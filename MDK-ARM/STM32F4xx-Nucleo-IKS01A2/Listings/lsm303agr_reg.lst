L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr\lsm303agr_reg.c"
N/*
N  ******************************************************************************
N  * @file    lsm303agr_reg.c
N  * @author  Sensor Solutions Software Team
N  * @brief   LSM303AGR driver file
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2019 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without
N  * modification, are permitted provided that the following conditions
N  * are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright
N  *      notice, this list of conditions and the following disclaimer in the
N  *      documentation and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its
N  *      contributors may be used to endorse or promote products derived from
N  *      this software without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N  * POSSIBILITY OF SUCH DAMAGE.
N  *
N  */
N
N#include "lsm303agr_reg.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr\lsm303agr_reg.h" 1
N/*
N ******************************************************************************
N * @file    lsm303agr_reg.h
N * @author  Sensors Software Solution Team
N * @brief   This file contains all the functions prototypes for the
N *          lsm303agr_reg.c driver.
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright
N *      notice, this list of conditions and the following disclaimer in the
N *      documentation and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its
N *      contributors may be used to endorse or promote products derived from
N *      this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef LSM303AGR_REGS_H
N#define LSM303AGR_REGS_H
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 47 "..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr\lsm303agr_reg.h" 2
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
N#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 1L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 48 "..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr\lsm303agr_reg.h" 2
N
N/** @addtogroup LSM303AGR
N  * @{
N  *
N  */
N
N/** @defgroup LSM303AGR_sensors_common_types
N  * @{
N  *
N  */
N
N#ifndef MEMS_SHARED_TYPES
N#define MEMS_SHARED_TYPES
N
N/**
N  * @defgroup axisXbitXX_t
N  * @brief    These unions are useful to represent different sensors data type.
N  *           These unions are not need by the driver.
N  *
N  *           REMOVING the unions you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
N
Ntypedef union{
N  int16_t i16bit[3];
N  uint8_t u8bit[6];
N} axis3bit16_t;
N
Ntypedef union{
N  int16_t i16bit;
N  uint8_t u8bit[2];
N} axis1bit16_t;
N
Ntypedef union{
N  int32_t i32bit[3];
N  uint8_t u8bit[12];
N} axis3bit32_t;
N
Ntypedef union{
N  int32_t i32bit;
N  uint8_t u8bit[4];
N} axis1bit32_t;
N
N/**
N  * @}
N  *
N  */
N
Ntypedef struct{
N  uint8_t bit0       : 1;
N  uint8_t bit1       : 1;
N  uint8_t bit2       : 1;
N  uint8_t bit3       : 1;
N  uint8_t bit4       : 1;
N  uint8_t bit5       : 1;
N  uint8_t bit6       : 1;
N  uint8_t bit7       : 1;
N} bitwise_t;
N
N#define PROPERTY_DISABLE                (0U)
N#define PROPERTY_ENABLE                 (1U)
N
N#endif /* MEMS_SHARED_TYPES */
N
N/**
N  * @}
N  *
N  */
N
N  /** @addtogroup  LSM303AGR_Interfaces_Functions
N  * @brief       This section provide a set of functions used to read and
N  *              write a generic register of the device.
N  *              MANDATORY: return 0 -> no Error.
N  * @{
N  *
N  */
N
Ntypedef int32_t (*lsm303agr_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);
Ntypedef int32_t (*lsm303agr_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);
N
Ntypedef struct {
N  /** Component mandatory fields **/
N  lsm303agr_write_ptr  write_reg;
N  lsm303agr_read_ptr   read_reg;
N  /** Customizable optional pointer **/
N  void *handle;
N} lsm303agr_ctx_t;
N
N/**
N  * @}
N  *
N  */
N
N/** @defgroup lsm303agr_Infos
N  * @{
N  *
N  */
N
N  /** I2C Device Address 8 bit format**/
N#define LSM303AGR_I2C_ADD_XL       0x33U
N#define LSM303AGR_I2C_ADD_MG       0x3DU
N
N/** Device Identification (Who am I) **/
N#define LSM303AGR_ID_XL            0x33U
N#define LSM303AGR_ID_MG            0x40U
N
N/**
N  * @}
N  *
N  */
N
N#define LSM303AGR_STATUS_REG_AUX_A           0x07U
Ntypedef struct {
N  uint8_t not_used_01            : 2;
N  uint8_t tda                    : 1;
N  uint8_t not_used_02            : 3;
N  uint8_t tor                    : 1;
N  uint8_t not_used_03            : 1;
N} lsm303agr_status_reg_aux_a_t;
N
N#define LSM303AGR_OUT_TEMP_L_A               0x0CU
N#define LSM303AGR_OUT_TEMP_H_A               0x0DU
N#define LSM303AGR_INT_COUNTER_REG_A          0x0EU
N#define LSM303AGR_WHO_AM_I_A                 0x0FU
N
N#define LSM303AGR_TEMP_CFG_REG_A             0x1FU
Ntypedef struct {
N  uint8_t not_used_01            : 6;
N  uint8_t temp_en                : 2;
N} lsm303agr_temp_cfg_reg_a_t;
N
N#define LSM303AGR_CTRL_REG1_A                0x20U
Ntypedef struct {
N  uint8_t xen                    : 1;
N  uint8_t yen                    : 1;
N  uint8_t zen                    : 1;
N  uint8_t lpen                   : 1;
N  uint8_t odr                    : 4;
N} lsm303agr_ctrl_reg1_a_t;
N
N#define LSM303AGR_CTRL_REG2_A                0x21U
Ntypedef struct {
N  uint8_t hp                     : 3; /* HPCLICK + HPIS2 + HPIS1 -> HP */
N  uint8_t fds                    : 1;
N  uint8_t hpcf                   : 2;
N  uint8_t hpm                    : 2;
N} lsm303agr_ctrl_reg2_a_t;
N
N#define LSM303AGR_CTRL_REG3_A                0x22U
Ntypedef struct {
N  uint8_t not_used_01            : 1;
N  uint8_t i1_overrun             : 1;
N  uint8_t i1_wtm                 : 1;
N  uint8_t i1_drdy2               : 1;
N  uint8_t i1_drdy1               : 1;
N  uint8_t i1_aoi2                : 1;
N  uint8_t i1_aoi1                : 1;
N  uint8_t i1_click               : 1;
N} lsm303agr_ctrl_reg3_a_t;
N
N#define LSM303AGR_CTRL_REG4_A                0x23U
Ntypedef struct {
N  uint8_t spi_enable             : 1;
N  uint8_t st                     : 2;
N  uint8_t hr                     : 1;
N  uint8_t fs                     : 2;
N  uint8_t ble                    : 1;
N  uint8_t bdu                    : 1;
N} lsm303agr_ctrl_reg4_a_t;
N
N#define LSM303AGR_CTRL_REG5_A                0x24U
Ntypedef struct {
N  uint8_t d4d_int2               : 1;
N  uint8_t lir_int2               : 1;
N  uint8_t d4d_int1               : 1;
N  uint8_t lir_int1               : 1;
N  uint8_t not_used_01            : 2;
N  uint8_t fifo_en                : 1;
N  uint8_t boot                   : 1;
N} lsm303agr_ctrl_reg5_a_t;
N
N#define LSM303AGR_CTRL_REG6_A               0x25U
Ntypedef struct {
N  uint8_t not_used_01            : 1;
N  uint8_t h_lactive              : 1;
N  uint8_t not_used_02            : 1;
N  uint8_t p2_act                 : 1;
N  uint8_t boot_i2                : 1;
N  uint8_t i2_int2                : 1;
N  uint8_t i2_int1                : 1;
N  uint8_t i2_clicken             : 1;
N} lsm303agr_ctrl_reg6_a_t;
N
N#define LSM303AGR_REFERENCE_A               0x26U
N#define LSM303AGR_STATUS_REG_A              0x27U
Ntypedef struct {
N  uint8_t xda                    : 1;
N  uint8_t yda                    : 1;
N  uint8_t zda                    : 1;
N  uint8_t zyxda                  : 1;
N  uint8_t _xor                   : 1;
N  uint8_t yor                    : 1;
N  uint8_t zor                    : 1;
N  uint8_t zyxor                  : 1;
N} lsm303agr_status_reg_a_t;
N
N#define LSM303AGR_OUT_X_L_A                 0x28U
N#define LSM303AGR_OUT_X_H_A                 0x29U
N#define LSM303AGR_OUT_Y_L_A                 0x2AU
N#define LSM303AGR_OUT_Y_H_A                 0x2BU
N#define LSM303AGR_OUT_Z_L_A                 0x2CU
N#define LSM303AGR_OUT_Z_H_A                 0x2DU
N#define LSM303AGR_FIFO_CTRL_REG_A           0x2EU
Ntypedef struct {
N  uint8_t fth                    : 5;
N  uint8_t tr                     : 1;
N  uint8_t fm                     : 2;
N} lsm303agr_fifo_ctrl_reg_a_t;
N
N#define LSM303AGR_FIFO_SRC_REG_A            0x2FU
Ntypedef struct {
N  uint8_t fss                    : 5;
N  uint8_t empty                  : 1;
N  uint8_t ovrn_fifo              : 1;
N  uint8_t wtm                    : 1;
N} lsm303agr_fifo_src_reg_a_t;
N
N#define LSM303AGR_INT1_CFG_A                0x30U
Ntypedef struct {
N  uint8_t xlie                   : 1; /* or XDOWNE */
N  uint8_t xhie                   : 1; /* or XUPE */
N  uint8_t ylie                   : 1; /* or YDOWNE */
N  uint8_t yhie                   : 1; /* or YUPE */
N  uint8_t zlie                   : 1; /* or ZDOWNE */
N  uint8_t zhie                   : 1; /* or ZUPE */
N  uint8_t _6d                    : 1;
N  uint8_t aoi                    : 1;
N} lsm303agr_int1_cfg_a_t;
N
N#define LSM303AGR_INT1_SRC_A                0x31U
Ntypedef struct {
N  uint8_t xl                     : 1;
N  uint8_t xh                     : 1;
N  uint8_t yl                     : 1;
N  uint8_t yh                     : 1;
N  uint8_t zl                     : 1;
N  uint8_t zh                     : 1;
N  uint8_t ia                     : 1;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int1_src_a_t;
N
N#define LSM303AGR_INT1_THS_A                0x32U
Ntypedef struct {
N  uint8_t ths                    : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int1_ths_a_t;
N
N#define LSM303AGR_INT1_DURATION_A           0x33U
Ntypedef struct {
N  uint8_t d                      : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int1_duration_a_t;
N
N#define LSM303AGR_INT2_CFG_A                0x34U
Ntypedef struct {
N  uint8_t xlie                   : 1;
N  uint8_t xhie                   : 1;
N  uint8_t ylie                   : 1;
N  uint8_t yhie                   : 1;
N  uint8_t zlie                   : 1;
N  uint8_t zhie                   : 1;
N  uint8_t _6d                    : 1;
N  uint8_t aoi                    : 1;
N} lsm303agr_int2_cfg_a_t;
N
N#define LSM303AGR_INT2_SRC_A                0x35U
Ntypedef struct {
N  uint8_t xl                     : 1;
N  uint8_t xh                     : 1;
N  uint8_t yl                     : 1;
N  uint8_t yh                     : 1;
N  uint8_t zl                     : 1;
N  uint8_t zh                     : 1;
N  uint8_t ia                     : 1;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int2_src_a_t;
N
N#define LSM303AGR_INT2_THS_A                0x36U
Ntypedef struct {
N  uint8_t ths                    : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int2_ths_a_t;
N
N#define LSM303AGR_INT2_DURATION_A           0x37U
Ntypedef struct {
N  uint8_t d                      : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int2_duration_a_t;
N
N#define LSM303AGR_CLICK_CFG_A               0x38U
Ntypedef struct {
N  uint8_t xs                     : 1;
N  uint8_t xd                     : 1;
N  uint8_t ys                     : 1;
N  uint8_t yd                     : 1;
N  uint8_t zs                     : 1;
N  uint8_t zd                     : 1;
N  uint8_t not_used_01            : 2;
N} lsm303agr_click_cfg_a_t;
N
N#define LSM303AGR_CLICK_SRC_A               0x39U
Ntypedef struct {
N  uint8_t x                      : 1;
N  uint8_t y                      : 1;
N  uint8_t z                      : 1;
N  uint8_t sign                   : 1;
N  uint8_t sclick                 : 1;
N  uint8_t dclick                 : 1;
N  uint8_t ia                     : 1;
N  uint8_t not_used_01            : 1;
N} lsm303agr_click_src_a_t;
N
N#define LSM303AGR_CLICK_THS_A               0x3AU
Ntypedef struct {
N  uint8_t ths                    : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_click_ths_a_t;
N
N#define LSM303AGR_TIME_LIMIT_A              0x3BU
Ntypedef struct {
N  uint8_t tli                    : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_time_limit_a_t;
N
N#define LSM303AGR_TIME_LATENCY_A            0x3CU
Ntypedef struct {
N  uint8_t tla                    : 8;
N} lsm303agr_time_latency_a_t;
N
N#define LSM303AGR_TIME_WINDOW_A             0x3DU
Ntypedef struct {
N  uint8_t tw                     : 8;
N} lsm303agr_time_window_a_t;
N
N#define LSM303AGR_ACT_THS_A                 0x3EU
Ntypedef struct {
N  uint8_t acth                   : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_act_ths_a_t;
N
N#define LSM303AGR_ACT_DUR_A                 0x3FU
Ntypedef struct {
N  uint8_t actd                   : 8;
N} lsm303agr_act_dur_a_t;
N
N#define LSM303AGR_OFFSET_X_REG_L_M          0x45U
N#define LSM303AGR_OFFSET_X_REG_H_M          0x46U
N#define LSM303AGR_OFFSET_Y_REG_L_M          0x47U
N#define LSM303AGR_OFFSET_Y_REG_H_M          0x48U
N#define LSM303AGR_OFFSET_Z_REG_L_M          0x49U
N#define LSM303AGR_OFFSET_Z_REG_H_M          0x4AU
N#define LSM303AGR_WHO_AM_I_M                0x4FU
N#define LSM303AGR_CFG_REG_A_M               0x60U
Ntypedef struct {
N  uint8_t md                     : 2;
N  uint8_t odr                    : 2;
N  uint8_t lp                     : 1;
N  uint8_t soft_rst               : 1;
N  uint8_t reboot                 : 1;
N  uint8_t comp_temp_en           : 1;
N} lsm303agr_cfg_reg_a_m_t;
N
N#define LSM303AGR_CFG_REG_B_M               0x61U
Ntypedef struct {
N  uint8_t lpf                    : 1;
N  uint8_t set_rst                : 2; /* OFF_CANC + Set_FREQ */
N  uint8_t int_on_dataoff         : 1;
N  uint8_t off_canc_one_shot      : 1;
N  uint8_t not_used_01            : 3;
N} lsm303agr_cfg_reg_b_m_t;
N
N#define LSM303AGR_CFG_REG_C_M               0x62U
Ntypedef struct {
N  uint8_t int_mag                : 1;
N  uint8_t self_test              : 1;
N  uint8_t not_used_01            : 1;
N  uint8_t ble                    : 1;
N  uint8_t bdu                    : 1;
N  uint8_t i2c_dis                : 1;
N  uint8_t int_mag_pin            : 1;
N  uint8_t not_used_02            : 1;
N} lsm303agr_cfg_reg_c_m_t;
N
N#define LSM303AGR_INT_CRTL_REG_M            0x63U
Ntypedef struct {
N  uint8_t ien                    : 1;
N  uint8_t iel                    : 1;
N  uint8_t iea                    : 1;
N  uint8_t not_used_01            : 2;
N  uint8_t zien                   : 1;
N  uint8_t yien                   : 1;
N  uint8_t xien                   : 1;
N} lsm303agr_int_crtl_reg_m_t;
N
N#define LSM303AGR_INT_SOURCE_REG_M          0x64U
Ntypedef struct {
N  uint8_t _int                    : 1;
N  uint8_t mroi                   : 1;
N  uint8_t n_th_s_z               : 1;
N  uint8_t n_th_s_y               : 1;
N  uint8_t n_th_s_x               : 1;
N  uint8_t p_th_s_z               : 1;
N  uint8_t p_th_s_y               : 1;
N  uint8_t p_th_s_x               : 1;
N} lsm303agr_int_source_reg_m_t;
N
N#define LSM303AGR_INT_THS_L_REG_M           0x65U
N#define LSM303AGR_INT_THS_H_REG_M           0x66U
N#define LSM303AGR_STATUS_REG_M              0x67U
Ntypedef struct {
N  uint8_t xda                    : 1;
N  uint8_t yda                    : 1;
N  uint8_t zda                    : 1;
N  uint8_t zyxda                  : 1;
N  uint8_t _xor                   : 1;
N  uint8_t yor                    : 1;
N  uint8_t zor                    : 1;
N  uint8_t zyxor                  : 1;
N} lsm303agr_status_reg_m_t;
N
N#define LSM303AGR_OUTX_L_REG_M              0x68U
N#define LSM303AGR_OUTX_H_REG_M              0x69U
N#define LSM303AGR_OUTY_L_REG_M              0x6AU
N#define LSM303AGR_OUTY_H_REG_M              0x6BU
N#define LSM303AGR_OUTZ_L_REG_M              0x6CU
N#define LSM303AGR_OUTZ_H_REG_M              0x6DU
N
N/**
N  * @defgroup LSM303AGR_Register_Union
N  * @brief    This union group all the registers that has a bit-field
N  *           description.
N  *           This union is useful but not need by the driver.
N  *
N  *           REMOVING this union you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
Ntypedef union{
N  lsm303agr_status_reg_aux_a_t       status_reg_aux_a;
N  lsm303agr_temp_cfg_reg_a_t         temp_cfg_reg_a;
N  lsm303agr_ctrl_reg1_a_t            ctrl_reg1_a;
N  lsm303agr_ctrl_reg2_a_t            ctrl_reg2_a;
N  lsm303agr_ctrl_reg3_a_t            ctrl_reg3_a;
N  lsm303agr_ctrl_reg4_a_t            ctrl_reg4_a;
N  lsm303agr_ctrl_reg5_a_t            ctrl_reg5_a;
N  lsm303agr_ctrl_reg6_a_t            ctrl_reg6_a;
N  lsm303agr_status_reg_a_t           status_reg_a;
N  lsm303agr_fifo_ctrl_reg_a_t        fifo_ctrl_reg_a;
N  lsm303agr_fifo_src_reg_a_t         fifo_src_reg_a;
N  lsm303agr_int1_cfg_a_t             int1_cfg_a;
N  lsm303agr_int1_src_a_t             int1_src_a;
N  lsm303agr_int1_ths_a_t             int1_ths_a;
N  lsm303agr_int1_duration_a_t        int1_duration_a;
N  lsm303agr_int2_cfg_a_t             int2_cfg_a;
N  lsm303agr_int2_src_a_t             int2_src_a;
N  lsm303agr_int2_ths_a_t             int2_ths_a;
N  lsm303agr_int2_duration_a_t        int2_duration_a;
N  lsm303agr_click_cfg_a_t            click_cfg_a;
N  lsm303agr_click_src_a_t            click_src_a;
N  lsm303agr_click_ths_a_t            click_ths_a;
N  lsm303agr_time_limit_a_t           time_limit_a;
N  lsm303agr_time_latency_a_t         time_latency_a;
N  lsm303agr_time_window_a_t          time_window_a;
N  lsm303agr_act_ths_a_t              act_ths_a;
N  lsm303agr_act_dur_a_t              act_dur_a;
N  lsm303agr_cfg_reg_a_m_t            cfg_reg_a_m;
N  lsm303agr_cfg_reg_b_m_t            cfg_reg_b_m;
N  lsm303agr_cfg_reg_c_m_t            cfg_reg_c_m;
N  lsm303agr_int_crtl_reg_m_t         int_crtl_reg_m;
N  lsm303agr_int_source_reg_m_t       int_source_reg_m;
N  lsm303agr_status_reg_m_t           status_reg_m;
N  bitwise_t                          bitwise;
N  uint8_t                            byte;
N} lsm303agr_reg_t;
N
N/**
N  * @}
N  *
N  */
N
Nint32_t lsm303agr_read_reg(lsm303agr_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                           uint16_t len);
Nint32_t lsm303agr_write_reg(lsm303agr_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                           uint16_t len);
N
Nextern float_t lsm303agr_from_fs_2g_hr_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_4g_hr_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_8g_hr_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_16g_hr_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_lsb_hr_to_celsius(int16_t lsb);
N
Nextern float_t lsm303agr_from_fs_2g_nm_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_4g_nm_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_8g_nm_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_16g_nm_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_lsb_nm_to_celsius(int16_t lsb);
N
Nextern float_t lsm303agr_from_fs_2g_lp_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_4g_lp_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_8g_lp_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_16g_lp_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_lsb_lp_to_celsius(int16_t lsb);
N
Nextern float_t lsm303agr_from_lsb_to_mgauss(int16_t lsb);
N
Nint32_t lsm303agr_temp_status_reg_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm303agr_temp_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_temp_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_temperature_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Ntypedef enum {
N  LSM303AGR_TEMP_DISABLE  = 0,
N  LSM303AGR_TEMP_ENABLE   = 3,
N} lsm303agr_temp_en_a_t;
Nint32_t lsm303agr_temperature_meas_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_temp_en_a_t val);
Nint32_t lsm303agr_temperature_meas_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_temp_en_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_HR_12bit   = 0,
N  LSM303AGR_NM_10bit   = 1,
N  LSM303AGR_LP_8bit    = 2,
N} lsm303agr_op_md_a_t;
Nint32_t lsm303agr_xl_operating_mode_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_op_md_a_t val);
Nint32_t lsm303agr_xl_operating_mode_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_op_md_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_XL_POWER_DOWN                      = 0,
N  LSM303AGR_XL_ODR_1Hz                         = 1,
N  LSM303AGR_XL_ODR_10Hz                        = 2,
N  LSM303AGR_XL_ODR_25Hz                        = 3,
N  LSM303AGR_XL_ODR_50Hz                        = 4,
N  LSM303AGR_XL_ODR_100Hz                       = 5,
N  LSM303AGR_XL_ODR_200Hz                       = 6,
N  LSM303AGR_XL_ODR_400Hz                       = 7,
N  LSM303AGR_XL_ODR_1kHz620_LP                  = 8,
N  LSM303AGR_XL_ODR_1kHz344_NM_HP_5kHz376_LP    = 9,
N} lsm303agr_odr_a_t;
Nint32_t lsm303agr_xl_data_rate_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_odr_a_t val);
Nint32_t lsm303agr_xl_data_rate_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_odr_a_t *val);
N
Nint32_t lsm303agr_xl_high_pass_on_outputs_set(lsm303agr_ctx_t *ctx,
N                                              uint8_t val);
Nint32_t lsm303agr_xl_high_pass_on_outputs_get(lsm303agr_ctx_t *ctx,
N                                              uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_AGGRESSIVE  = 0,
N  LSM303AGR_STRONG      = 1,
N  LSM303AGR_MEDIUM      = 2,
N  LSM303AGR_LIGHT       = 3,
N} lsm303agr_hpcf_a_t;
Nint32_t lsm303agr_xl_high_pass_bandwidth_set(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_hpcf_a_t val);
Nint32_t lsm303agr_xl_high_pass_bandwidth_get(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_hpcf_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_NORMAL_WITH_RST  = 0,
N  LSM303AGR_REFERENCE_MODE   = 1,
N  LSM303AGR_NORMAL           = 2,
N  LSM303AGR_AUTORST_ON_INT   = 3,
N} lsm303agr_hpm_a_t;
Nint32_t lsm303agr_xl_high_pass_mode_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_hpm_a_t val);
Nint32_t lsm303agr_xl_high_pass_mode_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_hpm_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_2g   = 0,
N  LSM303AGR_4g   = 1,
N  LSM303AGR_8g   = 2,
N  LSM303AGR_16g  = 3,
N} lsm303agr_fs_a_t;
Nint32_t lsm303agr_xl_full_scale_set(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_fs_a_t val);
Nint32_t lsm303agr_xl_full_scale_get(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_fs_a_t *val);
N
Nint32_t lsm303agr_xl_block_data_update_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val);
Nint32_t lsm303agr_xl_block_data_update_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val);
N
Nint32_t lsm303agr_xl_filter_reference_set(lsm303agr_ctx_t *ctx,
N                                          uint8_t *buff);
Nint32_t lsm303agr_xl_filter_reference_get(lsm303agr_ctx_t *ctx,
N                                          uint8_t *buff);
N
Nint32_t lsm303agr_xl_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_acceleration_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm303agr_xl_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Ntypedef enum {
N  LSM303AGR_ST_DISABLE   = 0,
N  LSM303AGR_ST_POSITIVE  = 1,
N  LSM303AGR_ST_NEGATIVE  = 2,
N} lsm303agr_st_a_t;
Nint32_t lsm303agr_xl_self_test_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_st_a_t val);
Nint32_t lsm303agr_xl_self_test_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_st_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_XL_LSB_AT_LOW_ADD = 0,
N  LSM303AGR_XL_MSB_AT_LOW_ADD = 1,
N} lsm303agr_ble_a_t;
Nint32_t lsm303agr_xl_data_format_set(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_ble_a_t val);
Nint32_t lsm303agr_xl_data_format_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_ble_a_t *val);
N
Nint32_t lsm303agr_xl_boot_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_xl_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_status_get(lsm303agr_ctx_t *ctx,
N                                lsm303agr_status_reg_a_t *val);
N
Nint32_t lsm303agr_xl_int1_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int1_cfg_a_t *val);
Nint32_t lsm303agr_xl_int1_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int1_cfg_a_t *val);
N
Nint32_t lsm303agr_xl_int1_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int1_src_a_t *val);
N
Nint32_t lsm303agr_xl_int1_gen_threshold_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_xl_int1_gen_threshold_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Nint32_t lsm303agr_xl_int1_gen_duration_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val);
Nint32_t lsm303agr_xl_int1_gen_duration_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val);
N
Nint32_t lsm303agr_xl_int2_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int2_cfg_a_t *val);
Nint32_t lsm303agr_xl_int2_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int2_cfg_a_t *val);
N
Nint32_t lsm303agr_xl_int2_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int2_src_a_t *val);
N
Nint32_t lsm303agr_xl_int2_gen_threshold_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_xl_int2_gen_threshold_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Nint32_t lsm303agr_xl_int2_gen_duration_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val);
Nint32_t lsm303agr_xl_int2_gen_duration_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_DISC_FROM_INT_GENERATOR  = 0,
N  LSM303AGR_ON_INT1_GEN              = 1,
N  LSM303AGR_ON_INT2_GEN              = 2,
N  LSM303AGR_ON_TAP_GEN               = 4,
N  LSM303AGR_ON_INT1_INT2_GEN         = 3,
N  LSM303AGR_ON_INT1_TAP_GEN          = 5,
N  LSM303AGR_ON_INT2_TAP_GEN          = 6,
N  LSM303AGR_ON_INT1_INT2_TAP_GEN     = 7,
N} lsm303agr_hp_a_t;
Nint32_t lsm303agr_xl_high_pass_int_conf_set(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_hp_a_t val);
Nint32_t lsm303agr_xl_high_pass_int_conf_get(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_hp_a_t *val);
N
Nint32_t lsm303agr_xl_pin_int1_config_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg3_a_t *val);
Nint32_t lsm303agr_xl_pin_int1_config_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg3_a_t *val);
N
Nint32_t lsm303agr_xl_int2_pin_detect_4d_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_xl_int2_pin_detect_4d_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_INT2_PULSED   = 0,
N  LSM303AGR_INT2_LATCHED  = 1,
N} lsm303agr_lir_int2_a_t;
Nint32_t lsm303agr_xl_int2pin_notification_mode_set(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int2_a_t val);
Nint32_t lsm303agr_xl_int2pin_notification_mode_get(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int2_a_t *val);
N
Nint32_t lsm303agr_xl_int1_pin_detect_4d_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_xl_int1_pin_detect_4d_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_INT1_PULSED   = 0,
N  LSM303AGR_INT1_LATCHED  = 1,
N} lsm303agr_lir_int1_a_t;
Nint32_t lsm303agr_xl_int1pin_notification_mode_set(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int1_a_t val);
Nint32_t lsm303agr_xl_int1pin_notification_mode_get(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int1_a_t *val);
N
Nint32_t lsm303agr_xl_pin_int2_config_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg6_a_t *val);
Nint32_t lsm303agr_xl_pin_int2_config_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg6_a_t *val);
N
Nint32_t lsm303agr_xl_fifo_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_xl_fifo_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_fifo_watermark_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_xl_fifo_watermark_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_INT1_GEN = 0,
N  LSM303AGR_INT2_GEN = 1,
N} lsm303agr_tr_a_t;
Nint32_t lsm303agr_xl_fifo_trigger_event_set(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_tr_a_t val);
Nint32_t lsm303agr_xl_fifo_trigger_event_get(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_tr_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_BYPASS_MODE           = 0,
N  LSM303AGR_FIFO_MODE             = 1,
N  LSM303AGR_DYNAMIC_STREAM_MODE   = 2,
N  LSM303AGR_STREAM_TO_FIFO_MODE   = 3,
N} lsm303agr_fm_a_t;
Nint32_t lsm303agr_xl_fifo_mode_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_fm_a_t val);
Nint32_t lsm303agr_xl_fifo_mode_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_fm_a_t *val);
N
Nint32_t lsm303agr_xl_fifo_status_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_fifo_src_reg_a_t *val);
N
Nint32_t lsm303agr_xl_fifo_data_level_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_fifo_empty_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_fifo_ovr_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_fifo_fth_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_tap_conf_set(lsm303agr_ctx_t *ctx,
N                               lsm303agr_click_cfg_a_t *val);
Nint32_t lsm303agr_tap_conf_get(lsm303agr_ctx_t *ctx,
N                               lsm303agr_click_cfg_a_t *val);
N
Nint32_t lsm303agr_tap_source_get(lsm303agr_ctx_t *ctx,
N                                lsm303agr_click_src_a_t *val);
N
Nint32_t lsm303agr_tap_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_tap_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_shock_dur_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_shock_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_quiet_dur_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_quiet_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_double_tap_timeout_set(lsm303agr_ctx_t *ctx,
N                                         uint8_t val);
Nint32_t lsm303agr_double_tap_timeout_get(lsm303agr_ctx_t *ctx,
N                                         uint8_t *val);
N
Nint32_t lsm303agr_act_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_act_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_act_timeout_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_act_timeout_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_SPI_4_WIRE = 0,
N  LSM303AGR_SPI_3_WIRE = 1,
N} lsm303agr_sim_a_t;
Nint32_t lsm303agr_xl_spi_mode_set(lsm303agr_ctx_t *ctx,
N                                  lsm303agr_sim_a_t val);
Nint32_t lsm303agr_xl_spi_mode_get(lsm303agr_ctx_t *ctx,
N                                  lsm303agr_sim_a_t *val);
N
Nint32_t lsm303agr_mag_user_offset_set(lsm303agr_ctx_t *ctx,
N                                      uint8_t *buff);
Nint32_t lsm303agr_mag_user_offset_get(lsm303agr_ctx_t *ctx,
N                                      uint8_t *buff);
N
Ntypedef enum {
N  LSM303AGR_CONTINUOUS_MODE  = 0,
N  LSM303AGR_SINGLE_TRIGGER   = 1,
N  LSM303AGR_POWER_DOWN       = 2,
N} lsm303agr_md_m_t;
Nint32_t lsm303agr_mag_operating_mode_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_md_m_t val);
Nint32_t lsm303agr_mag_operating_mode_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_md_m_t *val);
N
Ntypedef enum {
N  LSM303AGR_MG_ODR_10Hz   = 0,
N  LSM303AGR_MG_ODR_20Hz   = 1,
N  LSM303AGR_MG_ODR_50Hz   = 2,
N  LSM303AGR_MG_ODR_100Hz  = 3,
N} lsm303agr_mg_odr_m_t;
Nint32_t lsm303agr_mag_data_rate_set(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_mg_odr_m_t val);
Nint32_t lsm303agr_mag_data_rate_get(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_mg_odr_m_t *val);
N
Ntypedef enum {
N  LSM303AGR_HIGH_RESOLUTION  = 0,
N  LSM303AGR_LOW_POWER        = 1,
N} lsm303agr_lp_m_t;
Nint32_t lsm303agr_mag_power_mode_set(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_lp_m_t val);
Nint32_t lsm303agr_mag_power_mode_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_lp_m_t *val);
N
Nint32_t lsm303agr_mag_offset_temp_comp_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val);
Nint32_t lsm303agr_mag_offset_temp_comp_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_ODR_DIV_2  = 0,
N  LSM303AGR_ODR_DIV_4  = 1,
N} lsm303agr_lpf_m_t;
Nint32_t lsm303agr_mag_low_pass_bandwidth_set(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_lpf_m_t val);
Nint32_t lsm303agr_mag_low_pass_bandwidth_get(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_lpf_m_t *val);
N
Ntypedef enum {
N  LSM303AGR_SET_SENS_ODR_DIV_63        = 0,
N  LSM303AGR_SENS_OFF_CANC_EVERY_ODR    = 1,
N  LSM303AGR_SET_SENS_ONLY_AT_POWER_ON  = 2,
N} lsm303agr_set_rst_m_t;
Nint32_t lsm303agr_mag_set_rst_mode_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_set_rst_m_t val);
Nint32_t lsm303agr_mag_set_rst_mode_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_set_rst_m_t *val);
N
Nint32_t lsm303agr_mag_set_rst_sensor_single_set(lsm303agr_ctx_t *ctx,
N                                                uint8_t val);
Nint32_t lsm303agr_mag_set_rst_sensor_single_get(lsm303agr_ctx_t *ctx,
N                                                uint8_t *val);
N
Nint32_t lsm303agr_mag_block_data_update_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_mag_block_data_update_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Nint32_t lsm303agr_mag_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_magnetic_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm303agr_mag_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm303agr_mag_reset_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_mag_reset_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_boot_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_mag_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_self_test_set(lsm303agr_ctx_t *ctx,
N                                    uint8_t val);
Nint32_t lsm303agr_mag_self_test_get(lsm303agr_ctx_t *ctx,
N                                    uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_MG_LSB_AT_LOW_ADD  = 0,
N  LSM303AGR_MG_MSB_AT_LOW_ADD  = 1,
N} lsm303agr_ble_m_t;
Nint32_t lsm303agr_mag_data_format_set(lsm303agr_ctx_t *ctx,
N                                      lsm303agr_ble_m_t val);
Nint32_t lsm303agr_mag_data_format_get(lsm303agr_ctx_t *ctx,
N                                      lsm303agr_ble_m_t *val);
N
Nint32_t lsm303agr_mag_status_get(lsm303agr_ctx_t *ctx,
N                                 lsm303agr_status_reg_m_t *val);
N
Ntypedef enum {
N  LSM303AGR_CHECK_BEFORE  = 0,
N  LSM303AGR_CHECK_AFTER   = 1,
N} lsm303agr_int_on_dataoff_m_t;
Nint32_t lsm303agr_mag_offset_int_conf_set(lsm303agr_ctx_t *ctx,
N                                          lsm303agr_int_on_dataoff_m_t val);
Nint32_t lsm303agr_mag_offset_int_conf_get(lsm303agr_ctx_t *ctx,
N                                          lsm303agr_int_on_dataoff_m_t *val);
N
Nint32_t lsm303agr_mag_drdy_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_mag_drdy_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_int_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_mag_int_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_int_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int_crtl_reg_m_t *val);
Nint32_t lsm303agr_mag_int_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int_crtl_reg_m_t *val);
N
Nint32_t lsm303agr_mag_int_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int_source_reg_m_t *val);
N
Nint32_t lsm303agr_mag_int_gen_treshold_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t *buff);
Nint32_t lsm303agr_mag_int_gen_treshold_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *buff);
Ntypedef enum {
N  LSM303AGR_I2C_ENABLE   = 0,
N  LSM303AGR_I2C_DISABLE  = 1,
N} lsm303agr_i2c_dis_m_t;
Nint32_t lsm303agr_mag_i2c_interface_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_i2c_dis_m_t val);
Nint32_t lsm303agr_mag_i2c_interface_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_i2c_dis_m_t *val);
N
N/**
N  * @}
N  *
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LSM303AGR_REGS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 38 "..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr\lsm303agr_reg.c" 2
N
N/**
N  * @defgroup  LSM303AGR
N  * @brief     This file provides a set of functions needed to drive the
N  *            lsm303agr enhanced inertial module.
N  * @{
N  *
N  */
N
N/**
N  * @defgroup  LSM303AGR_Interfaces_Functions
N  * @brief     This section provide a set of functions used to read and
N  *            write a generic register of the device.
N  *            MANDATORY: return 0 -> no Error.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Read generic device register
N  *
N  * @param  ctx   read / write interface definitions(ptr)
N  * @param  reg   register to read
N  * @param  data  pointer to buffer that store the data read(ptr)
N  * @param  len   number of consecutive register to read
N  * @retval          interface status (MANDATORY: return 0 -> no Error)
N  *
N  */
Nint32_t lsm303agr_read_reg(lsm303agr_ctx_t* ctx, uint8_t reg, uint8_t* data,
N                         uint16_t len)
N{
N  int32_t ret;
N  ret = ctx->read_reg(ctx->handle, reg, data, len);
N  return ret;
N}
N
N/**
N  * @brief  Write generic device register
N  *
N  * @param  ctx   read / write interface definitions(ptr)
N  * @param  reg   register to write
N  * @param  data  pointer to data to write in register reg(ptr)
N  * @param  len   number of consecutive register to write
N  * @retval          interface status (MANDATORY: return 0 -> no Error)
N  *
N  */
Nint32_t lsm303agr_write_reg(lsm303agr_ctx_t* ctx, uint8_t reg, uint8_t* data,
N                          uint16_t len)
N{
N  int32_t ret;
N  ret = ctx->write_reg(ctx->handle, reg, data, len);
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM303AGR_Sensitivity
N  * @brief       These functions convert raw-data into engineering units.
N  * @{
N  *
N  */
N
Nfloat_t lsm303agr_from_fs_2g_hr_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 16.0f ) * 0.98f;
N}
N
Nfloat_t lsm303agr_from_fs_4g_hr_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 16.0f ) * 1.95f;
N}
N
Nfloat_t lsm303agr_from_fs_8g_hr_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 16.0f ) * 3.9f;
N}
N
Nfloat_t lsm303agr_from_fs_16g_hr_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 16.0f ) * 11.72f;
N}
N
Nfloat_t lsm303agr_from_lsb_hr_to_celsius(int16_t lsb)
N{
N  return ( ( (float_t)lsb / 64.0f ) / 4.0f ) + 25.0f;
N}
N
Nfloat_t lsm303agr_from_fs_2g_nm_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 64.0f ) * 3.9f;
N}
N
Nfloat_t lsm303agr_from_fs_4g_nm_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 64.0f ) * 7.82f;
N}
N
Nfloat_t lsm303agr_from_fs_8g_nm_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 64.0f ) * 15.63f;
N}
N
Nfloat_t lsm303agr_from_fs_16g_nm_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 64.0f ) * 46.9f;
N}
N
Nfloat_t lsm303agr_from_lsb_nm_to_celsius(int16_t lsb)
N{
N  return ( ( (float_t)lsb / 64.0f ) / 4.0f ) + 25.0f;
N}
N
Nfloat_t lsm303agr_from_fs_2g_lp_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 256.0f ) * 15.63f;
N}
N
Nfloat_t lsm303agr_from_fs_4g_lp_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 256.0f ) * 31.26f;
N}
N
Nfloat_t lsm303agr_from_fs_8g_lp_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 256.0f ) * 62.52f;
N}
N
Nfloat_t lsm303agr_from_fs_16g_lp_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb / 256.0f ) * 187.58f;
N}
N
Nfloat_t lsm303agr_from_lsb_lp_to_celsius(int16_t lsb)
N{
N  return ( ( (float_t)lsb / 256.0f ) * 1.0f ) + 25.0f;
N}
N
Nfloat_t lsm303agr_from_lsb_to_mgauss(int16_t lsb)
N{
N  return (float_t)lsb * 1.5f;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup   LSM303AGR_Data_generation
N  * @brief      This section group all the functions concerning data generation
N  * @{
N  *
N  */
N
N/**
N  * @brief  Temperature status register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores the data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_temp_status_reg_get(lsm303agr_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_AUX_A, buff, 1);
X  ret = lsm303agr_read_reg(ctx, 0x07U, buff, 1);
N  return ret;
N}
N
N/**
N  * @brief  Temperature data available.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of tda in reg STATUS_REG_AUX_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_temp_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_status_reg_aux_a_t status_reg_aux_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_AUX_A,
X  ret = lsm303agr_read_reg(ctx, 0x07U,
N                           (uint8_t*)&status_reg_aux_a, 1);
N  *val = status_reg_aux_a.tda;
N
N  return ret;
N}
N
N/**
N  * @brief  Temperature data overrun.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of tor in reg STATUS_REG_AUX_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_temp_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_status_reg_aux_a_t status_reg_aux_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_AUX_A,
X  ret = lsm303agr_read_reg(ctx, 0x07U,
N                           (uint8_t*)&status_reg_aux_a, 1);
N  *val = status_reg_aux_a.tor;
N
N  return ret;
N}
N
N/**
N  * @brief  Temperature output value.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores the data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_temperature_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_OUT_TEMP_L_A, buff, 2);
X  ret = lsm303agr_read_reg(ctx, 0x0CU, buff, 2);
N  return ret;
N}
N
N/**
N  * @brief  Temperature sensor enable.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of temp_en in reg TEMP_CFG_REG_A.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_temperature_meas_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_temp_en_a_t val)
N{
N  lsm303agr_temp_cfg_reg_a_t temp_cfg_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_TEMP_CFG_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x1FU,
N                           (uint8_t*)&temp_cfg_reg_a, 1);
N  if(ret == 0){
N    temp_cfg_reg_a.temp_en = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_TEMP_CFG_REG_A,
X    ret = lsm303agr_write_reg(ctx, 0x1FU,
N                              (uint8_t*)&temp_cfg_reg_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Temperature sensor enable.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of temp_en in reg TEMP_CFG_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_temperature_meas_get(lsm303agr_ctx_t *ctx,
N                                      lsm303agr_temp_en_a_t *val)
N{
N  lsm303agr_temp_cfg_reg_a_t temp_cfg_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_TEMP_CFG_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x1FU,
N                           (uint8_t*)&temp_cfg_reg_a, 1);
N  switch (temp_cfg_reg_a.temp_en){
N    case LSM303AGR_TEMP_DISABLE:
N      *val = LSM303AGR_TEMP_DISABLE;
N      break;
N    case LSM303AGR_TEMP_ENABLE:
N      *val = LSM303AGR_TEMP_ENABLE;
N      break;
N    default:
N      *val = LSM303AGR_TEMP_DISABLE;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Operating mode selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of lpen in reg
N  *                CTRL_REG1_A and HR in reg CTRL_REG4_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_operating_mode_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_op_md_a_t val)
N{
N  lsm303agr_ctrl_reg1_a_t ctrl_reg1_a;
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N  uint8_t lpen, hr;
N
N  if ( val == LSM303AGR_HR_12bit ){
N    lpen = 0;
N    hr   = 1;
N  } else if (val == LSM303AGR_NM_10bit) {
N    lpen = 0;
N    hr   = 0;
N  } else {
N    lpen = 1;
N    hr   = 0;
N  }
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG1_A,
X  ret = lsm303agr_read_reg(ctx, 0x20U,
N                           (uint8_t*)&ctrl_reg1_a, 1);
N  ctrl_reg1_a.lpen = (uint8_t)lpen;
N  if(ret == 0){
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG1_A,
X    ret = lsm303agr_write_reg(ctx, 0x20U,
N                              (uint8_t*)&ctrl_reg1_a, 1);
N  }
N  if(ret == 0){
N    ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X    ret = lsm303agr_read_reg(ctx, 0x23U,
N                             (uint8_t*)&ctrl_reg4_a, 1);
N  }
N  if(ret == 0){
N    ctrl_reg4_a.hr = hr;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A,
X    ret = lsm303agr_write_reg(ctx, 0x23U,
N                              (uint8_t*)&ctrl_reg4_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Operating mode selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of lpen in reg CTRL_REG1_A and HR in
N  *                reg CTRL_REG4_AG1_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_operating_mode_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_op_md_a_t *val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  lsm303agr_ctrl_reg1_a_t ctrl_reg1_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG1_A,
X  ret = lsm303agr_read_reg(ctx, 0x20U,
N                           (uint8_t*)&ctrl_reg1_a, 1);
N  if(ret == 0){
N    ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X    ret = lsm303agr_read_reg(ctx, 0x23U,
N                             (uint8_t*)&ctrl_reg4_a, 1);
N  }
N
N  if ( ctrl_reg1_a.lpen != PROPERTY_DISABLE ){
X  if ( ctrl_reg1_a.lpen != (0U) ){
N    *val = LSM303AGR_LP_8bit;
N  } else if (ctrl_reg4_a.hr  != PROPERTY_DISABLE ) {
X  } else if (ctrl_reg4_a.hr  != (0U) ) {
N    *val = LSM303AGR_HR_12bit;
N  } else{
N    *val = LSM303AGR_NM_10bit;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Output data rate selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of odr in reg CTRL_REG1_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_data_rate_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_odr_a_t val)
N{
N  lsm303agr_ctrl_reg1_a_t ctrl_reg1_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG1_A,
X  ret = lsm303agr_read_reg(ctx, 0x20U,
N                           (uint8_t*)&ctrl_reg1_a, 1);
N  if(ret == 0){
N    ctrl_reg1_a.odr = (uint8_t)val;
N   ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG1_A,
X   ret = lsm303agr_write_reg(ctx, 0x20U,
N                             (uint8_t*)&ctrl_reg1_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Output data rate selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of odr in reg CTRL_REG1_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_data_rate_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_odr_a_t *val)
N{
N  lsm303agr_ctrl_reg1_a_t ctrl_reg1_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG1_A,
X  ret = lsm303agr_read_reg(ctx, 0x20U,
N                           (uint8_t*)&ctrl_reg1_a, 1);
N
N  switch (ctrl_reg1_a.odr){
N    case LSM303AGR_XL_POWER_DOWN:
N      *val = LSM303AGR_XL_POWER_DOWN;
N      break;
N    case LSM303AGR_XL_ODR_1Hz:
N      *val = LSM303AGR_XL_ODR_1Hz;
N      break;
N    case LSM303AGR_XL_ODR_10Hz:
N      *val = LSM303AGR_XL_ODR_10Hz;
N      break;
N    case LSM303AGR_XL_ODR_25Hz:
N      *val = LSM303AGR_XL_ODR_25Hz;
N      break;
N    case LSM303AGR_XL_ODR_50Hz:
N      *val = LSM303AGR_XL_ODR_50Hz;
N      break;
N    case LSM303AGR_XL_ODR_100Hz:
N      *val = LSM303AGR_XL_ODR_100Hz;
N      break;
N    case LSM303AGR_XL_ODR_200Hz:
N      *val = LSM303AGR_XL_ODR_200Hz;
N      break;
N    case LSM303AGR_XL_ODR_400Hz:
N      *val = LSM303AGR_XL_ODR_400Hz;
N      break;
N    case LSM303AGR_XL_ODR_1kHz620_LP:
N      *val = LSM303AGR_XL_ODR_1kHz620_LP;
N      break;
N    case LSM303AGR_XL_ODR_1kHz344_NM_HP_5kHz376_LP:
N      *val = LSM303AGR_XL_ODR_1kHz344_NM_HP_5kHz376_LP;
N      break;
N    default:
N      *val = LSM303AGR_XL_POWER_DOWN;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief   High pass data from internal filter sent to output register and FIFO.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of fds in reg CTRL_REG2_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_high_pass_on_outputs_set(lsm303agr_ctx_t *ctx,
N                                              uint8_t val)
N{
N  lsm303agr_ctrl_reg2_a_t ctrl_reg2_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A,
X  ret = lsm303agr_read_reg(ctx, 0x21U,
N                           (uint8_t*)&ctrl_reg2_a, 1);
N  if(ret == 0){
N    ctrl_reg2_a.fds = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG2_A,
X    ret = lsm303agr_write_reg(ctx, 0x21U,
N                              (uint8_t*)&ctrl_reg2_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  High pass data from internal filter sent to output
N  *         register and FIFO.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of fds in reg CTRL_REG2_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_high_pass_on_outputs_get(lsm303agr_ctx_t *ctx,
N                                              uint8_t *val)
N{
N  lsm303agr_ctrl_reg2_a_t ctrl_reg2_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A,
X  ret = lsm303agr_read_reg(ctx, 0x21U,
N                           (uint8_t*)&ctrl_reg2_a, 1);
N  *val = ctrl_reg2_a.fds;
N
N  return ret;
N}
N
N/**
N  * @brief  High-pass filter cutoff frequency selection.[set]
N  *
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of hpcf in reg CTRL_REG2_A
N  *
N  * HPCF[2:1]\ft @1Hz    @10Hz  @25Hz  @50Hz @100Hz @200Hz @400Hz @1kHz6 ft@5kHz
N  * AGGRESSIVE   0.02Hz  0.2Hz  0.5Hz  1Hz   2Hz    4Hz    8Hz    32Hz   100Hz
N  * STRONG       0.008Hz 0.08Hz 0.2Hz  0.5Hz 1Hz    2Hz    4Hz    16Hz   50Hz
N  * MEDIUM       0.004Hz 0.04Hz 0.1Hz  0.2Hz 0.5Hz  1Hz    2Hz    8Hz    25Hz
N  * LIGHT        0.002Hz 0.02Hz 0.05Hz 0.1Hz 0.2Hz  0.5Hz  1Hz    4Hz    12Hz
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_high_pass_bandwidth_set(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_hpcf_a_t val)
N{
N  lsm303agr_ctrl_reg2_a_t ctrl_reg2_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A,
X  ret = lsm303agr_read_reg(ctx, 0x21U,
N                           (uint8_t*)&ctrl_reg2_a, 1);
N  if(ret == 0){
N    ctrl_reg2_a.hpcf = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG2_A,
X    ret = lsm303agr_write_reg(ctx, 0x21U,
N                              (uint8_t*)&ctrl_reg2_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  High-pass filter cutoff frequency selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of hpcf in reg CTRL_REG2_A.(ptr)
N  *
N  * HPCF[2:1]\ft @1Hz    @10Hz  @25Hz  @50Hz @100Hz @200Hz @400Hz @1kHz6 ft@5kHz
N  * AGGRESSIVE   0.02Hz  0.2Hz  0.5Hz  1Hz   2Hz    4Hz    8Hz    32Hz   100Hz
N  * STRONG       0.008Hz 0.08Hz 0.2Hz  0.5Hz 1Hz    2Hz    4Hz    16Hz   50Hz
N  * MEDIUM       0.004Hz 0.04Hz 0.1Hz  0.2Hz 0.5Hz  1Hz    2Hz    8Hz    25Hz
N  * LIGHT        0.002Hz 0.02Hz 0.05Hz 0.1Hz 0.2Hz  0.5Hz  1Hz    4Hz    12Hz
N  *
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_high_pass_bandwidth_get(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_hpcf_a_t *val)
N{
N  lsm303agr_ctrl_reg2_a_t ctrl_reg2_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A,
X  ret = lsm303agr_read_reg(ctx, 0x21U,
N                           (uint8_t*)&ctrl_reg2_a, 1);
N
N  switch (ctrl_reg2_a.hpcf){
N    case LSM303AGR_AGGRESSIVE:
N      *val = LSM303AGR_AGGRESSIVE;
N      break;
N    case LSM303AGR_STRONG:
N      *val = LSM303AGR_STRONG;
N      break;
N    case LSM303AGR_MEDIUM:
N      *val = LSM303AGR_MEDIUM;
N      break;
N    case LSM303AGR_LIGHT:
N      *val = LSM303AGR_LIGHT;
N      break;
N    default:
N      *val = LSM303AGR_AGGRESSIVE;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  High-pass filter mode selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of hpm in reg CTRL_REG2_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_high_pass_mode_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_hpm_a_t val)
N{
N  lsm303agr_ctrl_reg2_a_t ctrl_reg2_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A,
X  ret = lsm303agr_read_reg(ctx, 0x21U,
N                           (uint8_t*)&ctrl_reg2_a, 1);
N  if(ret == 0){
N    ctrl_reg2_a.hpm = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG2_A,
X    ret = lsm303agr_write_reg(ctx, 0x21U,
N                              (uint8_t*)&ctrl_reg2_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  High-pass filter mode selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of hpm in reg CTRL_REG2_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_high_pass_mode_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_hpm_a_t *val)
N{
N  lsm303agr_ctrl_reg2_a_t ctrl_reg2_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A,
X  ret = lsm303agr_read_reg(ctx, 0x21U,
N                           (uint8_t*)&ctrl_reg2_a, 1);
N
N  switch (ctrl_reg2_a.hpm){
N    case LSM303AGR_NORMAL_WITH_RST:
N      *val = LSM303AGR_NORMAL_WITH_RST;
N      break;
N    case LSM303AGR_REFERENCE_MODE:
N      *val = LSM303AGR_REFERENCE_MODE;
N      break;
N    case LSM303AGR_NORMAL:
N      *val = LSM303AGR_NORMAL;
N      break;
N    case LSM303AGR_AUTORST_ON_INT:
N      *val = LSM303AGR_AUTORST_ON_INT;
N      break;
N    default:
N      *val = LSM303AGR_NORMAL_WITH_RST;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Full-scale configuration.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of fs in reg CTRL_REG4_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_full_scale_set(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_fs_a_t val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N  if(ret == 0){
N    ctrl_reg4_a.fs = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A,
X    ret = lsm303agr_write_reg(ctx, 0x23U,
N                              (uint8_t*)&ctrl_reg4_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Full-scale configuration.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of fs in reg CTRL_REG4_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_full_scale_get(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_fs_a_t *val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N
N  switch (ctrl_reg4_a.fs){
N    case LSM303AGR_2g:
N      *val = LSM303AGR_2g;
N      break;
N    case LSM303AGR_4g:
N      *val = LSM303AGR_4g;
N      break;
N    case LSM303AGR_8g:
N      *val = LSM303AGR_8g;
N      break;
N    case LSM303AGR_16g:
N      *val = LSM303AGR_16g;
N      break;
N    default:
N      *val = LSM303AGR_2g;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Block data update.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of bdu in reg CTRL_REG4_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_block_data_update_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N  if(ret == 0){
N    ctrl_reg4_a.bdu = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A,
X    ret = lsm303agr_write_reg(ctx, 0x23U,
N                              (uint8_t*)&ctrl_reg4_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Block data update.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of bdu in reg CTRL_REG4_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_block_data_update_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N  *val = ctrl_reg4_a.bdu;
N
N  return ret;
N}
N
N/**
N  * @brief  Reference value for interrupt generation.[set]
N  *         LSB = ~16@2g / ~31@4g / ~63@8g / ~127@16g
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that contains data to write.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_filter_reference_set(lsm303agr_ctx_t *ctx,
N                                          uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_REFERENCE_A, buff, 1);
X  ret = lsm303agr_write_reg(ctx, 0x26U, buff, 1);
N  return ret;
N}
N
N/**
N  * @brief  Reference value for interrupt generation.[get]
N  *         LSB = ~16@2g / ~31@4g / ~63@8g / ~127@16g
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_filter_reference_get(lsm303agr_ctx_t *ctx,
N                                          uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_REFERENCE_A, buff, 1);
X  ret = lsm303agr_read_reg(ctx, 0x26U, buff, 1);
N  return ret;
N}
N
N/**
N  * @brief  Acceleration set of data available.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of zyxda in reg STATUS_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_status_reg_a_t status_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x27U,
N                           (uint8_t*)&status_reg_a, 1);
N  *val = status_reg_a.zyxda;
N
N  return ret;
N}
N
N/**
N  * @brief  Acceleration set of data overrun.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of zyxor in reg STATUS_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_status_reg_a_t status_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x27U,
N                           (uint8_t*)&status_reg_a, 1);
N  *val = status_reg_a.zyxor;
N
N  return ret;
N}
N
N/**
N  * @brief  Acceleration output value.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_acceleration_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_OUT_X_L_A, buff, 6);
X  ret = lsm303agr_read_reg(ctx, 0x28U, buff, 6);
N  return ret;
N}
N
N/**
N  * @brief  These registers comprise a 3 group of
N  *         16-bit number and represent hard-iron
N  *         offset in order to compensate environmental
N  *         effects. Data format is the same of
N  *         output data raw: twos complement with
N  *         1LSb = 1.5mG. These values act on the
N  *         magnetic output data value in order to
N  *         delete the environmental offset.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that contains data to write.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_user_offset_set(lsm303agr_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_OFFSET_X_REG_L_M, buff, 6);
X  ret = lsm303agr_write_reg(ctx, 0x45U, buff, 6);
N  return ret;
N}
N
N/**
N  * @brief  These registers comprise a 3 group of
N  *         16-bit number and represent hard-iron
N  *         offset in order to compensate environmental
N  *         effects. Data format is the same of
N  *         output data raw: twos complement with
N  *         1LSb = 1.5mG. These values act on the
N  *         magnetic output data value in order to
N  *         delete the environmental offset.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_user_offset_get(lsm303agr_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_OFFSET_X_REG_L_M, buff, 6);
X  ret = lsm303agr_read_reg(ctx, 0x45U, buff, 6);
N  return ret;
N}
N
N/**
N  * @brief  Operating mode selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of md in reg CFG_REG_A_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_operating_mode_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_md_m_t val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  if(ret == 0){
N    cfg_reg_a_m.md = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M,
X    ret = lsm303agr_write_reg(ctx, 0x60U,
N                              (uint8_t*)&cfg_reg_a_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Operating mode selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of md in reg CFG_REG_A_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_operating_mode_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_md_m_t *val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N
N    switch (cfg_reg_a_m.md){
N    case LSM303AGR_CONTINUOUS_MODE:
N      *val = LSM303AGR_CONTINUOUS_MODE;
N      break;
N    case LSM303AGR_SINGLE_TRIGGER:
N      *val = LSM303AGR_SINGLE_TRIGGER;
N      break;
N    case LSM303AGR_POWER_DOWN:
N      *val = LSM303AGR_POWER_DOWN;
N      break;
N    default:
N      *val = LSM303AGR_CONTINUOUS_MODE;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Output data rate selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of odr in reg CFG_REG_A_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_data_rate_set(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_mg_odr_m_t val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  if(ret == 0){
N    cfg_reg_a_m.odr = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M,
X    ret = lsm303agr_write_reg(ctx, 0x60U,
N                              (uint8_t*)&cfg_reg_a_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Output data rate selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of odr in reg CFG_REG_A_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_data_rate_get(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_mg_odr_m_t *val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N
N    switch (cfg_reg_a_m.odr){
N    case LSM303AGR_MG_ODR_10Hz:
N      *val = LSM303AGR_MG_ODR_10Hz;
N      break;
N    case LSM303AGR_MG_ODR_20Hz:
N      *val = LSM303AGR_MG_ODR_20Hz;
N      break;
N    case LSM303AGR_MG_ODR_50Hz:
N      *val = LSM303AGR_MG_ODR_50Hz;
N      break;
N    case LSM303AGR_MG_ODR_100Hz:
N      *val = LSM303AGR_MG_ODR_100Hz;
N      break;
N    default:
N      *val = LSM303AGR_MG_ODR_10Hz;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enables high-resolution/low-power mode.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of lp in reg CFG_REG_A_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_power_mode_set(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_lp_m_t val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  if(ret == 0){
N    cfg_reg_a_m.lp = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M,
X    ret = lsm303agr_write_reg(ctx, 0x60U,
N                              (uint8_t*)&cfg_reg_a_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Enables high-resolution/low-power mode.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of lp in reg CFG_REG_A_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_power_mode_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_lp_m_t *val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N
N    switch (cfg_reg_a_m.lp){
N    case LSM303AGR_HIGH_RESOLUTION:
N      *val = LSM303AGR_HIGH_RESOLUTION;
N      break;
N    case LSM303AGR_LOW_POWER:
N      *val = LSM303AGR_LOW_POWER;
N      break;
N    default:
N      *val = LSM303AGR_HIGH_RESOLUTION;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enables the magnetometer temperature compensation.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of comp_temp_en in reg CFG_REG_A_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_offset_temp_comp_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  if(ret == 0){
N    cfg_reg_a_m.comp_temp_en = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M,
X    ret = lsm303agr_write_reg(ctx, 0x60U,
N                              (uint8_t*)&cfg_reg_a_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Enables the magnetometer temperature compensation.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of comp_temp_en in reg CFG_REG_A_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_offset_temp_comp_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  *val = cfg_reg_a_m.comp_temp_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Low-pass bandwidth selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of lpf in reg CFG_REG_B_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_low_pass_bandwidth_set(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_lpf_m_t val)
N{
N  lsm303agr_cfg_reg_b_m_t cfg_reg_b_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M,
X  ret = lsm303agr_read_reg(ctx, 0x61U,
N                           (uint8_t*)&cfg_reg_b_m, 1);
N  if(ret == 0){
N    cfg_reg_b_m.lpf = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_B_M,
X    ret = lsm303agr_write_reg(ctx, 0x61U,
N                              (uint8_t*)&cfg_reg_b_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Low-pass bandwidth selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of lpf in reg CFG_REG_B_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_low_pass_bandwidth_get(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_lpf_m_t *val)
N{
N  lsm303agr_cfg_reg_b_m_t cfg_reg_b_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M,
X  ret = lsm303agr_read_reg(ctx, 0x61U,
N                           (uint8_t*)&cfg_reg_b_m, 1);
N
N    switch (cfg_reg_b_m.lpf){
N    case LSM303AGR_ODR_DIV_2:
N      *val = LSM303AGR_ODR_DIV_2;
N      break;
N    case LSM303AGR_ODR_DIV_4:
N      *val = LSM303AGR_ODR_DIV_4;
N      break;
N    default:
N      *val = LSM303AGR_ODR_DIV_2;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Magnetometer sampling mode.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of set_rst in reg CFG_REG_B_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_set_rst_mode_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_set_rst_m_t val)
N{
N  lsm303agr_cfg_reg_b_m_t cfg_reg_b_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M,
X  ret = lsm303agr_read_reg(ctx, 0x61U,
N                           (uint8_t*)&cfg_reg_b_m, 1);
N  if(ret == 0){
N    cfg_reg_b_m.set_rst = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_B_M,
X    ret = lsm303agr_write_reg(ctx, 0x61U,
N                              (uint8_t*)&cfg_reg_b_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Magnetometer sampling mode.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of set_rst in reg CFG_REG_B_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_set_rst_mode_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_set_rst_m_t *val)
N{
N  lsm303agr_cfg_reg_b_m_t cfg_reg_b_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M,
X  ret = lsm303agr_read_reg(ctx, 0x61U,
N                           (uint8_t*)&cfg_reg_b_m, 1);
N
N    switch (cfg_reg_b_m.set_rst){
N    case LSM303AGR_SET_SENS_ODR_DIV_63:
N      *val = LSM303AGR_SET_SENS_ODR_DIV_63;
N      break;
N    case LSM303AGR_SENS_OFF_CANC_EVERY_ODR:
N      *val = LSM303AGR_SENS_OFF_CANC_EVERY_ODR;
N      break;
N    case LSM303AGR_SET_SENS_ONLY_AT_POWER_ON:
N      *val = LSM303AGR_SET_SENS_ONLY_AT_POWER_ON;
N      break;
N    default:
N      *val = LSM303AGR_SET_SENS_ODR_DIV_63;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enables offset cancellation in single measurement mode.
N  *         The OFF_CANC bit must be set
N  *         to 1 when enabling offset
N  *         cancellation in single measurement
N  *         mode this means a call function:
N  *         mag_set_rst_mode
N  *         (SENS_OFF_CANC_EVERY_ODR) is need.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of off_canc_one_shot in reg CFG_REG_B_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_set_rst_sensor_single_set(lsm303agr_ctx_t *ctx,
N                                                uint8_t val)
N{
N  lsm303agr_cfg_reg_b_m_t cfg_reg_b_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M,
X  ret = lsm303agr_read_reg(ctx, 0x61U,
N                           (uint8_t*)&cfg_reg_b_m, 1);
N  if(ret == 0){
N    cfg_reg_b_m.off_canc_one_shot = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_B_M,
X    ret = lsm303agr_write_reg(ctx, 0x61U,
N                              (uint8_t*)&cfg_reg_b_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Enables offset cancellation in single measurement mode.
N  *         The OFF_CANC bit must be set to
N  *         1 when enabling offset cancellation
N  *         in single measurement mode this
N  *         means a call function:
N  *         mag_set_rst_mode
N  *         (SENS_OFF_CANC_EVERY_ODR) is need.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of off_canc_one_shot in
N  *                reg CFG_REG_B_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_set_rst_sensor_single_get(lsm303agr_ctx_t *ctx,
N                                                uint8_t *val)
N{
N  lsm303agr_cfg_reg_b_m_t cfg_reg_b_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M,
X  ret = lsm303agr_read_reg(ctx, 0x61U,
N                           (uint8_t*)&cfg_reg_b_m, 1);
N  *val = cfg_reg_b_m.off_canc_one_shot;
N
N  return ret;
N}
N
N/**
N  * @brief  Blockdataupdate.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of bdu in reg CFG_REG_C_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_block_data_update_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  if(ret == 0){
N    cfg_reg_c_m.bdu = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M,
X    ret = lsm303agr_write_reg(ctx, 0x62U,
N                              (uint8_t*)&cfg_reg_c_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Blockdataupdate.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of bdu in reg CFG_REG_C_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_block_data_update_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  *val = cfg_reg_c_m.bdu;
N
N  return ret;
N}
N
N/**
N  * @brief  Magnetic set of data available.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of zyxda in reg STATUS_REG_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_status_reg_m_t status_reg_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_M,
X  ret = lsm303agr_read_reg(ctx, 0x67U,
N                           (uint8_t*)&status_reg_m, 1);
N  *val = status_reg_m.zyxda;
N
N  return ret;
N}
N
N/**
N  * @brief  Magnetic set of data overrun.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of zyxor in reg STATUS_REG_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_status_reg_m_t status_reg_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_M,
X  ret = lsm303agr_read_reg(ctx, 0x67U,
N                           (uint8_t*)&status_reg_m, 1);
N  *val = status_reg_m.zyxor;
N
N  return ret;
N}
N
N/**
N  * @brief  Magnetic output value.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_magnetic_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_OUTX_L_REG_M, buff, 6);
X  ret = lsm303agr_read_reg(ctx, 0x68U, buff, 6);
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @addtogroup  common
N  * @brief   This section group common usefull functions
N  * @{
N  *
N  */
N
N/**
N  * @brief  DeviceWhoamI.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_WHO_AM_I_A, buff, 1);
X  ret = lsm303agr_read_reg(ctx, 0x0FU, buff, 1);
N  return ret;
N}
N
N/**
N  * @brief  Self-test.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of st in reg CTRL_REG4_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_self_test_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_st_a_t val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N  if(ret == 0){
N    ctrl_reg4_a.st = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A,
X    ret = lsm303agr_write_reg(ctx, 0x23U,
N                              (uint8_t*)&ctrl_reg4_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Self-test.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of st in reg CTRL_REG4_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_self_test_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_st_a_t *val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N
N    switch (ctrl_reg4_a.st){
N    case LSM303AGR_ST_DISABLE:
N      *val = LSM303AGR_ST_DISABLE;
N      break;
N    case LSM303AGR_ST_POSITIVE:
N      *val = LSM303AGR_ST_POSITIVE;
N      break;
N    case LSM303AGR_ST_NEGATIVE:
N      *val = LSM303AGR_ST_NEGATIVE;
N      break;
N    default:
N      *val = LSM303AGR_ST_DISABLE;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Big/Little Endian data selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of ble in reg CTRL_REG4_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_data_format_set(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_ble_a_t val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N  if(ret == 0){
N    ctrl_reg4_a.ble = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A,
X    ret = lsm303agr_write_reg(ctx, 0x23U,
N                              (uint8_t*)&ctrl_reg4_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Big/Little Endian data selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of ble in reg CTRL_REG4_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_data_format_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_ble_a_t *val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N
N    switch (ctrl_reg4_a.ble){
N    case LSM303AGR_XL_LSB_AT_LOW_ADD:
N      *val = LSM303AGR_XL_LSB_AT_LOW_ADD;
N      break;
N    case LSM303AGR_XL_MSB_AT_LOW_ADD:
N      *val = LSM303AGR_XL_MSB_AT_LOW_ADD;
N      break;
N    default:
N      *val = LSM303AGR_XL_LSB_AT_LOW_ADD;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Reboot memory content. Reload the calibration parameters.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of boot in reg CTRL_REG5_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_boot_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  if(ret == 0){
N    ctrl_reg5_a.boot = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A,
X    ret = lsm303agr_write_reg(ctx, 0x24U,
N                              (uint8_t*)&ctrl_reg5_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Reboot memory content. Reload the calibration parameters.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of boot in reg CTRL_REG5_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  *val = ctrl_reg5_a.boot;
N
N  return ret;
N}
N
N/**
N  * @brief  Info about device status.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get register STATUS_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_status_get(lsm303agr_ctx_t *ctx,
N                                lsm303agr_status_reg_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x27U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  DeviceWhoamI.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_WHO_AM_I_M, buff, 1);
X  ret = lsm303agr_read_reg(ctx, 0x4FU, buff, 1);
N  return ret;
N}
N
N/**
N  * @brief  Software reset. Restore the default values in user registers.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of soft_rst in reg CFG_REG_A_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_reset_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  if(ret == 0){
N    cfg_reg_a_m.soft_rst = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M,
X    ret = lsm303agr_write_reg(ctx, 0x60U,
N                              (uint8_t*)&cfg_reg_a_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Software reset. Restore the default values in user registers.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of soft_rst in reg CFG_REG_A_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_reset_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  *val = cfg_reg_a_m.soft_rst;
N
N  return ret;
N}
N
N/**
N  * @brief  Reboot memory content. Reload the calibration parameters.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of reboot in reg CFG_REG_A_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_boot_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  if(ret == 0){
N    cfg_reg_a_m.reboot = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_A_M,
X    ret = lsm303agr_write_reg(ctx, 0x60U,
N                              (uint8_t*)&cfg_reg_a_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Reboot memory content. Reload the calibration parameters.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of reboot in reg CFG_REG_A_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_cfg_reg_a_m_t cfg_reg_a_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_A_M,
X  ret = lsm303agr_read_reg(ctx, 0x60U,
N                           (uint8_t*)&cfg_reg_a_m, 1);
N  *val = cfg_reg_a_m.reboot;
N
N  return ret;
N}
N
N/**
N  * @brief  Selftest.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of self_test in reg CFG_REG_C_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_self_test_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  if(ret == 0){
N    cfg_reg_c_m.self_test = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M,
X    ret = lsm303agr_write_reg(ctx, 0x62U,
N                              (uint8_t*)&cfg_reg_c_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Selftest.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of self_test in reg CFG_REG_C_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_self_test_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  *val = cfg_reg_c_m.self_test;
N
N  return ret;
N}
N
N/**
N  * @brief  Big/Little Endian data selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of ble in reg CFG_REG_C_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_data_format_set(lsm303agr_ctx_t *ctx,
N                                      lsm303agr_ble_m_t val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  if(ret == 0){
N    cfg_reg_c_m.ble = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M,
X    ret = lsm303agr_write_reg(ctx, 0x62U,
N                              (uint8_t*)&cfg_reg_c_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Big/Little Endian data selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of ble in reg CFG_REG_C_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_data_format_get(lsm303agr_ctx_t *ctx,
N                                      lsm303agr_ble_m_t *val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N
N    switch (cfg_reg_c_m.ble){
N    case LSM303AGR_MG_LSB_AT_LOW_ADD:
N      *val = LSM303AGR_MG_LSB_AT_LOW_ADD;
N      break;
N    case LSM303AGR_MG_MSB_AT_LOW_ADD:
N      *val = LSM303AGR_MG_MSB_AT_LOW_ADD;
N      break;
N    default:
N      *val = LSM303AGR_MG_LSB_AT_LOW_ADD;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Info about device status.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers STATUS_REG_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_status_get(lsm303agr_ctx_t *ctx,
N                                 lsm303agr_status_reg_m_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_STATUS_REG_M, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x67U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @addtogroup   interrupts_generator_1_for_xl
N  * @brief   This section group all the functions that manage the first
N  *          interrupts generator of accelerometer
N  * @{
N  *
N  */
N
N/**
N  * @brief  Interrupt generator 1 configuration register.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change register INT1_CFG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int1_cfg_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_INT1_CFG_A, (uint8_t*) val, 1);
X  ret = lsm303agr_write_reg(ctx, 0x30U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Interrupt generator 1 configuration register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get register INT1_CFG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int1_cfg_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT1_CFG_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x30U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Interrupt generator 1 source register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers INT1_SRC_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int1_src_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT1_SRC_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x31U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  User-defined threshold value for xl
N  *         interrupt event on generator 1.[set]
N  *         LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of ths in reg INT1_THS_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_gen_threshold_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val)
N{
N  lsm303agr_int1_ths_a_t int1_ths_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT1_THS_A,
X  ret = lsm303agr_read_reg(ctx, 0x32U,
N                           (uint8_t*)&int1_ths_a, 1);
N  if(ret == 0){
N    int1_ths_a.ths = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_INT1_THS_A,
X    ret = lsm303agr_write_reg(ctx, 0x32U,
N                              (uint8_t*)&int1_ths_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  User-defined threshold value for xl
N  *         interrupt event on generator 1.[get]
N  *         LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of ths in reg INT1_THS_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_gen_threshold_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val)
N{
N  lsm303agr_int1_ths_a_t int1_ths_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT1_THS_A,
X  ret = lsm303agr_read_reg(ctx, 0x32U,
N                           (uint8_t*)&int1_ths_a, 1);
N  *val = int1_ths_a.ths;
N
N  return ret;
N}
N
N/**
N  * @brief  The minimum duration (LSb = 1/ODR) of the Interrupt 1 event to be
N  *         recognized.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of d in reg INT1_DURATION_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_gen_duration_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_int1_duration_a_t int1_duration_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT1_DURATION_A,
X  ret = lsm303agr_read_reg(ctx, 0x33U,
N                           (uint8_t*)&int1_duration_a, 1);
N  if(ret == 0){
N    int1_duration_a.d = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_INT1_DURATION_A,
X    ret = lsm303agr_write_reg(ctx, 0x33U,
N                              (uint8_t*)&int1_duration_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  The minimum duration (LSb = 1/ODR) of the Interrupt 1 event to be
N  *         recognized.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of d in reg INT1_DURATION_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_gen_duration_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_int1_duration_a_t int1_duration_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT1_DURATION_A,
X  ret = lsm303agr_read_reg(ctx, 0x33U,
N                           (uint8_t*)&int1_duration_a, 1);
N  *val = int1_duration_a.d;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @addtogroup   interrupts_generator_2_for_xl
N  * @brief   This section group all the functions that manage the second
N  *          interrupts generator for accelerometer
N  * @{
N  *
N  */
N
N/**
N  * @brief  Interrupt generator 2 configuration register.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change registers INT2_CFG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int2_cfg_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_INT2_CFG_A, (uint8_t*) val, 1);
X  ret = lsm303agr_write_reg(ctx, 0x34U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Interrupt generator 2 configuration register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers INT2_CFG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int2_cfg_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT2_CFG_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x34U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Interrupt generator 2 source register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers INT2_SRC_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int2_src_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT2_SRC_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x35U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  User-defined threshold value for xl
N  *         interrupt event on generator 2.[set]
N  *         LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of ths in reg INT2_THS_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_gen_threshold_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val)
N{
N  lsm303agr_int2_ths_a_t int2_ths_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT2_THS_A,
X  ret = lsm303agr_read_reg(ctx, 0x36U,
N                           (uint8_t*)&int2_ths_a, 1);
N  if(ret == 0){
N    int2_ths_a.ths = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_INT2_THS_A,
X    ret = lsm303agr_write_reg(ctx, 0x36U,
N                              (uint8_t*)&int2_ths_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  User-defined threshold value for
N  *         xl interrupt event on generator 2.[get]
N  *         LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of ths in reg INT2_THS_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_gen_threshold_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val)
N{
N  lsm303agr_int2_ths_a_t int2_ths_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT2_THS_A,
X  ret = lsm303agr_read_reg(ctx, 0x36U,
N                           (uint8_t*)&int2_ths_a, 1);
N  *val = int2_ths_a.ths;
N
N  return ret;
N}
N
N/**
N  * @brief  The minimum duration (LSb = 1/ODR) of the Interrupt 1 event to be
N  *         recognized.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of d in reg INT2_DURATION_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_gen_duration_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_int2_duration_a_t int2_duration_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT2_DURATION_A,
X  ret = lsm303agr_read_reg(ctx, 0x37U,
N                           (uint8_t*)&int2_duration_a, 1);
N  if(ret == 0){
N    int2_duration_a.d = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_INT2_DURATION_A,
X    ret = lsm303agr_write_reg(ctx, 0x37U,
N                              (uint8_t*)&int2_duration_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  The minimum duration (LSb = 1/ODR) of the Interrupt 1 event to be
N  *         recognized.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of d in reg INT2_DURATION_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_gen_duration_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val)
N{
N  lsm303agr_int2_duration_a_t int2_duration_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT2_DURATION_A,
X  ret = lsm303agr_read_reg(ctx, 0x37U,
N                           (uint8_t*)&int2_duration_a, 1);
N  *val = int2_duration_a.d;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @addtogroup  interrupt_pins_xl
N  * @brief   This section group all the functions that manage interrupt
N  *          pins of accelerometer
N  * @{
N  *
N  */
N
N/**
N  * @brief  High-pass filter on interrupts/tap generator.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of hp in reg CTRL_REG2_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_high_pass_int_conf_set(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_hp_a_t val)
N{
N  lsm303agr_ctrl_reg2_a_t ctrl_reg2_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A,
X  ret = lsm303agr_read_reg(ctx, 0x21U,
N                           (uint8_t*)&ctrl_reg2_a, 1);
N  if(ret == 0){
N    ctrl_reg2_a.hp = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG2_A,
X    ret = lsm303agr_write_reg(ctx, 0x21U,
N                              (uint8_t*)&ctrl_reg2_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  High-pass filter on interrupts/tap generator.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of hp in reg CTRL_REG2_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_high_pass_int_conf_get(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_hp_a_t *val)
N{
N  lsm303agr_ctrl_reg2_a_t ctrl_reg2_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG2_A,
X  ret = lsm303agr_read_reg(ctx, 0x21U,
N                           (uint8_t*)&ctrl_reg2_a, 1);
N
N    switch (ctrl_reg2_a.hp){
N    case LSM303AGR_DISC_FROM_INT_GENERATOR:
N      *val = LSM303AGR_DISC_FROM_INT_GENERATOR;
N      break;
N    case LSM303AGR_ON_INT1_GEN:
N      *val = LSM303AGR_ON_INT1_GEN;
N      break;
N    case LSM303AGR_ON_INT2_GEN:
N      *val = LSM303AGR_ON_INT2_GEN;
N      break;
N    case LSM303AGR_ON_TAP_GEN:
N      *val = LSM303AGR_ON_TAP_GEN;
N      break;
N    case LSM303AGR_ON_INT1_INT2_GEN:
N      *val = LSM303AGR_ON_INT1_INT2_GEN;
N      break;
N    case LSM303AGR_ON_INT1_TAP_GEN:
N      *val = LSM303AGR_ON_INT1_TAP_GEN;
N      break;
N    case LSM303AGR_ON_INT2_TAP_GEN:
N      *val = LSM303AGR_ON_INT2_TAP_GEN;
N      break;
N    case LSM303AGR_ON_INT1_INT2_TAP_GEN:
N      *val = LSM303AGR_ON_INT1_INT2_TAP_GEN;
N      break;
N    default:
N      *val = LSM303AGR_DISC_FROM_INT_GENERATOR;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Int1 pin routing configuration register.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change registers CTRL_REG3_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_pin_int1_config_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg3_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG3_A, (uint8_t*) val, 1);
X  ret = lsm303agr_write_reg(ctx, 0x22U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Int1 pin routing configuration register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers CTRL_REG3_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_pin_int1_config_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg3_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG3_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x22U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  4D detection is enabled on INT2 pin when 6D bit on
N  *         INT2_CFG_A (34h) is set to 1.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of d4d_int2 in reg CTRL_REG5_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_pin_detect_4d_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  if(ret == 0){
N    ctrl_reg5_a.d4d_int2 = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A,
X    ret = lsm303agr_write_reg(ctx, 0x24U,
N                              (uint8_t*)&ctrl_reg5_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  4D detection is enabled on INT2 pin when 6D bit on
N  *         INT2_CFG_A (34h) is set to 1.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of d4d_int2 in reg CTRL_REG5_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2_pin_detect_4d_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  *val = ctrl_reg5_a.d4d_int2;
N
N  return ret;
N}
N
N/**
N  * @brief  Latch interrupt request on INT2_SRC_A (35h) register, with
N  *         INT2_SRC_A (35h) register cleared by reading
N  *         INT2_SRC_A (35h) itself.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of lir_int2 in reg CTRL_REG5_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2pin_notification_mode_set(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int2_a_t val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  if(ret == 0){
N    ctrl_reg5_a.lir_int2 = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A,
X    ret = lsm303agr_write_reg(ctx, 0x24U,
N                              (uint8_t*)&ctrl_reg5_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Latch interrupt request on INT2_SRC_A (35h) register, with
N  *         INT2_SRC_A (35h) register cleared by reading
N  *         INT2_SRC_A (35h) itself.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of lir_int2 in reg CTRL_REG5_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int2pin_notification_mode_get(lsm303agr_ctx_t *ctx,
N                                                lsm303agr_lir_int2_a_t *val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N
N    switch (ctrl_reg5_a.lir_int2){
N    case LSM303AGR_INT2_PULSED:
N      *val = LSM303AGR_INT2_PULSED;
N      break;
N    case LSM303AGR_INT2_LATCHED:
N      *val = LSM303AGR_INT2_LATCHED;
N      break;
N    default:
N      *val = LSM303AGR_INT2_PULSED;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  4D detection is enabled on INT1 pin when 6D bit on
N  *         INT1_CFG_A (30h) is set to 1.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of d4d_int1 in reg CTRL_REG5_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_pin_detect_4d_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  if(ret == 0){
N    ctrl_reg5_a.d4d_int1 = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A,
X    ret = lsm303agr_write_reg(ctx, 0x24U,
N                              (uint8_t*)&ctrl_reg5_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  4D detection is enabled on INT1 pin when 6D bit on
N  *         INT1_CFG_A (30h) is set to 1.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of d4d_int1 in reg CTRL_REG5_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1_pin_detect_4d_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  *val = ctrl_reg5_a.d4d_int1;
N
N  return ret;
N}
N
N/**
N  * @brief  Latch interrupt request on INT1_SRC_A (31h), with
N  *         INT1_SRC_A(31h) register cleared by reading
N  *         INT1_SRC_A (31h) itself.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of lir_int1 in reg CTRL_REG5_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1pin_notification_mode_set(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int1_a_t val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  if(ret == 0){
N    ctrl_reg5_a.lir_int1 = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A,
X    ret = lsm303agr_write_reg(ctx, 0x24U,
N                              (uint8_t*)&ctrl_reg5_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Latch interrupt request on INT1_SRC_A (31h), with
N  *         INT1_SRC_A(31h) register cleared by reading
N  *         INT1_SRC_A (31h) itself.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of lir_int1 in reg CTRL_REG5_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_int1pin_notification_mode_get(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int1_a_t *val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N
N    switch (ctrl_reg5_a.lir_int1){
N    case LSM303AGR_INT1_PULSED:
N      *val = LSM303AGR_INT1_PULSED;
N      break;
N    case LSM303AGR_INT1_LATCHED:
N      *val = LSM303AGR_INT1_LATCHED;
N      break;
N    default:
N      *val = LSM303AGR_INT1_PULSED;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Int2 pin routing configuration register.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change registers CTRL_REG6_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_pin_int2_config_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg6_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG6_A, (uint8_t*) val, 1);
X  ret = lsm303agr_write_reg(ctx, 0x25U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Int2 pin routing configuration register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers CTRL_REG6_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_pin_int2_config_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg6_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG6_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x25U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N  /**
N  * @addtogroup  magnetometer interrupts
N  * @brief       This section group all the functions that manage the
N  *              magnetometer interrupts
N  * @{
N  *
N  */
N
N/**
N  * @brief  The interrupt block recognition checks
N  *         data after/before the hard-iron correction
N  *         to discover the interrupt.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of int_on_dataoff in reg CFG_REG_B_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_offset_int_conf_set(lsm303agr_ctx_t *ctx,
N                                          lsm303agr_int_on_dataoff_m_t val)
N{
N  lsm303agr_cfg_reg_b_m_t cfg_reg_b_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M,
X  ret = lsm303agr_read_reg(ctx, 0x61U,
N                           (uint8_t*)&cfg_reg_b_m, 1);
N  if(ret == 0){
N    cfg_reg_b_m.int_on_dataoff = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_B_M,
X    ret = lsm303agr_write_reg(ctx, 0x61U,
N                              (uint8_t*)&cfg_reg_b_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  The interrupt block recognition checks
N  *         data after/before the hard-iron correction
N  *         to discover the interrupt.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of int_on_dataoff in reg CFG_REG_B_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_offset_int_conf_get(lsm303agr_ctx_t *ctx,
N                                          lsm303agr_int_on_dataoff_m_t *val)
N{
N  lsm303agr_cfg_reg_b_m_t cfg_reg_b_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_B_M,
X  ret = lsm303agr_read_reg(ctx, 0x61U,
N                           (uint8_t*)&cfg_reg_b_m, 1);
N
N    switch (cfg_reg_b_m.int_on_dataoff){
N    case LSM303AGR_CHECK_BEFORE:
N      *val = LSM303AGR_CHECK_BEFORE;
N      break;
N    case LSM303AGR_CHECK_AFTER:
N      *val = LSM303AGR_CHECK_AFTER;
N      break;
N    default:
N      *val = LSM303AGR_CHECK_BEFORE;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Data-ready signal on INT_DRDY pin.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of drdy_on_pin in reg CFG_REG_C_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_drdy_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  if(ret == 0){
N    cfg_reg_c_m.int_mag = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M,
X    ret = lsm303agr_write_reg(ctx, 0x62U,
N                              (uint8_t*)&cfg_reg_c_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Data-ready signal on INT_DRDY pin.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of drdy_on_pin in reg CFG_REG_C_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_drdy_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  *val = cfg_reg_c_m.int_mag;
N
N  return ret;
N}
N
N/**
N  * @brief  Interrupt signal on INT_DRDY pin.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of int_on_pin in reg CFG_REG_C_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_int_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  if(ret == 0){
N    cfg_reg_c_m.int_mag_pin = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M,
X    ret = lsm303agr_write_reg(ctx, 0x62U,
N                              (uint8_t*)&cfg_reg_c_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Interrupt signal on INT_DRDY pin.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of int_on_pin in reg CFG_REG_C_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_int_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  *val = cfg_reg_c_m.int_mag_pin;
N
N  return ret;
N}
N
N/**
N  * @brief  Interrupt generator configuration register.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change registers INT_CRTL_REG_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_int_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int_crtl_reg_m_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_INT_CRTL_REG_M, (uint8_t*) val, 1);
X  ret = lsm303agr_write_reg(ctx, 0x63U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Interrupt generator configuration register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers INT_CRTL_REG_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_int_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int_crtl_reg_m_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT_CRTL_REG_M,
X  ret = lsm303agr_read_reg(ctx, 0x63U,
N                           (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Interrupt generator source register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers INT_SOURCE_REG_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_int_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int_source_reg_m_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT_SOURCE_REG_M,
X  ret = lsm303agr_read_reg(ctx, 0x64U,
N                           (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  User-defined threshold value for xl interrupt event on generator.
N  *         Data format is the same of output
N  *         data raw: twos complement with
N  *         1LSb = 1.5mG.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that contains data to write.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_int_gen_treshold_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_INT_THS_L_REG_M, buff, 2);
X  ret = lsm303agr_write_reg(ctx, 0x65U, buff, 2);
N  return ret;
N}
N
N/**
N  * @brief  User-defined threshold value for xl interrupt event on generator.
N  *         Data format is the same of output
N  *         data raw: twos complement with
N  *         1LSb = 1.5mG.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  buff   Buffer that stores data read.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_int_gen_treshold_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_INT_THS_L_REG_M, buff, 2);
X  ret = lsm303agr_read_reg(ctx, 0x65U, buff, 2);
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @addtogroup  accelerometer_fifo
N  * @brief       This section group all the functions concerning the xl
N  *              fifo usage
N  * @{
N  *
N  */
N
N/**
N  * @brief  FIFOenable.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of fifo_en in reg CTRL_REG5_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  if(ret == 0){
N    ctrl_reg5_a.fifo_en = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG5_A,
X    ret = lsm303agr_write_reg(ctx, 0x24U,
N                              (uint8_t*)&ctrl_reg5_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  FIFOenable.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of fifo_en in reg CTRL_REG5_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_ctrl_reg5_a_t ctrl_reg5_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG5_A,
X  ret = lsm303agr_read_reg(ctx, 0x24U,
N                           (uint8_t*)&ctrl_reg5_a, 1);
N  *val = ctrl_reg5_a.fifo_en;
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO watermark level selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of fth in reg FIFO_CTRL_REG_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_watermark_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_fifo_ctrl_reg_a_t fifo_ctrl_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2EU,
N                           (uint8_t*)&fifo_ctrl_reg_a, 1);
N  if(ret == 0){
N    fifo_ctrl_reg_a.fth = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X    ret = lsm303agr_write_reg(ctx, 0x2EU,
N                              (uint8_t*)&fifo_ctrl_reg_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO watermark level selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of fth in reg FIFO_CTRL_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_watermark_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_fifo_ctrl_reg_a_t fifo_ctrl_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2EU,
N                           (uint8_t*)&fifo_ctrl_reg_a, 1);
N  *val = fifo_ctrl_reg_a.fth;
N
N  return ret;
N}
N
N/**
N  * @brief  Trigger FIFO selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of tr in reg FIFO_CTRL_REG_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_trigger_event_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_tr_a_t val)
N{
N  lsm303agr_fifo_ctrl_reg_a_t fifo_ctrl_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2EU,
N                           (uint8_t*)&fifo_ctrl_reg_a, 1);
N  if(ret == 0){
N    fifo_ctrl_reg_a.tr = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X    ret = lsm303agr_write_reg(ctx, 0x2EU,
N                              (uint8_t*)&fifo_ctrl_reg_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Trigger FIFO selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of tr in reg FIFO_CTRL_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_trigger_event_get(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_tr_a_t *val)
N{
N  lsm303agr_fifo_ctrl_reg_a_t fifo_ctrl_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2EU,
N                           (uint8_t*)&fifo_ctrl_reg_a, 1);
N
N    switch (fifo_ctrl_reg_a.tr){
N    case LSM303AGR_INT1_GEN:
N      *val = LSM303AGR_INT1_GEN;
N      break;
N    case LSM303AGR_INT2_GEN:
N      *val = LSM303AGR_INT2_GEN;
N      break;
N    default:
N      *val = LSM303AGR_INT1_GEN;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  FIFO mode selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of fm in reg FIFO_CTRL_REG_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_mode_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_fm_a_t val)
N{
N  lsm303agr_fifo_ctrl_reg_a_t fifo_ctrl_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2EU,
N                           (uint8_t*)&fifo_ctrl_reg_a, 1);
N  if(ret == 0){
N    fifo_ctrl_reg_a.fm = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X    ret = lsm303agr_write_reg(ctx, 0x2EU,
N                              (uint8_t*)&fifo_ctrl_reg_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO mode selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of fm in reg FIFO_CTRL_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_mode_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_fm_a_t *val)
N{
N  lsm303agr_fifo_ctrl_reg_a_t fifo_ctrl_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_CTRL_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2EU,
N                           (uint8_t*)&fifo_ctrl_reg_a, 1);
N
N    switch (fifo_ctrl_reg_a.fm){
N    case LSM303AGR_BYPASS_MODE:
N      *val = LSM303AGR_BYPASS_MODE;
N      break;
N    case LSM303AGR_FIFO_MODE:
N      *val = LSM303AGR_FIFO_MODE;
N      break;
N    case LSM303AGR_DYNAMIC_STREAM_MODE:
N      *val = LSM303AGR_DYNAMIC_STREAM_MODE;
N      break;
N    case LSM303AGR_STREAM_TO_FIFO_MODE:
N      *val = LSM303AGR_STREAM_TO_FIFO_MODE;
N      break;
N    default:
N      *val = LSM303AGR_BYPASS_MODE;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  FIFO status register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers FIFO_SRC_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_status_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_fifo_src_reg_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x2FU, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  FIFO stored data level.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of fss in reg FIFO_SRC_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_data_level_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_fifo_src_reg_a_t fifo_src_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2FU,
N                           (uint8_t*)&fifo_src_reg_a, 1);
N  *val = fifo_src_reg_a.fss;
N
N  return ret;
N}
N
N/**
N  * @brief  Empty FIFO status flag.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of empty in reg FIFO_SRC_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_empty_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_fifo_src_reg_a_t fifo_src_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2FU,
N                           (uint8_t*)&fifo_src_reg_a, 1);
N  *val = fifo_src_reg_a.empty;
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO overrun status flag.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of ovrn_fifo in reg FIFO_SRC_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_ovr_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_fifo_src_reg_a_t fifo_src_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2FU,
N                           (uint8_t*)&fifo_src_reg_a, 1);
N  *val = fifo_src_reg_a.ovrn_fifo;
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO watermark status.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of wtm in reg FIFO_SRC_REG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_fifo_fth_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_fifo_src_reg_a_t fifo_src_reg_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_FIFO_SRC_REG_A,
X  ret = lsm303agr_read_reg(ctx, 0x2FU,
N                           (uint8_t*)&fifo_src_reg_a, 1);
N  *val = fifo_src_reg_a.wtm;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @addtogroup  tap_generator
N  * @brief       This section group all the functions that manage the tap and
N  *              double tap event generation
N  * @{
N  *
N  */
N
N/**
N  * @brief  Tap/Double Tap generator configuration register.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change registers CLICK_CFG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_tap_conf_set(lsm303agr_ctx_t *ctx,
N                               lsm303agr_click_cfg_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_write_reg(ctx, LSM303AGR_CLICK_CFG_A, (uint8_t*) val, 1);
X  ret = lsm303agr_write_reg(ctx, 0x38U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Tap/Double Tap generator configuration register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers CLICK_CFG_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_tap_conf_get(lsm303agr_ctx_t *ctx,
N                               lsm303agr_click_cfg_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CLICK_CFG_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x38U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Tap/Double Tap generator source register.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get registers CLICK_SRC_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_tap_source_get(lsm303agr_ctx_t *ctx,
N                                 lsm303agr_click_src_a_t *val)
N{
N  int32_t ret;
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CLICK_SRC_A, (uint8_t*) val, 1);
X  ret = lsm303agr_read_reg(ctx, 0x39U, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  User-defined threshold value for Tap/Double Tap event.
N  *         (1 LSB = full scale/128)[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of ths in reg CLICK_THS_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_tap_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_click_ths_a_t click_ths_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CLICK_THS_A,
X  ret = lsm303agr_read_reg(ctx, 0x3AU,
N                           (uint8_t*)&click_ths_a, 1);
N  if(ret == 0){
N    click_ths_a.ths = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CLICK_THS_A,
X    ret = lsm303agr_write_reg(ctx, 0x3AU,
N                              (uint8_t*)&click_ths_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  User-defined threshold value for Tap/Double Tap event.
N  *         (1 LSB = full scale/128)[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of ths in reg CLICK_THS_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_tap_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_click_ths_a_t click_ths_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CLICK_THS_A,
X  ret = lsm303agr_read_reg(ctx, 0x3AU,
N                           (uint8_t*)&click_ths_a, 1);
N  *val = click_ths_a.ths;
N
N  return ret;
N}
N
N/**
N  * @brief  The maximum time (1 LSB = 1/ODR) interval that can
N  *         elapse between the start of the click-detection procedure
N  *         and when the acceleration falls back below the threshold.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of tli in reg TIME_LIMIT_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_shock_dur_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_time_limit_a_t time_limit_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_TIME_LIMIT_A,
X  ret = lsm303agr_read_reg(ctx, 0x3BU,
N                           (uint8_t*)&time_limit_a, 1);
N  if(ret == 0){
N    time_limit_a.tli = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_TIME_LIMIT_A,
X    ret = lsm303agr_write_reg(ctx, 0x3BU,
N                              (uint8_t*)&time_limit_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  The maximum time (1 LSB = 1/ODR) interval that can
N  *         elapse between the start of the click-detection procedure
N  *         and when the acceleration falls back below the threshold.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of tli in reg TIME_LIMIT_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_shock_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_time_limit_a_t time_limit_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_TIME_LIMIT_A,
X  ret = lsm303agr_read_reg(ctx, 0x3BU,
N                           (uint8_t*)&time_limit_a, 1);
N  *val = time_limit_a.tli;
N
N  return ret;
N}
N
N/**
N  * @brief  The time (1 LSB = 1/ODR) interval that starts after the
N  *         first click detection where the click-detection procedure
N  *         is disabled, in cases where the device is configured for
N  *         double-click detection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of tla in reg TIME_LATENCY_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_quiet_dur_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_time_latency_a_t time_latency_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_TIME_LATENCY_A,
X  ret = lsm303agr_read_reg(ctx, 0x3CU,
N                           (uint8_t*)&time_latency_a, 1);
N  if(ret == 0){
N    time_latency_a.tla = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_TIME_LATENCY_A,
X    ret = lsm303agr_write_reg(ctx, 0x3CU,
N                              (uint8_t*)&time_latency_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  The time (1 LSB = 1/ODR) interval that starts after the first click
N  *         detection where the click-detection procedure is disabled, in cases
N  *         where the device is configured for double-click detection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of tla in reg TIME_LATENCY_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_quiet_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_time_latency_a_t time_latency_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_TIME_LATENCY_A,
X  ret = lsm303agr_read_reg(ctx, 0x3CU,
N                           (uint8_t*)&time_latency_a, 1);
N  *val = time_latency_a.tla;
N
N  return ret;
N}
N
N/**
N  * @brief  The maximum interval of time (1 LSB = 1/ODR) that can elapse after
N  *         the end of the latency interval in which the click-detection
N  *         procedure can start, in cases where the device is configured for
N  *         double-click detection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of tw in reg TIME_WINDOW_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_double_tap_timeout_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_time_window_a_t time_window_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_TIME_WINDOW_A,
X  ret = lsm303agr_read_reg(ctx, 0x3DU,
N                           (uint8_t*)&time_window_a, 1);
N  if(ret == 0){
N    time_window_a.tw = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_TIME_WINDOW_A,
X    ret = lsm303agr_write_reg(ctx, 0x3DU,
N                              (uint8_t*)&time_window_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  The maximum interval of time (1 LSB = 1/ODR) that can elapse after
N  *         the end of the latency interval in which the click-detection
N  *         procedure can start, in cases where the device is configured for
N  *         double-click detection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of tw in reg TIME_WINDOW_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_double_tap_timeout_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_time_window_a_t time_window_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_TIME_WINDOW_A,
X  ret = lsm303agr_read_reg(ctx, 0x3DU,
N                           (uint8_t*)&time_window_a, 1);
N  *val = time_window_a.tw;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @addtogroup   activity_inactivity_xl
N  * @brief        This section group all the functions concerning activity
N  *               inactivity functionality foe accelerometer
N  * @{
N  *
N  */
N
N/**
N  * @brief  Sleep-to-wake, return-to-sleep activation
N  *         threshold in low-power mode.[set]
N  *         1 LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of acth in reg ACT_THS_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_act_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_act_ths_a_t act_ths_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_ACT_THS_A,
X  ret = lsm303agr_read_reg(ctx, 0x3EU,
N                           (uint8_t*)&act_ths_a, 1);
N  if(ret == 0){
N    act_ths_a.acth = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_ACT_THS_A,
X    ret = lsm303agr_write_reg(ctx, 0x3EU,
N                              (uint8_t*)&act_ths_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Sleep-to-wake, return-to-sleep activation
N  *          threshold in low-power mode.[get]
N  *          1 LSb = 16mg@2g / 32mg@4g / 62mg@8g / 186mg@16g
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of acth in reg ACT_THS_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_act_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_act_ths_a_t act_ths_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_ACT_THS_A,
X  ret = lsm303agr_read_reg(ctx, 0x3EU,
N                           (uint8_t*)&act_ths_a, 1);
N  *val = act_ths_a.acth;
N
N  return ret;
N}
N
N/**
N  * @brief  Sleep-to-wake, return-to-sleep duration = (8*1[LSb]+1)/ODR.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of actd in reg ACT_DUR_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_act_timeout_set(lsm303agr_ctx_t *ctx, uint8_t val)
N{
N  lsm303agr_act_dur_a_t act_dur_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_ACT_DUR_A,
X  ret = lsm303agr_read_reg(ctx, 0x3FU,
N                           (uint8_t*)&act_dur_a, 1);
N  if(ret == 0){
N    act_dur_a.actd = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_ACT_DUR_A,
X    ret = lsm303agr_write_reg(ctx, 0x3FU,
N                              (uint8_t*)&act_dur_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Sleep-to-wake, return-to-sleep duration = (8*1[LSb]+1)/ODR.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of actd in reg ACT_DUR_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_act_timeout_get(lsm303agr_ctx_t *ctx, uint8_t *val)
N{
N  lsm303agr_act_dur_a_t act_dur_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_ACT_DUR_A,
X  ret = lsm303agr_read_reg(ctx, 0x3FU,
N                           (uint8_t*)&act_dur_a, 1);
N  *val = act_dur_a.actd;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @addtogroup  serial_interface
N  * @brief       This section group all the functions concerning serial
N  *              interface management
N  * @{
N  *
N  */
N
N/**
N  * @brief  SPI Serial Interface Mode selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of sim in reg CTRL_REG4_A
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_spi_mode_set(lsm303agr_ctx_t *ctx,
N                                  lsm303agr_sim_a_t val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N  if(ret == 0){
N    ctrl_reg4_a.spi_enable = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CTRL_REG4_A,
X    ret = lsm303agr_write_reg(ctx, 0x23U,
N                              (uint8_t*)&ctrl_reg4_a, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  SPI Serial Interface Mode selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of sim in reg CTRL_REG4_A.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_xl_spi_mode_get(lsm303agr_ctx_t *ctx,
N                                  lsm303agr_sim_a_t *val)
N{
N  lsm303agr_ctrl_reg4_a_t ctrl_reg4_a;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CTRL_REG4_A,
X  ret = lsm303agr_read_reg(ctx, 0x23U,
N                           (uint8_t*)&ctrl_reg4_a, 1);
N
N    switch (ctrl_reg4_a.spi_enable){
N    case LSM303AGR_SPI_4_WIRE:
N      *val = LSM303AGR_SPI_4_WIRE;
N      break;
N    case LSM303AGR_SPI_3_WIRE:
N      *val = LSM303AGR_SPI_3_WIRE;
N      break;
N    default:
N      *val = LSM303AGR_SPI_4_WIRE;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable/Disable I2C interface.[set]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Change the values of i2c_dis in reg CFG_REG_C_M
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_i2c_interface_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_i2c_dis_m_t val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N  if(ret == 0){
N    cfg_reg_c_m.i2c_dis = (uint8_t)val;
N    ret = lsm303agr_write_reg(ctx, LSM303AGR_CFG_REG_C_M,
X    ret = lsm303agr_write_reg(ctx, 0x62U,
N                              (uint8_t*)&cfg_reg_c_m, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Enable/Disable I2C interface.[get]
N  *
N  * @param  ctx    Read / write interface definitions.(ptr)
N  * @param  val    Get the values of i2c_dis in reg CFG_REG_C_M.(ptr)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm303agr_mag_i2c_interface_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_i2c_dis_m_t *val)
N{
N  lsm303agr_cfg_reg_c_m_t cfg_reg_c_m;
N  int32_t ret;
N
N  ret = lsm303agr_read_reg(ctx, LSM303AGR_CFG_REG_C_M,
X  ret = lsm303agr_read_reg(ctx, 0x62U,
N                           (uint8_t*)&cfg_reg_c_m, 1);
N
N    switch (cfg_reg_c_m.i2c_dis){
N    case LSM303AGR_I2C_ENABLE:
N      *val = LSM303AGR_I2C_ENABLE;
N      break;
N    case LSM303AGR_I2C_DISABLE:
N      *val = LSM303AGR_I2C_DISABLE;
N      break;
N    default:
N      *val = LSM303AGR_I2C_ENABLE;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
