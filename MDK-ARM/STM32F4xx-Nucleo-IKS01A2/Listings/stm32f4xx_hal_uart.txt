; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_uart.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2402     */
;;;2403   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2404   {
;;;2405     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2406   
;;;2407     /* Process Locked */
;;;2408     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L1.18|
00000e  2002              MOVS     r0,#2
                  |L1.16|
;;;2409   
;;;2410     huart->gState = HAL_UART_STATE_BUSY;
;;;2411   
;;;2412     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2413     tmpreg = huart->Instance->CR1;
;;;2414   
;;;2415     /* Clear TE and RE bits */
;;;2416     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2417   
;;;2418     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2419     tmpreg |= (uint32_t)USART_CR1_RE;
;;;2420   
;;;2421     /* Write to USART CR1 */
;;;2422     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2423   
;;;2424     huart->gState = HAL_UART_STATE_READY;
;;;2425   
;;;2426     /* Process Unlocked */
;;;2427     __HAL_UNLOCK(huart);
;;;2428   
;;;2429     return HAL_OK;
;;;2430   }
000010  4770              BX       lr
                  |L1.18|
000012  2001              MOVS     r0,#1                 ;2408
000014  f8810038          STRB     r0,[r1,#0x38]         ;2408
000018  bf00              NOP                            ;2408
00001a  2024              MOVS     r0,#0x24              ;2410
00001c  f8810039          STRB     r0,[r1,#0x39]         ;2410
000020  6808              LDR      r0,[r1,#0]            ;2413
000022  68c2              LDR      r2,[r0,#0xc]          ;2413
000024  f022020c          BIC      r2,r2,#0xc            ;2416
000028  f0420204          ORR      r2,r2,#4              ;2419
00002c  6808              LDR      r0,[r1,#0]            ;2422
00002e  60c2              STR      r2,[r0,#0xc]          ;2422
000030  2020              MOVS     r0,#0x20              ;2424
000032  f8810039          STRB     r0,[r1,#0x39]         ;2424
000036  bf00              NOP                            ;2427
000038  2000              MOVS     r0,#0                 ;2427
00003a  f8810038          STRB     r0,[r1,#0x38]         ;2427
00003e  bf00              NOP                            ;2427
000040  bf00              NOP                            ;2429
000042  e7e5              B        |L1.16|
;;;2431   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2367     */
;;;2368   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2369   {
;;;2370     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2371   
;;;2372     /* Process Locked */
;;;2373     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L2.18|
00000e  2002              MOVS     r0,#2
                  |L2.16|
;;;2374   
;;;2375     huart->gState = HAL_UART_STATE_BUSY;
;;;2376   
;;;2377     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2378     tmpreg = huart->Instance->CR1;
;;;2379   
;;;2380     /* Clear TE and RE bits */
;;;2381     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2382   
;;;2383     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2384     tmpreg |= (uint32_t)USART_CR1_TE;
;;;2385   
;;;2386     /* Write to USART CR1 */
;;;2387     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2388   
;;;2389     huart->gState = HAL_UART_STATE_READY;
;;;2390   
;;;2391     /* Process Unlocked */
;;;2392     __HAL_UNLOCK(huart);
;;;2393   
;;;2394     return HAL_OK;
;;;2395   }
000010  4770              BX       lr
                  |L2.18|
000012  2001              MOVS     r0,#1                 ;2373
000014  f8810038          STRB     r0,[r1,#0x38]         ;2373
000018  bf00              NOP                            ;2373
00001a  2024              MOVS     r0,#0x24              ;2375
00001c  f8810039          STRB     r0,[r1,#0x39]         ;2375
000020  6808              LDR      r0,[r1,#0]            ;2378
000022  68c2              LDR      r2,[r0,#0xc]          ;2378
000024  f022020c          BIC      r2,r2,#0xc            ;2381
000028  f0420208          ORR      r2,r2,#8              ;2384
00002c  6808              LDR      r0,[r1,#0]            ;2387
00002e  60c2              STR      r2,[r0,#0xc]          ;2387
000030  2020              MOVS     r0,#0x20              ;2389
000032  f8810039          STRB     r0,[r1,#0x39]         ;2389
000036  bf00              NOP                            ;2392
000038  2000              MOVS     r0,#0                 ;2392
00003a  f8810038          STRB     r0,[r1,#0x38]         ;2392
00003e  bf00              NOP                            ;2392
000040  bf00              NOP                            ;2394
000042  e7e5              B        |L2.16|
;;;2396   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;391      */
;;;392    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;393    {
000002  4604              MOV      r4,r0
;;;394      /* Check the UART handle allocation */
;;;395      if (huart == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;396      {
;;;397        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;398      }
;;;399    
;;;400      /* Check the parameters */
;;;401      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;402      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;403      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;404    
;;;405      if (huart->gState == HAL_UART_STATE_RESET)
;;;406      {
;;;407        /* Allocate lock resource and initialize it */
;;;408        huart->Lock = HAL_UNLOCKED;
;;;409    
;;;410    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;411        UART_InitCallbacksToDefault(huart);
;;;412    
;;;413        if (huart->MspInitCallback == NULL)
;;;414        {
;;;415          huart->MspInitCallback = HAL_UART_MspInit;
;;;416        }
;;;417    
;;;418        /* Init the low level hardware */
;;;419        huart->MspInitCallback(huart);
;;;420    #else
;;;421        /* Init the low level hardware : GPIO, CLOCK */
;;;422        HAL_UART_MspInit(huart);
;;;423    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;424      }
;;;425    
;;;426      huart->gState = HAL_UART_STATE_BUSY;
;;;427    
;;;428      /* Disable the peripheral */
;;;429      __HAL_UART_DISABLE(huart);
;;;430    
;;;431      /* Set the UART Communication parameters */
;;;432      UART_SetConfig(huart);
;;;433    
;;;434      /* In half-duplex mode, the following bits must be kept cleared:
;;;435         - LINEN and CLKEN bits in the USART_CR2 register,
;;;436         - SCEN and IREN bits in the USART_CR3 register.*/
;;;437      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;438      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;439    
;;;440      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;441      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;442    
;;;443      /* Enable the peripheral */
;;;444      __HAL_UART_ENABLE(huart);
;;;445    
;;;446      /* Initialize the UART state*/
;;;447      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;448      huart->gState = HAL_UART_STATE_READY;
;;;449      huart->RxState = HAL_UART_STATE_READY;
;;;450    
;;;451      return HAL_OK;
;;;452    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f8940039          LDRB     r0,[r4,#0x39]         ;405
00000e  b928              CBNZ     r0,|L3.28|
000010  2000              MOVS     r0,#0                 ;408
000012  f8840038          STRB     r0,[r4,#0x38]         ;408
000016  4620              MOV      r0,r4                 ;422
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L3.28|
00001c  2024              MOVS     r0,#0x24              ;426
00001e  f8840039          STRB     r0,[r4,#0x39]         ;426
000022  6820              LDR      r0,[r4,#0]            ;429
000024  68c0              LDR      r0,[r0,#0xc]          ;429
000026  f4205000          BIC      r0,r0,#0x2000         ;429
00002a  6821              LDR      r1,[r4,#0]            ;429
00002c  60c8              STR      r0,[r1,#0xc]          ;429
00002e  4620              MOV      r0,r4                 ;432
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;437
000036  6900              LDR      r0,[r0,#0x10]         ;437
000038  f4204090          BIC      r0,r0,#0x4800         ;437
00003c  6821              LDR      r1,[r4,#0]            ;437
00003e  6108              STR      r0,[r1,#0x10]         ;437
000040  6820              LDR      r0,[r4,#0]            ;438
000042  6940              LDR      r0,[r0,#0x14]         ;438
000044  f0200022          BIC      r0,r0,#0x22           ;438
000048  6821              LDR      r1,[r4,#0]            ;438
00004a  6148              STR      r0,[r1,#0x14]         ;438
00004c  6820              LDR      r0,[r4,#0]            ;441
00004e  6940              LDR      r0,[r0,#0x14]         ;441
000050  f0400008          ORR      r0,r0,#8              ;441
000054  6821              LDR      r1,[r4,#0]            ;441
000056  6148              STR      r0,[r1,#0x14]         ;441
000058  6820              LDR      r0,[r4,#0]            ;444
00005a  68c0              LDR      r0,[r0,#0xc]          ;444
00005c  f4405000          ORR      r0,r0,#0x2000         ;444
000060  6821              LDR      r1,[r4,#0]            ;444
000062  60c8              STR      r0,[r1,#0xc]          ;444
000064  2000              MOVS     r0,#0                 ;447
000066  63e0              STR      r0,[r4,#0x3c]         ;447
000068  2020              MOVS     r0,#0x20              ;448
00006a  f8840039          STRB     r0,[r4,#0x39]         ;448
00006e  f884003a          STRB     r0,[r4,#0x3a]         ;449
000072  2000              MOVS     r0,#0                 ;451
000074  e7c8              B        |L3.8|
;;;453    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;464      */
;;;465    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;466    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;467      /* Check the UART handle allocation */
;;;468      if (huart == NULL)
000006  b90c              CBNZ     r4,|L4.12|
;;;469      {
;;;470        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L4.10|
;;;471      }
;;;472    
;;;473      /* Check the LIN UART instance */
;;;474      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;475    
;;;476      /* Check the Break detection length parameter */
;;;477      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;478      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;479      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;480    
;;;481      if (huart->gState == HAL_UART_STATE_RESET)
;;;482      {
;;;483        /* Allocate lock resource and initialize it */
;;;484        huart->Lock = HAL_UNLOCKED;
;;;485    
;;;486    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;487        UART_InitCallbacksToDefault(huart);
;;;488    
;;;489        if (huart->MspInitCallback == NULL)
;;;490        {
;;;491          huart->MspInitCallback = HAL_UART_MspInit;
;;;492        }
;;;493    
;;;494        /* Init the low level hardware */
;;;495        huart->MspInitCallback(huart);
;;;496    #else
;;;497        /* Init the low level hardware : GPIO, CLOCK */
;;;498        HAL_UART_MspInit(huart);
;;;499    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;500      }
;;;501    
;;;502      huart->gState = HAL_UART_STATE_BUSY;
;;;503    
;;;504      /* Disable the peripheral */
;;;505      __HAL_UART_DISABLE(huart);
;;;506    
;;;507      /* Set the UART Communication parameters */
;;;508      UART_SetConfig(huart);
;;;509    
;;;510      /* In LIN mode, the following bits must be kept cleared:
;;;511         - CLKEN bits in the USART_CR2 register,
;;;512         - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/
;;;513      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
;;;514      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;515    
;;;516      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;517      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;518    
;;;519      /* Set the USART LIN Break detection length. */
;;;520      CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
;;;521      SET_BIT(huart->Instance->CR2, BreakDetectLength);
;;;522    
;;;523      /* Enable the peripheral */
;;;524      __HAL_UART_ENABLE(huart);
;;;525    
;;;526      /* Initialize the UART state*/
;;;527      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;528      huart->gState = HAL_UART_STATE_READY;
;;;529      huart->RxState = HAL_UART_STATE_READY;
;;;530    
;;;531      return HAL_OK;
;;;532    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  f8940039          LDRB     r0,[r4,#0x39]         ;481
000010  b928              CBNZ     r0,|L4.30|
000012  2000              MOVS     r0,#0                 ;484
000014  f8840038          STRB     r0,[r4,#0x38]         ;484
000018  4620              MOV      r0,r4                 ;498
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L4.30|
00001e  2024              MOVS     r0,#0x24              ;502
000020  f8840039          STRB     r0,[r4,#0x39]         ;502
000024  6820              LDR      r0,[r4,#0]            ;505
000026  68c0              LDR      r0,[r0,#0xc]          ;505
000028  f4205000          BIC      r0,r0,#0x2000         ;505
00002c  6821              LDR      r1,[r4,#0]            ;505
00002e  60c8              STR      r0,[r1,#0xc]          ;505
000030  4620              MOV      r0,r4                 ;508
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;513
000038  6900              LDR      r0,[r0,#0x10]         ;513
00003a  f4206000          BIC      r0,r0,#0x800          ;513
00003e  6821              LDR      r1,[r4,#0]            ;513
000040  6108              STR      r0,[r1,#0x10]         ;513
000042  6820              LDR      r0,[r4,#0]            ;514
000044  6940              LDR      r0,[r0,#0x14]         ;514
000046  f020002a          BIC      r0,r0,#0x2a           ;514
00004a  6821              LDR      r1,[r4,#0]            ;514
00004c  6148              STR      r0,[r1,#0x14]         ;514
00004e  6820              LDR      r0,[r4,#0]            ;517
000050  6900              LDR      r0,[r0,#0x10]         ;517
000052  f4404080          ORR      r0,r0,#0x4000         ;517
000056  6821              LDR      r1,[r4,#0]            ;517
000058  6108              STR      r0,[r1,#0x10]         ;517
00005a  6820              LDR      r0,[r4,#0]            ;520
00005c  6900              LDR      r0,[r0,#0x10]         ;520
00005e  f0200020          BIC      r0,r0,#0x20           ;520
000062  6821              LDR      r1,[r4,#0]            ;520
000064  6108              STR      r0,[r1,#0x10]         ;520
000066  6820              LDR      r0,[r4,#0]            ;521
000068  6900              LDR      r0,[r0,#0x10]         ;521
00006a  4328              ORRS     r0,r0,r5              ;521
00006c  6821              LDR      r1,[r4,#0]            ;521
00006e  6108              STR      r0,[r1,#0x10]         ;521
000070  6820              LDR      r0,[r4,#0]            ;524
000072  68c0              LDR      r0,[r0,#0xc]          ;524
000074  f4405000          ORR      r0,r0,#0x2000         ;524
000078  6821              LDR      r1,[r4,#0]            ;524
00007a  60c8              STR      r0,[r1,#0xc]          ;524
00007c  2000              MOVS     r0,#0                 ;527
00007e  63e0              STR      r0,[r4,#0x3c]         ;527
000080  2020              MOVS     r0,#0x20              ;528
000082  f8840039          STRB     r0,[r4,#0x39]         ;528
000086  f884003a          STRB     r0,[r4,#0x3a]         ;529
00008a  2000              MOVS     r0,#0                 ;531
00008c  e7bd              B        |L4.10|
;;;533    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2286     */
;;;2287   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2288   {
;;;2289     /* Check the parameters */
;;;2290     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2291   
;;;2292     /* Process Locked */
;;;2293     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;2294   
;;;2295     huart->gState = HAL_UART_STATE_BUSY;
;;;2296   
;;;2297     /* Send break characters */
;;;2298     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
;;;2299   
;;;2300     huart->gState = HAL_UART_STATE_READY;
;;;2301   
;;;2302     /* Process Unlocked */
;;;2303     __HAL_UNLOCK(huart);
;;;2304   
;;;2305     return HAL_OK;
;;;2306   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;2293
000012  f8810038          STRB     r0,[r1,#0x38]         ;2293
000016  bf00              NOP                            ;2293
000018  2024              MOVS     r0,#0x24              ;2295
00001a  f8810039          STRB     r0,[r1,#0x39]         ;2295
00001e  6808              LDR      r0,[r1,#0]            ;2298
000020  68c0              LDR      r0,[r0,#0xc]          ;2298
000022  f0400001          ORR      r0,r0,#1              ;2298
000026  680a              LDR      r2,[r1,#0]            ;2298
000028  60d0              STR      r0,[r2,#0xc]          ;2298
00002a  2020              MOVS     r0,#0x20              ;2300
00002c  f8810039          STRB     r0,[r1,#0x39]         ;2300
000030  bf00              NOP                            ;2303
000032  2000              MOVS     r0,#0                 ;2303
000034  f8810038          STRB     r0,[r1,#0x38]         ;2303
000038  bf00              NOP                            ;2303
00003a  bf00              NOP                            ;2305
00003c  e7e7              B        |L5.14|
;;;2307   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2313     */
;;;2314   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2315   {
;;;2316     /* Check the parameters */
;;;2317     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2318   
;;;2319     /* Process Locked */
;;;2320     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;2321   
;;;2322     huart->gState = HAL_UART_STATE_BUSY;
;;;2323   
;;;2324     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;2325     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2326   
;;;2327     huart->gState = HAL_UART_STATE_READY;
;;;2328   
;;;2329     /* Process Unlocked */
;;;2330     __HAL_UNLOCK(huart);
;;;2331   
;;;2332     return HAL_OK;
;;;2333   }
00000e  4770              BX       lr
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;2320
000012  f8810038          STRB     r0,[r1,#0x38]         ;2320
000016  bf00              NOP                            ;2320
000018  2024              MOVS     r0,#0x24              ;2322
00001a  f8810039          STRB     r0,[r1,#0x39]         ;2322
00001e  6808              LDR      r0,[r1,#0]            ;2325
000020  68c0              LDR      r0,[r0,#0xc]          ;2325
000022  f0400002          ORR      r0,r0,#2              ;2325
000026  680a              LDR      r2,[r1,#0]            ;2325
000028  60d0              STR      r0,[r2,#0xc]          ;2325
00002a  2020              MOVS     r0,#0x20              ;2327
00002c  f8810039          STRB     r0,[r1,#0x39]         ;2327
000030  bf00              NOP                            ;2330
000032  2000              MOVS     r0,#0                 ;2330
000034  f8810038          STRB     r0,[r1,#0x38]         ;2330
000038  bf00              NOP                            ;2330
00003a  bf00              NOP                            ;2332
00003c  e7e7              B        |L6.14|
;;;2334   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;2340     */
;;;2341   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2342   {
;;;2343     /* Check the parameters */
;;;2344     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2345   
;;;2346     /* Process Locked */
;;;2347     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910038          LDRB     r0,[r1,#0x38]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;2348   
;;;2349     huart->gState = HAL_UART_STATE_BUSY;
;;;2350   
;;;2351     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;2352     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2353   
;;;2354     huart->gState = HAL_UART_STATE_READY;
;;;2355   
;;;2356     /* Process Unlocked */
;;;2357     __HAL_UNLOCK(huart);
;;;2358   
;;;2359     return HAL_OK;
;;;2360   }
00000e  4770              BX       lr
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;2347
000012  f8810038          STRB     r0,[r1,#0x38]         ;2347
000016  bf00              NOP                            ;2347
000018  2024              MOVS     r0,#0x24              ;2349
00001a  f8810039          STRB     r0,[r1,#0x39]         ;2349
00001e  6808              LDR      r0,[r1,#0]            ;2352
000020  68c0              LDR      r0,[r0,#0xc]          ;2352
000022  f0200002          BIC      r0,r0,#2              ;2352
000026  680a              LDR      r2,[r1,#0]            ;2352
000028  60d0              STR      r0,[r2,#0xc]          ;2352
00002a  2020              MOVS     r0,#0x20              ;2354
00002c  f8810039          STRB     r0,[r1,#0x39]         ;2354
000030  bf00              NOP                            ;2357
000032  2000              MOVS     r0,#0                 ;2357
000034  f8810038          STRB     r0,[r1,#0x38]         ;2357
000038  bf00              NOP                            ;2357
00003a  bf00              NOP                            ;2359
00003c  e7e7              B        |L7.14|
;;;2361   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;545      */
;;;546    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;547    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;548      /* Check the UART handle allocation */
;;;549      if (huart == NULL)
000008  b90c              CBNZ     r4,|L8.14|
;;;550      {
;;;551        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;552      }
;;;553    
;;;554      /* Check the parameters */
;;;555      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;556    
;;;557      /* Check the Address & wake up method parameters */
;;;558      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;559      assert_param(IS_UART_ADDRESS(Address));
;;;560      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;561      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;562    
;;;563      if (huart->gState == HAL_UART_STATE_RESET)
;;;564      {
;;;565        /* Allocate lock resource and initialize it */
;;;566        huart->Lock = HAL_UNLOCKED;
;;;567    
;;;568    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;569        UART_InitCallbacksToDefault(huart);
;;;570    
;;;571        if (huart->MspInitCallback == NULL)
;;;572        {
;;;573          huart->MspInitCallback = HAL_UART_MspInit;
;;;574        }
;;;575    
;;;576        /* Init the low level hardware */
;;;577        huart->MspInitCallback(huart);
;;;578    #else
;;;579        /* Init the low level hardware : GPIO, CLOCK */
;;;580        HAL_UART_MspInit(huart);
;;;581    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;582      }
;;;583    
;;;584      huart->gState = HAL_UART_STATE_BUSY;
;;;585    
;;;586      /* Disable the peripheral */
;;;587      __HAL_UART_DISABLE(huart);
;;;588    
;;;589      /* Set the UART Communication parameters */
;;;590      UART_SetConfig(huart);
;;;591    
;;;592      /* In Multi-Processor mode, the following bits must be kept cleared:
;;;593         - LINEN and CLKEN bits in the USART_CR2 register,
;;;594         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;595      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;596      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;597    
;;;598      /* Set the USART address node */
;;;599      CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
;;;600      SET_BIT(huart->Instance->CR2, Address);
;;;601    
;;;602      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;603      CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
;;;604      SET_BIT(huart->Instance->CR1, WakeUpMethod);
;;;605    
;;;606      /* Enable the peripheral */
;;;607      __HAL_UART_ENABLE(huart);
;;;608    
;;;609      /* Initialize the UART state */
;;;610      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;611      huart->gState = HAL_UART_STATE_READY;
;;;612      huart->RxState = HAL_UART_STATE_READY;
;;;613    
;;;614      return HAL_OK;
;;;615    }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  f8940039          LDRB     r0,[r4,#0x39]         ;563
000012  b928              CBNZ     r0,|L8.32|
000014  2000              MOVS     r0,#0                 ;566
000016  f8840038          STRB     r0,[r4,#0x38]         ;566
00001a  4620              MOV      r0,r4                 ;580
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L8.32|
000020  2024              MOVS     r0,#0x24              ;584
000022  f8840039          STRB     r0,[r4,#0x39]         ;584
000026  6820              LDR      r0,[r4,#0]            ;587
000028  68c0              LDR      r0,[r0,#0xc]          ;587
00002a  f4205000          BIC      r0,r0,#0x2000         ;587
00002e  6821              LDR      r1,[r4,#0]            ;587
000030  60c8              STR      r0,[r1,#0xc]          ;587
000032  4620              MOV      r0,r4                 ;590
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;595
00003a  6900              LDR      r0,[r0,#0x10]         ;595
00003c  f4204090          BIC      r0,r0,#0x4800         ;595
000040  6821              LDR      r1,[r4,#0]            ;595
000042  6108              STR      r0,[r1,#0x10]         ;595
000044  6820              LDR      r0,[r4,#0]            ;596
000046  6940              LDR      r0,[r0,#0x14]         ;596
000048  f020002a          BIC      r0,r0,#0x2a           ;596
00004c  6821              LDR      r1,[r4,#0]            ;596
00004e  6148              STR      r0,[r1,#0x14]         ;596
000050  6820              LDR      r0,[r4,#0]            ;599
000052  6900              LDR      r0,[r0,#0x10]         ;599
000054  f020000f          BIC      r0,r0,#0xf            ;599
000058  6821              LDR      r1,[r4,#0]            ;599
00005a  6108              STR      r0,[r1,#0x10]         ;599
00005c  6820              LDR      r0,[r4,#0]            ;600
00005e  6900              LDR      r0,[r0,#0x10]         ;600
000060  4328              ORRS     r0,r0,r5              ;600
000062  6821              LDR      r1,[r4,#0]            ;600
000064  6108              STR      r0,[r1,#0x10]         ;600
000066  6820              LDR      r0,[r4,#0]            ;603
000068  68c0              LDR      r0,[r0,#0xc]          ;603
00006a  f4206000          BIC      r0,r0,#0x800          ;603
00006e  6821              LDR      r1,[r4,#0]            ;603
000070  60c8              STR      r0,[r1,#0xc]          ;603
000072  6820              LDR      r0,[r4,#0]            ;604
000074  68c0              LDR      r0,[r0,#0xc]          ;604
000076  4330              ORRS     r0,r0,r6              ;604
000078  6821              LDR      r1,[r4,#0]            ;604
00007a  60c8              STR      r0,[r1,#0xc]          ;604
00007c  6820              LDR      r0,[r4,#0]            ;607
00007e  68c0              LDR      r0,[r0,#0xc]          ;607
000080  f4405000          ORR      r0,r0,#0x2000         ;607
000084  6821              LDR      r1,[r4,#0]            ;607
000086  60c8              STR      r0,[r1,#0xc]          ;607
000088  2000              MOVS     r0,#0                 ;610
00008a  63e0              STR      r0,[r4,#0x3c]         ;610
00008c  2020              MOVS     r0,#0x20              ;611
00008e  f8840039          STRB     r0,[r4,#0x39]         ;611
000092  f884003a          STRB     r0,[r4,#0x3a]         ;612
000096  2000              MOVS     r0,#0                 ;614
000098  e7b8              B        |L8.12|
;;;616    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1535   */
;;;1536   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1537   {
000002  4604              MOV      r4,r0
;;;1538     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1539     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f42070f0          BIC      r0,r0,#0x1e0
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1540     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;1541   
;;;1542     /* Disable the UART DMA Tx request if enabled */
;;;1543     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0000080          AND      r0,r0,#0x80
000024  2880              CMP      r0,#0x80
000026  d117              BNE      |L9.88|
;;;1544     {
;;;1545       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000028  6820              LDR      r0,[r4,#0]
00002a  6940              LDR      r0,[r0,#0x14]
00002c  f0200080          BIC      r0,r0,#0x80
000030  6821              LDR      r1,[r4,#0]
000032  6148              STR      r0,[r1,#0x14]
;;;1546   
;;;1547       /* Abort the UART DMA Tx stream: use blocking DMA Abort API (no callback) */
;;;1548       if (huart->hdmatx != NULL)
000034  6b20              LDR      r0,[r4,#0x30]
000036  b178              CBZ      r0,|L9.88|
;;;1549       {
;;;1550         /* Set the UART DMA Abort callback to Null.
;;;1551            No call back execution at end of DMA abort procedure */
;;;1552         huart->hdmatx->XferAbortCallback = NULL;
000038  2000              MOVS     r0,#0
00003a  6b21              LDR      r1,[r4,#0x30]
00003c  6508              STR      r0,[r1,#0x50]
;;;1553   
;;;1554         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
00003e  6b20              LDR      r0,[r4,#0x30]
000040  f7fffffe          BL       HAL_DMA_Abort
000044  b140              CBZ      r0,|L9.88|
;;;1555         {
;;;1556           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
000046  6b20              LDR      r0,[r4,#0x30]
000048  f7fffffe          BL       HAL_DMA_GetError
00004c  2820              CMP      r0,#0x20
00004e  d103              BNE      |L9.88|
;;;1557           {
;;;1558             /* Set error code to DMA */
;;;1559             huart->ErrorCode = HAL_UART_ERROR_DMA;
000050  2010              MOVS     r0,#0x10
000052  63e0              STR      r0,[r4,#0x3c]
;;;1560   
;;;1561             return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L9.86|
;;;1562           }
;;;1563         }
;;;1564       }
;;;1565     }
;;;1566   
;;;1567     /* Disable the UART DMA Rx request if enabled */
;;;1568     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1569     {
;;;1570       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1571   
;;;1572       /* Abort the UART DMA Rx stream: use blocking DMA Abort API (no callback) */
;;;1573       if (huart->hdmarx != NULL)
;;;1574       {
;;;1575         /* Set the UART DMA Abort callback to Null.
;;;1576            No call back execution at end of DMA abort procedure */
;;;1577         huart->hdmarx->XferAbortCallback = NULL;
;;;1578   
;;;1579         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
;;;1580         {
;;;1581           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
;;;1582           {
;;;1583             /* Set error code to DMA */
;;;1584             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1585   
;;;1586             return HAL_TIMEOUT;
;;;1587           }
;;;1588         }
;;;1589       }
;;;1590     }
;;;1591   
;;;1592     /* Reset Tx and Rx transfer counters */
;;;1593     huart->TxXferCount = 0x00U;
;;;1594     huart->RxXferCount = 0x00U;
;;;1595   
;;;1596     /* Reset ErrorCode */
;;;1597     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1598   
;;;1599     /* Restore huart->RxState and huart->gState to Ready */
;;;1600     huart->RxState = HAL_UART_STATE_READY;
;;;1601     huart->gState = HAL_UART_STATE_READY;
;;;1602   
;;;1603     return HAL_OK;
;;;1604   }
000056  bd10              POP      {r4,pc}
                  |L9.88|
000058  6820              LDR      r0,[r4,#0]            ;1568
00005a  6940              LDR      r0,[r0,#0x14]         ;1568
00005c  f0000040          AND      r0,r0,#0x40           ;1568
000060  2840              CMP      r0,#0x40              ;1568
000062  d117              BNE      |L9.148|
000064  6820              LDR      r0,[r4,#0]            ;1570
000066  6940              LDR      r0,[r0,#0x14]         ;1570
000068  f0200040          BIC      r0,r0,#0x40           ;1570
00006c  6821              LDR      r1,[r4,#0]            ;1570
00006e  6148              STR      r0,[r1,#0x14]         ;1570
000070  6b60              LDR      r0,[r4,#0x34]         ;1573
000072  b178              CBZ      r0,|L9.148|
000074  2000              MOVS     r0,#0                 ;1577
000076  6b61              LDR      r1,[r4,#0x34]         ;1577
000078  6508              STR      r0,[r1,#0x50]         ;1577
00007a  6b60              LDR      r0,[r4,#0x34]         ;1579
00007c  f7fffffe          BL       HAL_DMA_Abort
000080  b140              CBZ      r0,|L9.148|
000082  6b60              LDR      r0,[r4,#0x34]         ;1581
000084  f7fffffe          BL       HAL_DMA_GetError
000088  2820              CMP      r0,#0x20              ;1581
00008a  d103              BNE      |L9.148|
00008c  2010              MOVS     r0,#0x10              ;1584
00008e  63e0              STR      r0,[r4,#0x3c]         ;1584
000090  2003              MOVS     r0,#3                 ;1586
000092  e7e0              B        |L9.86|
                  |L9.148|
000094  2000              MOVS     r0,#0                 ;1593
000096  84e0              STRH     r0,[r4,#0x26]         ;1593
000098  85e0              STRH     r0,[r4,#0x2e]         ;1594
00009a  63e0              STR      r0,[r4,#0x3c]         ;1597
00009c  2020              MOVS     r0,#0x20              ;1600
00009e  f884003a          STRB     r0,[r4,#0x3a]         ;1600
0000a2  f8840039          STRB     r0,[r4,#0x39]         ;1601
0000a6  2000              MOVS     r0,#0                 ;1603
0000a8  e7d5              B        |L9.86|
;;;1605   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2217     */
;;;2218   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2219   {
;;;2220     /* Prevent unused argument(s) compilation warning */
;;;2221     UNUSED(huart);
;;;2222   
;;;2223     /* NOTE : This function should not be modified, when the callback is needed,
;;;2224               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2225      */
;;;2226   }
;;;2227   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1668   */
;;;1669   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1670   {
000002  4604              MOV      r4,r0
;;;1671     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1672     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f4207090          BIC      r0,r0,#0x120
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1673     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;1674   
;;;1675     /* Disable the UART DMA Rx request if enabled */
;;;1676     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0000040          AND      r0,r0,#0x40
000024  2840              CMP      r0,#0x40
000026  d117              BNE      |L11.88|
;;;1677     {
;;;1678       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000028  6820              LDR      r0,[r4,#0]
00002a  6940              LDR      r0,[r0,#0x14]
00002c  f0200040          BIC      r0,r0,#0x40
000030  6821              LDR      r1,[r4,#0]
000032  6148              STR      r0,[r1,#0x14]
;;;1679   
;;;1680       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;1681       if (huart->hdmarx != NULL)
000034  6b60              LDR      r0,[r4,#0x34]
000036  b178              CBZ      r0,|L11.88|
;;;1682       {
;;;1683         /* Set the UART DMA Abort callback to Null.
;;;1684            No call back execution at end of DMA abort procedure */
;;;1685         huart->hdmarx->XferAbortCallback = NULL;
000038  2000              MOVS     r0,#0
00003a  6b61              LDR      r1,[r4,#0x34]
00003c  6508              STR      r0,[r1,#0x50]
;;;1686   
;;;1687         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
00003e  6b60              LDR      r0,[r4,#0x34]
000040  f7fffffe          BL       HAL_DMA_Abort
000044  b140              CBZ      r0,|L11.88|
;;;1688         {
;;;1689           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
000046  6b60              LDR      r0,[r4,#0x34]
000048  f7fffffe          BL       HAL_DMA_GetError
00004c  2820              CMP      r0,#0x20
00004e  d103              BNE      |L11.88|
;;;1690           {
;;;1691             /* Set error code to DMA */
;;;1692             huart->ErrorCode = HAL_UART_ERROR_DMA;
000050  2010              MOVS     r0,#0x10
000052  63e0              STR      r0,[r4,#0x3c]
;;;1693   
;;;1694             return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L11.86|
;;;1695           }
;;;1696         }
;;;1697       }
;;;1698     }
;;;1699   
;;;1700     /* Reset Rx transfer counter */
;;;1701     huart->RxXferCount = 0x00U;
;;;1702   
;;;1703     /* Restore huart->RxState to Ready */
;;;1704     huart->RxState = HAL_UART_STATE_READY;
;;;1705   
;;;1706     return HAL_OK;
;;;1707   }
000056  bd10              POP      {r4,pc}
                  |L11.88|
000058  2000              MOVS     r0,#0                 ;1701
00005a  85e0              STRH     r0,[r4,#0x2e]         ;1701
00005c  2020              MOVS     r0,#0x20              ;1704
00005e  f884003a          STRB     r0,[r4,#0x3a]         ;1704
000062  2000              MOVS     r0,#0                 ;1706
000064  e7f7              B        |L11.86|
;;;1708   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2247     */
;;;2248   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2249   {
;;;2250     /* Prevent unused argument(s) compilation warning */
;;;2251     UNUSED(huart);
;;;2252   
;;;2253     /* NOTE : This function should not be modified, when the callback is needed,
;;;2254               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2255      */
;;;2256   }
;;;2257   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1927   */
;;;1928   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1929   {
000002  4604              MOV      r4,r0
;;;1930     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1931     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f4207090          BIC      r0,r0,#0x120
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1932     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;1933   
;;;1934     /* Disable the UART DMA Rx request if enabled */
;;;1935     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0000040          AND      r0,r0,#0x40
000024  2840              CMP      r0,#0x40
000026  d11b              BNE      |L13.96|
;;;1936     {
;;;1937       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000028  6820              LDR      r0,[r4,#0]
00002a  6940              LDR      r0,[r0,#0x14]
00002c  f0200040          BIC      r0,r0,#0x40
000030  6821              LDR      r1,[r4,#0]
000032  6148              STR      r0,[r1,#0x14]
;;;1938   
;;;1939       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;1940       if (huart->hdmarx != NULL)
000034  6b60              LDR      r0,[r4,#0x34]
000036  b150              CBZ      r0,|L13.78|
;;;1941       {
;;;1942         /* Set the UART DMA Abort callback :
;;;1943            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1944         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
000038  480e              LDR      r0,|L13.116|
00003a  6b61              LDR      r1,[r4,#0x34]
00003c  6508              STR      r0,[r1,#0x50]
;;;1945   
;;;1946         /* Abort DMA RX */
;;;1947         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00003e  6b60              LDR      r0,[r4,#0x34]
000040  f7fffffe          BL       HAL_DMA_Abort_IT
000044  b1a0              CBZ      r0,|L13.112|
;;;1948         {
;;;1949           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1950           huart->hdmarx->XferAbortCallback(huart->hdmarx);
000046  6b60              LDR      r0,[r4,#0x34]
000048  6d01              LDR      r1,[r0,#0x50]
00004a  4788              BLX      r1
00004c  e010              B        |L13.112|
                  |L13.78|
;;;1951         }
;;;1952       }
;;;1953       else
;;;1954       {
;;;1955         /* Reset Rx transfer counter */
;;;1956         huart->RxXferCount = 0x00U;
00004e  2000              MOVS     r0,#0
000050  85e0              STRH     r0,[r4,#0x2e]
;;;1957   
;;;1958         /* Restore huart->RxState to Ready */
;;;1959         huart->RxState = HAL_UART_STATE_READY;
000052  2020              MOVS     r0,#0x20
000054  f884003a          STRB     r0,[r4,#0x3a]
;;;1960   
;;;1961         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1962   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1963         /* Call registered Abort Receive Complete Callback */
;;;1964         huart->AbortReceiveCpltCallback(huart);
;;;1965   #else
;;;1966         /* Call legacy weak Abort Receive Complete Callback */
;;;1967         HAL_UART_AbortReceiveCpltCallback(huart);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
00005e  e007              B        |L13.112|
                  |L13.96|
;;;1968   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1969       }
;;;1970     }
;;;1971     else
;;;1972     {
;;;1973       /* Reset Rx transfer counter */
;;;1974       huart->RxXferCount = 0x00U;
000060  2000              MOVS     r0,#0
000062  85e0              STRH     r0,[r4,#0x2e]
;;;1975   
;;;1976       /* Restore huart->RxState to Ready */
;;;1977       huart->RxState = HAL_UART_STATE_READY;
000064  2020              MOVS     r0,#0x20
000066  f884003a          STRB     r0,[r4,#0x3a]
;;;1978   
;;;1979       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1980   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1981       /* Call registered Abort Receive Complete Callback */
;;;1982       huart->AbortReceiveCpltCallback(huart);
;;;1983   #else
;;;1984       /* Call legacy weak Abort Receive Complete Callback */
;;;1985       HAL_UART_AbortReceiveCpltCallback(huart);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.112|
;;;1986   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1987     }
;;;1988   
;;;1989     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1990   }
000072  bd10              POP      {r4,pc}
;;;1991   
                          ENDP

                  |L13.116|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1617   */
;;;1618   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1619   {
000002  4604              MOV      r4,r0
;;;1620     /* Disable TXEIE and TCIE interrupts */
;;;1621     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f02000c0          BIC      r0,r0,#0xc0
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1622   
;;;1623     /* Disable the UART DMA Tx request if enabled */
;;;1624     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0000080          AND      r0,r0,#0x80
000018  2880              CMP      r0,#0x80
00001a  d117              BNE      |L14.76|
;;;1625     {
;;;1626       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6148              STR      r0,[r1,#0x14]
;;;1627   
;;;1628       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;1629       if (huart->hdmatx != NULL)
000028  6b20              LDR      r0,[r4,#0x30]
00002a  b178              CBZ      r0,|L14.76|
;;;1630       {
;;;1631         /* Set the UART DMA Abort callback to Null.
;;;1632            No call back execution at end of DMA abort procedure */
;;;1633         huart->hdmatx->XferAbortCallback = NULL;
00002c  2000              MOVS     r0,#0
00002e  6b21              LDR      r1,[r4,#0x30]
000030  6508              STR      r0,[r1,#0x50]
;;;1634   
;;;1635         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000032  6b20              LDR      r0,[r4,#0x30]
000034  f7fffffe          BL       HAL_DMA_Abort
000038  b140              CBZ      r0,|L14.76|
;;;1636         {
;;;1637           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
00003a  6b20              LDR      r0,[r4,#0x30]
00003c  f7fffffe          BL       HAL_DMA_GetError
000040  2820              CMP      r0,#0x20
000042  d103              BNE      |L14.76|
;;;1638           {
;;;1639             /* Set error code to DMA */
;;;1640             huart->ErrorCode = HAL_UART_ERROR_DMA;
000044  2010              MOVS     r0,#0x10
000046  63e0              STR      r0,[r4,#0x3c]
;;;1641   
;;;1642             return HAL_TIMEOUT;
000048  2003              MOVS     r0,#3
                  |L14.74|
;;;1643           }
;;;1644         }
;;;1645       }
;;;1646     }
;;;1647   
;;;1648     /* Reset Tx transfer counter */
;;;1649     huart->TxXferCount = 0x00U;
;;;1650   
;;;1651     /* Restore huart->gState to Ready */
;;;1652     huart->gState = HAL_UART_STATE_READY;
;;;1653   
;;;1654     return HAL_OK;
;;;1655   }
00004a  bd10              POP      {r4,pc}
                  |L14.76|
00004c  2000              MOVS     r0,#0                 ;1649
00004e  84e0              STRH     r0,[r4,#0x26]         ;1649
000050  2020              MOVS     r0,#0x20              ;1652
000052  f8840039          STRB     r0,[r4,#0x39]         ;1652
000056  2000              MOVS     r0,#0                 ;1654
000058  e7f7              B        |L14.74|
;;;1656   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2232     */
;;;2233   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2234   {
;;;2235     /* Prevent unused argument(s) compilation warning */
;;;2236     UNUSED(huart);
;;;2237   
;;;2238     /* NOTE : This function should not be modified, when the callback is needed,
;;;2239               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2240      */
;;;2241   }
;;;2242   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1850   */
;;;1851   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1852   {
000002  4604              MOV      r4,r0
;;;1853     /* Disable TXEIE and TCIE interrupts */
;;;1854     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f02000c0          BIC      r0,r0,#0xc0
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1855   
;;;1856     /* Disable the UART DMA Tx request if enabled */
;;;1857     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000010  6820              LDR      r0,[r4,#0]
000012  6940              LDR      r0,[r0,#0x14]
000014  f0000080          AND      r0,r0,#0x80
000018  2880              CMP      r0,#0x80
00001a  d11b              BNE      |L16.84|
;;;1858     {
;;;1859       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6940              LDR      r0,[r0,#0x14]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6148              STR      r0,[r1,#0x14]
;;;1860   
;;;1861       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;1862       if (huart->hdmatx != NULL)
000028  6b20              LDR      r0,[r4,#0x30]
00002a  b150              CBZ      r0,|L16.66|
;;;1863       {
;;;1864         /* Set the UART DMA Abort callback :
;;;1865            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1866         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
00002c  480e              LDR      r0,|L16.104|
00002e  6b21              LDR      r1,[r4,#0x30]
000030  6508              STR      r0,[r1,#0x50]
;;;1867   
;;;1868         /* Abort DMA TX */
;;;1869         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000032  6b20              LDR      r0,[r4,#0x30]
000034  f7fffffe          BL       HAL_DMA_Abort_IT
000038  b1a0              CBZ      r0,|L16.100|
;;;1870         {
;;;1871           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1872           huart->hdmatx->XferAbortCallback(huart->hdmatx);
00003a  6b20              LDR      r0,[r4,#0x30]
00003c  6d01              LDR      r1,[r0,#0x50]
00003e  4788              BLX      r1
000040  e010              B        |L16.100|
                  |L16.66|
;;;1873         }
;;;1874       }
;;;1875       else
;;;1876       {
;;;1877         /* Reset Tx transfer counter */
;;;1878         huart->TxXferCount = 0x00U;
000042  2000              MOVS     r0,#0
000044  84e0              STRH     r0,[r4,#0x26]
;;;1879   
;;;1880         /* Restore huart->gState to Ready */
;;;1881         huart->gState = HAL_UART_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  f8840039          STRB     r0,[r4,#0x39]
;;;1882   
;;;1883         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1884   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1885         /* Call registered Abort Transmit Complete Callback */
;;;1886         huart->AbortTransmitCpltCallback(huart);
;;;1887   #else
;;;1888         /* Call legacy weak Abort Transmit Complete Callback */
;;;1889         HAL_UART_AbortTransmitCpltCallback(huart);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
000052  e007              B        |L16.100|
                  |L16.84|
;;;1890   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1891       }
;;;1892     }
;;;1893     else
;;;1894     {
;;;1895       /* Reset Tx transfer counter */
;;;1896       huart->TxXferCount = 0x00U;
000054  2000              MOVS     r0,#0
000056  84e0              STRH     r0,[r4,#0x26]
;;;1897   
;;;1898       /* Restore huart->gState to Ready */
;;;1899       huart->gState = HAL_UART_STATE_READY;
000058  2020              MOVS     r0,#0x20
00005a  f8840039          STRB     r0,[r4,#0x39]
;;;1900   
;;;1901       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1902   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1903       /* Call registered Abort Transmit Complete Callback */
;;;1904       huart->AbortTransmitCpltCallback(huart);
;;;1905   #else
;;;1906       /* Call legacy weak Abort Transmit Complete Callback */
;;;1907       HAL_UART_AbortTransmitCpltCallback(huart);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.100|
;;;1908   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1909     }
;;;1910   
;;;1911     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1912   }
000066  bd10              POP      {r4,pc}
;;;1913   
                          ENDP

                  |L16.104|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1722   */
;;;1723   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1724   {
000002  4604              MOV      r4,r0
;;;1725     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;1726   
;;;1727     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1728     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f42070f0          BIC      r0,r0,#0x1e0
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;1729     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6940              LDR      r0,[r0,#0x14]
000016  f0200001          BIC      r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6148              STR      r0,[r1,#0x14]
;;;1730   
;;;1731     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1732        before any call to DMA Abort functions */
;;;1733     /* DMA Tx Handle is valid */
;;;1734     if (huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  b160              CBZ      r0,|L17.60|
;;;1735     {
;;;1736       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1737          Otherwise, set it to NULL */
;;;1738       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6820              LDR      r0,[r4,#0]
000024  6940              LDR      r0,[r0,#0x14]
000026  f0000080          AND      r0,r0,#0x80
00002a  2880              CMP      r0,#0x80
00002c  d103              BNE      |L17.54|
;;;1739       {
;;;1740         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
00002e  482a              LDR      r0,|L17.216|
000030  6b21              LDR      r1,[r4,#0x30]
000032  6508              STR      r0,[r1,#0x50]
000034  e002              B        |L17.60|
                  |L17.54|
;;;1741       }
;;;1742       else
;;;1743       {
;;;1744         huart->hdmatx->XferAbortCallback = NULL;
000036  2000              MOVS     r0,#0
000038  6b21              LDR      r1,[r4,#0x30]
00003a  6508              STR      r0,[r1,#0x50]
                  |L17.60|
;;;1745       }
;;;1746     }
;;;1747     /* DMA Rx Handle is valid */
;;;1748     if (huart->hdmarx != NULL)
00003c  6b60              LDR      r0,[r4,#0x34]
00003e  b160              CBZ      r0,|L17.90|
;;;1749     {
;;;1750       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1751          Otherwise, set it to NULL */
;;;1752       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000040  6820              LDR      r0,[r4,#0]
000042  6940              LDR      r0,[r0,#0x14]
000044  f0000040          AND      r0,r0,#0x40
000048  2840              CMP      r0,#0x40
00004a  d103              BNE      |L17.84|
;;;1753       {
;;;1754         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00004c  4823              LDR      r0,|L17.220|
00004e  6b61              LDR      r1,[r4,#0x34]
000050  6508              STR      r0,[r1,#0x50]
000052  e002              B        |L17.90|
                  |L17.84|
;;;1755       }
;;;1756       else
;;;1757       {
;;;1758         huart->hdmarx->XferAbortCallback = NULL;
000054  2000              MOVS     r0,#0
000056  6b61              LDR      r1,[r4,#0x34]
000058  6508              STR      r0,[r1,#0x50]
                  |L17.90|
;;;1759       }
;;;1760     }
;;;1761   
;;;1762     /* Disable the UART DMA Tx request if enabled */
;;;1763     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00005a  6820              LDR      r0,[r4,#0]
00005c  6940              LDR      r0,[r0,#0x14]
00005e  f0000080          AND      r0,r0,#0x80
000062  2880              CMP      r0,#0x80
000064  d110              BNE      |L17.136|
;;;1764     {
;;;1765       /* Disable DMA Tx at UART level */
;;;1766       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000066  6820              LDR      r0,[r4,#0]
000068  6940              LDR      r0,[r0,#0x14]
00006a  f0200080          BIC      r0,r0,#0x80
00006e  6821              LDR      r1,[r4,#0]
000070  6148              STR      r0,[r1,#0x14]
;;;1767   
;;;1768       /* Abort the UART DMA Tx stream : use non blocking DMA Abort API (callback) */
;;;1769       if (huart->hdmatx != NULL)
000072  6b20              LDR      r0,[r4,#0x30]
000074  b140              CBZ      r0,|L17.136|
;;;1770       {
;;;1771         /* UART Tx DMA Abort callback has already been initialised :
;;;1772            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1773   
;;;1774         /* Abort DMA TX */
;;;1775         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000076  6b20              LDR      r0,[r4,#0x30]
000078  f7fffffe          BL       HAL_DMA_Abort_IT
00007c  b118              CBZ      r0,|L17.134|
;;;1776         {
;;;1777           huart->hdmatx->XferAbortCallback = NULL;
00007e  2000              MOVS     r0,#0
000080  6b21              LDR      r1,[r4,#0x30]
000082  6508              STR      r0,[r1,#0x50]
000084  e000              B        |L17.136|
                  |L17.134|
;;;1778         }
;;;1779         else
;;;1780         {
;;;1781           AbortCplt = 0x00U;
000086  2500              MOVS     r5,#0
                  |L17.136|
;;;1782         }
;;;1783       }
;;;1784     }
;;;1785   
;;;1786     /* Disable the UART DMA Rx request if enabled */
;;;1787     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000088  6820              LDR      r0,[r4,#0]
00008a  6940              LDR      r0,[r0,#0x14]
00008c  f0000040          AND      r0,r0,#0x40
000090  2840              CMP      r0,#0x40
000092  d111              BNE      |L17.184|
;;;1788     {
;;;1789       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000094  6820              LDR      r0,[r4,#0]
000096  6940              LDR      r0,[r0,#0x14]
000098  f0200040          BIC      r0,r0,#0x40
00009c  6821              LDR      r1,[r4,#0]
00009e  6148              STR      r0,[r1,#0x14]
;;;1790   
;;;1791       /* Abort the UART DMA Rx stream : use non blocking DMA Abort API (callback) */
;;;1792       if (huart->hdmarx != NULL)
0000a0  6b60              LDR      r0,[r4,#0x34]
0000a2  b148              CBZ      r0,|L17.184|
;;;1793       {
;;;1794         /* UART Rx DMA Abort callback has already been initialised :
;;;1795            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1796   
;;;1797         /* Abort DMA RX */
;;;1798         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000a4  6b60              LDR      r0,[r4,#0x34]
0000a6  f7fffffe          BL       HAL_DMA_Abort_IT
0000aa  b120              CBZ      r0,|L17.182|
;;;1799         {
;;;1800           huart->hdmarx->XferAbortCallback = NULL;
0000ac  2000              MOVS     r0,#0
0000ae  6b61              LDR      r1,[r4,#0x34]
0000b0  6508              STR      r0,[r1,#0x50]
;;;1801           AbortCplt = 0x01U;
0000b2  2501              MOVS     r5,#1
0000b4  e000              B        |L17.184|
                  |L17.182|
;;;1802         }
;;;1803         else
;;;1804         {
;;;1805           AbortCplt = 0x00U;
0000b6  2500              MOVS     r5,#0
                  |L17.184|
;;;1806         }
;;;1807       }
;;;1808     }
;;;1809   
;;;1810     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1811     if (AbortCplt == 0x01U)
0000b8  2d01              CMP      r5,#1
0000ba  d10b              BNE      |L17.212|
;;;1812     {
;;;1813       /* Reset Tx and Rx transfer counters */
;;;1814       huart->TxXferCount = 0x00U;
0000bc  2000              MOVS     r0,#0
0000be  84e0              STRH     r0,[r4,#0x26]
;;;1815       huart->RxXferCount = 0x00U;
0000c0  85e0              STRH     r0,[r4,#0x2e]
;;;1816   
;;;1817       /* Reset ErrorCode */
;;;1818       huart->ErrorCode = HAL_UART_ERROR_NONE;
0000c2  63e0              STR      r0,[r4,#0x3c]
;;;1819   
;;;1820       /* Restore huart->gState and huart->RxState to Ready */
;;;1821       huart->gState  = HAL_UART_STATE_READY;
0000c4  2020              MOVS     r0,#0x20
0000c6  f8840039          STRB     r0,[r4,#0x39]
;;;1822       huart->RxState = HAL_UART_STATE_READY;
0000ca  f884003a          STRB     r0,[r4,#0x3a]
;;;1823   
;;;1824       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1825   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1826       /* Call registered Abort complete callback */
;;;1827       huart->AbortCpltCallback(huart);
;;;1828   #else
;;;1829       /* Call legacy weak Abort complete callback */
;;;1830       HAL_UART_AbortCpltCallback(huart);
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.212|
;;;1831   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1832     }
;;;1833   
;;;1834     return HAL_OK;
0000d4  2000              MOVS     r0,#0
;;;1835   }
0000d6  bd70              POP      {r4-r6,pc}
;;;1836   
                          ENDP

                  |L17.216|
                          DCD      UART_DMATxAbortCallback
                  |L17.220|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1410     */
;;;1411   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1412   {
;;;1413     uint32_t dmarequest = 0x00U;
000002  2200              MOVS     r2,#0
;;;1414   
;;;1415     /* Process Locked */
;;;1416     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L18.18|
00000e  2002              MOVS     r0,#2
                  |L18.16|
;;;1417   
;;;1418     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
;;;1419     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
;;;1420     {
;;;1421       /* Disable the UART DMA Tx request */
;;;1422       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1423     }
;;;1424   
;;;1425     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1426     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1427     {
;;;1428       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1429       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1430       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1431   
;;;1432       /* Disable the UART DMA Rx request */
;;;1433       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1434     }
;;;1435   
;;;1436     /* Process Unlocked */
;;;1437     __HAL_UNLOCK(huart);
;;;1438   
;;;1439     return HAL_OK;
;;;1440   }
000010  4770              BX       lr
                  |L18.18|
000012  2001              MOVS     r0,#1                 ;1416
000014  f8810038          STRB     r0,[r1,#0x38]         ;1416
000018  bf00              NOP                            ;1416
00001a  6808              LDR      r0,[r1,#0]            ;1418
00001c  6940              LDR      r0,[r0,#0x14]         ;1418
00001e  f3c012c0          UBFX     r2,r0,#7,#1           ;1418
000022  f8910039          LDRB     r0,[r1,#0x39]         ;1419
000026  2821              CMP      r0,#0x21              ;1419
000028  d106              BNE      |L18.56|
00002a  b12a              CBZ      r2,|L18.56|
00002c  6808              LDR      r0,[r1,#0]            ;1422
00002e  6940              LDR      r0,[r0,#0x14]         ;1422
000030  f0200080          BIC      r0,r0,#0x80           ;1422
000034  680b              LDR      r3,[r1,#0]            ;1422
000036  6158              STR      r0,[r3,#0x14]         ;1422
                  |L18.56|
000038  6808              LDR      r0,[r1,#0]            ;1425
00003a  6940              LDR      r0,[r0,#0x14]         ;1425
00003c  f3c01280          UBFX     r2,r0,#6,#1           ;1425
000040  f891003a          LDRB     r0,[r1,#0x3a]         ;1426
000044  2822              CMP      r0,#0x22              ;1426
000046  d112              BNE      |L18.110|
000048  b18a              CBZ      r2,|L18.110|
00004a  6808              LDR      r0,[r1,#0]            ;1429
00004c  68c0              LDR      r0,[r0,#0xc]          ;1429
00004e  f4207080          BIC      r0,r0,#0x100          ;1429
000052  680b              LDR      r3,[r1,#0]            ;1429
000054  60d8              STR      r0,[r3,#0xc]          ;1429
000056  6808              LDR      r0,[r1,#0]            ;1430
000058  6940              LDR      r0,[r0,#0x14]         ;1430
00005a  f0200001          BIC      r0,r0,#1              ;1430
00005e  680b              LDR      r3,[r1,#0]            ;1430
000060  6158              STR      r0,[r3,#0x14]         ;1430
000062  6808              LDR      r0,[r1,#0]            ;1433
000064  6940              LDR      r0,[r0,#0x14]         ;1433
000066  f0200040          BIC      r0,r0,#0x40           ;1433
00006a  680b              LDR      r3,[r1,#0]            ;1433
00006c  6158              STR      r0,[r3,#0x14]         ;1433
                  |L18.110|
00006e  bf00              NOP                            ;1437
000070  2000              MOVS     r0,#0                 ;1437
000072  f8810038          STRB     r0,[r1,#0x38]         ;1437
000076  bf00              NOP                            ;1437
000078  bf00              NOP                            ;1439
00007a  e7c9              B        |L18.16|
;;;1441   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1447     */
;;;1448   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1449   {
000002  4601              MOV      r1,r0
;;;1450     /* Process Locked */
;;;1451     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910038          LDRB     r0,[r1,#0x38]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L19.18|
00000e  2002              MOVS     r0,#2
                  |L19.16|
;;;1452   
;;;1453     if (huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1454     {
;;;1455       /* Enable the UART DMA Tx request */
;;;1456       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1457     }
;;;1458   
;;;1459     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1460     {
;;;1461       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1462       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1463   
;;;1464       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1465       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1466       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1467   
;;;1468       /* Enable the UART DMA Rx request */
;;;1469       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1470     }
;;;1471   
;;;1472     /* Process Unlocked */
;;;1473     __HAL_UNLOCK(huart);
;;;1474   
;;;1475     return HAL_OK;
;;;1476   }
000010  bd08              POP      {r3,pc}
                  |L19.18|
000012  2001              MOVS     r0,#1                 ;1451
000014  f8810038          STRB     r0,[r1,#0x38]         ;1451
000018  bf00              NOP                            ;1451
00001a  f8910039          LDRB     r0,[r1,#0x39]         ;1453
00001e  2821              CMP      r0,#0x21              ;1453
000020  d105              BNE      |L19.46|
000022  6808              LDR      r0,[r1,#0]            ;1456
000024  6940              LDR      r0,[r0,#0x14]         ;1456
000026  f0400080          ORR      r0,r0,#0x80           ;1456
00002a  680a              LDR      r2,[r1,#0]            ;1456
00002c  6150              STR      r0,[r2,#0x14]         ;1456
                  |L19.46|
00002e  f891003a          LDRB     r0,[r1,#0x3a]         ;1459
000032  2822              CMP      r0,#0x22              ;1459
000034  d11c              BNE      |L19.112|
000036  bf00              NOP                            ;1462
000038  2000              MOVS     r0,#0                 ;1462
00003a  9000              STR      r0,[sp,#0]            ;1462
00003c  6808              LDR      r0,[r1,#0]            ;1462
00003e  6800              LDR      r0,[r0,#0]            ;1462
000040  9000              STR      r0,[sp,#0]            ;1462
000042  6808              LDR      r0,[r1,#0]            ;1462
000044  6840              LDR      r0,[r0,#4]            ;1462
000046  9000              STR      r0,[sp,#0]            ;1462
000048  bf00              NOP                            ;1462
00004a  bf00              NOP                            ;1462
00004c  6808              LDR      r0,[r1,#0]            ;1465
00004e  68c0              LDR      r0,[r0,#0xc]          ;1465
000050  f4407080          ORR      r0,r0,#0x100          ;1465
000054  680a              LDR      r2,[r1,#0]            ;1465
000056  60d0              STR      r0,[r2,#0xc]          ;1465
000058  6808              LDR      r0,[r1,#0]            ;1466
00005a  6940              LDR      r0,[r0,#0x14]         ;1466
00005c  f0400001          ORR      r0,r0,#1              ;1466
000060  680a              LDR      r2,[r1,#0]            ;1466
000062  6150              STR      r0,[r2,#0x14]         ;1466
000064  6808              LDR      r0,[r1,#0]            ;1469
000066  6940              LDR      r0,[r0,#0x14]         ;1469
000068  f0400040          ORR      r0,r0,#0x40           ;1469
00006c  680a              LDR      r2,[r1,#0]            ;1469
00006e  6150              STR      r0,[r2,#0x14]         ;1469
                  |L19.112|
000070  bf00              NOP                            ;1473
000072  2000              MOVS     r0,#0                 ;1473
000074  f8810038          STRB     r0,[r1,#0x38]         ;1473
000078  bf00              NOP                            ;1473
00007a  bf00              NOP                            ;1475
00007c  e7c8              B        |L19.16|
;;;1477   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1483     */
;;;1484   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1485   {
000002  4604              MOV      r4,r0
;;;1486     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;1487     /* The Lock is not implemented on this API to allow the user application
;;;1488        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1489        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1490        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1491        */
;;;1492   
;;;1493     /* Stop UART DMA Tx request if ongoing */
;;;1494     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000006  6820              LDR      r0,[r4,#0]
000008  6940              LDR      r0,[r0,#0x14]
00000a  f3c015c0          UBFX     r5,r0,#7,#1
;;;1495     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2821              CMP      r0,#0x21
000014  d10e              BNE      |L20.52|
000016  b16d              CBZ      r5,|L20.52|
;;;1496     {
;;;1497       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000018  6820              LDR      r0,[r4,#0]
00001a  6940              LDR      r0,[r0,#0x14]
00001c  f0200080          BIC      r0,r0,#0x80
000020  6821              LDR      r1,[r4,#0]
000022  6148              STR      r0,[r1,#0x14]
;;;1498   
;;;1499       /* Abort the UART DMA Tx stream */
;;;1500       if (huart->hdmatx != NULL)
000024  6b20              LDR      r0,[r4,#0x30]
000026  b110              CBZ      r0,|L20.46|
;;;1501       {
;;;1502         HAL_DMA_Abort(huart->hdmatx);
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f7fffffe          BL       HAL_DMA_Abort
                  |L20.46|
;;;1503       }
;;;1504       UART_EndTxTransfer(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_EndTxTransfer
                  |L20.52|
;;;1505     }
;;;1506   
;;;1507     /* Stop UART DMA Rx request if ongoing */
;;;1508     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000034  6820              LDR      r0,[r4,#0]
000036  6940              LDR      r0,[r0,#0x14]
000038  f3c01580          UBFX     r5,r0,#6,#1
;;;1509     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00003c  f894003a          LDRB     r0,[r4,#0x3a]
000040  2822              CMP      r0,#0x22
000042  d10e              BNE      |L20.98|
000044  b16d              CBZ      r5,|L20.98|
;;;1510     {
;;;1511       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000046  6820              LDR      r0,[r4,#0]
000048  6940              LDR      r0,[r0,#0x14]
00004a  f0200040          BIC      r0,r0,#0x40
00004e  6821              LDR      r1,[r4,#0]
000050  6148              STR      r0,[r1,#0x14]
;;;1512   
;;;1513       /* Abort the UART DMA Rx stream */
;;;1514       if (huart->hdmarx != NULL)
000052  6b60              LDR      r0,[r4,#0x34]
000054  b110              CBZ      r0,|L20.92|
;;;1515       {
;;;1516         HAL_DMA_Abort(huart->hdmarx);
000056  6b60              LDR      r0,[r4,#0x34]
000058  f7fffffe          BL       HAL_DMA_Abort
                  |L20.92|
;;;1517       }
;;;1518       UART_EndRxTransfer(huart);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       UART_EndRxTransfer
                  |L20.98|
;;;1519     }
;;;1520   
;;;1521     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;1522   }
000064  bd70              POP      {r4-r6,pc}
;;;1523   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;622      */
;;;623    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;624    {
000002  4604              MOV      r4,r0
;;;625      /* Check the UART handle allocation */
;;;626      if (huart == NULL)
000004  b90c              CBNZ     r4,|L21.10|
;;;627      {
;;;628        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L21.8|
;;;629      }
;;;630    
;;;631      /* Check the parameters */
;;;632      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;633    
;;;634      huart->gState = HAL_UART_STATE_BUSY;
;;;635    
;;;636      /* Disable the Peripheral */
;;;637      __HAL_UART_DISABLE(huart);
;;;638    
;;;639    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;640      if (huart->MspDeInitCallback == NULL)
;;;641      {
;;;642        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;643      }
;;;644      /* DeInit the low level hardware */
;;;645      huart->MspDeInitCallback(huart);
;;;646    #else
;;;647      /* DeInit the low level hardware */
;;;648      HAL_UART_MspDeInit(huart);
;;;649    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;650    
;;;651      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;652      huart->gState = HAL_UART_STATE_RESET;
;;;653      huart->RxState = HAL_UART_STATE_RESET;
;;;654    
;;;655      /* Process Unlock */
;;;656      __HAL_UNLOCK(huart);
;;;657    
;;;658      return HAL_OK;
;;;659    }
000008  bd10              POP      {r4,pc}
                  |L21.10|
00000a  2024              MOVS     r0,#0x24              ;634
00000c  f8840039          STRB     r0,[r4,#0x39]         ;634
000010  6820              LDR      r0,[r4,#0]            ;637
000012  68c0              LDR      r0,[r0,#0xc]          ;637
000014  f4205000          BIC      r0,r0,#0x2000         ;637
000018  6821              LDR      r1,[r4,#0]            ;637
00001a  60c8              STR      r0,[r1,#0xc]          ;637
00001c  4620              MOV      r0,r4                 ;648
00001e  f7fffffe          BL       HAL_UART_MspDeInit
000022  2000              MOVS     r0,#0                 ;651
000024  63e0              STR      r0,[r4,#0x3c]         ;651
000026  f8840039          STRB     r0,[r4,#0x39]         ;652
00002a  f884003a          STRB     r0,[r4,#0x3a]         ;653
00002e  bf00              NOP                            ;656
000030  f8840038          STRB     r0,[r4,#0x38]         ;656
000034  bf00              NOP                            ;656
000036  bf00              NOP                            ;658
000038  e7e6              B        |L21.8|
;;;660    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2203     */
;;;2204   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2205   {
;;;2206     /* Prevent unused argument(s) compilation warning */
;;;2207     UNUSED(huart);
;;;2208     /* NOTE: This function should not be modified, when the callback is needed,
;;;2209              the HAL_UART_ErrorCallback could be implemented in the user file
;;;2210      */
;;;2211   }
;;;2212   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2474     */
;;;2475   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2476   {
;;;2477     return huart->ErrorCode;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;2478   }
000004  4770              BX       lr
;;;2479   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2459     */
;;;2460   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2461   {
;;;2462     uint32_t temp1 = 0x00U, temp2 = 0x00U;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;2463     temp1 = huart->gState;
000006  f8912039          LDRB     r2,[r1,#0x39]
;;;2464     temp2 = huart->RxState;
00000a  f891303a          LDRB     r3,[r1,#0x3a]
;;;2465   
;;;2466     return (HAL_UART_StateTypeDef)(temp1 | temp2);
00000e  ea420003          ORR      r0,r2,r3
;;;2467   }
000012  4770              BX       lr
;;;2468   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1997     */
;;;1998   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1999   {
000004  4604              MOV      r4,r0
;;;2000     uint32_t isrflags   = READ_REG(huart->Instance->SR);
000006  6820              LDR      r0,[r4,#0]
000008  6805              LDR      r5,[r0,#0]
;;;2001     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6820              LDR      r0,[r4,#0]
00000c  68c6              LDR      r6,[r0,#0xc]
;;;2002     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000e  6820              LDR      r0,[r4,#0]
000010  6947              LDR      r7,[r0,#0x14]
;;;2003     uint32_t errorflags = 0x00U;
000012  f04f0800          MOV      r8,#0
;;;2004     uint32_t dmarequest = 0x00U;
000016  46c1              MOV      r9,r8
;;;2005   
;;;2006     /* If no error occurs */
;;;2007     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
000018  f005080f          AND      r8,r5,#0xf
;;;2008     if (errorflags == RESET)
00001c  f1b80f00          CMP      r8,#0
000020  d10a              BNE      |L25.56|
;;;2009     {
;;;2010       /* UART in mode Receiver -------------------------------------------------*/
;;;2011       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000022  f0050020          AND      r0,r5,#0x20
000026  b138              CBZ      r0,|L25.56|
000028  f0060020          AND      r0,r6,#0x20
00002c  b120              CBZ      r0,|L25.56|
;;;2012       {
;;;2013         UART_Receive_IT(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_Receive_IT
                  |L25.52|
;;;2014         return;
;;;2015       }
;;;2016     }
;;;2017   
;;;2018     /* If some errors occur */
;;;2019     if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
;;;2020     {
;;;2021       /* UART parity error interrupt occurred ----------------------------------*/
;;;2022       if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;2023       {
;;;2024         huart->ErrorCode |= HAL_UART_ERROR_PE;
;;;2025       }
;;;2026   
;;;2027       /* UART noise error interrupt occurred -----------------------------------*/
;;;2028       if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2029       {
;;;2030         huart->ErrorCode |= HAL_UART_ERROR_NE;
;;;2031       }
;;;2032   
;;;2033       /* UART frame error interrupt occurred -----------------------------------*/
;;;2034       if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2035       {
;;;2036         huart->ErrorCode |= HAL_UART_ERROR_FE;
;;;2037       }
;;;2038   
;;;2039       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;2040       if (((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2041       {
;;;2042         huart->ErrorCode |= HAL_UART_ERROR_ORE;
;;;2043       }
;;;2044   
;;;2045       /* Call UART Error Call back function if need be --------------------------*/
;;;2046       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
;;;2047       {
;;;2048         /* UART in mode Receiver -----------------------------------------------*/
;;;2049         if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;2050         {
;;;2051           UART_Receive_IT(huart);
;;;2052         }
;;;2053   
;;;2054         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2055            consider error as blocking */
;;;2056         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;2057         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
;;;2058         {
;;;2059           /* Blocking error : transfer is aborted
;;;2060              Set the UART state ready to be able to start again the process,
;;;2061              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2062           UART_EndRxTransfer(huart);
;;;2063   
;;;2064           /* Disable the UART DMA Rx request if enabled */
;;;2065           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2066           {
;;;2067             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2068   
;;;2069             /* Abort the UART DMA Rx stream */
;;;2070             if (huart->hdmarx != NULL)
;;;2071             {
;;;2072               /* Set the UART DMA Abort callback :
;;;2073                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2074               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;2075               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;2076               {
;;;2077                 /* Call Directly XferAbortCallback function in case of error */
;;;2078                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;2079               }
;;;2080             }
;;;2081             else
;;;2082             {
;;;2083               /* Call user error callback */
;;;2084   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2085               /*Call registered error callback*/
;;;2086               huart->ErrorCallback(huart);
;;;2087   #else
;;;2088               /*Call legacy weak error callback*/
;;;2089               HAL_UART_ErrorCallback(huart);
;;;2090   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2091             }
;;;2092           }
;;;2093           else
;;;2094           {
;;;2095             /* Call user error callback */
;;;2096   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2097             /*Call registered error callback*/
;;;2098             huart->ErrorCallback(huart);
;;;2099   #else
;;;2100             /*Call legacy weak error callback*/
;;;2101             HAL_UART_ErrorCallback(huart);
;;;2102   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2103           }
;;;2104         }
;;;2105         else
;;;2106         {
;;;2107           /* Non Blocking error : transfer could go on.
;;;2108              Error is notified to user through user error callback */
;;;2109   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2110           /*Call registered error callback*/
;;;2111           huart->ErrorCallback(huart);
;;;2112   #else
;;;2113           /*Call legacy weak error callback*/
;;;2114           HAL_UART_ErrorCallback(huart);
;;;2115   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2116   
;;;2117           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2118         }
;;;2119       }
;;;2120       return;
;;;2121     } /* End if some error occurs */
;;;2122   
;;;2123     /* UART in mode Transmitter ------------------------------------------------*/
;;;2124     if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;2125     {
;;;2126       UART_Transmit_IT(huart);
;;;2127       return;
;;;2128     }
;;;2129   
;;;2130     /* UART in mode Transmitter end --------------------------------------------*/
;;;2131     if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;2132     {
;;;2133       UART_EndTransmit_IT(huart);
;;;2134       return;
;;;2135     }
;;;2136   }
000034  e8bd87f0          POP      {r4-r10,pc}
                  |L25.56|
000038  f1b80f00          CMP      r8,#0                 ;2019
00003c  d06e              BEQ      |L25.284|
00003e  f0070001          AND      r0,r7,#1              ;2019
000042  b918              CBNZ     r0,|L25.76|
000044  f4067090          AND      r0,r6,#0x120          ;2019
000048  2800              CMP      r0,#0                 ;2019
00004a  d067              BEQ      |L25.284|
                  |L25.76|
00004c  f0050001          AND      r0,r5,#1              ;2022
000050  b130              CBZ      r0,|L25.96|
000052  f4067080          AND      r0,r6,#0x100          ;2022
000056  b118              CBZ      r0,|L25.96|
000058  6be0              LDR      r0,[r4,#0x3c]         ;2024
00005a  f0400001          ORR      r0,r0,#1              ;2024
00005e  63e0              STR      r0,[r4,#0x3c]         ;2024
                  |L25.96|
000060  f0050004          AND      r0,r5,#4              ;2028
000064  b130              CBZ      r0,|L25.116|
000066  f0070001          AND      r0,r7,#1              ;2028
00006a  b118              CBZ      r0,|L25.116|
00006c  6be0              LDR      r0,[r4,#0x3c]         ;2030
00006e  f0400002          ORR      r0,r0,#2              ;2030
000072  63e0              STR      r0,[r4,#0x3c]         ;2030
                  |L25.116|
000074  f0050002          AND      r0,r5,#2              ;2034
000078  b130              CBZ      r0,|L25.136|
00007a  f0070001          AND      r0,r7,#1              ;2034
00007e  b118              CBZ      r0,|L25.136|
000080  6be0              LDR      r0,[r4,#0x3c]         ;2036
000082  f0400004          ORR      r0,r0,#4              ;2036
000086  63e0              STR      r0,[r4,#0x3c]         ;2036
                  |L25.136|
000088  f0050008          AND      r0,r5,#8              ;2040
00008c  b130              CBZ      r0,|L25.156|
00008e  f0070001          AND      r0,r7,#1              ;2040
000092  b118              CBZ      r0,|L25.156|
000094  6be0              LDR      r0,[r4,#0x3c]         ;2042
000096  f0400008          ORR      r0,r0,#8              ;2042
00009a  63e0              STR      r0,[r4,#0x3c]         ;2042
                  |L25.156|
00009c  6be0              LDR      r0,[r4,#0x3c]         ;2046
00009e  b370              CBZ      r0,|L25.254|
0000a0  f0050020          AND      r0,r5,#0x20           ;2049
0000a4  b128              CBZ      r0,|L25.178|
0000a6  f0060020          AND      r0,r6,#0x20           ;2049
0000aa  b110              CBZ      r0,|L25.178|
0000ac  4620              MOV      r0,r4                 ;2051
0000ae  f7fffffe          BL       UART_Receive_IT
                  |L25.178|
0000b2  6820              LDR      r0,[r4,#0]            ;2056
0000b4  6940              LDR      r0,[r0,#0x14]         ;2056
0000b6  f3c01980          UBFX     r9,r0,#6,#1           ;2056
0000ba  6be0              LDR      r0,[r4,#0x3c]         ;2057
0000bc  f0000008          AND      r0,r0,#8              ;2057
0000c0  b910              CBNZ     r0,|L25.200|
0000c2  f1b90f00          CMP      r9,#0                 ;2057
0000c6  d023              BEQ      |L25.272|
                  |L25.200|
0000c8  4620              MOV      r0,r4                 ;2062
0000ca  f7fffffe          BL       UART_EndRxTransfer
0000ce  6820              LDR      r0,[r4,#0]            ;2065
0000d0  6940              LDR      r0,[r0,#0x14]         ;2065
0000d2  f0000040          AND      r0,r0,#0x40           ;2065
0000d6  2840              CMP      r0,#0x40              ;2065
0000d8  d116              BNE      |L25.264|
0000da  6820              LDR      r0,[r4,#0]            ;2067
0000dc  6940              LDR      r0,[r0,#0x14]         ;2067
0000de  f0200040          BIC      r0,r0,#0x40           ;2067
0000e2  6821              LDR      r1,[r4,#0]            ;2067
0000e4  6148              STR      r0,[r1,#0x14]         ;2067
0000e6  6b60              LDR      r0,[r4,#0x34]         ;2070
0000e8  b150              CBZ      r0,|L25.256|
0000ea  4817              LDR      r0,|L25.328|
0000ec  6b61              LDR      r1,[r4,#0x34]         ;2074
0000ee  6508              STR      r0,[r1,#0x50]         ;2074
0000f0  6b60              LDR      r0,[r4,#0x34]         ;2075
0000f2  f7fffffe          BL       HAL_DMA_Abort_IT
0000f6  b110              CBZ      r0,|L25.254|
0000f8  6b60              LDR      r0,[r4,#0x34]         ;2078
0000fa  6d01              LDR      r1,[r0,#0x50]         ;2078
0000fc  4788              BLX      r1                    ;2078
                  |L25.254|
0000fe  e00c              B        |L25.282|
                  |L25.256|
000100  4620              MOV      r0,r4                 ;2089
000102  f7fffffe          BL       HAL_UART_ErrorCallback
000106  e008              B        |L25.282|
                  |L25.264|
000108  4620              MOV      r0,r4                 ;2101
00010a  f7fffffe          BL       HAL_UART_ErrorCallback
00010e  e004              B        |L25.282|
                  |L25.272|
000110  4620              MOV      r0,r4                 ;2114
000112  f7fffffe          BL       HAL_UART_ErrorCallback
000116  2000              MOVS     r0,#0                 ;2117
000118  63e0              STR      r0,[r4,#0x3c]         ;2117
                  |L25.282|
00011a  e78b              B        |L25.52|
                  |L25.284|
00011c  f0050080          AND      r0,r5,#0x80           ;2124
000120  b130              CBZ      r0,|L25.304|
000122  f0060080          AND      r0,r6,#0x80           ;2124
000126  b118              CBZ      r0,|L25.304|
000128  4620              MOV      r0,r4                 ;2126
00012a  f7fffffe          BL       UART_Transmit_IT
00012e  e781              B        |L25.52|
                  |L25.304|
000130  f0050040          AND      r0,r5,#0x40           ;2131
000134  b130              CBZ      r0,|L25.324|
000136  f0060040          AND      r0,r6,#0x40           ;2131
00013a  b118              CBZ      r0,|L25.324|
00013c  4620              MOV      r0,r4                 ;2133
00013e  f7fffffe          BL       UART_EndTransmit_IT
000142  e777              B        |L25.52|
                  |L25.324|
000144  bf00              NOP      
000146  e775              B        |L25.52|
;;;2137   
                          ENDP

                  |L25.328|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;316      */
;;;317    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;318    {
000002  4604              MOV      r4,r0
;;;319      /* Check the UART handle allocation */
;;;320      if (huart == NULL)
000004  b90c              CBNZ     r4,|L26.10|
;;;321      {
;;;322        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L26.8|
;;;323      }
;;;324    
;;;325      /* Check the parameters */
;;;326      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;327      {
;;;328        /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
;;;329        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;330        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;331      }
;;;332      else
;;;333      {
;;;334        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;335      }
;;;336      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;337      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;338    
;;;339      if (huart->gState == HAL_UART_STATE_RESET)
;;;340      {
;;;341        /* Allocate lock resource and initialize it */
;;;342        huart->Lock = HAL_UNLOCKED;
;;;343    
;;;344    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;345        UART_InitCallbacksToDefault(huart);
;;;346    
;;;347        if (huart->MspInitCallback == NULL)
;;;348        {
;;;349          huart->MspInitCallback = HAL_UART_MspInit;
;;;350        }
;;;351    
;;;352        /* Init the low level hardware */
;;;353        huart->MspInitCallback(huart);
;;;354    #else
;;;355        /* Init the low level hardware : GPIO, CLOCK */
;;;356        HAL_UART_MspInit(huart);
;;;357    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;358      }
;;;359    
;;;360      huart->gState = HAL_UART_STATE_BUSY;
;;;361    
;;;362      /* Disable the peripheral */
;;;363      __HAL_UART_DISABLE(huart);
;;;364    
;;;365      /* Set the UART Communication parameters */
;;;366      UART_SetConfig(huart);
;;;367    
;;;368      /* In asynchronous mode, the following bits must be kept cleared:
;;;369         - LINEN and CLKEN bits in the USART_CR2 register,
;;;370         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;371      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;372      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;373    
;;;374      /* Enable the peripheral */
;;;375      __HAL_UART_ENABLE(huart);
;;;376    
;;;377      /* Initialize the UART state */
;;;378      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;379      huart->gState = HAL_UART_STATE_READY;
;;;380      huart->RxState = HAL_UART_STATE_READY;
;;;381    
;;;382      return HAL_OK;
;;;383    }
000008  bd10              POP      {r4,pc}
                  |L26.10|
00000a  69a0              LDR      r0,[r4,#0x18]         ;326
00000c  b100              CBZ      r0,|L26.16|
00000e  e000              B        |L26.18|
                  |L26.16|
000010  bf00              NOP                            ;334
                  |L26.18|
000012  f8940039          LDRB     r0,[r4,#0x39]         ;339
000016  b928              CBNZ     r0,|L26.36|
000018  2000              MOVS     r0,#0                 ;342
00001a  f8840038          STRB     r0,[r4,#0x38]         ;342
00001e  4620              MOV      r0,r4                 ;356
000020  f7fffffe          BL       HAL_UART_MspInit
                  |L26.36|
000024  2024              MOVS     r0,#0x24              ;360
000026  f8840039          STRB     r0,[r4,#0x39]         ;360
00002a  6820              LDR      r0,[r4,#0]            ;363
00002c  68c0              LDR      r0,[r0,#0xc]          ;363
00002e  f4205000          BIC      r0,r0,#0x2000         ;363
000032  6821              LDR      r1,[r4,#0]            ;363
000034  60c8              STR      r0,[r1,#0xc]          ;363
000036  4620              MOV      r0,r4                 ;366
000038  f7fffffe          BL       UART_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;371
00003e  6900              LDR      r0,[r0,#0x10]         ;371
000040  f4204090          BIC      r0,r0,#0x4800         ;371
000044  6821              LDR      r1,[r4,#0]            ;371
000046  6108              STR      r0,[r1,#0x10]         ;371
000048  6820              LDR      r0,[r4,#0]            ;372
00004a  6940              LDR      r0,[r0,#0x14]         ;372
00004c  f020002a          BIC      r0,r0,#0x2a           ;372
000050  6821              LDR      r1,[r4,#0]            ;372
000052  6148              STR      r0,[r1,#0x14]         ;372
000054  6820              LDR      r0,[r4,#0]            ;375
000056  68c0              LDR      r0,[r0,#0xc]          ;375
000058  f4405000          ORR      r0,r0,#0x2000         ;375
00005c  6821              LDR      r1,[r4,#0]            ;375
00005e  60c8              STR      r0,[r1,#0xc]          ;375
000060  2000              MOVS     r0,#0                 ;378
000062  63e0              STR      r0,[r4,#0x3c]         ;378
000064  2020              MOVS     r0,#0x20              ;379
000066  f8840039          STRB     r0,[r4,#0x39]         ;379
00006a  f884003a          STRB     r0,[r4,#0x3a]         ;380
00006e  2000              MOVS     r0,#0                 ;382
000070  e7ca              B        |L26.8|
;;;384    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;681      */
;;;682    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;683    {
;;;684      /* Prevent unused argument(s) compilation warning */
;;;685      UNUSED(huart);
;;;686      /* NOTE: This function should not be modified, when the callback is needed,
;;;687               the HAL_UART_MspDeInit could be implemented in the user file
;;;688       */
;;;689    }
;;;690    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;666      */
;;;667    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;668    {
;;;669      /* Prevent unused argument(s) compilation warning */
;;;670      UNUSED(huart);
;;;671      /* NOTE: This function should not be modified, when the callback is needed,
;;;672               the HAL_UART_MspInit could be implemented in the user file
;;;673       */
;;;674    }
;;;675    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1100     */
;;;1101   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1102   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1103     uint16_t *tmp;
;;;1104     uint32_t tickstart = 0U;
00000c  f04f0900          MOV      r9,#0
;;;1105   
;;;1106     /* Check that a Rx process is not already ongoing */
;;;1107     if (huart->RxState == HAL_UART_STATE_READY)
000010  f894003a          LDRB     r0,[r4,#0x3a]
000014  2820              CMP      r0,#0x20
000016  d160              BNE      |L29.218|
;;;1108     {
;;;1109       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L29.28|
00001a  b916              CBNZ     r6,|L29.34|
                  |L29.28|
;;;1110       {
;;;1111         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L29.30|
;;;1112       }
;;;1113   
;;;1114       /* Process Locked */
;;;1115       __HAL_LOCK(huart);
;;;1116   
;;;1117       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1118       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1119   
;;;1120       /* Init tickstart for timeout managment */
;;;1121       tickstart = HAL_GetTick();
;;;1122   
;;;1123       huart->RxXferSize = Size;
;;;1124       huart->RxXferCount = Size;
;;;1125   
;;;1126       /* Check the remain data to be received */
;;;1127       while (huart->RxXferCount > 0U)
;;;1128       {
;;;1129         huart->RxXferCount--;
;;;1130         if (huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;1131         {
;;;1132           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1133           {
;;;1134             return HAL_TIMEOUT;
;;;1135           }
;;;1136           tmp = (uint16_t *) pData;
;;;1137           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1138           {
;;;1139             *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;1140             pData += 2U;
;;;1141           }
;;;1142           else
;;;1143           {
;;;1144             *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;1145             pData += 1U;
;;;1146           }
;;;1147   
;;;1148         }
;;;1149         else
;;;1150         {
;;;1151           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1152           {
;;;1153             return HAL_TIMEOUT;
;;;1154           }
;;;1155           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1156           {
;;;1157             *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1158           }
;;;1159           else
;;;1160           {
;;;1161             *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1162           }
;;;1163   
;;;1164         }
;;;1165       }
;;;1166   
;;;1167       /* At end of Rx process, restore huart->RxState to Ready */
;;;1168       huart->RxState = HAL_UART_STATE_READY;
;;;1169   
;;;1170       /* Process Unlocked */
;;;1171       __HAL_UNLOCK(huart);
;;;1172   
;;;1173       return HAL_OK;
;;;1174     }
;;;1175     else
;;;1176     {
;;;1177       return HAL_BUSY;
;;;1178     }
;;;1179   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L29.34|
000022  bf00              NOP                            ;1115
000024  f8940038          LDRB     r0,[r4,#0x38]         ;1115
000028  2801              CMP      r0,#1                 ;1115
00002a  d101              BNE      |L29.48|
00002c  2002              MOVS     r0,#2                 ;1115
00002e  e7f6              B        |L29.30|
                  |L29.48|
000030  2001              MOVS     r0,#1                 ;1115
000032  f8840038          STRB     r0,[r4,#0x38]         ;1115
000036  bf00              NOP                            ;1115
000038  2000              MOVS     r0,#0                 ;1117
00003a  63e0              STR      r0,[r4,#0x3c]         ;1117
00003c  2022              MOVS     r0,#0x22              ;1118
00003e  f884003a          STRB     r0,[r4,#0x3a]         ;1118
000042  f7fffffe          BL       HAL_GetTick
000046  4681              MOV      r9,r0                 ;1121
000048  85a6              STRH     r6,[r4,#0x2c]         ;1123
00004a  85e6              STRH     r6,[r4,#0x2e]         ;1124
00004c  e039              B        |L29.194|
                  |L29.78|
00004e  8de0              LDRH     r0,[r4,#0x2e]         ;1129
000050  1e40              SUBS     r0,r0,#1              ;1129
000052  85e0              STRH     r0,[r4,#0x2e]         ;1129
000054  68a0              LDR      r0,[r4,#8]            ;1130
000056  f5b05f80          CMP      r0,#0x1000            ;1130
00005a  d11b              BNE      |L29.148|
00005c  464b              MOV      r3,r9                 ;1132
00005e  2200              MOVS     r2,#0                 ;1132
000060  2120              MOVS     r1,#0x20              ;1132
000062  4620              MOV      r0,r4                 ;1132
000064  9700              STR      r7,[sp,#0]            ;1132
000066  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006a  b108              CBZ      r0,|L29.112|
00006c  2003              MOVS     r0,#3                 ;1134
00006e  e7d6              B        |L29.30|
                  |L29.112|
000070  46a8              MOV      r8,r5                 ;1136
000072  6920              LDR      r0,[r4,#0x10]         ;1137
000074  b938              CBNZ     r0,|L29.134|
000076  6820              LDR      r0,[r4,#0]            ;1139
000078  6840              LDR      r0,[r0,#4]            ;1139
00007a  f3c00008          UBFX     r0,r0,#0,#9           ;1139
00007e  f8a80000          STRH     r0,[r8,#0]            ;1139
000082  1cad              ADDS     r5,r5,#2              ;1140
000084  e01d              B        |L29.194|
                  |L29.134|
000086  6820              LDR      r0,[r4,#0]            ;1144
000088  6840              LDR      r0,[r0,#4]            ;1144
00008a  b2c0              UXTB     r0,r0                 ;1144
00008c  f8a80000          STRH     r0,[r8,#0]            ;1144
000090  1c6d              ADDS     r5,r5,#1              ;1145
000092  e016              B        |L29.194|
                  |L29.148|
000094  464b              MOV      r3,r9                 ;1151
000096  2200              MOVS     r2,#0                 ;1151
000098  2120              MOVS     r1,#0x20              ;1151
00009a  4620              MOV      r0,r4                 ;1151
00009c  9700              STR      r7,[sp,#0]            ;1151
00009e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a2  b108              CBZ      r0,|L29.168|
0000a4  2003              MOVS     r0,#3                 ;1153
0000a6  e7ba              B        |L29.30|
                  |L29.168|
0000a8  6920              LDR      r0,[r4,#0x10]         ;1155
0000aa  b920              CBNZ     r0,|L29.182|
0000ac  6820              LDR      r0,[r4,#0]            ;1157
0000ae  6840              LDR      r0,[r0,#4]            ;1157
0000b0  f8050b01          STRB     r0,[r5],#1            ;1157
0000b4  e005              B        |L29.194|
                  |L29.182|
0000b6  6820              LDR      r0,[r4,#0]            ;1161
0000b8  6840              LDR      r0,[r0,#4]            ;1161
0000ba  f000007f          AND      r0,r0,#0x7f           ;1161
0000be  f8050b01          STRB     r0,[r5],#1            ;1161
                  |L29.194|
0000c2  8de0              LDRH     r0,[r4,#0x2e]         ;1127
0000c4  2800              CMP      r0,#0                 ;1127
0000c6  d1c2              BNE      |L29.78|
0000c8  2020              MOVS     r0,#0x20              ;1168
0000ca  f884003a          STRB     r0,[r4,#0x3a]         ;1168
0000ce  bf00              NOP                            ;1171
0000d0  2000              MOVS     r0,#0                 ;1171
0000d2  f8840038          STRB     r0,[r4,#0x38]         ;1171
0000d6  bf00              NOP                            ;1171
0000d8  e7a1              B        |L29.30|
                  |L29.218|
0000da  2002              MOVS     r0,#2                 ;1177
0000dc  e79f              B        |L29.30|
;;;1180   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1343     */
;;;1344   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;1345   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;1346     uint32_t *tmp;
;;;1347   
;;;1348     /* Check that a Rx process is not already ongoing */
;;;1349     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003a          LDRB     r0,[r4,#0x3a]
00000c  2820              CMP      r0,#0x20
00000e  d150              BNE      |L30.178|
;;;1350     {
;;;1351       if ((pData == NULL) || (Size == 0U))
000010  9802              LDR      r0,[sp,#8]
000012  b100              CBZ      r0,|L30.22|
000014  b915              CBNZ     r5,|L30.28|
                  |L30.22|
;;;1352       {
;;;1353         return HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L30.24|
;;;1354       }
;;;1355   
;;;1356       /* Process Locked */
;;;1357       __HAL_LOCK(huart);
;;;1358   
;;;1359       huart->pRxBuffPtr = pData;
;;;1360       huart->RxXferSize = Size;
;;;1361   
;;;1362       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1363       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1364   
;;;1365       /* Set the UART DMA transfer complete callback */
;;;1366       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1367   
;;;1368       /* Set the UART DMA Half transfer complete callback */
;;;1369       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1370   
;;;1371       /* Set the DMA error callback */
;;;1372       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1373   
;;;1374       /* Set the DMA abort callback */
;;;1375       huart->hdmarx->XferAbortCallback = NULL;
;;;1376   
;;;1377       /* Enable the DMA stream */
;;;1378       tmp = (uint32_t *)&pData;
;;;1379       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
;;;1380   
;;;1381       /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;1382       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1383   
;;;1384       /* Process Unlocked */
;;;1385       __HAL_UNLOCK(huart);
;;;1386   
;;;1387       /* Enable the UART Parity Error Interrupt */
;;;1388       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1389   
;;;1390       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1391       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1392   
;;;1393       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1394       in the UART CR3 register */
;;;1395       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1396   
;;;1397       return HAL_OK;
;;;1398     }
;;;1399     else
;;;1400     {
;;;1401       return HAL_BUSY;
;;;1402     }
;;;1403   }
000018  b004              ADD      sp,sp,#0x10
00001a  bd70              POP      {r4-r6,pc}
                  |L30.28|
00001c  bf00              NOP                            ;1357
00001e  f8940038          LDRB     r0,[r4,#0x38]         ;1357
000022  2801              CMP      r0,#1                 ;1357
000024  d101              BNE      |L30.42|
000026  2002              MOVS     r0,#2                 ;1357
000028  e7f6              B        |L30.24|
                  |L30.42|
00002a  2001              MOVS     r0,#1                 ;1357
00002c  f8840038          STRB     r0,[r4,#0x38]         ;1357
000030  bf00              NOP                            ;1357
000032  9802              LDR      r0,[sp,#8]            ;1359
000034  62a0              STR      r0,[r4,#0x28]         ;1359
000036  85a5              STRH     r5,[r4,#0x2c]         ;1360
000038  2000              MOVS     r0,#0                 ;1362
00003a  63e0              STR      r0,[r4,#0x3c]         ;1362
00003c  2022              MOVS     r0,#0x22              ;1363
00003e  f884003a          STRB     r0,[r4,#0x3a]         ;1363
000042  481d              LDR      r0,|L30.184|
000044  6b61              LDR      r1,[r4,#0x34]         ;1366
000046  63c8              STR      r0,[r1,#0x3c]         ;1366
000048  481c              LDR      r0,|L30.188|
00004a  6b61              LDR      r1,[r4,#0x34]         ;1369
00004c  6408              STR      r0,[r1,#0x40]         ;1369
00004e  481c              LDR      r0,|L30.192|
000050  6b61              LDR      r1,[r4,#0x34]         ;1372
000052  64c8              STR      r0,[r1,#0x4c]         ;1372
000054  2000              MOVS     r0,#0                 ;1375
000056  6b61              LDR      r1,[r4,#0x34]         ;1375
000058  6508              STR      r0,[r1,#0x50]         ;1375
00005a  ae02              ADD      r6,sp,#8              ;1378
00005c  6832              LDR      r2,[r6,#0]            ;1379
00005e  6823              LDR      r3,[r4,#0]            ;1379
000060  1d19              ADDS     r1,r3,#4              ;1379
000062  462b              MOV      r3,r5                 ;1379
000064  6b60              LDR      r0,[r4,#0x34]         ;1379
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  bf00              NOP                            ;1382
00006c  2000              MOVS     r0,#0                 ;1382
00006e  9000              STR      r0,[sp,#0]            ;1382
000070  6820              LDR      r0,[r4,#0]            ;1382
000072  6800              LDR      r0,[r0,#0]            ;1382
000074  9000              STR      r0,[sp,#0]            ;1382
000076  6820              LDR      r0,[r4,#0]            ;1382
000078  6840              LDR      r0,[r0,#4]            ;1382
00007a  9000              STR      r0,[sp,#0]            ;1382
00007c  bf00              NOP                            ;1382
00007e  bf00              NOP                            ;1382
000080  bf00              NOP                            ;1385
000082  2000              MOVS     r0,#0                 ;1385
000084  f8840038          STRB     r0,[r4,#0x38]         ;1385
000088  bf00              NOP                            ;1385
00008a  6820              LDR      r0,[r4,#0]            ;1388
00008c  68c0              LDR      r0,[r0,#0xc]          ;1388
00008e  f4407080          ORR      r0,r0,#0x100          ;1388
000092  6821              LDR      r1,[r4,#0]            ;1388
000094  60c8              STR      r0,[r1,#0xc]          ;1388
000096  6820              LDR      r0,[r4,#0]            ;1391
000098  6940              LDR      r0,[r0,#0x14]         ;1391
00009a  f0400001          ORR      r0,r0,#1              ;1391
00009e  6821              LDR      r1,[r4,#0]            ;1391
0000a0  6148              STR      r0,[r1,#0x14]         ;1391
0000a2  6820              LDR      r0,[r4,#0]            ;1395
0000a4  6940              LDR      r0,[r0,#0x14]         ;1395
0000a6  f0400040          ORR      r0,r0,#0x40           ;1395
0000aa  6821              LDR      r1,[r4,#0]            ;1395
0000ac  6148              STR      r0,[r1,#0x14]         ;1395
0000ae  2000              MOVS     r0,#0                 ;1397
0000b0  e7b2              B        |L30.24|
                  |L30.178|
0000b2  2002              MOVS     r0,#2                 ;1401
0000b4  e7b0              B        |L30.24|
;;;1404   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L30.184|
                          DCD      UART_DMAReceiveCplt
                  |L30.188|
                          DCD      UART_DMARxHalfCplt
                  |L30.192|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;1230     */
;;;1231   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1232   {
000002  4603              MOV      r3,r0
;;;1233     /* Check that a Rx process is not already ongoing */
;;;1234     if (huart->RxState == HAL_UART_STATE_READY)
000004  f893003a          LDRB     r0,[r3,#0x3a]
000008  2820              CMP      r0,#0x20
00000a  d12f              BNE      |L31.108|
;;;1235     {
;;;1236       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L31.16|
00000e  b90a              CBNZ     r2,|L31.20|
                  |L31.16|
;;;1237       {
;;;1238         return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L31.18|
;;;1239       }
;;;1240   
;;;1241       /* Process Locked */
;;;1242       __HAL_LOCK(huart);
;;;1243   
;;;1244       huart->pRxBuffPtr = pData;
;;;1245       huart->RxXferSize = Size;
;;;1246       huart->RxXferCount = Size;
;;;1247   
;;;1248       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1249       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1250   
;;;1251       /* Process Unlocked */
;;;1252       __HAL_UNLOCK(huart);
;;;1253   
;;;1254       /* Enable the UART Parity Error Interrupt */
;;;1255       __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;1256   
;;;1257       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1258       __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;1259   
;;;1260       /* Enable the UART Data Register not empty Interrupt */
;;;1261       __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;1262   
;;;1263       return HAL_OK;
;;;1264     }
;;;1265     else
;;;1266     {
;;;1267       return HAL_BUSY;
;;;1268     }
;;;1269   }
000012  bd10              POP      {r4,pc}
                  |L31.20|
000014  bf00              NOP                            ;1242
000016  f8930038          LDRB     r0,[r3,#0x38]         ;1242
00001a  2801              CMP      r0,#1                 ;1242
00001c  d101              BNE      |L31.34|
00001e  2002              MOVS     r0,#2                 ;1242
000020  e7f7              B        |L31.18|
                  |L31.34|
000022  2001              MOVS     r0,#1                 ;1242
000024  f8830038          STRB     r0,[r3,#0x38]         ;1242
000028  bf00              NOP                            ;1242
00002a  6299              STR      r1,[r3,#0x28]         ;1244
00002c  859a              STRH     r2,[r3,#0x2c]         ;1245
00002e  85da              STRH     r2,[r3,#0x2e]         ;1246
000030  2000              MOVS     r0,#0                 ;1248
000032  63d8              STR      r0,[r3,#0x3c]         ;1248
000034  2022              MOVS     r0,#0x22              ;1249
000036  f883003a          STRB     r0,[r3,#0x3a]         ;1249
00003a  bf00              NOP                            ;1252
00003c  2000              MOVS     r0,#0                 ;1252
00003e  f8830038          STRB     r0,[r3,#0x38]         ;1252
000042  bf00              NOP                            ;1252
000044  6818              LDR      r0,[r3,#0]            ;1255
000046  68c0              LDR      r0,[r0,#0xc]          ;1255
000048  f4407080          ORR      r0,r0,#0x100          ;1255
00004c  681c              LDR      r4,[r3,#0]            ;1255
00004e  60e0              STR      r0,[r4,#0xc]          ;1255
000050  6818              LDR      r0,[r3,#0]            ;1258
000052  6940              LDR      r0,[r0,#0x14]         ;1258
000054  f0400001          ORR      r0,r0,#1              ;1258
000058  681c              LDR      r4,[r3,#0]            ;1258
00005a  6160              STR      r0,[r4,#0x14]         ;1258
00005c  6818              LDR      r0,[r3,#0]            ;1261
00005e  68c0              LDR      r0,[r0,#0xc]          ;1261
000060  f0400020          ORR      r0,r0,#0x20           ;1261
000064  681c              LDR      r4,[r3,#0]            ;1261
000066  60e0              STR      r0,[r4,#0xc]          ;1261
000068  2000              MOVS     r0,#0                 ;1263
00006a  e7d2              B        |L31.18|
                  |L31.108|
00006c  2002              MOVS     r0,#2                 ;1267
00006e  e7d0              B        |L31.18|
;;;1270   
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2173     */
;;;2174   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2175   {
;;;2176     /* Prevent unused argument(s) compilation warning */
;;;2177     UNUSED(huart);
;;;2178     /* NOTE: This function should not be modified, when the callback is needed,
;;;2179              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;2180      */
;;;2181   }
;;;2182   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2188     */
;;;2189   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2190   {
;;;2191     /* Prevent unused argument(s) compilation warning */
;;;2192     UNUSED(huart);
;;;2193     /* NOTE: This function should not be modified, when the callback is needed,
;;;2194              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;2195      */
;;;2196   }
;;;2197   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1018     */
;;;1019   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1020   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1021     uint16_t *tmp;
;;;1022     uint32_t tickstart = 0U;
00000c  f04f0900          MOV      r9,#0
;;;1023   
;;;1024     /* Check that a Tx process is not already ongoing */
;;;1025     if (huart->gState == HAL_UART_STATE_READY)
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2820              CMP      r0,#0x20
000016  d15c              BNE      |L34.210|
;;;1026     {
;;;1027       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L34.28|
00001a  b916              CBNZ     r6,|L34.34|
                  |L34.28|
;;;1028       {
;;;1029         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L34.30|
;;;1030       }
;;;1031   
;;;1032       /* Process Locked */
;;;1033       __HAL_LOCK(huart);
;;;1034   
;;;1035       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1036       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1037   
;;;1038       /* Init tickstart for timeout managment */
;;;1039       tickstart = HAL_GetTick();
;;;1040   
;;;1041       huart->TxXferSize = Size;
;;;1042       huart->TxXferCount = Size;
;;;1043       while (huart->TxXferCount > 0U)
;;;1044       {
;;;1045         huart->TxXferCount--;
;;;1046         if (huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;1047         {
;;;1048           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1049           {
;;;1050             return HAL_TIMEOUT;
;;;1051           }
;;;1052           tmp = (uint16_t *) pData;
;;;1053           huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;1054           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1055           {
;;;1056             pData += 2U;
;;;1057           }
;;;1058           else
;;;1059           {
;;;1060             pData += 1U;
;;;1061           }
;;;1062         }
;;;1063         else
;;;1064         {
;;;1065           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1066           {
;;;1067             return HAL_TIMEOUT;
;;;1068           }
;;;1069           huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;1070         }
;;;1071       }
;;;1072   
;;;1073       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1074       {
;;;1075         return HAL_TIMEOUT;
;;;1076       }
;;;1077   
;;;1078       /* At end of Tx process, restore huart->gState to Ready */
;;;1079       huart->gState = HAL_UART_STATE_READY;
;;;1080   
;;;1081       /* Process Unlocked */
;;;1082       __HAL_UNLOCK(huart);
;;;1083   
;;;1084       return HAL_OK;
;;;1085     }
;;;1086     else
;;;1087     {
;;;1088       return HAL_BUSY;
;;;1089     }
;;;1090   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L34.34|
000022  bf00              NOP                            ;1033
000024  f8940038          LDRB     r0,[r4,#0x38]         ;1033
000028  2801              CMP      r0,#1                 ;1033
00002a  d101              BNE      |L34.48|
00002c  2002              MOVS     r0,#2                 ;1033
00002e  e7f6              B        |L34.30|
                  |L34.48|
000030  2001              MOVS     r0,#1                 ;1033
000032  f8840038          STRB     r0,[r4,#0x38]         ;1033
000036  bf00              NOP                            ;1033
000038  2000              MOVS     r0,#0                 ;1035
00003a  63e0              STR      r0,[r4,#0x3c]         ;1035
00003c  2021              MOVS     r0,#0x21              ;1036
00003e  f8840039          STRB     r0,[r4,#0x39]         ;1036
000042  f7fffffe          BL       HAL_GetTick
000046  4681              MOV      r9,r0                 ;1039
000048  84a6              STRH     r6,[r4,#0x24]         ;1041
00004a  84e6              STRH     r6,[r4,#0x26]         ;1042
00004c  e02b              B        |L34.166|
                  |L34.78|
00004e  8ce0              LDRH     r0,[r4,#0x26]         ;1045
000050  1e40              SUBS     r0,r0,#1              ;1045
000052  84e0              STRH     r0,[r4,#0x26]         ;1045
000054  68a0              LDR      r0,[r4,#8]            ;1046
000056  f5b05f80          CMP      r0,#0x1000            ;1046
00005a  d116              BNE      |L34.138|
00005c  464b              MOV      r3,r9                 ;1048
00005e  2200              MOVS     r2,#0                 ;1048
000060  2180              MOVS     r1,#0x80              ;1048
000062  4620              MOV      r0,r4                 ;1048
000064  9700              STR      r7,[sp,#0]            ;1048
000066  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006a  b108              CBZ      r0,|L34.112|
00006c  2003              MOVS     r0,#3                 ;1050
00006e  e7d6              B        |L34.30|
                  |L34.112|
000070  46a8              MOV      r8,r5                 ;1052
000072  f8b80000          LDRH     r0,[r8,#0]            ;1053
000076  f3c00008          UBFX     r0,r0,#0,#9           ;1053
00007a  6821              LDR      r1,[r4,#0]            ;1053
00007c  6048              STR      r0,[r1,#4]            ;1053
00007e  6920              LDR      r0,[r4,#0x10]         ;1054
000080  b908              CBNZ     r0,|L34.134|
000082  1cad              ADDS     r5,r5,#2              ;1056
000084  e00f              B        |L34.166|
                  |L34.134|
000086  1c6d              ADDS     r5,r5,#1              ;1060
000088  e00d              B        |L34.166|
                  |L34.138|
00008a  464b              MOV      r3,r9                 ;1065
00008c  2200              MOVS     r2,#0                 ;1065
00008e  2180              MOVS     r1,#0x80              ;1065
000090  4620              MOV      r0,r4                 ;1065
000092  9700              STR      r7,[sp,#0]            ;1065
000094  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000098  b108              CBZ      r0,|L34.158|
00009a  2003              MOVS     r0,#3                 ;1067
00009c  e7bf              B        |L34.30|
                  |L34.158|
00009e  f8150b01          LDRB     r0,[r5],#1            ;1069
0000a2  6821              LDR      r1,[r4,#0]            ;1069
0000a4  6048              STR      r0,[r1,#4]            ;1069
                  |L34.166|
0000a6  8ce0              LDRH     r0,[r4,#0x26]         ;1043
0000a8  2800              CMP      r0,#0                 ;1043
0000aa  d1d0              BNE      |L34.78|
0000ac  464b              MOV      r3,r9                 ;1073
0000ae  2200              MOVS     r2,#0                 ;1073
0000b0  2140              MOVS     r1,#0x40              ;1073
0000b2  4620              MOV      r0,r4                 ;1073
0000b4  9700              STR      r7,[sp,#0]            ;1073
0000b6  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000ba  b108              CBZ      r0,|L34.192|
0000bc  2003              MOVS     r0,#3                 ;1075
0000be  e7ae              B        |L34.30|
                  |L34.192|
0000c0  2020              MOVS     r0,#0x20              ;1079
0000c2  f8840039          STRB     r0,[r4,#0x39]         ;1079
0000c6  bf00              NOP                            ;1082
0000c8  2000              MOVS     r0,#0                 ;1082
0000ca  f8840038          STRB     r0,[r4,#0x38]         ;1082
0000ce  bf00              NOP                            ;1082
0000d0  e7a5              B        |L34.30|
                  |L34.210|
0000d2  2002              MOVS     r0,#2                 ;1088
0000d4  e7a3              B        |L34.30|
;;;1091   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1278     */
;;;1279   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1280   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1281     uint32_t *tmp;
;;;1282   
;;;1283     /* Check that a Tx process is not already ongoing */
;;;1284     if (huart->gState == HAL_UART_STATE_READY)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  2820              CMP      r0,#0x20
00000c  d13d              BNE      |L35.138|
;;;1285     {
;;;1286       if ((pData == NULL) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  b100              CBZ      r0,|L35.20|
000012  b90d              CBNZ     r5,|L35.24|
                  |L35.20|
;;;1287       {
;;;1288         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L35.22|
;;;1289       }
;;;1290   
;;;1291       /* Process Locked */
;;;1292       __HAL_LOCK(huart);
;;;1293   
;;;1294       huart->pTxBuffPtr = pData;
;;;1295       huart->TxXferSize = Size;
;;;1296       huart->TxXferCount = Size;
;;;1297   
;;;1298       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1299       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1300   
;;;1301       /* Set the UART DMA transfer complete callback */
;;;1302       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1303   
;;;1304       /* Set the UART DMA Half transfer complete callback */
;;;1305       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1306   
;;;1307       /* Set the DMA error callback */
;;;1308       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1309   
;;;1310       /* Set the DMA abort callback */
;;;1311       huart->hdmatx->XferAbortCallback = NULL;
;;;1312   
;;;1313       /* Enable the UART transmit DMA stream */
;;;1314       tmp = (uint32_t *)&pData;
;;;1315       HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;1316   
;;;1317       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1318       __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;1319   
;;;1320       /* Process Unlocked */
;;;1321       __HAL_UNLOCK(huart);
;;;1322   
;;;1323       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1324          in the UART CR3 register */
;;;1325       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1326   
;;;1327       return HAL_OK;
;;;1328     }
;;;1329     else
;;;1330     {
;;;1331       return HAL_BUSY;
;;;1332     }
;;;1333   }
000016  bdfe              POP      {r1-r7,pc}
                  |L35.24|
000018  bf00              NOP                            ;1292
00001a  f8940038          LDRB     r0,[r4,#0x38]         ;1292
00001e  2801              CMP      r0,#1                 ;1292
000020  d101              BNE      |L35.38|
000022  2002              MOVS     r0,#2                 ;1292
000024  e7f7              B        |L35.22|
                  |L35.38|
000026  2001              MOVS     r0,#1                 ;1292
000028  f8840038          STRB     r0,[r4,#0x38]         ;1292
00002c  bf00              NOP                            ;1292
00002e  9801              LDR      r0,[sp,#4]            ;1294
000030  6220              STR      r0,[r4,#0x20]         ;1294
000032  84a5              STRH     r5,[r4,#0x24]         ;1295
000034  84e5              STRH     r5,[r4,#0x26]         ;1296
000036  2000              MOVS     r0,#0                 ;1298
000038  63e0              STR      r0,[r4,#0x3c]         ;1298
00003a  2021              MOVS     r0,#0x21              ;1299
00003c  f8840039          STRB     r0,[r4,#0x39]         ;1299
000040  4813              LDR      r0,|L35.144|
000042  6b21              LDR      r1,[r4,#0x30]         ;1302
000044  63c8              STR      r0,[r1,#0x3c]         ;1302
000046  4813              LDR      r0,|L35.148|
000048  6b21              LDR      r1,[r4,#0x30]         ;1305
00004a  6408              STR      r0,[r1,#0x40]         ;1305
00004c  4812              LDR      r0,|L35.152|
00004e  6b21              LDR      r1,[r4,#0x30]         ;1308
000050  64c8              STR      r0,[r1,#0x4c]         ;1308
000052  2000              MOVS     r0,#0                 ;1311
000054  6b21              LDR      r1,[r4,#0x30]         ;1311
000056  6508              STR      r0,[r1,#0x50]         ;1311
000058  ae01              ADD      r6,sp,#4              ;1314
00005a  6823              LDR      r3,[r4,#0]            ;1315
00005c  1d1a              ADDS     r2,r3,#4              ;1315
00005e  6831              LDR      r1,[r6,#0]            ;1315
000060  462b              MOV      r3,r5                 ;1315
000062  6b20              LDR      r0,[r4,#0x30]         ;1315
000064  f7fffffe          BL       HAL_DMA_Start_IT
000068  f06f0040          MVN      r0,#0x40              ;1318
00006c  6821              LDR      r1,[r4,#0]            ;1318
00006e  6008              STR      r0,[r1,#0]            ;1318
000070  bf00              NOP                            ;1321
000072  2000              MOVS     r0,#0                 ;1321
000074  f8840038          STRB     r0,[r4,#0x38]         ;1321
000078  bf00              NOP                            ;1321
00007a  6820              LDR      r0,[r4,#0]            ;1325
00007c  6940              LDR      r0,[r0,#0x14]         ;1325
00007e  f0400080          ORR      r0,r0,#0x80           ;1325
000082  6821              LDR      r1,[r4,#0]            ;1325
000084  6148              STR      r0,[r1,#0x14]         ;1325
000086  2000              MOVS     r0,#0                 ;1327
000088  e7c5              B        |L35.22|
                  |L35.138|
00008a  2002              MOVS     r0,#2                 ;1331
00008c  e7c3              B        |L35.22|
;;;1334   
                          ENDP

00008e  0000              DCW      0x0000
                  |L35.144|
                          DCD      UART_DMATransmitCplt
                  |L35.148|
                          DCD      UART_DMATxHalfCplt
                  |L35.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;1188     */
;;;1189   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1190   {
000002  4603              MOV      r3,r0
;;;1191     /* Check that a Tx process is not already ongoing */
;;;1192     if (huart->gState == HAL_UART_STATE_READY)
000004  f8930039          LDRB     r0,[r3,#0x39]
000008  2820              CMP      r0,#0x20
00000a  d123              BNE      |L36.84|
;;;1193     {
;;;1194       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L36.16|
00000e  b90a              CBNZ     r2,|L36.20|
                  |L36.16|
;;;1195       {
;;;1196         return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L36.18|
;;;1197       }
;;;1198   
;;;1199       /* Process Locked */
;;;1200       __HAL_LOCK(huart);
;;;1201   
;;;1202       huart->pTxBuffPtr = pData;
;;;1203       huart->TxXferSize = Size;
;;;1204       huart->TxXferCount = Size;
;;;1205   
;;;1206       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1207       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1208   
;;;1209       /* Process Unlocked */
;;;1210       __HAL_UNLOCK(huart);
;;;1211   
;;;1212       /* Enable the UART Transmit data register empty Interrupt */
;;;1213       __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;1214   
;;;1215       return HAL_OK;
;;;1216     }
;;;1217     else
;;;1218     {
;;;1219       return HAL_BUSY;
;;;1220     }
;;;1221   }
000012  bd10              POP      {r4,pc}
                  |L36.20|
000014  bf00              NOP                            ;1200
000016  f8930038          LDRB     r0,[r3,#0x38]         ;1200
00001a  2801              CMP      r0,#1                 ;1200
00001c  d101              BNE      |L36.34|
00001e  2002              MOVS     r0,#2                 ;1200
000020  e7f7              B        |L36.18|
                  |L36.34|
000022  2001              MOVS     r0,#1                 ;1200
000024  f8830038          STRB     r0,[r3,#0x38]         ;1200
000028  bf00              NOP                            ;1200
00002a  6219              STR      r1,[r3,#0x20]         ;1202
00002c  849a              STRH     r2,[r3,#0x24]         ;1203
00002e  84da              STRH     r2,[r3,#0x26]         ;1204
000030  2000              MOVS     r0,#0                 ;1206
000032  63d8              STR      r0,[r3,#0x3c]         ;1206
000034  2021              MOVS     r0,#0x21              ;1207
000036  f8830039          STRB     r0,[r3,#0x39]         ;1207
00003a  bf00              NOP                            ;1210
00003c  2000              MOVS     r0,#0                 ;1210
00003e  f8830038          STRB     r0,[r3,#0x38]         ;1210
000042  bf00              NOP                            ;1210
000044  6818              LDR      r0,[r3,#0]            ;1213
000046  68c0              LDR      r0,[r0,#0xc]          ;1213
000048  f0400080          ORR      r0,r0,#0x80           ;1213
00004c  681c              LDR      r4,[r3,#0]            ;1213
00004e  60e0              STR      r0,[r4,#0xc]          ;1213
000050  2000              MOVS     r0,#0                 ;1215
000052  e7de              B        |L36.18|
                  |L36.84|
000054  2002              MOVS     r0,#2                 ;1219
000056  e7dc              B        |L36.18|
;;;1222   
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2143     */
;;;2144   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2145   {
;;;2146     /* Prevent unused argument(s) compilation warning */
;;;2147     UNUSED(huart);
;;;2148     /* NOTE: This function should not be modified, when the callback is needed,
;;;2149              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;2150      */
;;;2151   }
;;;2152   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2158     */
;;;2159   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2160   {
;;;2161     /* Prevent unused argument(s) compilation warning */
;;;2162     UNUSED(huart);
;;;2163     /* NOTE: This function should not be modified, when the callback is needed,
;;;2164              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;2165      */
;;;2166   }
;;;2167   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2729     */
;;;2730   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2731   {
000002  4605              MOV      r5,r0
;;;2732     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2733     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;2734     huart->TxXferCount = 0x00U;
00000a  84e0              STRH     r0,[r4,#0x26]
;;;2735   
;;;2736   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2737     /*Call registered error callback*/
;;;2738     huart->ErrorCallback(huart);
;;;2739   #else
;;;2740     /*Call legacy weak error callback*/
;;;2741     HAL_UART_ErrorCallback(huart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2742   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2743   }
000012  bd70              POP      {r4-r6,pc}
;;;2744   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2625     */
;;;2626   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2627   {
000002  4606              MOV      r6,r0
;;;2628     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;2629     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000006  6bb4              LDR      r4,[r6,#0x38]
;;;2630   
;;;2631     /* Stop UART DMA Tx request if ongoing */
;;;2632     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000008  6820              LDR      r0,[r4,#0]
00000a  6940              LDR      r0,[r0,#0x14]
00000c  f3c015c0          UBFX     r5,r0,#7,#1
;;;2633     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2821              CMP      r0,#0x21
000016  d105              BNE      |L40.36|
000018  b125              CBZ      r5,|L40.36|
;;;2634     {
;;;2635       huart->TxXferCount = 0x00U;
00001a  2000              MOVS     r0,#0
00001c  84e0              STRH     r0,[r4,#0x26]
;;;2636       UART_EndTxTransfer(huart);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_EndTxTransfer
                  |L40.36|
;;;2637     }
;;;2638   
;;;2639     /* Stop UART DMA Rx request if ongoing */
;;;2640     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000024  6820              LDR      r0,[r4,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  f3c01580          UBFX     r5,r0,#6,#1
;;;2641     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00002c  f894003a          LDRB     r0,[r4,#0x3a]
000030  2822              CMP      r0,#0x22
000032  d105              BNE      |L40.64|
000034  b125              CBZ      r5,|L40.64|
;;;2642     {
;;;2643       huart->RxXferCount = 0x00U;
000036  2000              MOVS     r0,#0
000038  85e0              STRH     r0,[r4,#0x2e]
;;;2644       UART_EndRxTransfer(huart);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       UART_EndRxTransfer
                  |L40.64|
;;;2645     }
;;;2646   
;;;2647     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000040  6be0              LDR      r0,[r4,#0x3c]
000042  f0400010          ORR      r0,r0,#0x10
000046  63e0              STR      r0,[r4,#0x3c]
;;;2648   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2649     /*Call registered error callback*/
;;;2650     huart->ErrorCallback(huart);
;;;2651   #else
;;;2652     /*Call legacy weak error callback*/
;;;2653     HAL_UART_ErrorCallback(huart);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2654   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2655   }
00004e  bd70              POP      {r4-r6,pc}
;;;2656   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2572     */
;;;2573   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2574   {
000002  4605              MOV      r5,r0
;;;2575     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2576     /* DMA Normal mode*/
;;;2577     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b9b0              CBNZ     r0,|L41.62|
;;;2578     {
;;;2579       huart->RxXferCount = 0U;
000010  2000              MOVS     r0,#0
000012  85e0              STRH     r0,[r4,#0x2e]
;;;2580   
;;;2581       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2582       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6820              LDR      r0,[r4,#0]
000016  68c0              LDR      r0,[r0,#0xc]
000018  f4207080          BIC      r0,r0,#0x100
00001c  6821              LDR      r1,[r4,#0]
00001e  60c8              STR      r0,[r1,#0xc]
;;;2583       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000020  6820              LDR      r0,[r4,#0]
000022  6940              LDR      r0,[r0,#0x14]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6148              STR      r0,[r1,#0x14]
;;;2584   
;;;2585       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;2586          in the UART CR3 register */
;;;2587       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6940              LDR      r0,[r0,#0x14]
000030  f0200040          BIC      r0,r0,#0x40
000034  6821              LDR      r1,[r4,#0]
000036  6148              STR      r0,[r1,#0x14]
;;;2588   
;;;2589       /* At end of Rx process, restore huart->RxState to Ready */
;;;2590       huart->RxState = HAL_UART_STATE_READY;
000038  2020              MOVS     r0,#0x20
00003a  f884003a          STRB     r0,[r4,#0x3a]
                  |L41.62|
;;;2591     }
;;;2592   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2593     /*Call registered Rx complete callback*/
;;;2594     huart->RxCpltCallback(huart);
;;;2595   #else
;;;2596     /*Call legacy weak Rx complete callback*/
;;;2597     HAL_UART_RxCpltCallback(huart);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2598   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2599   }
000044  bd70              POP      {r4-r6,pc}
;;;2600   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2798     */
;;;2799   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2800   {
000002  4605              MOV      r5,r0
;;;2801     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2802   
;;;2803     huart->hdmarx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6b61              LDR      r1,[r4,#0x34]
00000a  6508              STR      r0,[r1,#0x50]
;;;2804   
;;;2805     /* Check if an Abort process is still ongoing */
;;;2806     if (huart->hdmatx != NULL)
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  b118              CBZ      r0,|L42.24|
;;;2807     {
;;;2808       if (huart->hdmatx->XferAbortCallback != NULL)
000010  6b20              LDR      r0,[r4,#0x30]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L42.24|
                  |L42.22|
;;;2809       {
;;;2810         return;
;;;2811       }
;;;2812     }
;;;2813   
;;;2814     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2815     huart->TxXferCount = 0x00U;
;;;2816     huart->RxXferCount = 0x00U;
;;;2817   
;;;2818     /* Reset ErrorCode */
;;;2819     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2820   
;;;2821     /* Restore huart->gState and huart->RxState to Ready */
;;;2822     huart->gState  = HAL_UART_STATE_READY;
;;;2823     huart->RxState = HAL_UART_STATE_READY;
;;;2824   
;;;2825     /* Call user Abort complete callback */
;;;2826   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2827     /* Call registered Abort complete callback */
;;;2828     huart->AbortCpltCallback(huart);
;;;2829   #else
;;;2830     /* Call legacy weak Abort complete callback */
;;;2831     HAL_UART_AbortCpltCallback(huart);
;;;2832   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2833   }
000016  bd70              POP      {r4-r6,pc}
                  |L42.24|
000018  2000              MOVS     r0,#0                 ;2815
00001a  84e0              STRH     r0,[r4,#0x26]         ;2815
00001c  85e0              STRH     r0,[r4,#0x2e]         ;2816
00001e  63e0              STR      r0,[r4,#0x3c]         ;2819
000020  2020              MOVS     r0,#0x20              ;2822
000022  f8840039          STRB     r0,[r4,#0x39]         ;2822
000026  f884003a          STRB     r0,[r4,#0x3a]         ;2823
00002a  4620              MOV      r0,r4                 ;2831
00002c  f7fffffe          BL       HAL_UART_AbortCpltCallback
000030  bf00              NOP      
000032  e7f0              B        |L42.22|
;;;2834   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2606     */
;;;2607   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2608   {
000002  4604              MOV      r4,r0
;;;2609     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2610   
;;;2611   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2612     /*Call registered Rx Half complete callback*/
;;;2613     huart->RxHalfCpltCallback(huart);
;;;2614   #else
;;;2615     /*Call legacy weak Rx Half complete callback*/
;;;2616     HAL_UART_RxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2617   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2618   }
00000c  bd70              POP      {r4-r6,pc}
;;;2619   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2871     */
;;;2872   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2873   {
000002  4605              MOV      r5,r0
;;;2874     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2875   
;;;2876     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;2877   
;;;2878     /* Restore huart->RxState to Ready */
;;;2879     huart->RxState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f884003a          STRB     r0,[r4,#0x3a]
;;;2880   
;;;2881     /* Call user Abort complete callback */
;;;2882   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2883     /* Call registered Abort Receive Complete Callback */
;;;2884     huart->AbortReceiveCpltCallback(huart);
;;;2885   #else
;;;2886     /* Call legacy weak Abort Receive Complete Callback */
;;;2887     HAL_UART_AbortReceiveCpltCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2888   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2889   }
000016  bd70              POP      {r4-r6,pc}
;;;2890   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2518     */
;;;2519   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2520   {
000002  4605              MOV      r5,r0
;;;2521     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2522     /* DMA Normal mode*/
;;;2523     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b970              CBNZ     r0,|L45.46|
;;;2524     {
;;;2525       huart->TxXferCount = 0x00U;
000010  2000              MOVS     r0,#0
000012  84e0              STRH     r0,[r4,#0x26]
;;;2526   
;;;2527       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2528          in the UART CR3 register */
;;;2529       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6820              LDR      r0,[r4,#0]
000016  6940              LDR      r0,[r0,#0x14]
000018  f0200080          BIC      r0,r0,#0x80
00001c  6821              LDR      r1,[r4,#0]
00001e  6148              STR      r0,[r1,#0x14]
;;;2530   
;;;2531       /* Enable the UART Transmit Complete Interrupt */
;;;2532       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000020  6820              LDR      r0,[r4,#0]
000022  68c0              LDR      r0,[r0,#0xc]
000024  f0400040          ORR      r0,r0,#0x40
000028  6821              LDR      r1,[r4,#0]
00002a  60c8              STR      r0,[r1,#0xc]
00002c  e002              B        |L45.52|
                  |L45.46|
;;;2533   
;;;2534     }
;;;2535     /* DMA Circular mode */
;;;2536     else
;;;2537     {
;;;2538   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2539       /*Call registered Tx complete callback*/
;;;2540       huart->TxCpltCallback(huart);
;;;2541   #else
;;;2542       /*Call legacy weak Tx complete callback*/
;;;2543       HAL_UART_TxCpltCallback(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L45.52|
;;;2544   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2545     }
;;;2546   }
000034  bd70              POP      {r4-r6,pc}
;;;2547   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2753     */
;;;2754   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2755   {
000002  4605              MOV      r5,r0
;;;2756     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2757   
;;;2758     huart->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6b21              LDR      r1,[r4,#0x30]
00000a  6508              STR      r0,[r1,#0x50]
;;;2759   
;;;2760     /* Check if an Abort process is still ongoing */
;;;2761     if (huart->hdmarx != NULL)
00000c  6b60              LDR      r0,[r4,#0x34]
00000e  b118              CBZ      r0,|L46.24|
;;;2762     {
;;;2763       if (huart->hdmarx->XferAbortCallback != NULL)
000010  6b60              LDR      r0,[r4,#0x34]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L46.24|
                  |L46.22|
;;;2764       {
;;;2765         return;
;;;2766       }
;;;2767     }
;;;2768   
;;;2769     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2770     huart->TxXferCount = 0x00U;
;;;2771     huart->RxXferCount = 0x00U;
;;;2772   
;;;2773     /* Reset ErrorCode */
;;;2774     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2775   
;;;2776     /* Restore huart->gState and huart->RxState to Ready */
;;;2777     huart->gState  = HAL_UART_STATE_READY;
;;;2778     huart->RxState = HAL_UART_STATE_READY;
;;;2779   
;;;2780     /* Call user Abort complete callback */
;;;2781   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2782     /* Call registered Abort complete callback */
;;;2783     huart->AbortCpltCallback(huart);
;;;2784   #else
;;;2785     /* Call legacy weak Abort complete callback */
;;;2786     HAL_UART_AbortCpltCallback(huart);
;;;2787   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2788   }
000016  bd70              POP      {r4-r6,pc}
                  |L46.24|
000018  2000              MOVS     r0,#0                 ;2770
00001a  84e0              STRH     r0,[r4,#0x26]         ;2770
00001c  85e0              STRH     r0,[r4,#0x2e]         ;2771
00001e  63e0              STR      r0,[r4,#0x3c]         ;2774
000020  2020              MOVS     r0,#0x20              ;2777
000022  f8840039          STRB     r0,[r4,#0x39]         ;2777
000026  f884003a          STRB     r0,[r4,#0x3a]         ;2778
00002a  4620              MOV      r0,r4                 ;2786
00002c  f7fffffe          BL       HAL_UART_AbortCpltCallback
000030  bf00              NOP      
000032  e7f0              B        |L46.22|
;;;2789   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2553     */
;;;2554   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2555   {
000002  4604              MOV      r4,r0
;;;2556     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2557   
;;;2558   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2559     /*Call registered Tx complete callback*/
;;;2560     huart->TxHalfCpltCallback(huart);
;;;2561   #else
;;;2562     /*Call legacy weak Tx complete callback*/
;;;2563     HAL_UART_TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2564   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2565   }
00000c  bd70              POP      {r4-r6,pc}
;;;2566   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2843     */
;;;2844   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2845   {
000002  4605              MOV      r5,r0
;;;2846     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2847   
;;;2848     huart->TxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  84e0              STRH     r0,[r4,#0x26]
;;;2849   
;;;2850     /* Restore huart->gState to Ready */
;;;2851     huart->gState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f8840039          STRB     r0,[r4,#0x39]
;;;2852   
;;;2853     /* Call user Abort complete callback */
;;;2854   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2855     /* Call registered Abort Transmit Complete Callback */
;;;2856     huart->AbortTransmitCpltCallback(huart);
;;;2857   #else
;;;2858     /* Call legacy weak Abort Transmit Complete Callback */
;;;2859     HAL_UART_AbortTransmitCpltCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2860   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2861   }
000016  bd70              POP      {r4-r6,pc}
;;;2862   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;2712     */
;;;2713   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2714   {
;;;2715     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2716     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  68c9              LDR      r1,[r1,#0xc]
000004  f4217190          BIC      r1,r1,#0x120
000008  6802              LDR      r2,[r0,#0]
00000a  60d1              STR      r1,[r2,#0xc]
;;;2717     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000c  6801              LDR      r1,[r0,#0]
00000e  6949              LDR      r1,[r1,#0x14]
000010  f0210101          BIC      r1,r1,#1
000014  6802              LDR      r2,[r0,#0]
000016  6151              STR      r1,[r2,#0x14]
;;;2718   
;;;2719     /* At end of Rx process, restore huart->RxState to Ready */
;;;2720     huart->RxState = HAL_UART_STATE_READY;
000018  2120              MOVS     r1,#0x20
00001a  f880103a          STRB     r1,[r0,#0x3a]
;;;2721   }
00001e  4770              BX       lr
;;;2722   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;2943     */
;;;2944   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2945   {
000002  4604              MOV      r4,r0
;;;2946     /* Disable the UART Transmit Complete Interrupt */
;;;2947     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;2948   
;;;2949     /* Tx process is ended, restore huart->gState to Ready */
;;;2950     huart->gState = HAL_UART_STATE_READY;
000010  2020              MOVS     r0,#0x20
000012  f8840039          STRB     r0,[r4,#0x39]
;;;2951   
;;;2952   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2953     /*Call registered Tx complete callback*/
;;;2954     huart->TxCpltCallback(huart);
;;;2955   #else
;;;2956     /*Call legacy weak Tx complete callback*/
;;;2957     HAL_UART_TxCpltCallback(huart);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2958   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2959   
;;;2960     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;2961   }
00001e  bd10              POP      {r4,pc}
;;;2962   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;2698     */
;;;2699   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2700   {
;;;2701     /* Disable TXEIE and TCIE interrupts */
;;;2702     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  68c9              LDR      r1,[r1,#0xc]
000004  f02101c0          BIC      r1,r1,#0xc0
000008  6802              LDR      r2,[r0,#0]
00000a  60d1              STR      r1,[r2,#0xc]
;;;2703   
;;;2704     /* At end of Tx process, restore huart->gState to Ready */
;;;2705     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  f8801039          STRB     r1,[r0,#0x39]
;;;2706   }
000012  4770              BX       lr
;;;2707   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;2968     */
;;;2969   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2970   {
000002  4604              MOV      r4,r0
;;;2971     uint16_t *tmp;
;;;2972   
;;;2973     /* Check that a Rx process is ongoing */
;;;2974     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000004  f894003a          LDRB     r0,[r4,#0x3a]
000008  2822              CMP      r0,#0x22
00000a  d14a              BNE      |L52.162|
;;;2975     {
;;;2976       if (huart->Init.WordLength == UART_WORDLENGTH_9B)
00000c  68a0              LDR      r0,[r4,#8]
00000e  f5b05f80          CMP      r0,#0x1000
000012  d113              BNE      |L52.60|
;;;2977       {
;;;2978         tmp = (uint16_t *) huart->pRxBuffPtr;
000014  6aa5              LDR      r5,[r4,#0x28]
;;;2979         if (huart->Init.Parity == UART_PARITY_NONE)
000016  6920              LDR      r0,[r4,#0x10]
000018  b940              CBNZ     r0,|L52.44|
;;;2980         {
;;;2981           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f3c00008          UBFX     r0,r0,#0,#9
000022  8028              STRH     r0,[r5,#0]
;;;2982           huart->pRxBuffPtr += 2U;
000024  6aa0              LDR      r0,[r4,#0x28]
000026  1c80              ADDS     r0,r0,#2
000028  62a0              STR      r0,[r4,#0x28]
00002a  e019              B        |L52.96|
                  |L52.44|
;;;2983         }
;;;2984         else
;;;2985         {
;;;2986           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  b2c0              UXTB     r0,r0
000032  8028              STRH     r0,[r5,#0]
;;;2987           huart->pRxBuffPtr += 1U;
000034  6aa0              LDR      r0,[r4,#0x28]
000036  1c40              ADDS     r0,r0,#1
000038  62a0              STR      r0,[r4,#0x28]
00003a  e011              B        |L52.96|
                  |L52.60|
;;;2988         }
;;;2989       }
;;;2990       else
;;;2991       {
;;;2992         if (huart->Init.Parity == UART_PARITY_NONE)
00003c  6920              LDR      r0,[r4,#0x10]
00003e  b938              CBNZ     r0,|L52.80|
;;;2993         {
;;;2994           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
000040  6820              LDR      r0,[r4,#0]
000042  6840              LDR      r0,[r0,#4]
000044  b2c1              UXTB     r1,r0
000046  6aa2              LDR      r2,[r4,#0x28]
000048  1c50              ADDS     r0,r2,#1
00004a  62a0              STR      r0,[r4,#0x28]
00004c  7011              STRB     r1,[r2,#0]
00004e  e007              B        |L52.96|
                  |L52.80|
;;;2995         }
;;;2996         else
;;;2997         {
;;;2998           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
000050  6820              LDR      r0,[r4,#0]
000052  6840              LDR      r0,[r0,#4]
000054  f000017f          AND      r1,r0,#0x7f
000058  6aa2              LDR      r2,[r4,#0x28]
00005a  1c50              ADDS     r0,r2,#1
00005c  62a0              STR      r0,[r4,#0x28]
00005e  7011              STRB     r1,[r2,#0]
                  |L52.96|
;;;2999         }
;;;3000       }
;;;3001   
;;;3002       if (--huart->RxXferCount == 0U)
000060  8de0              LDRH     r0,[r4,#0x2e]
000062  1e40              SUBS     r0,r0,#1
000064  b280              UXTH     r0,r0
000066  85e0              STRH     r0,[r4,#0x2e]
000068  b9c8              CBNZ     r0,|L52.158|
;;;3003       {
;;;3004         /* Disable the UART Data Register not empty Interrupt */
;;;3005         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
00006a  6820              LDR      r0,[r4,#0]
00006c  68c0              LDR      r0,[r0,#0xc]
00006e  f0200020          BIC      r0,r0,#0x20
000072  6821              LDR      r1,[r4,#0]
000074  60c8              STR      r0,[r1,#0xc]
;;;3006   
;;;3007         /* Disable the UART Parity Error Interrupt */
;;;3008         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000076  6820              LDR      r0,[r4,#0]
000078  68c0              LDR      r0,[r0,#0xc]
00007a  f4207080          BIC      r0,r0,#0x100
00007e  6821              LDR      r1,[r4,#0]
000080  60c8              STR      r0,[r1,#0xc]
;;;3009   
;;;3010         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3011         __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
000082  6820              LDR      r0,[r4,#0]
000084  6940              LDR      r0,[r0,#0x14]
000086  f0200001          BIC      r0,r0,#1
00008a  6821              LDR      r1,[r4,#0]
00008c  6148              STR      r0,[r1,#0x14]
;;;3012   
;;;3013         /* Rx process is completed, restore huart->RxState to Ready */
;;;3014         huart->RxState = HAL_UART_STATE_READY;
00008e  2020              MOVS     r0,#0x20
000090  f884003a          STRB     r0,[r4,#0x3a]
;;;3015   
;;;3016   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3017         /*Call registered Rx complete callback*/
;;;3018         huart->RxCpltCallback(huart);
;;;3019   #else
;;;3020         /*Call legacy weak Rx complete callback*/
;;;3021         HAL_UART_RxCpltCallback(huart);
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;3022   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3023   
;;;3024         return HAL_OK;
00009a  2000              MOVS     r0,#0
                  |L52.156|
;;;3025       }
;;;3026       return HAL_OK;
;;;3027     }
;;;3028     else
;;;3029     {
;;;3030       return HAL_BUSY;
;;;3031     }
;;;3032   }
00009c  bd70              POP      {r4-r6,pc}
                  |L52.158|
00009e  2000              MOVS     r0,#0                 ;3026
0000a0  e7fc              B        |L52.156|
                  |L52.162|
0000a2  2002              MOVS     r0,#2                 ;3030
0000a4  e7fa              B        |L52.156|
;;;3033   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;3039     */
;;;3040   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3041   {
000004  4604              MOV      r4,r0
;;;3042     uint32_t tmpreg;
;;;3043   
;;;3044     /* Check the parameters */
;;;3045     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;3046     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;3047     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;3048     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;3049   
;;;3050     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;3051     /* Configure the UART Stop Bits: Set STOP[13:12] bits
;;;3052        according to huart->Init.StopBits value */
;;;3053     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6820              LDR      r0,[r4,#0]
000008  6900              LDR      r0,[r0,#0x10]
00000a  f4205040          BIC      r0,r0,#0x3000
00000e  68e1              LDR      r1,[r4,#0xc]
000010  4308              ORRS     r0,r0,r1
000012  6821              LDR      r1,[r4,#0]
000014  6108              STR      r0,[r1,#0x10]
;;;3054   
;;;3055     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;3056     /* Configure the UART Word Length, Parity and mode:
;;;3057        Set the M bits according to huart->Init.WordLength value
;;;3058        Set PCE and PS bits according to huart->Init.Parity value
;;;3059        Set TE and RE bits according to huart->Init.Mode value
;;;3060        Set OVER8 bit according to huart->Init.OverSampling value */
;;;3061   
;;;3062     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
000016  6921              LDR      r1,[r4,#0x10]
000018  68a0              LDR      r0,[r4,#8]
00001a  4308              ORRS     r0,r0,r1
00001c  6961              LDR      r1,[r4,#0x14]
00001e  4308              ORRS     r0,r0,r1
000020  69e1              LDR      r1,[r4,#0x1c]
000022  ea400501          ORR      r5,r0,r1
;;;3063     MODIFY_REG(huart->Instance->CR1,
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f249610c          MOV      r1,#0x960c
00002e  4388              BICS     r0,r0,r1
000030  4328              ORRS     r0,r0,r5
000032  6821              LDR      r1,[r4,#0]
000034  60c8              STR      r0,[r1,#0xc]
;;;3064                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;3065                tmpreg);
;;;3066   
;;;3067     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;3068     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;3069     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
000036  6820              LDR      r0,[r4,#0]
000038  6940              LDR      r0,[r0,#0x14]
00003a  f4207040          BIC      r0,r0,#0x300
00003e  69a1              LDR      r1,[r4,#0x18]
000040  4308              ORRS     r0,r0,r1
000042  6821              LDR      r1,[r4,#0]
000044  6148              STR      r0,[r1,#0x14]
;;;3070   
;;;3071     /* Check the Over Sampling */
;;;3072     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000046  69e0              LDR      r0,[r4,#0x1c]
000048  f5b04f00          CMP      r0,#0x8000
00004c  d17e              BNE      |L53.332|
;;;3073     {
;;;3074       /*-------------------------- USART BRR Configuration ---------------------*/
;;;3075   #if defined(USART6)
;;;3076       if ((huart->Instance == USART1) || (huart->Instance == USART6))
00004e  49c4              LDR      r1,|L53.864|
000050  6820              LDR      r0,[r4,#0]
000052  4288              CMP      r0,r1
000054  d003              BEQ      |L53.94|
000056  49c3              LDR      r1,|L53.868|
000058  6820              LDR      r0,[r4,#0]
00005a  4288              CMP      r0,r1
00005c  d15d              BNE      |L53.282|
                  |L53.94|
;;;3077       {
;;;3078         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
00005e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000062  eb0001c0          ADD      r1,r0,r0,LSL #3
000066  eb011000          ADD      r0,r1,r0,LSL #4
00006a  6861              LDR      r1,[r4,#4]
00006c  0049              LSLS     r1,r1,#1
00006e  fbb0f0f1          UDIV     r0,r0,r1
000072  2164              MOVS     r1,#0x64
000074  fbb0f0f1          UDIV     r0,r0,r1
000078  0106              LSLS     r6,r0,#4
00007a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00007e  eb0001c0          ADD      r1,r0,r0,LSL #3
000082  eb011000          ADD      r0,r1,r0,LSL #4
000086  6861              LDR      r1,[r4,#4]
000088  0049              LSLS     r1,r1,#1
00008a  fbb0f7f1          UDIV     r7,r0,r1
00008e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000092  eb0001c0          ADD      r1,r0,r0,LSL #3
000096  eb011000          ADD      r0,r1,r0,LSL #4
00009a  6861              LDR      r1,[r4,#4]
00009c  0049              LSLS     r1,r1,#1
00009e  fbb0f0f1          UDIV     r0,r0,r1
0000a2  2164              MOVS     r1,#0x64
0000a4  fbb0f0f1          UDIV     r0,r0,r1
0000a8  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ac  eb011000          ADD      r0,r1,r0,LSL #4
0000b0  eba70080          SUB      r0,r7,r0,LSL #2
0000b4  2132              MOVS     r1,#0x32
0000b6  eb0100c0          ADD      r0,r1,r0,LSL #3
0000ba  2164              MOVS     r1,#0x64
0000bc  fbb0f0f1          UDIV     r0,r0,r1
0000c0  f00000f8          AND      r0,r0,#0xf8
0000c4  eb060640          ADD      r6,r6,r0,LSL #1
0000c8  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000cc  eb0001c0          ADD      r1,r0,r0,LSL #3
0000d0  eb011000          ADD      r0,r1,r0,LSL #4
0000d4  6861              LDR      r1,[r4,#4]
0000d6  0049              LSLS     r1,r1,#1
0000d8  fbb0f7f1          UDIV     r7,r0,r1
0000dc  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000e0  eb0001c0          ADD      r1,r0,r0,LSL #3
0000e4  eb011000          ADD      r0,r1,r0,LSL #4
0000e8  6861              LDR      r1,[r4,#4]
0000ea  0049              LSLS     r1,r1,#1
0000ec  fbb0f0f1          UDIV     r0,r0,r1
0000f0  2164              MOVS     r1,#0x64
0000f2  fbb0f0f1          UDIV     r0,r0,r1
0000f6  eb0001c0          ADD      r1,r0,r0,LSL #3
0000fa  eb011000          ADD      r0,r1,r0,LSL #4
0000fe  eba70080          SUB      r0,r7,r0,LSL #2
000102  2132              MOVS     r1,#0x32
000104  eb0100c0          ADD      r0,r1,r0,LSL #3
000108  2164              MOVS     r1,#0x64
00010a  fbb0f0f1          UDIV     r0,r0,r1
00010e  f0000007          AND      r0,r0,#7
000112  4430              ADD      r0,r0,r6
000114  6821              LDR      r1,[r4,#0]
000116  6088              STR      r0,[r1,#8]
000118  e120              B        |L53.860|
                  |L53.282|
;;;3079       }
;;;3080   #else
;;;3081       if (huart->Instance == USART1)
;;;3082       {
;;;3083         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;3084       }
;;;3085   #endif /* USART6 */
;;;3086       else
;;;3087       {
;;;3088         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
00011a  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00011e  eb0001c0          ADD      r1,r0,r0,LSL #3
000122  eb011000          ADD      r0,r1,r0,LSL #4
000126  6861              LDR      r1,[r4,#4]
000128  0049              LSLS     r1,r1,#1
00012a  fbb0f0f1          UDIV     r0,r0,r1
00012e  2164              MOVS     r1,#0x64
000130  fbb0f0f1          UDIV     r0,r0,r1
000134  0106              LSLS     r6,r0,#4
000136  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00013a  eb0001c0          ADD      r1,r0,r0,LSL #3
00013e  eb011000          ADD      r0,r1,r0,LSL #4
000142  6861              LDR      r1,[r4,#4]
000144  0049              LSLS     r1,r1,#1
000146  fbb0f7f1          UDIV     r7,r0,r1
00014a  e000              B        |L53.334|
                  |L53.332|
00014c  e045              B        |L53.474|
                  |L53.334|
00014e  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000152  eb0001c0          ADD      r1,r0,r0,LSL #3
000156  eb011000          ADD      r0,r1,r0,LSL #4
00015a  6861              LDR      r1,[r4,#4]
00015c  0049              LSLS     r1,r1,#1
00015e  fbb0f0f1          UDIV     r0,r0,r1
000162  2164              MOVS     r1,#0x64
000164  fbb0f0f1          UDIV     r0,r0,r1
000168  eb0001c0          ADD      r1,r0,r0,LSL #3
00016c  eb011000          ADD      r0,r1,r0,LSL #4
000170  eba70080          SUB      r0,r7,r0,LSL #2
000174  2132              MOVS     r1,#0x32
000176  eb0100c0          ADD      r0,r1,r0,LSL #3
00017a  2164              MOVS     r1,#0x64
00017c  fbb0f0f1          UDIV     r0,r0,r1
000180  f00000f8          AND      r0,r0,#0xf8
000184  eb060640          ADD      r6,r6,r0,LSL #1
000188  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00018c  eb0001c0          ADD      r1,r0,r0,LSL #3
000190  eb011000          ADD      r0,r1,r0,LSL #4
000194  6861              LDR      r1,[r4,#4]
000196  0049              LSLS     r1,r1,#1
000198  fbb0f7f1          UDIV     r7,r0,r1
00019c  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001a0  eb0001c0          ADD      r1,r0,r0,LSL #3
0001a4  eb011000          ADD      r0,r1,r0,LSL #4
0001a8  6861              LDR      r1,[r4,#4]
0001aa  0049              LSLS     r1,r1,#1
0001ac  fbb0f0f1          UDIV     r0,r0,r1
0001b0  2164              MOVS     r1,#0x64
0001b2  fbb0f0f1          UDIV     r0,r0,r1
0001b6  eb0001c0          ADD      r1,r0,r0,LSL #3
0001ba  eb011000          ADD      r0,r1,r0,LSL #4
0001be  eba70080          SUB      r0,r7,r0,LSL #2
0001c2  2132              MOVS     r1,#0x32
0001c4  eb0100c0          ADD      r0,r1,r0,LSL #3
0001c8  2164              MOVS     r1,#0x64
0001ca  fbb0f0f1          UDIV     r0,r0,r1
0001ce  f0000007          AND      r0,r0,#7
0001d2  4430              ADD      r0,r0,r6
0001d4  6821              LDR      r1,[r4,#0]
0001d6  6088              STR      r0,[r1,#8]
0001d8  e0c0              B        |L53.860|
                  |L53.474|
;;;3089       }
;;;3090     }
;;;3091     else
;;;3092     {
;;;3093       /*-------------------------- USART BRR Configuration ---------------------*/
;;;3094   #if defined(USART6)
;;;3095       if ((huart->Instance == USART1) || (huart->Instance == USART6))
0001da  4961              LDR      r1,|L53.864|
0001dc  6820              LDR      r0,[r4,#0]
0001de  4288              CMP      r0,r1
0001e0  d003              BEQ      |L53.490|
0001e2  4960              LDR      r1,|L53.868|
0001e4  6820              LDR      r0,[r4,#0]
0001e6  4288              CMP      r0,r1
0001e8  d15c              BNE      |L53.676|
                  |L53.490|
;;;3096       {
;;;3097         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
0001ea  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0001ee  eb0001c0          ADD      r1,r0,r0,LSL #3
0001f2  eb011000          ADD      r0,r1,r0,LSL #4
0001f6  6861              LDR      r1,[r4,#4]
0001f8  0089              LSLS     r1,r1,#2
0001fa  fbb0f6f1          UDIV     r6,r0,r1
0001fe  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000202  eb0001c0          ADD      r1,r0,r0,LSL #3
000206  eb011000          ADD      r0,r1,r0,LSL #4
00020a  6861              LDR      r1,[r4,#4]
00020c  0089              LSLS     r1,r1,#2
00020e  fbb0f0f1          UDIV     r0,r0,r1
000212  2164              MOVS     r1,#0x64
000214  fbb0f0f1          UDIV     r0,r0,r1
000218  eb0001c0          ADD      r1,r0,r0,LSL #3
00021c  eb011000          ADD      r0,r1,r0,LSL #4
000220  eba60080          SUB      r0,r6,r0,LSL #2
000224  2132              MOVS     r1,#0x32
000226  eb011000          ADD      r0,r1,r0,LSL #4
00022a  2164              MOVS     r1,#0x64
00022c  fbb0f0f1          UDIV     r0,r0,r1
000230  f00006f0          AND      r6,r0,#0xf0
000234  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000238  eb0001c0          ADD      r1,r0,r0,LSL #3
00023c  eb011000          ADD      r0,r1,r0,LSL #4
000240  6861              LDR      r1,[r4,#4]
000242  0089              LSLS     r1,r1,#2
000244  fbb0f0f1          UDIV     r0,r0,r1
000248  2164              MOVS     r1,#0x64
00024a  fbb0f0f1          UDIV     r0,r0,r1
00024e  eb061600          ADD      r6,r6,r0,LSL #4
000252  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000256  eb0001c0          ADD      r1,r0,r0,LSL #3
00025a  eb011000          ADD      r0,r1,r0,LSL #4
00025e  6861              LDR      r1,[r4,#4]
000260  0089              LSLS     r1,r1,#2
000262  fbb0f7f1          UDIV     r7,r0,r1
000266  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00026a  eb0001c0          ADD      r1,r0,r0,LSL #3
00026e  eb011000          ADD      r0,r1,r0,LSL #4
000272  6861              LDR      r1,[r4,#4]
000274  0089              LSLS     r1,r1,#2
000276  fbb0f0f1          UDIV     r0,r0,r1
00027a  2164              MOVS     r1,#0x64
00027c  fbb0f0f1          UDIV     r0,r0,r1
000280  eb0001c0          ADD      r1,r0,r0,LSL #3
000284  eb011000          ADD      r0,r1,r0,LSL #4
000288  eba70080          SUB      r0,r7,r0,LSL #2
00028c  2132              MOVS     r1,#0x32
00028e  eb011000          ADD      r0,r1,r0,LSL #4
000292  2164              MOVS     r1,#0x64
000294  fbb0f0f1          UDIV     r0,r0,r1
000298  f000000f          AND      r0,r0,#0xf
00029c  4430              ADD      r0,r0,r6
00029e  6821              LDR      r1,[r4,#0]
0002a0  6088              STR      r0,[r1,#8]
0002a2  e05b              B        |L53.860|
                  |L53.676|
;;;3098       }
;;;3099   #else
;;;3100       if (huart->Instance == USART1)
;;;3101       {
;;;3102         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;3103       }
;;;3104   #endif /* USART6 */
;;;3105       else
;;;3106       {
;;;3107         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
0002a4  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0002a8  eb0001c0          ADD      r1,r0,r0,LSL #3
0002ac  eb011000          ADD      r0,r1,r0,LSL #4
0002b0  6861              LDR      r1,[r4,#4]
0002b2  0089              LSLS     r1,r1,#2
0002b4  fbb0f6f1          UDIV     r6,r0,r1
0002b8  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0002bc  eb0001c0          ADD      r1,r0,r0,LSL #3
0002c0  eb011000          ADD      r0,r1,r0,LSL #4
0002c4  6861              LDR      r1,[r4,#4]
0002c6  0089              LSLS     r1,r1,#2
0002c8  fbb0f0f1          UDIV     r0,r0,r1
0002cc  2164              MOVS     r1,#0x64
0002ce  fbb0f0f1          UDIV     r0,r0,r1
0002d2  eb0001c0          ADD      r1,r0,r0,LSL #3
0002d6  eb011000          ADD      r0,r1,r0,LSL #4
0002da  eba60080          SUB      r0,r6,r0,LSL #2
0002de  2132              MOVS     r1,#0x32
0002e0  eb011000          ADD      r0,r1,r0,LSL #4
0002e4  2164              MOVS     r1,#0x64
0002e6  fbb0f0f1          UDIV     r0,r0,r1
0002ea  f00006f0          AND      r6,r0,#0xf0
0002ee  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0002f2  eb0001c0          ADD      r1,r0,r0,LSL #3
0002f6  eb011000          ADD      r0,r1,r0,LSL #4
0002fa  6861              LDR      r1,[r4,#4]
0002fc  0089              LSLS     r1,r1,#2
0002fe  fbb0f0f1          UDIV     r0,r0,r1
000302  2164              MOVS     r1,#0x64
000304  fbb0f0f1          UDIV     r0,r0,r1
000308  eb061600          ADD      r6,r6,r0,LSL #4
00030c  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000310  eb0001c0          ADD      r1,r0,r0,LSL #3
000314  eb011000          ADD      r0,r1,r0,LSL #4
000318  6861              LDR      r1,[r4,#4]
00031a  0089              LSLS     r1,r1,#2
00031c  fbb0f7f1          UDIV     r7,r0,r1
000320  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000324  eb0001c0          ADD      r1,r0,r0,LSL #3
000328  eb011000          ADD      r0,r1,r0,LSL #4
00032c  6861              LDR      r1,[r4,#4]
00032e  0089              LSLS     r1,r1,#2
000330  fbb0f0f1          UDIV     r0,r0,r1
000334  2164              MOVS     r1,#0x64
000336  fbb0f0f1          UDIV     r0,r0,r1
00033a  eb0001c0          ADD      r1,r0,r0,LSL #3
00033e  eb011000          ADD      r0,r1,r0,LSL #4
000342  eba70080          SUB      r0,r7,r0,LSL #2
000346  2132              MOVS     r1,#0x32
000348  eb011000          ADD      r0,r1,r0,LSL #4
00034c  2164              MOVS     r1,#0x64
00034e  fbb0f0f1          UDIV     r0,r0,r1
000352  f000000f          AND      r0,r0,#0xf
000356  4430              ADD      r0,r0,r6
000358  6821              LDR      r1,[r4,#0]
00035a  6088              STR      r0,[r1,#8]
                  |L53.860|
;;;3108       }
;;;3109     }
;;;3110   }
00035c  e8bd81f0          POP      {r4-r8,pc}
;;;3111   
                          ENDP

                  |L53.864|
                          DCD      0x40011000
                  |L53.868|
                          DCD      0x40011400

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2896     */
;;;2897   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2898   {
;;;2899     uint16_t *tmp;
;;;2900   
;;;2901     /* Check that a Tx process is ongoing */
;;;2902     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  f8910039          LDRB     r0,[r1,#0x39]
000006  2821              CMP      r0,#0x21
000008  d12c              BNE      |L54.100|
;;;2903     {
;;;2904       if (huart->Init.WordLength == UART_WORDLENGTH_9B)
00000a  6888              LDR      r0,[r1,#8]
00000c  f5b05f80          CMP      r0,#0x1000
000010  d10f              BNE      |L54.50|
;;;2905       {
;;;2906         tmp = (uint16_t *) huart->pTxBuffPtr;
000012  6a0a              LDR      r2,[r1,#0x20]
;;;2907         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
000014  8810              LDRH     r0,[r2,#0]
000016  f3c00008          UBFX     r0,r0,#0,#9
00001a  680b              LDR      r3,[r1,#0]
00001c  6058              STR      r0,[r3,#4]
;;;2908         if (huart->Init.Parity == UART_PARITY_NONE)
00001e  6908              LDR      r0,[r1,#0x10]
000020  b918              CBNZ     r0,|L54.42|
;;;2909         {
;;;2910           huart->pTxBuffPtr += 2U;
000022  6a08              LDR      r0,[r1,#0x20]
000024  1c80              ADDS     r0,r0,#2
000026  6208              STR      r0,[r1,#0x20]
000028  e009              B        |L54.62|
                  |L54.42|
;;;2911         }
;;;2912         else
;;;2913         {
;;;2914           huart->pTxBuffPtr += 1U;
00002a  6a08              LDR      r0,[r1,#0x20]
00002c  1c40              ADDS     r0,r0,#1
00002e  6208              STR      r0,[r1,#0x20]
000030  e005              B        |L54.62|
                  |L54.50|
;;;2915         }
;;;2916       }
;;;2917       else
;;;2918       {
;;;2919         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
000032  6a0b              LDR      r3,[r1,#0x20]
000034  1c58              ADDS     r0,r3,#1
000036  6208              STR      r0,[r1,#0x20]
000038  7818              LDRB     r0,[r3,#0]
00003a  680b              LDR      r3,[r1,#0]
00003c  6058              STR      r0,[r3,#4]
                  |L54.62|
;;;2920       }
;;;2921   
;;;2922       if (--huart->TxXferCount == 0U)
00003e  8cc8              LDRH     r0,[r1,#0x26]
000040  1e40              SUBS     r0,r0,#1
000042  b280              UXTH     r0,r0
000044  84c8              STRH     r0,[r1,#0x26]
000046  b958              CBNZ     r0,|L54.96|
;;;2923       {
;;;2924         /* Disable the UART Transmit Complete Interrupt */
;;;2925         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
000048  6808              LDR      r0,[r1,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  f0200080          BIC      r0,r0,#0x80
000050  680b              LDR      r3,[r1,#0]
000052  60d8              STR      r0,[r3,#0xc]
;;;2926   
;;;2927         /* Enable the UART Transmit Complete Interrupt */
;;;2928         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
000054  6808              LDR      r0,[r1,#0]
000056  68c0              LDR      r0,[r0,#0xc]
000058  f0400040          ORR      r0,r0,#0x40
00005c  680b              LDR      r3,[r1,#0]
00005e  60d8              STR      r0,[r3,#0xc]
                  |L54.96|
;;;2929       }
;;;2930       return HAL_OK;
000060  2000              MOVS     r0,#0
                  |L54.98|
;;;2931     }
;;;2932     else
;;;2933     {
;;;2934       return HAL_BUSY;
;;;2935     }
;;;2936   }
000062  4770              BX       lr
                  |L54.100|
000064  2002              MOVS     r0,#2                 ;2934
000066  e7fc              B        |L54.98|
;;;2937   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2666     */
;;;2667   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2668   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e06              LDR      r6,[sp,#0x18]
;;;2669     /* Wait until flag is set */
;;;2670     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000e  e021              B        |L55.84|
                  |L55.16|
;;;2671     {
;;;2672       /* Check for the Timeout */
;;;2673       if (Timeout != HAL_MAX_DELAY)
000010  1c70              ADDS     r0,r6,#1
000012  b1f8              CBZ      r0,|L55.84|
;;;2674       {
;;;2675         if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
000014  b12e              CBZ      r6,|L55.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d918              BLS      |L55.84|
                  |L55.34|
;;;2676         {
;;;2677           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2678           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000022  6820              LDR      r0,[r4,#0]
000024  68c0              LDR      r0,[r0,#0xc]
000026  f42070d0          BIC      r0,r0,#0x1a0
00002a  6821              LDR      r1,[r4,#0]
00002c  60c8              STR      r0,[r1,#0xc]
;;;2679           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00002e  6820              LDR      r0,[r4,#0]
000030  6940              LDR      r0,[r0,#0x14]
000032  f0200001          BIC      r0,r0,#1
000036  6821              LDR      r1,[r4,#0]
000038  6148              STR      r0,[r1,#0x14]
;;;2680   
;;;2681           huart->gState  = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  f8840039          STRB     r0,[r4,#0x39]
;;;2682           huart->RxState = HAL_UART_STATE_READY;
000040  f884003a          STRB     r0,[r4,#0x3a]
;;;2683   
;;;2684           /* Process Unlocked */
;;;2685           __HAL_UNLOCK(huart);
000044  bf00              NOP      
000046  2000              MOVS     r0,#0
000048  f8840038          STRB     r0,[r4,#0x38]
00004c  bf00              NOP      
;;;2686   
;;;2687           return HAL_TIMEOUT;
00004e  2003              MOVS     r0,#3
                  |L55.80|
;;;2688         }
;;;2689       }
;;;2690     }
;;;2691     return HAL_OK;
;;;2692   }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L55.84|
000054  6820              LDR      r0,[r4,#0]            ;2670
000056  6800              LDR      r0,[r0,#0]            ;2670
000058  4028              ANDS     r0,r0,r5              ;2670
00005a  42a8              CMP      r0,r5                 ;2670
00005c  d101              BNE      |L55.98|
00005e  2001              MOVS     r0,#1                 ;2670
000060  e000              B        |L55.100|
                  |L55.98|
000062  2000              MOVS     r0,#0                 ;2670
                  |L55.100|
000064  42b8              CMP      r0,r7                 ;2670
000066  d0d3              BEQ      |L55.16|
000068  2000              MOVS     r0,#0                 ;2691
00006a  e7f1              B        |L55.80|
;;;2693   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
