; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_rtc_ex.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_rtc_ex.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rtc_ex.c]
                          THUMB

                          AREA ||i.HAL_RTCEx_AlarmBEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_AlarmBEventCallback PROC
;;;1718     */
;;;1719   __weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1720   {
;;;1721     /* Prevent unused argument(s) compilation warning */
;;;1722     UNUSED(hrtc);
;;;1723     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1724               the HAL_RTC_AlarmBEventCallback could be implemented in the user file
;;;1725      */
;;;1726   }
;;;1727   
                          ENDP


                          AREA ||i.HAL_RTCEx_BKUPRead||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_BKUPRead PROC
;;;1145     */
;;;1146   uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
000000  4602              MOV      r2,r0
;;;1147   {
;;;1148     uint32_t tmp = 0U;
000002  2300              MOVS     r3,#0
;;;1149   
;;;1150     /* Check the parameters */
;;;1151     assert_param(IS_RTC_BKP(BackupRegister));
;;;1152   
;;;1153     tmp = (uint32_t)&(hrtc->Instance->BKP0R);
000004  6810              LDR      r0,[r2,#0]
000006  f1000350          ADD      r3,r0,#0x50
;;;1154     tmp += (BackupRegister * 4U);
00000a  eb030381          ADD      r3,r3,r1,LSL #2
;;;1155   
;;;1156     /* Read the specified register */
;;;1157     return (*(__IO uint32_t *)tmp);
00000e  6818              LDR      r0,[r3,#0]
;;;1158   }
000010  4770              BX       lr
;;;1159   
                          ENDP


                          AREA ||i.HAL_RTCEx_BKUPWrite||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_BKUPWrite PROC
;;;1122     */
;;;1123   void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
000000  b510              PUSH     {r4,lr}
;;;1124   {
;;;1125     uint32_t tmp = 0U;
000002  2300              MOVS     r3,#0
;;;1126   
;;;1127     /* Check the parameters */
;;;1128     assert_param(IS_RTC_BKP(BackupRegister));
;;;1129   
;;;1130     tmp = (uint32_t)&(hrtc->Instance->BKP0R);
000004  6804              LDR      r4,[r0,#0]
000006  f1040350          ADD      r3,r4,#0x50
;;;1131     tmp += (BackupRegister * 4U);
00000a  eb030381          ADD      r3,r3,r1,LSL #2
;;;1132   
;;;1133     /* Write the specified register */
;;;1134     *(__IO uint32_t *)tmp = (uint32_t)Data;
00000e  601a              STR      r2,[r3,#0]
;;;1135   }
000010  bd10              POP      {r4,pc}
;;;1136   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateCalibrationOutPut||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateCalibrationOutPut PROC
;;;1503     */
;;;1504   HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
000000  4601              MOV      r1,r0
;;;1505   {
;;;1506     /* Process Locked */
;;;1507     __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f08              LDRB     r0,[r1,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L4.14|
00000a  2002              MOVS     r0,#2
                  |L4.12|
;;;1508   
;;;1509     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1510   
;;;1511     /* Disable the write protection for RTC registers */
;;;1512     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1513   
;;;1514     __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);
;;;1515   
;;;1516     /* Enable the write protection for RTC registers */
;;;1517     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1518   
;;;1519     /* Change RTC state */
;;;1520     hrtc->State = HAL_RTC_STATE_READY;
;;;1521   
;;;1522     /* Process Unlocked */
;;;1523     __HAL_UNLOCK(hrtc);
;;;1524   
;;;1525     return HAL_OK;
;;;1526   }
00000c  4770              BX       lr
                  |L4.14|
00000e  2001              MOVS     r0,#1                 ;1507
000010  7708              STRB     r0,[r1,#0x1c]         ;1507
000012  bf00              NOP                            ;1507
000014  2002              MOVS     r0,#2                 ;1509
000016  7748              STRB     r0,[r1,#0x1d]         ;1509
000018  bf00              NOP                            ;1512
00001a  20ca              MOVS     r0,#0xca              ;1512
00001c  680a              LDR      r2,[r1,#0]            ;1512
00001e  6250              STR      r0,[r2,#0x24]         ;1512
000020  2053              MOVS     r0,#0x53              ;1512
000022  680a              LDR      r2,[r1,#0]            ;1512
000024  6250              STR      r0,[r2,#0x24]         ;1512
000026  bf00              NOP                            ;1512
000028  6808              LDR      r0,[r1,#0]            ;1514
00002a  6880              LDR      r0,[r0,#8]            ;1514
00002c  f4200000          BIC      r0,r0,#0x800000       ;1514
000030  680a              LDR      r2,[r1,#0]            ;1514
000032  6090              STR      r0,[r2,#8]            ;1514
000034  bf00              NOP                            ;1517
000036  20ff              MOVS     r0,#0xff              ;1517
000038  680a              LDR      r2,[r1,#0]            ;1517
00003a  6250              STR      r0,[r2,#0x24]         ;1517
00003c  bf00              NOP                            ;1517
00003e  2001              MOVS     r0,#1                 ;1520
000040  7748              STRB     r0,[r1,#0x1d]         ;1520
000042  bf00              NOP                            ;1523
000044  2000              MOVS     r0,#0                 ;1523
000046  7708              STRB     r0,[r1,#0x1c]         ;1523
000048  bf00              NOP                            ;1523
00004a  bf00              NOP                            ;1525
00004c  e7de              B        |L4.12|
;;;1527   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateCoarseCalib||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateCoarseCalib PROC
;;;1234     */
;;;1235   HAL_StatusTypeDef HAL_RTCEx_DeactivateCoarseCalib(RTC_HandleTypeDef* hrtc)
000000  b510              PUSH     {r4,lr}
;;;1236   {
000002  4604              MOV      r4,r0
;;;1237     /* Process Locked */
;;;1238     __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f20              LDRB     r0,[r4,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;1239   
;;;1240     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1241   
;;;1242     /* Disable the write protection for RTC registers */
;;;1243     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1244   
;;;1245     /* Set Initialization mode */
;;;1246     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1247     {
;;;1248       /* Enable the write protection for RTC registers */
;;;1249       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1250   
;;;1251       /* Set RTC state*/
;;;1252       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1253   
;;;1254       /* Process Unlocked */
;;;1255       __HAL_UNLOCK(hrtc);
;;;1256   
;;;1257       return HAL_ERROR;
;;;1258     }
;;;1259     else
;;;1260     {
;;;1261       /* Enable the Coarse Calibration */
;;;1262       __HAL_RTC_COARSE_CALIB_DISABLE(hrtc);
;;;1263   
;;;1264       /* Exit Initialization mode */
;;;1265       hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
;;;1266     }
;;;1267   
;;;1268     /* Enable the write protection for RTC registers */
;;;1269     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1270   
;;;1271     /* Change state */
;;;1272     hrtc->State = HAL_RTC_STATE_READY;
;;;1273   
;;;1274     /* Process Unlocked */
;;;1275     __HAL_UNLOCK(hrtc);
;;;1276   
;;;1277     return HAL_OK;
;;;1278   }
00000e  bd10              POP      {r4,pc}
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;1238
000012  7720              STRB     r0,[r4,#0x1c]         ;1238
000014  bf00              NOP                            ;1238
000016  2002              MOVS     r0,#2                 ;1240
000018  7760              STRB     r0,[r4,#0x1d]         ;1240
00001a  bf00              NOP                            ;1243
00001c  20ca              MOVS     r0,#0xca              ;1243
00001e  6821              LDR      r1,[r4,#0]            ;1243
000020  6248              STR      r0,[r1,#0x24]         ;1243
000022  2053              MOVS     r0,#0x53              ;1243
000024  6821              LDR      r1,[r4,#0]            ;1243
000026  6248              STR      r0,[r1,#0x24]         ;1243
000028  bf00              NOP                            ;1243
00002a  4620              MOV      r0,r4                 ;1246
00002c  f7fffffe          BL       RTC_EnterInitMode
000030  b160              CBZ      r0,|L5.76|
000032  bf00              NOP                            ;1249
000034  20ff              MOVS     r0,#0xff              ;1249
000036  6821              LDR      r1,[r4,#0]            ;1249
000038  6248              STR      r0,[r1,#0x24]         ;1249
00003a  bf00              NOP                            ;1249
00003c  2004              MOVS     r0,#4                 ;1252
00003e  7760              STRB     r0,[r4,#0x1d]         ;1252
000040  bf00              NOP                            ;1255
000042  2000              MOVS     r0,#0                 ;1255
000044  7720              STRB     r0,[r4,#0x1c]         ;1255
000046  bf00              NOP                            ;1255
000048  2001              MOVS     r0,#1                 ;1257
00004a  e7e0              B        |L5.14|
                  |L5.76|
00004c  6820              LDR      r0,[r4,#0]            ;1262
00004e  6880              LDR      r0,[r0,#8]            ;1262
000050  f0200080          BIC      r0,r0,#0x80           ;1262
000054  6821              LDR      r1,[r4,#0]            ;1262
000056  6088              STR      r0,[r1,#8]            ;1262
000058  6820              LDR      r0,[r4,#0]            ;1265
00005a  68c0              LDR      r0,[r0,#0xc]          ;1265
00005c  f0200080          BIC      r0,r0,#0x80           ;1265
000060  6821              LDR      r1,[r4,#0]            ;1265
000062  60c8              STR      r0,[r1,#0xc]          ;1265
000064  bf00              NOP                            ;1269
000066  20ff              MOVS     r0,#0xff              ;1269
000068  6821              LDR      r1,[r4,#0]            ;1269
00006a  6248              STR      r0,[r1,#0x24]         ;1269
00006c  bf00              NOP                            ;1269
00006e  2001              MOVS     r0,#1                 ;1272
000070  7760              STRB     r0,[r4,#0x1d]         ;1272
000072  bf00              NOP                            ;1275
000074  2000              MOVS     r0,#0                 ;1275
000076  7720              STRB     r0,[r4,#0x1c]         ;1275
000078  bf00              NOP                            ;1275
00007a  bf00              NOP                            ;1277
00007c  e7c7              B        |L5.14|
;;;1279   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateRefClock||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateRefClock PROC
;;;1583     */
;;;1584   HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef* hrtc)
000000  b510              PUSH     {r4,lr}
;;;1585   {
000002  4604              MOV      r4,r0
;;;1586     /* Process Locked */
;;;1587     __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f20              LDRB     r0,[r4,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;1588   
;;;1589     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1590   
;;;1591     /* Disable the write protection for RTC registers */
;;;1592     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1593   
;;;1594     /* Set Initialization mode */
;;;1595     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1596     {
;;;1597       /* Enable the write protection for RTC registers */
;;;1598       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1599   
;;;1600       /* Set RTC state*/
;;;1601       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1602   
;;;1603       /* Process Unlocked */
;;;1604       __HAL_UNLOCK(hrtc);
;;;1605   
;;;1606       return HAL_ERROR;
;;;1607     }
;;;1608     else
;;;1609     {
;;;1610       __HAL_RTC_CLOCKREF_DETECTION_DISABLE(hrtc);
;;;1611   
;;;1612       /* Exit Initialization mode */
;;;1613       hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
;;;1614     }
;;;1615   
;;;1616     /* Enable the write protection for RTC registers */
;;;1617     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1618   
;;;1619     /* Change RTC state */
;;;1620     hrtc->State = HAL_RTC_STATE_READY;
;;;1621   
;;;1622     /* Process Unlocked */
;;;1623     __HAL_UNLOCK(hrtc);
;;;1624   
;;;1625     return HAL_OK;
;;;1626   }
00000e  bd10              POP      {r4,pc}
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;1587
000012  7720              STRB     r0,[r4,#0x1c]         ;1587
000014  bf00              NOP                            ;1587
000016  2002              MOVS     r0,#2                 ;1589
000018  7760              STRB     r0,[r4,#0x1d]         ;1589
00001a  bf00              NOP                            ;1592
00001c  20ca              MOVS     r0,#0xca              ;1592
00001e  6821              LDR      r1,[r4,#0]            ;1592
000020  6248              STR      r0,[r1,#0x24]         ;1592
000022  2053              MOVS     r0,#0x53              ;1592
000024  6821              LDR      r1,[r4,#0]            ;1592
000026  6248              STR      r0,[r1,#0x24]         ;1592
000028  bf00              NOP                            ;1592
00002a  4620              MOV      r0,r4                 ;1595
00002c  f7fffffe          BL       RTC_EnterInitMode
000030  b160              CBZ      r0,|L6.76|
000032  bf00              NOP                            ;1598
000034  20ff              MOVS     r0,#0xff              ;1598
000036  6821              LDR      r1,[r4,#0]            ;1598
000038  6248              STR      r0,[r1,#0x24]         ;1598
00003a  bf00              NOP                            ;1598
00003c  2004              MOVS     r0,#4                 ;1601
00003e  7760              STRB     r0,[r4,#0x1d]         ;1601
000040  bf00              NOP                            ;1604
000042  2000              MOVS     r0,#0                 ;1604
000044  7720              STRB     r0,[r4,#0x1c]         ;1604
000046  bf00              NOP                            ;1604
000048  2001              MOVS     r0,#1                 ;1606
00004a  e7e0              B        |L6.14|
                  |L6.76|
00004c  6820              LDR      r0,[r4,#0]            ;1610
00004e  6880              LDR      r0,[r0,#8]            ;1610
000050  f0200010          BIC      r0,r0,#0x10           ;1610
000054  6821              LDR      r1,[r4,#0]            ;1610
000056  6088              STR      r0,[r1,#8]            ;1610
000058  6820              LDR      r0,[r4,#0]            ;1613
00005a  68c0              LDR      r0,[r0,#0xc]          ;1613
00005c  f0200080          BIC      r0,r0,#0x80           ;1613
000060  6821              LDR      r1,[r4,#0]            ;1613
000062  60c8              STR      r0,[r1,#0xc]          ;1613
000064  bf00              NOP                            ;1617
000066  20ff              MOVS     r0,#0xff              ;1617
000068  6821              LDR      r1,[r4,#0]            ;1617
00006a  6248              STR      r0,[r1,#0x24]         ;1617
00006c  bf00              NOP                            ;1617
00006e  2001              MOVS     r0,#1                 ;1620
000070  7760              STRB     r0,[r4,#0x1d]         ;1620
000072  bf00              NOP                            ;1623
000074  2000              MOVS     r0,#0                 ;1623
000076  7720              STRB     r0,[r4,#0x1c]         ;1623
000078  bf00              NOP                            ;1623
00007a  bf00              NOP                            ;1625
00007c  e7c7              B        |L6.14|
;;;1627   
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateTamper||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateTamper PROC
;;;473      */
;;;474    HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
000000  4602              MOV      r2,r0
;;;475    {
;;;476      assert_param(IS_RTC_TAMPER(Tamper));
;;;477    
;;;478      /* Process Locked */
;;;479      __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f10              LDRB     r0,[r2,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L7.14|
00000a  2002              MOVS     r0,#2
                  |L7.12|
;;;480    
;;;481      hrtc->State = HAL_RTC_STATE_BUSY;
;;;482    
;;;483      /* Disable the selected Tamper pin */
;;;484      hrtc->Instance->TAFCR &= (uint32_t)~Tamper;
;;;485    
;;;486      hrtc->State = HAL_RTC_STATE_READY;
;;;487    
;;;488      /* Process Unlocked */
;;;489      __HAL_UNLOCK(hrtc);
;;;490    
;;;491      return HAL_OK;
;;;492    }
00000c  4770              BX       lr
                  |L7.14|
00000e  2001              MOVS     r0,#1                 ;479
000010  7710              STRB     r0,[r2,#0x1c]         ;479
000012  bf00              NOP                            ;479
000014  2002              MOVS     r0,#2                 ;481
000016  7750              STRB     r0,[r2,#0x1d]         ;481
000018  6810              LDR      r0,[r2,#0]            ;484
00001a  6c00              LDR      r0,[r0,#0x40]         ;484
00001c  4388              BICS     r0,r0,r1              ;484
00001e  6813              LDR      r3,[r2,#0]            ;484
000020  6418              STR      r0,[r3,#0x40]         ;484
000022  2001              MOVS     r0,#1                 ;486
000024  7750              STRB     r0,[r2,#0x1d]         ;486
000026  bf00              NOP                            ;489
000028  2000              MOVS     r0,#0                 ;489
00002a  7710              STRB     r0,[r2,#0x1c]         ;489
00002c  bf00              NOP                            ;489
00002e  bf00              NOP                            ;491
000030  e7ec              B        |L7.12|
;;;493    
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateTimeStamp||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateTimeStamp PROC
;;;257      */
;;;258    HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
000000  4601              MOV      r1,r0
;;;259    {
;;;260      uint32_t tmpreg = 0U;
000002  2200              MOVS     r2,#0
;;;261    
;;;262      /* Process Locked */
;;;263      __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f08              LDRB     r0,[r1,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L8.16|
00000c  2002              MOVS     r0,#2
                  |L8.14|
;;;264    
;;;265      hrtc->State = HAL_RTC_STATE_BUSY;
;;;266    
;;;267      /* Disable the write protection for RTC registers */
;;;268      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;269    
;;;270      /* In case of interrupt mode is used, the interrupt source must disabled */
;;;271      __HAL_RTC_TIMESTAMP_DISABLE_IT(hrtc, RTC_IT_TS);
;;;272    
;;;273      /* Get the RTC_CR register and clear the bits to be configured */
;;;274      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
;;;275    
;;;276      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;277      hrtc->Instance->CR = (uint32_t)tmpreg;
;;;278    
;;;279      /* Enable the write protection for RTC registers */
;;;280      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;281    
;;;282      hrtc->State = HAL_RTC_STATE_READY;
;;;283    
;;;284      /* Process Unlocked */
;;;285      __HAL_UNLOCK(hrtc);
;;;286    
;;;287      return HAL_OK;
;;;288    }
00000e  4770              BX       lr
                  |L8.16|
000010  2001              MOVS     r0,#1                 ;263
000012  7708              STRB     r0,[r1,#0x1c]         ;263
000014  bf00              NOP                            ;263
000016  2002              MOVS     r0,#2                 ;265
000018  7748              STRB     r0,[r1,#0x1d]         ;265
00001a  bf00              NOP                            ;268
00001c  20ca              MOVS     r0,#0xca              ;268
00001e  680b              LDR      r3,[r1,#0]            ;268
000020  6258              STR      r0,[r3,#0x24]         ;268
000022  2053              MOVS     r0,#0x53              ;268
000024  680b              LDR      r3,[r1,#0]            ;268
000026  6258              STR      r0,[r3,#0x24]         ;268
000028  bf00              NOP                            ;268
00002a  6808              LDR      r0,[r1,#0]            ;271
00002c  6880              LDR      r0,[r0,#8]            ;271
00002e  f4204000          BIC      r0,r0,#0x8000         ;271
000032  680b              LDR      r3,[r1,#0]            ;271
000034  6098              STR      r0,[r3,#8]            ;271
000036  6808              LDR      r0,[r1,#0]            ;274
000038  6880              LDR      r0,[r0,#8]            ;274
00003a  f6400308          MOV      r3,#0x808             ;274
00003e  ea200203          BIC      r2,r0,r3              ;274
000042  6808              LDR      r0,[r1,#0]            ;277
000044  6082              STR      r2,[r0,#8]            ;277
000046  bf00              NOP                            ;280
000048  20ff              MOVS     r0,#0xff              ;280
00004a  680b              LDR      r3,[r1,#0]            ;280
00004c  6258              STR      r0,[r3,#0x24]         ;280
00004e  bf00              NOP                            ;280
000050  2001              MOVS     r0,#1                 ;282
000052  7748              STRB     r0,[r1,#0x1d]         ;282
000054  bf00              NOP                            ;285
000056  2000              MOVS     r0,#0                 ;285
000058  7708              STRB     r0,[r1,#0x1c]         ;285
00005a  bf00              NOP                            ;285
00005c  bf00              NOP                            ;287
00005e  e7d6              B        |L8.14|
;;;289    
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateWakeUpTimer PROC
;;;937      */
;;;938    uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;939    {
000002  4604              MOV      r4,r0
;;;940      uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;941    
;;;942      /* Process Locked */
;;;943      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f20              LDRB     r0,[r4,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L9.18|
00000e  2002              MOVS     r0,#2
                  |L9.16|
;;;944    
;;;945      hrtc->State = HAL_RTC_STATE_BUSY;
;;;946    
;;;947      /* Disable the write protection for RTC registers */
;;;948      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;949    
;;;950      /* Disable the Wake-up Timer */
;;;951      __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
;;;952    
;;;953      /* In case of interrupt mode is used, the interrupt source must disabled */
;;;954      __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc,RTC_IT_WUT);
;;;955    
;;;956      /* Get tick */
;;;957      tickstart = HAL_GetTick();
;;;958    
;;;959      /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;960      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
;;;961      {
;;;962        if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;963        {
;;;964          /* Enable the write protection for RTC registers */
;;;965          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;966    
;;;967          hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;968    
;;;969          /* Process Unlocked */
;;;970          __HAL_UNLOCK(hrtc);
;;;971    
;;;972          return HAL_TIMEOUT;
;;;973        }
;;;974      }
;;;975    
;;;976      /* Enable the write protection for RTC registers */
;;;977      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;978    
;;;979      hrtc->State = HAL_RTC_STATE_READY;
;;;980    
;;;981      /* Process Unlocked */
;;;982      __HAL_UNLOCK(hrtc);
;;;983    
;;;984      return HAL_OK;
;;;985    }
000010  bd70              POP      {r4-r6,pc}
                  |L9.18|
000012  2001              MOVS     r0,#1                 ;943
000014  7720              STRB     r0,[r4,#0x1c]         ;943
000016  bf00              NOP                            ;943
000018  2002              MOVS     r0,#2                 ;945
00001a  7760              STRB     r0,[r4,#0x1d]         ;945
00001c  bf00              NOP                            ;948
00001e  20ca              MOVS     r0,#0xca              ;948
000020  6821              LDR      r1,[r4,#0]            ;948
000022  6248              STR      r0,[r1,#0x24]         ;948
000024  2053              MOVS     r0,#0x53              ;948
000026  6821              LDR      r1,[r4,#0]            ;948
000028  6248              STR      r0,[r1,#0x24]         ;948
00002a  bf00              NOP                            ;948
00002c  6820              LDR      r0,[r4,#0]            ;951
00002e  6880              LDR      r0,[r0,#8]            ;951
000030  f4206080          BIC      r0,r0,#0x400          ;951
000034  6821              LDR      r1,[r4,#0]            ;951
000036  6088              STR      r0,[r1,#8]            ;951
000038  6820              LDR      r0,[r4,#0]            ;954
00003a  6880              LDR      r0,[r0,#8]            ;954
00003c  f4204080          BIC      r0,r0,#0x4000         ;954
000040  6821              LDR      r1,[r4,#0]            ;954
000042  6088              STR      r0,[r1,#8]            ;954
000044  f7fffffe          BL       HAL_GetTick
000048  4605              MOV      r5,r0                 ;957
00004a  e012              B        |L9.114|
                  |L9.76|
00004c  f7fffffe          BL       HAL_GetTick
000050  1b40              SUBS     r0,r0,r5              ;962
000052  f5b07f7a          CMP      r0,#0x3e8             ;962
000056  d90c              BLS      |L9.114|
000058  bf00              NOP                            ;965
00005a  20ff              MOVS     r0,#0xff              ;965
00005c  6821              LDR      r1,[r4,#0]            ;965
00005e  6248              STR      r0,[r1,#0x24]         ;965
000060  bf00              NOP                            ;965
000062  2003              MOVS     r0,#3                 ;967
000064  7760              STRB     r0,[r4,#0x1d]         ;967
000066  bf00              NOP                            ;970
000068  2000              MOVS     r0,#0                 ;970
00006a  7720              STRB     r0,[r4,#0x1c]         ;970
00006c  bf00              NOP                            ;970
00006e  2003              MOVS     r0,#3                 ;972
000070  e7ce              B        |L9.16|
                  |L9.114|
000072  6820              LDR      r0,[r4,#0]            ;960
000074  68c0              LDR      r0,[r0,#0xc]          ;960
000076  f3c00080          UBFX     r0,r0,#2,#1           ;960
00007a  2800              CMP      r0,#0                 ;960
00007c  d0e6              BEQ      |L9.76|
00007e  bf00              NOP                            ;977
000080  20ff              MOVS     r0,#0xff              ;977
000082  6821              LDR      r1,[r4,#0]            ;977
000084  6248              STR      r0,[r1,#0x24]         ;977
000086  bf00              NOP                            ;977
000088  2001              MOVS     r0,#1                 ;979
00008a  7760              STRB     r0,[r4,#0x1d]         ;979
00008c  bf00              NOP                            ;982
00008e  2000              MOVS     r0,#0                 ;982
000090  7720              STRB     r0,[r4,#0x1c]         ;982
000092  bf00              NOP                            ;982
000094  bf00              NOP                            ;984
000096  e7bb              B        |L9.16|
;;;986    
                          ENDP


                          AREA ||i.HAL_RTCEx_DisableBypassShadow||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DisableBypassShadow PROC
;;;1668     */
;;;1669   HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
000000  4601              MOV      r1,r0
;;;1670   {
;;;1671     /* Process Locked */
;;;1672     __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f08              LDRB     r0,[r1,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L10.14|
00000a  2002              MOVS     r0,#2
                  |L10.12|
;;;1673   
;;;1674     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1675   
;;;1676     /* Disable the write protection for RTC registers */
;;;1677     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1678   
;;;1679     /* Reset the BYPSHAD bit */
;;;1680     hrtc->Instance->CR &= (uint8_t)~RTC_CR_BYPSHAD;
;;;1681   
;;;1682     /* Enable the write protection for RTC registers */
;;;1683     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1684   
;;;1685     /* Change RTC state */
;;;1686     hrtc->State = HAL_RTC_STATE_READY;
;;;1687   
;;;1688     /* Process Unlocked */
;;;1689     __HAL_UNLOCK(hrtc);
;;;1690   
;;;1691     return HAL_OK;
;;;1692   }
00000c  4770              BX       lr
                  |L10.14|
00000e  2001              MOVS     r0,#1                 ;1672
000010  7708              STRB     r0,[r1,#0x1c]         ;1672
000012  bf00              NOP                            ;1672
000014  2002              MOVS     r0,#2                 ;1674
000016  7748              STRB     r0,[r1,#0x1d]         ;1674
000018  bf00              NOP                            ;1677
00001a  20ca              MOVS     r0,#0xca              ;1677
00001c  680a              LDR      r2,[r1,#0]            ;1677
00001e  6250              STR      r0,[r2,#0x24]         ;1677
000020  2053              MOVS     r0,#0x53              ;1677
000022  680a              LDR      r2,[r1,#0]            ;1677
000024  6250              STR      r0,[r2,#0x24]         ;1677
000026  bf00              NOP                            ;1677
000028  6808              LDR      r0,[r1,#0]            ;1680
00002a  6880              LDR      r0,[r0,#8]            ;1680
00002c  f00000df          AND      r0,r0,#0xdf           ;1680
000030  680a              LDR      r2,[r1,#0]            ;1680
000032  6090              STR      r0,[r2,#8]            ;1680
000034  bf00              NOP                            ;1683
000036  20ff              MOVS     r0,#0xff              ;1683
000038  680a              LDR      r2,[r1,#0]            ;1683
00003a  6250              STR      r0,[r2,#0x24]         ;1683
00003c  bf00              NOP                            ;1683
00003e  2001              MOVS     r0,#1                 ;1686
000040  7748              STRB     r0,[r1,#0x1d]         ;1686
000042  bf00              NOP                            ;1689
000044  2000              MOVS     r0,#0                 ;1689
000046  7708              STRB     r0,[r1,#0x1c]         ;1689
000048  bf00              NOP                            ;1689
00004a  bf00              NOP                            ;1691
00004c  e7de              B        |L10.12|
;;;1693   
                          ENDP


                          AREA ||i.HAL_RTCEx_EnableBypassShadow||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_EnableBypassShadow PROC
;;;1635     */
;;;1636   HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
000000  4601              MOV      r1,r0
;;;1637   {
;;;1638     /* Process Locked */
;;;1639     __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f08              LDRB     r0,[r1,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L11.14|
00000a  2002              MOVS     r0,#2
                  |L11.12|
;;;1640   
;;;1641     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1642   
;;;1643     /* Disable the write protection for RTC registers */
;;;1644     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1645   
;;;1646     /* Set the BYPSHAD bit */
;;;1647     hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;
;;;1648   
;;;1649     /* Enable the write protection for RTC registers */
;;;1650     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1651   
;;;1652     /* Change RTC state */
;;;1653     hrtc->State = HAL_RTC_STATE_READY;
;;;1654   
;;;1655     /* Process Unlocked */
;;;1656     __HAL_UNLOCK(hrtc);
;;;1657   
;;;1658     return HAL_OK;
;;;1659   }
00000c  4770              BX       lr
                  |L11.14|
00000e  2001              MOVS     r0,#1                 ;1639
000010  7708              STRB     r0,[r1,#0x1c]         ;1639
000012  bf00              NOP                            ;1639
000014  2002              MOVS     r0,#2                 ;1641
000016  7748              STRB     r0,[r1,#0x1d]         ;1641
000018  bf00              NOP                            ;1644
00001a  20ca              MOVS     r0,#0xca              ;1644
00001c  680a              LDR      r2,[r1,#0]            ;1644
00001e  6250              STR      r0,[r2,#0x24]         ;1644
000020  2053              MOVS     r0,#0x53              ;1644
000022  680a              LDR      r2,[r1,#0]            ;1644
000024  6250              STR      r0,[r2,#0x24]         ;1644
000026  bf00              NOP                            ;1644
000028  6808              LDR      r0,[r1,#0]            ;1647
00002a  6880              LDR      r0,[r0,#8]            ;1647
00002c  f0400020          ORR      r0,r0,#0x20           ;1647
000030  680a              LDR      r2,[r1,#0]            ;1647
000032  6090              STR      r0,[r2,#8]            ;1647
000034  bf00              NOP                            ;1650
000036  20ff              MOVS     r0,#0xff              ;1650
000038  680a              LDR      r2,[r1,#0]            ;1650
00003a  6250              STR      r0,[r2,#0x24]         ;1650
00003c  bf00              NOP                            ;1650
00003e  2001              MOVS     r0,#1                 ;1653
000040  7748              STRB     r0,[r1,#0x1d]         ;1653
000042  bf00              NOP                            ;1656
000044  2000              MOVS     r0,#0                 ;1656
000046  7708              STRB     r0,[r1,#0x1c]         ;1656
000048  bf00              NOP                            ;1656
00004a  bf00              NOP                            ;1658
00004c  e7de              B        |L11.12|
;;;1660   
                          ENDP


                          AREA ||i.HAL_RTCEx_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_GetTimeStamp PROC
;;;301      */
;;;302    HAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef* sTimeStamp, RTC_DateTypeDef* sTimeStampDate, uint32_t Format)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;303    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
;;;304      uint32_t tmptime = 0U, tmpdate = 0U;
00000c  2700              MOVS     r7,#0
00000e  46b8              MOV      r8,r7
;;;305    
;;;306      /* Check the parameters */
;;;307      assert_param(IS_RTC_FORMAT(Format));
;;;308    
;;;309      /* Get the TimeStamp time and date registers values */
;;;310      tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
000010  6830              LDR      r0,[r6,#0]
000012  6b00              LDR      r0,[r0,#0x30]
000014  4924              LDR      r1,|L12.168|
000016  ea000701          AND      r7,r0,r1
;;;311      tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);
00001a  6830              LDR      r0,[r6,#0]
00001c  6b40              LDR      r0,[r0,#0x34]
00001e  4923              LDR      r1,|L12.172|
000020  ea000801          AND      r8,r0,r1
;;;312    
;;;313      /* Fill the Time structure fields with the read parameters */
;;;314      sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
000024  f3c74005          UBFX     r0,r7,#16,#6
000028  7020              STRB     r0,[r4,#0]
;;;315      sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
00002a  f3c72006          UBFX     r0,r7,#8,#7
00002e  7060              STRB     r0,[r4,#1]
;;;316      sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000030  f007007f          AND      r0,r7,#0x7f
000034  70a0              STRB     r0,[r4,#2]
;;;317      sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16U);
000036  f4070080          AND      r0,r7,#0x400000
00003a  0c00              LSRS     r0,r0,#16
00003c  70e0              STRB     r0,[r4,#3]
;;;318      sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;
00003e  6830              LDR      r0,[r6,#0]
000040  6b80              LDR      r0,[r0,#0x38]
000042  6060              STR      r0,[r4,#4]
;;;319    
;;;320      /* Fill the Date structure fields with the read parameters */
;;;321      sTimeStampDate->Year = 0U;
000044  2000              MOVS     r0,#0
000046  70e8              STRB     r0,[r5,#3]
;;;322      sTimeStampDate->Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
000048  f3c82004          UBFX     r0,r8,#8,#5
00004c  7068              STRB     r0,[r5,#1]
;;;323      sTimeStampDate->Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
00004e  f008003f          AND      r0,r8,#0x3f
000052  70a8              STRB     r0,[r5,#2]
;;;324      sTimeStampDate->WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13U);
000054  f3c83042          UBFX     r0,r8,#13,#3
000058  7028              STRB     r0,[r5,#0]
;;;325    
;;;326      /* Check the input parameters format */
;;;327      if(Format == RTC_FORMAT_BIN)
00005a  f1b90f00          CMP      r9,#0
00005e  d117              BNE      |L12.144|
;;;328      {
;;;329        /* Convert the TimeStamp structure parameters to Binary format */
;;;330        sTimeStamp->Hours = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Hours);
000060  7820              LDRB     r0,[r4,#0]
000062  f7fffffe          BL       RTC_Bcd2ToByte
000066  7020              STRB     r0,[r4,#0]
;;;331        sTimeStamp->Minutes = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Minutes);
000068  7860              LDRB     r0,[r4,#1]
00006a  f7fffffe          BL       RTC_Bcd2ToByte
00006e  7060              STRB     r0,[r4,#1]
;;;332        sTimeStamp->Seconds = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Seconds);
000070  78a0              LDRB     r0,[r4,#2]
000072  f7fffffe          BL       RTC_Bcd2ToByte
000076  70a0              STRB     r0,[r4,#2]
;;;333    
;;;334        /* Convert the DateTimeStamp structure parameters to Binary format */
;;;335        sTimeStampDate->Month = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Month);
000078  7868              LDRB     r0,[r5,#1]
00007a  f7fffffe          BL       RTC_Bcd2ToByte
00007e  7068              STRB     r0,[r5,#1]
;;;336        sTimeStampDate->Date = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Date);
000080  78a8              LDRB     r0,[r5,#2]
000082  f7fffffe          BL       RTC_Bcd2ToByte
000086  70a8              STRB     r0,[r5,#2]
;;;337        sTimeStampDate->WeekDay = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->WeekDay);
000088  7828              LDRB     r0,[r5,#0]
00008a  f7fffffe          BL       RTC_Bcd2ToByte
00008e  7028              STRB     r0,[r5,#0]
                  |L12.144|
;;;338      }
;;;339    
;;;340      /* Clear the TIMESTAMP Flag */
;;;341      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
000090  6830              LDR      r0,[r6,#0]
000092  68c0              LDR      r0,[r0,#0xc]
000094  f0000080          AND      r0,r0,#0x80
000098  f4606008          ORN      r0,r0,#0x880
00009c  6831              LDR      r1,[r6,#0]
00009e  60c8              STR      r0,[r1,#0xc]
;;;342    
;;;343      return HAL_OK;
0000a0  2000              MOVS     r0,#0
;;;344    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;345    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L12.168|
                          DCD      0x007f7f7f
                  |L12.172|
                          DCD      0x00ffff3f

                          AREA ||i.HAL_RTCEx_GetWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_GetWakeUpTimer PROC
;;;992      */
;;;993    uint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc)
000000  4601              MOV      r1,r0
;;;994    {
;;;995      /* Get the counter value */
;;;996      return ((uint32_t)(hrtc->Instance->WUTR & RTC_WUTR_WUT));
000002  6808              LDR      r0,[r1,#0]
000004  6940              LDR      r0,[r0,#0x14]
000006  b280              UXTH     r0,r0
;;;997    }
000008  4770              BX       lr
;;;998    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForAlarmBEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForAlarmBEvent PROC
;;;1734     */
;;;1735   HAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1736   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1737     uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;1738   
;;;1739     /* Get tick */
;;;1740     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;1741   
;;;1742     while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == RESET)
00000e  e00a              B        |L14.38|
                  |L14.16|
;;;1743     {
;;;1744       if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L14.38|
;;;1745       {
;;;1746         if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L14.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L14.38|
                  |L14.32|
;;;1747         {
;;;1748           hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L14.36|
;;;1749           return HAL_TIMEOUT;
;;;1750         }
;;;1751       }
;;;1752     }
;;;1753   
;;;1754     /* Clear the Alarm Flag */
;;;1755     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
;;;1756   
;;;1757     /* Change RTC state */
;;;1758     hrtc->State = HAL_RTC_STATE_READY;
;;;1759   
;;;1760     return HAL_OK;
;;;1761   }
000024  bd70              POP      {r4-r6,pc}
                  |L14.38|
000026  6820              LDR      r0,[r4,#0]            ;1742
000028  68c0              LDR      r0,[r0,#0xc]          ;1742
00002a  f3c02040          UBFX     r0,r0,#9,#1           ;1742
00002e  2800              CMP      r0,#0                 ;1742
000030  d0ee              BEQ      |L14.16|
000032  6820              LDR      r0,[r4,#0]            ;1755
000034  68c0              LDR      r0,[r0,#0xc]          ;1755
000036  f0000080          AND      r0,r0,#0x80           ;1755
00003a  f4607020          ORN      r0,r0,#0x280          ;1755
00003e  6821              LDR      r1,[r4,#0]            ;1755
000040  60c8              STR      r0,[r1,#0xc]          ;1755
000042  2001              MOVS     r0,#1                 ;1758
000044  7760              STRB     r0,[r4,#0x1d]         ;1758
000046  2000              MOVS     r0,#0                 ;1760
000048  e7ec              B        |L14.36|
;;;1762   
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTamper1Event||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTamper1Event PROC
;;;655      */
;;;656    HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;657    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;658      uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;659    
;;;660      /* Get tick */
;;;661      tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;662    
;;;663      /* Get the status of the Interrupt */
;;;664      while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F)== RESET)
00000e  e00a              B        |L15.38|
                  |L15.16|
;;;665      {
;;;666        if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L15.38|
;;;667        {
;;;668          if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L15.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L15.38|
                  |L15.32|
;;;669          {
;;;670            hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L15.36|
;;;671            return HAL_TIMEOUT;
;;;672          }
;;;673        }
;;;674      }
;;;675    
;;;676      /* Clear the Tamper Flag */
;;;677      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
;;;678    
;;;679      /* Change RTC state */
;;;680      hrtc->State = HAL_RTC_STATE_READY;
;;;681    
;;;682      return HAL_OK;
;;;683    }
000024  bd70              POP      {r4-r6,pc}
                  |L15.38|
000026  6820              LDR      r0,[r4,#0]            ;664
000028  68c0              LDR      r0,[r0,#0xc]          ;664
00002a  f3c03040          UBFX     r0,r0,#13,#1          ;664
00002e  2800              CMP      r0,#0                 ;664
000030  d0ee              BEQ      |L15.16|
000032  6820              LDR      r0,[r4,#0]            ;677
000034  68c0              LDR      r0,[r0,#0xc]          ;677
000036  f0000080          AND      r0,r0,#0x80           ;677
00003a  f4605002          ORN      r0,r0,#0x2080         ;677
00003e  6821              LDR      r1,[r4,#0]            ;677
000040  60c8              STR      r0,[r1,#0xc]          ;677
000042  2001              MOVS     r0,#1                 ;680
000044  7760              STRB     r0,[r4,#0x1d]         ;680
000046  2000              MOVS     r0,#0                 ;682
000048  e7ec              B        |L15.36|
;;;684    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTamper2Event||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTamper2Event PROC
;;;691      */
;;;692    HAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;693    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;694      uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;695    
;;;696      /* Get tick */
;;;697      tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;698    
;;;699      /* Get the status of the Interrupt */
;;;700      while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == RESET)
00000e  e00a              B        |L16.38|
                  |L16.16|
;;;701      {
;;;702        if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L16.38|
;;;703        {
;;;704          if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L16.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L16.38|
                  |L16.32|
;;;705          {
;;;706            hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L16.36|
;;;707            return HAL_TIMEOUT;
;;;708          }
;;;709        }
;;;710      }
;;;711    
;;;712      /* Clear the Tamper Flag */
;;;713      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP2F);
;;;714    
;;;715      /* Change RTC state */
;;;716      hrtc->State = HAL_RTC_STATE_READY;
;;;717    
;;;718      return HAL_OK;
;;;719    }
000024  bd70              POP      {r4-r6,pc}
                  |L16.38|
000026  6820              LDR      r0,[r4,#0]            ;700
000028  68c0              LDR      r0,[r0,#0xc]          ;700
00002a  f3c03080          UBFX     r0,r0,#14,#1          ;700
00002e  2800              CMP      r0,#0                 ;700
000030  d0ee              BEQ      |L16.16|
000032  6820              LDR      r0,[r4,#0]            ;713
000034  68c0              LDR      r0,[r0,#0xc]          ;713
000036  f0000080          AND      r0,r0,#0x80           ;713
00003a  f4604081          ORN      r0,r0,#0x4080         ;713
00003e  6821              LDR      r1,[r4,#0]            ;713
000040  60c8              STR      r0,[r1,#0xc]          ;713
000042  2001              MOVS     r0,#1                 ;716
000044  7760              STRB     r0,[r4,#0x1d]         ;716
000046  2000              MOVS     r0,#0                 ;718
000048  e7ec              B        |L16.36|
;;;720    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForTimeStampEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForTimeStampEvent PROC
;;;612      */
;;;613    HAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;614    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;615      uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;616    
;;;617      /* Get tick */
;;;618      tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;619    
;;;620      while(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == RESET)
00000e  e01b              B        |L17.72|
                  |L17.16|
;;;621      {
;;;622        if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != RESET)
000010  6820              LDR      r0,[r4,#0]
000012  68c0              LDR      r0,[r0,#0xc]
000014  f3c03000          UBFX     r0,r0,#12,#1
000018  b158              CBZ      r0,|L17.50|
;;;623        {
;;;624          /* Clear the TIMESTAMP Overrun Flag */
;;;625          __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
00001a  6820              LDR      r0,[r4,#0]
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  f0000080          AND      r0,r0,#0x80
000022  f4605084          ORN      r0,r0,#0x1080
000026  6821              LDR      r1,[r4,#0]
000028  60c8              STR      r0,[r1,#0xc]
;;;626    
;;;627          /* Change TIMESTAMP state */
;;;628          hrtc->State = HAL_RTC_STATE_ERROR;
00002a  2004              MOVS     r0,#4
00002c  7760              STRB     r0,[r4,#0x1d]
;;;629    
;;;630          return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L17.48|
;;;631        }
;;;632    
;;;633        if(Timeout != HAL_MAX_DELAY)
;;;634        {
;;;635          if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
;;;636          {
;;;637            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;638            return HAL_TIMEOUT;
;;;639          }
;;;640        }
;;;641      }
;;;642    
;;;643      /* Change RTC state */
;;;644      hrtc->State = HAL_RTC_STATE_READY;
;;;645    
;;;646      return HAL_OK;
;;;647    }
000030  bd70              POP      {r4-r6,pc}
                  |L17.50|
000032  1c68              ADDS     r0,r5,#1              ;633
000034  b140              CBZ      r0,|L17.72|
000036  b125              CBZ      r5,|L17.66|
000038  f7fffffe          BL       HAL_GetTick
00003c  1b80              SUBS     r0,r0,r6              ;635
00003e  42a8              CMP      r0,r5                 ;635
000040  d902              BLS      |L17.72|
                  |L17.66|
000042  2003              MOVS     r0,#3                 ;637
000044  7760              STRB     r0,[r4,#0x1d]         ;637
000046  e7f3              B        |L17.48|
                  |L17.72|
000048  6820              LDR      r0,[r4,#0]            ;620
00004a  68c0              LDR      r0,[r0,#0xc]          ;620
00004c  f3c020c0          UBFX     r0,r0,#11,#1          ;620
000050  2800              CMP      r0,#0                 ;620
000052  d0dd              BEQ      |L17.16|
000054  2001              MOVS     r0,#1                 ;644
000056  7760              STRB     r0,[r4,#0x1d]         ;644
000058  2000              MOVS     r0,#0                 ;646
00005a  e7e9              B        |L17.48|
;;;648    
                          ENDP


                          AREA ||i.HAL_RTCEx_PollForWakeUpTimerEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_PollForWakeUpTimerEvent PROC
;;;1052     */
;;;1053   HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1054   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1055     uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;1056   
;;;1057     /* Get tick */
;;;1058     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;1059   
;;;1060     while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == RESET)
00000e  e00a              B        |L18.38|
                  |L18.16|
;;;1061     {
;;;1062       if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L18.38|
;;;1063       {
;;;1064         if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L18.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L18.38|
                  |L18.32|
;;;1065         {
;;;1066           hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L18.36|
;;;1067   
;;;1068           return HAL_TIMEOUT;
;;;1069         }
;;;1070       }
;;;1071     }
;;;1072   
;;;1073     /* Clear the WAKEUPTIMER Flag */
;;;1074     __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
;;;1075   
;;;1076     /* Change RTC state */
;;;1077     hrtc->State = HAL_RTC_STATE_READY;
;;;1078   
;;;1079     return HAL_OK;
;;;1080   }
000024  bd70              POP      {r4-r6,pc}
                  |L18.38|
000026  6820              LDR      r0,[r4,#0]            ;1060
000028  68c0              LDR      r0,[r0,#0xc]          ;1060
00002a  f3c02080          UBFX     r0,r0,#10,#1          ;1060
00002e  2800              CMP      r0,#0                 ;1060
000030  d0ee              BEQ      |L18.16|
000032  6820              LDR      r0,[r4,#0]            ;1074
000034  68c0              LDR      r0,[r0,#0xc]          ;1074
000036  f0000080          AND      r0,r0,#0x80           ;1074
00003a  f4606090          ORN      r0,r0,#0x480          ;1074
00003e  6821              LDR      r1,[r4,#0]            ;1074
000040  60c8              STR      r0,[r1,#0xc]          ;1074
000042  2001              MOVS     r0,#1                 ;1077
000044  7760              STRB     r0,[r4,#0x1d]         ;1077
000046  2000              MOVS     r0,#0                 ;1079
000048  e7ec              B        |L18.36|
;;;1081   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetCalibrationOutPut||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetCalibrationOutPut PROC
;;;1464     */
;;;1465   HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef* hrtc, uint32_t CalibOutput)
000000  4602              MOV      r2,r0
;;;1466   {
;;;1467     /* Check the parameters */
;;;1468     assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));
;;;1469   
;;;1470     /* Process Locked */
;;;1471     __HAL_LOCK(hrtc);
000002  bf00              NOP      
000004  7f10              LDRB     r0,[r2,#0x1c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L19.14|
00000a  2002              MOVS     r0,#2
                  |L19.12|
;;;1472   
;;;1473     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1474   
;;;1475     /* Disable the write protection for RTC registers */
;;;1476     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1477   
;;;1478     /* Clear flags before config */
;;;1479     hrtc->Instance->CR &= (uint32_t)~RTC_CR_COSEL;
;;;1480   
;;;1481     /* Configure the RTC_CR register */
;;;1482     hrtc->Instance->CR |= (uint32_t)CalibOutput;
;;;1483   
;;;1484     __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);
;;;1485   
;;;1486     /* Enable the write protection for RTC registers */
;;;1487     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1488   
;;;1489     /* Change RTC state */
;;;1490     hrtc->State = HAL_RTC_STATE_READY;
;;;1491   
;;;1492     /* Process Unlocked */
;;;1493     __HAL_UNLOCK(hrtc);
;;;1494   
;;;1495     return HAL_OK;
;;;1496   }
00000c  4770              BX       lr
                  |L19.14|
00000e  2001              MOVS     r0,#1                 ;1471
000010  7710              STRB     r0,[r2,#0x1c]         ;1471
000012  bf00              NOP                            ;1471
000014  2002              MOVS     r0,#2                 ;1473
000016  7750              STRB     r0,[r2,#0x1d]         ;1473
000018  bf00              NOP                            ;1476
00001a  20ca              MOVS     r0,#0xca              ;1476
00001c  6813              LDR      r3,[r2,#0]            ;1476
00001e  6258              STR      r0,[r3,#0x24]         ;1476
000020  2053              MOVS     r0,#0x53              ;1476
000022  6813              LDR      r3,[r2,#0]            ;1476
000024  6258              STR      r0,[r3,#0x24]         ;1476
000026  bf00              NOP                            ;1476
000028  6810              LDR      r0,[r2,#0]            ;1479
00002a  6880              LDR      r0,[r0,#8]            ;1479
00002c  f4202000          BIC      r0,r0,#0x80000        ;1479
000030  6813              LDR      r3,[r2,#0]            ;1479
000032  6098              STR      r0,[r3,#8]            ;1479
000034  6810              LDR      r0,[r2,#0]            ;1482
000036  6880              LDR      r0,[r0,#8]            ;1482
000038  4308              ORRS     r0,r0,r1              ;1482
00003a  6813              LDR      r3,[r2,#0]            ;1482
00003c  6098              STR      r0,[r3,#8]            ;1482
00003e  6810              LDR      r0,[r2,#0]            ;1484
000040  6880              LDR      r0,[r0,#8]            ;1484
000042  f4400000          ORR      r0,r0,#0x800000       ;1484
000046  6813              LDR      r3,[r2,#0]            ;1484
000048  6098              STR      r0,[r3,#8]            ;1484
00004a  bf00              NOP                            ;1487
00004c  20ff              MOVS     r0,#0xff              ;1487
00004e  6813              LDR      r3,[r2,#0]            ;1487
000050  6258              STR      r0,[r3,#0x24]         ;1487
000052  bf00              NOP                            ;1487
000054  2001              MOVS     r0,#1                 ;1490
000056  7750              STRB     r0,[r2,#0x1d]         ;1490
000058  bf00              NOP                            ;1493
00005a  2000              MOVS     r0,#0                 ;1493
00005c  7710              STRB     r0,[r2,#0x1c]         ;1493
00005e  bf00              NOP                            ;1493
000060  bf00              NOP                            ;1495
000062  e7d3              B        |L19.12|
;;;1497   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetCoarseCalib||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetCoarseCalib PROC
;;;1176     */
;;;1177   HAL_StatusTypeDef HAL_RTCEx_SetCoarseCalib(RTC_HandleTypeDef* hrtc, uint32_t CalibSign, uint32_t Value)
000000  b570              PUSH     {r4-r6,lr}
;;;1178   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1179     /* Check the parameters */
;;;1180     assert_param(IS_RTC_CALIB_SIGN(CalibSign));
;;;1181     assert_param(IS_RTC_CALIB_VALUE(Value));
;;;1182   
;;;1183     /* Process Locked */
;;;1184     __HAL_LOCK(hrtc);
000008  bf00              NOP      
00000a  7f20              LDRB     r0,[r4,#0x1c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L20.20|
000010  2002              MOVS     r0,#2
                  |L20.18|
;;;1185   
;;;1186     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1187   
;;;1188     /* Disable the write protection for RTC registers */
;;;1189     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1190   
;;;1191     /* Set Initialization mode */
;;;1192     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1193     {
;;;1194       /* Enable the write protection for RTC registers */
;;;1195       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1196   
;;;1197       /* Set RTC state*/
;;;1198       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1199   
;;;1200       /* Process Unlocked */
;;;1201       __HAL_UNLOCK(hrtc);
;;;1202   
;;;1203       return HAL_ERROR;
;;;1204     }
;;;1205     else
;;;1206     {
;;;1207       /* Enable the Coarse Calibration */
;;;1208       __HAL_RTC_COARSE_CALIB_ENABLE(hrtc);
;;;1209   
;;;1210       /* Set the coarse calibration value */
;;;1211       hrtc->Instance->CALIBR = (uint32_t)(CalibSign|Value);
;;;1212   
;;;1213       /* Exit Initialization mode */
;;;1214       hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
;;;1215     }
;;;1216   
;;;1217     /* Enable the write protection for RTC registers */
;;;1218     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1219   
;;;1220     /* Change state */
;;;1221     hrtc->State = HAL_RTC_STATE_READY;
;;;1222   
;;;1223     /* Process Unlocked */
;;;1224     __HAL_UNLOCK(hrtc);
;;;1225   
;;;1226     return HAL_OK;
;;;1227   }
000012  bd70              POP      {r4-r6,pc}
                  |L20.20|
000014  2001              MOVS     r0,#1                 ;1184
000016  7720              STRB     r0,[r4,#0x1c]         ;1184
000018  bf00              NOP                            ;1184
00001a  2002              MOVS     r0,#2                 ;1186
00001c  7760              STRB     r0,[r4,#0x1d]         ;1186
00001e  bf00              NOP                            ;1189
000020  20ca              MOVS     r0,#0xca              ;1189
000022  6821              LDR      r1,[r4,#0]            ;1189
000024  6248              STR      r0,[r1,#0x24]         ;1189
000026  2053              MOVS     r0,#0x53              ;1189
000028  6821              LDR      r1,[r4,#0]            ;1189
00002a  6248              STR      r0,[r1,#0x24]         ;1189
00002c  bf00              NOP                            ;1189
00002e  4620              MOV      r0,r4                 ;1192
000030  f7fffffe          BL       RTC_EnterInitMode
000034  b160              CBZ      r0,|L20.80|
000036  bf00              NOP                            ;1195
000038  20ff              MOVS     r0,#0xff              ;1195
00003a  6821              LDR      r1,[r4,#0]            ;1195
00003c  6248              STR      r0,[r1,#0x24]         ;1195
00003e  bf00              NOP                            ;1195
000040  2004              MOVS     r0,#4                 ;1198
000042  7760              STRB     r0,[r4,#0x1d]         ;1198
000044  bf00              NOP                            ;1201
000046  2000              MOVS     r0,#0                 ;1201
000048  7720              STRB     r0,[r4,#0x1c]         ;1201
00004a  bf00              NOP                            ;1201
00004c  2001              MOVS     r0,#1                 ;1203
00004e  e7e0              B        |L20.18|
                  |L20.80|
000050  6820              LDR      r0,[r4,#0]            ;1208
000052  6880              LDR      r0,[r0,#8]            ;1208
000054  f0400080          ORR      r0,r0,#0x80           ;1208
000058  6821              LDR      r1,[r4,#0]            ;1208
00005a  6088              STR      r0,[r1,#8]            ;1208
00005c  ea460005          ORR      r0,r6,r5              ;1211
000060  6821              LDR      r1,[r4,#0]            ;1211
000062  6188              STR      r0,[r1,#0x18]         ;1211
000064  6820              LDR      r0,[r4,#0]            ;1214
000066  68c0              LDR      r0,[r0,#0xc]          ;1214
000068  f0200080          BIC      r0,r0,#0x80           ;1214
00006c  6821              LDR      r1,[r4,#0]            ;1214
00006e  60c8              STR      r0,[r1,#0xc]          ;1214
000070  bf00              NOP                            ;1218
000072  20ff              MOVS     r0,#0xff              ;1218
000074  6821              LDR      r1,[r4,#0]            ;1218
000076  6248              STR      r0,[r1,#0x24]         ;1218
000078  bf00              NOP                            ;1218
00007a  2001              MOVS     r0,#1                 ;1221
00007c  7760              STRB     r0,[r4,#0x1d]         ;1221
00007e  bf00              NOP                            ;1224
000080  2000              MOVS     r0,#0                 ;1224
000082  7720              STRB     r0,[r4,#0x1c]         ;1224
000084  bf00              NOP                            ;1224
000086  bf00              NOP                            ;1226
000088  e7c3              B        |L20.18|
;;;1228   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetRefClock||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetRefClock PROC
;;;1533     */
;;;1534   HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef* hrtc)
000000  b510              PUSH     {r4,lr}
;;;1535   {
000002  4604              MOV      r4,r0
;;;1536     /* Process Locked */
;;;1537     __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f20              LDRB     r0,[r4,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L21.16|
00000c  2002              MOVS     r0,#2
                  |L21.14|
;;;1538   
;;;1539     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1540   
;;;1541     /* Disable the write protection for RTC registers */
;;;1542     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1543   
;;;1544     /* Set Initialization mode */
;;;1545     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1546     {
;;;1547       /* Enable the write protection for RTC registers */
;;;1548       __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1549   
;;;1550       /* Set RTC state*/
;;;1551       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1552   
;;;1553       /* Process Unlocked */
;;;1554       __HAL_UNLOCK(hrtc);
;;;1555   
;;;1556       return HAL_ERROR;
;;;1557     }
;;;1558     else
;;;1559     {
;;;1560       __HAL_RTC_CLOCKREF_DETECTION_ENABLE(hrtc);
;;;1561   
;;;1562       /* Exit Initialization mode */
;;;1563       hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
;;;1564     }
;;;1565   
;;;1566     /* Enable the write protection for RTC registers */
;;;1567     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1568   
;;;1569      /* Change RTC state */
;;;1570     hrtc->State = HAL_RTC_STATE_READY;
;;;1571   
;;;1572     /* Process Unlocked */
;;;1573     __HAL_UNLOCK(hrtc);
;;;1574   
;;;1575     return HAL_OK;
;;;1576   }
00000e  bd10              POP      {r4,pc}
                  |L21.16|
000010  2001              MOVS     r0,#1                 ;1537
000012  7720              STRB     r0,[r4,#0x1c]         ;1537
000014  bf00              NOP                            ;1537
000016  2002              MOVS     r0,#2                 ;1539
000018  7760              STRB     r0,[r4,#0x1d]         ;1539
00001a  bf00              NOP                            ;1542
00001c  20ca              MOVS     r0,#0xca              ;1542
00001e  6821              LDR      r1,[r4,#0]            ;1542
000020  6248              STR      r0,[r1,#0x24]         ;1542
000022  2053              MOVS     r0,#0x53              ;1542
000024  6821              LDR      r1,[r4,#0]            ;1542
000026  6248              STR      r0,[r1,#0x24]         ;1542
000028  bf00              NOP                            ;1542
00002a  4620              MOV      r0,r4                 ;1545
00002c  f7fffffe          BL       RTC_EnterInitMode
000030  b160              CBZ      r0,|L21.76|
000032  bf00              NOP                            ;1548
000034  20ff              MOVS     r0,#0xff              ;1548
000036  6821              LDR      r1,[r4,#0]            ;1548
000038  6248              STR      r0,[r1,#0x24]         ;1548
00003a  bf00              NOP                            ;1548
00003c  2004              MOVS     r0,#4                 ;1551
00003e  7760              STRB     r0,[r4,#0x1d]         ;1551
000040  bf00              NOP                            ;1554
000042  2000              MOVS     r0,#0                 ;1554
000044  7720              STRB     r0,[r4,#0x1c]         ;1554
000046  bf00              NOP                            ;1554
000048  2001              MOVS     r0,#1                 ;1556
00004a  e7e0              B        |L21.14|
                  |L21.76|
00004c  6820              LDR      r0,[r4,#0]            ;1560
00004e  6880              LDR      r0,[r0,#8]            ;1560
000050  f0400010          ORR      r0,r0,#0x10           ;1560
000054  6821              LDR      r1,[r4,#0]            ;1560
000056  6088              STR      r0,[r1,#8]            ;1560
000058  6820              LDR      r0,[r4,#0]            ;1563
00005a  68c0              LDR      r0,[r0,#0xc]          ;1563
00005c  f0200080          BIC      r0,r0,#0x80           ;1563
000060  6821              LDR      r1,[r4,#0]            ;1563
000062  60c8              STR      r0,[r1,#0xc]          ;1563
000064  bf00              NOP                            ;1567
000066  20ff              MOVS     r0,#0xff              ;1567
000068  6821              LDR      r1,[r4,#0]            ;1567
00006a  6248              STR      r0,[r1,#0x24]         ;1567
00006c  bf00              NOP                            ;1567
00006e  2001              MOVS     r0,#1                 ;1570
000070  7760              STRB     r0,[r4,#0x1d]         ;1570
000072  bf00              NOP                            ;1573
000074  2000              MOVS     r0,#0                 ;1573
000076  7720              STRB     r0,[r4,#0x1c]         ;1573
000078  bf00              NOP                            ;1573
00007a  bf00              NOP                            ;1575
00007c  e7c7              B        |L21.14|
;;;1577   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetSmoothCalib||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetSmoothCalib PROC
;;;1299     */
;;;1300   HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef* hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmouthCalibMinusPulsesValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1301   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1302     uint32_t tickstart = 0U;
00000c  f04f0800          MOV      r8,#0
;;;1303   
;;;1304     /* Check the parameters */
;;;1305     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
;;;1306     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
;;;1307     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmouthCalibMinusPulsesValue));
;;;1308   
;;;1309     /* Process Locked */
;;;1310     __HAL_LOCK(hrtc);
000010  bf00              NOP      
000012  7f20              LDRB     r0,[r4,#0x1c]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L22.30|
000018  2002              MOVS     r0,#2
                  |L22.26|
;;;1311   
;;;1312     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1313   
;;;1314     /* Disable the write protection for RTC registers */
;;;1315     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1316   
;;;1317     /* check if a calibration is pending*/
;;;1318     if((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
;;;1319     {
;;;1320     /* Get tick */
;;;1321     tickstart = HAL_GetTick();
;;;1322   
;;;1323       /* check if a calibration is pending*/
;;;1324       while((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
;;;1325       {
;;;1326         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;1327         {
;;;1328           /* Enable the write protection for RTC registers */
;;;1329           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1330   
;;;1331           /* Change RTC state */
;;;1332           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1333   
;;;1334           /* Process Unlocked */
;;;1335           __HAL_UNLOCK(hrtc);
;;;1336   
;;;1337           return HAL_TIMEOUT;
;;;1338         }
;;;1339       }
;;;1340     }
;;;1341   
;;;1342     /* Configure the Smooth calibration settings */
;;;1343     hrtc->Instance->CALR = (uint32_t)((uint32_t)SmoothCalibPeriod | (uint32_t)SmoothCalibPlusPulses | (uint32_t)SmouthCalibMinusPulsesValue);
;;;1344   
;;;1345     /* Enable the write protection for RTC registers */
;;;1346     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1347   
;;;1348     /* Change RTC state */
;;;1349     hrtc->State = HAL_RTC_STATE_READY;
;;;1350   
;;;1351     /* Process Unlocked */
;;;1352     __HAL_UNLOCK(hrtc);
;;;1353   
;;;1354     return HAL_OK;
;;;1355   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L22.30|
00001e  2001              MOVS     r0,#1                 ;1310
000020  7720              STRB     r0,[r4,#0x1c]         ;1310
000022  bf00              NOP                            ;1310
000024  2002              MOVS     r0,#2                 ;1312
000026  7760              STRB     r0,[r4,#0x1d]         ;1312
000028  bf00              NOP                            ;1315
00002a  20ca              MOVS     r0,#0xca              ;1315
00002c  6821              LDR      r1,[r4,#0]            ;1315
00002e  6248              STR      r0,[r1,#0x24]         ;1315
000030  2053              MOVS     r0,#0x53              ;1315
000032  6821              LDR      r1,[r4,#0]            ;1315
000034  6248              STR      r0,[r1,#0x24]         ;1315
000036  bf00              NOP                            ;1315
000038  6820              LDR      r0,[r4,#0]            ;1318
00003a  68c0              LDR      r0,[r0,#0xc]          ;1318
00003c  f4003080          AND      r0,r0,#0x10000        ;1318
000040  b1e8              CBZ      r0,|L22.126|
000042  f7fffffe          BL       HAL_GetTick
000046  4680              MOV      r8,r0                 ;1321
000048  e013              B        |L22.114|
                  |L22.74|
00004a  f7fffffe          BL       HAL_GetTick
00004e  eba00008          SUB      r0,r0,r8              ;1326
000052  f5b07f7a          CMP      r0,#0x3e8             ;1326
000056  d90c              BLS      |L22.114|
000058  bf00              NOP                            ;1329
00005a  20ff              MOVS     r0,#0xff              ;1329
00005c  6821              LDR      r1,[r4,#0]            ;1329
00005e  6248              STR      r0,[r1,#0x24]         ;1329
000060  bf00              NOP                            ;1329
000062  2003              MOVS     r0,#3                 ;1332
000064  7760              STRB     r0,[r4,#0x1d]         ;1332
000066  bf00              NOP                            ;1335
000068  2000              MOVS     r0,#0                 ;1335
00006a  7720              STRB     r0,[r4,#0x1c]         ;1335
00006c  bf00              NOP                            ;1335
00006e  2003              MOVS     r0,#3                 ;1337
000070  e7d3              B        |L22.26|
                  |L22.114|
000072  6820              LDR      r0,[r4,#0]            ;1324
000074  68c0              LDR      r0,[r0,#0xc]          ;1324
000076  f4003080          AND      r0,r0,#0x10000        ;1324
00007a  2800              CMP      r0,#0                 ;1324
00007c  d1e5              BNE      |L22.74|
                  |L22.126|
00007e  ea450006          ORR      r0,r5,r6              ;1343
000082  4338              ORRS     r0,r0,r7              ;1343
000084  6821              LDR      r1,[r4,#0]            ;1343
000086  63c8              STR      r0,[r1,#0x3c]         ;1343
000088  bf00              NOP                            ;1346
00008a  20ff              MOVS     r0,#0xff              ;1346
00008c  6821              LDR      r1,[r4,#0]            ;1346
00008e  6248              STR      r0,[r1,#0x24]         ;1346
000090  bf00              NOP                            ;1346
000092  2001              MOVS     r0,#1                 ;1349
000094  7760              STRB     r0,[r4,#0x1d]         ;1349
000096  bf00              NOP                            ;1352
000098  2000              MOVS     r0,#0                 ;1352
00009a  7720              STRB     r0,[r4,#0x1c]         ;1352
00009c  bf00              NOP                            ;1352
00009e  bf00              NOP                            ;1354
0000a0  e7bb              B        |L22.26|
;;;1356   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetSynchroShift||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetSynchroShift PROC
;;;1369     */
;;;1370   HAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef* hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1371   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1372     uint32_t tickstart = 0U;
00000a  2700              MOVS     r7,#0
;;;1373   
;;;1374     /* Check the parameters */
;;;1375     assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
;;;1376     assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));
;;;1377   
;;;1378     /* Process Locked */
;;;1379     __HAL_LOCK(hrtc);
00000c  bf00              NOP      
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L23.26|
000014  2002              MOVS     r0,#2
                  |L23.22|
;;;1380   
;;;1381     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1382   
;;;1383     /* Disable the write protection for RTC registers */
;;;1384     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1385   
;;;1386     /* Get tick */
;;;1387     tickstart = HAL_GetTick();
;;;1388   
;;;1389       /* Wait until the shift is completed*/
;;;1390       while((hrtc->Instance->ISR & RTC_ISR_SHPF) != RESET)
;;;1391       {
;;;1392         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;1393         {
;;;1394           /* Enable the write protection for RTC registers */
;;;1395           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1396   
;;;1397           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1398   
;;;1399           /* Process Unlocked */
;;;1400           __HAL_UNLOCK(hrtc);
;;;1401   
;;;1402           return HAL_TIMEOUT;
;;;1403         }
;;;1404       }
;;;1405   
;;;1406       /* Check if the reference clock detection is disabled */
;;;1407       if((hrtc->Instance->CR & RTC_CR_REFCKON) == RESET)
;;;1408       {
;;;1409         /* Configure the Shift settings */
;;;1410         hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);
;;;1411   
;;;1412         /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;1413         if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
;;;1414         {
;;;1415           if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;1416           {
;;;1417             /* Enable the write protection for RTC registers */
;;;1418             __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1419   
;;;1420             hrtc->State = HAL_RTC_STATE_ERROR;
;;;1421   
;;;1422             /* Process Unlocked */
;;;1423             __HAL_UNLOCK(hrtc);
;;;1424   
;;;1425             return HAL_ERROR;
;;;1426           }
;;;1427         }
;;;1428       }
;;;1429       else
;;;1430       {
;;;1431         /* Enable the write protection for RTC registers */
;;;1432         __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1433   
;;;1434         /* Change RTC state */
;;;1435         hrtc->State = HAL_RTC_STATE_ERROR;
;;;1436   
;;;1437         /* Process Unlocked */
;;;1438         __HAL_UNLOCK(hrtc);
;;;1439   
;;;1440         return HAL_ERROR;
;;;1441       }
;;;1442   
;;;1443     /* Enable the write protection for RTC registers */
;;;1444     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1445   
;;;1446     /* Change RTC state */
;;;1447     hrtc->State = HAL_RTC_STATE_READY;
;;;1448   
;;;1449     /* Process Unlocked */
;;;1450     __HAL_UNLOCK(hrtc);
;;;1451   
;;;1452     return HAL_OK;
;;;1453   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L23.26|
00001a  2001              MOVS     r0,#1                 ;1379
00001c  7720              STRB     r0,[r4,#0x1c]         ;1379
00001e  bf00              NOP                            ;1379
000020  2002              MOVS     r0,#2                 ;1381
000022  7760              STRB     r0,[r4,#0x1d]         ;1381
000024  bf00              NOP                            ;1384
000026  20ca              MOVS     r0,#0xca              ;1384
000028  6821              LDR      r1,[r4,#0]            ;1384
00002a  6248              STR      r0,[r1,#0x24]         ;1384
00002c  2053              MOVS     r0,#0x53              ;1384
00002e  6821              LDR      r1,[r4,#0]            ;1384
000030  6248              STR      r0,[r1,#0x24]         ;1384
000032  bf00              NOP                            ;1384
000034  f7fffffe          BL       HAL_GetTick
000038  4607              MOV      r7,r0                 ;1387
00003a  e012              B        |L23.98|
                  |L23.60|
00003c  f7fffffe          BL       HAL_GetTick
000040  1bc0              SUBS     r0,r0,r7              ;1392
000042  f5b07f7a          CMP      r0,#0x3e8             ;1392
000046  d90c              BLS      |L23.98|
000048  bf00              NOP                            ;1395
00004a  20ff              MOVS     r0,#0xff              ;1395
00004c  6821              LDR      r1,[r4,#0]            ;1395
00004e  6248              STR      r0,[r1,#0x24]         ;1395
000050  bf00              NOP                            ;1395
000052  2003              MOVS     r0,#3                 ;1397
000054  7760              STRB     r0,[r4,#0x1d]         ;1397
000056  bf00              NOP                            ;1400
000058  2000              MOVS     r0,#0                 ;1400
00005a  7720              STRB     r0,[r4,#0x1c]         ;1400
00005c  bf00              NOP                            ;1400
00005e  2003              MOVS     r0,#3                 ;1402
000060  e7d9              B        |L23.22|
                  |L23.98|
000062  6820              LDR      r0,[r4,#0]            ;1390
000064  68c0              LDR      r0,[r0,#0xc]          ;1390
000066  f0000008          AND      r0,r0,#8              ;1390
00006a  2800              CMP      r0,#0                 ;1390
00006c  d1e6              BNE      |L23.60|
00006e  6820              LDR      r0,[r4,#0]            ;1407
000070  6880              LDR      r0,[r0,#8]            ;1407
000072  f0000010          AND      r0,r0,#0x10           ;1407
000076  b9c8              CBNZ     r0,|L23.172|
000078  ea460005          ORR      r0,r6,r5              ;1410
00007c  6821              LDR      r1,[r4,#0]            ;1410
00007e  62c8              STR      r0,[r1,#0x2c]         ;1410
000080  6820              LDR      r0,[r4,#0]            ;1413
000082  6880              LDR      r0,[r0,#8]            ;1413
000084  f0000020          AND      r0,r0,#0x20           ;1413
000088  b9e8              CBNZ     r0,|L23.198|
00008a  4620              MOV      r0,r4                 ;1415
00008c  f7fffffe          BL       HAL_RTC_WaitForSynchro
000090  b1c8              CBZ      r0,|L23.198|
000092  bf00              NOP                            ;1418
000094  20ff              MOVS     r0,#0xff              ;1418
000096  6821              LDR      r1,[r4,#0]            ;1418
000098  6248              STR      r0,[r1,#0x24]         ;1418
00009a  bf00              NOP                            ;1418
00009c  2004              MOVS     r0,#4                 ;1420
00009e  7760              STRB     r0,[r4,#0x1d]         ;1420
0000a0  bf00              NOP                            ;1423
0000a2  2000              MOVS     r0,#0                 ;1423
0000a4  7720              STRB     r0,[r4,#0x1c]         ;1423
0000a6  bf00              NOP                            ;1423
0000a8  2001              MOVS     r0,#1                 ;1425
0000aa  e7b4              B        |L23.22|
                  |L23.172|
0000ac  bf00              NOP                            ;1432
0000ae  20ff              MOVS     r0,#0xff              ;1432
0000b0  6821              LDR      r1,[r4,#0]            ;1432
0000b2  6248              STR      r0,[r1,#0x24]         ;1432
0000b4  bf00              NOP                            ;1432
0000b6  2004              MOVS     r0,#4                 ;1435
0000b8  7760              STRB     r0,[r4,#0x1d]         ;1435
0000ba  bf00              NOP                            ;1438
0000bc  2000              MOVS     r0,#0                 ;1438
0000be  7720              STRB     r0,[r4,#0x1c]         ;1438
0000c0  bf00              NOP                            ;1438
0000c2  2001              MOVS     r0,#1                 ;1440
0000c4  e7a7              B        |L23.22|
                  |L23.198|
0000c6  bf00              NOP                            ;1444
0000c8  20ff              MOVS     r0,#0xff              ;1444
0000ca  6821              LDR      r1,[r4,#0]            ;1444
0000cc  6248              STR      r0,[r1,#0x24]         ;1444
0000ce  bf00              NOP                            ;1444
0000d0  2001              MOVS     r0,#1                 ;1447
0000d2  7760              STRB     r0,[r4,#0x1d]         ;1447
0000d4  bf00              NOP                            ;1450
0000d6  2000              MOVS     r0,#0                 ;1450
0000d8  7720              STRB     r0,[r4,#0x1c]         ;1450
0000da  bf00              NOP                            ;1450
0000dc  bf00              NOP                            ;1452
0000de  e79a              B        |L23.22|
;;;1454   
                          ENDP


                          AREA ||i.HAL_RTCEx_SetTamper||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetTamper PROC
;;;353      */
;;;354    HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
000000  b510              PUSH     {r4,lr}
;;;355    {
000002  4602              MOV      r2,r0
;;;356      uint32_t tmpreg = 0U;
000004  2300              MOVS     r3,#0
;;;357    
;;;358      /* Check the parameters */
;;;359      assert_param(IS_RTC_TAMPER(sTamper->Tamper));
;;;360      assert_param(IS_RTC_TAMPER_PIN(sTamper->PinSelection));
;;;361      assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;362      assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
;;;363      assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));
;;;364      assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
;;;365      assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
;;;366      assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
;;;367    
;;;368      /* Process Locked */
;;;369      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f10              LDRB     r0,[r2,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L24.18|
00000e  2002              MOVS     r0,#2
                  |L24.16|
;;;370    
;;;371      hrtc->State = HAL_RTC_STATE_BUSY;
;;;372    
;;;373      if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
;;;374      {
;;;375        sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1U);
;;;376      }
;;;377    
;;;378      tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->PinSelection | (uint32_t)sTamper->Trigger  |\
;;;379                (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency | (uint32_t)sTamper->PrechargeDuration |\
;;;380                (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);
;;;381    
;;;382      hrtc->Instance->TAFCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1U) | (uint32_t)RTC_TAFCR_TAMPTS |\
;;;383                                           (uint32_t)RTC_TAFCR_TAMPFREQ | (uint32_t)RTC_TAFCR_TAMPFLT | (uint32_t)RTC_TAFCR_TAMPPRCH |\
;;;384                                           (uint32_t)RTC_TAFCR_TAMPPUDIS | (uint32_t)RTC_TAFCR_TAMPINSEL | (uint32_t)RTC_TAFCR_TAMPIE);
;;;385    
;;;386      hrtc->Instance->TAFCR |= tmpreg;
;;;387    
;;;388      hrtc->State = HAL_RTC_STATE_READY;
;;;389    
;;;390      /* Process Unlocked */
;;;391      __HAL_UNLOCK(hrtc);
;;;392    
;;;393      return HAL_OK;
;;;394    }
000010  bd10              POP      {r4,pc}
                  |L24.18|
000012  2001              MOVS     r0,#1                 ;369
000014  7710              STRB     r0,[r2,#0x1c]         ;369
000016  bf00              NOP                            ;369
000018  2002              MOVS     r0,#2                 ;371
00001a  7750              STRB     r0,[r2,#0x1d]         ;371
00001c  6888              LDR      r0,[r1,#8]            ;373
00001e  b110              CBZ      r0,|L24.38|
000020  6808              LDR      r0,[r1,#0]            ;375
000022  0040              LSLS     r0,r0,#1              ;375
000024  6088              STR      r0,[r1,#8]            ;375
                  |L24.38|
000026  e9d10400          LDRD     r0,r4,[r1,#0]         ;378
00002a  4320              ORRS     r0,r0,r4              ;378
00002c  688c              LDR      r4,[r1,#8]            ;378
00002e  4320              ORRS     r0,r0,r4              ;378
000030  68cc              LDR      r4,[r1,#0xc]          ;378
000032  4320              ORRS     r0,r0,r4              ;378
000034  690c              LDR      r4,[r1,#0x10]         ;378
000036  4320              ORRS     r0,r0,r4              ;378
000038  694c              LDR      r4,[r1,#0x14]         ;378
00003a  4320              ORRS     r0,r0,r4              ;378
00003c  698c              LDR      r4,[r1,#0x18]         ;378
00003e  4320              ORRS     r0,r0,r4              ;378
000040  69cc              LDR      r4,[r1,#0x1c]         ;378
000042  ea400304          ORR      r3,r0,r4              ;378
000046  6808              LDR      r0,[r1,#0]            ;382
000048  ea400040          ORR      r0,r0,r0,LSL #1       ;382
00004c  f44040ff          ORR      r0,r0,#0x7f80         ;382
000050  f44030c0          ORR      r0,r0,#0x18000        ;382
000054  f0400404          ORR      r4,r0,#4              ;382
000058  6810              LDR      r0,[r2,#0]            ;382
00005a  6c00              LDR      r0,[r0,#0x40]         ;382
00005c  43a0              BICS     r0,r0,r4              ;382
00005e  6814              LDR      r4,[r2,#0]            ;382
000060  6420              STR      r0,[r4,#0x40]         ;382
000062  6810              LDR      r0,[r2,#0]            ;386
000064  6c00              LDR      r0,[r0,#0x40]         ;386
000066  4318              ORRS     r0,r0,r3              ;386
000068  6814              LDR      r4,[r2,#0]            ;386
00006a  6420              STR      r0,[r4,#0x40]         ;386
00006c  2001              MOVS     r0,#1                 ;388
00006e  7750              STRB     r0,[r2,#0x1d]         ;388
000070  bf00              NOP                            ;391
000072  2000              MOVS     r0,#0                 ;391
000074  7710              STRB     r0,[r2,#0x1c]         ;391
000076  bf00              NOP                            ;391
000078  bf00              NOP                            ;393
00007a  e7c9              B        |L24.16|
;;;395    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetTamper_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTamper_IT PROC
;;;403      */
;;;404    HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
000000  b510              PUSH     {r4,lr}
;;;405    {
000002  4602              MOV      r2,r0
;;;406      uint32_t tmpreg = 0U;
000004  2300              MOVS     r3,#0
;;;407    
;;;408      /* Check the parameters */
;;;409      assert_param(IS_RTC_TAMPER(sTamper->Tamper));
;;;410      assert_param(IS_RTC_TAMPER_PIN(sTamper->PinSelection));
;;;411      assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;412      assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
;;;413      assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));
;;;414      assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
;;;415      assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
;;;416      assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
;;;417    
;;;418      /* Process Locked */
;;;419      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f10              LDRB     r0,[r2,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L25.18|
00000e  2002              MOVS     r0,#2
                  |L25.16|
;;;420    
;;;421      hrtc->State = HAL_RTC_STATE_BUSY;
;;;422    
;;;423      /* Configure the tamper trigger */
;;;424      if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
;;;425      {
;;;426        sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1U);
;;;427      }
;;;428    
;;;429      tmpreg = ((uint32_t)sTamper->Tamper | (uint32_t)sTamper->PinSelection | (uint32_t)sTamper->Trigger  |\
;;;430                (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency | (uint32_t)sTamper->PrechargeDuration |\
;;;431                (uint32_t)sTamper->TamperPullUp | sTamper->TimeStampOnTamperDetection);
;;;432    
;;;433      hrtc->Instance->TAFCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1U) | (uint32_t)RTC_TAFCR_TAMPTS |\
;;;434                                           (uint32_t)RTC_TAFCR_TAMPFREQ | (uint32_t)RTC_TAFCR_TAMPFLT | (uint32_t)RTC_TAFCR_TAMPPRCH |\
;;;435                                           (uint32_t)RTC_TAFCR_TAMPPUDIS | (uint32_t)RTC_TAFCR_TAMPINSEL);
;;;436    
;;;437      hrtc->Instance->TAFCR |= tmpreg;
;;;438    
;;;439      /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;440      hrtc->Instance->TAFCR |= (uint32_t)RTC_TAFCR_TAMPIE;
;;;441    
;;;442      if(sTamper->Tamper == RTC_TAMPER_1)
;;;443      {
;;;444        /* Clear RTC Tamper 1 flag */
;;;445        __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
;;;446      }
;;;447      else
;;;448      {
;;;449        /* Clear RTC Tamper 2 flag */
;;;450        __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
;;;451      }
;;;452    
;;;453      /* RTC Tamper Interrupt Configuration: EXTI configuration */
;;;454      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
;;;455    
;;;456      EXTI->RTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT;
;;;457    
;;;458      hrtc->State = HAL_RTC_STATE_READY;
;;;459    
;;;460      /* Process Unlocked */
;;;461      __HAL_UNLOCK(hrtc);
;;;462    
;;;463      return HAL_OK;
;;;464    }
000010  bd10              POP      {r4,pc}
                  |L25.18|
000012  2001              MOVS     r0,#1                 ;419
000014  7710              STRB     r0,[r2,#0x1c]         ;419
000016  bf00              NOP                            ;419
000018  2002              MOVS     r0,#2                 ;421
00001a  7750              STRB     r0,[r2,#0x1d]         ;421
00001c  6888              LDR      r0,[r1,#8]            ;424
00001e  b110              CBZ      r0,|L25.38|
000020  6808              LDR      r0,[r1,#0]            ;426
000022  0040              LSLS     r0,r0,#1              ;426
000024  6088              STR      r0,[r1,#8]            ;426
                  |L25.38|
000026  e9d10400          LDRD     r0,r4,[r1,#0]         ;429
00002a  4320              ORRS     r0,r0,r4              ;429
00002c  688c              LDR      r4,[r1,#8]            ;429
00002e  4320              ORRS     r0,r0,r4              ;429
000030  68cc              LDR      r4,[r1,#0xc]          ;429
000032  4320              ORRS     r0,r0,r4              ;429
000034  690c              LDR      r4,[r1,#0x10]         ;429
000036  4320              ORRS     r0,r0,r4              ;429
000038  694c              LDR      r4,[r1,#0x14]         ;429
00003a  4320              ORRS     r0,r0,r4              ;429
00003c  698c              LDR      r4,[r1,#0x18]         ;429
00003e  4320              ORRS     r0,r0,r4              ;429
000040  69cc              LDR      r4,[r1,#0x1c]         ;429
000042  ea400304          ORR      r3,r0,r4              ;429
000046  6808              LDR      r0,[r1,#0]            ;433
000048  ea400040          ORR      r0,r0,r0,LSL #1       ;433
00004c  f44040ff          ORR      r0,r0,#0x7f80         ;433
000050  f44034c0          ORR      r4,r0,#0x18000        ;433
000054  6810              LDR      r0,[r2,#0]            ;433
000056  6c00              LDR      r0,[r0,#0x40]         ;433
000058  43a0              BICS     r0,r0,r4              ;433
00005a  6814              LDR      r4,[r2,#0]            ;433
00005c  6420              STR      r0,[r4,#0x40]         ;433
00005e  6810              LDR      r0,[r2,#0]            ;437
000060  6c00              LDR      r0,[r0,#0x40]         ;437
000062  4318              ORRS     r0,r0,r3              ;437
000064  6814              LDR      r4,[r2,#0]            ;437
000066  6420              STR      r0,[r4,#0x40]         ;437
000068  6810              LDR      r0,[r2,#0]            ;440
00006a  6c00              LDR      r0,[r0,#0x40]         ;440
00006c  f0400004          ORR      r0,r0,#4              ;440
000070  6814              LDR      r4,[r2,#0]            ;440
000072  6420              STR      r0,[r4,#0x40]         ;440
000074  6808              LDR      r0,[r1,#0]            ;442
000076  2801              CMP      r0,#1                 ;442
000078  d108              BNE      |L25.140|
00007a  6810              LDR      r0,[r2,#0]            ;445
00007c  68c0              LDR      r0,[r0,#0xc]          ;445
00007e  f0000080          AND      r0,r0,#0x80           ;445
000082  f4605002          ORN      r0,r0,#0x2080         ;445
000086  6814              LDR      r4,[r2,#0]            ;445
000088  60e0              STR      r0,[r4,#0xc]          ;445
00008a  e007              B        |L25.156|
                  |L25.140|
00008c  6810              LDR      r0,[r2,#0]            ;450
00008e  68c0              LDR      r0,[r0,#0xc]          ;450
000090  f0000080          AND      r0,r0,#0x80           ;450
000094  f4604081          ORN      r0,r0,#0x4080         ;450
000098  6814              LDR      r4,[r2,#0]            ;450
00009a  60e0              STR      r0,[r4,#0xc]          ;450
                  |L25.156|
00009c  480a              LDR      r0,|L25.200|
00009e  6800              LDR      r0,[r0,#0]            ;454
0000a0  f4401000          ORR      r0,r0,#0x200000       ;454
0000a4  4c08              LDR      r4,|L25.200|
0000a6  6020              STR      r0,[r4,#0]            ;454
0000a8  4807              LDR      r0,|L25.200|
0000aa  3008              ADDS     r0,r0,#8              ;456
0000ac  6800              LDR      r0,[r0,#0]            ;456
0000ae  f4401000          ORR      r0,r0,#0x200000       ;456
0000b2  4c05              LDR      r4,|L25.200|
0000b4  3408              ADDS     r4,r4,#8              ;456
0000b6  6020              STR      r0,[r4,#0]            ;456
0000b8  2001              MOVS     r0,#1                 ;458
0000ba  7750              STRB     r0,[r2,#0x1d]         ;458
0000bc  bf00              NOP                            ;461
0000be  2000              MOVS     r0,#0                 ;461
0000c0  7710              STRB     r0,[r2,#0x1c]         ;461
0000c2  bf00              NOP                            ;461
0000c4  bf00              NOP                            ;463
0000c6  e7a3              B        |L25.16|
;;;465    
                          ENDP

                  |L25.200|
                          DCD      0x40013c00

                          AREA ||i.HAL_RTCEx_SetTimeStamp||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetTimeStamp PROC
;;;140      */
;;;141    HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
000000  b530              PUSH     {r4,r5,lr}
;;;142    {
000002  4603              MOV      r3,r0
;;;143      uint32_t tmpreg = 0U;
000004  2400              MOVS     r4,#0
;;;144    
;;;145      /* Check the parameters */
;;;146      assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
;;;147      assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;148    
;;;149      /* Process Locked */
;;;150      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f18              LDRB     r0,[r3,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L26.18|
00000e  2002              MOVS     r0,#2
                  |L26.16|
;;;151    
;;;152      hrtc->State = HAL_RTC_STATE_BUSY;
;;;153    
;;;154      /* Get the RTC_CR register and clear the bits to be configured */
;;;155      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
;;;156    
;;;157      tmpreg|= TimeStampEdge;
;;;158    
;;;159      /* Disable the write protection for RTC registers */
;;;160      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;161    
;;;162      hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_TSINSEL;
;;;163      hrtc->Instance->TAFCR |= (uint32_t)(RTC_TimeStampPin);
;;;164    
;;;165      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;166      hrtc->Instance->CR = (uint32_t)tmpreg;
;;;167    
;;;168      __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
;;;169    
;;;170      /* Enable the write protection for RTC registers */
;;;171      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;172    
;;;173      /* Change RTC state */
;;;174      hrtc->State = HAL_RTC_STATE_READY;
;;;175    
;;;176      /* Process Unlocked */
;;;177      __HAL_UNLOCK(hrtc);
;;;178    
;;;179      return HAL_OK;
;;;180    }
000010  bd30              POP      {r4,r5,pc}
                  |L26.18|
000012  2001              MOVS     r0,#1                 ;150
000014  7718              STRB     r0,[r3,#0x1c]         ;150
000016  bf00              NOP                            ;150
000018  2002              MOVS     r0,#2                 ;152
00001a  7758              STRB     r0,[r3,#0x1d]         ;152
00001c  6818              LDR      r0,[r3,#0]            ;155
00001e  6880              LDR      r0,[r0,#8]            ;155
000020  f6400508          MOV      r5,#0x808             ;155
000024  ea200405          BIC      r4,r0,r5              ;155
000028  430c              ORRS     r4,r4,r1              ;157
00002a  bf00              NOP                            ;160
00002c  20ca              MOVS     r0,#0xca              ;160
00002e  681d              LDR      r5,[r3,#0]            ;160
000030  6268              STR      r0,[r5,#0x24]         ;160
000032  2053              MOVS     r0,#0x53              ;160
000034  681d              LDR      r5,[r3,#0]            ;160
000036  6268              STR      r0,[r5,#0x24]         ;160
000038  bf00              NOP                            ;160
00003a  6818              LDR      r0,[r3,#0]            ;162
00003c  6c00              LDR      r0,[r0,#0x40]         ;162
00003e  f4203000          BIC      r0,r0,#0x20000        ;162
000042  681d              LDR      r5,[r3,#0]            ;162
000044  6428              STR      r0,[r5,#0x40]         ;162
000046  6818              LDR      r0,[r3,#0]            ;163
000048  6c00              LDR      r0,[r0,#0x40]         ;163
00004a  4310              ORRS     r0,r0,r2              ;163
00004c  681d              LDR      r5,[r3,#0]            ;163
00004e  6428              STR      r0,[r5,#0x40]         ;163
000050  6818              LDR      r0,[r3,#0]            ;166
000052  6084              STR      r4,[r0,#8]            ;166
000054  6818              LDR      r0,[r3,#0]            ;168
000056  6880              LDR      r0,[r0,#8]            ;168
000058  f4406000          ORR      r0,r0,#0x800          ;168
00005c  681d              LDR      r5,[r3,#0]            ;168
00005e  60a8              STR      r0,[r5,#8]            ;168
000060  bf00              NOP                            ;171
000062  20ff              MOVS     r0,#0xff              ;171
000064  681d              LDR      r5,[r3,#0]            ;171
000066  6268              STR      r0,[r5,#0x24]         ;171
000068  bf00              NOP                            ;171
00006a  2001              MOVS     r0,#1                 ;174
00006c  7758              STRB     r0,[r3,#0x1d]         ;174
00006e  bf00              NOP                            ;177
000070  2000              MOVS     r0,#0                 ;177
000072  7718              STRB     r0,[r3,#0x1c]         ;177
000074  bf00              NOP                            ;177
000076  bf00              NOP                            ;179
000078  e7ca              B        |L26.16|
;;;181    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetTimeStamp_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTimeStamp_IT PROC
;;;200      */
;;;201    HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
000000  b530              PUSH     {r4,r5,lr}
;;;202    {
000002  4603              MOV      r3,r0
;;;203      uint32_t tmpreg = 0U;
000004  2400              MOVS     r4,#0
;;;204    
;;;205      /* Check the parameters */
;;;206      assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
;;;207      assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;208    
;;;209      /* Process Locked */
;;;210      __HAL_LOCK(hrtc);
000006  bf00              NOP      
000008  7f18              LDRB     r0,[r3,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L27.18|
00000e  2002              MOVS     r0,#2
                  |L27.16|
;;;211    
;;;212      hrtc->State = HAL_RTC_STATE_BUSY;
;;;213    
;;;214      /* Get the RTC_CR register and clear the bits to be configured */
;;;215      tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
;;;216    
;;;217      tmpreg |= TimeStampEdge;
;;;218    
;;;219      /* Disable the write protection for RTC registers */
;;;220      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;221    
;;;222      /* Configure the Time Stamp TSEDGE and Enable bits */
;;;223      hrtc->Instance->CR = (uint32_t)tmpreg;
;;;224    
;;;225      hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_TSINSEL;
;;;226      hrtc->Instance->TAFCR |= (uint32_t)(RTC_TimeStampPin);
;;;227    
;;;228      /* Clear RTC Timestamp flag */
;;;229      __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
;;;230    
;;;231      __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
;;;232    
;;;233      /* Enable IT timestamp */
;;;234      __HAL_RTC_TIMESTAMP_ENABLE_IT(hrtc,RTC_IT_TS);
;;;235    
;;;236      /* RTC timestamp Interrupt Configuration: EXTI configuration */
;;;237      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
;;;238    
;;;239      EXTI->RTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT;
;;;240    
;;;241      /* Enable the write protection for RTC registers */
;;;242      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;243    
;;;244      hrtc->State = HAL_RTC_STATE_READY;
;;;245    
;;;246      /* Process Unlocked */
;;;247      __HAL_UNLOCK(hrtc);
;;;248    
;;;249      return HAL_OK;
;;;250    }
000010  bd30              POP      {r4,r5,pc}
                  |L27.18|
000012  2001              MOVS     r0,#1                 ;210
000014  7718              STRB     r0,[r3,#0x1c]         ;210
000016  bf00              NOP                            ;210
000018  2002              MOVS     r0,#2                 ;212
00001a  7758              STRB     r0,[r3,#0x1d]         ;212
00001c  6818              LDR      r0,[r3,#0]            ;215
00001e  6880              LDR      r0,[r0,#8]            ;215
000020  f6400508          MOV      r5,#0x808             ;215
000024  ea200405          BIC      r4,r0,r5              ;215
000028  430c              ORRS     r4,r4,r1              ;217
00002a  bf00              NOP                            ;220
00002c  20ca              MOVS     r0,#0xca              ;220
00002e  681d              LDR      r5,[r3,#0]            ;220
000030  6268              STR      r0,[r5,#0x24]         ;220
000032  2053              MOVS     r0,#0x53              ;220
000034  681d              LDR      r5,[r3,#0]            ;220
000036  6268              STR      r0,[r5,#0x24]         ;220
000038  bf00              NOP                            ;220
00003a  6818              LDR      r0,[r3,#0]            ;223
00003c  6084              STR      r4,[r0,#8]            ;223
00003e  6818              LDR      r0,[r3,#0]            ;225
000040  6c00              LDR      r0,[r0,#0x40]         ;225
000042  f4203000          BIC      r0,r0,#0x20000        ;225
000046  681d              LDR      r5,[r3,#0]            ;225
000048  6428              STR      r0,[r5,#0x40]         ;225
00004a  6818              LDR      r0,[r3,#0]            ;226
00004c  6c00              LDR      r0,[r0,#0x40]         ;226
00004e  4310              ORRS     r0,r0,r2              ;226
000050  681d              LDR      r5,[r3,#0]            ;226
000052  6428              STR      r0,[r5,#0x40]         ;226
000054  6818              LDR      r0,[r3,#0]            ;229
000056  68c0              LDR      r0,[r0,#0xc]          ;229
000058  f0000080          AND      r0,r0,#0x80           ;229
00005c  f4606008          ORN      r0,r0,#0x880          ;229
000060  681d              LDR      r5,[r3,#0]            ;229
000062  60e8              STR      r0,[r5,#0xc]          ;229
000064  6818              LDR      r0,[r3,#0]            ;231
000066  6880              LDR      r0,[r0,#8]            ;231
000068  f4406000          ORR      r0,r0,#0x800          ;231
00006c  681d              LDR      r5,[r3,#0]            ;231
00006e  60a8              STR      r0,[r5,#8]            ;231
000070  6818              LDR      r0,[r3,#0]            ;234
000072  6880              LDR      r0,[r0,#8]            ;234
000074  f4404000          ORR      r0,r0,#0x8000         ;234
000078  681d              LDR      r5,[r3,#0]            ;234
00007a  60a8              STR      r0,[r5,#8]            ;234
00007c  480d              LDR      r0,|L27.180|
00007e  6800              LDR      r0,[r0,#0]            ;237
000080  f4401000          ORR      r0,r0,#0x200000       ;237
000084  4d0b              LDR      r5,|L27.180|
000086  6028              STR      r0,[r5,#0]            ;237
000088  480a              LDR      r0,|L27.180|
00008a  3008              ADDS     r0,r0,#8              ;239
00008c  6800              LDR      r0,[r0,#0]            ;239
00008e  f4401000          ORR      r0,r0,#0x200000       ;239
000092  4d08              LDR      r5,|L27.180|
000094  3508              ADDS     r5,r5,#8              ;239
000096  6028              STR      r0,[r5,#0]            ;239
000098  bf00              NOP                            ;242
00009a  20ff              MOVS     r0,#0xff              ;242
00009c  681d              LDR      r5,[r3,#0]            ;242
00009e  6268              STR      r0,[r5,#0x24]         ;242
0000a0  bf00              NOP                            ;242
0000a2  2001              MOVS     r0,#1                 ;244
0000a4  7758              STRB     r0,[r3,#0x1d]         ;244
0000a6  bf00              NOP                            ;247
0000a8  2000              MOVS     r0,#0                 ;247
0000aa  7718              STRB     r0,[r3,#0x1c]         ;247
0000ac  bf00              NOP                            ;247
0000ae  bf00              NOP                            ;249
0000b0  e7ae              B        |L27.16|
;;;251    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L27.180|
                          DCD      0x40013c00

                          AREA ||i.HAL_RTCEx_SetWakeUpTimer||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetWakeUpTimer PROC
;;;746      */
;;;747    HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;748    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;749      uint32_t tickstart = 0U;
00000a  2700              MOVS     r7,#0
;;;750    
;;;751      /* Check the parameters */
;;;752      assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
;;;753      assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
;;;754    
;;;755      /* Process Locked */
;;;756      __HAL_LOCK(hrtc);
00000c  bf00              NOP      
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L28.26|
000014  2002              MOVS     r0,#2
                  |L28.22|
;;;757    
;;;758      hrtc->State = HAL_RTC_STATE_BUSY;
;;;759    
;;;760      /* Disable the write protection for RTC registers */
;;;761      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;762    
;;;763      /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
;;;764      if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
;;;765      {
;;;766        tickstart = HAL_GetTick();
;;;767    
;;;768        /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
;;;769        while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
;;;770        {
;;;771          if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;772          {
;;;773            /* Enable the write protection for RTC registers */
;;;774            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;775    
;;;776            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;777    
;;;778            /* Process Unlocked */
;;;779            __HAL_UNLOCK(hrtc);
;;;780    
;;;781            return HAL_TIMEOUT;
;;;782          }
;;;783        }
;;;784      }
;;;785    
;;;786      __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
;;;787    
;;;788      tickstart = HAL_GetTick();
;;;789    
;;;790      /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;791      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
;;;792      {
;;;793        if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;794        {
;;;795          /* Enable the write protection for RTC registers */
;;;796          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;797    
;;;798          hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;799    
;;;800          /* Process Unlocked */
;;;801          __HAL_UNLOCK(hrtc);
;;;802    
;;;803          return HAL_TIMEOUT;
;;;804        }
;;;805      }
;;;806    
;;;807      /* Clear the Wake-up Timer clock source bits in CR register */
;;;808      hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
;;;809    
;;;810      /* Configure the clock source */
;;;811      hrtc->Instance->CR |= (uint32_t)WakeUpClock;
;;;812    
;;;813      /* Configure the Wake-up Timer counter */
;;;814      hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
;;;815    
;;;816       /* Enable the Wake-up Timer */
;;;817      __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
;;;818    
;;;819      /* Enable the write protection for RTC registers */
;;;820      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;821    
;;;822      hrtc->State = HAL_RTC_STATE_READY;
;;;823    
;;;824      /* Process Unlocked */
;;;825      __HAL_UNLOCK(hrtc);
;;;826    
;;;827      return HAL_OK;
;;;828    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L28.26|
00001a  2001              MOVS     r0,#1                 ;756
00001c  7720              STRB     r0,[r4,#0x1c]         ;756
00001e  bf00              NOP                            ;756
000020  2002              MOVS     r0,#2                 ;758
000022  7760              STRB     r0,[r4,#0x1d]         ;758
000024  bf00              NOP                            ;761
000026  20ca              MOVS     r0,#0xca              ;761
000028  6821              LDR      r1,[r4,#0]            ;761
00002a  6248              STR      r0,[r1,#0x24]         ;761
00002c  2053              MOVS     r0,#0x53              ;761
00002e  6821              LDR      r1,[r4,#0]            ;761
000030  6248              STR      r0,[r1,#0x24]         ;761
000032  bf00              NOP                            ;761
000034  6820              LDR      r0,[r4,#0]            ;764
000036  6880              LDR      r0,[r0,#8]            ;764
000038  f4006080          AND      r0,r0,#0x400          ;764
00003c  b1e0              CBZ      r0,|L28.120|
00003e  f7fffffe          BL       HAL_GetTick
000042  4607              MOV      r7,r0                 ;766
000044  e012              B        |L28.108|
                  |L28.70|
000046  f7fffffe          BL       HAL_GetTick
00004a  1bc0              SUBS     r0,r0,r7              ;771
00004c  f5b07f7a          CMP      r0,#0x3e8             ;771
000050  d90c              BLS      |L28.108|
000052  bf00              NOP                            ;774
000054  20ff              MOVS     r0,#0xff              ;774
000056  6821              LDR      r1,[r4,#0]            ;774
000058  6248              STR      r0,[r1,#0x24]         ;774
00005a  bf00              NOP                            ;774
00005c  2003              MOVS     r0,#3                 ;776
00005e  7760              STRB     r0,[r4,#0x1d]         ;776
000060  bf00              NOP                            ;779
000062  2000              MOVS     r0,#0                 ;779
000064  7720              STRB     r0,[r4,#0x1c]         ;779
000066  bf00              NOP                            ;779
000068  2003              MOVS     r0,#3                 ;781
00006a  e7d4              B        |L28.22|
                  |L28.108|
00006c  6820              LDR      r0,[r4,#0]            ;769
00006e  68c0              LDR      r0,[r0,#0xc]          ;769
000070  f3c00080          UBFX     r0,r0,#2,#1           ;769
000074  2800              CMP      r0,#0                 ;769
000076  d1e6              BNE      |L28.70|
                  |L28.120|
000078  6820              LDR      r0,[r4,#0]            ;786
00007a  6880              LDR      r0,[r0,#8]            ;786
00007c  f4206080          BIC      r0,r0,#0x400          ;786
000080  6821              LDR      r1,[r4,#0]            ;786
000082  6088              STR      r0,[r1,#8]            ;786
000084  f7fffffe          BL       HAL_GetTick
000088  4607              MOV      r7,r0                 ;788
00008a  e012              B        |L28.178|
                  |L28.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  1bc0              SUBS     r0,r0,r7              ;793
000092  f5b07f7a          CMP      r0,#0x3e8             ;793
000096  d90c              BLS      |L28.178|
000098  bf00              NOP                            ;796
00009a  20ff              MOVS     r0,#0xff              ;796
00009c  6821              LDR      r1,[r4,#0]            ;796
00009e  6248              STR      r0,[r1,#0x24]         ;796
0000a0  bf00              NOP                            ;796
0000a2  2003              MOVS     r0,#3                 ;798
0000a4  7760              STRB     r0,[r4,#0x1d]         ;798
0000a6  bf00              NOP                            ;801
0000a8  2000              MOVS     r0,#0                 ;801
0000aa  7720              STRB     r0,[r4,#0x1c]         ;801
0000ac  bf00              NOP                            ;801
0000ae  2003              MOVS     r0,#3                 ;803
0000b0  e7b1              B        |L28.22|
                  |L28.178|
0000b2  6820              LDR      r0,[r4,#0]            ;791
0000b4  68c0              LDR      r0,[r0,#0xc]          ;791
0000b6  f3c00080          UBFX     r0,r0,#2,#1           ;791
0000ba  2800              CMP      r0,#0                 ;791
0000bc  d0e6              BEQ      |L28.140|
0000be  6820              LDR      r0,[r4,#0]            ;808
0000c0  6880              LDR      r0,[r0,#8]            ;808
0000c2  f0200007          BIC      r0,r0,#7              ;808
0000c6  6821              LDR      r1,[r4,#0]            ;808
0000c8  6088              STR      r0,[r1,#8]            ;808
0000ca  6820              LDR      r0,[r4,#0]            ;811
0000cc  6880              LDR      r0,[r0,#8]            ;811
0000ce  4330              ORRS     r0,r0,r6              ;811
0000d0  6821              LDR      r1,[r4,#0]            ;811
0000d2  6088              STR      r0,[r1,#8]            ;811
0000d4  6820              LDR      r0,[r4,#0]            ;814
0000d6  6145              STR      r5,[r0,#0x14]         ;814
0000d8  6820              LDR      r0,[r4,#0]            ;817
0000da  6880              LDR      r0,[r0,#8]            ;817
0000dc  f4406080          ORR      r0,r0,#0x400          ;817
0000e0  6821              LDR      r1,[r4,#0]            ;817
0000e2  6088              STR      r0,[r1,#8]            ;817
0000e4  bf00              NOP                            ;820
0000e6  20ff              MOVS     r0,#0xff              ;820
0000e8  6821              LDR      r1,[r4,#0]            ;820
0000ea  6248              STR      r0,[r1,#0x24]         ;820
0000ec  bf00              NOP                            ;820
0000ee  2001              MOVS     r0,#1                 ;822
0000f0  7760              STRB     r0,[r4,#0x1d]         ;822
0000f2  bf00              NOP                            ;825
0000f4  2000              MOVS     r0,#0                 ;825
0000f6  7720              STRB     r0,[r4,#0x1c]         ;825
0000f8  bf00              NOP                            ;825
0000fa  bf00              NOP                            ;827
0000fc  e78b              B        |L28.22|
;;;829    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetWakeUpTimer_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetWakeUpTimer_IT PROC
;;;837      */
;;;838    HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
000000  b518              PUSH     {r3,r4,lr}
;;;839    {
000002  4603              MOV      r3,r0
;;;840      __IO uint32_t count;
;;;841    
;;;842      /* Check the parameters */
;;;843      assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
;;;844      assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
;;;845    
;;;846      /* Process Locked */
;;;847      __HAL_LOCK(hrtc);
000004  bf00              NOP      
000006  7f18              LDRB     r0,[r3,#0x1c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L29.16|
00000c  2002              MOVS     r0,#2
                  |L29.14|
;;;848    
;;;849      hrtc->State = HAL_RTC_STATE_BUSY;
;;;850    
;;;851      /* Disable the write protection for RTC registers */
;;;852      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;853    
;;;854      /* Check RTC WUTWF flag is reset only when wake up timer enabled */
;;;855      if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
;;;856      {
;;;857        /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
;;;858        count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U);
;;;859        do
;;;860        {
;;;861          if(count-- == 0U)
;;;862          {
;;;863            /* Enable the write protection for RTC registers */
;;;864            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;865    
;;;866            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;867    
;;;868            /* Process Unlocked */
;;;869            __HAL_UNLOCK(hrtc);
;;;870    
;;;871            return HAL_TIMEOUT;
;;;872          }
;;;873        }
;;;874        while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET);
;;;875      }
;;;876    
;;;877      __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
;;;878    
;;;879      /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;880      count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U);
;;;881      do
;;;882      {
;;;883        if(count-- == 0U)
;;;884        {
;;;885          /* Enable the write protection for RTC registers */
;;;886          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;887    
;;;888          hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;889    
;;;890          /* Process Unlocked */
;;;891          __HAL_UNLOCK(hrtc);
;;;892    
;;;893          return HAL_TIMEOUT;
;;;894        }
;;;895      }
;;;896      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET);
;;;897    
;;;898      /* Configure the Wake-up Timer counter */
;;;899      hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
;;;900    
;;;901      /* Clear the Wake-up Timer clock source bits in CR register */
;;;902      hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
;;;903    
;;;904      /* Configure the clock source */
;;;905      hrtc->Instance->CR |= (uint32_t)WakeUpClock;
;;;906    
;;;907      /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
;;;908      __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
;;;909    
;;;910      EXTI->RTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT;
;;;911    
;;;912      /* Clear RTC Wake Up timer Flag */
;;;913      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
;;;914    
;;;915      /* Configure the Interrupt in the RTC_CR register */
;;;916      __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc,RTC_IT_WUT);
;;;917    
;;;918      /* Enable the Wake-up Timer */
;;;919      __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
;;;920    
;;;921      /* Enable the write protection for RTC registers */
;;;922      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;923    
;;;924      hrtc->State = HAL_RTC_STATE_READY;
;;;925    
;;;926      /* Process Unlocked */
;;;927      __HAL_UNLOCK(hrtc);
;;;928    
;;;929      return HAL_OK;
;;;930    }
00000e  bd18              POP      {r3,r4,pc}
                  |L29.16|
000010  2001              MOVS     r0,#1                 ;847
000012  7718              STRB     r0,[r3,#0x1c]         ;847
000014  bf00              NOP                            ;847
000016  2002              MOVS     r0,#2                 ;849
000018  7758              STRB     r0,[r3,#0x1d]         ;849
00001a  bf00              NOP                            ;852
00001c  20ca              MOVS     r0,#0xca              ;852
00001e  681c              LDR      r4,[r3,#0]            ;852
000020  6260              STR      r0,[r4,#0x24]         ;852
000022  2053              MOVS     r0,#0x53              ;852
000024  681c              LDR      r4,[r3,#0]            ;852
000026  6260              STR      r0,[r4,#0x24]         ;852
000028  bf00              NOP                            ;852
00002a  6818              LDR      r0,[r3,#0]            ;855
00002c  6880              LDR      r0,[r0,#8]            ;855
00002e  f4006080          AND      r0,r0,#0x400          ;855
000032  b300              CBZ      r0,|L29.118|
000034  4841              LDR      r0,|L29.316|
000036  6800              LDR      r0,[r0,#0]            ;858  ; SystemCoreClock
000038  0940              LSRS     r0,r0,#5              ;858
00003a  f44f747a          MOV      r4,#0x3e8             ;858
00003e  fbb0f0f4          UDIV     r0,r0,r4              ;858
000042  4360              MULS     r0,r4,r0              ;858
000044  9000              STR      r0,[sp,#0]            ;858
000046  bf00              NOP                            ;859
                  |L29.72|
000048  9800              LDR      r0,[sp,#0]            ;861
00004a  1e44              SUBS     r4,r0,#1              ;861
00004c  9400              STR      r4,[sp,#0]            ;861
00004e  b960              CBNZ     r0,|L29.106|
000050  bf00              NOP                            ;864
000052  20ff              MOVS     r0,#0xff              ;864
000054  681c              LDR      r4,[r3,#0]            ;864
000056  6260              STR      r0,[r4,#0x24]         ;864
000058  bf00              NOP                            ;864
00005a  2003              MOVS     r0,#3                 ;866
00005c  7758              STRB     r0,[r3,#0x1d]         ;866
00005e  bf00              NOP                            ;869
000060  2000              MOVS     r0,#0                 ;869
000062  7718              STRB     r0,[r3,#0x1c]         ;869
000064  bf00              NOP                            ;869
000066  2003              MOVS     r0,#3                 ;871
000068  e7d1              B        |L29.14|
                  |L29.106|
00006a  6818              LDR      r0,[r3,#0]            ;874
00006c  68c0              LDR      r0,[r0,#0xc]          ;874
00006e  f3c00080          UBFX     r0,r0,#2,#1           ;874
000072  2800              CMP      r0,#0                 ;874
000074  d1e8              BNE      |L29.72|
                  |L29.118|
000076  6818              LDR      r0,[r3,#0]            ;877
000078  6880              LDR      r0,[r0,#8]            ;877
00007a  f4206080          BIC      r0,r0,#0x400          ;877
00007e  681c              LDR      r4,[r3,#0]            ;877
000080  60a0              STR      r0,[r4,#8]            ;877
000082  482e              LDR      r0,|L29.316|
000084  6800              LDR      r0,[r0,#0]            ;880  ; SystemCoreClock
000086  0940              LSRS     r0,r0,#5              ;880
000088  f44f747a          MOV      r4,#0x3e8             ;880
00008c  fbb0f0f4          UDIV     r0,r0,r4              ;880
000090  4360              MULS     r0,r4,r0              ;880
000092  9000              STR      r0,[sp,#0]            ;880
000094  bf00              NOP                            ;881
                  |L29.150|
000096  9800              LDR      r0,[sp,#0]            ;883
000098  1e44              SUBS     r4,r0,#1              ;883
00009a  9400              STR      r4,[sp,#0]            ;883
00009c  b960              CBNZ     r0,|L29.184|
00009e  bf00              NOP                            ;886
0000a0  20ff              MOVS     r0,#0xff              ;886
0000a2  681c              LDR      r4,[r3,#0]            ;886
0000a4  6260              STR      r0,[r4,#0x24]         ;886
0000a6  bf00              NOP                            ;886
0000a8  2003              MOVS     r0,#3                 ;888
0000aa  7758              STRB     r0,[r3,#0x1d]         ;888
0000ac  bf00              NOP                            ;891
0000ae  2000              MOVS     r0,#0                 ;891
0000b0  7718              STRB     r0,[r3,#0x1c]         ;891
0000b2  bf00              NOP                            ;891
0000b4  2003              MOVS     r0,#3                 ;893
0000b6  e7aa              B        |L29.14|
                  |L29.184|
0000b8  6818              LDR      r0,[r3,#0]            ;896
0000ba  68c0              LDR      r0,[r0,#0xc]          ;896
0000bc  f3c00080          UBFX     r0,r0,#2,#1           ;896
0000c0  2800              CMP      r0,#0                 ;896
0000c2  d0e8              BEQ      |L29.150|
0000c4  6818              LDR      r0,[r3,#0]            ;899
0000c6  6141              STR      r1,[r0,#0x14]         ;899
0000c8  6818              LDR      r0,[r3,#0]            ;902
0000ca  6880              LDR      r0,[r0,#8]            ;902
0000cc  f0200007          BIC      r0,r0,#7              ;902
0000d0  681c              LDR      r4,[r3,#0]            ;902
0000d2  60a0              STR      r0,[r4,#8]            ;902
0000d4  6818              LDR      r0,[r3,#0]            ;905
0000d6  6880              LDR      r0,[r0,#8]            ;905
0000d8  4310              ORRS     r0,r0,r2              ;905
0000da  681c              LDR      r4,[r3,#0]            ;905
0000dc  60a0              STR      r0,[r4,#8]            ;905
0000de  4818              LDR      r0,|L29.320|
0000e0  6800              LDR      r0,[r0,#0]            ;908
0000e2  f4400080          ORR      r0,r0,#0x400000       ;908
0000e6  4c16              LDR      r4,|L29.320|
0000e8  6020              STR      r0,[r4,#0]            ;908
0000ea  4815              LDR      r0,|L29.320|
0000ec  3008              ADDS     r0,r0,#8              ;910
0000ee  6800              LDR      r0,[r0,#0]            ;910
0000f0  f4400080          ORR      r0,r0,#0x400000       ;910
0000f4  4c12              LDR      r4,|L29.320|
0000f6  3408              ADDS     r4,r4,#8              ;910
0000f8  6020              STR      r0,[r4,#0]            ;910
0000fa  6818              LDR      r0,[r3,#0]            ;913
0000fc  68c0              LDR      r0,[r0,#0xc]          ;913
0000fe  f0000080          AND      r0,r0,#0x80           ;913
000102  f4606090          ORN      r0,r0,#0x480          ;913
000106  681c              LDR      r4,[r3,#0]            ;913
000108  60e0              STR      r0,[r4,#0xc]          ;913
00010a  6818              LDR      r0,[r3,#0]            ;916
00010c  6880              LDR      r0,[r0,#8]            ;916
00010e  f4404080          ORR      r0,r0,#0x4000         ;916
000112  681c              LDR      r4,[r3,#0]            ;916
000114  60a0              STR      r0,[r4,#8]            ;916
000116  6818              LDR      r0,[r3,#0]            ;919
000118  6880              LDR      r0,[r0,#8]            ;919
00011a  f4406080          ORR      r0,r0,#0x400          ;919
00011e  681c              LDR      r4,[r3,#0]            ;919
000120  60a0              STR      r0,[r4,#8]            ;919
000122  bf00              NOP                            ;922
000124  20ff              MOVS     r0,#0xff              ;922
000126  681c              LDR      r4,[r3,#0]            ;922
000128  6260              STR      r0,[r4,#0x24]         ;922
00012a  bf00              NOP                            ;922
00012c  2001              MOVS     r0,#1                 ;924
00012e  7758              STRB     r0,[r3,#0x1d]         ;924
000130  bf00              NOP                            ;927
000132  2000              MOVS     r0,#0                 ;927
000134  7718              STRB     r0,[r3,#0x1c]         ;927
000136  bf00              NOP                            ;927
000138  bf00              NOP                            ;929
00013a  e768              B        |L29.14|
;;;931    
                          ENDP

                  |L29.316|
                          DCD      SystemCoreClock
                  |L29.320|
                          DCD      0x40013c00

                          AREA ||i.HAL_RTCEx_Tamper1EventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_Tamper1EventCallback PROC
;;;581      */
;;;582    __weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;583    {
;;;584      /* Prevent unused argument(s) compilation warning */
;;;585      UNUSED(hrtc);
;;;586      /* NOTE : This function Should not be modified, when the callback is needed,
;;;587                the HAL_RTC_Tamper1EventCallback could be implemented in the user file
;;;588       */
;;;589    }
;;;590    
                          ENDP


                          AREA ||i.HAL_RTCEx_Tamper2EventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_Tamper2EventCallback PROC
;;;596      */
;;;597    __weak void HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;598    {
;;;599      /* Prevent unused argument(s) compilation warning */
;;;600      UNUSED(hrtc);
;;;601      /* NOTE : This function Should not be modified, when the callback is needed,
;;;602                the HAL_RTC_Tamper2EventCallback could be implemented in the user file
;;;603       */
;;;604    }
;;;605    
                          ENDP


                          AREA ||i.HAL_RTCEx_TamperTimeStampIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_TamperTimeStampIRQHandler PROC
;;;499      */
;;;500    void HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;501    {
000002  4604              MOV      r4,r0
;;;502      if(__HAL_RTC_TIMESTAMP_GET_IT(hrtc, RTC_IT_TS))
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f3c020c0          UBFX     r0,r0,#11,#1
00000c  b178              CBZ      r0,|L32.46|
;;;503      {
;;;504        /* Get the status of the Interrupt */
;;;505        if((uint32_t)(hrtc->Instance->CR & RTC_IT_TS) != (uint32_t)RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  6880              LDR      r0,[r0,#8]
000012  f4004000          AND      r0,r0,#0x8000
000016  b150              CBZ      r0,|L32.46|
;;;506        {
;;;507          /* TIMESTAMP callback */
;;;508    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;509          hrtc->TimeStampEventCallback(hrtc);
;;;510    #else
;;;511          HAL_RTCEx_TimeStampEventCallback(hrtc);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_RTCEx_TimeStampEventCallback
;;;512    #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;513    
;;;514          /* Clear the TIMESTAMP interrupt pending bit */
;;;515          __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc,RTC_FLAG_TSF);
00001e  6820              LDR      r0,[r4,#0]
000020  68c0              LDR      r0,[r0,#0xc]
000022  f0000080          AND      r0,r0,#0x80
000026  f4606008          ORN      r0,r0,#0x880
00002a  6821              LDR      r1,[r4,#0]
00002c  60c8              STR      r0,[r1,#0xc]
                  |L32.46|
;;;516        }
;;;517      }
;;;518    
;;;519      /* Get the status of the Interrupt */
;;;520      if(__HAL_RTC_TAMPER_GET_IT(hrtc,RTC_IT_TAMP1))
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f3c03040          UBFX     r0,r0,#13,#1
000036  b178              CBZ      r0,|L32.88|
;;;521      {
;;;522        /* Get the TAMPER Interrupt enable bit and pending bit */
;;;523        if(((hrtc->Instance->TAFCR & (RTC_TAFCR_TAMPIE))) != (uint32_t)RESET)
000038  6820              LDR      r0,[r4,#0]
00003a  6c00              LDR      r0,[r0,#0x40]
00003c  f0000004          AND      r0,r0,#4
000040  b150              CBZ      r0,|L32.88|
;;;524        {
;;;525          /* Tamper callback */
;;;526    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;527          hrtc->Tamper1EventCallback(hrtc);
;;;528    #else
;;;529          HAL_RTCEx_Tamper1EventCallback(hrtc);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_RTCEx_Tamper1EventCallback
;;;530    #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;531    
;;;532          /* Clear the Tamper interrupt pending bit */
;;;533          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
000048  6820              LDR      r0,[r4,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  f0000080          AND      r0,r0,#0x80
000050  f4605002          ORN      r0,r0,#0x2080
000054  6821              LDR      r1,[r4,#0]
000056  60c8              STR      r0,[r1,#0xc]
                  |L32.88|
;;;534        }
;;;535      }
;;;536    
;;;537      /* Get the status of the Interrupt */
;;;538      if(__HAL_RTC_TAMPER_GET_IT(hrtc, RTC_IT_TAMP2))
000058  6820              LDR      r0,[r4,#0]
00005a  68c0              LDR      r0,[r0,#0xc]
00005c  f3c03080          UBFX     r0,r0,#14,#1
000060  b178              CBZ      r0,|L32.130|
;;;539      {
;;;540        /* Get the TAMPER Interrupt enable bit and pending bit */
;;;541        if(((hrtc->Instance->TAFCR & RTC_TAFCR_TAMPIE)) != (uint32_t)RESET)
000062  6820              LDR      r0,[r4,#0]
000064  6c00              LDR      r0,[r0,#0x40]
000066  f0000004          AND      r0,r0,#4
00006a  b150              CBZ      r0,|L32.130|
;;;542        {
;;;543          /* Tamper callback */
;;;544    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;545          hrtc->Tamper2EventCallback(hrtc);
;;;546    #else
;;;547          HAL_RTCEx_Tamper2EventCallback(hrtc);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       HAL_RTCEx_Tamper2EventCallback
;;;548    #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;549    
;;;550          /* Clear the Tamper interrupt pending bit */
;;;551          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  f0000080          AND      r0,r0,#0x80
00007a  f4604081          ORN      r0,r0,#0x4080
00007e  6821              LDR      r1,[r4,#0]
000080  60c8              STR      r0,[r1,#0xc]
                  |L32.130|
;;;552        }
;;;553      }
;;;554      /* Clear the EXTI's Flag for RTC TimeStamp and Tamper */
;;;555      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();
000082  f44f1000          MOV      r0,#0x200000
000086  4902              LDR      r1,|L32.144|
000088  6008              STR      r0,[r1,#0]
;;;556    
;;;557      /* Change RTC state */
;;;558      hrtc->State = HAL_RTC_STATE_READY;
00008a  2001              MOVS     r0,#1
00008c  7760              STRB     r0,[r4,#0x1d]
;;;559    }
00008e  bd10              POP      {r4,pc}
;;;560    
                          ENDP

                  |L32.144|
                          DCD      0x40013c14

                          AREA ||i.HAL_RTCEx_TimeStampEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_TimeStampEventCallback PROC
;;;566      */
;;;567    __weak void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;568    {
;;;569      /* Prevent unused argument(s) compilation warning */
;;;570      UNUSED(hrtc);
;;;571      /* NOTE : This function Should not be modified, when the callback is needed,
;;;572                the HAL_RTC_TimeStampEventCallback could be implemented in the user file
;;;573      */
;;;574    }
;;;575    
                          ENDP


                          AREA ||i.HAL_RTCEx_WakeUpTimerEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_WakeUpTimerEventCallback PROC
;;;1036     */
;;;1037   __weak void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1038   {
;;;1039     /* Prevent unused argument(s) compilation warning */
;;;1040     UNUSED(hrtc);
;;;1041     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1042               the HAL_RTC_WakeUpTimerEventCallback could be implemented in the user file
;;;1043      */
;;;1044   }
;;;1045   
                          ENDP


                          AREA ||i.HAL_RTCEx_WakeUpTimerIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_WakeUpTimerIRQHandler PROC
;;;1004     */
;;;1005   void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;1006   {
000002  4604              MOV      r4,r0
;;;1007     if(__HAL_RTC_WAKEUPTIMER_GET_IT(hrtc, RTC_IT_WUT))
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f3c02080          UBFX     r0,r0,#10,#1
00000c  b178              CBZ      r0,|L35.46|
;;;1008     {
;;;1009       /* Get the status of the Interrupt */
;;;1010       if((uint32_t)(hrtc->Instance->CR & RTC_IT_WUT) != (uint32_t)RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  6880              LDR      r0,[r0,#8]
000012  f4004080          AND      r0,r0,#0x4000
000016  b150              CBZ      r0,|L35.46|
;;;1011       {
;;;1012         /* WAKEUPTIMER callback */
;;;1013   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;1014         hrtc->WakeUpTimerEventCallback(hrtc);
;;;1015   #else
;;;1016         HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_RTCEx_WakeUpTimerEventCallback
;;;1017   #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;1018   
;;;1019         /* Clear the WAKEUPTIMER interrupt pending bit */
;;;1020         __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
00001e  6820              LDR      r0,[r4,#0]
000020  68c0              LDR      r0,[r0,#0xc]
000022  f0000080          AND      r0,r0,#0x80
000026  f4606090          ORN      r0,r0,#0x480
00002a  6821              LDR      r1,[r4,#0]
00002c  60c8              STR      r0,[r1,#0xc]
                  |L35.46|
;;;1021       }
;;;1022     }
;;;1023   
;;;1024     /* Clear the EXTI's line Flag for RTC WakeUpTimer */
;;;1025     __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
00002e  f44f0080          MOV      r0,#0x400000
000032  4902              LDR      r1,|L35.60|
000034  6008              STR      r0,[r1,#0]
;;;1026   
;;;1027     /* Change RTC state */
;;;1028     hrtc->State = HAL_RTC_STATE_READY;
000036  2001              MOVS     r0,#1
000038  7760              STRB     r0,[r4,#0x1d]
;;;1029   }
00003a  bd10              POP      {r4,pc}
;;;1030   
                          ENDP

                  |L35.60|
                          DCD      0x40013c14

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_rtc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____RRX|
#line 587
|__asm___22_stm32f4xx_hal_rtc_ex_c_7fcc3a7e____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
