L 1 "..\Src\main.c"
N/**
N ******************************************************************************
N * @file    main.c
N * @author  MEMS Software Solutions Team
N * @brief   Main program body
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/**
N * @mainpage Documentation for MotionEC package of X-CUBE-MEMS1 Software for
N * X-NUCLEO-IKS01A2 expansion board
N *
N * @image html st_logo.png
N *
N * <b>Introduction</b>
N *
N * MotionEC software is an add-on for the X-CUBE-MEMS1 software and provides
N * E-Compass functionality.
N * The expansion is built on top of STM32Cube software technology that eases
N * portability across different STM32 microcontrollers.
N */
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 52 "..\Src\main.c" 2
N#include "main.h"
L 1 "..\Inc\main.h" 1
N/**
N ******************************************************************************
N * @file    main.h
N * @author  MEMS Software Solutions Team
N * @brief   This file contains definitions for the main.c file
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef MAIN_H
N#define MAIN_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "cube_hal.h"
L 1 "..\Inc\cube_hal.h" 1
N/**
N *******************************************************************************
N * @file    cube_hal.h
N * @author  MEMS Software Solutions Team
N * @brief   Header for cube_hal_f4.c, cube_hal_l0.c, cube_hal_l1.c and cube_hal_l4.c
N *******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ********************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef CUBE_HAL_H
N#define CUBE_HAL_H
N
N/* Includes ------------------------------------------------------------------*/
N#ifdef USE_STM32F4XX_NUCLEO
N#include "stm32f4xx_hal.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal.h
N  * @author  MCD Application Team
N  * @brief   This file contains all the functions prototypes for the HAL 
N  *          module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_H
N#define __STM32F4xx_HAL_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_conf.h"
L 1 "..\Inc\stm32f4xx_hal_conf.h" 1
N/**
N ******************************************************************************
N * @file    stm32f4xx_hal_conf.h
N * @author  MCD Application Team
N * @brief   HAL configuration file
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32F4xx_HAL_CONF_H
N#define STM32F4xx_HAL_CONF_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/* ########################## Module Selection ############################## */
N/**
N * @brief This is the list of modules to be used in the HAL driver
N */
N#define HAL_MODULE_ENABLED
N#define HAL_ADC_MODULE_ENABLED
N/* #define HAL_CAN_MODULE_ENABLED */
N#define HAL_CORTEX_MODULE_ENABLED
N#define HAL_CRC_MODULE_ENABLED
N/* #define HAL_CRYP_MODULE_ENABLED */
N/* #define HAL_DAC_MODULE_ENABLED */
N/* #define HAL_DCMI_MODULE_ENABLED */
N#define HAL_DMA_MODULE_ENABLED
N/* #define HAL_DMA2D_MODULE_ENABLED */
N/* #define HAL_ETH_MODULE_ENABLED */
N#define HAL_FLASH_MODULE_ENABLED
N/* #define HAL_NAND_MODULE_ENABLED */
N/* #define HAL_NOR_MODULE_ENABLED */
N/* #define HAL_PCCARD_MODULE_ENABLED */
N/* #define HAL_SRAM_MODULE_ENABLED */
N/* #define HAL_SDRAM_MODULE_ENABLED */
N/* #define HAL_HASH_MODULE_ENABLED */
N#define HAL_GPIO_MODULE_ENABLED
N#define HAL_I2C_MODULE_ENABLED
N/* #define HAL_I2S_MODULE_ENABLED */
N/* #define HAL_IWDG_MODULE_ENABLED */
N/* #define HAL_LTDC_MODULE_ENABLED */
N#define HAL_PWR_MODULE_ENABLED
N#define HAL_RCC_MODULE_ENABLED
N/* #define HAL_RNG_MODULE_ENABLED */
N#define HAL_RTC_MODULE_ENABLED
N/* #define HAL_SAI_MODULE_ENABLED */
N/* #define HAL_SD_MODULE_ENABLED */
N#define HAL_SPI_MODULE_ENABLED
N#define HAL_TIM_MODULE_ENABLED
N#define HAL_UART_MODULE_ENABLED
N/* #define HAL_USART_MODULE_ENABLED */
N/* #define HAL_IRDA_MODULE_ENABLED */
N/* #define HAL_SMARTCARD_MODULE_ENABLED */
N/* #define HAL_WWDG_MODULE_ENABLED */
N/* #define HAL_PCD_MODULE_ENABLED */
N/* #define HAL_HCD_MODULE_ENABLED */
N
N
N/* ########################## Oscillator Values adaptation #################### */
N/**
N * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
N *        This value is used by the RCC HAL module to compute the system frequency
N *        (when HSE is used as system clock source, directly or through the PLL).
N */
N#if !defined  (HSE_VALUE)
X#if !0L
N#define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
N#endif /* HSE_VALUE */
N
N#if !defined  (HSE_STARTUP_TIMEOUT)
X#if !0L
N#define HSE_STARTUP_TIMEOUT    ((uint32_t)100)   /*!< Time out for HSE start up, in ms */
N#endif /* HSE_STARTUP_TIMEOUT */
N
N/**
N * @brief Internal Multiple Speed oscillator (MSI) default value.
N *        This value is the default MSI range value after Reset.
N */
N#if !defined  (MSI_VALUE)
X#if !0L
N#define MSI_VALUE    ((uint32_t)4000000) /*!< Value of the Internal oscillator in Hz */
N#endif /* MSI_VALUE */
N
N/**
N * @brief Internal High Speed oscillator (HSI) value.
N *        This value is used by the RCC HAL module to compute the system frequency
N *        (when HSI is used as system clock source, directly or through the PLL).
N */
N#if !defined  (HSI_VALUE)
X#if !0L
N#define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz */
N#endif /* HSI_VALUE */
N
N/**
N * @brief Internal Low Speed oscillator (LSI) value.
N */
N#if !defined  (LSI_VALUE)
X#if !0L
N#define LSI_VALUE  ((uint32_t)32000)  /*!< LSI Typical Value in Hz */
N#endif /* LSI_VALUE */                /*!< Value of the Internal Low Speed oscillator in Hz.
N                                           The real value may vary depending on the variations
N                                           in voltage and temperature. */
N/**
N * @brief External Low Speed oscillator (LSE) value.
N */
N#if !defined  (LSE_VALUE)
X#if !0L
N#define LSE_VALUE  ((uint32_t)32768)  /*!< Value of the External Low Speed oscillator in Hz */
N#endif /* LSE_VALUE */
N
N/**
N * @brief Time out for LSE start up value in ms.
N */
N#if !defined  (LSE_STARTUP_TIMEOUT)
X#if !0L
N#define LSE_STARTUP_TIMEOUT    ((uint32_t)5000)   /*!< Time out for LSE start up, in ms */
N#endif /* LSE_STARTUP_TIMEOUT */
N
N/**
N * @brief External clock source for SAI1 peripheral
N *        This value is used by the RCC HAL module to compute the SAI1 & SAI2 clock source
N *        frequency.
N */
N#if !defined  (EXTERNAL_SAI1_CLOCK_VALUE)
X#if !0L
N#define EXTERNAL_SAI1_CLOCK_VALUE    ((uint32_t)48000) /*!< Value of the SAI1 External clock source in Hz */
N#endif /* EXTERNAL_SAI1_CLOCK_VALUE */
N
N/**
N * @brief External clock source for I2S peripheral
N *        This value is used by the I2S HAL module to compute the I2S clock source
N *        frequency, this source is inserted directly through I2S_CKIN pad.
N */
N#if !defined  (EXTERNAL_CLOCK_VALUE)
X#if !0L
N#define EXTERNAL_CLOCK_VALUE    (12288000U) /*!< Value of the External oscillator in Hz */
N#endif /* EXTERNAL_CLOCK_VALUE */
N
N/* Tip: To avoid modifying this file each time you need to use different HSE,
N   ===  you can define the HSE value in your toolchain compiler preprocessor. */
N
N/* ########################### System Configuration ######################### */
N/**
N * @brief This is the HAL system configuration section
N */
N#define  VDD_VALUE                    ((uint32_t)3300U) /*!< Value of VDD in mv */
N#define  TICK_INT_PRIORITY            ((uint32_t)0x0FU) /*!< tick interrupt priority */
N#define  USE_RTOS                     0U
N#define  PREFETCH_ENABLE              0U
N#define  INSTRUCTION_CACHE_ENABLE     1U
N#define  DATA_CACHE_ENABLE            1U
N
N/* ########################## Assert Selection ############################## */
N/**
N * @brief Uncomment the line below to expanse the "assert_param" macro in the
N *        HAL drivers code
N */
N/* #define USE_FULL_ASSERT            1U */
N
N/* ################## SPI peripheral configuration ########################## */
N
N/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
N * Activated: CRC code is present inside driver
N * Deactivated: CRC code cleaned from driver
N */
N
N#define USE_SPI_CRC                   1U
N
N/* Includes ------------------------------------------------------------------*/
N/**
N * @brief Include module's header file
N */
N
N#ifdef HAL_RCC_MODULE_ENABLED
N#include "stm32f4xx_hal_rcc.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_rcc.h
N  * @author  MCD Application Team
N  * @brief   Header file of RCC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_RCC_H
N#define __STM32F4xx_HAL_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_def.h
N  * @author  MCD Application Team
N  * @brief   This file contains HAL common defines, enumeration, macros and 
N  *          structures definitions. 
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_DEF
N#define __STM32F4xx_HAL_DEF
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
L 1 "..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS STM32F4xx Device Peripheral Access Layer Header File.
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The STM32F4xx device used in the target application
N  *              - To use or not the peripherals drivers in application code(i.e. 
N  *                code will be based on direct access to peripherals registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_HAL_DRIVER"
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f4xx
N  * @{
N  */
N    
N#ifndef __STM32F4xx_H
N#define __STM32F4xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N   
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/**
N  * @brief STM32 Family
N  */
N#if !defined  (STM32F4)
X#if !0L
N#define STM32F4
N#endif /* STM32F4 */
N
N/* Uncomment the line below according to the target STM32 device used in your
N   application 
N  */
N#if !defined (STM32F405xx) && !defined (STM32F415xx) && !defined (STM32F407xx) && !defined (STM32F417xx) && \
N    !defined (STM32F427xx) && !defined (STM32F437xx) && !defined (STM32F429xx) && !defined (STM32F439xx) && \
N    !defined (STM32F401xC) && !defined (STM32F401xE) && !defined (STM32F410Tx) && !defined (STM32F410Cx) && \
N    !defined (STM32F410Rx) && !defined (STM32F411xE) && !defined (STM32F446xx) && !defined (STM32F469xx) && \
N    !defined (STM32F479xx) && !defined (STM32F412Cx) && !defined (STM32F412Rx) && !defined (STM32F412Vx) && \
N    !defined (STM32F412Zx) && !defined (STM32F413xx) && !defined (STM32F423xx)
X#if !0L && !0L && !0L && !0L &&     !0L && !0L && !0L && !0L &&     !0L && !1L && !0L && !0L &&     !0L && !0L && !0L && !0L &&     !0L && !0L && !0L && !0L &&     !0L && !0L && !0L
S  /* #define STM32F405xx */   /*!< STM32F405RG, STM32F405VG and STM32F405ZG Devices */
S  /* #define STM32F415xx */   /*!< STM32F415RG, STM32F415VG and STM32F415ZG Devices */
S  /* #define STM32F407xx */   /*!< STM32F407VG, STM32F407VE, STM32F407ZG, STM32F407ZE, STM32F407IG  and STM32F407IE Devices */
S  /* #define STM32F417xx */   /*!< STM32F417VG, STM32F417VE, STM32F417ZG, STM32F417ZE, STM32F417IG and STM32F417IE Devices */
S  /* #define STM32F427xx */   /*!< STM32F427VG, STM32F427VI, STM32F427ZG, STM32F427ZI, STM32F427IG and STM32F427II Devices */
S  /* #define STM32F437xx */   /*!< STM32F437VG, STM32F437VI, STM32F437ZG, STM32F437ZI, STM32F437IG and STM32F437II Devices */
S  /* #define STM32F429xx */   /*!< STM32F429VG, STM32F429VI, STM32F429ZG, STM32F429ZI, STM32F429BG, STM32F429BI, STM32F429NG, 
S                                   STM32F439NI, STM32F429IG  and STM32F429II Devices */
S  /* #define STM32F439xx */   /*!< STM32F439VG, STM32F439VI, STM32F439ZG, STM32F439ZI, STM32F439BG, STM32F439BI, STM32F439NG, 
S                                   STM32F439NI, STM32F439IG and STM32F439II Devices */
S  /* #define STM32F401xC */   /*!< STM32F401CB, STM32F401CC, STM32F401RB, STM32F401RC, STM32F401VB and STM32F401VC Devices */
S  /* #define STM32F401xE */   /*!< STM32F401CD, STM32F401RD, STM32F401VD, STM32F401CE, STM32F401RE and STM32F401VE Devices */
S  /* #define STM32F410Tx */   /*!< STM32F410T8 and STM32F410TB Devices */
S  /* #define STM32F410Cx */   /*!< STM32F410C8 and STM32F410CB Devices */
S  /* #define STM32F410Rx */   /*!< STM32F410R8 and STM32F410RB Devices */
S  /* #define STM32F411xE */   /*!< STM32F411CC, STM32F411RC, STM32F411VC, STM32F411CE, STM32F411RE and STM32F411VE Devices */
S  /* #define STM32F446xx */   /*!< STM32F446MC, STM32F446ME, STM32F446RC, STM32F446RE, STM32F446VC, STM32F446VE, STM32F446ZC, 
S                                   and STM32F446ZE Devices */
S  /* #define STM32F469xx */   /*!< STM32F469AI, STM32F469II, STM32F469BI, STM32F469NI, STM32F469AG, STM32F469IG, STM32F469BG, 
S                                   STM32F469NG, STM32F469AE, STM32F469IE, STM32F469BE and STM32F469NE Devices */
S  /* #define STM32F479xx */   /*!< STM32F479AI, STM32F479II, STM32F479BI, STM32F479NI, STM32F479AG, STM32F479IG, STM32F479BG 
S                                   and STM32F479NG Devices */
S  /* #define STM32F412Cx */   /*!< STM32F412CEU and STM32F412CGU Devices */
S  /* #define STM32F412Zx */   /*!< STM32F412ZET, STM32F412ZGT, STM32F412ZEJ and STM32F412ZGJ Devices */
S  /* #define STM32F412Vx */   /*!< STM32F412VET, STM32F412VGT, STM32F412VEH and STM32F412VGH Devices */
S  /* #define STM32F412Rx */   /*!< STM32F412RET, STM32F412RGT, STM32F412REY and STM32F412RGY Devices */
S  /* #define STM32F413xx */   /*!< STM32F413CH, STM32F413MH, STM32F413RH, STM32F413VH, STM32F413ZH, STM32F413CG, STM32F413MG,
S                                   STM32F413RG, STM32F413VG and STM32F413ZG Devices */
S  /* #define STM32F423xx */   /*!< STM32F423CH, STM32F423RH, STM32F423VH and STM32F423ZH Devices */
N#endif
N   
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N#if !defined  (USE_HAL_DRIVER)
X#if !1L
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_HAL_DRIVER */
N#endif /* USE_HAL_DRIVER */
N
N/**
N  * @brief CMSIS version number V2.6.3
N  */
N#define __STM32F4xx_CMSIS_VERSION_MAIN   (0x02U) /*!< [31:24] main version */
N#define __STM32F4xx_CMSIS_VERSION_SUB1   (0x06U) /*!< [23:16] sub1 version */
N#define __STM32F4xx_CMSIS_VERSION_SUB2   (0x03U) /*!< [15:8]  sub2 version */
N#define __STM32F4xx_CMSIS_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */
N#define __STM32F4xx_CMSIS_VERSION        ((__STM32F4xx_CMSIS_VERSION_MAIN << 24)\
N                                         |(__STM32F4xx_CMSIS_VERSION_SUB1 << 16)\
N                                         |(__STM32F4xx_CMSIS_VERSION_SUB2 << 8 )\
N                                         |(__STM32F4xx_CMSIS_VERSION))
X#define __STM32F4xx_CMSIS_VERSION        ((__STM32F4xx_CMSIS_VERSION_MAIN << 24)                                         |(__STM32F4xx_CMSIS_VERSION_SUB1 << 16)                                         |(__STM32F4xx_CMSIS_VERSION_SUB2 << 8 )                                         |(__STM32F4xx_CMSIS_VERSION))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Device_Included
N  * @{
N  */
N
N#if defined(STM32F405xx)
X#if 0L
S  #include "stm32f405xx.h"
S#elif defined(STM32F415xx)
X#elif 0L
S  #include "stm32f415xx.h"
S#elif defined(STM32F407xx)
X#elif 0L
S  #include "stm32f407xx.h"
S#elif defined(STM32F417xx)
X#elif 0L
S  #include "stm32f417xx.h"
S#elif defined(STM32F427xx)
X#elif 0L
S  #include "stm32f427xx.h"
S#elif defined(STM32F437xx)
X#elif 0L
S  #include "stm32f437xx.h"
S#elif defined(STM32F429xx)
X#elif 0L
S  #include "stm32f429xx.h"
S#elif defined(STM32F439xx)
X#elif 0L
S  #include "stm32f439xx.h"
S#elif defined(STM32F401xC)
X#elif 0L
S  #include "stm32f401xc.h"
N#elif defined(STM32F401xE)
X#elif 1L
N  #include "stm32f401xe.h"
L 1 "..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f401xe.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f401xe.h
N  * @author  MCD Application Team
N  * @brief   CMSIS STM32F401xE Device Peripheral Access Layer Header File.
N  *
N  *          This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - peripherals registers declarations and bits definition
N  *           - Macros to access peripherals registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS_Device
N  * @{
N  */
N
N/** @addtogroup stm32f401xe
N  * @{
N  */
N    
N#ifndef __STM32F401xE_H
N#define __STM32F401xE_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N  * @brief Configuration of the Cortex-M4 Processor and Core Peripherals 
N  */
N#define __CM4_REV                 0x0001U  /*!< Core revision r0p1                            */
N#define __MPU_PRESENT             1U       /*!< STM32F4XX provides an MPU                     */
N#define __NVIC_PRIO_BITS          4U       /*!< STM32F4XX uses 4 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig    0U       /*!< Set to 1 if different SysTick Config is used  */
N#define __FPU_PRESENT             1U       /*!< FPU present                                   */
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_interrupt_number_definition
N  * @{
N  */
N
N/**
N * @brief STM32F4XX Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
Ntypedef enum
N{
N/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
N  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
N  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
N  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
N  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
N/******  STM32 specific Interrupt Numbers **********************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
N  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
N  TAMP_STAMP_IRQn             = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line             */
N  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line                        */
N  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
N  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
N  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
N  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
N  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                              */
N  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
N  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
N  DMA1_Stream0_IRQn           = 11,     /*!< DMA1 Stream 0 global Interrupt                                    */
N  DMA1_Stream1_IRQn           = 12,     /*!< DMA1 Stream 1 global Interrupt                                    */
N  DMA1_Stream2_IRQn           = 13,     /*!< DMA1 Stream 2 global Interrupt                                    */
N  DMA1_Stream3_IRQn           = 14,     /*!< DMA1 Stream 3 global Interrupt                                    */
N  DMA1_Stream4_IRQn           = 15,     /*!< DMA1 Stream 4 global Interrupt                                    */
N  DMA1_Stream5_IRQn           = 16,     /*!< DMA1 Stream 5 global Interrupt                                    */
N  DMA1_Stream6_IRQn           = 17,     /*!< DMA1 Stream 6 global Interrupt                                    */
N  ADC_IRQn                    = 18,     /*!< ADC1, ADC2 and ADC3 global Interrupts                             */
N  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
N  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
N  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
N  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
N  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
N  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
N  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
N  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
N  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
N  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
N  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
N  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
N  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
N  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
N  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
N  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
N  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
N  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
N  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
N  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
N  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
N  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
N  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
N  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
N  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
N  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
N  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
N  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
N  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
N  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
N  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
N  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
N  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
N  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
N  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
N  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
N  SPI4_IRQn                   = 84      /*!< SPI4 global Interrupt                                              */
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm4.h"             /* Cortex-M4 processor and core peripherals */
L 1 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cm4.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x04U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1U)
X    #if (1U == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\..\..\..\..\Drivers\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060750 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x04U) == 0x04U) || ((0x04U) == 0x07U)
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1U == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1U == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060750 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x04U) >= 0x04U)   
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 211 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cm4.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 212 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cm4.h" 2
N#include "core_cmSimd.h"                 /* Compiler specific SIMD Intrinsics */
L 1 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 213 "..\..\..\..\..\..\Drivers\CMSIS\Include\core_cm4.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1U)
X#if (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#if (__FPU_PRESENT == 1U)
X#if (1U == 1U)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 4U)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 4U)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 4U)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 4U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4U)) ? (uint32_t)(4U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4U)) ? (uint32_t)(4U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 4U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 157 "..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f401xe.h" 2
N#include "system_stm32f4xx.h"
L 1 "..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\system_stm32f4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32f4xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS Cortex-M4 Device System Source File for STM32F4xx devices.       
N  ******************************************************************************  
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f4xx_system
N  * @{
N  */  
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32F4XX_H
N#define __SYSTEM_STM32F4XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/** @addtogroup STM32F4xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32F4xx_System_Exported_types
N  * @{
N  */
N  /* This variable is updated in three ways:
N      1) by calling CMSIS function SystemCoreClockUpdate()
N      2) by calling HAL API function HAL_RCC_GetSysClockFreq()
N      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency 
N         Note: If you use this function to configure the system clock; then there
N               is no need to call the 2 first functions listed above, since SystemCoreClock
N               variable is updated automatically.
N  */
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
Nextern const uint8_t  AHBPrescTable[16];    /*!< AHB prescalers table values */
Nextern const uint8_t  APBPrescTable[8];     /*!< APB prescalers table values */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Functions
N  * @{
N  */
N  
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__SYSTEM_STM32F4XX_H */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 158 "..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f401xe.h" 2
N#include <stdint.h>
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t SR;     /*!< ADC status register,                         Address offset: 0x00 */
X  volatile uint32_t SR;      
N  __IO uint32_t CR1;    /*!< ADC control register 1,                      Address offset: 0x04 */
X  volatile uint32_t CR1;     
N  __IO uint32_t CR2;    /*!< ADC control register 2,                      Address offset: 0x08 */
X  volatile uint32_t CR2;     
N  __IO uint32_t SMPR1;  /*!< ADC sample time register 1,                  Address offset: 0x0C */
X  volatile uint32_t SMPR1;   
N  __IO uint32_t SMPR2;  /*!< ADC sample time register 2,                  Address offset: 0x10 */
X  volatile uint32_t SMPR2;   
N  __IO uint32_t JOFR1;  /*!< ADC injected channel data offset register 1, Address offset: 0x14 */
X  volatile uint32_t JOFR1;   
N  __IO uint32_t JOFR2;  /*!< ADC injected channel data offset register 2, Address offset: 0x18 */
X  volatile uint32_t JOFR2;   
N  __IO uint32_t JOFR3;  /*!< ADC injected channel data offset register 3, Address offset: 0x1C */
X  volatile uint32_t JOFR3;   
N  __IO uint32_t JOFR4;  /*!< ADC injected channel data offset register 4, Address offset: 0x20 */
X  volatile uint32_t JOFR4;   
N  __IO uint32_t HTR;    /*!< ADC watchdog higher threshold register,      Address offset: 0x24 */
X  volatile uint32_t HTR;     
N  __IO uint32_t LTR;    /*!< ADC watchdog lower threshold register,       Address offset: 0x28 */
X  volatile uint32_t LTR;     
N  __IO uint32_t SQR1;   /*!< ADC regular sequence register 1,             Address offset: 0x2C */
X  volatile uint32_t SQR1;    
N  __IO uint32_t SQR2;   /*!< ADC regular sequence register 2,             Address offset: 0x30 */
X  volatile uint32_t SQR2;    
N  __IO uint32_t SQR3;   /*!< ADC regular sequence register 3,             Address offset: 0x34 */
X  volatile uint32_t SQR3;    
N  __IO uint32_t JSQR;   /*!< ADC injected sequence register,              Address offset: 0x38*/
X  volatile uint32_t JSQR;    
N  __IO uint32_t JDR1;   /*!< ADC injected data register 1,                Address offset: 0x3C */
X  volatile uint32_t JDR1;    
N  __IO uint32_t JDR2;   /*!< ADC injected data register 2,                Address offset: 0x40 */
X  volatile uint32_t JDR2;    
N  __IO uint32_t JDR3;   /*!< ADC injected data register 3,                Address offset: 0x44 */
X  volatile uint32_t JDR3;    
N  __IO uint32_t JDR4;   /*!< ADC injected data register 4,                Address offset: 0x48 */
X  volatile uint32_t JDR4;    
N  __IO uint32_t DR;     /*!< ADC regular data register,                   Address offset: 0x4C */
X  volatile uint32_t DR;      
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSR;    /*!< ADC Common status register,                  Address offset: ADC1 base address + 0x300 */
X  volatile uint32_t CSR;     
N  __IO uint32_t CCR;    /*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 */
X  volatile uint32_t CCR;     
N  __IO uint32_t CDR;    /*!< ADC common regular data register for dual
X  volatile uint32_t CDR;    
N                             AND triple modes,                            Address offset: ADC1 base address + 0x308 */
N} ADC_Common_TypeDef;
N
N/** 
N  * @brief CRC calculation unit 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;         /*!< CRC Data register,             Address offset: 0x00 */
X  volatile uint32_t DR;          
N  __IO uint8_t  IDR;        /*!< CRC Independent data register, Address offset: 0x04 */
X  volatile uint8_t  IDR;         
N  uint8_t       RESERVED0;  /*!< Reserved, 0x05                                      */
N  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                      */
N  __IO uint32_t CR;         /*!< CRC Control register,          Address offset: 0x08 */
X  volatile uint32_t CR;          
N} CRC_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;  /*!< MCU device ID code,               Address offset: 0x00 */
X  volatile uint32_t IDCODE;   
N  __IO uint32_t CR;      /*!< Debug MCU configuration register, Address offset: 0x04 */
X  volatile uint32_t CR;       
N  __IO uint32_t APB1FZ;  /*!< Debug MCU APB1 freeze register,   Address offset: 0x08 */
X  volatile uint32_t APB1FZ;   
N  __IO uint32_t APB2FZ;  /*!< Debug MCU APB2 freeze register,   Address offset: 0x0C */
X  volatile uint32_t APB2FZ;   
N}DBGMCU_TypeDef;
N
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;     /*!< DMA stream x configuration register      */
X  volatile uint32_t CR;      
N  __IO uint32_t NDTR;   /*!< DMA stream x number of data register     */
X  volatile uint32_t NDTR;    
N  __IO uint32_t PAR;    /*!< DMA stream x peripheral address register */
X  volatile uint32_t PAR;     
N  __IO uint32_t M0AR;   /*!< DMA stream x memory 0 address register   */
X  volatile uint32_t M0AR;    
N  __IO uint32_t M1AR;   /*!< DMA stream x memory 1 address register   */
X  volatile uint32_t M1AR;    
N  __IO uint32_t FCR;    /*!< DMA stream x FIFO control register       */
X  volatile uint32_t FCR;     
N} DMA_Stream_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t LISR;   /*!< DMA low interrupt status register,      Address offset: 0x00 */
X  volatile uint32_t LISR;    
N  __IO uint32_t HISR;   /*!< DMA high interrupt status register,     Address offset: 0x04 */
X  volatile uint32_t HISR;    
N  __IO uint32_t LIFCR;  /*!< DMA low interrupt flag clear register,  Address offset: 0x08 */
X  volatile uint32_t LIFCR;   
N  __IO uint32_t HIFCR;  /*!< DMA high interrupt flag clear register, Address offset: 0x0C */
X  volatile uint32_t HIFCR;   
N} DMA_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;    /*!< EXTI Interrupt mask register,            Address offset: 0x00 */
X  volatile uint32_t IMR;     
N  __IO uint32_t EMR;    /*!< EXTI Event mask register,                Address offset: 0x04 */
X  volatile uint32_t EMR;     
N  __IO uint32_t RTSR;   /*!< EXTI Rising trigger selection register,  Address offset: 0x08 */
X  volatile uint32_t RTSR;    
N  __IO uint32_t FTSR;   /*!< EXTI Falling trigger selection register, Address offset: 0x0C */
X  volatile uint32_t FTSR;    
N  __IO uint32_t SWIER;  /*!< EXTI Software interrupt event register,  Address offset: 0x10 */
X  volatile uint32_t SWIER;   
N  __IO uint32_t PR;     /*!< EXTI Pending register,                   Address offset: 0x14 */
X  volatile uint32_t PR;      
N} EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ACR;      /*!< FLASH access control register,   Address offset: 0x00 */
X  volatile uint32_t ACR;       
N  __IO uint32_t KEYR;     /*!< FLASH key register,              Address offset: 0x04 */
X  volatile uint32_t KEYR;      
N  __IO uint32_t OPTKEYR;  /*!< FLASH option key register,       Address offset: 0x08 */
X  volatile uint32_t OPTKEYR;   
N  __IO uint32_t SR;       /*!< FLASH status register,           Address offset: 0x0C */
X  volatile uint32_t SR;        
N  __IO uint32_t CR;       /*!< FLASH control register,          Address offset: 0x10 */
X  volatile uint32_t CR;        
N  __IO uint32_t OPTCR;    /*!< FLASH option control register ,  Address offset: 0x14 */
X  volatile uint32_t OPTCR;     
N  __IO uint32_t OPTCR1;   /*!< FLASH option control register 1, Address offset: 0x18 */
X  volatile uint32_t OPTCR1;    
N} FLASH_TypeDef;
N
N/** 
N  * @brief General Purpose I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
X  volatile uint32_t MODER;     
N  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
X  volatile uint32_t OTYPER;    
N  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
X  volatile uint32_t OSPEEDR;   
N  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
X  volatile uint32_t PUPDR;     
N  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
X  volatile uint32_t IDR;       
N  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
X  volatile uint32_t ODR;       
N  __IO uint32_t BSRR;     /*!< GPIO port bit set/reset register,      Address offset: 0x18      */
X  volatile uint32_t BSRR;      
N  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
X  volatile uint32_t LCKR;      
N  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];    
N} GPIO_TypeDef;
N
N/** 
N  * @brief System configuration controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MEMRMP;       /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
X  volatile uint32_t MEMRMP;        
N  __IO uint32_t PMC;          /*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      */
X  volatile uint32_t PMC;           
N  __IO uint32_t EXTICR[4];    /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
X  volatile uint32_t EXTICR[4];     
N  uint32_t      RESERVED[2];  /*!< Reserved, 0x18-0x1C                                                          */
N  __IO uint32_t CMPCR;        /*!< SYSCFG Compensation cell control register,         Address offset: 0x20      */
X  volatile uint32_t CMPCR;         
N} SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;        /*!< I2C Control register 1,     Address offset: 0x00 */
X  volatile uint32_t CR1;         
N  __IO uint32_t CR2;        /*!< I2C Control register 2,     Address offset: 0x04 */
X  volatile uint32_t CR2;         
N  __IO uint32_t OAR1;       /*!< I2C Own address register 1, Address offset: 0x08 */
X  volatile uint32_t OAR1;        
N  __IO uint32_t OAR2;       /*!< I2C Own address register 2, Address offset: 0x0C */
X  volatile uint32_t OAR2;        
N  __IO uint32_t DR;         /*!< I2C Data register,          Address offset: 0x10 */
X  volatile uint32_t DR;          
N  __IO uint32_t SR1;        /*!< I2C Status register 1,      Address offset: 0x14 */
X  volatile uint32_t SR1;         
N  __IO uint32_t SR2;        /*!< I2C Status register 2,      Address offset: 0x18 */
X  volatile uint32_t SR2;         
N  __IO uint32_t CCR;        /*!< I2C Clock control register, Address offset: 0x1C */
X  volatile uint32_t CCR;         
N  __IO uint32_t TRISE;      /*!< I2C TRISE register,         Address offset: 0x20 */
X  volatile uint32_t TRISE;       
N  __IO uint32_t FLTR;       /*!< I2C FLTR register,          Address offset: 0x24 */
X  volatile uint32_t FLTR;        
N} I2C_TypeDef;
N
N/** 
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;    
N  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;    
N  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;   
N  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;    
N} IWDG_TypeDef;
N
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
X  volatile uint32_t CSR;   
N} PWR_TypeDef;
N
N/** 
N  * @brief Reset and Clock Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< RCC clock control register,                                  Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t PLLCFGR;       /*!< RCC PLL configuration register,                              Address offset: 0x04 */
X  volatile uint32_t PLLCFGR;        
N  __IO uint32_t CFGR;          /*!< RCC clock configuration register,                            Address offset: 0x08 */
X  volatile uint32_t CFGR;           
N  __IO uint32_t CIR;           /*!< RCC clock interrupt register,                                Address offset: 0x0C */
X  volatile uint32_t CIR;            
N  __IO uint32_t AHB1RSTR;      /*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 */
X  volatile uint32_t AHB1RSTR;       
N  __IO uint32_t AHB2RSTR;      /*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 */
X  volatile uint32_t AHB2RSTR;       
N  __IO uint32_t AHB3RSTR;      /*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 */
X  volatile uint32_t AHB3RSTR;       
N  uint32_t      RESERVED0;     /*!< Reserved, 0x1C                                                                    */
N  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 */
X  volatile uint32_t APB1RSTR;       
N  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 */
X  volatile uint32_t APB2RSTR;       
N  uint32_t      RESERVED1[2];  /*!< Reserved, 0x28-0x2C                                                               */
N  __IO uint32_t AHB1ENR;       /*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 */
X  volatile uint32_t AHB1ENR;        
N  __IO uint32_t AHB2ENR;       /*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 */
X  volatile uint32_t AHB2ENR;        
N  __IO uint32_t AHB3ENR;       /*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 */
X  volatile uint32_t AHB3ENR;        
N  uint32_t      RESERVED2;     /*!< Reserved, 0x3C                                                                    */
N  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */
X  volatile uint32_t APB1ENR;        
N  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */
X  volatile uint32_t APB2ENR;        
N  uint32_t      RESERVED3[2];  /*!< Reserved, 0x48-0x4C                                                               */
N  __IO uint32_t AHB1LPENR;     /*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */
X  volatile uint32_t AHB1LPENR;      
N  __IO uint32_t AHB2LPENR;     /*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */
X  volatile uint32_t AHB2LPENR;      
N  __IO uint32_t AHB3LPENR;     /*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */
X  volatile uint32_t AHB3LPENR;      
N  uint32_t      RESERVED4;     /*!< Reserved, 0x5C                                                                    */
N  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */
X  volatile uint32_t APB1LPENR;      
N  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */
X  volatile uint32_t APB2LPENR;      
N  uint32_t      RESERVED5[2];  /*!< Reserved, 0x68-0x6C                                                               */
N  __IO uint32_t BDCR;          /*!< RCC Backup domain control register,                          Address offset: 0x70 */
X  volatile uint32_t BDCR;           
N  __IO uint32_t CSR;           /*!< RCC clock control & status register,                         Address offset: 0x74 */
X  volatile uint32_t CSR;            
N  uint32_t      RESERVED6[2];  /*!< Reserved, 0x78-0x7C                                                               */
N  __IO uint32_t SSCGR;         /*!< RCC spread spectrum clock generation register,               Address offset: 0x80 */
X  volatile uint32_t SSCGR;          
N  __IO uint32_t PLLI2SCFGR;    /*!< RCC PLLI2S configuration register,                           Address offset: 0x84 */
X  volatile uint32_t PLLI2SCFGR;     
N  uint32_t      RESERVED7[1];  /*!< Reserved, 0x88                                                                    */
N  __IO uint32_t DCKCFGR;       /*!< RCC Dedicated Clocks configuration register,                 Address offset: 0x8C */
X  volatile uint32_t DCKCFGR;        
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TR;      /*!< RTC time register,                                        Address offset: 0x00 */
X  volatile uint32_t TR;       
N  __IO uint32_t DR;      /*!< RTC date register,                                        Address offset: 0x04 */
X  volatile uint32_t DR;       
N  __IO uint32_t CR;      /*!< RTC control register,                                     Address offset: 0x08 */
X  volatile uint32_t CR;       
N  __IO uint32_t ISR;     /*!< RTC initialization and status register,                   Address offset: 0x0C */
X  volatile uint32_t ISR;      
N  __IO uint32_t PRER;    /*!< RTC prescaler register,                                   Address offset: 0x10 */
X  volatile uint32_t PRER;     
N  __IO uint32_t WUTR;    /*!< RTC wakeup timer register,                                Address offset: 0x14 */
X  volatile uint32_t WUTR;     
N  __IO uint32_t CALIBR;  /*!< RTC calibration register,                                 Address offset: 0x18 */
X  volatile uint32_t CALIBR;   
N  __IO uint32_t ALRMAR;  /*!< RTC alarm A register,                                     Address offset: 0x1C */
X  volatile uint32_t ALRMAR;   
N  __IO uint32_t ALRMBR;  /*!< RTC alarm B register,                                     Address offset: 0x20 */
X  volatile uint32_t ALRMBR;   
N  __IO uint32_t WPR;     /*!< RTC write protection register,                            Address offset: 0x24 */
X  volatile uint32_t WPR;      
N  __IO uint32_t SSR;     /*!< RTC sub second register,                                  Address offset: 0x28 */
X  volatile uint32_t SSR;      
N  __IO uint32_t SHIFTR;  /*!< RTC shift control register,                               Address offset: 0x2C */
X  volatile uint32_t SHIFTR;   
N  __IO uint32_t TSTR;    /*!< RTC time stamp time register,                             Address offset: 0x30 */
X  volatile uint32_t TSTR;     
N  __IO uint32_t TSDR;    /*!< RTC time stamp date register,                             Address offset: 0x34 */
X  volatile uint32_t TSDR;     
N  __IO uint32_t TSSSR;   /*!< RTC time-stamp sub second register,                       Address offset: 0x38 */
X  volatile uint32_t TSSSR;    
N  __IO uint32_t CALR;    /*!< RTC calibration register,                                 Address offset: 0x3C */
X  volatile uint32_t CALR;     
N  __IO uint32_t TAFCR;   /*!< RTC tamper and alternate function configuration register, Address offset: 0x40 */
X  volatile uint32_t TAFCR;    
N  __IO uint32_t ALRMASSR;/*!< RTC alarm A sub second register,                          Address offset: 0x44 */
X  volatile uint32_t ALRMASSR; 
N  __IO uint32_t ALRMBSSR;/*!< RTC alarm B sub second register,                          Address offset: 0x48 */
X  volatile uint32_t ALRMBSSR; 
N  uint32_t RESERVED7;    /*!< Reserved, 0x4C                                                                 */
N  __IO uint32_t BKP0R;   /*!< RTC backup register 1,                                    Address offset: 0x50 */
X  volatile uint32_t BKP0R;    
N  __IO uint32_t BKP1R;   /*!< RTC backup register 1,                                    Address offset: 0x54 */
X  volatile uint32_t BKP1R;    
N  __IO uint32_t BKP2R;   /*!< RTC backup register 2,                                    Address offset: 0x58 */
X  volatile uint32_t BKP2R;    
N  __IO uint32_t BKP3R;   /*!< RTC backup register 3,                                    Address offset: 0x5C */
X  volatile uint32_t BKP3R;    
N  __IO uint32_t BKP4R;   /*!< RTC backup register 4,                                    Address offset: 0x60 */
X  volatile uint32_t BKP4R;    
N  __IO uint32_t BKP5R;   /*!< RTC backup register 5,                                    Address offset: 0x64 */
X  volatile uint32_t BKP5R;    
N  __IO uint32_t BKP6R;   /*!< RTC backup register 6,                                    Address offset: 0x68 */
X  volatile uint32_t BKP6R;    
N  __IO uint32_t BKP7R;   /*!< RTC backup register 7,                                    Address offset: 0x6C */
X  volatile uint32_t BKP7R;    
N  __IO uint32_t BKP8R;   /*!< RTC backup register 8,                                    Address offset: 0x70 */
X  volatile uint32_t BKP8R;    
N  __IO uint32_t BKP9R;   /*!< RTC backup register 9,                                    Address offset: 0x74 */
X  volatile uint32_t BKP9R;    
N  __IO uint32_t BKP10R;  /*!< RTC backup register 10,                                   Address offset: 0x78 */
X  volatile uint32_t BKP10R;   
N  __IO uint32_t BKP11R;  /*!< RTC backup register 11,                                   Address offset: 0x7C */
X  volatile uint32_t BKP11R;   
N  __IO uint32_t BKP12R;  /*!< RTC backup register 12,                                   Address offset: 0x80 */
X  volatile uint32_t BKP12R;   
N  __IO uint32_t BKP13R;  /*!< RTC backup register 13,                                   Address offset: 0x84 */
X  volatile uint32_t BKP13R;   
N  __IO uint32_t BKP14R;  /*!< RTC backup register 14,                                   Address offset: 0x88 */
X  volatile uint32_t BKP14R;   
N  __IO uint32_t BKP15R;  /*!< RTC backup register 15,                                   Address offset: 0x8C */
X  volatile uint32_t BKP15R;   
N  __IO uint32_t BKP16R;  /*!< RTC backup register 16,                                   Address offset: 0x90 */
X  volatile uint32_t BKP16R;   
N  __IO uint32_t BKP17R;  /*!< RTC backup register 17,                                   Address offset: 0x94 */
X  volatile uint32_t BKP17R;   
N  __IO uint32_t BKP18R;  /*!< RTC backup register 18,                                   Address offset: 0x98 */
X  volatile uint32_t BKP18R;   
N  __IO uint32_t BKP19R;  /*!< RTC backup register 19,                                   Address offset: 0x9C */
X  volatile uint32_t BKP19R;   
N} RTC_TypeDef;
N
N/** 
N  * @brief SD host Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t POWER;                 /*!< SDIO power control register,    Address offset: 0x00 */
X  volatile uint32_t POWER;                  
N  __IO uint32_t CLKCR;                 /*!< SDI clock control register,     Address offset: 0x04 */
X  volatile uint32_t CLKCR;                  
N  __IO uint32_t ARG;                   /*!< SDIO argument register,         Address offset: 0x08 */
X  volatile uint32_t ARG;                    
N  __IO uint32_t CMD;                   /*!< SDIO command register,          Address offset: 0x0C */
X  volatile uint32_t CMD;                    
N  __IO const uint32_t  RESPCMD;        /*!< SDIO command response register, Address offset: 0x10 */
X  volatile const uint32_t  RESPCMD;         
N  __IO const uint32_t  RESP1;          /*!< SDIO response 1 register,       Address offset: 0x14 */
X  volatile const uint32_t  RESP1;           
N  __IO const uint32_t  RESP2;          /*!< SDIO response 2 register,       Address offset: 0x18 */
X  volatile const uint32_t  RESP2;           
N  __IO const uint32_t  RESP3;          /*!< SDIO response 3 register,       Address offset: 0x1C */
X  volatile const uint32_t  RESP3;           
N  __IO const uint32_t  RESP4;          /*!< SDIO response 4 register,       Address offset: 0x20 */
X  volatile const uint32_t  RESP4;           
N  __IO uint32_t DTIMER;                /*!< SDIO data timer register,       Address offset: 0x24 */
X  volatile uint32_t DTIMER;                 
N  __IO uint32_t DLEN;                  /*!< SDIO data length register,      Address offset: 0x28 */
X  volatile uint32_t DLEN;                   
N  __IO uint32_t DCTRL;                 /*!< SDIO data control register,     Address offset: 0x2C */
X  volatile uint32_t DCTRL;                  
N  __IO const uint32_t  DCOUNT;         /*!< SDIO data counter register,     Address offset: 0x30 */
X  volatile const uint32_t  DCOUNT;          
N  __IO const uint32_t  STA;            /*!< SDIO status register,           Address offset: 0x34 */
X  volatile const uint32_t  STA;             
N  __IO uint32_t ICR;                   /*!< SDIO interrupt clear register,  Address offset: 0x38 */
X  volatile uint32_t ICR;                    
N  __IO uint32_t MASK;                  /*!< SDIO mask register,             Address offset: 0x3C */
X  volatile uint32_t MASK;                   
N  uint32_t      RESERVED0[2];          /*!< Reserved, 0x40-0x44                                  */
N  __IO const uint32_t  FIFOCNT;        /*!< SDIO FIFO counter register,     Address offset: 0x48 */
X  volatile const uint32_t  FIFOCNT;         
N  uint32_t      RESERVED1[13];         /*!< Reserved, 0x4C-0x7C                                  */
N  __IO uint32_t FIFO;                  /*!< SDIO data FIFO register,        Address offset: 0x80 */
X  volatile uint32_t FIFO;                   
N} SDIO_TypeDef;
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;        /*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 */
X  volatile uint32_t CR1;         
N  __IO uint32_t CR2;        /*!< SPI control register 2,                             Address offset: 0x04 */
X  volatile uint32_t CR2;         
N  __IO uint32_t SR;         /*!< SPI status register,                                Address offset: 0x08 */
X  volatile uint32_t SR;          
N  __IO uint32_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
X  volatile uint32_t DR;          
N  __IO uint32_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
X  volatile uint32_t CRCPR;       
N  __IO uint32_t RXCRCR;     /*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 */
X  volatile uint32_t RXCRCR;      
N  __IO uint32_t TXCRCR;     /*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 */
X  volatile uint32_t TXCRCR;      
N  __IO uint32_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
X  volatile uint32_t I2SCFGR;     
N  __IO uint32_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
X  volatile uint32_t I2SPR;       
N} SPI_TypeDef;
N
N
N/** 
N  * @brief TIM
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
X  volatile uint32_t CR1;          
N  __IO uint32_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
X  volatile uint32_t CR2;          
N  __IO uint32_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
X  volatile uint32_t SMCR;         
N  __IO uint32_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
X  volatile uint32_t DIER;         
N  __IO uint32_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
X  volatile uint32_t SR;           
N  __IO uint32_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
X  volatile uint32_t EGR;          
N  __IO uint32_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
X  volatile uint32_t CCMR1;        
N  __IO uint32_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
X  volatile uint32_t CCMR2;        
N  __IO uint32_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
X  volatile uint32_t CCER;         
N  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
X  volatile uint32_t CNT;          
N  __IO uint32_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
X  volatile uint32_t PSC;          
N  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
X  volatile uint32_t ARR;          
N  __IO uint32_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
X  volatile uint32_t RCR;          
N  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
X  volatile uint32_t CCR1;         
N  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
X  volatile uint32_t CCR2;         
N  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
X  volatile uint32_t CCR3;         
N  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
X  volatile uint32_t CCR4;         
N  __IO uint32_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
X  volatile uint32_t BDTR;         
N  __IO uint32_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
X  volatile uint32_t DCR;          
N  __IO uint32_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
X  volatile uint32_t DMAR;         
N  __IO uint32_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
X  volatile uint32_t OR;           
N} TIM_TypeDef;
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N 
Ntypedef struct
N{
N  __IO uint32_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
X  volatile uint32_t SR;          
N  __IO uint32_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
X  volatile uint32_t DR;          
N  __IO uint32_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
X  volatile uint32_t BRR;         
N  __IO uint32_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
X  volatile uint32_t CR1;         
N  __IO uint32_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
X  volatile uint32_t CR2;         
N  __IO uint32_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
X  volatile uint32_t CR3;         
N  __IO uint32_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
X  volatile uint32_t GTPR;        
N} USART_TypeDef;
N
N/** 
N  * @brief Window WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N/** 
N  * @brief USB_OTG_Core_Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t GOTGCTL;              /*!< USB_OTG Control and Status Register          000h */
X  volatile uint32_t GOTGCTL;               
N  __IO uint32_t GOTGINT;              /*!< USB_OTG Interrupt Register                   004h */
X  volatile uint32_t GOTGINT;               
N  __IO uint32_t GAHBCFG;              /*!< Core AHB Configuration Register              008h */
X  volatile uint32_t GAHBCFG;               
N  __IO uint32_t GUSBCFG;              /*!< Core USB Configuration Register              00Ch */
X  volatile uint32_t GUSBCFG;               
N  __IO uint32_t GRSTCTL;              /*!< Core Reset Register                          010h */
X  volatile uint32_t GRSTCTL;               
N  __IO uint32_t GINTSTS;              /*!< Core Interrupt Register                      014h */
X  volatile uint32_t GINTSTS;               
N  __IO uint32_t GINTMSK;              /*!< Core Interrupt Mask Register                 018h */
X  volatile uint32_t GINTMSK;               
N  __IO uint32_t GRXSTSR;              /*!< Receive Sts Q Read Register                  01Ch */
X  volatile uint32_t GRXSTSR;               
N  __IO uint32_t GRXSTSP;              /*!< Receive Sts Q Read & POP Register            020h */
X  volatile uint32_t GRXSTSP;               
N  __IO uint32_t GRXFSIZ;              /*!< Receive FIFO Size Register                   024h */
X  volatile uint32_t GRXFSIZ;               
N  __IO uint32_t DIEPTXF0_HNPTXFSIZ;   /*!< EP0 / Non Periodic Tx FIFO Size Register     028h */
X  volatile uint32_t DIEPTXF0_HNPTXFSIZ;    
N  __IO uint32_t HNPTXSTS;             /*!< Non Periodic Tx FIFO/Queue Sts reg           02Ch */
X  volatile uint32_t HNPTXSTS;              
N  uint32_t Reserved30[2];             /*!< Reserved                                     030h */
N  __IO uint32_t GCCFG;                /*!< General Purpose IO Register                  038h */
X  volatile uint32_t GCCFG;                 
N  __IO uint32_t CID;                  /*!< User ID Register                             03Ch */
X  volatile uint32_t CID;                   
N  uint32_t  Reserved40[48];           /*!< Reserved                                0x40-0xFF */
N  __IO uint32_t HPTXFSIZ;             /*!< Host Periodic Tx FIFO Size Reg               100h */
X  volatile uint32_t HPTXFSIZ;              
N  __IO uint32_t DIEPTXF[0x0F];        /*!< dev Periodic Transmit FIFO                        */
X  volatile uint32_t DIEPTXF[0x0F];         
N} USB_OTG_GlobalTypeDef;
N
N/** 
N  * @brief USB_OTG_device_Registers
N  */
Ntypedef struct 
N{
N  __IO uint32_t DCFG;            /*!< dev Configuration Register   800h */
X  volatile uint32_t DCFG;             
N  __IO uint32_t DCTL;            /*!< dev Control Register         804h */
X  volatile uint32_t DCTL;             
N  __IO uint32_t DSTS;            /*!< dev Status Register (RO)     808h */
X  volatile uint32_t DSTS;             
N  uint32_t Reserved0C;           /*!< Reserved                     80Ch */
N  __IO uint32_t DIEPMSK;         /*!< dev IN Endpoint Mask         810h */
X  volatile uint32_t DIEPMSK;          
N  __IO uint32_t DOEPMSK;         /*!< dev OUT Endpoint Mask        814h */
X  volatile uint32_t DOEPMSK;          
N  __IO uint32_t DAINT;           /*!< dev All Endpoints Itr Reg    818h */
X  volatile uint32_t DAINT;            
N  __IO uint32_t DAINTMSK;        /*!< dev All Endpoints Itr Mask   81Ch */
X  volatile uint32_t DAINTMSK;         
N  uint32_t  Reserved20;          /*!< Reserved                     820h */
N  uint32_t Reserved9;            /*!< Reserved                     824h */
N  __IO uint32_t DVBUSDIS;        /*!< dev VBUS discharge Register  828h */
X  volatile uint32_t DVBUSDIS;         
N  __IO uint32_t DVBUSPULSE;      /*!< dev VBUS Pulse Register      82Ch */
X  volatile uint32_t DVBUSPULSE;       
N  __IO uint32_t DTHRCTL;         /*!< dev threshold                830h */
X  volatile uint32_t DTHRCTL;          
N  __IO uint32_t DIEPEMPMSK;      /*!< dev empty msk                834h */
X  volatile uint32_t DIEPEMPMSK;       
N  __IO uint32_t DEACHINT;        /*!< dedicated EP interrupt       838h */
X  volatile uint32_t DEACHINT;         
N  __IO uint32_t DEACHMSK;        /*!< dedicated EP msk             83Ch */
X  volatile uint32_t DEACHMSK;         
N  uint32_t Reserved40;           /*!< dedicated EP mask            840h */
N  __IO uint32_t DINEP1MSK;       /*!< dedicated EP mask            844h */
X  volatile uint32_t DINEP1MSK;        
N  uint32_t  Reserved44[15];      /*!< Reserved                 844-87Ch */
N  __IO uint32_t DOUTEP1MSK;      /*!< dedicated EP msk             884h */
X  volatile uint32_t DOUTEP1MSK;       
N} USB_OTG_DeviceTypeDef;
N
N/** 
N  * @brief USB_OTG_IN_Endpoint-Specific_Register
N  */
Ntypedef struct 
N{
N  __IO uint32_t DIEPCTL;           /*!< dev IN Endpoint Control Reg    900h + (ep_num * 20h) + 00h */
X  volatile uint32_t DIEPCTL;            
N  uint32_t Reserved04;             /*!< Reserved                       900h + (ep_num * 20h) + 04h */
N  __IO uint32_t DIEPINT;           /*!< dev IN Endpoint Itr Reg        900h + (ep_num * 20h) + 08h */
X  volatile uint32_t DIEPINT;            
N  uint32_t Reserved0C;             /*!< Reserved                       900h + (ep_num * 20h) + 0Ch */
N  __IO uint32_t DIEPTSIZ;          /*!< IN Endpoint Txfer Size         900h + (ep_num * 20h) + 10h */
X  volatile uint32_t DIEPTSIZ;           
N  __IO uint32_t DIEPDMA;           /*!< IN Endpoint DMA Address Reg    900h + (ep_num * 20h) + 14h */
X  volatile uint32_t DIEPDMA;            
N  __IO uint32_t DTXFSTS;           /*!< IN Endpoint Tx FIFO Status Reg 900h + (ep_num * 20h) + 18h */
X  volatile uint32_t DTXFSTS;            
N  uint32_t Reserved18;             /*!< Reserved  900h+(ep_num*20h)+1Ch-900h+ (ep_num * 20h) + 1Ch */
N} USB_OTG_INEndpointTypeDef;
N
N/** 
N  * @brief USB_OTG_OUT_Endpoint-Specific_Registers
N  */
Ntypedef struct 
N{
N  __IO uint32_t DOEPCTL;       /*!< dev OUT Endpoint Control Reg           B00h + (ep_num * 20h) + 00h */
X  volatile uint32_t DOEPCTL;        
N  uint32_t Reserved04;         /*!< Reserved                               B00h + (ep_num * 20h) + 04h */
N  __IO uint32_t DOEPINT;       /*!< dev OUT Endpoint Itr Reg               B00h + (ep_num * 20h) + 08h */
X  volatile uint32_t DOEPINT;        
N  uint32_t Reserved0C;         /*!< Reserved                               B00h + (ep_num * 20h) + 0Ch */
N  __IO uint32_t DOEPTSIZ;      /*!< dev OUT Endpoint Txfer Size            B00h + (ep_num * 20h) + 10h */
X  volatile uint32_t DOEPTSIZ;       
N  __IO uint32_t DOEPDMA;       /*!< dev OUT Endpoint DMA Address           B00h + (ep_num * 20h) + 14h */
X  volatile uint32_t DOEPDMA;        
N  uint32_t Reserved18[2];      /*!< Reserved B00h + (ep_num * 20h) + 18h - B00h + (ep_num * 20h) + 1Ch */
N} USB_OTG_OUTEndpointTypeDef;
N
N/** 
N  * @brief USB_OTG_Host_Mode_Register_Structures
N  */
Ntypedef struct 
N{
N  __IO uint32_t HCFG;             /*!< Host Configuration Register          400h */
X  volatile uint32_t HCFG;              
N  __IO uint32_t HFIR;             /*!< Host Frame Interval Register         404h */
X  volatile uint32_t HFIR;              
N  __IO uint32_t HFNUM;            /*!< Host Frame Nbr/Frame Remaining       408h */
X  volatile uint32_t HFNUM;             
N  uint32_t Reserved40C;           /*!< Reserved                             40Ch */
N  __IO uint32_t HPTXSTS;          /*!< Host Periodic Tx FIFO/ Queue Status  410h */
X  volatile uint32_t HPTXSTS;           
N  __IO uint32_t HAINT;            /*!< Host All Channels Interrupt Register 414h */
X  volatile uint32_t HAINT;             
N  __IO uint32_t HAINTMSK;         /*!< Host All Channels Interrupt Mask     418h */
X  volatile uint32_t HAINTMSK;          
N} USB_OTG_HostTypeDef;
N
N/** 
N  * @brief USB_OTG_Host_Channel_Specific_Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t HCCHAR;           /*!< Host Channel Characteristics Register    500h */
X  volatile uint32_t HCCHAR;            
N  __IO uint32_t HCSPLT;           /*!< Host Channel Split Control Register      504h */
X  volatile uint32_t HCSPLT;            
N  __IO uint32_t HCINT;            /*!< Host Channel Interrupt Register          508h */
X  volatile uint32_t HCINT;             
N  __IO uint32_t HCINTMSK;         /*!< Host Channel Interrupt Mask Register     50Ch */
X  volatile uint32_t HCINTMSK;          
N  __IO uint32_t HCTSIZ;           /*!< Host Channel Transfer Size Register      510h */
X  volatile uint32_t HCTSIZ;            
N  __IO uint32_t HCDMA;            /*!< Host Channel DMA Address Register        514h */
X  volatile uint32_t HCDMA;             
N  uint32_t Reserved[2];           /*!< Reserved                                      */
N} USB_OTG_HostChannelTypeDef;
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N#define FLASH_BASE            0x08000000UL /*!< FLASH(up to 1 MB) base address in the alias region                         */
N#define SRAM1_BASE            0x20000000UL /*!< SRAM1(96 KB) base address in the alias region                              */
N#define PERIPH_BASE           0x40000000UL /*!< Peripheral base address in the alias region                                */
N#define SRAM1_BB_BASE         0x22000000UL /*!< SRAM1(96 KB) base address in the bit-band region                           */
N#define PERIPH_BB_BASE        0x42000000UL /*!< Peripheral base address in the bit-band region                             */
N#define BKPSRAM_BB_BASE       0x42480000UL /*!< Backup SRAM(4 KB) base address in the bit-band region                      */
N#define FLASH_END             0x0807FFFFUL /*!< FLASH end address                                                          */
N#define FLASH_OTP_BASE        0x1FFF7800UL /*!< Base address of : (up to 528 Bytes) embedded FLASH OTP Area                */
N#define FLASH_OTP_END         0x1FFF7A0FUL /*!< End address of : (up to 528 Bytes) embedded FLASH OTP Area                 */
N
N/* Legacy defines */
N#define SRAM_BASE             SRAM1_BASE
N#define SRAM_BB_BASE          SRAM1_BB_BASE
N
N/*!< Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)
N#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000UL)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x10000000UL)
N
N/*!< APB1 peripherals */
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000UL)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400UL)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800UL)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00UL)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800UL)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00UL)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000UL)
N#define I2S2ext_BASE          (APB1PERIPH_BASE + 0x3400UL)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800UL)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00UL)
N#define I2S3ext_BASE          (APB1PERIPH_BASE + 0x4000UL)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400UL)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400UL)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800UL)
N#define I2C3_BASE             (APB1PERIPH_BASE + 0x5C00UL)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000UL)
N
N/*!< APB2 peripherals */
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x0000UL)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x1000UL)
N#define USART6_BASE           (APB2PERIPH_BASE + 0x1400UL)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2000UL)
N#define ADC1_COMMON_BASE      (APB2PERIPH_BASE + 0x2300UL)
N/* Legacy define */
N#define ADC_BASE               ADC1_COMMON_BASE
N#define SDIO_BASE             (APB2PERIPH_BASE + 0x2C00UL)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000UL)
N#define SPI4_BASE             (APB2PERIPH_BASE + 0x3400UL)
N#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x3800UL)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x3C00UL)
N#define TIM9_BASE             (APB2PERIPH_BASE + 0x4000UL)
N#define TIM10_BASE            (APB2PERIPH_BASE + 0x4400UL)
N#define TIM11_BASE            (APB2PERIPH_BASE + 0x4800UL)
N
N/*!< AHB1 peripherals */
N#define GPIOA_BASE            (AHB1PERIPH_BASE + 0x0000UL)
N#define GPIOB_BASE            (AHB1PERIPH_BASE + 0x0400UL)
N#define GPIOC_BASE            (AHB1PERIPH_BASE + 0x0800UL)
N#define GPIOD_BASE            (AHB1PERIPH_BASE + 0x0C00UL)
N#define GPIOE_BASE            (AHB1PERIPH_BASE + 0x1000UL)
N#define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00UL)
N#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000UL)
N#define RCC_BASE              (AHB1PERIPH_BASE + 0x3800UL)
N#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x3C00UL)
N#define DMA1_BASE             (AHB1PERIPH_BASE + 0x6000UL)
N#define DMA1_Stream0_BASE     (DMA1_BASE + 0x010UL)
N#define DMA1_Stream1_BASE     (DMA1_BASE + 0x028UL)
N#define DMA1_Stream2_BASE     (DMA1_BASE + 0x040UL)
N#define DMA1_Stream3_BASE     (DMA1_BASE + 0x058UL)
N#define DMA1_Stream4_BASE     (DMA1_BASE + 0x070UL)
N#define DMA1_Stream5_BASE     (DMA1_BASE + 0x088UL)
N#define DMA1_Stream6_BASE     (DMA1_BASE + 0x0A0UL)
N#define DMA1_Stream7_BASE     (DMA1_BASE + 0x0B8UL)
N#define DMA2_BASE             (AHB1PERIPH_BASE + 0x6400UL)
N#define DMA2_Stream0_BASE     (DMA2_BASE + 0x010UL)
N#define DMA2_Stream1_BASE     (DMA2_BASE + 0x028UL)
N#define DMA2_Stream2_BASE     (DMA2_BASE + 0x040UL)
N#define DMA2_Stream3_BASE     (DMA2_BASE + 0x058UL)
N#define DMA2_Stream4_BASE     (DMA2_BASE + 0x070UL)
N#define DMA2_Stream5_BASE     (DMA2_BASE + 0x088UL)
N#define DMA2_Stream6_BASE     (DMA2_BASE + 0x0A0UL)
N#define DMA2_Stream7_BASE     (DMA2_BASE + 0x0B8UL)
N
N
N/*!< Debug MCU registers base address */
N#define DBGMCU_BASE           0xE0042000UL
N/*!< USB registers base address */
N#define USB_OTG_FS_PERIPH_BASE               0x50000000UL
N
N#define USB_OTG_GLOBAL_BASE                  0x000UL
N#define USB_OTG_DEVICE_BASE                  0x800UL
N#define USB_OTG_IN_ENDPOINT_BASE             0x900UL
N#define USB_OTG_OUT_ENDPOINT_BASE            0xB00UL
N#define USB_OTG_EP_REG_SIZE                  0x20UL
N#define USB_OTG_HOST_BASE                    0x400UL
N#define USB_OTG_HOST_PORT_BASE               0x440UL
N#define USB_OTG_HOST_CHANNEL_BASE            0x500UL
N#define USB_OTG_HOST_CHANNEL_SIZE            0x20UL
N#define USB_OTG_PCGCCTL_BASE                 0xE00UL
N#define USB_OTG_FIFO_BASE                    0x1000UL
N#define USB_OTG_FIFO_SIZE                    0x1000UL
N
N#define UID_BASE                     0x1FFF7A10UL           /*!< Unique device ID register base address */
N#define FLASHSIZE_BASE               0x1FFF7A22UL           /*!< FLASH Size register base address       */
N#define PACKAGE_BASE                 0x1FFF7BF0UL           /*!< Package size register base address     */
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_declaration
N  * @{
N  */  
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define I2S2ext             ((SPI_TypeDef *) I2S2ext_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#define I2S3ext             ((SPI_TypeDef *) I2S3ext_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define I2C3                ((I2C_TypeDef *) I2C3_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define USART6              ((USART_TypeDef *) USART6_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC1_COMMON         ((ADC_Common_TypeDef *) ADC1_COMMON_BASE)
N/* Legacy define */
N#define ADC                  ADC1_COMMON
N#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define SPI4                ((SPI_TypeDef *) SPI4_BASE)
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
N#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
N#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Stream0        ((DMA_Stream_TypeDef *) DMA1_Stream0_BASE)
N#define DMA1_Stream1        ((DMA_Stream_TypeDef *) DMA1_Stream1_BASE)
N#define DMA1_Stream2        ((DMA_Stream_TypeDef *) DMA1_Stream2_BASE)
N#define DMA1_Stream3        ((DMA_Stream_TypeDef *) DMA1_Stream3_BASE)
N#define DMA1_Stream4        ((DMA_Stream_TypeDef *) DMA1_Stream4_BASE)
N#define DMA1_Stream5        ((DMA_Stream_TypeDef *) DMA1_Stream5_BASE)
N#define DMA1_Stream6        ((DMA_Stream_TypeDef *) DMA1_Stream6_BASE)
N#define DMA1_Stream7        ((DMA_Stream_TypeDef *) DMA1_Stream7_BASE)
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define DMA2_Stream0        ((DMA_Stream_TypeDef *) DMA2_Stream0_BASE)
N#define DMA2_Stream1        ((DMA_Stream_TypeDef *) DMA2_Stream1_BASE)
N#define DMA2_Stream2        ((DMA_Stream_TypeDef *) DMA2_Stream2_BASE)
N#define DMA2_Stream3        ((DMA_Stream_TypeDef *) DMA2_Stream3_BASE)
N#define DMA2_Stream4        ((DMA_Stream_TypeDef *) DMA2_Stream4_BASE)
N#define DMA2_Stream5        ((DMA_Stream_TypeDef *) DMA2_Stream5_BASE)
N#define DMA2_Stream6        ((DMA_Stream_TypeDef *) DMA2_Stream6_BASE)
N#define DMA2_Stream7        ((DMA_Stream_TypeDef *) DMA2_Stream7_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#define USB_OTG_FS          ((USB_OTG_GlobalTypeDef *) USB_OTG_FS_PERIPH_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N  
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N    
N/******************************************************************************/
N/*                         Peripheral Registers_Bits_Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Analog to Digital Converter                         */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for ADC_SR register  ********************/
N#define ADC_SR_AWD_Pos            (0U)                                         
N#define ADC_SR_AWD_Msk            (0x1UL << ADC_SR_AWD_Pos)                     /*!< 0x00000001 */
N#define ADC_SR_AWD                ADC_SR_AWD_Msk                               /*!<Analog watchdog flag */
N#define ADC_SR_EOC_Pos            (1U)                                         
N#define ADC_SR_EOC_Msk            (0x1UL << ADC_SR_EOC_Pos)                     /*!< 0x00000002 */
N#define ADC_SR_EOC                ADC_SR_EOC_Msk                               /*!<End of conversion */
N#define ADC_SR_JEOC_Pos           (2U)                                         
N#define ADC_SR_JEOC_Msk           (0x1UL << ADC_SR_JEOC_Pos)                    /*!< 0x00000004 */
N#define ADC_SR_JEOC               ADC_SR_JEOC_Msk                              /*!<Injected channel end of conversion */
N#define ADC_SR_JSTRT_Pos          (3U)                                         
N#define ADC_SR_JSTRT_Msk          (0x1UL << ADC_SR_JSTRT_Pos)                   /*!< 0x00000008 */
N#define ADC_SR_JSTRT              ADC_SR_JSTRT_Msk                             /*!<Injected channel Start flag */
N#define ADC_SR_STRT_Pos           (4U)                                         
N#define ADC_SR_STRT_Msk           (0x1UL << ADC_SR_STRT_Pos)                    /*!< 0x00000010 */
N#define ADC_SR_STRT               ADC_SR_STRT_Msk                              /*!<Regular channel Start flag */
N#define ADC_SR_OVR_Pos            (5U)                                         
N#define ADC_SR_OVR_Msk            (0x1UL << ADC_SR_OVR_Pos)                     /*!< 0x00000020 */
N#define ADC_SR_OVR                ADC_SR_OVR_Msk                               /*!<Overrun flag */
N
N/*******************  Bit definition for ADC_CR1 register  ********************/
N#define ADC_CR1_AWDCH_Pos         (0U)                                         
N#define ADC_CR1_AWDCH_Msk         (0x1FUL << ADC_CR1_AWDCH_Pos)                 /*!< 0x0000001F */
N#define ADC_CR1_AWDCH             ADC_CR1_AWDCH_Msk                            /*!<AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define ADC_CR1_AWDCH_0           (0x01UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000001 */
N#define ADC_CR1_AWDCH_1           (0x02UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000002 */
N#define ADC_CR1_AWDCH_2           (0x04UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000004 */
N#define ADC_CR1_AWDCH_3           (0x08UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000008 */
N#define ADC_CR1_AWDCH_4           (0x10UL << ADC_CR1_AWDCH_Pos)                 /*!< 0x00000010 */
N#define ADC_CR1_EOCIE_Pos         (5U)                                         
N#define ADC_CR1_EOCIE_Msk         (0x1UL << ADC_CR1_EOCIE_Pos)                  /*!< 0x00000020 */
N#define ADC_CR1_EOCIE             ADC_CR1_EOCIE_Msk                            /*!<Interrupt enable for EOC */
N#define ADC_CR1_AWDIE_Pos         (6U)                                         
N#define ADC_CR1_AWDIE_Msk         (0x1UL << ADC_CR1_AWDIE_Pos)                  /*!< 0x00000040 */
N#define ADC_CR1_AWDIE             ADC_CR1_AWDIE_Msk                            /*!<AAnalog Watchdog interrupt enable */
N#define ADC_CR1_JEOCIE_Pos        (7U)                                         
N#define ADC_CR1_JEOCIE_Msk        (0x1UL << ADC_CR1_JEOCIE_Pos)                 /*!< 0x00000080 */
N#define ADC_CR1_JEOCIE            ADC_CR1_JEOCIE_Msk                           /*!<Interrupt enable for injected channels */
N#define ADC_CR1_SCAN_Pos          (8U)                                         
N#define ADC_CR1_SCAN_Msk          (0x1UL << ADC_CR1_SCAN_Pos)                   /*!< 0x00000100 */
N#define ADC_CR1_SCAN              ADC_CR1_SCAN_Msk                             /*!<Scan mode */
N#define ADC_CR1_AWDSGL_Pos        (9U)                                         
N#define ADC_CR1_AWDSGL_Msk        (0x1UL << ADC_CR1_AWDSGL_Pos)                 /*!< 0x00000200 */
N#define ADC_CR1_AWDSGL            ADC_CR1_AWDSGL_Msk                           /*!<Enable the watchdog on a single channel in scan mode */
N#define ADC_CR1_JAUTO_Pos         (10U)                                        
N#define ADC_CR1_JAUTO_Msk         (0x1UL << ADC_CR1_JAUTO_Pos)                  /*!< 0x00000400 */
N#define ADC_CR1_JAUTO             ADC_CR1_JAUTO_Msk                            /*!<Automatic injected group conversion */
N#define ADC_CR1_DISCEN_Pos        (11U)                                        
N#define ADC_CR1_DISCEN_Msk        (0x1UL << ADC_CR1_DISCEN_Pos)                 /*!< 0x00000800 */
N#define ADC_CR1_DISCEN            ADC_CR1_DISCEN_Msk                           /*!<Discontinuous mode on regular channels */
N#define ADC_CR1_JDISCEN_Pos       (12U)                                        
N#define ADC_CR1_JDISCEN_Msk       (0x1UL << ADC_CR1_JDISCEN_Pos)                /*!< 0x00001000 */
N#define ADC_CR1_JDISCEN           ADC_CR1_JDISCEN_Msk                          /*!<Discontinuous mode on injected channels */
N#define ADC_CR1_DISCNUM_Pos       (13U)                                        
N#define ADC_CR1_DISCNUM_Msk       (0x7UL << ADC_CR1_DISCNUM_Pos)                /*!< 0x0000E000 */
N#define ADC_CR1_DISCNUM           ADC_CR1_DISCNUM_Msk                          /*!<DISCNUM[2:0] bits (Discontinuous mode channel count) */
N#define ADC_CR1_DISCNUM_0         (0x1UL << ADC_CR1_DISCNUM_Pos)                /*!< 0x00002000 */
N#define ADC_CR1_DISCNUM_1         (0x2UL << ADC_CR1_DISCNUM_Pos)                /*!< 0x00004000 */
N#define ADC_CR1_DISCNUM_2         (0x4UL << ADC_CR1_DISCNUM_Pos)                /*!< 0x00008000 */
N#define ADC_CR1_JAWDEN_Pos        (22U)                                        
N#define ADC_CR1_JAWDEN_Msk        (0x1UL << ADC_CR1_JAWDEN_Pos)                 /*!< 0x00400000 */
N#define ADC_CR1_JAWDEN            ADC_CR1_JAWDEN_Msk                           /*!<Analog watchdog enable on injected channels */
N#define ADC_CR1_AWDEN_Pos         (23U)                                        
N#define ADC_CR1_AWDEN_Msk         (0x1UL << ADC_CR1_AWDEN_Pos)                  /*!< 0x00800000 */
N#define ADC_CR1_AWDEN             ADC_CR1_AWDEN_Msk                            /*!<Analog watchdog enable on regular channels */
N#define ADC_CR1_RES_Pos           (24U)                                        
N#define ADC_CR1_RES_Msk           (0x3UL << ADC_CR1_RES_Pos)                    /*!< 0x03000000 */
N#define ADC_CR1_RES               ADC_CR1_RES_Msk                              /*!<RES[2:0] bits (Resolution) */
N#define ADC_CR1_RES_0             (0x1UL << ADC_CR1_RES_Pos)                    /*!< 0x01000000 */
N#define ADC_CR1_RES_1             (0x2UL << ADC_CR1_RES_Pos)                    /*!< 0x02000000 */
N#define ADC_CR1_OVRIE_Pos         (26U)                                        
N#define ADC_CR1_OVRIE_Msk         (0x1UL << ADC_CR1_OVRIE_Pos)                  /*!< 0x04000000 */
N#define ADC_CR1_OVRIE             ADC_CR1_OVRIE_Msk                            /*!<overrun interrupt enable */
N  
N/*******************  Bit definition for ADC_CR2 register  ********************/
N#define ADC_CR2_ADON_Pos          (0U)                                         
N#define ADC_CR2_ADON_Msk          (0x1UL << ADC_CR2_ADON_Pos)                   /*!< 0x00000001 */
N#define ADC_CR2_ADON              ADC_CR2_ADON_Msk                             /*!<A/D Converter ON / OFF */
N#define ADC_CR2_CONT_Pos          (1U)                                         
N#define ADC_CR2_CONT_Msk          (0x1UL << ADC_CR2_CONT_Pos)                   /*!< 0x00000002 */
N#define ADC_CR2_CONT              ADC_CR2_CONT_Msk                             /*!<Continuous Conversion */
N#define ADC_CR2_DMA_Pos           (8U)                                         
N#define ADC_CR2_DMA_Msk           (0x1UL << ADC_CR2_DMA_Pos)                    /*!< 0x00000100 */
N#define ADC_CR2_DMA               ADC_CR2_DMA_Msk                              /*!<Direct Memory access mode */
N#define ADC_CR2_DDS_Pos           (9U)                                         
N#define ADC_CR2_DDS_Msk           (0x1UL << ADC_CR2_DDS_Pos)                    /*!< 0x00000200 */
N#define ADC_CR2_DDS               ADC_CR2_DDS_Msk                              /*!<DMA disable selection (Single ADC) */
N#define ADC_CR2_EOCS_Pos          (10U)                                        
N#define ADC_CR2_EOCS_Msk          (0x1UL << ADC_CR2_EOCS_Pos)                   /*!< 0x00000400 */
N#define ADC_CR2_EOCS              ADC_CR2_EOCS_Msk                             /*!<End of conversion selection */
N#define ADC_CR2_ALIGN_Pos         (11U)                                        
N#define ADC_CR2_ALIGN_Msk         (0x1UL << ADC_CR2_ALIGN_Pos)                  /*!< 0x00000800 */
N#define ADC_CR2_ALIGN             ADC_CR2_ALIGN_Msk                            /*!<Data Alignment */
N#define ADC_CR2_JEXTSEL_Pos       (16U)                                        
N#define ADC_CR2_JEXTSEL_Msk       (0xFUL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x000F0000 */
N#define ADC_CR2_JEXTSEL           ADC_CR2_JEXTSEL_Msk                          /*!<JEXTSEL[3:0] bits (External event select for injected group) */
N#define ADC_CR2_JEXTSEL_0         (0x1UL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x00010000 */
N#define ADC_CR2_JEXTSEL_1         (0x2UL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x00020000 */
N#define ADC_CR2_JEXTSEL_2         (0x4UL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x00040000 */
N#define ADC_CR2_JEXTSEL_3         (0x8UL << ADC_CR2_JEXTSEL_Pos)                /*!< 0x00080000 */
N#define ADC_CR2_JEXTEN_Pos        (20U)                                        
N#define ADC_CR2_JEXTEN_Msk        (0x3UL << ADC_CR2_JEXTEN_Pos)                 /*!< 0x00300000 */
N#define ADC_CR2_JEXTEN            ADC_CR2_JEXTEN_Msk                           /*!<JEXTEN[1:0] bits (External Trigger Conversion mode for injected channelsp) */
N#define ADC_CR2_JEXTEN_0          (0x1UL << ADC_CR2_JEXTEN_Pos)                 /*!< 0x00100000 */
N#define ADC_CR2_JEXTEN_1          (0x2UL << ADC_CR2_JEXTEN_Pos)                 /*!< 0x00200000 */
N#define ADC_CR2_JSWSTART_Pos      (22U)                                        
N#define ADC_CR2_JSWSTART_Msk      (0x1UL << ADC_CR2_JSWSTART_Pos)               /*!< 0x00400000 */
N#define ADC_CR2_JSWSTART          ADC_CR2_JSWSTART_Msk                         /*!<Start Conversion of injected channels */
N#define ADC_CR2_EXTSEL_Pos        (24U)                                        
N#define ADC_CR2_EXTSEL_Msk        (0xFUL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x0F000000 */
N#define ADC_CR2_EXTSEL            ADC_CR2_EXTSEL_Msk                           /*!<EXTSEL[3:0] bits (External Event Select for regular group) */
N#define ADC_CR2_EXTSEL_0          (0x1UL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x01000000 */
N#define ADC_CR2_EXTSEL_1          (0x2UL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x02000000 */
N#define ADC_CR2_EXTSEL_2          (0x4UL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x04000000 */
N#define ADC_CR2_EXTSEL_3          (0x8UL << ADC_CR2_EXTSEL_Pos)                 /*!< 0x08000000 */
N#define ADC_CR2_EXTEN_Pos         (28U)                                        
N#define ADC_CR2_EXTEN_Msk         (0x3UL << ADC_CR2_EXTEN_Pos)                  /*!< 0x30000000 */
N#define ADC_CR2_EXTEN             ADC_CR2_EXTEN_Msk                            /*!<EXTEN[1:0] bits (External Trigger Conversion mode for regular channelsp) */
N#define ADC_CR2_EXTEN_0           (0x1UL << ADC_CR2_EXTEN_Pos)                  /*!< 0x10000000 */
N#define ADC_CR2_EXTEN_1           (0x2UL << ADC_CR2_EXTEN_Pos)                  /*!< 0x20000000 */
N#define ADC_CR2_SWSTART_Pos       (30U)                                        
N#define ADC_CR2_SWSTART_Msk       (0x1UL << ADC_CR2_SWSTART_Pos)                /*!< 0x40000000 */
N#define ADC_CR2_SWSTART           ADC_CR2_SWSTART_Msk                          /*!<Start Conversion of regular channels */
N
N/******************  Bit definition for ADC_SMPR1 register  *******************/
N#define ADC_SMPR1_SMP10_Pos       (0U)                                         
N#define ADC_SMPR1_SMP10_Msk       (0x7UL << ADC_SMPR1_SMP10_Pos)                /*!< 0x00000007 */
N#define ADC_SMPR1_SMP10           ADC_SMPR1_SMP10_Msk                          /*!<SMP10[2:0] bits (Channel 10 Sample time selection) */
N#define ADC_SMPR1_SMP10_0         (0x1UL << ADC_SMPR1_SMP10_Pos)                /*!< 0x00000001 */
N#define ADC_SMPR1_SMP10_1         (0x2UL << ADC_SMPR1_SMP10_Pos)                /*!< 0x00000002 */
N#define ADC_SMPR1_SMP10_2         (0x4UL << ADC_SMPR1_SMP10_Pos)                /*!< 0x00000004 */
N#define ADC_SMPR1_SMP11_Pos       (3U)                                         
N#define ADC_SMPR1_SMP11_Msk       (0x7UL << ADC_SMPR1_SMP11_Pos)                /*!< 0x00000038 */
N#define ADC_SMPR1_SMP11           ADC_SMPR1_SMP11_Msk                          /*!<SMP11[2:0] bits (Channel 11 Sample time selection) */
N#define ADC_SMPR1_SMP11_0         (0x1UL << ADC_SMPR1_SMP11_Pos)                /*!< 0x00000008 */
N#define ADC_SMPR1_SMP11_1         (0x2UL << ADC_SMPR1_SMP11_Pos)                /*!< 0x00000010 */
N#define ADC_SMPR1_SMP11_2         (0x4UL << ADC_SMPR1_SMP11_Pos)                /*!< 0x00000020 */
N#define ADC_SMPR1_SMP12_Pos       (6U)                                         
N#define ADC_SMPR1_SMP12_Msk       (0x7UL << ADC_SMPR1_SMP12_Pos)                /*!< 0x000001C0 */
N#define ADC_SMPR1_SMP12           ADC_SMPR1_SMP12_Msk                          /*!<SMP12[2:0] bits (Channel 12 Sample time selection) */
N#define ADC_SMPR1_SMP12_0         (0x1UL << ADC_SMPR1_SMP12_Pos)                /*!< 0x00000040 */
N#define ADC_SMPR1_SMP12_1         (0x2UL << ADC_SMPR1_SMP12_Pos)                /*!< 0x00000080 */
N#define ADC_SMPR1_SMP12_2         (0x4UL << ADC_SMPR1_SMP12_Pos)                /*!< 0x00000100 */
N#define ADC_SMPR1_SMP13_Pos       (9U)                                         
N#define ADC_SMPR1_SMP13_Msk       (0x7UL << ADC_SMPR1_SMP13_Pos)                /*!< 0x00000E00 */
N#define ADC_SMPR1_SMP13           ADC_SMPR1_SMP13_Msk                          /*!<SMP13[2:0] bits (Channel 13 Sample time selection) */
N#define ADC_SMPR1_SMP13_0         (0x1UL << ADC_SMPR1_SMP13_Pos)                /*!< 0x00000200 */
N#define ADC_SMPR1_SMP13_1         (0x2UL << ADC_SMPR1_SMP13_Pos)                /*!< 0x00000400 */
N#define ADC_SMPR1_SMP13_2         (0x4UL << ADC_SMPR1_SMP13_Pos)                /*!< 0x00000800 */
N#define ADC_SMPR1_SMP14_Pos       (12U)                                        
N#define ADC_SMPR1_SMP14_Msk       (0x7UL << ADC_SMPR1_SMP14_Pos)                /*!< 0x00007000 */
N#define ADC_SMPR1_SMP14           ADC_SMPR1_SMP14_Msk                          /*!<SMP14[2:0] bits (Channel 14 Sample time selection) */
N#define ADC_SMPR1_SMP14_0         (0x1UL << ADC_SMPR1_SMP14_Pos)                /*!< 0x00001000 */
N#define ADC_SMPR1_SMP14_1         (0x2UL << ADC_SMPR1_SMP14_Pos)                /*!< 0x00002000 */
N#define ADC_SMPR1_SMP14_2         (0x4UL << ADC_SMPR1_SMP14_Pos)                /*!< 0x00004000 */
N#define ADC_SMPR1_SMP15_Pos       (15U)                                        
N#define ADC_SMPR1_SMP15_Msk       (0x7UL << ADC_SMPR1_SMP15_Pos)                /*!< 0x00038000 */
N#define ADC_SMPR1_SMP15           ADC_SMPR1_SMP15_Msk                          /*!<SMP15[2:0] bits (Channel 15 Sample time selection) */
N#define ADC_SMPR1_SMP15_0         (0x1UL << ADC_SMPR1_SMP15_Pos)                /*!< 0x00008000 */
N#define ADC_SMPR1_SMP15_1         (0x2UL << ADC_SMPR1_SMP15_Pos)                /*!< 0x00010000 */
N#define ADC_SMPR1_SMP15_2         (0x4UL << ADC_SMPR1_SMP15_Pos)                /*!< 0x00020000 */
N#define ADC_SMPR1_SMP16_Pos       (18U)                                        
N#define ADC_SMPR1_SMP16_Msk       (0x7UL << ADC_SMPR1_SMP16_Pos)                /*!< 0x001C0000 */
N#define ADC_SMPR1_SMP16           ADC_SMPR1_SMP16_Msk                          /*!<SMP16[2:0] bits (Channel 16 Sample time selection) */
N#define ADC_SMPR1_SMP16_0         (0x1UL << ADC_SMPR1_SMP16_Pos)                /*!< 0x00040000 */
N#define ADC_SMPR1_SMP16_1         (0x2UL << ADC_SMPR1_SMP16_Pos)                /*!< 0x00080000 */
N#define ADC_SMPR1_SMP16_2         (0x4UL << ADC_SMPR1_SMP16_Pos)                /*!< 0x00100000 */
N#define ADC_SMPR1_SMP17_Pos       (21U)                                        
N#define ADC_SMPR1_SMP17_Msk       (0x7UL << ADC_SMPR1_SMP17_Pos)                /*!< 0x00E00000 */
N#define ADC_SMPR1_SMP17           ADC_SMPR1_SMP17_Msk                          /*!<SMP17[2:0] bits (Channel 17 Sample time selection) */
N#define ADC_SMPR1_SMP17_0         (0x1UL << ADC_SMPR1_SMP17_Pos)                /*!< 0x00200000 */
N#define ADC_SMPR1_SMP17_1         (0x2UL << ADC_SMPR1_SMP17_Pos)                /*!< 0x00400000 */
N#define ADC_SMPR1_SMP17_2         (0x4UL << ADC_SMPR1_SMP17_Pos)                /*!< 0x00800000 */
N#define ADC_SMPR1_SMP18_Pos       (24U)                                        
N#define ADC_SMPR1_SMP18_Msk       (0x7UL << ADC_SMPR1_SMP18_Pos)                /*!< 0x07000000 */
N#define ADC_SMPR1_SMP18           ADC_SMPR1_SMP18_Msk                          /*!<SMP18[2:0] bits (Channel 18 Sample time selection) */
N#define ADC_SMPR1_SMP18_0         (0x1UL << ADC_SMPR1_SMP18_Pos)                /*!< 0x01000000 */
N#define ADC_SMPR1_SMP18_1         (0x2UL << ADC_SMPR1_SMP18_Pos)                /*!< 0x02000000 */
N#define ADC_SMPR1_SMP18_2         (0x4UL << ADC_SMPR1_SMP18_Pos)                /*!< 0x04000000 */
N
N/******************  Bit definition for ADC_SMPR2 register  *******************/
N#define ADC_SMPR2_SMP0_Pos        (0U)                                         
N#define ADC_SMPR2_SMP0_Msk        (0x7UL << ADC_SMPR2_SMP0_Pos)                 /*!< 0x00000007 */
N#define ADC_SMPR2_SMP0            ADC_SMPR2_SMP0_Msk                           /*!<SMP0[2:0] bits (Channel 0 Sample time selection) */
N#define ADC_SMPR2_SMP0_0          (0x1UL << ADC_SMPR2_SMP0_Pos)                 /*!< 0x00000001 */
N#define ADC_SMPR2_SMP0_1          (0x2UL << ADC_SMPR2_SMP0_Pos)                 /*!< 0x00000002 */
N#define ADC_SMPR2_SMP0_2          (0x4UL << ADC_SMPR2_SMP0_Pos)                 /*!< 0x00000004 */
N#define ADC_SMPR2_SMP1_Pos        (3U)                                         
N#define ADC_SMPR2_SMP1_Msk        (0x7UL << ADC_SMPR2_SMP1_Pos)                 /*!< 0x00000038 */
N#define ADC_SMPR2_SMP1            ADC_SMPR2_SMP1_Msk                           /*!<SMP1[2:0] bits (Channel 1 Sample time selection) */
N#define ADC_SMPR2_SMP1_0          (0x1UL << ADC_SMPR2_SMP1_Pos)                 /*!< 0x00000008 */
N#define ADC_SMPR2_SMP1_1          (0x2UL << ADC_SMPR2_SMP1_Pos)                 /*!< 0x00000010 */
N#define ADC_SMPR2_SMP1_2          (0x4UL << ADC_SMPR2_SMP1_Pos)                 /*!< 0x00000020 */
N#define ADC_SMPR2_SMP2_Pos        (6U)                                         
N#define ADC_SMPR2_SMP2_Msk        (0x7UL << ADC_SMPR2_SMP2_Pos)                 /*!< 0x000001C0 */
N#define ADC_SMPR2_SMP2            ADC_SMPR2_SMP2_Msk                           /*!<SMP2[2:0] bits (Channel 2 Sample time selection) */
N#define ADC_SMPR2_SMP2_0          (0x1UL << ADC_SMPR2_SMP2_Pos)                 /*!< 0x00000040 */
N#define ADC_SMPR2_SMP2_1          (0x2UL << ADC_SMPR2_SMP2_Pos)                 /*!< 0x00000080 */
N#define ADC_SMPR2_SMP2_2          (0x4UL << ADC_SMPR2_SMP2_Pos)                 /*!< 0x00000100 */
N#define ADC_SMPR2_SMP3_Pos        (9U)                                         
N#define ADC_SMPR2_SMP3_Msk        (0x7UL << ADC_SMPR2_SMP3_Pos)                 /*!< 0x00000E00 */
N#define ADC_SMPR2_SMP3            ADC_SMPR2_SMP3_Msk                           /*!<SMP3[2:0] bits (Channel 3 Sample time selection) */
N#define ADC_SMPR2_SMP3_0          (0x1UL << ADC_SMPR2_SMP3_Pos)                 /*!< 0x00000200 */
N#define ADC_SMPR2_SMP3_1          (0x2UL << ADC_SMPR2_SMP3_Pos)                 /*!< 0x00000400 */
N#define ADC_SMPR2_SMP3_2          (0x4UL << ADC_SMPR2_SMP3_Pos)                 /*!< 0x00000800 */
N#define ADC_SMPR2_SMP4_Pos        (12U)                                        
N#define ADC_SMPR2_SMP4_Msk        (0x7UL << ADC_SMPR2_SMP4_Pos)                 /*!< 0x00007000 */
N#define ADC_SMPR2_SMP4            ADC_SMPR2_SMP4_Msk                           /*!<SMP4[2:0] bits (Channel 4 Sample time selection) */
N#define ADC_SMPR2_SMP4_0          (0x1UL << ADC_SMPR2_SMP4_Pos)                 /*!< 0x00001000 */
N#define ADC_SMPR2_SMP4_1          (0x2UL << ADC_SMPR2_SMP4_Pos)                 /*!< 0x00002000 */
N#define ADC_SMPR2_SMP4_2          (0x4UL << ADC_SMPR2_SMP4_Pos)                 /*!< 0x00004000 */
N#define ADC_SMPR2_SMP5_Pos        (15U)                                        
N#define ADC_SMPR2_SMP5_Msk        (0x7UL << ADC_SMPR2_SMP5_Pos)                 /*!< 0x00038000 */
N#define ADC_SMPR2_SMP5            ADC_SMPR2_SMP5_Msk                           /*!<SMP5[2:0] bits (Channel 5 Sample time selection) */
N#define ADC_SMPR2_SMP5_0          (0x1UL << ADC_SMPR2_SMP5_Pos)                 /*!< 0x00008000 */
N#define ADC_SMPR2_SMP5_1          (0x2UL << ADC_SMPR2_SMP5_Pos)                 /*!< 0x00010000 */
N#define ADC_SMPR2_SMP5_2          (0x4UL << ADC_SMPR2_SMP5_Pos)                 /*!< 0x00020000 */
N#define ADC_SMPR2_SMP6_Pos        (18U)                                        
N#define ADC_SMPR2_SMP6_Msk        (0x7UL << ADC_SMPR2_SMP6_Pos)                 /*!< 0x001C0000 */
N#define ADC_SMPR2_SMP6            ADC_SMPR2_SMP6_Msk                           /*!<SMP6[2:0] bits (Channel 6 Sample time selection) */
N#define ADC_SMPR2_SMP6_0          (0x1UL << ADC_SMPR2_SMP6_Pos)                 /*!< 0x00040000 */
N#define ADC_SMPR2_SMP6_1          (0x2UL << ADC_SMPR2_SMP6_Pos)                 /*!< 0x00080000 */
N#define ADC_SMPR2_SMP6_2          (0x4UL << ADC_SMPR2_SMP6_Pos)                 /*!< 0x00100000 */
N#define ADC_SMPR2_SMP7_Pos        (21U)                                        
N#define ADC_SMPR2_SMP7_Msk        (0x7UL << ADC_SMPR2_SMP7_Pos)                 /*!< 0x00E00000 */
N#define ADC_SMPR2_SMP7            ADC_SMPR2_SMP7_Msk                           /*!<SMP7[2:0] bits (Channel 7 Sample time selection) */
N#define ADC_SMPR2_SMP7_0          (0x1UL << ADC_SMPR2_SMP7_Pos)                 /*!< 0x00200000 */
N#define ADC_SMPR2_SMP7_1          (0x2UL << ADC_SMPR2_SMP7_Pos)                 /*!< 0x00400000 */
N#define ADC_SMPR2_SMP7_2          (0x4UL << ADC_SMPR2_SMP7_Pos)                 /*!< 0x00800000 */
N#define ADC_SMPR2_SMP8_Pos        (24U)                                        
N#define ADC_SMPR2_SMP8_Msk        (0x7UL << ADC_SMPR2_SMP8_Pos)                 /*!< 0x07000000 */
N#define ADC_SMPR2_SMP8            ADC_SMPR2_SMP8_Msk                           /*!<SMP8[2:0] bits (Channel 8 Sample time selection) */
N#define ADC_SMPR2_SMP8_0          (0x1UL << ADC_SMPR2_SMP8_Pos)                 /*!< 0x01000000 */
N#define ADC_SMPR2_SMP8_1          (0x2UL << ADC_SMPR2_SMP8_Pos)                 /*!< 0x02000000 */
N#define ADC_SMPR2_SMP8_2          (0x4UL << ADC_SMPR2_SMP8_Pos)                 /*!< 0x04000000 */
N#define ADC_SMPR2_SMP9_Pos        (27U)                                        
N#define ADC_SMPR2_SMP9_Msk        (0x7UL << ADC_SMPR2_SMP9_Pos)                 /*!< 0x38000000 */
N#define ADC_SMPR2_SMP9            ADC_SMPR2_SMP9_Msk                           /*!<SMP9[2:0] bits (Channel 9 Sample time selection) */
N#define ADC_SMPR2_SMP9_0          (0x1UL << ADC_SMPR2_SMP9_Pos)                 /*!< 0x08000000 */
N#define ADC_SMPR2_SMP9_1          (0x2UL << ADC_SMPR2_SMP9_Pos)                 /*!< 0x10000000 */
N#define ADC_SMPR2_SMP9_2          (0x4UL << ADC_SMPR2_SMP9_Pos)                 /*!< 0x20000000 */
N
N/******************  Bit definition for ADC_JOFR1 register  *******************/
N#define ADC_JOFR1_JOFFSET1_Pos    (0U)                                         
N#define ADC_JOFR1_JOFFSET1_Msk    (0xFFFUL << ADC_JOFR1_JOFFSET1_Pos)           /*!< 0x00000FFF */
N#define ADC_JOFR1_JOFFSET1        ADC_JOFR1_JOFFSET1_Msk                       /*!<Data offset for injected channel 1 */
N
N/******************  Bit definition for ADC_JOFR2 register  *******************/
N#define ADC_JOFR2_JOFFSET2_Pos    (0U)                                         
N#define ADC_JOFR2_JOFFSET2_Msk    (0xFFFUL << ADC_JOFR2_JOFFSET2_Pos)           /*!< 0x00000FFF */
N#define ADC_JOFR2_JOFFSET2        ADC_JOFR2_JOFFSET2_Msk                       /*!<Data offset for injected channel 2 */
N
N/******************  Bit definition for ADC_JOFR3 register  *******************/
N#define ADC_JOFR3_JOFFSET3_Pos    (0U)                                         
N#define ADC_JOFR3_JOFFSET3_Msk    (0xFFFUL << ADC_JOFR3_JOFFSET3_Pos)           /*!< 0x00000FFF */
N#define ADC_JOFR3_JOFFSET3        ADC_JOFR3_JOFFSET3_Msk                       /*!<Data offset for injected channel 3 */
N
N/******************  Bit definition for ADC_JOFR4 register  *******************/
N#define ADC_JOFR4_JOFFSET4_Pos    (0U)                                         
N#define ADC_JOFR4_JOFFSET4_Msk    (0xFFFUL << ADC_JOFR4_JOFFSET4_Pos)           /*!< 0x00000FFF */
N#define ADC_JOFR4_JOFFSET4        ADC_JOFR4_JOFFSET4_Msk                       /*!<Data offset for injected channel 4 */
N
N/*******************  Bit definition for ADC_HTR register  ********************/
N#define ADC_HTR_HT_Pos            (0U)                                         
N#define ADC_HTR_HT_Msk            (0xFFFUL << ADC_HTR_HT_Pos)                   /*!< 0x00000FFF */
N#define ADC_HTR_HT                ADC_HTR_HT_Msk                               /*!<Analog watchdog high threshold */
N
N/*******************  Bit definition for ADC_LTR register  ********************/
N#define ADC_LTR_LT_Pos            (0U)                                         
N#define ADC_LTR_LT_Msk            (0xFFFUL << ADC_LTR_LT_Pos)                   /*!< 0x00000FFF */
N#define ADC_LTR_LT                ADC_LTR_LT_Msk                               /*!<Analog watchdog low threshold */
N
N/*******************  Bit definition for ADC_SQR1 register  *******************/
N#define ADC_SQR1_SQ13_Pos         (0U)                                         
N#define ADC_SQR1_SQ13_Msk         (0x1FUL << ADC_SQR1_SQ13_Pos)                 /*!< 0x0000001F */
N#define ADC_SQR1_SQ13             ADC_SQR1_SQ13_Msk                            /*!<SQ13[4:0] bits (13th conversion in regular sequence) */
N#define ADC_SQR1_SQ13_0           (0x01UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000001 */
N#define ADC_SQR1_SQ13_1           (0x02UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000002 */
N#define ADC_SQR1_SQ13_2           (0x04UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000004 */
N#define ADC_SQR1_SQ13_3           (0x08UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000008 */
N#define ADC_SQR1_SQ13_4           (0x10UL << ADC_SQR1_SQ13_Pos)                 /*!< 0x00000010 */
N#define ADC_SQR1_SQ14_Pos         (5U)                                         
N#define ADC_SQR1_SQ14_Msk         (0x1FUL << ADC_SQR1_SQ14_Pos)                 /*!< 0x000003E0 */
N#define ADC_SQR1_SQ14             ADC_SQR1_SQ14_Msk                            /*!<SQ14[4:0] bits (14th conversion in regular sequence) */
N#define ADC_SQR1_SQ14_0           (0x01UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000020 */
N#define ADC_SQR1_SQ14_1           (0x02UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000040 */
N#define ADC_SQR1_SQ14_2           (0x04UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000080 */
N#define ADC_SQR1_SQ14_3           (0x08UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000100 */
N#define ADC_SQR1_SQ14_4           (0x10UL << ADC_SQR1_SQ14_Pos)                 /*!< 0x00000200 */
N#define ADC_SQR1_SQ15_Pos         (10U)                                        
N#define ADC_SQR1_SQ15_Msk         (0x1FUL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00007C00 */
N#define ADC_SQR1_SQ15             ADC_SQR1_SQ15_Msk                            /*!<SQ15[4:0] bits (15th conversion in regular sequence) */
N#define ADC_SQR1_SQ15_0           (0x01UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00000400 */
N#define ADC_SQR1_SQ15_1           (0x02UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00000800 */
N#define ADC_SQR1_SQ15_2           (0x04UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00001000 */
N#define ADC_SQR1_SQ15_3           (0x08UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00002000 */
N#define ADC_SQR1_SQ15_4           (0x10UL << ADC_SQR1_SQ15_Pos)                 /*!< 0x00004000 */
N#define ADC_SQR1_SQ16_Pos         (15U)                                        
N#define ADC_SQR1_SQ16_Msk         (0x1FUL << ADC_SQR1_SQ16_Pos)                 /*!< 0x000F8000 */
N#define ADC_SQR1_SQ16             ADC_SQR1_SQ16_Msk                            /*!<SQ16[4:0] bits (16th conversion in regular sequence) */
N#define ADC_SQR1_SQ16_0           (0x01UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00008000 */
N#define ADC_SQR1_SQ16_1           (0x02UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00010000 */
N#define ADC_SQR1_SQ16_2           (0x04UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00020000 */
N#define ADC_SQR1_SQ16_3           (0x08UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00040000 */
N#define ADC_SQR1_SQ16_4           (0x10UL << ADC_SQR1_SQ16_Pos)                 /*!< 0x00080000 */
N#define ADC_SQR1_L_Pos            (20U)                                        
N#define ADC_SQR1_L_Msk            (0xFUL << ADC_SQR1_L_Pos)                     /*!< 0x00F00000 */
N#define ADC_SQR1_L                ADC_SQR1_L_Msk                               /*!<L[3:0] bits (Regular channel sequence length) */
N#define ADC_SQR1_L_0              (0x1UL << ADC_SQR1_L_Pos)                     /*!< 0x00100000 */
N#define ADC_SQR1_L_1              (0x2UL << ADC_SQR1_L_Pos)                     /*!< 0x00200000 */
N#define ADC_SQR1_L_2              (0x4UL << ADC_SQR1_L_Pos)                     /*!< 0x00400000 */
N#define ADC_SQR1_L_3              (0x8UL << ADC_SQR1_L_Pos)                     /*!< 0x00800000 */
N
N/*******************  Bit definition for ADC_SQR2 register  *******************/
N#define ADC_SQR2_SQ7_Pos          (0U)                                         
N#define ADC_SQR2_SQ7_Msk          (0x1FUL << ADC_SQR2_SQ7_Pos)                  /*!< 0x0000001F */
N#define ADC_SQR2_SQ7              ADC_SQR2_SQ7_Msk                             /*!<SQ7[4:0] bits (7th conversion in regular sequence) */
N#define ADC_SQR2_SQ7_0            (0x01UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000001 */
N#define ADC_SQR2_SQ7_1            (0x02UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000002 */
N#define ADC_SQR2_SQ7_2            (0x04UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000004 */
N#define ADC_SQR2_SQ7_3            (0x08UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000008 */
N#define ADC_SQR2_SQ7_4            (0x10UL << ADC_SQR2_SQ7_Pos)                  /*!< 0x00000010 */
N#define ADC_SQR2_SQ8_Pos          (5U)                                         
N#define ADC_SQR2_SQ8_Msk          (0x1FUL << ADC_SQR2_SQ8_Pos)                  /*!< 0x000003E0 */
N#define ADC_SQR2_SQ8              ADC_SQR2_SQ8_Msk                             /*!<SQ8[4:0] bits (8th conversion in regular sequence) */
N#define ADC_SQR2_SQ8_0            (0x01UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000020 */
N#define ADC_SQR2_SQ8_1            (0x02UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000040 */
N#define ADC_SQR2_SQ8_2            (0x04UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000080 */
N#define ADC_SQR2_SQ8_3            (0x08UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000100 */
N#define ADC_SQR2_SQ8_4            (0x10UL << ADC_SQR2_SQ8_Pos)                  /*!< 0x00000200 */
N#define ADC_SQR2_SQ9_Pos          (10U)                                        
N#define ADC_SQR2_SQ9_Msk          (0x1FUL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00007C00 */
N#define ADC_SQR2_SQ9              ADC_SQR2_SQ9_Msk                             /*!<SQ9[4:0] bits (9th conversion in regular sequence) */
N#define ADC_SQR2_SQ9_0            (0x01UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00000400 */
N#define ADC_SQR2_SQ9_1            (0x02UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00000800 */
N#define ADC_SQR2_SQ9_2            (0x04UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00001000 */
N#define ADC_SQR2_SQ9_3            (0x08UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00002000 */
N#define ADC_SQR2_SQ9_4            (0x10UL << ADC_SQR2_SQ9_Pos)                  /*!< 0x00004000 */
N#define ADC_SQR2_SQ10_Pos         (15U)                                        
N#define ADC_SQR2_SQ10_Msk         (0x1FUL << ADC_SQR2_SQ10_Pos)                 /*!< 0x000F8000 */
N#define ADC_SQR2_SQ10             ADC_SQR2_SQ10_Msk                            /*!<SQ10[4:0] bits (10th conversion in regular sequence) */
N#define ADC_SQR2_SQ10_0           (0x01UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00008000 */
N#define ADC_SQR2_SQ10_1           (0x02UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00010000 */
N#define ADC_SQR2_SQ10_2           (0x04UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00020000 */
N#define ADC_SQR2_SQ10_3           (0x08UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00040000 */
N#define ADC_SQR2_SQ10_4           (0x10UL << ADC_SQR2_SQ10_Pos)                 /*!< 0x00080000 */
N#define ADC_SQR2_SQ11_Pos         (20U)                                        
N#define ADC_SQR2_SQ11_Msk         (0x1FUL << ADC_SQR2_SQ11_Pos)                 /*!< 0x01F00000 */
N#define ADC_SQR2_SQ11             ADC_SQR2_SQ11_Msk                            /*!<SQ11[4:0] bits (11th conversion in regular sequence) */
N#define ADC_SQR2_SQ11_0           (0x01UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x00100000 */
N#define ADC_SQR2_SQ11_1           (0x02UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x00200000 */
N#define ADC_SQR2_SQ11_2           (0x04UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x00400000 */
N#define ADC_SQR2_SQ11_3           (0x08UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x00800000 */
N#define ADC_SQR2_SQ11_4           (0x10UL << ADC_SQR2_SQ11_Pos)                 /*!< 0x01000000 */
N#define ADC_SQR2_SQ12_Pos         (25U)                                        
N#define ADC_SQR2_SQ12_Msk         (0x1FUL << ADC_SQR2_SQ12_Pos)                 /*!< 0x3E000000 */
N#define ADC_SQR2_SQ12             ADC_SQR2_SQ12_Msk                            /*!<SQ12[4:0] bits (12th conversion in regular sequence) */
N#define ADC_SQR2_SQ12_0           (0x01UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x02000000 */
N#define ADC_SQR2_SQ12_1           (0x02UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x04000000 */
N#define ADC_SQR2_SQ12_2           (0x04UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x08000000 */
N#define ADC_SQR2_SQ12_3           (0x08UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x10000000 */
N#define ADC_SQR2_SQ12_4           (0x10UL << ADC_SQR2_SQ12_Pos)                 /*!< 0x20000000 */
N
N/*******************  Bit definition for ADC_SQR3 register  *******************/
N#define ADC_SQR3_SQ1_Pos          (0U)                                         
N#define ADC_SQR3_SQ1_Msk          (0x1FUL << ADC_SQR3_SQ1_Pos)                  /*!< 0x0000001F */
N#define ADC_SQR3_SQ1              ADC_SQR3_SQ1_Msk                             /*!<SQ1[4:0] bits (1st conversion in regular sequence) */
N#define ADC_SQR3_SQ1_0            (0x01UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000001 */
N#define ADC_SQR3_SQ1_1            (0x02UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000002 */
N#define ADC_SQR3_SQ1_2            (0x04UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000004 */
N#define ADC_SQR3_SQ1_3            (0x08UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000008 */
N#define ADC_SQR3_SQ1_4            (0x10UL << ADC_SQR3_SQ1_Pos)                  /*!< 0x00000010 */
N#define ADC_SQR3_SQ2_Pos          (5U)                                         
N#define ADC_SQR3_SQ2_Msk          (0x1FUL << ADC_SQR3_SQ2_Pos)                  /*!< 0x000003E0 */
N#define ADC_SQR3_SQ2              ADC_SQR3_SQ2_Msk                             /*!<SQ2[4:0] bits (2nd conversion in regular sequence) */
N#define ADC_SQR3_SQ2_0            (0x01UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000020 */
N#define ADC_SQR3_SQ2_1            (0x02UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000040 */
N#define ADC_SQR3_SQ2_2            (0x04UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000080 */
N#define ADC_SQR3_SQ2_3            (0x08UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000100 */
N#define ADC_SQR3_SQ2_4            (0x10UL << ADC_SQR3_SQ2_Pos)                  /*!< 0x00000200 */
N#define ADC_SQR3_SQ3_Pos          (10U)                                        
N#define ADC_SQR3_SQ3_Msk          (0x1FUL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00007C00 */
N#define ADC_SQR3_SQ3              ADC_SQR3_SQ3_Msk                             /*!<SQ3[4:0] bits (3rd conversion in regular sequence) */
N#define ADC_SQR3_SQ3_0            (0x01UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00000400 */
N#define ADC_SQR3_SQ3_1            (0x02UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00000800 */
N#define ADC_SQR3_SQ3_2            (0x04UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00001000 */
N#define ADC_SQR3_SQ3_3            (0x08UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00002000 */
N#define ADC_SQR3_SQ3_4            (0x10UL << ADC_SQR3_SQ3_Pos)                  /*!< 0x00004000 */
N#define ADC_SQR3_SQ4_Pos          (15U)                                        
N#define ADC_SQR3_SQ4_Msk          (0x1FUL << ADC_SQR3_SQ4_Pos)                  /*!< 0x000F8000 */
N#define ADC_SQR3_SQ4              ADC_SQR3_SQ4_Msk                             /*!<SQ4[4:0] bits (4th conversion in regular sequence) */
N#define ADC_SQR3_SQ4_0            (0x01UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00008000 */
N#define ADC_SQR3_SQ4_1            (0x02UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00010000 */
N#define ADC_SQR3_SQ4_2            (0x04UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00020000 */
N#define ADC_SQR3_SQ4_3            (0x08UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00040000 */
N#define ADC_SQR3_SQ4_4            (0x10UL << ADC_SQR3_SQ4_Pos)                  /*!< 0x00080000 */
N#define ADC_SQR3_SQ5_Pos          (20U)                                        
N#define ADC_SQR3_SQ5_Msk          (0x1FUL << ADC_SQR3_SQ5_Pos)                  /*!< 0x01F00000 */
N#define ADC_SQR3_SQ5              ADC_SQR3_SQ5_Msk                             /*!<SQ5[4:0] bits (5th conversion in regular sequence) */
N#define ADC_SQR3_SQ5_0            (0x01UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x00100000 */
N#define ADC_SQR3_SQ5_1            (0x02UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x00200000 */
N#define ADC_SQR3_SQ5_2            (0x04UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x00400000 */
N#define ADC_SQR3_SQ5_3            (0x08UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x00800000 */
N#define ADC_SQR3_SQ5_4            (0x10UL << ADC_SQR3_SQ5_Pos)                  /*!< 0x01000000 */
N#define ADC_SQR3_SQ6_Pos          (25U)                                        
N#define ADC_SQR3_SQ6_Msk          (0x1FUL << ADC_SQR3_SQ6_Pos)                  /*!< 0x3E000000 */
N#define ADC_SQR3_SQ6              ADC_SQR3_SQ6_Msk                             /*!<SQ6[4:0] bits (6th conversion in regular sequence) */
N#define ADC_SQR3_SQ6_0            (0x01UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x02000000 */
N#define ADC_SQR3_SQ6_1            (0x02UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x04000000 */
N#define ADC_SQR3_SQ6_2            (0x04UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x08000000 */
N#define ADC_SQR3_SQ6_3            (0x08UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x10000000 */
N#define ADC_SQR3_SQ6_4            (0x10UL << ADC_SQR3_SQ6_Pos)                  /*!< 0x20000000 */
N
N/*******************  Bit definition for ADC_JSQR register  *******************/
N#define ADC_JSQR_JSQ1_Pos         (0U)                                         
N#define ADC_JSQR_JSQ1_Msk         (0x1FUL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x0000001F */
N#define ADC_JSQR_JSQ1             ADC_JSQR_JSQ1_Msk                            /*!<JSQ1[4:0] bits (1st conversion in injected sequence) */  
N#define ADC_JSQR_JSQ1_0           (0x01UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000001 */
N#define ADC_JSQR_JSQ1_1           (0x02UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000002 */
N#define ADC_JSQR_JSQ1_2           (0x04UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000004 */
N#define ADC_JSQR_JSQ1_3           (0x08UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000008 */
N#define ADC_JSQR_JSQ1_4           (0x10UL << ADC_JSQR_JSQ1_Pos)                 /*!< 0x00000010 */
N#define ADC_JSQR_JSQ2_Pos         (5U)                                         
N#define ADC_JSQR_JSQ2_Msk         (0x1FUL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x000003E0 */
N#define ADC_JSQR_JSQ2             ADC_JSQR_JSQ2_Msk                            /*!<JSQ2[4:0] bits (2nd conversion in injected sequence) */
N#define ADC_JSQR_JSQ2_0           (0x01UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000020 */
N#define ADC_JSQR_JSQ2_1           (0x02UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000040 */
N#define ADC_JSQR_JSQ2_2           (0x04UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000080 */
N#define ADC_JSQR_JSQ2_3           (0x08UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000100 */
N#define ADC_JSQR_JSQ2_4           (0x10UL << ADC_JSQR_JSQ2_Pos)                 /*!< 0x00000200 */
N#define ADC_JSQR_JSQ3_Pos         (10U)                                        
N#define ADC_JSQR_JSQ3_Msk         (0x1FUL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00007C00 */
N#define ADC_JSQR_JSQ3             ADC_JSQR_JSQ3_Msk                            /*!<JSQ3[4:0] bits (3rd conversion in injected sequence) */
N#define ADC_JSQR_JSQ3_0           (0x01UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00000400 */
N#define ADC_JSQR_JSQ3_1           (0x02UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00000800 */
N#define ADC_JSQR_JSQ3_2           (0x04UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00001000 */
N#define ADC_JSQR_JSQ3_3           (0x08UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00002000 */
N#define ADC_JSQR_JSQ3_4           (0x10UL << ADC_JSQR_JSQ3_Pos)                 /*!< 0x00004000 */
N#define ADC_JSQR_JSQ4_Pos         (15U)                                        
N#define ADC_JSQR_JSQ4_Msk         (0x1FUL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x000F8000 */
N#define ADC_JSQR_JSQ4             ADC_JSQR_JSQ4_Msk                            /*!<JSQ4[4:0] bits (4th conversion in injected sequence) */
N#define ADC_JSQR_JSQ4_0           (0x01UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00008000 */
N#define ADC_JSQR_JSQ4_1           (0x02UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00010000 */
N#define ADC_JSQR_JSQ4_2           (0x04UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00020000 */
N#define ADC_JSQR_JSQ4_3           (0x08UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00040000 */
N#define ADC_JSQR_JSQ4_4           (0x10UL << ADC_JSQR_JSQ4_Pos)                 /*!< 0x00080000 */
N#define ADC_JSQR_JL_Pos           (20U)                                        
N#define ADC_JSQR_JL_Msk           (0x3UL << ADC_JSQR_JL_Pos)                    /*!< 0x00300000 */
N#define ADC_JSQR_JL               ADC_JSQR_JL_Msk                              /*!<JL[1:0] bits (Injected Sequence length) */
N#define ADC_JSQR_JL_0             (0x1UL << ADC_JSQR_JL_Pos)                    /*!< 0x00100000 */
N#define ADC_JSQR_JL_1             (0x2UL << ADC_JSQR_JL_Pos)                    /*!< 0x00200000 */
N
N/*******************  Bit definition for ADC_JDR1 register  *******************/
N#define ADC_JDR1_JDATA_Pos        (0U)                                         
N#define ADC_JDR1_JDATA_Msk        (0xFFFFUL << ADC_JDR1_JDATA_Pos)              /*!< 0x0000FFFF */
N#define ADC_JDR1_JDATA            ADC_JDR1_JDATA_Msk                           /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR2 register  *******************/
N#define ADC_JDR2_JDATA_Pos        (0U)                                         
N#define ADC_JDR2_JDATA_Msk        (0xFFFFUL << ADC_JDR2_JDATA_Pos)              /*!< 0x0000FFFF */
N#define ADC_JDR2_JDATA            ADC_JDR2_JDATA_Msk                           /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR3 register  *******************/
N#define ADC_JDR3_JDATA_Pos        (0U)                                         
N#define ADC_JDR3_JDATA_Msk        (0xFFFFUL << ADC_JDR3_JDATA_Pos)              /*!< 0x0000FFFF */
N#define ADC_JDR3_JDATA            ADC_JDR3_JDATA_Msk                           /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR4 register  *******************/
N#define ADC_JDR4_JDATA_Pos        (0U)                                         
N#define ADC_JDR4_JDATA_Msk        (0xFFFFUL << ADC_JDR4_JDATA_Pos)              /*!< 0x0000FFFF */
N#define ADC_JDR4_JDATA            ADC_JDR4_JDATA_Msk                           /*!<Injected data */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define ADC_DR_DATA_Pos           (0U)                                         
N#define ADC_DR_DATA_Msk           (0xFFFFUL << ADC_DR_DATA_Pos)                 /*!< 0x0000FFFF */
N#define ADC_DR_DATA               ADC_DR_DATA_Msk                              /*!<Regular data */
N#define ADC_DR_ADC2DATA_Pos       (16U)                                        
N#define ADC_DR_ADC2DATA_Msk       (0xFFFFUL << ADC_DR_ADC2DATA_Pos)             /*!< 0xFFFF0000 */
N#define ADC_DR_ADC2DATA           ADC_DR_ADC2DATA_Msk                          /*!<ADC2 data */
N
N/*******************  Bit definition for ADC_CSR register  ********************/
N#define ADC_CSR_AWD1_Pos          (0U)                                         
N#define ADC_CSR_AWD1_Msk          (0x1UL << ADC_CSR_AWD1_Pos)                   /*!< 0x00000001 */
N#define ADC_CSR_AWD1              ADC_CSR_AWD1_Msk                             /*!<ADC1 Analog watchdog flag */
N#define ADC_CSR_EOC1_Pos          (1U)                                         
N#define ADC_CSR_EOC1_Msk          (0x1UL << ADC_CSR_EOC1_Pos)                   /*!< 0x00000002 */
N#define ADC_CSR_EOC1              ADC_CSR_EOC1_Msk                             /*!<ADC1 End of conversion */
N#define ADC_CSR_JEOC1_Pos         (2U)                                         
N#define ADC_CSR_JEOC1_Msk         (0x1UL << ADC_CSR_JEOC1_Pos)                  /*!< 0x00000004 */
N#define ADC_CSR_JEOC1             ADC_CSR_JEOC1_Msk                            /*!<ADC1 Injected channel end of conversion */
N#define ADC_CSR_JSTRT1_Pos        (3U)                                         
N#define ADC_CSR_JSTRT1_Msk        (0x1UL << ADC_CSR_JSTRT1_Pos)                 /*!< 0x00000008 */
N#define ADC_CSR_JSTRT1            ADC_CSR_JSTRT1_Msk                           /*!<ADC1 Injected channel Start flag */
N#define ADC_CSR_STRT1_Pos         (4U)                                         
N#define ADC_CSR_STRT1_Msk         (0x1UL << ADC_CSR_STRT1_Pos)                  /*!< 0x00000010 */
N#define ADC_CSR_STRT1             ADC_CSR_STRT1_Msk                            /*!<ADC1 Regular channel Start flag */
N#define ADC_CSR_OVR1_Pos          (5U)                                         
N#define ADC_CSR_OVR1_Msk          (0x1UL << ADC_CSR_OVR1_Pos)                   /*!< 0x00000020 */
N#define ADC_CSR_OVR1              ADC_CSR_OVR1_Msk                             /*!<ADC1 DMA overrun  flag */
N
N/* Legacy defines */
N#define  ADC_CSR_DOVR1                        ADC_CSR_OVR1
N
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define ADC_CCR_MULTI_Pos         (0U)                                         
N#define ADC_CCR_MULTI_Msk         (0x1FUL << ADC_CCR_MULTI_Pos)                 /*!< 0x0000001F */
N#define ADC_CCR_MULTI             ADC_CCR_MULTI_Msk                            /*!<MULTI[4:0] bits (Multi-ADC mode selection) */  
N#define ADC_CCR_MULTI_0           (0x01UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000001 */
N#define ADC_CCR_MULTI_1           (0x02UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000002 */
N#define ADC_CCR_MULTI_2           (0x04UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000004 */
N#define ADC_CCR_MULTI_3           (0x08UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000008 */
N#define ADC_CCR_MULTI_4           (0x10UL << ADC_CCR_MULTI_Pos)                 /*!< 0x00000010 */
N#define ADC_CCR_DELAY_Pos         (8U)                                         
N#define ADC_CCR_DELAY_Msk         (0xFUL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000F00 */
N#define ADC_CCR_DELAY             ADC_CCR_DELAY_Msk                            /*!<DELAY[3:0] bits (Delay between 2 sampling phases) */  
N#define ADC_CCR_DELAY_0           (0x1UL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000100 */
N#define ADC_CCR_DELAY_1           (0x2UL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000200 */
N#define ADC_CCR_DELAY_2           (0x4UL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000400 */
N#define ADC_CCR_DELAY_3           (0x8UL << ADC_CCR_DELAY_Pos)                  /*!< 0x00000800 */
N#define ADC_CCR_DDS_Pos           (13U)                                        
N#define ADC_CCR_DDS_Msk           (0x1UL << ADC_CCR_DDS_Pos)                    /*!< 0x00002000 */
N#define ADC_CCR_DDS               ADC_CCR_DDS_Msk                              /*!<DMA disable selection (Multi-ADC mode) */
N#define ADC_CCR_DMA_Pos           (14U)                                        
N#define ADC_CCR_DMA_Msk           (0x3UL << ADC_CCR_DMA_Pos)                    /*!< 0x0000C000 */
N#define ADC_CCR_DMA               ADC_CCR_DMA_Msk                              /*!<DMA[1:0] bits (Direct Memory Access mode for multimode) */  
N#define ADC_CCR_DMA_0             (0x1UL << ADC_CCR_DMA_Pos)                    /*!< 0x00004000 */
N#define ADC_CCR_DMA_1             (0x2UL << ADC_CCR_DMA_Pos)                    /*!< 0x00008000 */
N#define ADC_CCR_ADCPRE_Pos        (16U)                                        
N#define ADC_CCR_ADCPRE_Msk        (0x3UL << ADC_CCR_ADCPRE_Pos)                 /*!< 0x00030000 */
N#define ADC_CCR_ADCPRE            ADC_CCR_ADCPRE_Msk                           /*!<ADCPRE[1:0] bits (ADC prescaler) */  
N#define ADC_CCR_ADCPRE_0          (0x1UL << ADC_CCR_ADCPRE_Pos)                 /*!< 0x00010000 */
N#define ADC_CCR_ADCPRE_1          (0x2UL << ADC_CCR_ADCPRE_Pos)                 /*!< 0x00020000 */
N#define ADC_CCR_VBATE_Pos         (22U)                                        
N#define ADC_CCR_VBATE_Msk         (0x1UL << ADC_CCR_VBATE_Pos)                  /*!< 0x00400000 */
N#define ADC_CCR_VBATE             ADC_CCR_VBATE_Msk                            /*!<VBAT Enable */
N#define ADC_CCR_TSVREFE_Pos       (23U)                                        
N#define ADC_CCR_TSVREFE_Msk       (0x1UL << ADC_CCR_TSVREFE_Pos)                /*!< 0x00800000 */
N#define ADC_CCR_TSVREFE           ADC_CCR_TSVREFE_Msk                          /*!<Temperature Sensor and VREFINT Enable */
N
N/*******************  Bit definition for ADC_CDR register  ********************/
N#define ADC_CDR_DATA1_Pos         (0U)                                         
N#define ADC_CDR_DATA1_Msk         (0xFFFFUL << ADC_CDR_DATA1_Pos)               /*!< 0x0000FFFF */
N#define ADC_CDR_DATA1             ADC_CDR_DATA1_Msk                            /*!<1st data of a pair of regular conversions */
N#define ADC_CDR_DATA2_Pos         (16U)                                        
N#define ADC_CDR_DATA2_Msk         (0xFFFFUL << ADC_CDR_DATA2_Pos)               /*!< 0xFFFF0000 */
N#define ADC_CDR_DATA2             ADC_CDR_DATA2_Msk                            /*!<2nd data of a pair of regular conversions */
N
N/* Legacy defines */
N#define ADC_CDR_RDATA_MST         ADC_CDR_DATA1
N#define ADC_CDR_RDATA_SLV         ADC_CDR_DATA2
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRC calculation unit                              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define CRC_DR_DR_Pos       (0U)                                               
N#define CRC_DR_DR_Msk       (0xFFFFFFFFUL << CRC_DR_DR_Pos)                     /*!< 0xFFFFFFFF */
N#define CRC_DR_DR           CRC_DR_DR_Msk                                      /*!< Data register bits */
N
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define CRC_IDR_IDR_Pos     (0U)                                               
N#define CRC_IDR_IDR_Msk     (0xFFUL << CRC_IDR_IDR_Pos)                         /*!< 0x000000FF */
N#define CRC_IDR_IDR         CRC_IDR_IDR_Msk                                    /*!< General-purpose 8-bit data register bits */
N
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define CRC_CR_RESET_Pos    (0U)                                               
N#define CRC_CR_RESET_Msk    (0x1UL << CRC_CR_RESET_Pos)                         /*!< 0x00000001 */
N#define CRC_CR_RESET        CRC_CR_RESET_Msk                                   /*!< RESET bit */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                             DMA Controller                                 */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for DMA_SxCR register  *****************/
N#define DMA_SxCR_CHSEL_Pos       (25U)                                         
N#define DMA_SxCR_CHSEL_Msk       (0x7UL << DMA_SxCR_CHSEL_Pos)                  /*!< 0x0E000000 */
N#define DMA_SxCR_CHSEL           DMA_SxCR_CHSEL_Msk                            
N#define DMA_SxCR_CHSEL_0         0x02000000U                                   
N#define DMA_SxCR_CHSEL_1         0x04000000U                                   
N#define DMA_SxCR_CHSEL_2         0x08000000U                                   
N#define DMA_SxCR_MBURST_Pos      (23U)                                         
N#define DMA_SxCR_MBURST_Msk      (0x3UL << DMA_SxCR_MBURST_Pos)                 /*!< 0x01800000 */
N#define DMA_SxCR_MBURST          DMA_SxCR_MBURST_Msk                           
N#define DMA_SxCR_MBURST_0        (0x1UL << DMA_SxCR_MBURST_Pos)                 /*!< 0x00800000 */
N#define DMA_SxCR_MBURST_1        (0x2UL << DMA_SxCR_MBURST_Pos)                 /*!< 0x01000000 */
N#define DMA_SxCR_PBURST_Pos      (21U)                                         
N#define DMA_SxCR_PBURST_Msk      (0x3UL << DMA_SxCR_PBURST_Pos)                 /*!< 0x00600000 */
N#define DMA_SxCR_PBURST          DMA_SxCR_PBURST_Msk                           
N#define DMA_SxCR_PBURST_0        (0x1UL << DMA_SxCR_PBURST_Pos)                 /*!< 0x00200000 */
N#define DMA_SxCR_PBURST_1        (0x2UL << DMA_SxCR_PBURST_Pos)                 /*!< 0x00400000 */
N#define DMA_SxCR_CT_Pos          (19U)                                         
N#define DMA_SxCR_CT_Msk          (0x1UL << DMA_SxCR_CT_Pos)                     /*!< 0x00080000 */
N#define DMA_SxCR_CT              DMA_SxCR_CT_Msk                               
N#define DMA_SxCR_DBM_Pos         (18U)                                         
N#define DMA_SxCR_DBM_Msk         (0x1UL << DMA_SxCR_DBM_Pos)                    /*!< 0x00040000 */
N#define DMA_SxCR_DBM             DMA_SxCR_DBM_Msk                              
N#define DMA_SxCR_PL_Pos          (16U)                                         
N#define DMA_SxCR_PL_Msk          (0x3UL << DMA_SxCR_PL_Pos)                     /*!< 0x00030000 */
N#define DMA_SxCR_PL              DMA_SxCR_PL_Msk                               
N#define DMA_SxCR_PL_0            (0x1UL << DMA_SxCR_PL_Pos)                     /*!< 0x00010000 */
N#define DMA_SxCR_PL_1            (0x2UL << DMA_SxCR_PL_Pos)                     /*!< 0x00020000 */
N#define DMA_SxCR_PINCOS_Pos      (15U)                                         
N#define DMA_SxCR_PINCOS_Msk      (0x1UL << DMA_SxCR_PINCOS_Pos)                 /*!< 0x00008000 */
N#define DMA_SxCR_PINCOS          DMA_SxCR_PINCOS_Msk                           
N#define DMA_SxCR_MSIZE_Pos       (13U)                                         
N#define DMA_SxCR_MSIZE_Msk       (0x3UL << DMA_SxCR_MSIZE_Pos)                  /*!< 0x00006000 */
N#define DMA_SxCR_MSIZE           DMA_SxCR_MSIZE_Msk                            
N#define DMA_SxCR_MSIZE_0         (0x1UL << DMA_SxCR_MSIZE_Pos)                  /*!< 0x00002000 */
N#define DMA_SxCR_MSIZE_1         (0x2UL << DMA_SxCR_MSIZE_Pos)                  /*!< 0x00004000 */
N#define DMA_SxCR_PSIZE_Pos       (11U)                                         
N#define DMA_SxCR_PSIZE_Msk       (0x3UL << DMA_SxCR_PSIZE_Pos)                  /*!< 0x00001800 */
N#define DMA_SxCR_PSIZE           DMA_SxCR_PSIZE_Msk                            
N#define DMA_SxCR_PSIZE_0         (0x1UL << DMA_SxCR_PSIZE_Pos)                  /*!< 0x00000800 */
N#define DMA_SxCR_PSIZE_1         (0x2UL << DMA_SxCR_PSIZE_Pos)                  /*!< 0x00001000 */
N#define DMA_SxCR_MINC_Pos        (10U)                                         
N#define DMA_SxCR_MINC_Msk        (0x1UL << DMA_SxCR_MINC_Pos)                   /*!< 0x00000400 */
N#define DMA_SxCR_MINC            DMA_SxCR_MINC_Msk                             
N#define DMA_SxCR_PINC_Pos        (9U)                                          
N#define DMA_SxCR_PINC_Msk        (0x1UL << DMA_SxCR_PINC_Pos)                   /*!< 0x00000200 */
N#define DMA_SxCR_PINC            DMA_SxCR_PINC_Msk                             
N#define DMA_SxCR_CIRC_Pos        (8U)                                          
N#define DMA_SxCR_CIRC_Msk        (0x1UL << DMA_SxCR_CIRC_Pos)                   /*!< 0x00000100 */
N#define DMA_SxCR_CIRC            DMA_SxCR_CIRC_Msk                             
N#define DMA_SxCR_DIR_Pos         (6U)                                          
N#define DMA_SxCR_DIR_Msk         (0x3UL << DMA_SxCR_DIR_Pos)                    /*!< 0x000000C0 */
N#define DMA_SxCR_DIR             DMA_SxCR_DIR_Msk                              
N#define DMA_SxCR_DIR_0           (0x1UL << DMA_SxCR_DIR_Pos)                    /*!< 0x00000040 */
N#define DMA_SxCR_DIR_1           (0x2UL << DMA_SxCR_DIR_Pos)                    /*!< 0x00000080 */
N#define DMA_SxCR_PFCTRL_Pos      (5U)                                          
N#define DMA_SxCR_PFCTRL_Msk      (0x1UL << DMA_SxCR_PFCTRL_Pos)                 /*!< 0x00000020 */
N#define DMA_SxCR_PFCTRL          DMA_SxCR_PFCTRL_Msk                           
N#define DMA_SxCR_TCIE_Pos        (4U)                                          
N#define DMA_SxCR_TCIE_Msk        (0x1UL << DMA_SxCR_TCIE_Pos)                   /*!< 0x00000010 */
N#define DMA_SxCR_TCIE            DMA_SxCR_TCIE_Msk                             
N#define DMA_SxCR_HTIE_Pos        (3U)                                          
N#define DMA_SxCR_HTIE_Msk        (0x1UL << DMA_SxCR_HTIE_Pos)                   /*!< 0x00000008 */
N#define DMA_SxCR_HTIE            DMA_SxCR_HTIE_Msk                             
N#define DMA_SxCR_TEIE_Pos        (2U)                                          
N#define DMA_SxCR_TEIE_Msk        (0x1UL << DMA_SxCR_TEIE_Pos)                   /*!< 0x00000004 */
N#define DMA_SxCR_TEIE            DMA_SxCR_TEIE_Msk                             
N#define DMA_SxCR_DMEIE_Pos       (1U)                                          
N#define DMA_SxCR_DMEIE_Msk       (0x1UL << DMA_SxCR_DMEIE_Pos)                  /*!< 0x00000002 */
N#define DMA_SxCR_DMEIE           DMA_SxCR_DMEIE_Msk                            
N#define DMA_SxCR_EN_Pos          (0U)                                          
N#define DMA_SxCR_EN_Msk          (0x1UL << DMA_SxCR_EN_Pos)                     /*!< 0x00000001 */
N#define DMA_SxCR_EN              DMA_SxCR_EN_Msk                               
N
N/* Legacy defines */
N#define DMA_SxCR_ACK_Pos         (20U)                                         
N#define DMA_SxCR_ACK_Msk         (0x1UL << DMA_SxCR_ACK_Pos)                    /*!< 0x00100000 */
N#define DMA_SxCR_ACK             DMA_SxCR_ACK_Msk                              
N
N/********************  Bits definition for DMA_SxCNDTR register  **************/
N#define DMA_SxNDT_Pos            (0U)                                          
N#define DMA_SxNDT_Msk            (0xFFFFUL << DMA_SxNDT_Pos)                    /*!< 0x0000FFFF */
N#define DMA_SxNDT                DMA_SxNDT_Msk                                 
N#define DMA_SxNDT_0              (0x0001UL << DMA_SxNDT_Pos)                    /*!< 0x00000001 */
N#define DMA_SxNDT_1              (0x0002UL << DMA_SxNDT_Pos)                    /*!< 0x00000002 */
N#define DMA_SxNDT_2              (0x0004UL << DMA_SxNDT_Pos)                    /*!< 0x00000004 */
N#define DMA_SxNDT_3              (0x0008UL << DMA_SxNDT_Pos)                    /*!< 0x00000008 */
N#define DMA_SxNDT_4              (0x0010UL << DMA_SxNDT_Pos)                    /*!< 0x00000010 */
N#define DMA_SxNDT_5              (0x0020UL << DMA_SxNDT_Pos)                    /*!< 0x00000020 */
N#define DMA_SxNDT_6              (0x0040UL << DMA_SxNDT_Pos)                    /*!< 0x00000040 */
N#define DMA_SxNDT_7              (0x0080UL << DMA_SxNDT_Pos)                    /*!< 0x00000080 */
N#define DMA_SxNDT_8              (0x0100UL << DMA_SxNDT_Pos)                    /*!< 0x00000100 */
N#define DMA_SxNDT_9              (0x0200UL << DMA_SxNDT_Pos)                    /*!< 0x00000200 */
N#define DMA_SxNDT_10             (0x0400UL << DMA_SxNDT_Pos)                    /*!< 0x00000400 */
N#define DMA_SxNDT_11             (0x0800UL << DMA_SxNDT_Pos)                    /*!< 0x00000800 */
N#define DMA_SxNDT_12             (0x1000UL << DMA_SxNDT_Pos)                    /*!< 0x00001000 */
N#define DMA_SxNDT_13             (0x2000UL << DMA_SxNDT_Pos)                    /*!< 0x00002000 */
N#define DMA_SxNDT_14             (0x4000UL << DMA_SxNDT_Pos)                    /*!< 0x00004000 */
N#define DMA_SxNDT_15             (0x8000UL << DMA_SxNDT_Pos)                    /*!< 0x00008000 */
N
N/********************  Bits definition for DMA_SxFCR register  ****************/ 
N#define DMA_SxFCR_FEIE_Pos       (7U)                                          
N#define DMA_SxFCR_FEIE_Msk       (0x1UL << DMA_SxFCR_FEIE_Pos)                  /*!< 0x00000080 */
N#define DMA_SxFCR_FEIE           DMA_SxFCR_FEIE_Msk                            
N#define DMA_SxFCR_FS_Pos         (3U)                                          
N#define DMA_SxFCR_FS_Msk         (0x7UL << DMA_SxFCR_FS_Pos)                    /*!< 0x00000038 */
N#define DMA_SxFCR_FS             DMA_SxFCR_FS_Msk                              
N#define DMA_SxFCR_FS_0           (0x1UL << DMA_SxFCR_FS_Pos)                    /*!< 0x00000008 */
N#define DMA_SxFCR_FS_1           (0x2UL << DMA_SxFCR_FS_Pos)                    /*!< 0x00000010 */
N#define DMA_SxFCR_FS_2           (0x4UL << DMA_SxFCR_FS_Pos)                    /*!< 0x00000020 */
N#define DMA_SxFCR_DMDIS_Pos      (2U)                                          
N#define DMA_SxFCR_DMDIS_Msk      (0x1UL << DMA_SxFCR_DMDIS_Pos)                 /*!< 0x00000004 */
N#define DMA_SxFCR_DMDIS          DMA_SxFCR_DMDIS_Msk                           
N#define DMA_SxFCR_FTH_Pos        (0U)                                          
N#define DMA_SxFCR_FTH_Msk        (0x3UL << DMA_SxFCR_FTH_Pos)                   /*!< 0x00000003 */
N#define DMA_SxFCR_FTH            DMA_SxFCR_FTH_Msk                             
N#define DMA_SxFCR_FTH_0          (0x1UL << DMA_SxFCR_FTH_Pos)                   /*!< 0x00000001 */
N#define DMA_SxFCR_FTH_1          (0x2UL << DMA_SxFCR_FTH_Pos)                   /*!< 0x00000002 */
N
N/********************  Bits definition for DMA_LISR register  *****************/ 
N#define DMA_LISR_TCIF3_Pos       (27U)                                         
N#define DMA_LISR_TCIF3_Msk       (0x1UL << DMA_LISR_TCIF3_Pos)                  /*!< 0x08000000 */
N#define DMA_LISR_TCIF3           DMA_LISR_TCIF3_Msk                            
N#define DMA_LISR_HTIF3_Pos       (26U)                                         
N#define DMA_LISR_HTIF3_Msk       (0x1UL << DMA_LISR_HTIF3_Pos)                  /*!< 0x04000000 */
N#define DMA_LISR_HTIF3           DMA_LISR_HTIF3_Msk                            
N#define DMA_LISR_TEIF3_Pos       (25U)                                         
N#define DMA_LISR_TEIF3_Msk       (0x1UL << DMA_LISR_TEIF3_Pos)                  /*!< 0x02000000 */
N#define DMA_LISR_TEIF3           DMA_LISR_TEIF3_Msk                            
N#define DMA_LISR_DMEIF3_Pos      (24U)                                         
N#define DMA_LISR_DMEIF3_Msk      (0x1UL << DMA_LISR_DMEIF3_Pos)                 /*!< 0x01000000 */
N#define DMA_LISR_DMEIF3          DMA_LISR_DMEIF3_Msk                           
N#define DMA_LISR_FEIF3_Pos       (22U)                                         
N#define DMA_LISR_FEIF3_Msk       (0x1UL << DMA_LISR_FEIF3_Pos)                  /*!< 0x00400000 */
N#define DMA_LISR_FEIF3           DMA_LISR_FEIF3_Msk                            
N#define DMA_LISR_TCIF2_Pos       (21U)                                         
N#define DMA_LISR_TCIF2_Msk       (0x1UL << DMA_LISR_TCIF2_Pos)                  /*!< 0x00200000 */
N#define DMA_LISR_TCIF2           DMA_LISR_TCIF2_Msk                            
N#define DMA_LISR_HTIF2_Pos       (20U)                                         
N#define DMA_LISR_HTIF2_Msk       (0x1UL << DMA_LISR_HTIF2_Pos)                  /*!< 0x00100000 */
N#define DMA_LISR_HTIF2           DMA_LISR_HTIF2_Msk                            
N#define DMA_LISR_TEIF2_Pos       (19U)                                         
N#define DMA_LISR_TEIF2_Msk       (0x1UL << DMA_LISR_TEIF2_Pos)                  /*!< 0x00080000 */
N#define DMA_LISR_TEIF2           DMA_LISR_TEIF2_Msk                            
N#define DMA_LISR_DMEIF2_Pos      (18U)                                         
N#define DMA_LISR_DMEIF2_Msk      (0x1UL << DMA_LISR_DMEIF2_Pos)                 /*!< 0x00040000 */
N#define DMA_LISR_DMEIF2          DMA_LISR_DMEIF2_Msk                           
N#define DMA_LISR_FEIF2_Pos       (16U)                                         
N#define DMA_LISR_FEIF2_Msk       (0x1UL << DMA_LISR_FEIF2_Pos)                  /*!< 0x00010000 */
N#define DMA_LISR_FEIF2           DMA_LISR_FEIF2_Msk                            
N#define DMA_LISR_TCIF1_Pos       (11U)                                         
N#define DMA_LISR_TCIF1_Msk       (0x1UL << DMA_LISR_TCIF1_Pos)                  /*!< 0x00000800 */
N#define DMA_LISR_TCIF1           DMA_LISR_TCIF1_Msk                            
N#define DMA_LISR_HTIF1_Pos       (10U)                                         
N#define DMA_LISR_HTIF1_Msk       (0x1UL << DMA_LISR_HTIF1_Pos)                  /*!< 0x00000400 */
N#define DMA_LISR_HTIF1           DMA_LISR_HTIF1_Msk                            
N#define DMA_LISR_TEIF1_Pos       (9U)                                          
N#define DMA_LISR_TEIF1_Msk       (0x1UL << DMA_LISR_TEIF1_Pos)                  /*!< 0x00000200 */
N#define DMA_LISR_TEIF1           DMA_LISR_TEIF1_Msk                            
N#define DMA_LISR_DMEIF1_Pos      (8U)                                          
N#define DMA_LISR_DMEIF1_Msk      (0x1UL << DMA_LISR_DMEIF1_Pos)                 /*!< 0x00000100 */
N#define DMA_LISR_DMEIF1          DMA_LISR_DMEIF1_Msk                           
N#define DMA_LISR_FEIF1_Pos       (6U)                                          
N#define DMA_LISR_FEIF1_Msk       (0x1UL << DMA_LISR_FEIF1_Pos)                  /*!< 0x00000040 */
N#define DMA_LISR_FEIF1           DMA_LISR_FEIF1_Msk                            
N#define DMA_LISR_TCIF0_Pos       (5U)                                          
N#define DMA_LISR_TCIF0_Msk       (0x1UL << DMA_LISR_TCIF0_Pos)                  /*!< 0x00000020 */
N#define DMA_LISR_TCIF0           DMA_LISR_TCIF0_Msk                            
N#define DMA_LISR_HTIF0_Pos       (4U)                                          
N#define DMA_LISR_HTIF0_Msk       (0x1UL << DMA_LISR_HTIF0_Pos)                  /*!< 0x00000010 */
N#define DMA_LISR_HTIF0           DMA_LISR_HTIF0_Msk                            
N#define DMA_LISR_TEIF0_Pos       (3U)                                          
N#define DMA_LISR_TEIF0_Msk       (0x1UL << DMA_LISR_TEIF0_Pos)                  /*!< 0x00000008 */
N#define DMA_LISR_TEIF0           DMA_LISR_TEIF0_Msk                            
N#define DMA_LISR_DMEIF0_Pos      (2U)                                          
N#define DMA_LISR_DMEIF0_Msk      (0x1UL << DMA_LISR_DMEIF0_Pos)                 /*!< 0x00000004 */
N#define DMA_LISR_DMEIF0          DMA_LISR_DMEIF0_Msk                           
N#define DMA_LISR_FEIF0_Pos       (0U)                                          
N#define DMA_LISR_FEIF0_Msk       (0x1UL << DMA_LISR_FEIF0_Pos)                  /*!< 0x00000001 */
N#define DMA_LISR_FEIF0           DMA_LISR_FEIF0_Msk                            
N
N/********************  Bits definition for DMA_HISR register  *****************/ 
N#define DMA_HISR_TCIF7_Pos       (27U)                                         
N#define DMA_HISR_TCIF7_Msk       (0x1UL << DMA_HISR_TCIF7_Pos)                  /*!< 0x08000000 */
N#define DMA_HISR_TCIF7           DMA_HISR_TCIF7_Msk                            
N#define DMA_HISR_HTIF7_Pos       (26U)                                         
N#define DMA_HISR_HTIF7_Msk       (0x1UL << DMA_HISR_HTIF7_Pos)                  /*!< 0x04000000 */
N#define DMA_HISR_HTIF7           DMA_HISR_HTIF7_Msk                            
N#define DMA_HISR_TEIF7_Pos       (25U)                                         
N#define DMA_HISR_TEIF7_Msk       (0x1UL << DMA_HISR_TEIF7_Pos)                  /*!< 0x02000000 */
N#define DMA_HISR_TEIF7           DMA_HISR_TEIF7_Msk                            
N#define DMA_HISR_DMEIF7_Pos      (24U)                                         
N#define DMA_HISR_DMEIF7_Msk      (0x1UL << DMA_HISR_DMEIF7_Pos)                 /*!< 0x01000000 */
N#define DMA_HISR_DMEIF7          DMA_HISR_DMEIF7_Msk                           
N#define DMA_HISR_FEIF7_Pos       (22U)                                         
N#define DMA_HISR_FEIF7_Msk       (0x1UL << DMA_HISR_FEIF7_Pos)                  /*!< 0x00400000 */
N#define DMA_HISR_FEIF7           DMA_HISR_FEIF7_Msk                            
N#define DMA_HISR_TCIF6_Pos       (21U)                                         
N#define DMA_HISR_TCIF6_Msk       (0x1UL << DMA_HISR_TCIF6_Pos)                  /*!< 0x00200000 */
N#define DMA_HISR_TCIF6           DMA_HISR_TCIF6_Msk                            
N#define DMA_HISR_HTIF6_Pos       (20U)                                         
N#define DMA_HISR_HTIF6_Msk       (0x1UL << DMA_HISR_HTIF6_Pos)                  /*!< 0x00100000 */
N#define DMA_HISR_HTIF6           DMA_HISR_HTIF6_Msk                            
N#define DMA_HISR_TEIF6_Pos       (19U)                                         
N#define DMA_HISR_TEIF6_Msk       (0x1UL << DMA_HISR_TEIF6_Pos)                  /*!< 0x00080000 */
N#define DMA_HISR_TEIF6           DMA_HISR_TEIF6_Msk                            
N#define DMA_HISR_DMEIF6_Pos      (18U)                                         
N#define DMA_HISR_DMEIF6_Msk      (0x1UL << DMA_HISR_DMEIF6_Pos)                 /*!< 0x00040000 */
N#define DMA_HISR_DMEIF6          DMA_HISR_DMEIF6_Msk                           
N#define DMA_HISR_FEIF6_Pos       (16U)                                         
N#define DMA_HISR_FEIF6_Msk       (0x1UL << DMA_HISR_FEIF6_Pos)                  /*!< 0x00010000 */
N#define DMA_HISR_FEIF6           DMA_HISR_FEIF6_Msk                            
N#define DMA_HISR_TCIF5_Pos       (11U)                                         
N#define DMA_HISR_TCIF5_Msk       (0x1UL << DMA_HISR_TCIF5_Pos)                  /*!< 0x00000800 */
N#define DMA_HISR_TCIF5           DMA_HISR_TCIF5_Msk                            
N#define DMA_HISR_HTIF5_Pos       (10U)                                         
N#define DMA_HISR_HTIF5_Msk       (0x1UL << DMA_HISR_HTIF5_Pos)                  /*!< 0x00000400 */
N#define DMA_HISR_HTIF5           DMA_HISR_HTIF5_Msk                            
N#define DMA_HISR_TEIF5_Pos       (9U)                                          
N#define DMA_HISR_TEIF5_Msk       (0x1UL << DMA_HISR_TEIF5_Pos)                  /*!< 0x00000200 */
N#define DMA_HISR_TEIF5           DMA_HISR_TEIF5_Msk                            
N#define DMA_HISR_DMEIF5_Pos      (8U)                                          
N#define DMA_HISR_DMEIF5_Msk      (0x1UL << DMA_HISR_DMEIF5_Pos)                 /*!< 0x00000100 */
N#define DMA_HISR_DMEIF5          DMA_HISR_DMEIF5_Msk                           
N#define DMA_HISR_FEIF5_Pos       (6U)                                          
N#define DMA_HISR_FEIF5_Msk       (0x1UL << DMA_HISR_FEIF5_Pos)                  /*!< 0x00000040 */
N#define DMA_HISR_FEIF5           DMA_HISR_FEIF5_Msk                            
N#define DMA_HISR_TCIF4_Pos       (5U)                                          
N#define DMA_HISR_TCIF4_Msk       (0x1UL << DMA_HISR_TCIF4_Pos)                  /*!< 0x00000020 */
N#define DMA_HISR_TCIF4           DMA_HISR_TCIF4_Msk                            
N#define DMA_HISR_HTIF4_Pos       (4U)                                          
N#define DMA_HISR_HTIF4_Msk       (0x1UL << DMA_HISR_HTIF4_Pos)                  /*!< 0x00000010 */
N#define DMA_HISR_HTIF4           DMA_HISR_HTIF4_Msk                            
N#define DMA_HISR_TEIF4_Pos       (3U)                                          
N#define DMA_HISR_TEIF4_Msk       (0x1UL << DMA_HISR_TEIF4_Pos)                  /*!< 0x00000008 */
N#define DMA_HISR_TEIF4           DMA_HISR_TEIF4_Msk                            
N#define DMA_HISR_DMEIF4_Pos      (2U)                                          
N#define DMA_HISR_DMEIF4_Msk      (0x1UL << DMA_HISR_DMEIF4_Pos)                 /*!< 0x00000004 */
N#define DMA_HISR_DMEIF4          DMA_HISR_DMEIF4_Msk                           
N#define DMA_HISR_FEIF4_Pos       (0U)                                          
N#define DMA_HISR_FEIF4_Msk       (0x1UL << DMA_HISR_FEIF4_Pos)                  /*!< 0x00000001 */
N#define DMA_HISR_FEIF4           DMA_HISR_FEIF4_Msk                            
N
N/********************  Bits definition for DMA_LIFCR register  ****************/ 
N#define DMA_LIFCR_CTCIF3_Pos     (27U)                                         
N#define DMA_LIFCR_CTCIF3_Msk     (0x1UL << DMA_LIFCR_CTCIF3_Pos)                /*!< 0x08000000 */
N#define DMA_LIFCR_CTCIF3         DMA_LIFCR_CTCIF3_Msk                          
N#define DMA_LIFCR_CHTIF3_Pos     (26U)                                         
N#define DMA_LIFCR_CHTIF3_Msk     (0x1UL << DMA_LIFCR_CHTIF3_Pos)                /*!< 0x04000000 */
N#define DMA_LIFCR_CHTIF3         DMA_LIFCR_CHTIF3_Msk                          
N#define DMA_LIFCR_CTEIF3_Pos     (25U)                                         
N#define DMA_LIFCR_CTEIF3_Msk     (0x1UL << DMA_LIFCR_CTEIF3_Pos)                /*!< 0x02000000 */
N#define DMA_LIFCR_CTEIF3         DMA_LIFCR_CTEIF3_Msk                          
N#define DMA_LIFCR_CDMEIF3_Pos    (24U)                                         
N#define DMA_LIFCR_CDMEIF3_Msk    (0x1UL << DMA_LIFCR_CDMEIF3_Pos)               /*!< 0x01000000 */
N#define DMA_LIFCR_CDMEIF3        DMA_LIFCR_CDMEIF3_Msk                         
N#define DMA_LIFCR_CFEIF3_Pos     (22U)                                         
N#define DMA_LIFCR_CFEIF3_Msk     (0x1UL << DMA_LIFCR_CFEIF3_Pos)                /*!< 0x00400000 */
N#define DMA_LIFCR_CFEIF3         DMA_LIFCR_CFEIF3_Msk                          
N#define DMA_LIFCR_CTCIF2_Pos     (21U)                                         
N#define DMA_LIFCR_CTCIF2_Msk     (0x1UL << DMA_LIFCR_CTCIF2_Pos)                /*!< 0x00200000 */
N#define DMA_LIFCR_CTCIF2         DMA_LIFCR_CTCIF2_Msk                          
N#define DMA_LIFCR_CHTIF2_Pos     (20U)                                         
N#define DMA_LIFCR_CHTIF2_Msk     (0x1UL << DMA_LIFCR_CHTIF2_Pos)                /*!< 0x00100000 */
N#define DMA_LIFCR_CHTIF2         DMA_LIFCR_CHTIF2_Msk                          
N#define DMA_LIFCR_CTEIF2_Pos     (19U)                                         
N#define DMA_LIFCR_CTEIF2_Msk     (0x1UL << DMA_LIFCR_CTEIF2_Pos)                /*!< 0x00080000 */
N#define DMA_LIFCR_CTEIF2         DMA_LIFCR_CTEIF2_Msk                          
N#define DMA_LIFCR_CDMEIF2_Pos    (18U)                                         
N#define DMA_LIFCR_CDMEIF2_Msk    (0x1UL << DMA_LIFCR_CDMEIF2_Pos)               /*!< 0x00040000 */
N#define DMA_LIFCR_CDMEIF2        DMA_LIFCR_CDMEIF2_Msk                         
N#define DMA_LIFCR_CFEIF2_Pos     (16U)                                         
N#define DMA_LIFCR_CFEIF2_Msk     (0x1UL << DMA_LIFCR_CFEIF2_Pos)                /*!< 0x00010000 */
N#define DMA_LIFCR_CFEIF2         DMA_LIFCR_CFEIF2_Msk                          
N#define DMA_LIFCR_CTCIF1_Pos     (11U)                                         
N#define DMA_LIFCR_CTCIF1_Msk     (0x1UL << DMA_LIFCR_CTCIF1_Pos)                /*!< 0x00000800 */
N#define DMA_LIFCR_CTCIF1         DMA_LIFCR_CTCIF1_Msk                          
N#define DMA_LIFCR_CHTIF1_Pos     (10U)                                         
N#define DMA_LIFCR_CHTIF1_Msk     (0x1UL << DMA_LIFCR_CHTIF1_Pos)                /*!< 0x00000400 */
N#define DMA_LIFCR_CHTIF1         DMA_LIFCR_CHTIF1_Msk                          
N#define DMA_LIFCR_CTEIF1_Pos     (9U)                                          
N#define DMA_LIFCR_CTEIF1_Msk     (0x1UL << DMA_LIFCR_CTEIF1_Pos)                /*!< 0x00000200 */
N#define DMA_LIFCR_CTEIF1         DMA_LIFCR_CTEIF1_Msk                          
N#define DMA_LIFCR_CDMEIF1_Pos    (8U)                                          
N#define DMA_LIFCR_CDMEIF1_Msk    (0x1UL << DMA_LIFCR_CDMEIF1_Pos)               /*!< 0x00000100 */
N#define DMA_LIFCR_CDMEIF1        DMA_LIFCR_CDMEIF1_Msk                         
N#define DMA_LIFCR_CFEIF1_Pos     (6U)                                          
N#define DMA_LIFCR_CFEIF1_Msk     (0x1UL << DMA_LIFCR_CFEIF1_Pos)                /*!< 0x00000040 */
N#define DMA_LIFCR_CFEIF1         DMA_LIFCR_CFEIF1_Msk                          
N#define DMA_LIFCR_CTCIF0_Pos     (5U)                                          
N#define DMA_LIFCR_CTCIF0_Msk     (0x1UL << DMA_LIFCR_CTCIF0_Pos)                /*!< 0x00000020 */
N#define DMA_LIFCR_CTCIF0         DMA_LIFCR_CTCIF0_Msk                          
N#define DMA_LIFCR_CHTIF0_Pos     (4U)                                          
N#define DMA_LIFCR_CHTIF0_Msk     (0x1UL << DMA_LIFCR_CHTIF0_Pos)                /*!< 0x00000010 */
N#define DMA_LIFCR_CHTIF0         DMA_LIFCR_CHTIF0_Msk                          
N#define DMA_LIFCR_CTEIF0_Pos     (3U)                                          
N#define DMA_LIFCR_CTEIF0_Msk     (0x1UL << DMA_LIFCR_CTEIF0_Pos)                /*!< 0x00000008 */
N#define DMA_LIFCR_CTEIF0         DMA_LIFCR_CTEIF0_Msk                          
N#define DMA_LIFCR_CDMEIF0_Pos    (2U)                                          
N#define DMA_LIFCR_CDMEIF0_Msk    (0x1UL << DMA_LIFCR_CDMEIF0_Pos)               /*!< 0x00000004 */
N#define DMA_LIFCR_CDMEIF0        DMA_LIFCR_CDMEIF0_Msk                         
N#define DMA_LIFCR_CFEIF0_Pos     (0U)                                          
N#define DMA_LIFCR_CFEIF0_Msk     (0x1UL << DMA_LIFCR_CFEIF0_Pos)                /*!< 0x00000001 */
N#define DMA_LIFCR_CFEIF0         DMA_LIFCR_CFEIF0_Msk                          
N
N/********************  Bits definition for DMA_HIFCR  register  ****************/ 
N#define DMA_HIFCR_CTCIF7_Pos     (27U)                                         
N#define DMA_HIFCR_CTCIF7_Msk     (0x1UL << DMA_HIFCR_CTCIF7_Pos)                /*!< 0x08000000 */
N#define DMA_HIFCR_CTCIF7         DMA_HIFCR_CTCIF7_Msk                          
N#define DMA_HIFCR_CHTIF7_Pos     (26U)                                         
N#define DMA_HIFCR_CHTIF7_Msk     (0x1UL << DMA_HIFCR_CHTIF7_Pos)                /*!< 0x04000000 */
N#define DMA_HIFCR_CHTIF7         DMA_HIFCR_CHTIF7_Msk                          
N#define DMA_HIFCR_CTEIF7_Pos     (25U)                                         
N#define DMA_HIFCR_CTEIF7_Msk     (0x1UL << DMA_HIFCR_CTEIF7_Pos)                /*!< 0x02000000 */
N#define DMA_HIFCR_CTEIF7         DMA_HIFCR_CTEIF7_Msk                          
N#define DMA_HIFCR_CDMEIF7_Pos    (24U)                                         
N#define DMA_HIFCR_CDMEIF7_Msk    (0x1UL << DMA_HIFCR_CDMEIF7_Pos)               /*!< 0x01000000 */
N#define DMA_HIFCR_CDMEIF7        DMA_HIFCR_CDMEIF7_Msk                         
N#define DMA_HIFCR_CFEIF7_Pos     (22U)                                         
N#define DMA_HIFCR_CFEIF7_Msk     (0x1UL << DMA_HIFCR_CFEIF7_Pos)                /*!< 0x00400000 */
N#define DMA_HIFCR_CFEIF7         DMA_HIFCR_CFEIF7_Msk                          
N#define DMA_HIFCR_CTCIF6_Pos     (21U)                                         
N#define DMA_HIFCR_CTCIF6_Msk     (0x1UL << DMA_HIFCR_CTCIF6_Pos)                /*!< 0x00200000 */
N#define DMA_HIFCR_CTCIF6         DMA_HIFCR_CTCIF6_Msk                          
N#define DMA_HIFCR_CHTIF6_Pos     (20U)                                         
N#define DMA_HIFCR_CHTIF6_Msk     (0x1UL << DMA_HIFCR_CHTIF6_Pos)                /*!< 0x00100000 */
N#define DMA_HIFCR_CHTIF6         DMA_HIFCR_CHTIF6_Msk                          
N#define DMA_HIFCR_CTEIF6_Pos     (19U)                                         
N#define DMA_HIFCR_CTEIF6_Msk     (0x1UL << DMA_HIFCR_CTEIF6_Pos)                /*!< 0x00080000 */
N#define DMA_HIFCR_CTEIF6         DMA_HIFCR_CTEIF6_Msk                          
N#define DMA_HIFCR_CDMEIF6_Pos    (18U)                                         
N#define DMA_HIFCR_CDMEIF6_Msk    (0x1UL << DMA_HIFCR_CDMEIF6_Pos)               /*!< 0x00040000 */
N#define DMA_HIFCR_CDMEIF6        DMA_HIFCR_CDMEIF6_Msk                         
N#define DMA_HIFCR_CFEIF6_Pos     (16U)                                         
N#define DMA_HIFCR_CFEIF6_Msk     (0x1UL << DMA_HIFCR_CFEIF6_Pos)                /*!< 0x00010000 */
N#define DMA_HIFCR_CFEIF6         DMA_HIFCR_CFEIF6_Msk                          
N#define DMA_HIFCR_CTCIF5_Pos     (11U)                                         
N#define DMA_HIFCR_CTCIF5_Msk     (0x1UL << DMA_HIFCR_CTCIF5_Pos)                /*!< 0x00000800 */
N#define DMA_HIFCR_CTCIF5         DMA_HIFCR_CTCIF5_Msk                          
N#define DMA_HIFCR_CHTIF5_Pos     (10U)                                         
N#define DMA_HIFCR_CHTIF5_Msk     (0x1UL << DMA_HIFCR_CHTIF5_Pos)                /*!< 0x00000400 */
N#define DMA_HIFCR_CHTIF5         DMA_HIFCR_CHTIF5_Msk                          
N#define DMA_HIFCR_CTEIF5_Pos     (9U)                                          
N#define DMA_HIFCR_CTEIF5_Msk     (0x1UL << DMA_HIFCR_CTEIF5_Pos)                /*!< 0x00000200 */
N#define DMA_HIFCR_CTEIF5         DMA_HIFCR_CTEIF5_Msk                          
N#define DMA_HIFCR_CDMEIF5_Pos    (8U)                                          
N#define DMA_HIFCR_CDMEIF5_Msk    (0x1UL << DMA_HIFCR_CDMEIF5_Pos)               /*!< 0x00000100 */
N#define DMA_HIFCR_CDMEIF5        DMA_HIFCR_CDMEIF5_Msk                         
N#define DMA_HIFCR_CFEIF5_Pos     (6U)                                          
N#define DMA_HIFCR_CFEIF5_Msk     (0x1UL << DMA_HIFCR_CFEIF5_Pos)                /*!< 0x00000040 */
N#define DMA_HIFCR_CFEIF5         DMA_HIFCR_CFEIF5_Msk                          
N#define DMA_HIFCR_CTCIF4_Pos     (5U)                                          
N#define DMA_HIFCR_CTCIF4_Msk     (0x1UL << DMA_HIFCR_CTCIF4_Pos)                /*!< 0x00000020 */
N#define DMA_HIFCR_CTCIF4         DMA_HIFCR_CTCIF4_Msk                          
N#define DMA_HIFCR_CHTIF4_Pos     (4U)                                          
N#define DMA_HIFCR_CHTIF4_Msk     (0x1UL << DMA_HIFCR_CHTIF4_Pos)                /*!< 0x00000010 */
N#define DMA_HIFCR_CHTIF4         DMA_HIFCR_CHTIF4_Msk                          
N#define DMA_HIFCR_CTEIF4_Pos     (3U)                                          
N#define DMA_HIFCR_CTEIF4_Msk     (0x1UL << DMA_HIFCR_CTEIF4_Pos)                /*!< 0x00000008 */
N#define DMA_HIFCR_CTEIF4         DMA_HIFCR_CTEIF4_Msk                          
N#define DMA_HIFCR_CDMEIF4_Pos    (2U)                                          
N#define DMA_HIFCR_CDMEIF4_Msk    (0x1UL << DMA_HIFCR_CDMEIF4_Pos)               /*!< 0x00000004 */
N#define DMA_HIFCR_CDMEIF4        DMA_HIFCR_CDMEIF4_Msk                         
N#define DMA_HIFCR_CFEIF4_Pos     (0U)                                          
N#define DMA_HIFCR_CFEIF4_Msk     (0x1UL << DMA_HIFCR_CFEIF4_Pos)                /*!< 0x00000001 */
N#define DMA_HIFCR_CFEIF4         DMA_HIFCR_CFEIF4_Msk                          
N
N/******************  Bit definition for DMA_SxPAR register  ********************/
N#define DMA_SxPAR_PA_Pos         (0U)                                          
N#define DMA_SxPAR_PA_Msk         (0xFFFFFFFFUL << DMA_SxPAR_PA_Pos)             /*!< 0xFFFFFFFF */
N#define DMA_SxPAR_PA             DMA_SxPAR_PA_Msk                              /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_SxM0AR register  ********************/
N#define DMA_SxM0AR_M0A_Pos       (0U)                                          
N#define DMA_SxM0AR_M0A_Msk       (0xFFFFFFFFUL << DMA_SxM0AR_M0A_Pos)           /*!< 0xFFFFFFFF */
N#define DMA_SxM0AR_M0A           DMA_SxM0AR_M0A_Msk                            /*!< Memory Address */
N
N/******************  Bit definition for DMA_SxM1AR register  ********************/
N#define DMA_SxM1AR_M1A_Pos       (0U)                                          
N#define DMA_SxM1AR_M1A_Msk       (0xFFFFFFFFUL << DMA_SxM1AR_M1A_Pos)           /*!< 0xFFFFFFFF */
N#define DMA_SxM1AR_M1A           DMA_SxM1AR_M1A_Msk                            /*!< Memory Address */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                    External Interrupt/Event Controller                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define EXTI_IMR_MR0_Pos          (0U)                                         
N#define EXTI_IMR_MR0_Msk          (0x1UL << EXTI_IMR_MR0_Pos)                   /*!< 0x00000001 */
N#define EXTI_IMR_MR0              EXTI_IMR_MR0_Msk                             /*!< Interrupt Mask on line 0 */
N#define EXTI_IMR_MR1_Pos          (1U)                                         
N#define EXTI_IMR_MR1_Msk          (0x1UL << EXTI_IMR_MR1_Pos)                   /*!< 0x00000002 */
N#define EXTI_IMR_MR1              EXTI_IMR_MR1_Msk                             /*!< Interrupt Mask on line 1 */
N#define EXTI_IMR_MR2_Pos          (2U)                                         
N#define EXTI_IMR_MR2_Msk          (0x1UL << EXTI_IMR_MR2_Pos)                   /*!< 0x00000004 */
N#define EXTI_IMR_MR2              EXTI_IMR_MR2_Msk                             /*!< Interrupt Mask on line 2 */
N#define EXTI_IMR_MR3_Pos          (3U)                                         
N#define EXTI_IMR_MR3_Msk          (0x1UL << EXTI_IMR_MR3_Pos)                   /*!< 0x00000008 */
N#define EXTI_IMR_MR3              EXTI_IMR_MR3_Msk                             /*!< Interrupt Mask on line 3 */
N#define EXTI_IMR_MR4_Pos          (4U)                                         
N#define EXTI_IMR_MR4_Msk          (0x1UL << EXTI_IMR_MR4_Pos)                   /*!< 0x00000010 */
N#define EXTI_IMR_MR4              EXTI_IMR_MR4_Msk                             /*!< Interrupt Mask on line 4 */
N#define EXTI_IMR_MR5_Pos          (5U)                                         
N#define EXTI_IMR_MR5_Msk          (0x1UL << EXTI_IMR_MR5_Pos)                   /*!< 0x00000020 */
N#define EXTI_IMR_MR5              EXTI_IMR_MR5_Msk                             /*!< Interrupt Mask on line 5 */
N#define EXTI_IMR_MR6_Pos          (6U)                                         
N#define EXTI_IMR_MR6_Msk          (0x1UL << EXTI_IMR_MR6_Pos)                   /*!< 0x00000040 */
N#define EXTI_IMR_MR6              EXTI_IMR_MR6_Msk                             /*!< Interrupt Mask on line 6 */
N#define EXTI_IMR_MR7_Pos          (7U)                                         
N#define EXTI_IMR_MR7_Msk          (0x1UL << EXTI_IMR_MR7_Pos)                   /*!< 0x00000080 */
N#define EXTI_IMR_MR7              EXTI_IMR_MR7_Msk                             /*!< Interrupt Mask on line 7 */
N#define EXTI_IMR_MR8_Pos          (8U)                                         
N#define EXTI_IMR_MR8_Msk          (0x1UL << EXTI_IMR_MR8_Pos)                   /*!< 0x00000100 */
N#define EXTI_IMR_MR8              EXTI_IMR_MR8_Msk                             /*!< Interrupt Mask on line 8 */
N#define EXTI_IMR_MR9_Pos          (9U)                                         
N#define EXTI_IMR_MR9_Msk          (0x1UL << EXTI_IMR_MR9_Pos)                   /*!< 0x00000200 */
N#define EXTI_IMR_MR9              EXTI_IMR_MR9_Msk                             /*!< Interrupt Mask on line 9 */
N#define EXTI_IMR_MR10_Pos         (10U)                                        
N#define EXTI_IMR_MR10_Msk         (0x1UL << EXTI_IMR_MR10_Pos)                  /*!< 0x00000400 */
N#define EXTI_IMR_MR10             EXTI_IMR_MR10_Msk                            /*!< Interrupt Mask on line 10 */
N#define EXTI_IMR_MR11_Pos         (11U)                                        
N#define EXTI_IMR_MR11_Msk         (0x1UL << EXTI_IMR_MR11_Pos)                  /*!< 0x00000800 */
N#define EXTI_IMR_MR11             EXTI_IMR_MR11_Msk                            /*!< Interrupt Mask on line 11 */
N#define EXTI_IMR_MR12_Pos         (12U)                                        
N#define EXTI_IMR_MR12_Msk         (0x1UL << EXTI_IMR_MR12_Pos)                  /*!< 0x00001000 */
N#define EXTI_IMR_MR12             EXTI_IMR_MR12_Msk                            /*!< Interrupt Mask on line 12 */
N#define EXTI_IMR_MR13_Pos         (13U)                                        
N#define EXTI_IMR_MR13_Msk         (0x1UL << EXTI_IMR_MR13_Pos)                  /*!< 0x00002000 */
N#define EXTI_IMR_MR13             EXTI_IMR_MR13_Msk                            /*!< Interrupt Mask on line 13 */
N#define EXTI_IMR_MR14_Pos         (14U)                                        
N#define EXTI_IMR_MR14_Msk         (0x1UL << EXTI_IMR_MR14_Pos)                  /*!< 0x00004000 */
N#define EXTI_IMR_MR14             EXTI_IMR_MR14_Msk                            /*!< Interrupt Mask on line 14 */
N#define EXTI_IMR_MR15_Pos         (15U)                                        
N#define EXTI_IMR_MR15_Msk         (0x1UL << EXTI_IMR_MR15_Pos)                  /*!< 0x00008000 */
N#define EXTI_IMR_MR15             EXTI_IMR_MR15_Msk                            /*!< Interrupt Mask on line 15 */
N#define EXTI_IMR_MR16_Pos         (16U)                                        
N#define EXTI_IMR_MR16_Msk         (0x1UL << EXTI_IMR_MR16_Pos)                  /*!< 0x00010000 */
N#define EXTI_IMR_MR16             EXTI_IMR_MR16_Msk                            /*!< Interrupt Mask on line 16 */
N#define EXTI_IMR_MR17_Pos         (17U)                                        
N#define EXTI_IMR_MR17_Msk         (0x1UL << EXTI_IMR_MR17_Pos)                  /*!< 0x00020000 */
N#define EXTI_IMR_MR17             EXTI_IMR_MR17_Msk                            /*!< Interrupt Mask on line 17 */
N#define EXTI_IMR_MR18_Pos         (18U)                                        
N#define EXTI_IMR_MR18_Msk         (0x1UL << EXTI_IMR_MR18_Pos)                  /*!< 0x00040000 */
N#define EXTI_IMR_MR18             EXTI_IMR_MR18_Msk                            /*!< Interrupt Mask on line 18 */
N#define EXTI_IMR_MR19_Pos         (19U)                                        
N#define EXTI_IMR_MR19_Msk         (0x1UL << EXTI_IMR_MR19_Pos)                  /*!< 0x00080000 */
N#define EXTI_IMR_MR19             EXTI_IMR_MR19_Msk                            /*!< Interrupt Mask on line 19 */
N#define EXTI_IMR_MR20_Pos         (20U)                                        
N#define EXTI_IMR_MR20_Msk         (0x1UL << EXTI_IMR_MR20_Pos)                  /*!< 0x00100000 */
N#define EXTI_IMR_MR20             EXTI_IMR_MR20_Msk                            /*!< Interrupt Mask on line 20 */
N#define EXTI_IMR_MR21_Pos         (21U)                                        
N#define EXTI_IMR_MR21_Msk         (0x1UL << EXTI_IMR_MR21_Pos)                  /*!< 0x00200000 */
N#define EXTI_IMR_MR21             EXTI_IMR_MR21_Msk                            /*!< Interrupt Mask on line 21 */
N#define EXTI_IMR_MR22_Pos         (22U)                                        
N#define EXTI_IMR_MR22_Msk         (0x1UL << EXTI_IMR_MR22_Pos)                  /*!< 0x00400000 */
N#define EXTI_IMR_MR22             EXTI_IMR_MR22_Msk                            /*!< Interrupt Mask on line 22 */
N
N/* Reference Defines */
N#define  EXTI_IMR_IM0                        EXTI_IMR_MR0
N#define  EXTI_IMR_IM1                        EXTI_IMR_MR1
N#define  EXTI_IMR_IM2                        EXTI_IMR_MR2
N#define  EXTI_IMR_IM3                        EXTI_IMR_MR3
N#define  EXTI_IMR_IM4                        EXTI_IMR_MR4
N#define  EXTI_IMR_IM5                        EXTI_IMR_MR5
N#define  EXTI_IMR_IM6                        EXTI_IMR_MR6
N#define  EXTI_IMR_IM7                        EXTI_IMR_MR7
N#define  EXTI_IMR_IM8                        EXTI_IMR_MR8
N#define  EXTI_IMR_IM9                        EXTI_IMR_MR9
N#define  EXTI_IMR_IM10                       EXTI_IMR_MR10
N#define  EXTI_IMR_IM11                       EXTI_IMR_MR11
N#define  EXTI_IMR_IM12                       EXTI_IMR_MR12
N#define  EXTI_IMR_IM13                       EXTI_IMR_MR13
N#define  EXTI_IMR_IM14                       EXTI_IMR_MR14
N#define  EXTI_IMR_IM15                       EXTI_IMR_MR15
N#define  EXTI_IMR_IM16                       EXTI_IMR_MR16
N#define  EXTI_IMR_IM17                       EXTI_IMR_MR17
N#define  EXTI_IMR_IM18                       EXTI_IMR_MR18
N#define  EXTI_IMR_IM19                       EXTI_IMR_MR19
N#define  EXTI_IMR_IM20                       EXTI_IMR_MR20
N#define  EXTI_IMR_IM21                       EXTI_IMR_MR21
N#define  EXTI_IMR_IM22                       EXTI_IMR_MR22
N#define EXTI_IMR_IM_Pos           (0U)                                         
N#define EXTI_IMR_IM_Msk           (0x7FFFFFUL << EXTI_IMR_IM_Pos)               /*!< 0x007FFFFF */
N#define EXTI_IMR_IM               EXTI_IMR_IM_Msk                              /*!< Interrupt Mask All */
N
N/*******************  Bit definition for EXTI_EMR register  *******************/
N#define EXTI_EMR_MR0_Pos          (0U)                                         
N#define EXTI_EMR_MR0_Msk          (0x1UL << EXTI_EMR_MR0_Pos)                   /*!< 0x00000001 */
N#define EXTI_EMR_MR0              EXTI_EMR_MR0_Msk                             /*!< Event Mask on line 0 */
N#define EXTI_EMR_MR1_Pos          (1U)                                         
N#define EXTI_EMR_MR1_Msk          (0x1UL << EXTI_EMR_MR1_Pos)                   /*!< 0x00000002 */
N#define EXTI_EMR_MR1              EXTI_EMR_MR1_Msk                             /*!< Event Mask on line 1 */
N#define EXTI_EMR_MR2_Pos          (2U)                                         
N#define EXTI_EMR_MR2_Msk          (0x1UL << EXTI_EMR_MR2_Pos)                   /*!< 0x00000004 */
N#define EXTI_EMR_MR2              EXTI_EMR_MR2_Msk                             /*!< Event Mask on line 2 */
N#define EXTI_EMR_MR3_Pos          (3U)                                         
N#define EXTI_EMR_MR3_Msk          (0x1UL << EXTI_EMR_MR3_Pos)                   /*!< 0x00000008 */
N#define EXTI_EMR_MR3              EXTI_EMR_MR3_Msk                             /*!< Event Mask on line 3 */
N#define EXTI_EMR_MR4_Pos          (4U)                                         
N#define EXTI_EMR_MR4_Msk          (0x1UL << EXTI_EMR_MR4_Pos)                   /*!< 0x00000010 */
N#define EXTI_EMR_MR4              EXTI_EMR_MR4_Msk                             /*!< Event Mask on line 4 */
N#define EXTI_EMR_MR5_Pos          (5U)                                         
N#define EXTI_EMR_MR5_Msk          (0x1UL << EXTI_EMR_MR5_Pos)                   /*!< 0x00000020 */
N#define EXTI_EMR_MR5              EXTI_EMR_MR5_Msk                             /*!< Event Mask on line 5 */
N#define EXTI_EMR_MR6_Pos          (6U)                                         
N#define EXTI_EMR_MR6_Msk          (0x1UL << EXTI_EMR_MR6_Pos)                   /*!< 0x00000040 */
N#define EXTI_EMR_MR6              EXTI_EMR_MR6_Msk                             /*!< Event Mask on line 6 */
N#define EXTI_EMR_MR7_Pos          (7U)                                         
N#define EXTI_EMR_MR7_Msk          (0x1UL << EXTI_EMR_MR7_Pos)                   /*!< 0x00000080 */
N#define EXTI_EMR_MR7              EXTI_EMR_MR7_Msk                             /*!< Event Mask on line 7 */
N#define EXTI_EMR_MR8_Pos          (8U)                                         
N#define EXTI_EMR_MR8_Msk          (0x1UL << EXTI_EMR_MR8_Pos)                   /*!< 0x00000100 */
N#define EXTI_EMR_MR8              EXTI_EMR_MR8_Msk                             /*!< Event Mask on line 8 */
N#define EXTI_EMR_MR9_Pos          (9U)                                         
N#define EXTI_EMR_MR9_Msk          (0x1UL << EXTI_EMR_MR9_Pos)                   /*!< 0x00000200 */
N#define EXTI_EMR_MR9              EXTI_EMR_MR9_Msk                             /*!< Event Mask on line 9 */
N#define EXTI_EMR_MR10_Pos         (10U)                                        
N#define EXTI_EMR_MR10_Msk         (0x1UL << EXTI_EMR_MR10_Pos)                  /*!< 0x00000400 */
N#define EXTI_EMR_MR10             EXTI_EMR_MR10_Msk                            /*!< Event Mask on line 10 */
N#define EXTI_EMR_MR11_Pos         (11U)                                        
N#define EXTI_EMR_MR11_Msk         (0x1UL << EXTI_EMR_MR11_Pos)                  /*!< 0x00000800 */
N#define EXTI_EMR_MR11             EXTI_EMR_MR11_Msk                            /*!< Event Mask on line 11 */
N#define EXTI_EMR_MR12_Pos         (12U)                                        
N#define EXTI_EMR_MR12_Msk         (0x1UL << EXTI_EMR_MR12_Pos)                  /*!< 0x00001000 */
N#define EXTI_EMR_MR12             EXTI_EMR_MR12_Msk                            /*!< Event Mask on line 12 */
N#define EXTI_EMR_MR13_Pos         (13U)                                        
N#define EXTI_EMR_MR13_Msk         (0x1UL << EXTI_EMR_MR13_Pos)                  /*!< 0x00002000 */
N#define EXTI_EMR_MR13             EXTI_EMR_MR13_Msk                            /*!< Event Mask on line 13 */
N#define EXTI_EMR_MR14_Pos         (14U)                                        
N#define EXTI_EMR_MR14_Msk         (0x1UL << EXTI_EMR_MR14_Pos)                  /*!< 0x00004000 */
N#define EXTI_EMR_MR14             EXTI_EMR_MR14_Msk                            /*!< Event Mask on line 14 */
N#define EXTI_EMR_MR15_Pos         (15U)                                        
N#define EXTI_EMR_MR15_Msk         (0x1UL << EXTI_EMR_MR15_Pos)                  /*!< 0x00008000 */
N#define EXTI_EMR_MR15             EXTI_EMR_MR15_Msk                            /*!< Event Mask on line 15 */
N#define EXTI_EMR_MR16_Pos         (16U)                                        
N#define EXTI_EMR_MR16_Msk         (0x1UL << EXTI_EMR_MR16_Pos)                  /*!< 0x00010000 */
N#define EXTI_EMR_MR16             EXTI_EMR_MR16_Msk                            /*!< Event Mask on line 16 */
N#define EXTI_EMR_MR17_Pos         (17U)                                        
N#define EXTI_EMR_MR17_Msk         (0x1UL << EXTI_EMR_MR17_Pos)                  /*!< 0x00020000 */
N#define EXTI_EMR_MR17             EXTI_EMR_MR17_Msk                            /*!< Event Mask on line 17 */
N#define EXTI_EMR_MR18_Pos         (18U)                                        
N#define EXTI_EMR_MR18_Msk         (0x1UL << EXTI_EMR_MR18_Pos)                  /*!< 0x00040000 */
N#define EXTI_EMR_MR18             EXTI_EMR_MR18_Msk                            /*!< Event Mask on line 18 */
N#define EXTI_EMR_MR19_Pos         (19U)                                        
N#define EXTI_EMR_MR19_Msk         (0x1UL << EXTI_EMR_MR19_Pos)                  /*!< 0x00080000 */
N#define EXTI_EMR_MR19             EXTI_EMR_MR19_Msk                            /*!< Event Mask on line 19 */
N#define EXTI_EMR_MR20_Pos         (20U)                                        
N#define EXTI_EMR_MR20_Msk         (0x1UL << EXTI_EMR_MR20_Pos)                  /*!< 0x00100000 */
N#define EXTI_EMR_MR20             EXTI_EMR_MR20_Msk                            /*!< Event Mask on line 20 */
N#define EXTI_EMR_MR21_Pos         (21U)                                        
N#define EXTI_EMR_MR21_Msk         (0x1UL << EXTI_EMR_MR21_Pos)                  /*!< 0x00200000 */
N#define EXTI_EMR_MR21             EXTI_EMR_MR21_Msk                            /*!< Event Mask on line 21 */
N#define EXTI_EMR_MR22_Pos         (22U)                                        
N#define EXTI_EMR_MR22_Msk         (0x1UL << EXTI_EMR_MR22_Pos)                  /*!< 0x00400000 */
N#define EXTI_EMR_MR22             EXTI_EMR_MR22_Msk                            /*!< Event Mask on line 22 */
N
N/* Reference Defines */
N#define  EXTI_EMR_EM0                        EXTI_EMR_MR0
N#define  EXTI_EMR_EM1                        EXTI_EMR_MR1
N#define  EXTI_EMR_EM2                        EXTI_EMR_MR2
N#define  EXTI_EMR_EM3                        EXTI_EMR_MR3
N#define  EXTI_EMR_EM4                        EXTI_EMR_MR4
N#define  EXTI_EMR_EM5                        EXTI_EMR_MR5
N#define  EXTI_EMR_EM6                        EXTI_EMR_MR6
N#define  EXTI_EMR_EM7                        EXTI_EMR_MR7
N#define  EXTI_EMR_EM8                        EXTI_EMR_MR8
N#define  EXTI_EMR_EM9                        EXTI_EMR_MR9
N#define  EXTI_EMR_EM10                       EXTI_EMR_MR10
N#define  EXTI_EMR_EM11                       EXTI_EMR_MR11
N#define  EXTI_EMR_EM12                       EXTI_EMR_MR12
N#define  EXTI_EMR_EM13                       EXTI_EMR_MR13
N#define  EXTI_EMR_EM14                       EXTI_EMR_MR14
N#define  EXTI_EMR_EM15                       EXTI_EMR_MR15
N#define  EXTI_EMR_EM16                       EXTI_EMR_MR16
N#define  EXTI_EMR_EM17                       EXTI_EMR_MR17
N#define  EXTI_EMR_EM18                       EXTI_EMR_MR18
N#define  EXTI_EMR_EM19                       EXTI_EMR_MR19
N#define  EXTI_EMR_EM20                       EXTI_EMR_MR20
N#define  EXTI_EMR_EM21                       EXTI_EMR_MR21
N#define  EXTI_EMR_EM22                       EXTI_EMR_MR22
N
N/******************  Bit definition for EXTI_RTSR register  *******************/
N#define EXTI_RTSR_TR0_Pos         (0U)                                         
N#define EXTI_RTSR_TR0_Msk         (0x1UL << EXTI_RTSR_TR0_Pos)                  /*!< 0x00000001 */
N#define EXTI_RTSR_TR0             EXTI_RTSR_TR0_Msk                            /*!< Rising trigger event configuration bit of line 0 */
N#define EXTI_RTSR_TR1_Pos         (1U)                                         
N#define EXTI_RTSR_TR1_Msk         (0x1UL << EXTI_RTSR_TR1_Pos)                  /*!< 0x00000002 */
N#define EXTI_RTSR_TR1             EXTI_RTSR_TR1_Msk                            /*!< Rising trigger event configuration bit of line 1 */
N#define EXTI_RTSR_TR2_Pos         (2U)                                         
N#define EXTI_RTSR_TR2_Msk         (0x1UL << EXTI_RTSR_TR2_Pos)                  /*!< 0x00000004 */
N#define EXTI_RTSR_TR2             EXTI_RTSR_TR2_Msk                            /*!< Rising trigger event configuration bit of line 2 */
N#define EXTI_RTSR_TR3_Pos         (3U)                                         
N#define EXTI_RTSR_TR3_Msk         (0x1UL << EXTI_RTSR_TR3_Pos)                  /*!< 0x00000008 */
N#define EXTI_RTSR_TR3             EXTI_RTSR_TR3_Msk                            /*!< Rising trigger event configuration bit of line 3 */
N#define EXTI_RTSR_TR4_Pos         (4U)                                         
N#define EXTI_RTSR_TR4_Msk         (0x1UL << EXTI_RTSR_TR4_Pos)                  /*!< 0x00000010 */
N#define EXTI_RTSR_TR4             EXTI_RTSR_TR4_Msk                            /*!< Rising trigger event configuration bit of line 4 */
N#define EXTI_RTSR_TR5_Pos         (5U)                                         
N#define EXTI_RTSR_TR5_Msk         (0x1UL << EXTI_RTSR_TR5_Pos)                  /*!< 0x00000020 */
N#define EXTI_RTSR_TR5             EXTI_RTSR_TR5_Msk                            /*!< Rising trigger event configuration bit of line 5 */
N#define EXTI_RTSR_TR6_Pos         (6U)                                         
N#define EXTI_RTSR_TR6_Msk         (0x1UL << EXTI_RTSR_TR6_Pos)                  /*!< 0x00000040 */
N#define EXTI_RTSR_TR6             EXTI_RTSR_TR6_Msk                            /*!< Rising trigger event configuration bit of line 6 */
N#define EXTI_RTSR_TR7_Pos         (7U)                                         
N#define EXTI_RTSR_TR7_Msk         (0x1UL << EXTI_RTSR_TR7_Pos)                  /*!< 0x00000080 */
N#define EXTI_RTSR_TR7             EXTI_RTSR_TR7_Msk                            /*!< Rising trigger event configuration bit of line 7 */
N#define EXTI_RTSR_TR8_Pos         (8U)                                         
N#define EXTI_RTSR_TR8_Msk         (0x1UL << EXTI_RTSR_TR8_Pos)                  /*!< 0x00000100 */
N#define EXTI_RTSR_TR8             EXTI_RTSR_TR8_Msk                            /*!< Rising trigger event configuration bit of line 8 */
N#define EXTI_RTSR_TR9_Pos         (9U)                                         
N#define EXTI_RTSR_TR9_Msk         (0x1UL << EXTI_RTSR_TR9_Pos)                  /*!< 0x00000200 */
N#define EXTI_RTSR_TR9             EXTI_RTSR_TR9_Msk                            /*!< Rising trigger event configuration bit of line 9 */
N#define EXTI_RTSR_TR10_Pos        (10U)                                        
N#define EXTI_RTSR_TR10_Msk        (0x1UL << EXTI_RTSR_TR10_Pos)                 /*!< 0x00000400 */
N#define EXTI_RTSR_TR10            EXTI_RTSR_TR10_Msk                           /*!< Rising trigger event configuration bit of line 10 */
N#define EXTI_RTSR_TR11_Pos        (11U)                                        
N#define EXTI_RTSR_TR11_Msk        (0x1UL << EXTI_RTSR_TR11_Pos)                 /*!< 0x00000800 */
N#define EXTI_RTSR_TR11            EXTI_RTSR_TR11_Msk                           /*!< Rising trigger event configuration bit of line 11 */
N#define EXTI_RTSR_TR12_Pos        (12U)                                        
N#define EXTI_RTSR_TR12_Msk        (0x1UL << EXTI_RTSR_TR12_Pos)                 /*!< 0x00001000 */
N#define EXTI_RTSR_TR12            EXTI_RTSR_TR12_Msk                           /*!< Rising trigger event configuration bit of line 12 */
N#define EXTI_RTSR_TR13_Pos        (13U)                                        
N#define EXTI_RTSR_TR13_Msk        (0x1UL << EXTI_RTSR_TR13_Pos)                 /*!< 0x00002000 */
N#define EXTI_RTSR_TR13            EXTI_RTSR_TR13_Msk                           /*!< Rising trigger event configuration bit of line 13 */
N#define EXTI_RTSR_TR14_Pos        (14U)                                        
N#define EXTI_RTSR_TR14_Msk        (0x1UL << EXTI_RTSR_TR14_Pos)                 /*!< 0x00004000 */
N#define EXTI_RTSR_TR14            EXTI_RTSR_TR14_Msk                           /*!< Rising trigger event configuration bit of line 14 */
N#define EXTI_RTSR_TR15_Pos        (15U)                                        
N#define EXTI_RTSR_TR15_Msk        (0x1UL << EXTI_RTSR_TR15_Pos)                 /*!< 0x00008000 */
N#define EXTI_RTSR_TR15            EXTI_RTSR_TR15_Msk                           /*!< Rising trigger event configuration bit of line 15 */
N#define EXTI_RTSR_TR16_Pos        (16U)                                        
N#define EXTI_RTSR_TR16_Msk        (0x1UL << EXTI_RTSR_TR16_Pos)                 /*!< 0x00010000 */
N#define EXTI_RTSR_TR16            EXTI_RTSR_TR16_Msk                           /*!< Rising trigger event configuration bit of line 16 */
N#define EXTI_RTSR_TR17_Pos        (17U)                                        
N#define EXTI_RTSR_TR17_Msk        (0x1UL << EXTI_RTSR_TR17_Pos)                 /*!< 0x00020000 */
N#define EXTI_RTSR_TR17            EXTI_RTSR_TR17_Msk                           /*!< Rising trigger event configuration bit of line 17 */
N#define EXTI_RTSR_TR18_Pos        (18U)                                        
N#define EXTI_RTSR_TR18_Msk        (0x1UL << EXTI_RTSR_TR18_Pos)                 /*!< 0x00040000 */
N#define EXTI_RTSR_TR18            EXTI_RTSR_TR18_Msk                           /*!< Rising trigger event configuration bit of line 18 */
N#define EXTI_RTSR_TR19_Pos        (19U)                                        
N#define EXTI_RTSR_TR19_Msk        (0x1UL << EXTI_RTSR_TR19_Pos)                 /*!< 0x00080000 */
N#define EXTI_RTSR_TR19            EXTI_RTSR_TR19_Msk                           /*!< Rising trigger event configuration bit of line 19 */
N#define EXTI_RTSR_TR20_Pos        (20U)                                        
N#define EXTI_RTSR_TR20_Msk        (0x1UL << EXTI_RTSR_TR20_Pos)                 /*!< 0x00100000 */
N#define EXTI_RTSR_TR20            EXTI_RTSR_TR20_Msk                           /*!< Rising trigger event configuration bit of line 20 */
N#define EXTI_RTSR_TR21_Pos        (21U)                                        
N#define EXTI_RTSR_TR21_Msk        (0x1UL << EXTI_RTSR_TR21_Pos)                 /*!< 0x00200000 */
N#define EXTI_RTSR_TR21            EXTI_RTSR_TR21_Msk                           /*!< Rising trigger event configuration bit of line 21 */
N#define EXTI_RTSR_TR22_Pos        (22U)                                        
N#define EXTI_RTSR_TR22_Msk        (0x1UL << EXTI_RTSR_TR22_Pos)                 /*!< 0x00400000 */
N#define EXTI_RTSR_TR22            EXTI_RTSR_TR22_Msk                           /*!< Rising trigger event configuration bit of line 22 */
N
N/******************  Bit definition for EXTI_FTSR register  *******************/
N#define EXTI_FTSR_TR0_Pos         (0U)                                         
N#define EXTI_FTSR_TR0_Msk         (0x1UL << EXTI_FTSR_TR0_Pos)                  /*!< 0x00000001 */
N#define EXTI_FTSR_TR0             EXTI_FTSR_TR0_Msk                            /*!< Falling trigger event configuration bit of line 0 */
N#define EXTI_FTSR_TR1_Pos         (1U)                                         
N#define EXTI_FTSR_TR1_Msk         (0x1UL << EXTI_FTSR_TR1_Pos)                  /*!< 0x00000002 */
N#define EXTI_FTSR_TR1             EXTI_FTSR_TR1_Msk                            /*!< Falling trigger event configuration bit of line 1 */
N#define EXTI_FTSR_TR2_Pos         (2U)                                         
N#define EXTI_FTSR_TR2_Msk         (0x1UL << EXTI_FTSR_TR2_Pos)                  /*!< 0x00000004 */
N#define EXTI_FTSR_TR2             EXTI_FTSR_TR2_Msk                            /*!< Falling trigger event configuration bit of line 2 */
N#define EXTI_FTSR_TR3_Pos         (3U)                                         
N#define EXTI_FTSR_TR3_Msk         (0x1UL << EXTI_FTSR_TR3_Pos)                  /*!< 0x00000008 */
N#define EXTI_FTSR_TR3             EXTI_FTSR_TR3_Msk                            /*!< Falling trigger event configuration bit of line 3 */
N#define EXTI_FTSR_TR4_Pos         (4U)                                         
N#define EXTI_FTSR_TR4_Msk         (0x1UL << EXTI_FTSR_TR4_Pos)                  /*!< 0x00000010 */
N#define EXTI_FTSR_TR4             EXTI_FTSR_TR4_Msk                            /*!< Falling trigger event configuration bit of line 4 */
N#define EXTI_FTSR_TR5_Pos         (5U)                                         
N#define EXTI_FTSR_TR5_Msk         (0x1UL << EXTI_FTSR_TR5_Pos)                  /*!< 0x00000020 */
N#define EXTI_FTSR_TR5             EXTI_FTSR_TR5_Msk                            /*!< Falling trigger event configuration bit of line 5 */
N#define EXTI_FTSR_TR6_Pos         (6U)                                         
N#define EXTI_FTSR_TR6_Msk         (0x1UL << EXTI_FTSR_TR6_Pos)                  /*!< 0x00000040 */
N#define EXTI_FTSR_TR6             EXTI_FTSR_TR6_Msk                            /*!< Falling trigger event configuration bit of line 6 */
N#define EXTI_FTSR_TR7_Pos         (7U)                                         
N#define EXTI_FTSR_TR7_Msk         (0x1UL << EXTI_FTSR_TR7_Pos)                  /*!< 0x00000080 */
N#define EXTI_FTSR_TR7             EXTI_FTSR_TR7_Msk                            /*!< Falling trigger event configuration bit of line 7 */
N#define EXTI_FTSR_TR8_Pos         (8U)                                         
N#define EXTI_FTSR_TR8_Msk         (0x1UL << EXTI_FTSR_TR8_Pos)                  /*!< 0x00000100 */
N#define EXTI_FTSR_TR8             EXTI_FTSR_TR8_Msk                            /*!< Falling trigger event configuration bit of line 8 */
N#define EXTI_FTSR_TR9_Pos         (9U)                                         
N#define EXTI_FTSR_TR9_Msk         (0x1UL << EXTI_FTSR_TR9_Pos)                  /*!< 0x00000200 */
N#define EXTI_FTSR_TR9             EXTI_FTSR_TR9_Msk                            /*!< Falling trigger event configuration bit of line 9 */
N#define EXTI_FTSR_TR10_Pos        (10U)                                        
N#define EXTI_FTSR_TR10_Msk        (0x1UL << EXTI_FTSR_TR10_Pos)                 /*!< 0x00000400 */
N#define EXTI_FTSR_TR10            EXTI_FTSR_TR10_Msk                           /*!< Falling trigger event configuration bit of line 10 */
N#define EXTI_FTSR_TR11_Pos        (11U)                                        
N#define EXTI_FTSR_TR11_Msk        (0x1UL << EXTI_FTSR_TR11_Pos)                 /*!< 0x00000800 */
N#define EXTI_FTSR_TR11            EXTI_FTSR_TR11_Msk                           /*!< Falling trigger event configuration bit of line 11 */
N#define EXTI_FTSR_TR12_Pos        (12U)                                        
N#define EXTI_FTSR_TR12_Msk        (0x1UL << EXTI_FTSR_TR12_Pos)                 /*!< 0x00001000 */
N#define EXTI_FTSR_TR12            EXTI_FTSR_TR12_Msk                           /*!< Falling trigger event configuration bit of line 12 */
N#define EXTI_FTSR_TR13_Pos        (13U)                                        
N#define EXTI_FTSR_TR13_Msk        (0x1UL << EXTI_FTSR_TR13_Pos)                 /*!< 0x00002000 */
N#define EXTI_FTSR_TR13            EXTI_FTSR_TR13_Msk                           /*!< Falling trigger event configuration bit of line 13 */
N#define EXTI_FTSR_TR14_Pos        (14U)                                        
N#define EXTI_FTSR_TR14_Msk        (0x1UL << EXTI_FTSR_TR14_Pos)                 /*!< 0x00004000 */
N#define EXTI_FTSR_TR14            EXTI_FTSR_TR14_Msk                           /*!< Falling trigger event configuration bit of line 14 */
N#define EXTI_FTSR_TR15_Pos        (15U)                                        
N#define EXTI_FTSR_TR15_Msk        (0x1UL << EXTI_FTSR_TR15_Pos)                 /*!< 0x00008000 */
N#define EXTI_FTSR_TR15            EXTI_FTSR_TR15_Msk                           /*!< Falling trigger event configuration bit of line 15 */
N#define EXTI_FTSR_TR16_Pos        (16U)                                        
N#define EXTI_FTSR_TR16_Msk        (0x1UL << EXTI_FTSR_TR16_Pos)                 /*!< 0x00010000 */
N#define EXTI_FTSR_TR16            EXTI_FTSR_TR16_Msk                           /*!< Falling trigger event configuration bit of line 16 */
N#define EXTI_FTSR_TR17_Pos        (17U)                                        
N#define EXTI_FTSR_TR17_Msk        (0x1UL << EXTI_FTSR_TR17_Pos)                 /*!< 0x00020000 */
N#define EXTI_FTSR_TR17            EXTI_FTSR_TR17_Msk                           /*!< Falling trigger event configuration bit of line 17 */
N#define EXTI_FTSR_TR18_Pos        (18U)                                        
N#define EXTI_FTSR_TR18_Msk        (0x1UL << EXTI_FTSR_TR18_Pos)                 /*!< 0x00040000 */
N#define EXTI_FTSR_TR18            EXTI_FTSR_TR18_Msk                           /*!< Falling trigger event configuration bit of line 18 */
N#define EXTI_FTSR_TR19_Pos        (19U)                                        
N#define EXTI_FTSR_TR19_Msk        (0x1UL << EXTI_FTSR_TR19_Pos)                 /*!< 0x00080000 */
N#define EXTI_FTSR_TR19            EXTI_FTSR_TR19_Msk                           /*!< Falling trigger event configuration bit of line 19 */
N#define EXTI_FTSR_TR20_Pos        (20U)                                        
N#define EXTI_FTSR_TR20_Msk        (0x1UL << EXTI_FTSR_TR20_Pos)                 /*!< 0x00100000 */
N#define EXTI_FTSR_TR20            EXTI_FTSR_TR20_Msk                           /*!< Falling trigger event configuration bit of line 20 */
N#define EXTI_FTSR_TR21_Pos        (21U)                                        
N#define EXTI_FTSR_TR21_Msk        (0x1UL << EXTI_FTSR_TR21_Pos)                 /*!< 0x00200000 */
N#define EXTI_FTSR_TR21            EXTI_FTSR_TR21_Msk                           /*!< Falling trigger event configuration bit of line 21 */
N#define EXTI_FTSR_TR22_Pos        (22U)                                        
N#define EXTI_FTSR_TR22_Msk        (0x1UL << EXTI_FTSR_TR22_Pos)                 /*!< 0x00400000 */
N#define EXTI_FTSR_TR22            EXTI_FTSR_TR22_Msk                           /*!< Falling trigger event configuration bit of line 22 */
N
N/******************  Bit definition for EXTI_SWIER register  ******************/
N#define EXTI_SWIER_SWIER0_Pos     (0U)                                         
N#define EXTI_SWIER_SWIER0_Msk     (0x1UL << EXTI_SWIER_SWIER0_Pos)              /*!< 0x00000001 */
N#define EXTI_SWIER_SWIER0         EXTI_SWIER_SWIER0_Msk                        /*!< Software Interrupt on line 0 */
N#define EXTI_SWIER_SWIER1_Pos     (1U)                                         
N#define EXTI_SWIER_SWIER1_Msk     (0x1UL << EXTI_SWIER_SWIER1_Pos)              /*!< 0x00000002 */
N#define EXTI_SWIER_SWIER1         EXTI_SWIER_SWIER1_Msk                        /*!< Software Interrupt on line 1 */
N#define EXTI_SWIER_SWIER2_Pos     (2U)                                         
N#define EXTI_SWIER_SWIER2_Msk     (0x1UL << EXTI_SWIER_SWIER2_Pos)              /*!< 0x00000004 */
N#define EXTI_SWIER_SWIER2         EXTI_SWIER_SWIER2_Msk                        /*!< Software Interrupt on line 2 */
N#define EXTI_SWIER_SWIER3_Pos     (3U)                                         
N#define EXTI_SWIER_SWIER3_Msk     (0x1UL << EXTI_SWIER_SWIER3_Pos)              /*!< 0x00000008 */
N#define EXTI_SWIER_SWIER3         EXTI_SWIER_SWIER3_Msk                        /*!< Software Interrupt on line 3 */
N#define EXTI_SWIER_SWIER4_Pos     (4U)                                         
N#define EXTI_SWIER_SWIER4_Msk     (0x1UL << EXTI_SWIER_SWIER4_Pos)              /*!< 0x00000010 */
N#define EXTI_SWIER_SWIER4         EXTI_SWIER_SWIER4_Msk                        /*!< Software Interrupt on line 4 */
N#define EXTI_SWIER_SWIER5_Pos     (5U)                                         
N#define EXTI_SWIER_SWIER5_Msk     (0x1UL << EXTI_SWIER_SWIER5_Pos)              /*!< 0x00000020 */
N#define EXTI_SWIER_SWIER5         EXTI_SWIER_SWIER5_Msk                        /*!< Software Interrupt on line 5 */
N#define EXTI_SWIER_SWIER6_Pos     (6U)                                         
N#define EXTI_SWIER_SWIER6_Msk     (0x1UL << EXTI_SWIER_SWIER6_Pos)              /*!< 0x00000040 */
N#define EXTI_SWIER_SWIER6         EXTI_SWIER_SWIER6_Msk                        /*!< Software Interrupt on line 6 */
N#define EXTI_SWIER_SWIER7_Pos     (7U)                                         
N#define EXTI_SWIER_SWIER7_Msk     (0x1UL << EXTI_SWIER_SWIER7_Pos)              /*!< 0x00000080 */
N#define EXTI_SWIER_SWIER7         EXTI_SWIER_SWIER7_Msk                        /*!< Software Interrupt on line 7 */
N#define EXTI_SWIER_SWIER8_Pos     (8U)                                         
N#define EXTI_SWIER_SWIER8_Msk     (0x1UL << EXTI_SWIER_SWIER8_Pos)              /*!< 0x00000100 */
N#define EXTI_SWIER_SWIER8         EXTI_SWIER_SWIER8_Msk                        /*!< Software Interrupt on line 8 */
N#define EXTI_SWIER_SWIER9_Pos     (9U)                                         
N#define EXTI_SWIER_SWIER9_Msk     (0x1UL << EXTI_SWIER_SWIER9_Pos)              /*!< 0x00000200 */
N#define EXTI_SWIER_SWIER9         EXTI_SWIER_SWIER9_Msk                        /*!< Software Interrupt on line 9 */
N#define EXTI_SWIER_SWIER10_Pos    (10U)                                        
N#define EXTI_SWIER_SWIER10_Msk    (0x1UL << EXTI_SWIER_SWIER10_Pos)             /*!< 0x00000400 */
N#define EXTI_SWIER_SWIER10        EXTI_SWIER_SWIER10_Msk                       /*!< Software Interrupt on line 10 */
N#define EXTI_SWIER_SWIER11_Pos    (11U)                                        
N#define EXTI_SWIER_SWIER11_Msk    (0x1UL << EXTI_SWIER_SWIER11_Pos)             /*!< 0x00000800 */
N#define EXTI_SWIER_SWIER11        EXTI_SWIER_SWIER11_Msk                       /*!< Software Interrupt on line 11 */
N#define EXTI_SWIER_SWIER12_Pos    (12U)                                        
N#define EXTI_SWIER_SWIER12_Msk    (0x1UL << EXTI_SWIER_SWIER12_Pos)             /*!< 0x00001000 */
N#define EXTI_SWIER_SWIER12        EXTI_SWIER_SWIER12_Msk                       /*!< Software Interrupt on line 12 */
N#define EXTI_SWIER_SWIER13_Pos    (13U)                                        
N#define EXTI_SWIER_SWIER13_Msk    (0x1UL << EXTI_SWIER_SWIER13_Pos)             /*!< 0x00002000 */
N#define EXTI_SWIER_SWIER13        EXTI_SWIER_SWIER13_Msk                       /*!< Software Interrupt on line 13 */
N#define EXTI_SWIER_SWIER14_Pos    (14U)                                        
N#define EXTI_SWIER_SWIER14_Msk    (0x1UL << EXTI_SWIER_SWIER14_Pos)             /*!< 0x00004000 */
N#define EXTI_SWIER_SWIER14        EXTI_SWIER_SWIER14_Msk                       /*!< Software Interrupt on line 14 */
N#define EXTI_SWIER_SWIER15_Pos    (15U)                                        
N#define EXTI_SWIER_SWIER15_Msk    (0x1UL << EXTI_SWIER_SWIER15_Pos)             /*!< 0x00008000 */
N#define EXTI_SWIER_SWIER15        EXTI_SWIER_SWIER15_Msk                       /*!< Software Interrupt on line 15 */
N#define EXTI_SWIER_SWIER16_Pos    (16U)                                        
N#define EXTI_SWIER_SWIER16_Msk    (0x1UL << EXTI_SWIER_SWIER16_Pos)             /*!< 0x00010000 */
N#define EXTI_SWIER_SWIER16        EXTI_SWIER_SWIER16_Msk                       /*!< Software Interrupt on line 16 */
N#define EXTI_SWIER_SWIER17_Pos    (17U)                                        
N#define EXTI_SWIER_SWIER17_Msk    (0x1UL << EXTI_SWIER_SWIER17_Pos)             /*!< 0x00020000 */
N#define EXTI_SWIER_SWIER17        EXTI_SWIER_SWIER17_Msk                       /*!< Software Interrupt on line 17 */
N#define EXTI_SWIER_SWIER18_Pos    (18U)                                        
N#define EXTI_SWIER_SWIER18_Msk    (0x1UL << EXTI_SWIER_SWIER18_Pos)             /*!< 0x00040000 */
N#define EXTI_SWIER_SWIER18        EXTI_SWIER_SWIER18_Msk                       /*!< Software Interrupt on line 18 */
N#define EXTI_SWIER_SWIER19_Pos    (19U)                                        
N#define EXTI_SWIER_SWIER19_Msk    (0x1UL << EXTI_SWIER_SWIER19_Pos)             /*!< 0x00080000 */
N#define EXTI_SWIER_SWIER19        EXTI_SWIER_SWIER19_Msk                       /*!< Software Interrupt on line 19 */
N#define EXTI_SWIER_SWIER20_Pos    (20U)                                        
N#define EXTI_SWIER_SWIER20_Msk    (0x1UL << EXTI_SWIER_SWIER20_Pos)             /*!< 0x00100000 */
N#define EXTI_SWIER_SWIER20        EXTI_SWIER_SWIER20_Msk                       /*!< Software Interrupt on line 20 */
N#define EXTI_SWIER_SWIER21_Pos    (21U)                                        
N#define EXTI_SWIER_SWIER21_Msk    (0x1UL << EXTI_SWIER_SWIER21_Pos)             /*!< 0x00200000 */
N#define EXTI_SWIER_SWIER21        EXTI_SWIER_SWIER21_Msk                       /*!< Software Interrupt on line 21 */
N#define EXTI_SWIER_SWIER22_Pos    (22U)                                        
N#define EXTI_SWIER_SWIER22_Msk    (0x1UL << EXTI_SWIER_SWIER22_Pos)             /*!< 0x00400000 */
N#define EXTI_SWIER_SWIER22        EXTI_SWIER_SWIER22_Msk                       /*!< Software Interrupt on line 22 */
N
N/*******************  Bit definition for EXTI_PR register  ********************/
N#define EXTI_PR_PR0_Pos           (0U)                                         
N#define EXTI_PR_PR0_Msk           (0x1UL << EXTI_PR_PR0_Pos)                    /*!< 0x00000001 */
N#define EXTI_PR_PR0               EXTI_PR_PR0_Msk                              /*!< Pending bit for line 0 */
N#define EXTI_PR_PR1_Pos           (1U)                                         
N#define EXTI_PR_PR1_Msk           (0x1UL << EXTI_PR_PR1_Pos)                    /*!< 0x00000002 */
N#define EXTI_PR_PR1               EXTI_PR_PR1_Msk                              /*!< Pending bit for line 1 */
N#define EXTI_PR_PR2_Pos           (2U)                                         
N#define EXTI_PR_PR2_Msk           (0x1UL << EXTI_PR_PR2_Pos)                    /*!< 0x00000004 */
N#define EXTI_PR_PR2               EXTI_PR_PR2_Msk                              /*!< Pending bit for line 2 */
N#define EXTI_PR_PR3_Pos           (3U)                                         
N#define EXTI_PR_PR3_Msk           (0x1UL << EXTI_PR_PR3_Pos)                    /*!< 0x00000008 */
N#define EXTI_PR_PR3               EXTI_PR_PR3_Msk                              /*!< Pending bit for line 3 */
N#define EXTI_PR_PR4_Pos           (4U)                                         
N#define EXTI_PR_PR4_Msk           (0x1UL << EXTI_PR_PR4_Pos)                    /*!< 0x00000010 */
N#define EXTI_PR_PR4               EXTI_PR_PR4_Msk                              /*!< Pending bit for line 4 */
N#define EXTI_PR_PR5_Pos           (5U)                                         
N#define EXTI_PR_PR5_Msk           (0x1UL << EXTI_PR_PR5_Pos)                    /*!< 0x00000020 */
N#define EXTI_PR_PR5               EXTI_PR_PR5_Msk                              /*!< Pending bit for line 5 */
N#define EXTI_PR_PR6_Pos           (6U)                                         
N#define EXTI_PR_PR6_Msk           (0x1UL << EXTI_PR_PR6_Pos)                    /*!< 0x00000040 */
N#define EXTI_PR_PR6               EXTI_PR_PR6_Msk                              /*!< Pending bit for line 6 */
N#define EXTI_PR_PR7_Pos           (7U)                                         
N#define EXTI_PR_PR7_Msk           (0x1UL << EXTI_PR_PR7_Pos)                    /*!< 0x00000080 */
N#define EXTI_PR_PR7               EXTI_PR_PR7_Msk                              /*!< Pending bit for line 7 */
N#define EXTI_PR_PR8_Pos           (8U)                                         
N#define EXTI_PR_PR8_Msk           (0x1UL << EXTI_PR_PR8_Pos)                    /*!< 0x00000100 */
N#define EXTI_PR_PR8               EXTI_PR_PR8_Msk                              /*!< Pending bit for line 8 */
N#define EXTI_PR_PR9_Pos           (9U)                                         
N#define EXTI_PR_PR9_Msk           (0x1UL << EXTI_PR_PR9_Pos)                    /*!< 0x00000200 */
N#define EXTI_PR_PR9               EXTI_PR_PR9_Msk                              /*!< Pending bit for line 9 */
N#define EXTI_PR_PR10_Pos          (10U)                                        
N#define EXTI_PR_PR10_Msk          (0x1UL << EXTI_PR_PR10_Pos)                   /*!< 0x00000400 */
N#define EXTI_PR_PR10              EXTI_PR_PR10_Msk                             /*!< Pending bit for line 10 */
N#define EXTI_PR_PR11_Pos          (11U)                                        
N#define EXTI_PR_PR11_Msk          (0x1UL << EXTI_PR_PR11_Pos)                   /*!< 0x00000800 */
N#define EXTI_PR_PR11              EXTI_PR_PR11_Msk                             /*!< Pending bit for line 11 */
N#define EXTI_PR_PR12_Pos          (12U)                                        
N#define EXTI_PR_PR12_Msk          (0x1UL << EXTI_PR_PR12_Pos)                   /*!< 0x00001000 */
N#define EXTI_PR_PR12              EXTI_PR_PR12_Msk                             /*!< Pending bit for line 12 */
N#define EXTI_PR_PR13_Pos          (13U)                                        
N#define EXTI_PR_PR13_Msk          (0x1UL << EXTI_PR_PR13_Pos)                   /*!< 0x00002000 */
N#define EXTI_PR_PR13              EXTI_PR_PR13_Msk                             /*!< Pending bit for line 13 */
N#define EXTI_PR_PR14_Pos          (14U)                                        
N#define EXTI_PR_PR14_Msk          (0x1UL << EXTI_PR_PR14_Pos)                   /*!< 0x00004000 */
N#define EXTI_PR_PR14              EXTI_PR_PR14_Msk                             /*!< Pending bit for line 14 */
N#define EXTI_PR_PR15_Pos          (15U)                                        
N#define EXTI_PR_PR15_Msk          (0x1UL << EXTI_PR_PR15_Pos)                   /*!< 0x00008000 */
N#define EXTI_PR_PR15              EXTI_PR_PR15_Msk                             /*!< Pending bit for line 15 */
N#define EXTI_PR_PR16_Pos          (16U)                                        
N#define EXTI_PR_PR16_Msk          (0x1UL << EXTI_PR_PR16_Pos)                   /*!< 0x00010000 */
N#define EXTI_PR_PR16              EXTI_PR_PR16_Msk                             /*!< Pending bit for line 16 */
N#define EXTI_PR_PR17_Pos          (17U)                                        
N#define EXTI_PR_PR17_Msk          (0x1UL << EXTI_PR_PR17_Pos)                   /*!< 0x00020000 */
N#define EXTI_PR_PR17              EXTI_PR_PR17_Msk                             /*!< Pending bit for line 17 */
N#define EXTI_PR_PR18_Pos          (18U)                                        
N#define EXTI_PR_PR18_Msk          (0x1UL << EXTI_PR_PR18_Pos)                   /*!< 0x00040000 */
N#define EXTI_PR_PR18              EXTI_PR_PR18_Msk                             /*!< Pending bit for line 18 */
N#define EXTI_PR_PR19_Pos          (19U)                                        
N#define EXTI_PR_PR19_Msk          (0x1UL << EXTI_PR_PR19_Pos)                   /*!< 0x00080000 */
N#define EXTI_PR_PR19              EXTI_PR_PR19_Msk                             /*!< Pending bit for line 19 */
N#define EXTI_PR_PR20_Pos          (20U)                                        
N#define EXTI_PR_PR20_Msk          (0x1UL << EXTI_PR_PR20_Pos)                   /*!< 0x00100000 */
N#define EXTI_PR_PR20              EXTI_PR_PR20_Msk                             /*!< Pending bit for line 20 */
N#define EXTI_PR_PR21_Pos          (21U)                                        
N#define EXTI_PR_PR21_Msk          (0x1UL << EXTI_PR_PR21_Pos)                   /*!< 0x00200000 */
N#define EXTI_PR_PR21              EXTI_PR_PR21_Msk                             /*!< Pending bit for line 21 */
N#define EXTI_PR_PR22_Pos          (22U)                                        
N#define EXTI_PR_PR22_Msk          (0x1UL << EXTI_PR_PR22_Pos)                   /*!< 0x00400000 */
N#define EXTI_PR_PR22              EXTI_PR_PR22_Msk                             /*!< Pending bit for line 22 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    FLASH                                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bits definition for FLASH_ACR register  *****************/
N#define FLASH_ACR_LATENCY_Pos          (0U)                                    
N#define FLASH_ACR_LATENCY_Msk          (0xFUL << FLASH_ACR_LATENCY_Pos)         /*!< 0x0000000F */
N#define FLASH_ACR_LATENCY              FLASH_ACR_LATENCY_Msk                   
N#define FLASH_ACR_LATENCY_0WS          0x00000000U                             
N#define FLASH_ACR_LATENCY_1WS          0x00000001U                             
N#define FLASH_ACR_LATENCY_2WS          0x00000002U                             
N#define FLASH_ACR_LATENCY_3WS          0x00000003U                             
N#define FLASH_ACR_LATENCY_4WS          0x00000004U                             
N#define FLASH_ACR_LATENCY_5WS          0x00000005U                             
N#define FLASH_ACR_LATENCY_6WS          0x00000006U                             
N#define FLASH_ACR_LATENCY_7WS          0x00000007U                             
N
N#define FLASH_ACR_PRFTEN_Pos           (8U)                                    
N#define FLASH_ACR_PRFTEN_Msk           (0x1UL << FLASH_ACR_PRFTEN_Pos)          /*!< 0x00000100 */
N#define FLASH_ACR_PRFTEN               FLASH_ACR_PRFTEN_Msk                    
N#define FLASH_ACR_ICEN_Pos             (9U)                                    
N#define FLASH_ACR_ICEN_Msk             (0x1UL << FLASH_ACR_ICEN_Pos)            /*!< 0x00000200 */
N#define FLASH_ACR_ICEN                 FLASH_ACR_ICEN_Msk                      
N#define FLASH_ACR_DCEN_Pos             (10U)                                   
N#define FLASH_ACR_DCEN_Msk             (0x1UL << FLASH_ACR_DCEN_Pos)            /*!< 0x00000400 */
N#define FLASH_ACR_DCEN                 FLASH_ACR_DCEN_Msk                      
N#define FLASH_ACR_ICRST_Pos            (11U)                                   
N#define FLASH_ACR_ICRST_Msk            (0x1UL << FLASH_ACR_ICRST_Pos)           /*!< 0x00000800 */
N#define FLASH_ACR_ICRST                FLASH_ACR_ICRST_Msk                     
N#define FLASH_ACR_DCRST_Pos            (12U)                                   
N#define FLASH_ACR_DCRST_Msk            (0x1UL << FLASH_ACR_DCRST_Pos)           /*!< 0x00001000 */
N#define FLASH_ACR_DCRST                FLASH_ACR_DCRST_Msk                     
N#define FLASH_ACR_BYTE0_ADDRESS_Pos    (10U)                                   
N#define FLASH_ACR_BYTE0_ADDRESS_Msk    (0x10008FUL << FLASH_ACR_BYTE0_ADDRESS_Pos) /*!< 0x40023C00 */
N#define FLASH_ACR_BYTE0_ADDRESS        FLASH_ACR_BYTE0_ADDRESS_Msk             
N#define FLASH_ACR_BYTE2_ADDRESS_Pos    (0U)                                    
N#define FLASH_ACR_BYTE2_ADDRESS_Msk    (0x40023C03UL << FLASH_ACR_BYTE2_ADDRESS_Pos) /*!< 0x40023C03 */
N#define FLASH_ACR_BYTE2_ADDRESS        FLASH_ACR_BYTE2_ADDRESS_Msk             
N
N/*******************  Bits definition for FLASH_SR register  ******************/
N#define FLASH_SR_EOP_Pos               (0U)                                    
N#define FLASH_SR_EOP_Msk               (0x1UL << FLASH_SR_EOP_Pos)              /*!< 0x00000001 */
N#define FLASH_SR_EOP                   FLASH_SR_EOP_Msk                        
N#define FLASH_SR_SOP_Pos               (1U)                                    
N#define FLASH_SR_SOP_Msk               (0x1UL << FLASH_SR_SOP_Pos)              /*!< 0x00000002 */
N#define FLASH_SR_SOP                   FLASH_SR_SOP_Msk                        
N#define FLASH_SR_WRPERR_Pos            (4U)                                    
N#define FLASH_SR_WRPERR_Msk            (0x1UL << FLASH_SR_WRPERR_Pos)           /*!< 0x00000010 */
N#define FLASH_SR_WRPERR                FLASH_SR_WRPERR_Msk                     
N#define FLASH_SR_PGAERR_Pos            (5U)                                    
N#define FLASH_SR_PGAERR_Msk            (0x1UL << FLASH_SR_PGAERR_Pos)           /*!< 0x00000020 */
N#define FLASH_SR_PGAERR                FLASH_SR_PGAERR_Msk                     
N#define FLASH_SR_PGPERR_Pos            (6U)                                    
N#define FLASH_SR_PGPERR_Msk            (0x1UL << FLASH_SR_PGPERR_Pos)           /*!< 0x00000040 */
N#define FLASH_SR_PGPERR                FLASH_SR_PGPERR_Msk                     
N#define FLASH_SR_PGSERR_Pos            (7U)                                    
N#define FLASH_SR_PGSERR_Msk            (0x1UL << FLASH_SR_PGSERR_Pos)           /*!< 0x00000080 */
N#define FLASH_SR_PGSERR                FLASH_SR_PGSERR_Msk                     
N#define FLASH_SR_RDERR_Pos            (8U)                                    
N#define FLASH_SR_RDERR_Msk            (0x1UL << FLASH_SR_RDERR_Pos)             /*!< 0x00000100 */
N#define FLASH_SR_RDERR                FLASH_SR_RDERR_Msk                     
N#define FLASH_SR_BSY_Pos               (16U)                                   
N#define FLASH_SR_BSY_Msk               (0x1UL << FLASH_SR_BSY_Pos)              /*!< 0x00010000 */
N#define FLASH_SR_BSY                   FLASH_SR_BSY_Msk                        
N
N/*******************  Bits definition for FLASH_CR register  ******************/
N#define FLASH_CR_PG_Pos                (0U)                                    
N#define FLASH_CR_PG_Msk                (0x1UL << FLASH_CR_PG_Pos)               /*!< 0x00000001 */
N#define FLASH_CR_PG                    FLASH_CR_PG_Msk                         
N#define FLASH_CR_SER_Pos               (1U)                                    
N#define FLASH_CR_SER_Msk               (0x1UL << FLASH_CR_SER_Pos)              /*!< 0x00000002 */
N#define FLASH_CR_SER                   FLASH_CR_SER_Msk                        
N#define FLASH_CR_MER_Pos               (2U)                                    
N#define FLASH_CR_MER_Msk               (0x1UL << FLASH_CR_MER_Pos)              /*!< 0x00000004 */
N#define FLASH_CR_MER                   FLASH_CR_MER_Msk                        
N#define FLASH_CR_SNB_Pos               (3U)                                    
N#define FLASH_CR_SNB_Msk               (0x1FUL << FLASH_CR_SNB_Pos)             /*!< 0x000000F8 */
N#define FLASH_CR_SNB                   FLASH_CR_SNB_Msk                        
N#define FLASH_CR_SNB_0                 (0x01UL << FLASH_CR_SNB_Pos)             /*!< 0x00000008 */
N#define FLASH_CR_SNB_1                 (0x02UL << FLASH_CR_SNB_Pos)             /*!< 0x00000010 */
N#define FLASH_CR_SNB_2                 (0x04UL << FLASH_CR_SNB_Pos)             /*!< 0x00000020 */
N#define FLASH_CR_SNB_3                 (0x08UL << FLASH_CR_SNB_Pos)             /*!< 0x00000040 */
N#define FLASH_CR_SNB_4                 (0x10UL << FLASH_CR_SNB_Pos)             /*!< 0x00000080 */
N#define FLASH_CR_PSIZE_Pos             (8U)                                    
N#define FLASH_CR_PSIZE_Msk             (0x3UL << FLASH_CR_PSIZE_Pos)            /*!< 0x00000300 */
N#define FLASH_CR_PSIZE                 FLASH_CR_PSIZE_Msk                      
N#define FLASH_CR_PSIZE_0               (0x1UL << FLASH_CR_PSIZE_Pos)            /*!< 0x00000100 */
N#define FLASH_CR_PSIZE_1               (0x2UL << FLASH_CR_PSIZE_Pos)            /*!< 0x00000200 */
N#define FLASH_CR_STRT_Pos              (16U)                                   
N#define FLASH_CR_STRT_Msk              (0x1UL << FLASH_CR_STRT_Pos)             /*!< 0x00010000 */
N#define FLASH_CR_STRT                  FLASH_CR_STRT_Msk                       
N#define FLASH_CR_EOPIE_Pos             (24U)                                   
N#define FLASH_CR_EOPIE_Msk             (0x1UL << FLASH_CR_EOPIE_Pos)            /*!< 0x01000000 */
N#define FLASH_CR_EOPIE                 FLASH_CR_EOPIE_Msk                      
N#define FLASH_CR_LOCK_Pos              (31U)                                   
N#define FLASH_CR_LOCK_Msk              (0x1UL << FLASH_CR_LOCK_Pos)             /*!< 0x80000000 */
N#define FLASH_CR_LOCK                  FLASH_CR_LOCK_Msk                       
N
N/*******************  Bits definition for FLASH_OPTCR register  ***************/
N#define FLASH_OPTCR_OPTLOCK_Pos        (0U)                                    
N#define FLASH_OPTCR_OPTLOCK_Msk        (0x1UL << FLASH_OPTCR_OPTLOCK_Pos)       /*!< 0x00000001 */
N#define FLASH_OPTCR_OPTLOCK            FLASH_OPTCR_OPTLOCK_Msk                 
N#define FLASH_OPTCR_OPTSTRT_Pos        (1U)                                    
N#define FLASH_OPTCR_OPTSTRT_Msk        (0x1UL << FLASH_OPTCR_OPTSTRT_Pos)       /*!< 0x00000002 */
N#define FLASH_OPTCR_OPTSTRT            FLASH_OPTCR_OPTSTRT_Msk                 
N
N#define FLASH_OPTCR_BOR_LEV_0          0x00000004U                             
N#define FLASH_OPTCR_BOR_LEV_1          0x00000008U                             
N#define FLASH_OPTCR_BOR_LEV_Pos        (2U)                                    
N#define FLASH_OPTCR_BOR_LEV_Msk        (0x3UL << FLASH_OPTCR_BOR_LEV_Pos)       /*!< 0x0000000C */
N#define FLASH_OPTCR_BOR_LEV            FLASH_OPTCR_BOR_LEV_Msk                 
N#define FLASH_OPTCR_WDG_SW_Pos         (5U)                                    
N#define FLASH_OPTCR_WDG_SW_Msk         (0x1UL << FLASH_OPTCR_WDG_SW_Pos)        /*!< 0x00000020 */
N#define FLASH_OPTCR_WDG_SW             FLASH_OPTCR_WDG_SW_Msk                  
N#define FLASH_OPTCR_nRST_STOP_Pos      (6U)                                    
N#define FLASH_OPTCR_nRST_STOP_Msk      (0x1UL << FLASH_OPTCR_nRST_STOP_Pos)     /*!< 0x00000040 */
N#define FLASH_OPTCR_nRST_STOP          FLASH_OPTCR_nRST_STOP_Msk               
N#define FLASH_OPTCR_nRST_STDBY_Pos     (7U)                                    
N#define FLASH_OPTCR_nRST_STDBY_Msk     (0x1UL << FLASH_OPTCR_nRST_STDBY_Pos)    /*!< 0x00000080 */
N#define FLASH_OPTCR_nRST_STDBY         FLASH_OPTCR_nRST_STDBY_Msk              
N#define FLASH_OPTCR_RDP_Pos            (8U)                                    
N#define FLASH_OPTCR_RDP_Msk            (0xFFUL << FLASH_OPTCR_RDP_Pos)          /*!< 0x0000FF00 */
N#define FLASH_OPTCR_RDP                FLASH_OPTCR_RDP_Msk                     
N#define FLASH_OPTCR_RDP_0              (0x01UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00000100 */
N#define FLASH_OPTCR_RDP_1              (0x02UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00000200 */
N#define FLASH_OPTCR_RDP_2              (0x04UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00000400 */
N#define FLASH_OPTCR_RDP_3              (0x08UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00000800 */
N#define FLASH_OPTCR_RDP_4              (0x10UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00001000 */
N#define FLASH_OPTCR_RDP_5              (0x20UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00002000 */
N#define FLASH_OPTCR_RDP_6              (0x40UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00004000 */
N#define FLASH_OPTCR_RDP_7              (0x80UL << FLASH_OPTCR_RDP_Pos)          /*!< 0x00008000 */
N#define FLASH_OPTCR_nWRP_Pos           (16U)                                   
N#define FLASH_OPTCR_nWRP_Msk           (0xFFFUL << FLASH_OPTCR_nWRP_Pos)        /*!< 0x0FFF0000 */
N#define FLASH_OPTCR_nWRP               FLASH_OPTCR_nWRP_Msk                    
N#define FLASH_OPTCR_nWRP_0             0x00010000U                             
N#define FLASH_OPTCR_nWRP_1             0x00020000U                             
N#define FLASH_OPTCR_nWRP_2             0x00040000U                             
N#define FLASH_OPTCR_nWRP_3             0x00080000U                             
N#define FLASH_OPTCR_nWRP_4             0x00100000U                             
N#define FLASH_OPTCR_nWRP_5             0x00200000U                             
N#define FLASH_OPTCR_nWRP_6             0x00400000U                             
N#define FLASH_OPTCR_nWRP_7             0x00800000U                             
N#define FLASH_OPTCR_nWRP_8             0x01000000U                             
N#define FLASH_OPTCR_nWRP_9             0x02000000U                             
N#define FLASH_OPTCR_nWRP_10            0x04000000U                             
N#define FLASH_OPTCR_nWRP_11            0x08000000U                             
N                                             
N/******************  Bits definition for FLASH_OPTCR1 register  ***************/
N#define FLASH_OPTCR1_nWRP_Pos          (16U)                                   
N#define FLASH_OPTCR1_nWRP_Msk          (0xFFFUL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x0FFF0000 */
N#define FLASH_OPTCR1_nWRP              FLASH_OPTCR1_nWRP_Msk                   
N#define FLASH_OPTCR1_nWRP_0            (0x001UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00010000 */
N#define FLASH_OPTCR1_nWRP_1            (0x002UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00020000 */
N#define FLASH_OPTCR1_nWRP_2            (0x004UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00040000 */
N#define FLASH_OPTCR1_nWRP_3            (0x008UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00080000 */
N#define FLASH_OPTCR1_nWRP_4            (0x010UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00100000 */
N#define FLASH_OPTCR1_nWRP_5            (0x020UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00200000 */
N#define FLASH_OPTCR1_nWRP_6            (0x040UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00400000 */
N#define FLASH_OPTCR1_nWRP_7            (0x080UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x00800000 */
N#define FLASH_OPTCR1_nWRP_8            (0x100UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x01000000 */
N#define FLASH_OPTCR1_nWRP_9            (0x200UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x02000000 */
N#define FLASH_OPTCR1_nWRP_10           (0x400UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x04000000 */
N#define FLASH_OPTCR1_nWRP_11           (0x800UL << FLASH_OPTCR1_nWRP_Pos)       /*!< 0x08000000 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            General Purpose I/O                             */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bits definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0_Pos            (0U)                                  
N#define GPIO_MODER_MODER0_Msk            (0x3UL << GPIO_MODER_MODER0_Pos)       /*!< 0x00000003 */
N#define GPIO_MODER_MODER0                GPIO_MODER_MODER0_Msk                 
N#define GPIO_MODER_MODER0_0              (0x1UL << GPIO_MODER_MODER0_Pos)       /*!< 0x00000001 */
N#define GPIO_MODER_MODER0_1              (0x2UL << GPIO_MODER_MODER0_Pos)       /*!< 0x00000002 */
N#define GPIO_MODER_MODER1_Pos            (2U)                                  
N#define GPIO_MODER_MODER1_Msk            (0x3UL << GPIO_MODER_MODER1_Pos)       /*!< 0x0000000C */
N#define GPIO_MODER_MODER1                GPIO_MODER_MODER1_Msk                 
N#define GPIO_MODER_MODER1_0              (0x1UL << GPIO_MODER_MODER1_Pos)       /*!< 0x00000004 */
N#define GPIO_MODER_MODER1_1              (0x2UL << GPIO_MODER_MODER1_Pos)       /*!< 0x00000008 */
N#define GPIO_MODER_MODER2_Pos            (4U)                                  
N#define GPIO_MODER_MODER2_Msk            (0x3UL << GPIO_MODER_MODER2_Pos)       /*!< 0x00000030 */
N#define GPIO_MODER_MODER2                GPIO_MODER_MODER2_Msk                 
N#define GPIO_MODER_MODER2_0              (0x1UL << GPIO_MODER_MODER2_Pos)       /*!< 0x00000010 */
N#define GPIO_MODER_MODER2_1              (0x2UL << GPIO_MODER_MODER2_Pos)       /*!< 0x00000020 */
N#define GPIO_MODER_MODER3_Pos            (6U)                                  
N#define GPIO_MODER_MODER3_Msk            (0x3UL << GPIO_MODER_MODER3_Pos)       /*!< 0x000000C0 */
N#define GPIO_MODER_MODER3                GPIO_MODER_MODER3_Msk                 
N#define GPIO_MODER_MODER3_0              (0x1UL << GPIO_MODER_MODER3_Pos)       /*!< 0x00000040 */
N#define GPIO_MODER_MODER3_1              (0x2UL << GPIO_MODER_MODER3_Pos)       /*!< 0x00000080 */
N#define GPIO_MODER_MODER4_Pos            (8U)                                  
N#define GPIO_MODER_MODER4_Msk            (0x3UL << GPIO_MODER_MODER4_Pos)       /*!< 0x00000300 */
N#define GPIO_MODER_MODER4                GPIO_MODER_MODER4_Msk                 
N#define GPIO_MODER_MODER4_0              (0x1UL << GPIO_MODER_MODER4_Pos)       /*!< 0x00000100 */
N#define GPIO_MODER_MODER4_1              (0x2UL << GPIO_MODER_MODER4_Pos)       /*!< 0x00000200 */
N#define GPIO_MODER_MODER5_Pos            (10U)                                 
N#define GPIO_MODER_MODER5_Msk            (0x3UL << GPIO_MODER_MODER5_Pos)       /*!< 0x00000C00 */
N#define GPIO_MODER_MODER5                GPIO_MODER_MODER5_Msk                 
N#define GPIO_MODER_MODER5_0              (0x1UL << GPIO_MODER_MODER5_Pos)       /*!< 0x00000400 */
N#define GPIO_MODER_MODER5_1              (0x2UL << GPIO_MODER_MODER5_Pos)       /*!< 0x00000800 */
N#define GPIO_MODER_MODER6_Pos            (12U)                                 
N#define GPIO_MODER_MODER6_Msk            (0x3UL << GPIO_MODER_MODER6_Pos)       /*!< 0x00003000 */
N#define GPIO_MODER_MODER6                GPIO_MODER_MODER6_Msk                 
N#define GPIO_MODER_MODER6_0              (0x1UL << GPIO_MODER_MODER6_Pos)       /*!< 0x00001000 */
N#define GPIO_MODER_MODER6_1              (0x2UL << GPIO_MODER_MODER6_Pos)       /*!< 0x00002000 */
N#define GPIO_MODER_MODER7_Pos            (14U)                                 
N#define GPIO_MODER_MODER7_Msk            (0x3UL << GPIO_MODER_MODER7_Pos)       /*!< 0x0000C000 */
N#define GPIO_MODER_MODER7                GPIO_MODER_MODER7_Msk                 
N#define GPIO_MODER_MODER7_0              (0x1UL << GPIO_MODER_MODER7_Pos)       /*!< 0x00004000 */
N#define GPIO_MODER_MODER7_1              (0x2UL << GPIO_MODER_MODER7_Pos)       /*!< 0x00008000 */
N#define GPIO_MODER_MODER8_Pos            (16U)                                 
N#define GPIO_MODER_MODER8_Msk            (0x3UL << GPIO_MODER_MODER8_Pos)       /*!< 0x00030000 */
N#define GPIO_MODER_MODER8                GPIO_MODER_MODER8_Msk                 
N#define GPIO_MODER_MODER8_0              (0x1UL << GPIO_MODER_MODER8_Pos)       /*!< 0x00010000 */
N#define GPIO_MODER_MODER8_1              (0x2UL << GPIO_MODER_MODER8_Pos)       /*!< 0x00020000 */
N#define GPIO_MODER_MODER9_Pos            (18U)                                 
N#define GPIO_MODER_MODER9_Msk            (0x3UL << GPIO_MODER_MODER9_Pos)       /*!< 0x000C0000 */
N#define GPIO_MODER_MODER9                GPIO_MODER_MODER9_Msk                 
N#define GPIO_MODER_MODER9_0              (0x1UL << GPIO_MODER_MODER9_Pos)       /*!< 0x00040000 */
N#define GPIO_MODER_MODER9_1              (0x2UL << GPIO_MODER_MODER9_Pos)       /*!< 0x00080000 */
N#define GPIO_MODER_MODER10_Pos           (20U)                                 
N#define GPIO_MODER_MODER10_Msk           (0x3UL << GPIO_MODER_MODER10_Pos)      /*!< 0x00300000 */
N#define GPIO_MODER_MODER10               GPIO_MODER_MODER10_Msk                
N#define GPIO_MODER_MODER10_0             (0x1UL << GPIO_MODER_MODER10_Pos)      /*!< 0x00100000 */
N#define GPIO_MODER_MODER10_1             (0x2UL << GPIO_MODER_MODER10_Pos)      /*!< 0x00200000 */
N#define GPIO_MODER_MODER11_Pos           (22U)                                 
N#define GPIO_MODER_MODER11_Msk           (0x3UL << GPIO_MODER_MODER11_Pos)      /*!< 0x00C00000 */
N#define GPIO_MODER_MODER11               GPIO_MODER_MODER11_Msk                
N#define GPIO_MODER_MODER11_0             (0x1UL << GPIO_MODER_MODER11_Pos)      /*!< 0x00400000 */
N#define GPIO_MODER_MODER11_1             (0x2UL << GPIO_MODER_MODER11_Pos)      /*!< 0x00800000 */
N#define GPIO_MODER_MODER12_Pos           (24U)                                 
N#define GPIO_MODER_MODER12_Msk           (0x3UL << GPIO_MODER_MODER12_Pos)      /*!< 0x03000000 */
N#define GPIO_MODER_MODER12               GPIO_MODER_MODER12_Msk                
N#define GPIO_MODER_MODER12_0             (0x1UL << GPIO_MODER_MODER12_Pos)      /*!< 0x01000000 */
N#define GPIO_MODER_MODER12_1             (0x2UL << GPIO_MODER_MODER12_Pos)      /*!< 0x02000000 */
N#define GPIO_MODER_MODER13_Pos           (26U)                                 
N#define GPIO_MODER_MODER13_Msk           (0x3UL << GPIO_MODER_MODER13_Pos)      /*!< 0x0C000000 */
N#define GPIO_MODER_MODER13               GPIO_MODER_MODER13_Msk                
N#define GPIO_MODER_MODER13_0             (0x1UL << GPIO_MODER_MODER13_Pos)      /*!< 0x04000000 */
N#define GPIO_MODER_MODER13_1             (0x2UL << GPIO_MODER_MODER13_Pos)      /*!< 0x08000000 */
N#define GPIO_MODER_MODER14_Pos           (28U)                                 
N#define GPIO_MODER_MODER14_Msk           (0x3UL << GPIO_MODER_MODER14_Pos)      /*!< 0x30000000 */
N#define GPIO_MODER_MODER14               GPIO_MODER_MODER14_Msk                
N#define GPIO_MODER_MODER14_0             (0x1UL << GPIO_MODER_MODER14_Pos)      /*!< 0x10000000 */
N#define GPIO_MODER_MODER14_1             (0x2UL << GPIO_MODER_MODER14_Pos)      /*!< 0x20000000 */
N#define GPIO_MODER_MODER15_Pos           (30U)                                 
N#define GPIO_MODER_MODER15_Msk           (0x3UL << GPIO_MODER_MODER15_Pos)      /*!< 0xC0000000 */
N#define GPIO_MODER_MODER15               GPIO_MODER_MODER15_Msk                
N#define GPIO_MODER_MODER15_0             (0x1UL << GPIO_MODER_MODER15_Pos)      /*!< 0x40000000 */
N#define GPIO_MODER_MODER15_1             (0x2UL << GPIO_MODER_MODER15_Pos)      /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_MODER_MODE0_Pos             GPIO_MODER_MODER0_Pos                                  
N#define GPIO_MODER_MODE0_Msk             GPIO_MODER_MODER0_Msk
N#define GPIO_MODER_MODE0                 GPIO_MODER_MODER0                 
N#define GPIO_MODER_MODE0_0               GPIO_MODER_MODER0_0
N#define GPIO_MODER_MODE0_1               GPIO_MODER_MODER0_1
N#define GPIO_MODER_MODE1_Pos             GPIO_MODER_MODER1_Pos                                  
N#define GPIO_MODER_MODE1_Msk             GPIO_MODER_MODER1_Msk
N#define GPIO_MODER_MODE1                 GPIO_MODER_MODER1                  
N#define GPIO_MODER_MODE1_0               GPIO_MODER_MODER1_0
N#define GPIO_MODER_MODE1_1               GPIO_MODER_MODER1_1
N#define GPIO_MODER_MODE2_Pos             GPIO_MODER_MODER2_PoS
N#define GPIO_MODER_MODE2_Msk             GPIO_MODER_MODER2_Msk
N#define GPIO_MODER_MODE2                 GPIO_MODER_MODER2                 
N#define GPIO_MODER_MODE2_0               GPIO_MODER_MODER2_0
N#define GPIO_MODER_MODE2_1               GPIO_MODER_MODER2_1
N#define GPIO_MODER_MODE3_Pos             GPIO_MODER_MODER3_Pos                                
N#define GPIO_MODER_MODE3_Msk             GPIO_MODER_MODER3_Msk
N#define GPIO_MODER_MODE3                 GPIO_MODER_MODER3
N#define GPIO_MODER_MODE3_0               GPIO_MODER_MODER3_0
N#define GPIO_MODER_MODE3_1               GPIO_MODER_MODER3_1
N#define GPIO_MODER_MODE4_Pos             GPIO_MODER_MODER4_Pos
N#define GPIO_MODER_MODE4_Msk             GPIO_MODER_MODER4_Msk
N#define GPIO_MODER_MODE4                 GPIO_MODER_MODER4
N#define GPIO_MODER_MODE4_0               GPIO_MODER_MODER4_0
N#define GPIO_MODER_MODE4_1               GPIO_MODER_MODER4_1
N#define GPIO_MODER_MODE5_Pos             GPIO_MODER_MODER5_Pos
N#define GPIO_MODER_MODE5_Msk             GPIO_MODER_MODER5_Msk
N#define GPIO_MODER_MODE5                 GPIO_MODER_MODER5
N#define GPIO_MODER_MODE5_0               GPIO_MODER_MODER5_0
N#define GPIO_MODER_MODE5_1               GPIO_MODER_MODER5_1
N#define GPIO_MODER_MODE6_Pos             GPIO_MODER_MODER6_Pos
N#define GPIO_MODER_MODE6_Msk             GPIO_MODER_MODER6_Msk
N#define GPIO_MODER_MODE6                 GPIO_MODER_MODER6
N#define GPIO_MODER_MODE6_0               GPIO_MODER_MODER6_0
N#define GPIO_MODER_MODE6_1               GPIO_MODER_MODER6_1
N#define GPIO_MODER_MODE7_Pos             GPIO_MODER_MODER7_Pos
N#define GPIO_MODER_MODE7_Msk             GPIO_MODER_MODER7_Msk
N#define GPIO_MODER_MODE7                 GPIO_MODER_MODER7
N#define GPIO_MODER_MODE7_0               GPIO_MODER_MODER7_0
N#define GPIO_MODER_MODE7_1               GPIO_MODER_MODER7_1
N#define GPIO_MODER_MODE8_Pos             GPIO_MODER_MODER8_Pos
N#define GPIO_MODER_MODE8_Msk             GPIO_MODER_MODER2_Msk
N#define GPIO_MODER_MODE8                 GPIO_MODER_MODER8
N#define GPIO_MODER_MODE8_0               GPIO_MODER_MODER8_0
N#define GPIO_MODER_MODE8_1               GPIO_MODER_MODER8_1
N#define GPIO_MODER_MODE9_Pos             GPIO_MODER_MODER9_Pos
N#define GPIO_MODER_MODE9_Msk             GPIO_MODER_MODER9_Msk
N#define GPIO_MODER_MODE9                 GPIO_MODER_MODER9
N#define GPIO_MODER_MODE9_0               GPIO_MODER_MODER9_0
N#define GPIO_MODER_MODE9_1               GPIO_MODER_MODER9_1
N#define GPIO_MODER_MODE10_Pos            GPIO_MODER_MODER10_Pos
N#define GPIO_MODER_MODE10_Msk            GPIO_MODER_MODER10_Msk
N#define GPIO_MODER_MODE10                GPIO_MODER_MODER10
N#define GPIO_MODER_MODE10_0              GPIO_MODER_MODER10_0
N#define GPIO_MODER_MODE10_1              GPIO_MODER_MODER10_1
N#define GPIO_MODER_MODE11_Pos            GPIO_MODER_MODER11_Pos
N#define GPIO_MODER_MODE11_Msk            GPIO_MODER_MODER11_Msk
N#define GPIO_MODER_MODE11                GPIO_MODER_MODER11
N#define GPIO_MODER_MODE11_0              GPIO_MODER_MODER11_0
N#define GPIO_MODER_MODE11_1              GPIO_MODER_MODER11_1
N#define GPIO_MODER_MODE12_Pos            GPIO_MODER_MODER12_Pos
N#define GPIO_MODER_MODE12_Msk            GPIO_MODER_MODER12_Msk
N#define GPIO_MODER_MODE12                GPIO_MODER_MODER12
N#define GPIO_MODER_MODE12_0              GPIO_MODER_MODER12_0
N#define GPIO_MODER_MODE12_1              GPIO_MODER_MODER12_1
N#define GPIO_MODER_MODE13_Pos            GPIO_MODER_MODER13_Pos
N#define GPIO_MODER_MODE13_Msk            GPIO_MODER_MODER13_Msk
N#define GPIO_MODER_MODE13                GPIO_MODER_MODER13
N#define GPIO_MODER_MODE13_0              GPIO_MODER_MODER13_0
N#define GPIO_MODER_MODE13_1              GPIO_MODER_MODER13_1
N#define GPIO_MODER_MODE14_Pos            GPIO_MODER_MODER14_Pos
N#define GPIO_MODER_MODE14_Msk            GPIO_MODER_MODER14_Msk
N#define GPIO_MODER_MODE14                GPIO_MODER_MODER14
N#define GPIO_MODER_MODE14_0              GPIO_MODER_MODER14_0
N#define GPIO_MODER_MODE14_1              GPIO_MODER_MODER14_1
N#define GPIO_MODER_MODE15_Pos            GPIO_MODER_MODER15_Pos
N#define GPIO_MODER_MODE15_Msk            GPIO_MODER_MODER15_Msk
N#define GPIO_MODER_MODE15                GPIO_MODER_MODER15
N#define GPIO_MODER_MODE15_0              GPIO_MODER_MODER15_0
N#define GPIO_MODER_MODE15_1              GPIO_MODER_MODER15_1
N
N/******************  Bits definition for GPIO_OTYPER register  ****************/
N#define GPIO_OTYPER_OT0_Pos              (0U)                                  
N#define GPIO_OTYPER_OT0_Msk              (0x1UL << GPIO_OTYPER_OT0_Pos)         /*!< 0x00000001 */
N#define GPIO_OTYPER_OT0                  GPIO_OTYPER_OT0_Msk                   
N#define GPIO_OTYPER_OT1_Pos              (1U)                                  
N#define GPIO_OTYPER_OT1_Msk              (0x1UL << GPIO_OTYPER_OT1_Pos)         /*!< 0x00000002 */
N#define GPIO_OTYPER_OT1                  GPIO_OTYPER_OT1_Msk                   
N#define GPIO_OTYPER_OT2_Pos              (2U)                                  
N#define GPIO_OTYPER_OT2_Msk              (0x1UL << GPIO_OTYPER_OT2_Pos)         /*!< 0x00000004 */
N#define GPIO_OTYPER_OT2                  GPIO_OTYPER_OT2_Msk                   
N#define GPIO_OTYPER_OT3_Pos              (3U)                                  
N#define GPIO_OTYPER_OT3_Msk              (0x1UL << GPIO_OTYPER_OT3_Pos)         /*!< 0x00000008 */
N#define GPIO_OTYPER_OT3                  GPIO_OTYPER_OT3_Msk                   
N#define GPIO_OTYPER_OT4_Pos              (4U)                                  
N#define GPIO_OTYPER_OT4_Msk              (0x1UL << GPIO_OTYPER_OT4_Pos)         /*!< 0x00000010 */
N#define GPIO_OTYPER_OT4                  GPIO_OTYPER_OT4_Msk                   
N#define GPIO_OTYPER_OT5_Pos              (5U)                                  
N#define GPIO_OTYPER_OT5_Msk              (0x1UL << GPIO_OTYPER_OT5_Pos)         /*!< 0x00000020 */
N#define GPIO_OTYPER_OT5                  GPIO_OTYPER_OT5_Msk                   
N#define GPIO_OTYPER_OT6_Pos              (6U)                                  
N#define GPIO_OTYPER_OT6_Msk              (0x1UL << GPIO_OTYPER_OT6_Pos)         /*!< 0x00000040 */
N#define GPIO_OTYPER_OT6                  GPIO_OTYPER_OT6_Msk                   
N#define GPIO_OTYPER_OT7_Pos              (7U)                                  
N#define GPIO_OTYPER_OT7_Msk              (0x1UL << GPIO_OTYPER_OT7_Pos)         /*!< 0x00000080 */
N#define GPIO_OTYPER_OT7                  GPIO_OTYPER_OT7_Msk                   
N#define GPIO_OTYPER_OT8_Pos              (8U)                                  
N#define GPIO_OTYPER_OT8_Msk              (0x1UL << GPIO_OTYPER_OT8_Pos)         /*!< 0x00000100 */
N#define GPIO_OTYPER_OT8                  GPIO_OTYPER_OT8_Msk                   
N#define GPIO_OTYPER_OT9_Pos              (9U)                                  
N#define GPIO_OTYPER_OT9_Msk              (0x1UL << GPIO_OTYPER_OT9_Pos)         /*!< 0x00000200 */
N#define GPIO_OTYPER_OT9                  GPIO_OTYPER_OT9_Msk                   
N#define GPIO_OTYPER_OT10_Pos             (10U)                                 
N#define GPIO_OTYPER_OT10_Msk             (0x1UL << GPIO_OTYPER_OT10_Pos)        /*!< 0x00000400 */
N#define GPIO_OTYPER_OT10                 GPIO_OTYPER_OT10_Msk                  
N#define GPIO_OTYPER_OT11_Pos             (11U)                                 
N#define GPIO_OTYPER_OT11_Msk             (0x1UL << GPIO_OTYPER_OT11_Pos)        /*!< 0x00000800 */
N#define GPIO_OTYPER_OT11                 GPIO_OTYPER_OT11_Msk                  
N#define GPIO_OTYPER_OT12_Pos             (12U)                                 
N#define GPIO_OTYPER_OT12_Msk             (0x1UL << GPIO_OTYPER_OT12_Pos)        /*!< 0x00001000 */
N#define GPIO_OTYPER_OT12                 GPIO_OTYPER_OT12_Msk                  
N#define GPIO_OTYPER_OT13_Pos             (13U)                                 
N#define GPIO_OTYPER_OT13_Msk             (0x1UL << GPIO_OTYPER_OT13_Pos)        /*!< 0x00002000 */
N#define GPIO_OTYPER_OT13                 GPIO_OTYPER_OT13_Msk                  
N#define GPIO_OTYPER_OT14_Pos             (14U)                                 
N#define GPIO_OTYPER_OT14_Msk             (0x1UL << GPIO_OTYPER_OT14_Pos)        /*!< 0x00004000 */
N#define GPIO_OTYPER_OT14                 GPIO_OTYPER_OT14_Msk                  
N#define GPIO_OTYPER_OT15_Pos             (15U)                                 
N#define GPIO_OTYPER_OT15_Msk             (0x1UL << GPIO_OTYPER_OT15_Pos)        /*!< 0x00008000 */
N#define GPIO_OTYPER_OT15                 GPIO_OTYPER_OT15_Msk                  
N
N/* Legacy defines */
N#define GPIO_OTYPER_OT_0                 GPIO_OTYPER_OT0
N#define GPIO_OTYPER_OT_1                 GPIO_OTYPER_OT1
N#define GPIO_OTYPER_OT_2                 GPIO_OTYPER_OT2
N#define GPIO_OTYPER_OT_3                 GPIO_OTYPER_OT3
N#define GPIO_OTYPER_OT_4                 GPIO_OTYPER_OT4
N#define GPIO_OTYPER_OT_5                 GPIO_OTYPER_OT5
N#define GPIO_OTYPER_OT_6                 GPIO_OTYPER_OT6
N#define GPIO_OTYPER_OT_7                 GPIO_OTYPER_OT7
N#define GPIO_OTYPER_OT_8                 GPIO_OTYPER_OT8
N#define GPIO_OTYPER_OT_9                 GPIO_OTYPER_OT9
N#define GPIO_OTYPER_OT_10                GPIO_OTYPER_OT10
N#define GPIO_OTYPER_OT_11                GPIO_OTYPER_OT11
N#define GPIO_OTYPER_OT_12                GPIO_OTYPER_OT12
N#define GPIO_OTYPER_OT_13                GPIO_OTYPER_OT13
N#define GPIO_OTYPER_OT_14                GPIO_OTYPER_OT14
N#define GPIO_OTYPER_OT_15                GPIO_OTYPER_OT15
N
N/******************  Bits definition for GPIO_OSPEEDR register  ***************/
N#define GPIO_OSPEEDR_OSPEED0_Pos         (0U)                                  
N#define GPIO_OSPEEDR_OSPEED0_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED0_Pos)    /*!< 0x00000003 */
N#define GPIO_OSPEEDR_OSPEED0             GPIO_OSPEEDR_OSPEED0_Msk              
N#define GPIO_OSPEEDR_OSPEED0_0           (0x1UL << GPIO_OSPEEDR_OSPEED0_Pos)    /*!< 0x00000001 */
N#define GPIO_OSPEEDR_OSPEED0_1           (0x2UL << GPIO_OSPEEDR_OSPEED0_Pos)    /*!< 0x00000002 */
N#define GPIO_OSPEEDR_OSPEED1_Pos         (2U)                                  
N#define GPIO_OSPEEDR_OSPEED1_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED1_Pos)    /*!< 0x0000000C */
N#define GPIO_OSPEEDR_OSPEED1             GPIO_OSPEEDR_OSPEED1_Msk              
N#define GPIO_OSPEEDR_OSPEED1_0           (0x1UL << GPIO_OSPEEDR_OSPEED1_Pos)    /*!< 0x00000004 */
N#define GPIO_OSPEEDR_OSPEED1_1           (0x2UL << GPIO_OSPEEDR_OSPEED1_Pos)    /*!< 0x00000008 */
N#define GPIO_OSPEEDR_OSPEED2_Pos         (4U)                                  
N#define GPIO_OSPEEDR_OSPEED2_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED2_Pos)    /*!< 0x00000030 */
N#define GPIO_OSPEEDR_OSPEED2             GPIO_OSPEEDR_OSPEED2_Msk              
N#define GPIO_OSPEEDR_OSPEED2_0           (0x1UL << GPIO_OSPEEDR_OSPEED2_Pos)    /*!< 0x00000010 */
N#define GPIO_OSPEEDR_OSPEED2_1           (0x2UL << GPIO_OSPEEDR_OSPEED2_Pos)    /*!< 0x00000020 */
N#define GPIO_OSPEEDR_OSPEED3_Pos         (6U)                                  
N#define GPIO_OSPEEDR_OSPEED3_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED3_Pos)    /*!< 0x000000C0 */
N#define GPIO_OSPEEDR_OSPEED3             GPIO_OSPEEDR_OSPEED3_Msk              
N#define GPIO_OSPEEDR_OSPEED3_0           (0x1UL << GPIO_OSPEEDR_OSPEED3_Pos)    /*!< 0x00000040 */
N#define GPIO_OSPEEDR_OSPEED3_1           (0x2UL << GPIO_OSPEEDR_OSPEED3_Pos)    /*!< 0x00000080 */
N#define GPIO_OSPEEDR_OSPEED4_Pos         (8U)                                  
N#define GPIO_OSPEEDR_OSPEED4_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED4_Pos)    /*!< 0x00000300 */
N#define GPIO_OSPEEDR_OSPEED4             GPIO_OSPEEDR_OSPEED4_Msk              
N#define GPIO_OSPEEDR_OSPEED4_0           (0x1UL << GPIO_OSPEEDR_OSPEED4_Pos)    /*!< 0x00000100 */
N#define GPIO_OSPEEDR_OSPEED4_1           (0x2UL << GPIO_OSPEEDR_OSPEED4_Pos)    /*!< 0x00000200 */
N#define GPIO_OSPEEDR_OSPEED5_Pos         (10U)                                 
N#define GPIO_OSPEEDR_OSPEED5_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED5_Pos)    /*!< 0x00000C00 */
N#define GPIO_OSPEEDR_OSPEED5             GPIO_OSPEEDR_OSPEED5_Msk              
N#define GPIO_OSPEEDR_OSPEED5_0           (0x1UL << GPIO_OSPEEDR_OSPEED5_Pos)    /*!< 0x00000400 */
N#define GPIO_OSPEEDR_OSPEED5_1           (0x2UL << GPIO_OSPEEDR_OSPEED5_Pos)    /*!< 0x00000800 */
N#define GPIO_OSPEEDR_OSPEED6_Pos         (12U)                                 
N#define GPIO_OSPEEDR_OSPEED6_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED6_Pos)    /*!< 0x00003000 */
N#define GPIO_OSPEEDR_OSPEED6             GPIO_OSPEEDR_OSPEED6_Msk              
N#define GPIO_OSPEEDR_OSPEED6_0           (0x1UL << GPIO_OSPEEDR_OSPEED6_Pos)    /*!< 0x00001000 */
N#define GPIO_OSPEEDR_OSPEED6_1           (0x2UL << GPIO_OSPEEDR_OSPEED6_Pos)    /*!< 0x00002000 */
N#define GPIO_OSPEEDR_OSPEED7_Pos         (14U)                                 
N#define GPIO_OSPEEDR_OSPEED7_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED7_Pos)    /*!< 0x0000C000 */
N#define GPIO_OSPEEDR_OSPEED7             GPIO_OSPEEDR_OSPEED7_Msk              
N#define GPIO_OSPEEDR_OSPEED7_0           (0x1UL << GPIO_OSPEEDR_OSPEED7_Pos)    /*!< 0x00004000 */
N#define GPIO_OSPEEDR_OSPEED7_1           (0x2UL << GPIO_OSPEEDR_OSPEED7_Pos)    /*!< 0x00008000 */
N#define GPIO_OSPEEDR_OSPEED8_Pos         (16U)                                 
N#define GPIO_OSPEEDR_OSPEED8_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED8_Pos)    /*!< 0x00030000 */
N#define GPIO_OSPEEDR_OSPEED8             GPIO_OSPEEDR_OSPEED8_Msk              
N#define GPIO_OSPEEDR_OSPEED8_0           (0x1UL << GPIO_OSPEEDR_OSPEED8_Pos)    /*!< 0x00010000 */
N#define GPIO_OSPEEDR_OSPEED8_1           (0x2UL << GPIO_OSPEEDR_OSPEED8_Pos)    /*!< 0x00020000 */
N#define GPIO_OSPEEDR_OSPEED9_Pos         (18U)                                 
N#define GPIO_OSPEEDR_OSPEED9_Msk         (0x3UL << GPIO_OSPEEDR_OSPEED9_Pos)    /*!< 0x000C0000 */
N#define GPIO_OSPEEDR_OSPEED9             GPIO_OSPEEDR_OSPEED9_Msk              
N#define GPIO_OSPEEDR_OSPEED9_0           (0x1UL << GPIO_OSPEEDR_OSPEED9_Pos)    /*!< 0x00040000 */
N#define GPIO_OSPEEDR_OSPEED9_1           (0x2UL << GPIO_OSPEEDR_OSPEED9_Pos)    /*!< 0x00080000 */
N#define GPIO_OSPEEDR_OSPEED10_Pos        (20U)                                 
N#define GPIO_OSPEEDR_OSPEED10_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED10_Pos)   /*!< 0x00300000 */
N#define GPIO_OSPEEDR_OSPEED10            GPIO_OSPEEDR_OSPEED10_Msk             
N#define GPIO_OSPEEDR_OSPEED10_0          (0x1UL << GPIO_OSPEEDR_OSPEED10_Pos)   /*!< 0x00100000 */
N#define GPIO_OSPEEDR_OSPEED10_1          (0x2UL << GPIO_OSPEEDR_OSPEED10_Pos)   /*!< 0x00200000 */
N#define GPIO_OSPEEDR_OSPEED11_Pos        (22U)                                 
N#define GPIO_OSPEEDR_OSPEED11_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED11_Pos)   /*!< 0x00C00000 */
N#define GPIO_OSPEEDR_OSPEED11            GPIO_OSPEEDR_OSPEED11_Msk             
N#define GPIO_OSPEEDR_OSPEED11_0          (0x1UL << GPIO_OSPEEDR_OSPEED11_Pos)   /*!< 0x00400000 */
N#define GPIO_OSPEEDR_OSPEED11_1          (0x2UL << GPIO_OSPEEDR_OSPEED11_Pos)   /*!< 0x00800000 */
N#define GPIO_OSPEEDR_OSPEED12_Pos        (24U)                                 
N#define GPIO_OSPEEDR_OSPEED12_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED12_Pos)   /*!< 0x03000000 */
N#define GPIO_OSPEEDR_OSPEED12            GPIO_OSPEEDR_OSPEED12_Msk             
N#define GPIO_OSPEEDR_OSPEED12_0          (0x1UL << GPIO_OSPEEDR_OSPEED12_Pos)   /*!< 0x01000000 */
N#define GPIO_OSPEEDR_OSPEED12_1          (0x2UL << GPIO_OSPEEDR_OSPEED12_Pos)   /*!< 0x02000000 */
N#define GPIO_OSPEEDR_OSPEED13_Pos        (26U)                                 
N#define GPIO_OSPEEDR_OSPEED13_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED13_Pos)   /*!< 0x0C000000 */
N#define GPIO_OSPEEDR_OSPEED13            GPIO_OSPEEDR_OSPEED13_Msk             
N#define GPIO_OSPEEDR_OSPEED13_0          (0x1UL << GPIO_OSPEEDR_OSPEED13_Pos)   /*!< 0x04000000 */
N#define GPIO_OSPEEDR_OSPEED13_1          (0x2UL << GPIO_OSPEEDR_OSPEED13_Pos)   /*!< 0x08000000 */
N#define GPIO_OSPEEDR_OSPEED14_Pos        (28U)                                 
N#define GPIO_OSPEEDR_OSPEED14_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED14_Pos)   /*!< 0x30000000 */
N#define GPIO_OSPEEDR_OSPEED14            GPIO_OSPEEDR_OSPEED14_Msk             
N#define GPIO_OSPEEDR_OSPEED14_0          (0x1UL << GPIO_OSPEEDR_OSPEED14_Pos)   /*!< 0x10000000 */
N#define GPIO_OSPEEDR_OSPEED14_1          (0x2UL << GPIO_OSPEEDR_OSPEED14_Pos)   /*!< 0x20000000 */
N#define GPIO_OSPEEDR_OSPEED15_Pos        (30U)                                 
N#define GPIO_OSPEEDR_OSPEED15_Msk        (0x3UL << GPIO_OSPEEDR_OSPEED15_Pos)   /*!< 0xC0000000 */
N#define GPIO_OSPEEDR_OSPEED15            GPIO_OSPEEDR_OSPEED15_Msk             
N#define GPIO_OSPEEDR_OSPEED15_0          (0x1UL << GPIO_OSPEEDR_OSPEED15_Pos)   /*!< 0x40000000 */
N#define GPIO_OSPEEDR_OSPEED15_1          (0x2UL << GPIO_OSPEEDR_OSPEED15_Pos)   /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_OSPEEDER_OSPEEDR0           GPIO_OSPEEDR_OSPEED0
N#define GPIO_OSPEEDER_OSPEEDR0_0         GPIO_OSPEEDR_OSPEED0_0
N#define GPIO_OSPEEDER_OSPEEDR0_1         GPIO_OSPEEDR_OSPEED0_1
N#define GPIO_OSPEEDER_OSPEEDR1           GPIO_OSPEEDR_OSPEED1
N#define GPIO_OSPEEDER_OSPEEDR1_0         GPIO_OSPEEDR_OSPEED1_0
N#define GPIO_OSPEEDER_OSPEEDR1_1         GPIO_OSPEEDR_OSPEED1_1
N#define GPIO_OSPEEDER_OSPEEDR2           GPIO_OSPEEDR_OSPEED2
N#define GPIO_OSPEEDER_OSPEEDR2_0         GPIO_OSPEEDR_OSPEED2_0
N#define GPIO_OSPEEDER_OSPEEDR2_1         GPIO_OSPEEDR_OSPEED2_1
N#define GPIO_OSPEEDER_OSPEEDR3           GPIO_OSPEEDR_OSPEED3
N#define GPIO_OSPEEDER_OSPEEDR3_0         GPIO_OSPEEDR_OSPEED3_0
N#define GPIO_OSPEEDER_OSPEEDR3_1         GPIO_OSPEEDR_OSPEED3_1
N#define GPIO_OSPEEDER_OSPEEDR4           GPIO_OSPEEDR_OSPEED4
N#define GPIO_OSPEEDER_OSPEEDR4_0         GPIO_OSPEEDR_OSPEED4_0
N#define GPIO_OSPEEDER_OSPEEDR4_1         GPIO_OSPEEDR_OSPEED4_1
N#define GPIO_OSPEEDER_OSPEEDR5           GPIO_OSPEEDR_OSPEED5
N#define GPIO_OSPEEDER_OSPEEDR5_0         GPIO_OSPEEDR_OSPEED5_0
N#define GPIO_OSPEEDER_OSPEEDR5_1         GPIO_OSPEEDR_OSPEED5_1
N#define GPIO_OSPEEDER_OSPEEDR6           GPIO_OSPEEDR_OSPEED6
N#define GPIO_OSPEEDER_OSPEEDR6_0         GPIO_OSPEEDR_OSPEED6_0
N#define GPIO_OSPEEDER_OSPEEDR6_1         GPIO_OSPEEDR_OSPEED6_1
N#define GPIO_OSPEEDER_OSPEEDR7           GPIO_OSPEEDR_OSPEED7
N#define GPIO_OSPEEDER_OSPEEDR7_0         GPIO_OSPEEDR_OSPEED7_0
N#define GPIO_OSPEEDER_OSPEEDR7_1         GPIO_OSPEEDR_OSPEED7_1
N#define GPIO_OSPEEDER_OSPEEDR8           GPIO_OSPEEDR_OSPEED8
N#define GPIO_OSPEEDER_OSPEEDR8_0         GPIO_OSPEEDR_OSPEED8_0
N#define GPIO_OSPEEDER_OSPEEDR8_1         GPIO_OSPEEDR_OSPEED8_1
N#define GPIO_OSPEEDER_OSPEEDR9           GPIO_OSPEEDR_OSPEED9
N#define GPIO_OSPEEDER_OSPEEDR9_0         GPIO_OSPEEDR_OSPEED9_0
N#define GPIO_OSPEEDER_OSPEEDR9_1         GPIO_OSPEEDR_OSPEED9_1
N#define GPIO_OSPEEDER_OSPEEDR10          GPIO_OSPEEDR_OSPEED10
N#define GPIO_OSPEEDER_OSPEEDR10_0        GPIO_OSPEEDR_OSPEED10_0
N#define GPIO_OSPEEDER_OSPEEDR10_1        GPIO_OSPEEDR_OSPEED10_1
N#define GPIO_OSPEEDER_OSPEEDR11          GPIO_OSPEEDR_OSPEED11
N#define GPIO_OSPEEDER_OSPEEDR11_0        GPIO_OSPEEDR_OSPEED11_0
N#define GPIO_OSPEEDER_OSPEEDR11_1        GPIO_OSPEEDR_OSPEED11_1
N#define GPIO_OSPEEDER_OSPEEDR12          GPIO_OSPEEDR_OSPEED12
N#define GPIO_OSPEEDER_OSPEEDR12_0        GPIO_OSPEEDR_OSPEED12_0
N#define GPIO_OSPEEDER_OSPEEDR12_1        GPIO_OSPEEDR_OSPEED12_1
N#define GPIO_OSPEEDER_OSPEEDR13          GPIO_OSPEEDR_OSPEED13
N#define GPIO_OSPEEDER_OSPEEDR13_0        GPIO_OSPEEDR_OSPEED13_0
N#define GPIO_OSPEEDER_OSPEEDR13_1        GPIO_OSPEEDR_OSPEED13_1
N#define GPIO_OSPEEDER_OSPEEDR14          GPIO_OSPEEDR_OSPEED14
N#define GPIO_OSPEEDER_OSPEEDR14_0        GPIO_OSPEEDR_OSPEED14_0
N#define GPIO_OSPEEDER_OSPEEDR14_1        GPIO_OSPEEDR_OSPEED14_1
N#define GPIO_OSPEEDER_OSPEEDR15          GPIO_OSPEEDR_OSPEED15
N#define GPIO_OSPEEDER_OSPEEDR15_0        GPIO_OSPEEDR_OSPEED15_0
N#define GPIO_OSPEEDER_OSPEEDR15_1        GPIO_OSPEEDR_OSPEED15_1
N
N/******************  Bits definition for GPIO_PUPDR register  *****************/
N#define GPIO_PUPDR_PUPD0_Pos             (0U)                                  
N#define GPIO_PUPDR_PUPD0_Msk             (0x3UL << GPIO_PUPDR_PUPD0_Pos)        /*!< 0x00000003 */
N#define GPIO_PUPDR_PUPD0                 GPIO_PUPDR_PUPD0_Msk                  
N#define GPIO_PUPDR_PUPD0_0               (0x1UL << GPIO_PUPDR_PUPD0_Pos)        /*!< 0x00000001 */
N#define GPIO_PUPDR_PUPD0_1               (0x2UL << GPIO_PUPDR_PUPD0_Pos)        /*!< 0x00000002 */
N#define GPIO_PUPDR_PUPD1_Pos             (2U)                                  
N#define GPIO_PUPDR_PUPD1_Msk             (0x3UL << GPIO_PUPDR_PUPD1_Pos)        /*!< 0x0000000C */
N#define GPIO_PUPDR_PUPD1                 GPIO_PUPDR_PUPD1_Msk                  
N#define GPIO_PUPDR_PUPD1_0               (0x1UL << GPIO_PUPDR_PUPD1_Pos)        /*!< 0x00000004 */
N#define GPIO_PUPDR_PUPD1_1               (0x2UL << GPIO_PUPDR_PUPD1_Pos)        /*!< 0x00000008 */
N#define GPIO_PUPDR_PUPD2_Pos             (4U)                                  
N#define GPIO_PUPDR_PUPD2_Msk             (0x3UL << GPIO_PUPDR_PUPD2_Pos)        /*!< 0x00000030 */
N#define GPIO_PUPDR_PUPD2                 GPIO_PUPDR_PUPD2_Msk                  
N#define GPIO_PUPDR_PUPD2_0               (0x1UL << GPIO_PUPDR_PUPD2_Pos)        /*!< 0x00000010 */
N#define GPIO_PUPDR_PUPD2_1               (0x2UL << GPIO_PUPDR_PUPD2_Pos)        /*!< 0x00000020 */
N#define GPIO_PUPDR_PUPD3_Pos             (6U)                                  
N#define GPIO_PUPDR_PUPD3_Msk             (0x3UL << GPIO_PUPDR_PUPD3_Pos)        /*!< 0x000000C0 */
N#define GPIO_PUPDR_PUPD3                 GPIO_PUPDR_PUPD3_Msk                  
N#define GPIO_PUPDR_PUPD3_0               (0x1UL << GPIO_PUPDR_PUPD3_Pos)        /*!< 0x00000040 */
N#define GPIO_PUPDR_PUPD3_1               (0x2UL << GPIO_PUPDR_PUPD3_Pos)        /*!< 0x00000080 */
N#define GPIO_PUPDR_PUPD4_Pos             (8U)                                  
N#define GPIO_PUPDR_PUPD4_Msk             (0x3UL << GPIO_PUPDR_PUPD4_Pos)        /*!< 0x00000300 */
N#define GPIO_PUPDR_PUPD4                 GPIO_PUPDR_PUPD4_Msk                  
N#define GPIO_PUPDR_PUPD4_0               (0x1UL << GPIO_PUPDR_PUPD4_Pos)        /*!< 0x00000100 */
N#define GPIO_PUPDR_PUPD4_1               (0x2UL << GPIO_PUPDR_PUPD4_Pos)        /*!< 0x00000200 */
N#define GPIO_PUPDR_PUPD5_Pos             (10U)                                 
N#define GPIO_PUPDR_PUPD5_Msk             (0x3UL << GPIO_PUPDR_PUPD5_Pos)        /*!< 0x00000C00 */
N#define GPIO_PUPDR_PUPD5                 GPIO_PUPDR_PUPD5_Msk                  
N#define GPIO_PUPDR_PUPD5_0               (0x1UL << GPIO_PUPDR_PUPD5_Pos)        /*!< 0x00000400 */
N#define GPIO_PUPDR_PUPD5_1               (0x2UL << GPIO_PUPDR_PUPD5_Pos)        /*!< 0x00000800 */
N#define GPIO_PUPDR_PUPD6_Pos             (12U)                                 
N#define GPIO_PUPDR_PUPD6_Msk             (0x3UL << GPIO_PUPDR_PUPD6_Pos)        /*!< 0x00003000 */
N#define GPIO_PUPDR_PUPD6                 GPIO_PUPDR_PUPD6_Msk                  
N#define GPIO_PUPDR_PUPD6_0               (0x1UL << GPIO_PUPDR_PUPD6_Pos)        /*!< 0x00001000 */
N#define GPIO_PUPDR_PUPD6_1               (0x2UL << GPIO_PUPDR_PUPD6_Pos)        /*!< 0x00002000 */
N#define GPIO_PUPDR_PUPD7_Pos             (14U)                                 
N#define GPIO_PUPDR_PUPD7_Msk             (0x3UL << GPIO_PUPDR_PUPD7_Pos)        /*!< 0x0000C000 */
N#define GPIO_PUPDR_PUPD7                 GPIO_PUPDR_PUPD7_Msk                  
N#define GPIO_PUPDR_PUPD7_0               (0x1UL << GPIO_PUPDR_PUPD7_Pos)        /*!< 0x00004000 */
N#define GPIO_PUPDR_PUPD7_1               (0x2UL << GPIO_PUPDR_PUPD7_Pos)        /*!< 0x00008000 */
N#define GPIO_PUPDR_PUPD8_Pos             (16U)                                 
N#define GPIO_PUPDR_PUPD8_Msk             (0x3UL << GPIO_PUPDR_PUPD8_Pos)        /*!< 0x00030000 */
N#define GPIO_PUPDR_PUPD8                 GPIO_PUPDR_PUPD8_Msk                  
N#define GPIO_PUPDR_PUPD8_0               (0x1UL << GPIO_PUPDR_PUPD8_Pos)        /*!< 0x00010000 */
N#define GPIO_PUPDR_PUPD8_1               (0x2UL << GPIO_PUPDR_PUPD8_Pos)        /*!< 0x00020000 */
N#define GPIO_PUPDR_PUPD9_Pos             (18U)                                 
N#define GPIO_PUPDR_PUPD9_Msk             (0x3UL << GPIO_PUPDR_PUPD9_Pos)        /*!< 0x000C0000 */
N#define GPIO_PUPDR_PUPD9                 GPIO_PUPDR_PUPD9_Msk                  
N#define GPIO_PUPDR_PUPD9_0               (0x1UL << GPIO_PUPDR_PUPD9_Pos)        /*!< 0x00040000 */
N#define GPIO_PUPDR_PUPD9_1               (0x2UL << GPIO_PUPDR_PUPD9_Pos)        /*!< 0x00080000 */
N#define GPIO_PUPDR_PUPD10_Pos            (20U)                                 
N#define GPIO_PUPDR_PUPD10_Msk            (0x3UL << GPIO_PUPDR_PUPD10_Pos)       /*!< 0x00300000 */
N#define GPIO_PUPDR_PUPD10                GPIO_PUPDR_PUPD10_Msk                 
N#define GPIO_PUPDR_PUPD10_0              (0x1UL << GPIO_PUPDR_PUPD10_Pos)       /*!< 0x00100000 */
N#define GPIO_PUPDR_PUPD10_1              (0x2UL << GPIO_PUPDR_PUPD10_Pos)       /*!< 0x00200000 */
N#define GPIO_PUPDR_PUPD11_Pos            (22U)                                 
N#define GPIO_PUPDR_PUPD11_Msk            (0x3UL << GPIO_PUPDR_PUPD11_Pos)       /*!< 0x00C00000 */
N#define GPIO_PUPDR_PUPD11                GPIO_PUPDR_PUPD11_Msk                 
N#define GPIO_PUPDR_PUPD11_0              (0x1UL << GPIO_PUPDR_PUPD11_Pos)       /*!< 0x00400000 */
N#define GPIO_PUPDR_PUPD11_1              (0x2UL << GPIO_PUPDR_PUPD11_Pos)       /*!< 0x00800000 */
N#define GPIO_PUPDR_PUPD12_Pos            (24U)                                 
N#define GPIO_PUPDR_PUPD12_Msk            (0x3UL << GPIO_PUPDR_PUPD12_Pos)       /*!< 0x03000000 */
N#define GPIO_PUPDR_PUPD12                GPIO_PUPDR_PUPD12_Msk                 
N#define GPIO_PUPDR_PUPD12_0              (0x1UL << GPIO_PUPDR_PUPD12_Pos)       /*!< 0x01000000 */
N#define GPIO_PUPDR_PUPD12_1              (0x2UL << GPIO_PUPDR_PUPD12_Pos)       /*!< 0x02000000 */
N#define GPIO_PUPDR_PUPD13_Pos            (26U)                                 
N#define GPIO_PUPDR_PUPD13_Msk            (0x3UL << GPIO_PUPDR_PUPD13_Pos)       /*!< 0x0C000000 */
N#define GPIO_PUPDR_PUPD13                GPIO_PUPDR_PUPD13_Msk                 
N#define GPIO_PUPDR_PUPD13_0              (0x1UL << GPIO_PUPDR_PUPD13_Pos)       /*!< 0x04000000 */
N#define GPIO_PUPDR_PUPD13_1              (0x2UL << GPIO_PUPDR_PUPD13_Pos)       /*!< 0x08000000 */
N#define GPIO_PUPDR_PUPD14_Pos            (28U)                                 
N#define GPIO_PUPDR_PUPD14_Msk            (0x3UL << GPIO_PUPDR_PUPD14_Pos)       /*!< 0x30000000 */
N#define GPIO_PUPDR_PUPD14                GPIO_PUPDR_PUPD14_Msk                 
N#define GPIO_PUPDR_PUPD14_0              (0x1UL << GPIO_PUPDR_PUPD14_Pos)       /*!< 0x10000000 */
N#define GPIO_PUPDR_PUPD14_1              (0x2UL << GPIO_PUPDR_PUPD14_Pos)       /*!< 0x20000000 */
N#define GPIO_PUPDR_PUPD15_Pos            (30U)                                 
N#define GPIO_PUPDR_PUPD15_Msk            (0x3UL << GPIO_PUPDR_PUPD15_Pos)       /*!< 0xC0000000 */
N#define GPIO_PUPDR_PUPD15                GPIO_PUPDR_PUPD15_Msk                 
N#define GPIO_PUPDR_PUPD15_0              (0x1UL << GPIO_PUPDR_PUPD15_Pos)       /*!< 0x40000000 */
N#define GPIO_PUPDR_PUPD15_1              (0x2UL << GPIO_PUPDR_PUPD15_Pos)       /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_PUPDR_PUPDR0                GPIO_PUPDR_PUPD0
N#define GPIO_PUPDR_PUPDR0_0              GPIO_PUPDR_PUPD0_0
N#define GPIO_PUPDR_PUPDR0_1              GPIO_PUPDR_PUPD0_1
N#define GPIO_PUPDR_PUPDR1                GPIO_PUPDR_PUPD1
N#define GPIO_PUPDR_PUPDR1_0              GPIO_PUPDR_PUPD1_0
N#define GPIO_PUPDR_PUPDR1_1              GPIO_PUPDR_PUPD1_1
N#define GPIO_PUPDR_PUPDR2                GPIO_PUPDR_PUPD2
N#define GPIO_PUPDR_PUPDR2_0              GPIO_PUPDR_PUPD2_0
N#define GPIO_PUPDR_PUPDR2_1              GPIO_PUPDR_PUPD2_1
N#define GPIO_PUPDR_PUPDR3                GPIO_PUPDR_PUPD3
N#define GPIO_PUPDR_PUPDR3_0              GPIO_PUPDR_PUPD3_0
N#define GPIO_PUPDR_PUPDR3_1              GPIO_PUPDR_PUPD3_1
N#define GPIO_PUPDR_PUPDR4                GPIO_PUPDR_PUPD4
N#define GPIO_PUPDR_PUPDR4_0              GPIO_PUPDR_PUPD4_0
N#define GPIO_PUPDR_PUPDR4_1              GPIO_PUPDR_PUPD4_1
N#define GPIO_PUPDR_PUPDR5                GPIO_PUPDR_PUPD5
N#define GPIO_PUPDR_PUPDR5_0              GPIO_PUPDR_PUPD5_0
N#define GPIO_PUPDR_PUPDR5_1              GPIO_PUPDR_PUPD5_1
N#define GPIO_PUPDR_PUPDR6                GPIO_PUPDR_PUPD6
N#define GPIO_PUPDR_PUPDR6_0              GPIO_PUPDR_PUPD6_0
N#define GPIO_PUPDR_PUPDR6_1              GPIO_PUPDR_PUPD6_1
N#define GPIO_PUPDR_PUPDR7                GPIO_PUPDR_PUPD7
N#define GPIO_PUPDR_PUPDR7_0              GPIO_PUPDR_PUPD7_0
N#define GPIO_PUPDR_PUPDR7_1              GPIO_PUPDR_PUPD7_1
N#define GPIO_PUPDR_PUPDR8                GPIO_PUPDR_PUPD8
N#define GPIO_PUPDR_PUPDR8_0              GPIO_PUPDR_PUPD8_0
N#define GPIO_PUPDR_PUPDR8_1              GPIO_PUPDR_PUPD8_1
N#define GPIO_PUPDR_PUPDR9                GPIO_PUPDR_PUPD9
N#define GPIO_PUPDR_PUPDR9_0              GPIO_PUPDR_PUPD9_0
N#define GPIO_PUPDR_PUPDR9_1              GPIO_PUPDR_PUPD9_1
N#define GPIO_PUPDR_PUPDR10               GPIO_PUPDR_PUPD10
N#define GPIO_PUPDR_PUPDR10_0             GPIO_PUPDR_PUPD10_0
N#define GPIO_PUPDR_PUPDR10_1             GPIO_PUPDR_PUPD10_1
N#define GPIO_PUPDR_PUPDR11               GPIO_PUPDR_PUPD11
N#define GPIO_PUPDR_PUPDR11_0             GPIO_PUPDR_PUPD11_0
N#define GPIO_PUPDR_PUPDR11_1             GPIO_PUPDR_PUPD11_1
N#define GPIO_PUPDR_PUPDR12               GPIO_PUPDR_PUPD12
N#define GPIO_PUPDR_PUPDR12_0             GPIO_PUPDR_PUPD12_0
N#define GPIO_PUPDR_PUPDR12_1             GPIO_PUPDR_PUPD12_1
N#define GPIO_PUPDR_PUPDR13               GPIO_PUPDR_PUPD13
N#define GPIO_PUPDR_PUPDR13_0             GPIO_PUPDR_PUPD13_0
N#define GPIO_PUPDR_PUPDR13_1             GPIO_PUPDR_PUPD13_1
N#define GPIO_PUPDR_PUPDR14               GPIO_PUPDR_PUPD14
N#define GPIO_PUPDR_PUPDR14_0             GPIO_PUPDR_PUPD14_0
N#define GPIO_PUPDR_PUPDR14_1             GPIO_PUPDR_PUPD14_1
N#define GPIO_PUPDR_PUPDR15               GPIO_PUPDR_PUPD15
N#define GPIO_PUPDR_PUPDR15_0             GPIO_PUPDR_PUPD15_0
N#define GPIO_PUPDR_PUPDR15_1             GPIO_PUPDR_PUPD15_1
N
N/******************  Bits definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_ID0_Pos                 (0U)                                  
N#define GPIO_IDR_ID0_Msk                 (0x1UL << GPIO_IDR_ID0_Pos)            /*!< 0x00000001 */
N#define GPIO_IDR_ID0                     GPIO_IDR_ID0_Msk                      
N#define GPIO_IDR_ID1_Pos                 (1U)                                  
N#define GPIO_IDR_ID1_Msk                 (0x1UL << GPIO_IDR_ID1_Pos)            /*!< 0x00000002 */
N#define GPIO_IDR_ID1                     GPIO_IDR_ID1_Msk                      
N#define GPIO_IDR_ID2_Pos                 (2U)                                  
N#define GPIO_IDR_ID2_Msk                 (0x1UL << GPIO_IDR_ID2_Pos)            /*!< 0x00000004 */
N#define GPIO_IDR_ID2                     GPIO_IDR_ID2_Msk                      
N#define GPIO_IDR_ID3_Pos                 (3U)                                  
N#define GPIO_IDR_ID3_Msk                 (0x1UL << GPIO_IDR_ID3_Pos)            /*!< 0x00000008 */
N#define GPIO_IDR_ID3                     GPIO_IDR_ID3_Msk                      
N#define GPIO_IDR_ID4_Pos                 (4U)                                  
N#define GPIO_IDR_ID4_Msk                 (0x1UL << GPIO_IDR_ID4_Pos)            /*!< 0x00000010 */
N#define GPIO_IDR_ID4                     GPIO_IDR_ID4_Msk                      
N#define GPIO_IDR_ID5_Pos                 (5U)                                  
N#define GPIO_IDR_ID5_Msk                 (0x1UL << GPIO_IDR_ID5_Pos)            /*!< 0x00000020 */
N#define GPIO_IDR_ID5                     GPIO_IDR_ID5_Msk                      
N#define GPIO_IDR_ID6_Pos                 (6U)                                  
N#define GPIO_IDR_ID6_Msk                 (0x1UL << GPIO_IDR_ID6_Pos)            /*!< 0x00000040 */
N#define GPIO_IDR_ID6                     GPIO_IDR_ID6_Msk                      
N#define GPIO_IDR_ID7_Pos                 (7U)                                  
N#define GPIO_IDR_ID7_Msk                 (0x1UL << GPIO_IDR_ID7_Pos)            /*!< 0x00000080 */
N#define GPIO_IDR_ID7                     GPIO_IDR_ID7_Msk                      
N#define GPIO_IDR_ID8_Pos                 (8U)                                  
N#define GPIO_IDR_ID8_Msk                 (0x1UL << GPIO_IDR_ID8_Pos)            /*!< 0x00000100 */
N#define GPIO_IDR_ID8                     GPIO_IDR_ID8_Msk                      
N#define GPIO_IDR_ID9_Pos                 (9U)                                  
N#define GPIO_IDR_ID9_Msk                 (0x1UL << GPIO_IDR_ID9_Pos)            /*!< 0x00000200 */
N#define GPIO_IDR_ID9                     GPIO_IDR_ID9_Msk                      
N#define GPIO_IDR_ID10_Pos                (10U)                                 
N#define GPIO_IDR_ID10_Msk                (0x1UL << GPIO_IDR_ID10_Pos)           /*!< 0x00000400 */
N#define GPIO_IDR_ID10                    GPIO_IDR_ID10_Msk                     
N#define GPIO_IDR_ID11_Pos                (11U)                                 
N#define GPIO_IDR_ID11_Msk                (0x1UL << GPIO_IDR_ID11_Pos)           /*!< 0x00000800 */
N#define GPIO_IDR_ID11                    GPIO_IDR_ID11_Msk                     
N#define GPIO_IDR_ID12_Pos                (12U)                                 
N#define GPIO_IDR_ID12_Msk                (0x1UL << GPIO_IDR_ID12_Pos)           /*!< 0x00001000 */
N#define GPIO_IDR_ID12                    GPIO_IDR_ID12_Msk                     
N#define GPIO_IDR_ID13_Pos                (13U)                                 
N#define GPIO_IDR_ID13_Msk                (0x1UL << GPIO_IDR_ID13_Pos)           /*!< 0x00002000 */
N#define GPIO_IDR_ID13                    GPIO_IDR_ID13_Msk                     
N#define GPIO_IDR_ID14_Pos                (14U)                                 
N#define GPIO_IDR_ID14_Msk                (0x1UL << GPIO_IDR_ID14_Pos)           /*!< 0x00004000 */
N#define GPIO_IDR_ID14                    GPIO_IDR_ID14_Msk                     
N#define GPIO_IDR_ID15_Pos                (15U)                                 
N#define GPIO_IDR_ID15_Msk                (0x1UL << GPIO_IDR_ID15_Pos)           /*!< 0x00008000 */
N#define GPIO_IDR_ID15                    GPIO_IDR_ID15_Msk                     
N
N/* Legacy defines */
N#define GPIO_IDR_IDR_0                   GPIO_IDR_ID0
N#define GPIO_IDR_IDR_1                   GPIO_IDR_ID1
N#define GPIO_IDR_IDR_2                   GPIO_IDR_ID2
N#define GPIO_IDR_IDR_3                   GPIO_IDR_ID3
N#define GPIO_IDR_IDR_4                   GPIO_IDR_ID4
N#define GPIO_IDR_IDR_5                   GPIO_IDR_ID5
N#define GPIO_IDR_IDR_6                   GPIO_IDR_ID6
N#define GPIO_IDR_IDR_7                   GPIO_IDR_ID7
N#define GPIO_IDR_IDR_8                   GPIO_IDR_ID8
N#define GPIO_IDR_IDR_9                   GPIO_IDR_ID9
N#define GPIO_IDR_IDR_10                  GPIO_IDR_ID10
N#define GPIO_IDR_IDR_11                  GPIO_IDR_ID11
N#define GPIO_IDR_IDR_12                  GPIO_IDR_ID12
N#define GPIO_IDR_IDR_13                  GPIO_IDR_ID13
N#define GPIO_IDR_IDR_14                  GPIO_IDR_ID14
N#define GPIO_IDR_IDR_15                  GPIO_IDR_ID15
N
N/******************  Bits definition for GPIO_ODR register  *******************/
N#define GPIO_ODR_OD0_Pos                 (0U)                                  
N#define GPIO_ODR_OD0_Msk                 (0x1UL << GPIO_ODR_OD0_Pos)            /*!< 0x00000001 */
N#define GPIO_ODR_OD0                     GPIO_ODR_OD0_Msk                      
N#define GPIO_ODR_OD1_Pos                 (1U)                                  
N#define GPIO_ODR_OD1_Msk                 (0x1UL << GPIO_ODR_OD1_Pos)            /*!< 0x00000002 */
N#define GPIO_ODR_OD1                     GPIO_ODR_OD1_Msk                      
N#define GPIO_ODR_OD2_Pos                 (2U)                                  
N#define GPIO_ODR_OD2_Msk                 (0x1UL << GPIO_ODR_OD2_Pos)            /*!< 0x00000004 */
N#define GPIO_ODR_OD2                     GPIO_ODR_OD2_Msk                      
N#define GPIO_ODR_OD3_Pos                 (3U)                                  
N#define GPIO_ODR_OD3_Msk                 (0x1UL << GPIO_ODR_OD3_Pos)            /*!< 0x00000008 */
N#define GPIO_ODR_OD3                     GPIO_ODR_OD3_Msk                      
N#define GPIO_ODR_OD4_Pos                 (4U)                                  
N#define GPIO_ODR_OD4_Msk                 (0x1UL << GPIO_ODR_OD4_Pos)            /*!< 0x00000010 */
N#define GPIO_ODR_OD4                     GPIO_ODR_OD4_Msk                      
N#define GPIO_ODR_OD5_Pos                 (5U)                                  
N#define GPIO_ODR_OD5_Msk                 (0x1UL << GPIO_ODR_OD5_Pos)            /*!< 0x00000020 */
N#define GPIO_ODR_OD5                     GPIO_ODR_OD5_Msk                      
N#define GPIO_ODR_OD6_Pos                 (6U)                                  
N#define GPIO_ODR_OD6_Msk                 (0x1UL << GPIO_ODR_OD6_Pos)            /*!< 0x00000040 */
N#define GPIO_ODR_OD6                     GPIO_ODR_OD6_Msk                      
N#define GPIO_ODR_OD7_Pos                 (7U)                                  
N#define GPIO_ODR_OD7_Msk                 (0x1UL << GPIO_ODR_OD7_Pos)            /*!< 0x00000080 */
N#define GPIO_ODR_OD7                     GPIO_ODR_OD7_Msk                      
N#define GPIO_ODR_OD8_Pos                 (8U)                                  
N#define GPIO_ODR_OD8_Msk                 (0x1UL << GPIO_ODR_OD8_Pos)            /*!< 0x00000100 */
N#define GPIO_ODR_OD8                     GPIO_ODR_OD8_Msk                      
N#define GPIO_ODR_OD9_Pos                 (9U)                                  
N#define GPIO_ODR_OD9_Msk                 (0x1UL << GPIO_ODR_OD9_Pos)            /*!< 0x00000200 */
N#define GPIO_ODR_OD9                     GPIO_ODR_OD9_Msk                      
N#define GPIO_ODR_OD10_Pos                (10U)                                 
N#define GPIO_ODR_OD10_Msk                (0x1UL << GPIO_ODR_OD10_Pos)           /*!< 0x00000400 */
N#define GPIO_ODR_OD10                    GPIO_ODR_OD10_Msk                     
N#define GPIO_ODR_OD11_Pos                (11U)                                 
N#define GPIO_ODR_OD11_Msk                (0x1UL << GPIO_ODR_OD11_Pos)           /*!< 0x00000800 */
N#define GPIO_ODR_OD11                    GPIO_ODR_OD11_Msk                     
N#define GPIO_ODR_OD12_Pos                (12U)                                 
N#define GPIO_ODR_OD12_Msk                (0x1UL << GPIO_ODR_OD12_Pos)           /*!< 0x00001000 */
N#define GPIO_ODR_OD12                    GPIO_ODR_OD12_Msk                     
N#define GPIO_ODR_OD13_Pos                (13U)                                 
N#define GPIO_ODR_OD13_Msk                (0x1UL << GPIO_ODR_OD13_Pos)           /*!< 0x00002000 */
N#define GPIO_ODR_OD13                    GPIO_ODR_OD13_Msk                     
N#define GPIO_ODR_OD14_Pos                (14U)                                 
N#define GPIO_ODR_OD14_Msk                (0x1UL << GPIO_ODR_OD14_Pos)           /*!< 0x00004000 */
N#define GPIO_ODR_OD14                    GPIO_ODR_OD14_Msk                     
N#define GPIO_ODR_OD15_Pos                (15U)                                 
N#define GPIO_ODR_OD15_Msk                (0x1UL << GPIO_ODR_OD15_Pos)           /*!< 0x00008000 */
N#define GPIO_ODR_OD15                    GPIO_ODR_OD15_Msk                     
N/* Legacy defines */
N#define GPIO_ODR_ODR_0                   GPIO_ODR_OD0
N#define GPIO_ODR_ODR_1                   GPIO_ODR_OD1
N#define GPIO_ODR_ODR_2                   GPIO_ODR_OD2
N#define GPIO_ODR_ODR_3                   GPIO_ODR_OD3
N#define GPIO_ODR_ODR_4                   GPIO_ODR_OD4
N#define GPIO_ODR_ODR_5                   GPIO_ODR_OD5
N#define GPIO_ODR_ODR_6                   GPIO_ODR_OD6
N#define GPIO_ODR_ODR_7                   GPIO_ODR_OD7
N#define GPIO_ODR_ODR_8                   GPIO_ODR_OD8
N#define GPIO_ODR_ODR_9                   GPIO_ODR_OD9
N#define GPIO_ODR_ODR_10                  GPIO_ODR_OD10
N#define GPIO_ODR_ODR_11                  GPIO_ODR_OD11
N#define GPIO_ODR_ODR_12                  GPIO_ODR_OD12
N#define GPIO_ODR_ODR_13                  GPIO_ODR_OD13
N#define GPIO_ODR_ODR_14                  GPIO_ODR_OD14
N#define GPIO_ODR_ODR_15                  GPIO_ODR_OD15
N
N/******************  Bits definition for GPIO_BSRR register  ******************/
N#define GPIO_BSRR_BS0_Pos                (0U)                                  
N#define GPIO_BSRR_BS0_Msk                (0x1UL << GPIO_BSRR_BS0_Pos)           /*!< 0x00000001 */
N#define GPIO_BSRR_BS0                    GPIO_BSRR_BS0_Msk                     
N#define GPIO_BSRR_BS1_Pos                (1U)                                  
N#define GPIO_BSRR_BS1_Msk                (0x1UL << GPIO_BSRR_BS1_Pos)           /*!< 0x00000002 */
N#define GPIO_BSRR_BS1                    GPIO_BSRR_BS1_Msk                     
N#define GPIO_BSRR_BS2_Pos                (2U)                                  
N#define GPIO_BSRR_BS2_Msk                (0x1UL << GPIO_BSRR_BS2_Pos)           /*!< 0x00000004 */
N#define GPIO_BSRR_BS2                    GPIO_BSRR_BS2_Msk                     
N#define GPIO_BSRR_BS3_Pos                (3U)                                  
N#define GPIO_BSRR_BS3_Msk                (0x1UL << GPIO_BSRR_BS3_Pos)           /*!< 0x00000008 */
N#define GPIO_BSRR_BS3                    GPIO_BSRR_BS3_Msk                     
N#define GPIO_BSRR_BS4_Pos                (4U)                                  
N#define GPIO_BSRR_BS4_Msk                (0x1UL << GPIO_BSRR_BS4_Pos)           /*!< 0x00000010 */
N#define GPIO_BSRR_BS4                    GPIO_BSRR_BS4_Msk                     
N#define GPIO_BSRR_BS5_Pos                (5U)                                  
N#define GPIO_BSRR_BS5_Msk                (0x1UL << GPIO_BSRR_BS5_Pos)           /*!< 0x00000020 */
N#define GPIO_BSRR_BS5                    GPIO_BSRR_BS5_Msk                     
N#define GPIO_BSRR_BS6_Pos                (6U)                                  
N#define GPIO_BSRR_BS6_Msk                (0x1UL << GPIO_BSRR_BS6_Pos)           /*!< 0x00000040 */
N#define GPIO_BSRR_BS6                    GPIO_BSRR_BS6_Msk                     
N#define GPIO_BSRR_BS7_Pos                (7U)                                  
N#define GPIO_BSRR_BS7_Msk                (0x1UL << GPIO_BSRR_BS7_Pos)           /*!< 0x00000080 */
N#define GPIO_BSRR_BS7                    GPIO_BSRR_BS7_Msk                     
N#define GPIO_BSRR_BS8_Pos                (8U)                                  
N#define GPIO_BSRR_BS8_Msk                (0x1UL << GPIO_BSRR_BS8_Pos)           /*!< 0x00000100 */
N#define GPIO_BSRR_BS8                    GPIO_BSRR_BS8_Msk                     
N#define GPIO_BSRR_BS9_Pos                (9U)                                  
N#define GPIO_BSRR_BS9_Msk                (0x1UL << GPIO_BSRR_BS9_Pos)           /*!< 0x00000200 */
N#define GPIO_BSRR_BS9                    GPIO_BSRR_BS9_Msk                     
N#define GPIO_BSRR_BS10_Pos               (10U)                                 
N#define GPIO_BSRR_BS10_Msk               (0x1UL << GPIO_BSRR_BS10_Pos)          /*!< 0x00000400 */
N#define GPIO_BSRR_BS10                   GPIO_BSRR_BS10_Msk                    
N#define GPIO_BSRR_BS11_Pos               (11U)                                 
N#define GPIO_BSRR_BS11_Msk               (0x1UL << GPIO_BSRR_BS11_Pos)          /*!< 0x00000800 */
N#define GPIO_BSRR_BS11                   GPIO_BSRR_BS11_Msk                    
N#define GPIO_BSRR_BS12_Pos               (12U)                                 
N#define GPIO_BSRR_BS12_Msk               (0x1UL << GPIO_BSRR_BS12_Pos)          /*!< 0x00001000 */
N#define GPIO_BSRR_BS12                   GPIO_BSRR_BS12_Msk                    
N#define GPIO_BSRR_BS13_Pos               (13U)                                 
N#define GPIO_BSRR_BS13_Msk               (0x1UL << GPIO_BSRR_BS13_Pos)          /*!< 0x00002000 */
N#define GPIO_BSRR_BS13                   GPIO_BSRR_BS13_Msk                    
N#define GPIO_BSRR_BS14_Pos               (14U)                                 
N#define GPIO_BSRR_BS14_Msk               (0x1UL << GPIO_BSRR_BS14_Pos)          /*!< 0x00004000 */
N#define GPIO_BSRR_BS14                   GPIO_BSRR_BS14_Msk                    
N#define GPIO_BSRR_BS15_Pos               (15U)                                 
N#define GPIO_BSRR_BS15_Msk               (0x1UL << GPIO_BSRR_BS15_Pos)          /*!< 0x00008000 */
N#define GPIO_BSRR_BS15                   GPIO_BSRR_BS15_Msk                    
N#define GPIO_BSRR_BR0_Pos                (16U)                                 
N#define GPIO_BSRR_BR0_Msk                (0x1UL << GPIO_BSRR_BR0_Pos)           /*!< 0x00010000 */
N#define GPIO_BSRR_BR0                    GPIO_BSRR_BR0_Msk                     
N#define GPIO_BSRR_BR1_Pos                (17U)                                 
N#define GPIO_BSRR_BR1_Msk                (0x1UL << GPIO_BSRR_BR1_Pos)           /*!< 0x00020000 */
N#define GPIO_BSRR_BR1                    GPIO_BSRR_BR1_Msk                     
N#define GPIO_BSRR_BR2_Pos                (18U)                                 
N#define GPIO_BSRR_BR2_Msk                (0x1UL << GPIO_BSRR_BR2_Pos)           /*!< 0x00040000 */
N#define GPIO_BSRR_BR2                    GPIO_BSRR_BR2_Msk                     
N#define GPIO_BSRR_BR3_Pos                (19U)                                 
N#define GPIO_BSRR_BR3_Msk                (0x1UL << GPIO_BSRR_BR3_Pos)           /*!< 0x00080000 */
N#define GPIO_BSRR_BR3                    GPIO_BSRR_BR3_Msk                     
N#define GPIO_BSRR_BR4_Pos                (20U)                                 
N#define GPIO_BSRR_BR4_Msk                (0x1UL << GPIO_BSRR_BR4_Pos)           /*!< 0x00100000 */
N#define GPIO_BSRR_BR4                    GPIO_BSRR_BR4_Msk                     
N#define GPIO_BSRR_BR5_Pos                (21U)                                 
N#define GPIO_BSRR_BR5_Msk                (0x1UL << GPIO_BSRR_BR5_Pos)           /*!< 0x00200000 */
N#define GPIO_BSRR_BR5                    GPIO_BSRR_BR5_Msk                     
N#define GPIO_BSRR_BR6_Pos                (22U)                                 
N#define GPIO_BSRR_BR6_Msk                (0x1UL << GPIO_BSRR_BR6_Pos)           /*!< 0x00400000 */
N#define GPIO_BSRR_BR6                    GPIO_BSRR_BR6_Msk                     
N#define GPIO_BSRR_BR7_Pos                (23U)                                 
N#define GPIO_BSRR_BR7_Msk                (0x1UL << GPIO_BSRR_BR7_Pos)           /*!< 0x00800000 */
N#define GPIO_BSRR_BR7                    GPIO_BSRR_BR7_Msk                     
N#define GPIO_BSRR_BR8_Pos                (24U)                                 
N#define GPIO_BSRR_BR8_Msk                (0x1UL << GPIO_BSRR_BR8_Pos)           /*!< 0x01000000 */
N#define GPIO_BSRR_BR8                    GPIO_BSRR_BR8_Msk                     
N#define GPIO_BSRR_BR9_Pos                (25U)                                 
N#define GPIO_BSRR_BR9_Msk                (0x1UL << GPIO_BSRR_BR9_Pos)           /*!< 0x02000000 */
N#define GPIO_BSRR_BR9                    GPIO_BSRR_BR9_Msk                     
N#define GPIO_BSRR_BR10_Pos               (26U)                                 
N#define GPIO_BSRR_BR10_Msk               (0x1UL << GPIO_BSRR_BR10_Pos)          /*!< 0x04000000 */
N#define GPIO_BSRR_BR10                   GPIO_BSRR_BR10_Msk                    
N#define GPIO_BSRR_BR11_Pos               (27U)                                 
N#define GPIO_BSRR_BR11_Msk               (0x1UL << GPIO_BSRR_BR11_Pos)          /*!< 0x08000000 */
N#define GPIO_BSRR_BR11                   GPIO_BSRR_BR11_Msk                    
N#define GPIO_BSRR_BR12_Pos               (28U)                                 
N#define GPIO_BSRR_BR12_Msk               (0x1UL << GPIO_BSRR_BR12_Pos)          /*!< 0x10000000 */
N#define GPIO_BSRR_BR12                   GPIO_BSRR_BR12_Msk                    
N#define GPIO_BSRR_BR13_Pos               (29U)                                 
N#define GPIO_BSRR_BR13_Msk               (0x1UL << GPIO_BSRR_BR13_Pos)          /*!< 0x20000000 */
N#define GPIO_BSRR_BR13                   GPIO_BSRR_BR13_Msk                    
N#define GPIO_BSRR_BR14_Pos               (30U)                                 
N#define GPIO_BSRR_BR14_Msk               (0x1UL << GPIO_BSRR_BR14_Pos)          /*!< 0x40000000 */
N#define GPIO_BSRR_BR14                   GPIO_BSRR_BR14_Msk                    
N#define GPIO_BSRR_BR15_Pos               (31U)                                 
N#define GPIO_BSRR_BR15_Msk               (0x1UL << GPIO_BSRR_BR15_Pos)          /*!< 0x80000000 */
N#define GPIO_BSRR_BR15                   GPIO_BSRR_BR15_Msk                    
N
N/* Legacy defines */
N#define GPIO_BSRR_BS_0                   GPIO_BSRR_BS0
N#define GPIO_BSRR_BS_1                   GPIO_BSRR_BS1
N#define GPIO_BSRR_BS_2                   GPIO_BSRR_BS2
N#define GPIO_BSRR_BS_3                   GPIO_BSRR_BS3
N#define GPIO_BSRR_BS_4                   GPIO_BSRR_BS4
N#define GPIO_BSRR_BS_5                   GPIO_BSRR_BS5
N#define GPIO_BSRR_BS_6                   GPIO_BSRR_BS6
N#define GPIO_BSRR_BS_7                   GPIO_BSRR_BS7
N#define GPIO_BSRR_BS_8                   GPIO_BSRR_BS8
N#define GPIO_BSRR_BS_9                   GPIO_BSRR_BS9
N#define GPIO_BSRR_BS_10                  GPIO_BSRR_BS10
N#define GPIO_BSRR_BS_11                  GPIO_BSRR_BS11
N#define GPIO_BSRR_BS_12                  GPIO_BSRR_BS12
N#define GPIO_BSRR_BS_13                  GPIO_BSRR_BS13
N#define GPIO_BSRR_BS_14                  GPIO_BSRR_BS14
N#define GPIO_BSRR_BS_15                  GPIO_BSRR_BS15
N#define GPIO_BSRR_BR_0                   GPIO_BSRR_BR0
N#define GPIO_BSRR_BR_1                   GPIO_BSRR_BR1
N#define GPIO_BSRR_BR_2                   GPIO_BSRR_BR2
N#define GPIO_BSRR_BR_3                   GPIO_BSRR_BR3
N#define GPIO_BSRR_BR_4                   GPIO_BSRR_BR4
N#define GPIO_BSRR_BR_5                   GPIO_BSRR_BR5
N#define GPIO_BSRR_BR_6                   GPIO_BSRR_BR6
N#define GPIO_BSRR_BR_7                   GPIO_BSRR_BR7
N#define GPIO_BSRR_BR_8                   GPIO_BSRR_BR8
N#define GPIO_BSRR_BR_9                   GPIO_BSRR_BR9
N#define GPIO_BSRR_BR_10                  GPIO_BSRR_BR10
N#define GPIO_BSRR_BR_11                  GPIO_BSRR_BR11
N#define GPIO_BSRR_BR_12                  GPIO_BSRR_BR12
N#define GPIO_BSRR_BR_13                  GPIO_BSRR_BR13
N#define GPIO_BSRR_BR_14                  GPIO_BSRR_BR14
N#define GPIO_BSRR_BR_15                  GPIO_BSRR_BR15
N#define GPIO_BRR_BR0                     GPIO_BSRR_BR0
N#define GPIO_BRR_BR0_Pos                 GPIO_BSRR_BR0_Pos
N#define GPIO_BRR_BR0_Msk                 GPIO_BSRR_BR0_Msk
N#define GPIO_BRR_BR1                     GPIO_BSRR_BR1
N#define GPIO_BRR_BR1_Pos                 GPIO_BSRR_BR1_Pos
N#define GPIO_BRR_BR1_Msk                 GPIO_BSRR_BR1_Msk
N#define GPIO_BRR_BR2                     GPIO_BSRR_BR2
N#define GPIO_BRR_BR2_Pos                 GPIO_BSRR_BR2_Pos
N#define GPIO_BRR_BR2_Msk                 GPIO_BSRR_BR2_Msk
N#define GPIO_BRR_BR3                     GPIO_BSRR_BR3
N#define GPIO_BRR_BR3_Pos                 GPIO_BSRR_BR3_Pos
N#define GPIO_BRR_BR3_Msk                 GPIO_BSRR_BR3_Msk
N#define GPIO_BRR_BR4                     GPIO_BSRR_BR4
N#define GPIO_BRR_BR4_Pos                 GPIO_BSRR_BR4_Pos
N#define GPIO_BRR_BR4_Msk                 GPIO_BSRR_BR4_Msk
N#define GPIO_BRR_BR5                     GPIO_BSRR_BR5
N#define GPIO_BRR_BR5_Pos                 GPIO_BSRR_BR5_Pos
N#define GPIO_BRR_BR5_Msk                 GPIO_BSRR_BR5_Msk
N#define GPIO_BRR_BR6                     GPIO_BSRR_BR6
N#define GPIO_BRR_BR6_Pos                 GPIO_BSRR_BR6_Pos
N#define GPIO_BRR_BR6_Msk                 GPIO_BSRR_BR6_Msk
N#define GPIO_BRR_BR7                     GPIO_BSRR_BR7
N#define GPIO_BRR_BR7_Pos                 GPIO_BSRR_BR7_Pos
N#define GPIO_BRR_BR7_Msk                 GPIO_BSRR_BR7_Msk
N#define GPIO_BRR_BR8                     GPIO_BSRR_BR8
N#define GPIO_BRR_BR8_Pos                 GPIO_BSRR_BR8_Pos
N#define GPIO_BRR_BR8_Msk                 GPIO_BSRR_BR8_Msk
N#define GPIO_BRR_BR9                     GPIO_BSRR_BR9
N#define GPIO_BRR_BR9_Pos                 GPIO_BSRR_BR9_Pos
N#define GPIO_BRR_BR9_Msk                 GPIO_BSRR_BR9_Msk
N#define GPIO_BRR_BR10                    GPIO_BSRR_BR10
N#define GPIO_BRR_BR10_Pos                GPIO_BSRR_BR10_Pos
N#define GPIO_BRR_BR10_Msk                GPIO_BSRR_BR10_Msk
N#define GPIO_BRR_BR11                    GPIO_BSRR_BR11
N#define GPIO_BRR_BR11_Pos                GPIO_BSRR_BR11_Pos
N#define GPIO_BRR_BR11_Msk                GPIO_BSRR_BR11_Msk
N#define GPIO_BRR_BR12                    GPIO_BSRR_BR12
N#define GPIO_BRR_BR12_Pos                GPIO_BSRR_BR12_Pos
N#define GPIO_BRR_BR12_Msk                GPIO_BSRR_BR12_Msk
N#define GPIO_BRR_BR13                    GPIO_BSRR_BR13
N#define GPIO_BRR_BR13_Pos                GPIO_BSRR_BR13_Pos
N#define GPIO_BRR_BR13_Msk                GPIO_BSRR_BR13_Msk
N#define GPIO_BRR_BR14                    GPIO_BSRR_BR14
N#define GPIO_BRR_BR14_Pos                GPIO_BSRR_BR14_Pos
N#define GPIO_BRR_BR14_Msk                GPIO_BSRR_BR14_Msk
N#define GPIO_BRR_BR15                    GPIO_BSRR_BR15
N#define GPIO_BRR_BR15_Pos                GPIO_BSRR_BR15_Pos
N#define GPIO_BRR_BR15_Msk                GPIO_BSRR_BR15_Msk 
N/****************** Bit definition for GPIO_LCKR register *********************/
N#define GPIO_LCKR_LCK0_Pos               (0U)                                  
N#define GPIO_LCKR_LCK0_Msk               (0x1UL << GPIO_LCKR_LCK0_Pos)          /*!< 0x00000001 */
N#define GPIO_LCKR_LCK0                   GPIO_LCKR_LCK0_Msk                    
N#define GPIO_LCKR_LCK1_Pos               (1U)                                  
N#define GPIO_LCKR_LCK1_Msk               (0x1UL << GPIO_LCKR_LCK1_Pos)          /*!< 0x00000002 */
N#define GPIO_LCKR_LCK1                   GPIO_LCKR_LCK1_Msk                    
N#define GPIO_LCKR_LCK2_Pos               (2U)                                  
N#define GPIO_LCKR_LCK2_Msk               (0x1UL << GPIO_LCKR_LCK2_Pos)          /*!< 0x00000004 */
N#define GPIO_LCKR_LCK2                   GPIO_LCKR_LCK2_Msk                    
N#define GPIO_LCKR_LCK3_Pos               (3U)                                  
N#define GPIO_LCKR_LCK3_Msk               (0x1UL << GPIO_LCKR_LCK3_Pos)          /*!< 0x00000008 */
N#define GPIO_LCKR_LCK3                   GPIO_LCKR_LCK3_Msk                    
N#define GPIO_LCKR_LCK4_Pos               (4U)                                  
N#define GPIO_LCKR_LCK4_Msk               (0x1UL << GPIO_LCKR_LCK4_Pos)          /*!< 0x00000010 */
N#define GPIO_LCKR_LCK4                   GPIO_LCKR_LCK4_Msk                    
N#define GPIO_LCKR_LCK5_Pos               (5U)                                  
N#define GPIO_LCKR_LCK5_Msk               (0x1UL << GPIO_LCKR_LCK5_Pos)          /*!< 0x00000020 */
N#define GPIO_LCKR_LCK5                   GPIO_LCKR_LCK5_Msk                    
N#define GPIO_LCKR_LCK6_Pos               (6U)                                  
N#define GPIO_LCKR_LCK6_Msk               (0x1UL << GPIO_LCKR_LCK6_Pos)          /*!< 0x00000040 */
N#define GPIO_LCKR_LCK6                   GPIO_LCKR_LCK6_Msk                    
N#define GPIO_LCKR_LCK7_Pos               (7U)                                  
N#define GPIO_LCKR_LCK7_Msk               (0x1UL << GPIO_LCKR_LCK7_Pos)          /*!< 0x00000080 */
N#define GPIO_LCKR_LCK7                   GPIO_LCKR_LCK7_Msk                    
N#define GPIO_LCKR_LCK8_Pos               (8U)                                  
N#define GPIO_LCKR_LCK8_Msk               (0x1UL << GPIO_LCKR_LCK8_Pos)          /*!< 0x00000100 */
N#define GPIO_LCKR_LCK8                   GPIO_LCKR_LCK8_Msk                    
N#define GPIO_LCKR_LCK9_Pos               (9U)                                  
N#define GPIO_LCKR_LCK9_Msk               (0x1UL << GPIO_LCKR_LCK9_Pos)          /*!< 0x00000200 */
N#define GPIO_LCKR_LCK9                   GPIO_LCKR_LCK9_Msk                    
N#define GPIO_LCKR_LCK10_Pos              (10U)                                 
N#define GPIO_LCKR_LCK10_Msk              (0x1UL << GPIO_LCKR_LCK10_Pos)         /*!< 0x00000400 */
N#define GPIO_LCKR_LCK10                  GPIO_LCKR_LCK10_Msk                   
N#define GPIO_LCKR_LCK11_Pos              (11U)                                 
N#define GPIO_LCKR_LCK11_Msk              (0x1UL << GPIO_LCKR_LCK11_Pos)         /*!< 0x00000800 */
N#define GPIO_LCKR_LCK11                  GPIO_LCKR_LCK11_Msk                   
N#define GPIO_LCKR_LCK12_Pos              (12U)                                 
N#define GPIO_LCKR_LCK12_Msk              (0x1UL << GPIO_LCKR_LCK12_Pos)         /*!< 0x00001000 */
N#define GPIO_LCKR_LCK12                  GPIO_LCKR_LCK12_Msk                   
N#define GPIO_LCKR_LCK13_Pos              (13U)                                 
N#define GPIO_LCKR_LCK13_Msk              (0x1UL << GPIO_LCKR_LCK13_Pos)         /*!< 0x00002000 */
N#define GPIO_LCKR_LCK13                  GPIO_LCKR_LCK13_Msk                   
N#define GPIO_LCKR_LCK14_Pos              (14U)                                 
N#define GPIO_LCKR_LCK14_Msk              (0x1UL << GPIO_LCKR_LCK14_Pos)         /*!< 0x00004000 */
N#define GPIO_LCKR_LCK14                  GPIO_LCKR_LCK14_Msk                   
N#define GPIO_LCKR_LCK15_Pos              (15U)                                 
N#define GPIO_LCKR_LCK15_Msk              (0x1UL << GPIO_LCKR_LCK15_Pos)         /*!< 0x00008000 */
N#define GPIO_LCKR_LCK15                  GPIO_LCKR_LCK15_Msk                   
N#define GPIO_LCKR_LCKK_Pos               (16U)                                 
N#define GPIO_LCKR_LCKK_Msk               (0x1UL << GPIO_LCKR_LCKK_Pos)          /*!< 0x00010000 */
N#define GPIO_LCKR_LCKK                   GPIO_LCKR_LCKK_Msk                    
N/****************** Bit definition for GPIO_AFRL register *********************/
N#define GPIO_AFRL_AFSEL0_Pos             (0U)                                  
N#define GPIO_AFRL_AFSEL0_Msk             (0xFUL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x0000000F */
N#define GPIO_AFRL_AFSEL0                 GPIO_AFRL_AFSEL0_Msk                  
N#define GPIO_AFRL_AFSEL0_0               (0x1UL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x00000001 */
N#define GPIO_AFRL_AFSEL0_1               (0x2UL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x00000002 */
N#define GPIO_AFRL_AFSEL0_2               (0x4UL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x00000004 */
N#define GPIO_AFRL_AFSEL0_3               (0x8UL << GPIO_AFRL_AFSEL0_Pos)        /*!< 0x00000008 */
N#define GPIO_AFRL_AFSEL1_Pos             (4U)                                  
N#define GPIO_AFRL_AFSEL1_Msk             (0xFUL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x000000F0 */
N#define GPIO_AFRL_AFSEL1                 GPIO_AFRL_AFSEL1_Msk                  
N#define GPIO_AFRL_AFSEL1_0               (0x1UL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x00000010 */
N#define GPIO_AFRL_AFSEL1_1               (0x2UL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x00000020 */
N#define GPIO_AFRL_AFSEL1_2               (0x4UL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x00000040 */
N#define GPIO_AFRL_AFSEL1_3               (0x8UL << GPIO_AFRL_AFSEL1_Pos)        /*!< 0x00000080 */
N#define GPIO_AFRL_AFSEL2_Pos             (8U)                                  
N#define GPIO_AFRL_AFSEL2_Msk             (0xFUL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000F00 */
N#define GPIO_AFRL_AFSEL2                 GPIO_AFRL_AFSEL2_Msk                  
N#define GPIO_AFRL_AFSEL2_0               (0x1UL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000100 */
N#define GPIO_AFRL_AFSEL2_1               (0x2UL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000200 */
N#define GPIO_AFRL_AFSEL2_2               (0x4UL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000400 */
N#define GPIO_AFRL_AFSEL2_3               (0x8UL << GPIO_AFRL_AFSEL2_Pos)        /*!< 0x00000800 */
N#define GPIO_AFRL_AFSEL3_Pos             (12U)                                 
N#define GPIO_AFRL_AFSEL3_Msk             (0xFUL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x0000F000 */
N#define GPIO_AFRL_AFSEL3                 GPIO_AFRL_AFSEL3_Msk                  
N#define GPIO_AFRL_AFSEL3_0               (0x1UL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x00001000 */
N#define GPIO_AFRL_AFSEL3_1               (0x2UL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x00002000 */
N#define GPIO_AFRL_AFSEL3_2               (0x4UL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x00004000 */
N#define GPIO_AFRL_AFSEL3_3               (0x8UL << GPIO_AFRL_AFSEL3_Pos)        /*!< 0x00008000 */
N#define GPIO_AFRL_AFSEL4_Pos             (16U)                                 
N#define GPIO_AFRL_AFSEL4_Msk             (0xFUL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x000F0000 */
N#define GPIO_AFRL_AFSEL4                 GPIO_AFRL_AFSEL4_Msk                  
N#define GPIO_AFRL_AFSEL4_0               (0x1UL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x00010000 */
N#define GPIO_AFRL_AFSEL4_1               (0x2UL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x00020000 */
N#define GPIO_AFRL_AFSEL4_2               (0x4UL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x00040000 */
N#define GPIO_AFRL_AFSEL4_3               (0x8UL << GPIO_AFRL_AFSEL4_Pos)        /*!< 0x00080000 */
N#define GPIO_AFRL_AFSEL5_Pos             (20U)                                 
N#define GPIO_AFRL_AFSEL5_Msk             (0xFUL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00F00000 */
N#define GPIO_AFRL_AFSEL5                 GPIO_AFRL_AFSEL5_Msk                  
N#define GPIO_AFRL_AFSEL5_0               (0x1UL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00100000 */
N#define GPIO_AFRL_AFSEL5_1               (0x2UL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00200000 */
N#define GPIO_AFRL_AFSEL5_2               (0x4UL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00400000 */
N#define GPIO_AFRL_AFSEL5_3               (0x8UL << GPIO_AFRL_AFSEL5_Pos)        /*!< 0x00800000 */
N#define GPIO_AFRL_AFSEL6_Pos             (24U)                                 
N#define GPIO_AFRL_AFSEL6_Msk             (0xFUL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x0F000000 */
N#define GPIO_AFRL_AFSEL6                 GPIO_AFRL_AFSEL6_Msk                  
N#define GPIO_AFRL_AFSEL6_0               (0x1UL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x01000000 */
N#define GPIO_AFRL_AFSEL6_1               (0x2UL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x02000000 */
N#define GPIO_AFRL_AFSEL6_2               (0x4UL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x04000000 */
N#define GPIO_AFRL_AFSEL6_3               (0x8UL << GPIO_AFRL_AFSEL6_Pos)        /*!< 0x08000000 */
N#define GPIO_AFRL_AFSEL7_Pos             (28U)                                 
N#define GPIO_AFRL_AFSEL7_Msk             (0xFUL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0xF0000000 */
N#define GPIO_AFRL_AFSEL7                 GPIO_AFRL_AFSEL7_Msk                  
N#define GPIO_AFRL_AFSEL7_0               (0x1UL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0x10000000 */
N#define GPIO_AFRL_AFSEL7_1               (0x2UL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0x20000000 */
N#define GPIO_AFRL_AFSEL7_2               (0x4UL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0x40000000 */
N#define GPIO_AFRL_AFSEL7_3               (0x8UL << GPIO_AFRL_AFSEL7_Pos)        /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_AFRL_AFRL0                  GPIO_AFRL_AFSEL0
N#define GPIO_AFRL_AFRL0_0                GPIO_AFRL_AFSEL0_0
N#define GPIO_AFRL_AFRL0_1                GPIO_AFRL_AFSEL0_1
N#define GPIO_AFRL_AFRL0_2                GPIO_AFRL_AFSEL0_2
N#define GPIO_AFRL_AFRL0_3                GPIO_AFRL_AFSEL0_3
N#define GPIO_AFRL_AFRL1                  GPIO_AFRL_AFSEL1
N#define GPIO_AFRL_AFRL1_0                GPIO_AFRL_AFSEL1_0
N#define GPIO_AFRL_AFRL1_1                GPIO_AFRL_AFSEL1_1
N#define GPIO_AFRL_AFRL1_2                GPIO_AFRL_AFSEL1_2
N#define GPIO_AFRL_AFRL1_3                GPIO_AFRL_AFSEL1_3
N#define GPIO_AFRL_AFRL2                  GPIO_AFRL_AFSEL2
N#define GPIO_AFRL_AFRL2_0                GPIO_AFRL_AFSEL2_0
N#define GPIO_AFRL_AFRL2_1                GPIO_AFRL_AFSEL2_1
N#define GPIO_AFRL_AFRL2_2                GPIO_AFRL_AFSEL2_2
N#define GPIO_AFRL_AFRL2_3                GPIO_AFRL_AFSEL2_3
N#define GPIO_AFRL_AFRL3                  GPIO_AFRL_AFSEL3
N#define GPIO_AFRL_AFRL3_0                GPIO_AFRL_AFSEL3_0
N#define GPIO_AFRL_AFRL3_1                GPIO_AFRL_AFSEL3_1
N#define GPIO_AFRL_AFRL3_2                GPIO_AFRL_AFSEL3_2
N#define GPIO_AFRL_AFRL3_3                GPIO_AFRL_AFSEL3_3
N#define GPIO_AFRL_AFRL4                  GPIO_AFRL_AFSEL4
N#define GPIO_AFRL_AFRL4_0                GPIO_AFRL_AFSEL4_0
N#define GPIO_AFRL_AFRL4_1                GPIO_AFRL_AFSEL4_1
N#define GPIO_AFRL_AFRL4_2                GPIO_AFRL_AFSEL4_2
N#define GPIO_AFRL_AFRL4_3                GPIO_AFRL_AFSEL4_3
N#define GPIO_AFRL_AFRL5                  GPIO_AFRL_AFSEL5
N#define GPIO_AFRL_AFRL5_0                GPIO_AFRL_AFSEL5_0
N#define GPIO_AFRL_AFRL5_1                GPIO_AFRL_AFSEL5_1
N#define GPIO_AFRL_AFRL5_2                GPIO_AFRL_AFSEL5_2
N#define GPIO_AFRL_AFRL5_3                GPIO_AFRL_AFSEL5_3
N#define GPIO_AFRL_AFRL6                  GPIO_AFRL_AFSEL6
N#define GPIO_AFRL_AFRL6_0                GPIO_AFRL_AFSEL6_0
N#define GPIO_AFRL_AFRL6_1                GPIO_AFRL_AFSEL6_1
N#define GPIO_AFRL_AFRL6_2                GPIO_AFRL_AFSEL6_2
N#define GPIO_AFRL_AFRL6_3                GPIO_AFRL_AFSEL6_3
N#define GPIO_AFRL_AFRL7                  GPIO_AFRL_AFSEL7
N#define GPIO_AFRL_AFRL7_0                GPIO_AFRL_AFSEL7_0
N#define GPIO_AFRL_AFRL7_1                GPIO_AFRL_AFSEL7_1
N#define GPIO_AFRL_AFRL7_2                GPIO_AFRL_AFSEL7_2
N#define GPIO_AFRL_AFRL7_3                GPIO_AFRL_AFSEL7_3
N
N/****************** Bit definition for GPIO_AFRH register *********************/
N#define GPIO_AFRH_AFSEL8_Pos             (0U)                                  
N#define GPIO_AFRH_AFSEL8_Msk             (0xFUL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x0000000F */
N#define GPIO_AFRH_AFSEL8                 GPIO_AFRH_AFSEL8_Msk                  
N#define GPIO_AFRH_AFSEL8_0               (0x1UL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x00000001 */
N#define GPIO_AFRH_AFSEL8_1               (0x2UL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x00000002 */
N#define GPIO_AFRH_AFSEL8_2               (0x4UL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x00000004 */
N#define GPIO_AFRH_AFSEL8_3               (0x8UL << GPIO_AFRH_AFSEL8_Pos)        /*!< 0x00000008 */
N#define GPIO_AFRH_AFSEL9_Pos             (4U)                                  
N#define GPIO_AFRH_AFSEL9_Msk             (0xFUL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x000000F0 */
N#define GPIO_AFRH_AFSEL9                 GPIO_AFRH_AFSEL9_Msk                  
N#define GPIO_AFRH_AFSEL9_0               (0x1UL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x00000010 */
N#define GPIO_AFRH_AFSEL9_1               (0x2UL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x00000020 */
N#define GPIO_AFRH_AFSEL9_2               (0x4UL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x00000040 */
N#define GPIO_AFRH_AFSEL9_3               (0x8UL << GPIO_AFRH_AFSEL9_Pos)        /*!< 0x00000080 */
N#define GPIO_AFRH_AFSEL10_Pos            (8U)                                  
N#define GPIO_AFRH_AFSEL10_Msk            (0xFUL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000F00 */
N#define GPIO_AFRH_AFSEL10                GPIO_AFRH_AFSEL10_Msk                 
N#define GPIO_AFRH_AFSEL10_0              (0x1UL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000100 */
N#define GPIO_AFRH_AFSEL10_1              (0x2UL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000200 */
N#define GPIO_AFRH_AFSEL10_2              (0x4UL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000400 */
N#define GPIO_AFRH_AFSEL10_3              (0x8UL << GPIO_AFRH_AFSEL10_Pos)       /*!< 0x00000800 */
N#define GPIO_AFRH_AFSEL11_Pos            (12U)                                 
N#define GPIO_AFRH_AFSEL11_Msk            (0xFUL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x0000F000 */
N#define GPIO_AFRH_AFSEL11                GPIO_AFRH_AFSEL11_Msk                 
N#define GPIO_AFRH_AFSEL11_0              (0x1UL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x00001000 */
N#define GPIO_AFRH_AFSEL11_1              (0x2UL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x00002000 */
N#define GPIO_AFRH_AFSEL11_2              (0x4UL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x00004000 */
N#define GPIO_AFRH_AFSEL11_3              (0x8UL << GPIO_AFRH_AFSEL11_Pos)       /*!< 0x00008000 */
N#define GPIO_AFRH_AFSEL12_Pos            (16U)                                 
N#define GPIO_AFRH_AFSEL12_Msk            (0xFUL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x000F0000 */
N#define GPIO_AFRH_AFSEL12                GPIO_AFRH_AFSEL12_Msk                 
N#define GPIO_AFRH_AFSEL12_0              (0x1UL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x00010000 */
N#define GPIO_AFRH_AFSEL12_1              (0x2UL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x00020000 */
N#define GPIO_AFRH_AFSEL12_2              (0x4UL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x00040000 */
N#define GPIO_AFRH_AFSEL12_3              (0x8UL << GPIO_AFRH_AFSEL12_Pos)       /*!< 0x00080000 */
N#define GPIO_AFRH_AFSEL13_Pos            (20U)                                 
N#define GPIO_AFRH_AFSEL13_Msk            (0xFUL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00F00000 */
N#define GPIO_AFRH_AFSEL13                GPIO_AFRH_AFSEL13_Msk                 
N#define GPIO_AFRH_AFSEL13_0              (0x1UL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00100000 */
N#define GPIO_AFRH_AFSEL13_1              (0x2UL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00200000 */
N#define GPIO_AFRH_AFSEL13_2              (0x4UL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00400000 */
N#define GPIO_AFRH_AFSEL13_3              (0x8UL << GPIO_AFRH_AFSEL13_Pos)       /*!< 0x00800000 */
N#define GPIO_AFRH_AFSEL14_Pos            (24U)                                 
N#define GPIO_AFRH_AFSEL14_Msk            (0xFUL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x0F000000 */
N#define GPIO_AFRH_AFSEL14                GPIO_AFRH_AFSEL14_Msk                 
N#define GPIO_AFRH_AFSEL14_0              (0x1UL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x01000000 */
N#define GPIO_AFRH_AFSEL14_1              (0x2UL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x02000000 */
N#define GPIO_AFRH_AFSEL14_2              (0x4UL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x04000000 */
N#define GPIO_AFRH_AFSEL14_3              (0x8UL << GPIO_AFRH_AFSEL14_Pos)       /*!< 0x08000000 */
N#define GPIO_AFRH_AFSEL15_Pos            (28U)                                 
N#define GPIO_AFRH_AFSEL15_Msk            (0xFUL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0xF0000000 */
N#define GPIO_AFRH_AFSEL15                GPIO_AFRH_AFSEL15_Msk                 
N#define GPIO_AFRH_AFSEL15_0              (0x1UL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0x10000000 */
N#define GPIO_AFRH_AFSEL15_1              (0x2UL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0x20000000 */
N#define GPIO_AFRH_AFSEL15_2              (0x4UL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0x40000000 */
N#define GPIO_AFRH_AFSEL15_3              (0x8UL << GPIO_AFRH_AFSEL15_Pos)       /*!< 0x80000000 */
N
N/* Legacy defines */
N#define GPIO_AFRH_AFRH0                  GPIO_AFRH_AFSEL8
N#define GPIO_AFRH_AFRH0_0                GPIO_AFRH_AFSEL8_0
N#define GPIO_AFRH_AFRH0_1                GPIO_AFRH_AFSEL8_1
N#define GPIO_AFRH_AFRH0_2                GPIO_AFRH_AFSEL8_2
N#define GPIO_AFRH_AFRH0_3                GPIO_AFRH_AFSEL8_3
N#define GPIO_AFRH_AFRH1                  GPIO_AFRH_AFSEL9
N#define GPIO_AFRH_AFRH1_0                GPIO_AFRH_AFSEL9_0
N#define GPIO_AFRH_AFRH1_1                GPIO_AFRH_AFSEL9_1
N#define GPIO_AFRH_AFRH1_2                GPIO_AFRH_AFSEL9_2
N#define GPIO_AFRH_AFRH1_3                GPIO_AFRH_AFSEL9_3
N#define GPIO_AFRH_AFRH2                  GPIO_AFRH_AFSEL10
N#define GPIO_AFRH_AFRH2_0                GPIO_AFRH_AFSEL10_0
N#define GPIO_AFRH_AFRH2_1                GPIO_AFRH_AFSEL10_1
N#define GPIO_AFRH_AFRH2_2                GPIO_AFRH_AFSEL10_2
N#define GPIO_AFRH_AFRH2_3                GPIO_AFRH_AFSEL10_3
N#define GPIO_AFRH_AFRH3                  GPIO_AFRH_AFSEL11
N#define GPIO_AFRH_AFRH3_0                GPIO_AFRH_AFSEL11_0
N#define GPIO_AFRH_AFRH3_1                GPIO_AFRH_AFSEL11_1
N#define GPIO_AFRH_AFRH3_2                GPIO_AFRH_AFSEL11_2
N#define GPIO_AFRH_AFRH3_3                GPIO_AFRH_AFSEL11_3
N#define GPIO_AFRH_AFRH4                  GPIO_AFRH_AFSEL12
N#define GPIO_AFRH_AFRH4_0                GPIO_AFRH_AFSEL12_0
N#define GPIO_AFRH_AFRH4_1                GPIO_AFRH_AFSEL12_1
N#define GPIO_AFRH_AFRH4_2                GPIO_AFRH_AFSEL12_2
N#define GPIO_AFRH_AFRH4_3                GPIO_AFRH_AFSEL12_3
N#define GPIO_AFRH_AFRH5                  GPIO_AFRH_AFSEL13
N#define GPIO_AFRH_AFRH5_0                GPIO_AFRH_AFSEL13_0
N#define GPIO_AFRH_AFRH5_1                GPIO_AFRH_AFSEL13_1
N#define GPIO_AFRH_AFRH5_2                GPIO_AFRH_AFSEL13_2
N#define GPIO_AFRH_AFRH5_3                GPIO_AFRH_AFSEL13_3
N#define GPIO_AFRH_AFRH6                  GPIO_AFRH_AFSEL14
N#define GPIO_AFRH_AFRH6_0                GPIO_AFRH_AFSEL14_0
N#define GPIO_AFRH_AFRH6_1                GPIO_AFRH_AFSEL14_1
N#define GPIO_AFRH_AFRH6_2                GPIO_AFRH_AFSEL14_2
N#define GPIO_AFRH_AFRH6_3                GPIO_AFRH_AFSEL14_3
N#define GPIO_AFRH_AFRH7                  GPIO_AFRH_AFSEL15
N#define GPIO_AFRH_AFRH7_0                GPIO_AFRH_AFSEL15_0
N#define GPIO_AFRH_AFRH7_1                GPIO_AFRH_AFSEL15_1
N#define GPIO_AFRH_AFRH7_2                GPIO_AFRH_AFSEL15_2
N#define GPIO_AFRH_AFRH7_3                GPIO_AFRH_AFSEL15_3
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Inter-integrated Circuit Interface                    */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for I2C_CR1 register  ********************/
N#define I2C_CR1_PE_Pos            (0U)                                         
N#define I2C_CR1_PE_Msk            (0x1UL << I2C_CR1_PE_Pos)                     /*!< 0x00000001 */
N#define I2C_CR1_PE                I2C_CR1_PE_Msk                               /*!<Peripheral Enable                             */
N#define I2C_CR1_SMBUS_Pos         (1U)                                         
N#define I2C_CR1_SMBUS_Msk         (0x1UL << I2C_CR1_SMBUS_Pos)                  /*!< 0x00000002 */
N#define I2C_CR1_SMBUS             I2C_CR1_SMBUS_Msk                            /*!<SMBus Mode                                    */
N#define I2C_CR1_SMBTYPE_Pos       (3U)                                         
N#define I2C_CR1_SMBTYPE_Msk       (0x1UL << I2C_CR1_SMBTYPE_Pos)                /*!< 0x00000008 */
N#define I2C_CR1_SMBTYPE           I2C_CR1_SMBTYPE_Msk                          /*!<SMBus Type                                    */
N#define I2C_CR1_ENARP_Pos         (4U)                                         
N#define I2C_CR1_ENARP_Msk         (0x1UL << I2C_CR1_ENARP_Pos)                  /*!< 0x00000010 */
N#define I2C_CR1_ENARP             I2C_CR1_ENARP_Msk                            /*!<ARP Enable                                    */
N#define I2C_CR1_ENPEC_Pos         (5U)                                         
N#define I2C_CR1_ENPEC_Msk         (0x1UL << I2C_CR1_ENPEC_Pos)                  /*!< 0x00000020 */
N#define I2C_CR1_ENPEC             I2C_CR1_ENPEC_Msk                            /*!<PEC Enable                                    */
N#define I2C_CR1_ENGC_Pos          (6U)                                         
N#define I2C_CR1_ENGC_Msk          (0x1UL << I2C_CR1_ENGC_Pos)                   /*!< 0x00000040 */
N#define I2C_CR1_ENGC              I2C_CR1_ENGC_Msk                             /*!<General Call Enable                           */
N#define I2C_CR1_NOSTRETCH_Pos     (7U)                                         
N#define I2C_CR1_NOSTRETCH_Msk     (0x1UL << I2C_CR1_NOSTRETCH_Pos)              /*!< 0x00000080 */
N#define I2C_CR1_NOSTRETCH         I2C_CR1_NOSTRETCH_Msk                        /*!<Clock Stretching Disable (Slave mode)         */
N#define I2C_CR1_START_Pos         (8U)                                         
N#define I2C_CR1_START_Msk         (0x1UL << I2C_CR1_START_Pos)                  /*!< 0x00000100 */
N#define I2C_CR1_START             I2C_CR1_START_Msk                            /*!<Start Generation                              */
N#define I2C_CR1_STOP_Pos          (9U)                                         
N#define I2C_CR1_STOP_Msk          (0x1UL << I2C_CR1_STOP_Pos)                   /*!< 0x00000200 */
N#define I2C_CR1_STOP              I2C_CR1_STOP_Msk                             /*!<Stop Generation                               */
N#define I2C_CR1_ACK_Pos           (10U)                                        
N#define I2C_CR1_ACK_Msk           (0x1UL << I2C_CR1_ACK_Pos)                    /*!< 0x00000400 */
N#define I2C_CR1_ACK               I2C_CR1_ACK_Msk                              /*!<Acknowledge Enable                            */
N#define I2C_CR1_POS_Pos           (11U)                                        
N#define I2C_CR1_POS_Msk           (0x1UL << I2C_CR1_POS_Pos)                    /*!< 0x00000800 */
N#define I2C_CR1_POS               I2C_CR1_POS_Msk                              /*!<Acknowledge/PEC Position (for data reception) */
N#define I2C_CR1_PEC_Pos           (12U)                                        
N#define I2C_CR1_PEC_Msk           (0x1UL << I2C_CR1_PEC_Pos)                    /*!< 0x00001000 */
N#define I2C_CR1_PEC               I2C_CR1_PEC_Msk                              /*!<Packet Error Checking                         */
N#define I2C_CR1_ALERT_Pos         (13U)                                        
N#define I2C_CR1_ALERT_Msk         (0x1UL << I2C_CR1_ALERT_Pos)                  /*!< 0x00002000 */
N#define I2C_CR1_ALERT             I2C_CR1_ALERT_Msk                            /*!<SMBus Alert                                   */
N#define I2C_CR1_SWRST_Pos         (15U)                                        
N#define I2C_CR1_SWRST_Msk         (0x1UL << I2C_CR1_SWRST_Pos)                  /*!< 0x00008000 */
N#define I2C_CR1_SWRST             I2C_CR1_SWRST_Msk                            /*!<Software Reset                                */
N
N/*******************  Bit definition for I2C_CR2 register  ********************/
N#define I2C_CR2_FREQ_Pos          (0U)                                         
N#define I2C_CR2_FREQ_Msk          (0x3FUL << I2C_CR2_FREQ_Pos)                  /*!< 0x0000003F */
N#define I2C_CR2_FREQ              I2C_CR2_FREQ_Msk                             /*!<FREQ[5:0] bits (Peripheral Clock Frequency)   */
N#define I2C_CR2_FREQ_0            (0x01UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000001 */
N#define I2C_CR2_FREQ_1            (0x02UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000002 */
N#define I2C_CR2_FREQ_2            (0x04UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000004 */
N#define I2C_CR2_FREQ_3            (0x08UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000008 */
N#define I2C_CR2_FREQ_4            (0x10UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000010 */
N#define I2C_CR2_FREQ_5            (0x20UL << I2C_CR2_FREQ_Pos)                  /*!< 0x00000020 */
N
N#define I2C_CR2_ITERREN_Pos       (8U)                                         
N#define I2C_CR2_ITERREN_Msk       (0x1UL << I2C_CR2_ITERREN_Pos)                /*!< 0x00000100 */
N#define I2C_CR2_ITERREN           I2C_CR2_ITERREN_Msk                          /*!<Error Interrupt Enable  */
N#define I2C_CR2_ITEVTEN_Pos       (9U)                                         
N#define I2C_CR2_ITEVTEN_Msk       (0x1UL << I2C_CR2_ITEVTEN_Pos)                /*!< 0x00000200 */
N#define I2C_CR2_ITEVTEN           I2C_CR2_ITEVTEN_Msk                          /*!<Event Interrupt Enable  */
N#define I2C_CR2_ITBUFEN_Pos       (10U)                                        
N#define I2C_CR2_ITBUFEN_Msk       (0x1UL << I2C_CR2_ITBUFEN_Pos)                /*!< 0x00000400 */
N#define I2C_CR2_ITBUFEN           I2C_CR2_ITBUFEN_Msk                          /*!<Buffer Interrupt Enable */
N#define I2C_CR2_DMAEN_Pos         (11U)                                        
N#define I2C_CR2_DMAEN_Msk         (0x1UL << I2C_CR2_DMAEN_Pos)                  /*!< 0x00000800 */
N#define I2C_CR2_DMAEN             I2C_CR2_DMAEN_Msk                            /*!<DMA Requests Enable     */
N#define I2C_CR2_LAST_Pos          (12U)                                        
N#define I2C_CR2_LAST_Msk          (0x1UL << I2C_CR2_LAST_Pos)                   /*!< 0x00001000 */
N#define I2C_CR2_LAST              I2C_CR2_LAST_Msk                             /*!<DMA Last Transfer       */
N
N/*******************  Bit definition for I2C_OAR1 register  *******************/
N#define I2C_OAR1_ADD1_7           0x000000FEU                                  /*!<Interface Address */
N#define I2C_OAR1_ADD8_9           0x00000300U                                  /*!<Interface Address */
N
N#define I2C_OAR1_ADD0_Pos         (0U)                                         
N#define I2C_OAR1_ADD0_Msk         (0x1UL << I2C_OAR1_ADD0_Pos)                  /*!< 0x00000001 */
N#define I2C_OAR1_ADD0             I2C_OAR1_ADD0_Msk                            /*!<Bit 0 */
N#define I2C_OAR1_ADD1_Pos         (1U)                                         
N#define I2C_OAR1_ADD1_Msk         (0x1UL << I2C_OAR1_ADD1_Pos)                  /*!< 0x00000002 */
N#define I2C_OAR1_ADD1             I2C_OAR1_ADD1_Msk                            /*!<Bit 1 */
N#define I2C_OAR1_ADD2_Pos         (2U)                                         
N#define I2C_OAR1_ADD2_Msk         (0x1UL << I2C_OAR1_ADD2_Pos)                  /*!< 0x00000004 */
N#define I2C_OAR1_ADD2             I2C_OAR1_ADD2_Msk                            /*!<Bit 2 */
N#define I2C_OAR1_ADD3_Pos         (3U)                                         
N#define I2C_OAR1_ADD3_Msk         (0x1UL << I2C_OAR1_ADD3_Pos)                  /*!< 0x00000008 */
N#define I2C_OAR1_ADD3             I2C_OAR1_ADD3_Msk                            /*!<Bit 3 */
N#define I2C_OAR1_ADD4_Pos         (4U)                                         
N#define I2C_OAR1_ADD4_Msk         (0x1UL << I2C_OAR1_ADD4_Pos)                  /*!< 0x00000010 */
N#define I2C_OAR1_ADD4             I2C_OAR1_ADD4_Msk                            /*!<Bit 4 */
N#define I2C_OAR1_ADD5_Pos         (5U)                                         
N#define I2C_OAR1_ADD5_Msk         (0x1UL << I2C_OAR1_ADD5_Pos)                  /*!< 0x00000020 */
N#define I2C_OAR1_ADD5             I2C_OAR1_ADD5_Msk                            /*!<Bit 5 */
N#define I2C_OAR1_ADD6_Pos         (6U)                                         
N#define I2C_OAR1_ADD6_Msk         (0x1UL << I2C_OAR1_ADD6_Pos)                  /*!< 0x00000040 */
N#define I2C_OAR1_ADD6             I2C_OAR1_ADD6_Msk                            /*!<Bit 6 */
N#define I2C_OAR1_ADD7_Pos         (7U)                                         
N#define I2C_OAR1_ADD7_Msk         (0x1UL << I2C_OAR1_ADD7_Pos)                  /*!< 0x00000080 */
N#define I2C_OAR1_ADD7             I2C_OAR1_ADD7_Msk                            /*!<Bit 7 */
N#define I2C_OAR1_ADD8_Pos         (8U)                                         
N#define I2C_OAR1_ADD8_Msk         (0x1UL << I2C_OAR1_ADD8_Pos)                  /*!< 0x00000100 */
N#define I2C_OAR1_ADD8             I2C_OAR1_ADD8_Msk                            /*!<Bit 8 */
N#define I2C_OAR1_ADD9_Pos         (9U)                                         
N#define I2C_OAR1_ADD9_Msk         (0x1UL << I2C_OAR1_ADD9_Pos)                  /*!< 0x00000200 */
N#define I2C_OAR1_ADD9             I2C_OAR1_ADD9_Msk                            /*!<Bit 9 */
N
N#define I2C_OAR1_ADDMODE_Pos      (15U)                                        
N#define I2C_OAR1_ADDMODE_Msk      (0x1UL << I2C_OAR1_ADDMODE_Pos)               /*!< 0x00008000 */
N#define I2C_OAR1_ADDMODE          I2C_OAR1_ADDMODE_Msk                         /*!<Addressing Mode (Slave mode) */
N
N/*******************  Bit definition for I2C_OAR2 register  *******************/
N#define I2C_OAR2_ENDUAL_Pos       (0U)                                         
N#define I2C_OAR2_ENDUAL_Msk       (0x1UL << I2C_OAR2_ENDUAL_Pos)                /*!< 0x00000001 */
N#define I2C_OAR2_ENDUAL           I2C_OAR2_ENDUAL_Msk                          /*!<Dual addressing mode enable */
N#define I2C_OAR2_ADD2_Pos         (1U)                                         
N#define I2C_OAR2_ADD2_Msk         (0x7FUL << I2C_OAR2_ADD2_Pos)                 /*!< 0x000000FE */
N#define I2C_OAR2_ADD2             I2C_OAR2_ADD2_Msk                            /*!<Interface address           */
N
N/********************  Bit definition for I2C_DR register  ********************/
N#define I2C_DR_DR_Pos             (0U)                                         
N#define I2C_DR_DR_Msk             (0xFFUL << I2C_DR_DR_Pos)                     /*!< 0x000000FF */
N#define I2C_DR_DR                 I2C_DR_DR_Msk                                /*!<8-bit Data Register         */
N
N/*******************  Bit definition for I2C_SR1 register  ********************/
N#define I2C_SR1_SB_Pos            (0U)                                         
N#define I2C_SR1_SB_Msk            (0x1UL << I2C_SR1_SB_Pos)                     /*!< 0x00000001 */
N#define I2C_SR1_SB                I2C_SR1_SB_Msk                               /*!<Start Bit (Master mode)                         */
N#define I2C_SR1_ADDR_Pos          (1U)                                         
N#define I2C_SR1_ADDR_Msk          (0x1UL << I2C_SR1_ADDR_Pos)                   /*!< 0x00000002 */
N#define I2C_SR1_ADDR              I2C_SR1_ADDR_Msk                             /*!<Address sent (master mode)/matched (slave mode) */
N#define I2C_SR1_BTF_Pos           (2U)                                         
N#define I2C_SR1_BTF_Msk           (0x1UL << I2C_SR1_BTF_Pos)                    /*!< 0x00000004 */
N#define I2C_SR1_BTF               I2C_SR1_BTF_Msk                              /*!<Byte Transfer Finished                          */
N#define I2C_SR1_ADD10_Pos         (3U)                                         
N#define I2C_SR1_ADD10_Msk         (0x1UL << I2C_SR1_ADD10_Pos)                  /*!< 0x00000008 */
N#define I2C_SR1_ADD10             I2C_SR1_ADD10_Msk                            /*!<10-bit header sent (Master mode)                */
N#define I2C_SR1_STOPF_Pos         (4U)                                         
N#define I2C_SR1_STOPF_Msk         (0x1UL << I2C_SR1_STOPF_Pos)                  /*!< 0x00000010 */
N#define I2C_SR1_STOPF             I2C_SR1_STOPF_Msk                            /*!<Stop detection (Slave mode)                     */
N#define I2C_SR1_RXNE_Pos          (6U)                                         
N#define I2C_SR1_RXNE_Msk          (0x1UL << I2C_SR1_RXNE_Pos)                   /*!< 0x00000040 */
N#define I2C_SR1_RXNE              I2C_SR1_RXNE_Msk                             /*!<Data Register not Empty (receivers)             */
N#define I2C_SR1_TXE_Pos           (7U)                                         
N#define I2C_SR1_TXE_Msk           (0x1UL << I2C_SR1_TXE_Pos)                    /*!< 0x00000080 */
N#define I2C_SR1_TXE               I2C_SR1_TXE_Msk                              /*!<Data Register Empty (transmitters)              */
N#define I2C_SR1_BERR_Pos          (8U)                                         
N#define I2C_SR1_BERR_Msk          (0x1UL << I2C_SR1_BERR_Pos)                   /*!< 0x00000100 */
N#define I2C_SR1_BERR              I2C_SR1_BERR_Msk                             /*!<Bus Error                                       */
N#define I2C_SR1_ARLO_Pos          (9U)                                         
N#define I2C_SR1_ARLO_Msk          (0x1UL << I2C_SR1_ARLO_Pos)                   /*!< 0x00000200 */
N#define I2C_SR1_ARLO              I2C_SR1_ARLO_Msk                             /*!<Arbitration Lost (master mode)                  */
N#define I2C_SR1_AF_Pos            (10U)                                        
N#define I2C_SR1_AF_Msk            (0x1UL << I2C_SR1_AF_Pos)                     /*!< 0x00000400 */
N#define I2C_SR1_AF                I2C_SR1_AF_Msk                               /*!<Acknowledge Failure                             */
N#define I2C_SR1_OVR_Pos           (11U)                                        
N#define I2C_SR1_OVR_Msk           (0x1UL << I2C_SR1_OVR_Pos)                    /*!< 0x00000800 */
N#define I2C_SR1_OVR               I2C_SR1_OVR_Msk                              /*!<Overrun/Underrun                                */
N#define I2C_SR1_PECERR_Pos        (12U)                                        
N#define I2C_SR1_PECERR_Msk        (0x1UL << I2C_SR1_PECERR_Pos)                 /*!< 0x00001000 */
N#define I2C_SR1_PECERR            I2C_SR1_PECERR_Msk                           /*!<PEC Error in reception                          */
N#define I2C_SR1_TIMEOUT_Pos       (14U)                                        
N#define I2C_SR1_TIMEOUT_Msk       (0x1UL << I2C_SR1_TIMEOUT_Pos)                /*!< 0x00004000 */
N#define I2C_SR1_TIMEOUT           I2C_SR1_TIMEOUT_Msk                          /*!<Timeout or Tlow Error                           */
N#define I2C_SR1_SMBALERT_Pos      (15U)                                        
N#define I2C_SR1_SMBALERT_Msk      (0x1UL << I2C_SR1_SMBALERT_Pos)               /*!< 0x00008000 */
N#define I2C_SR1_SMBALERT          I2C_SR1_SMBALERT_Msk                         /*!<SMBus Alert                                     */
N
N/*******************  Bit definition for I2C_SR2 register  ********************/
N#define I2C_SR2_MSL_Pos           (0U)                                         
N#define I2C_SR2_MSL_Msk           (0x1UL << I2C_SR2_MSL_Pos)                    /*!< 0x00000001 */
N#define I2C_SR2_MSL               I2C_SR2_MSL_Msk                              /*!<Master/Slave                                    */
N#define I2C_SR2_BUSY_Pos          (1U)                                         
N#define I2C_SR2_BUSY_Msk          (0x1UL << I2C_SR2_BUSY_Pos)                   /*!< 0x00000002 */
N#define I2C_SR2_BUSY              I2C_SR2_BUSY_Msk                             /*!<Bus Busy                                        */
N#define I2C_SR2_TRA_Pos           (2U)                                         
N#define I2C_SR2_TRA_Msk           (0x1UL << I2C_SR2_TRA_Pos)                    /*!< 0x00000004 */
N#define I2C_SR2_TRA               I2C_SR2_TRA_Msk                              /*!<Transmitter/Receiver                            */
N#define I2C_SR2_GENCALL_Pos       (4U)                                         
N#define I2C_SR2_GENCALL_Msk       (0x1UL << I2C_SR2_GENCALL_Pos)                /*!< 0x00000010 */
N#define I2C_SR2_GENCALL           I2C_SR2_GENCALL_Msk                          /*!<General Call Address (Slave mode)               */
N#define I2C_SR2_SMBDEFAULT_Pos    (5U)                                         
N#define I2C_SR2_SMBDEFAULT_Msk    (0x1UL << I2C_SR2_SMBDEFAULT_Pos)             /*!< 0x00000020 */
N#define I2C_SR2_SMBDEFAULT        I2C_SR2_SMBDEFAULT_Msk                       /*!<SMBus Device Default Address (Slave mode)       */
N#define I2C_SR2_SMBHOST_Pos       (6U)                                         
N#define I2C_SR2_SMBHOST_Msk       (0x1UL << I2C_SR2_SMBHOST_Pos)                /*!< 0x00000040 */
N#define I2C_SR2_SMBHOST           I2C_SR2_SMBHOST_Msk                          /*!<SMBus Host Header (Slave mode)                  */
N#define I2C_SR2_DUALF_Pos         (7U)                                         
N#define I2C_SR2_DUALF_Msk         (0x1UL << I2C_SR2_DUALF_Pos)                  /*!< 0x00000080 */
N#define I2C_SR2_DUALF             I2C_SR2_DUALF_Msk                            /*!<Dual Flag (Slave mode)                          */
N#define I2C_SR2_PEC_Pos           (8U)                                         
N#define I2C_SR2_PEC_Msk           (0xFFUL << I2C_SR2_PEC_Pos)                   /*!< 0x0000FF00 */
N#define I2C_SR2_PEC               I2C_SR2_PEC_Msk                              /*!<Packet Error Checking Register                  */
N
N/*******************  Bit definition for I2C_CCR register  ********************/
N#define I2C_CCR_CCR_Pos           (0U)                                         
N#define I2C_CCR_CCR_Msk           (0xFFFUL << I2C_CCR_CCR_Pos)                  /*!< 0x00000FFF */
N#define I2C_CCR_CCR               I2C_CCR_CCR_Msk                              /*!<Clock Control Register in Fast/Standard mode (Master mode) */
N#define I2C_CCR_DUTY_Pos          (14U)                                        
N#define I2C_CCR_DUTY_Msk          (0x1UL << I2C_CCR_DUTY_Pos)                   /*!< 0x00004000 */
N#define I2C_CCR_DUTY              I2C_CCR_DUTY_Msk                             /*!<Fast Mode Duty Cycle                                       */
N#define I2C_CCR_FS_Pos            (15U)                                        
N#define I2C_CCR_FS_Msk            (0x1UL << I2C_CCR_FS_Pos)                     /*!< 0x00008000 */
N#define I2C_CCR_FS                I2C_CCR_FS_Msk                               /*!<I2C Master Mode Selection                                  */
N
N/******************  Bit definition for I2C_TRISE register  *******************/
N#define I2C_TRISE_TRISE_Pos       (0U)                                         
N#define I2C_TRISE_TRISE_Msk       (0x3FUL << I2C_TRISE_TRISE_Pos)               /*!< 0x0000003F */
N#define I2C_TRISE_TRISE           I2C_TRISE_TRISE_Msk                          /*!<Maximum Rise Time in Fast/Standard mode (Master mode) */
N
N/******************  Bit definition for I2C_FLTR register  *******************/
N#define I2C_FLTR_DNF_Pos          (0U)                                         
N#define I2C_FLTR_DNF_Msk          (0xFUL << I2C_FLTR_DNF_Pos)                   /*!< 0x0000000F */
N#define I2C_FLTR_DNF              I2C_FLTR_DNF_Msk                             /*!<Digital Noise Filter */
N#define I2C_FLTR_ANOFF_Pos        (4U)                                         
N#define I2C_FLTR_ANOFF_Msk        (0x1UL << I2C_FLTR_ANOFF_Pos)                 /*!< 0x00000010 */
N#define I2C_FLTR_ANOFF            I2C_FLTR_ANOFF_Msk                           /*!<Analog Noise Filter OFF */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Independent WATCHDOG                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define IWDG_KR_KEY_Pos     (0U)                                               
N#define IWDG_KR_KEY_Msk     (0xFFFFUL << IWDG_KR_KEY_Pos)                       /*!< 0x0000FFFF */
N#define IWDG_KR_KEY         IWDG_KR_KEY_Msk                                    /*!<Key value (write only, read 0000h)  */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define IWDG_PR_PR_Pos      (0U)                                               
N#define IWDG_PR_PR_Msk      (0x7UL << IWDG_PR_PR_Pos)                           /*!< 0x00000007 */
N#define IWDG_PR_PR          IWDG_PR_PR_Msk                                     /*!<PR[2:0] (Prescaler divider)         */
N#define IWDG_PR_PR_0        (0x1UL << IWDG_PR_PR_Pos)                           /*!< 0x01 */
N#define IWDG_PR_PR_1        (0x2UL << IWDG_PR_PR_Pos)                           /*!< 0x02 */
N#define IWDG_PR_PR_2        (0x4UL << IWDG_PR_PR_Pos)                           /*!< 0x04 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define IWDG_RLR_RL_Pos     (0U)                                               
N#define IWDG_RLR_RL_Msk     (0xFFFUL << IWDG_RLR_RL_Pos)                        /*!< 0x00000FFF */
N#define IWDG_RLR_RL         IWDG_RLR_RL_Msk                                    /*!<Watchdog counter reload value        */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define IWDG_SR_PVU_Pos     (0U)                                               
N#define IWDG_SR_PVU_Msk     (0x1UL << IWDG_SR_PVU_Pos)                          /*!< 0x00000001 */
N#define IWDG_SR_PVU         IWDG_SR_PVU_Msk                                    /*!<Watchdog prescaler value update      */
N#define IWDG_SR_RVU_Pos     (1U)                                               
N#define IWDG_SR_RVU_Msk     (0x1UL << IWDG_SR_RVU_Pos)                          /*!< 0x00000002 */
N#define IWDG_SR_RVU         IWDG_SR_RVU_Msk                                    /*!<Watchdog counter reload value update */
N
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                             Power Control                                  */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWR_CR register  ********************/
N#define PWR_CR_LPDS_Pos        (0U)                                            
N#define PWR_CR_LPDS_Msk        (0x1UL << PWR_CR_LPDS_Pos)                       /*!< 0x00000001 */
N#define PWR_CR_LPDS            PWR_CR_LPDS_Msk                                 /*!< Low-Power Deepsleep                 */
N#define PWR_CR_PDDS_Pos        (1U)                                            
N#define PWR_CR_PDDS_Msk        (0x1UL << PWR_CR_PDDS_Pos)                       /*!< 0x00000002 */
N#define PWR_CR_PDDS            PWR_CR_PDDS_Msk                                 /*!< Power Down Deepsleep                */
N#define PWR_CR_CWUF_Pos        (2U)                                            
N#define PWR_CR_CWUF_Msk        (0x1UL << PWR_CR_CWUF_Pos)                       /*!< 0x00000004 */
N#define PWR_CR_CWUF            PWR_CR_CWUF_Msk                                 /*!< Clear Wakeup Flag                   */
N#define PWR_CR_CSBF_Pos        (3U)                                            
N#define PWR_CR_CSBF_Msk        (0x1UL << PWR_CR_CSBF_Pos)                       /*!< 0x00000008 */
N#define PWR_CR_CSBF            PWR_CR_CSBF_Msk                                 /*!< Clear Standby Flag                  */
N#define PWR_CR_PVDE_Pos        (4U)                                            
N#define PWR_CR_PVDE_Msk        (0x1UL << PWR_CR_PVDE_Pos)                       /*!< 0x00000010 */
N#define PWR_CR_PVDE            PWR_CR_PVDE_Msk                                 /*!< Power Voltage Detector Enable       */
N
N#define PWR_CR_PLS_Pos         (5U)                                            
N#define PWR_CR_PLS_Msk         (0x7UL << PWR_CR_PLS_Pos)                        /*!< 0x000000E0 */
N#define PWR_CR_PLS             PWR_CR_PLS_Msk                                  /*!< PLS[2:0] bits (PVD Level Selection) */
N#define PWR_CR_PLS_0           (0x1UL << PWR_CR_PLS_Pos)                        /*!< 0x00000020 */
N#define PWR_CR_PLS_1           (0x2UL << PWR_CR_PLS_Pos)                        /*!< 0x00000040 */
N#define PWR_CR_PLS_2           (0x4UL << PWR_CR_PLS_Pos)                        /*!< 0x00000080 */
N
N/*!< PVD level configuration */
N#define PWR_CR_PLS_LEV0        0x00000000U                                     /*!< PVD level 0 */
N#define PWR_CR_PLS_LEV1        0x00000020U                                     /*!< PVD level 1 */
N#define PWR_CR_PLS_LEV2        0x00000040U                                     /*!< PVD level 2 */
N#define PWR_CR_PLS_LEV3        0x00000060U                                     /*!< PVD level 3 */
N#define PWR_CR_PLS_LEV4        0x00000080U                                     /*!< PVD level 4 */
N#define PWR_CR_PLS_LEV5        0x000000A0U                                     /*!< PVD level 5 */
N#define PWR_CR_PLS_LEV6        0x000000C0U                                     /*!< PVD level 6 */
N#define PWR_CR_PLS_LEV7        0x000000E0U                                     /*!< PVD level 7 */
N#define PWR_CR_DBP_Pos         (8U)                                            
N#define PWR_CR_DBP_Msk         (0x1UL << PWR_CR_DBP_Pos)                        /*!< 0x00000100 */
N#define PWR_CR_DBP             PWR_CR_DBP_Msk                                  /*!< Disable Backup Domain write protection                     */
N#define PWR_CR_FPDS_Pos        (9U)                                            
N#define PWR_CR_FPDS_Msk        (0x1UL << PWR_CR_FPDS_Pos)                       /*!< 0x00000200 */
N#define PWR_CR_FPDS            PWR_CR_FPDS_Msk                                 /*!< Flash power down in Stop mode                              */
N#define PWR_CR_LPLVDS_Pos      (10U)                                           
N#define PWR_CR_LPLVDS_Msk      (0x1UL << PWR_CR_LPLVDS_Pos)                     /*!< 0x00000400 */
N#define PWR_CR_LPLVDS          PWR_CR_LPLVDS_Msk                               /*!< Low Power Regulator Low Voltage in Deep Sleep mode         */
N#define PWR_CR_MRLVDS_Pos      (11U)                                           
N#define PWR_CR_MRLVDS_Msk      (0x1UL << PWR_CR_MRLVDS_Pos)                     /*!< 0x00000800 */
N#define PWR_CR_MRLVDS          PWR_CR_MRLVDS_Msk                               /*!< Main Regulator Low Voltage in Deep Sleep mode              */
N#define PWR_CR_ADCDC1_Pos      (13U)                                           
N#define PWR_CR_ADCDC1_Msk      (0x1UL << PWR_CR_ADCDC1_Pos)                     /*!< 0x00002000 */
N#define PWR_CR_ADCDC1          PWR_CR_ADCDC1_Msk                               /*!< Refer to AN4073 on how to use this bit                     */ 
N#define PWR_CR_VOS_Pos         (14U)                                           
N#define PWR_CR_VOS_Msk         (0x3UL << PWR_CR_VOS_Pos)                        /*!< 0x0000C000 */
N#define PWR_CR_VOS             PWR_CR_VOS_Msk                                  /*!< VOS[1:0] bits (Regulator voltage scaling output selection) */
N#define PWR_CR_VOS_0           0x00004000U                                     /*!< Bit 0 */
N#define PWR_CR_VOS_1           0x00008000U                                     /*!< Bit 1 */
N
N/* Legacy define */
N#define  PWR_CR_PMODE                        PWR_CR_VOS
N
N/*******************  Bit definition for PWR_CSR register  ********************/
N#define PWR_CSR_WUF_Pos        (0U)                                            
N#define PWR_CSR_WUF_Msk        (0x1UL << PWR_CSR_WUF_Pos)                       /*!< 0x00000001 */
N#define PWR_CSR_WUF            PWR_CSR_WUF_Msk                                 /*!< Wakeup Flag                                      */
N#define PWR_CSR_SBF_Pos        (1U)                                            
N#define PWR_CSR_SBF_Msk        (0x1UL << PWR_CSR_SBF_Pos)                       /*!< 0x00000002 */
N#define PWR_CSR_SBF            PWR_CSR_SBF_Msk                                 /*!< Standby Flag                                     */
N#define PWR_CSR_PVDO_Pos       (2U)                                            
N#define PWR_CSR_PVDO_Msk       (0x1UL << PWR_CSR_PVDO_Pos)                      /*!< 0x00000004 */
N#define PWR_CSR_PVDO           PWR_CSR_PVDO_Msk                                /*!< PVD Output                                       */
N#define PWR_CSR_BRR_Pos        (3U)                                            
N#define PWR_CSR_BRR_Msk        (0x1UL << PWR_CSR_BRR_Pos)                       /*!< 0x00000008 */
N#define PWR_CSR_BRR            PWR_CSR_BRR_Msk                                 /*!< Backup regulator ready                           */
N#define PWR_CSR_EWUP_Pos       (8U)                                            
N#define PWR_CSR_EWUP_Msk       (0x1UL << PWR_CSR_EWUP_Pos)                      /*!< 0x00000100 */
N#define PWR_CSR_EWUP           PWR_CSR_EWUP_Msk                                /*!< Enable WKUP pin                                  */
N#define PWR_CSR_BRE_Pos        (9U)                                            
N#define PWR_CSR_BRE_Msk        (0x1UL << PWR_CSR_BRE_Pos)                       /*!< 0x00000200 */
N#define PWR_CSR_BRE            PWR_CSR_BRE_Msk                                 /*!< Backup regulator enable                          */
N#define PWR_CSR_VOSRDY_Pos     (14U)                                           
N#define PWR_CSR_VOSRDY_Msk     (0x1UL << PWR_CSR_VOSRDY_Pos)                    /*!< 0x00004000 */
N#define PWR_CSR_VOSRDY         PWR_CSR_VOSRDY_Msk                              /*!< Regulator voltage scaling output selection ready */
N
N/* Legacy define */
N#define  PWR_CSR_REGRDY                      PWR_CSR_VOSRDY
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for RCC_CR register  ********************/
N#define RCC_CR_HSION_Pos                   (0U)                                
N#define RCC_CR_HSION_Msk                   (0x1UL << RCC_CR_HSION_Pos)          /*!< 0x00000001 */
N#define RCC_CR_HSION                       RCC_CR_HSION_Msk                    
N#define RCC_CR_HSIRDY_Pos                  (1U)                                
N#define RCC_CR_HSIRDY_Msk                  (0x1UL << RCC_CR_HSIRDY_Pos)         /*!< 0x00000002 */
N#define RCC_CR_HSIRDY                      RCC_CR_HSIRDY_Msk                   
N
N#define RCC_CR_HSITRIM_Pos                 (3U)                                
N#define RCC_CR_HSITRIM_Msk                 (0x1FUL << RCC_CR_HSITRIM_Pos)       /*!< 0x000000F8 */
N#define RCC_CR_HSITRIM                     RCC_CR_HSITRIM_Msk                  
N#define RCC_CR_HSITRIM_0                   (0x01UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000008 */
N#define RCC_CR_HSITRIM_1                   (0x02UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000010 */
N#define RCC_CR_HSITRIM_2                   (0x04UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000020 */
N#define RCC_CR_HSITRIM_3                   (0x08UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000040 */
N#define RCC_CR_HSITRIM_4                   (0x10UL << RCC_CR_HSITRIM_Pos)       /*!< 0x00000080 */
N
N#define RCC_CR_HSICAL_Pos                  (8U)                                
N#define RCC_CR_HSICAL_Msk                  (0xFFUL << RCC_CR_HSICAL_Pos)        /*!< 0x0000FF00 */
N#define RCC_CR_HSICAL                      RCC_CR_HSICAL_Msk                   
N#define RCC_CR_HSICAL_0                    (0x01UL << RCC_CR_HSICAL_Pos)        /*!< 0x00000100 */
N#define RCC_CR_HSICAL_1                    (0x02UL << RCC_CR_HSICAL_Pos)        /*!< 0x00000200 */
N#define RCC_CR_HSICAL_2                    (0x04UL << RCC_CR_HSICAL_Pos)        /*!< 0x00000400 */
N#define RCC_CR_HSICAL_3                    (0x08UL << RCC_CR_HSICAL_Pos)        /*!< 0x00000800 */
N#define RCC_CR_HSICAL_4                    (0x10UL << RCC_CR_HSICAL_Pos)        /*!< 0x00001000 */
N#define RCC_CR_HSICAL_5                    (0x20UL << RCC_CR_HSICAL_Pos)        /*!< 0x00002000 */
N#define RCC_CR_HSICAL_6                    (0x40UL << RCC_CR_HSICAL_Pos)        /*!< 0x00004000 */
N#define RCC_CR_HSICAL_7                    (0x80UL << RCC_CR_HSICAL_Pos)        /*!< 0x00008000 */
N
N#define RCC_CR_HSEON_Pos                   (16U)                               
N#define RCC_CR_HSEON_Msk                   (0x1UL << RCC_CR_HSEON_Pos)          /*!< 0x00010000 */
N#define RCC_CR_HSEON                       RCC_CR_HSEON_Msk                    
N#define RCC_CR_HSERDY_Pos                  (17U)                               
N#define RCC_CR_HSERDY_Msk                  (0x1UL << RCC_CR_HSERDY_Pos)         /*!< 0x00020000 */
N#define RCC_CR_HSERDY                      RCC_CR_HSERDY_Msk                   
N#define RCC_CR_HSEBYP_Pos                  (18U)                               
N#define RCC_CR_HSEBYP_Msk                  (0x1UL << RCC_CR_HSEBYP_Pos)         /*!< 0x00040000 */
N#define RCC_CR_HSEBYP                      RCC_CR_HSEBYP_Msk                   
N#define RCC_CR_CSSON_Pos                   (19U)                               
N#define RCC_CR_CSSON_Msk                   (0x1UL << RCC_CR_CSSON_Pos)          /*!< 0x00080000 */
N#define RCC_CR_CSSON                       RCC_CR_CSSON_Msk                    
N#define RCC_CR_PLLON_Pos                   (24U)                               
N#define RCC_CR_PLLON_Msk                   (0x1UL << RCC_CR_PLLON_Pos)          /*!< 0x01000000 */
N#define RCC_CR_PLLON                       RCC_CR_PLLON_Msk                    
N#define RCC_CR_PLLRDY_Pos                  (25U)                               
N#define RCC_CR_PLLRDY_Msk                  (0x1UL << RCC_CR_PLLRDY_Pos)         /*!< 0x02000000 */
N#define RCC_CR_PLLRDY                      RCC_CR_PLLRDY_Msk                   
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F4 serie)
N */
N#define RCC_PLLI2S_SUPPORT                                                     /*!< Support PLLI2S oscillator */
N
N#define RCC_CR_PLLI2SON_Pos                (26U)                               
N#define RCC_CR_PLLI2SON_Msk                (0x1UL << RCC_CR_PLLI2SON_Pos)       /*!< 0x04000000 */
N#define RCC_CR_PLLI2SON                    RCC_CR_PLLI2SON_Msk                 
N#define RCC_CR_PLLI2SRDY_Pos               (27U)                               
N#define RCC_CR_PLLI2SRDY_Msk               (0x1UL << RCC_CR_PLLI2SRDY_Pos)      /*!< 0x08000000 */
N#define RCC_CR_PLLI2SRDY                   RCC_CR_PLLI2SRDY_Msk                
N
N/********************  Bit definition for RCC_PLLCFGR register  ***************/
N#define RCC_PLLCFGR_PLLM_Pos               (0U)                                
N#define RCC_PLLCFGR_PLLM_Msk               (0x3FUL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x0000003F */
N#define RCC_PLLCFGR_PLLM                   RCC_PLLCFGR_PLLM_Msk                
N#define RCC_PLLCFGR_PLLM_0                 (0x01UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000001 */
N#define RCC_PLLCFGR_PLLM_1                 (0x02UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000002 */
N#define RCC_PLLCFGR_PLLM_2                 (0x04UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000004 */
N#define RCC_PLLCFGR_PLLM_3                 (0x08UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000008 */
N#define RCC_PLLCFGR_PLLM_4                 (0x10UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000010 */
N#define RCC_PLLCFGR_PLLM_5                 (0x20UL << RCC_PLLCFGR_PLLM_Pos)     /*!< 0x00000020 */
N
N#define RCC_PLLCFGR_PLLN_Pos               (6U)                                
N#define RCC_PLLCFGR_PLLN_Msk               (0x1FFUL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00007FC0 */
N#define RCC_PLLCFGR_PLLN                   RCC_PLLCFGR_PLLN_Msk                
N#define RCC_PLLCFGR_PLLN_0                 (0x001UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000040 */
N#define RCC_PLLCFGR_PLLN_1                 (0x002UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000080 */
N#define RCC_PLLCFGR_PLLN_2                 (0x004UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000100 */
N#define RCC_PLLCFGR_PLLN_3                 (0x008UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000200 */
N#define RCC_PLLCFGR_PLLN_4                 (0x010UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000400 */
N#define RCC_PLLCFGR_PLLN_5                 (0x020UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00000800 */
N#define RCC_PLLCFGR_PLLN_6                 (0x040UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00001000 */
N#define RCC_PLLCFGR_PLLN_7                 (0x080UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00002000 */
N#define RCC_PLLCFGR_PLLN_8                 (0x100UL << RCC_PLLCFGR_PLLN_Pos)    /*!< 0x00004000 */
N
N#define RCC_PLLCFGR_PLLP_Pos               (16U)                               
N#define RCC_PLLCFGR_PLLP_Msk               (0x3UL << RCC_PLLCFGR_PLLP_Pos)      /*!< 0x00030000 */
N#define RCC_PLLCFGR_PLLP                   RCC_PLLCFGR_PLLP_Msk                
N#define RCC_PLLCFGR_PLLP_0                 (0x1UL << RCC_PLLCFGR_PLLP_Pos)      /*!< 0x00010000 */
N#define RCC_PLLCFGR_PLLP_1                 (0x2UL << RCC_PLLCFGR_PLLP_Pos)      /*!< 0x00020000 */
N
N#define RCC_PLLCFGR_PLLSRC_Pos             (22U)                               
N#define RCC_PLLCFGR_PLLSRC_Msk             (0x1UL << RCC_PLLCFGR_PLLSRC_Pos)    /*!< 0x00400000 */
N#define RCC_PLLCFGR_PLLSRC                 RCC_PLLCFGR_PLLSRC_Msk              
N#define RCC_PLLCFGR_PLLSRC_HSE_Pos         (22U)                               
N#define RCC_PLLCFGR_PLLSRC_HSE_Msk         (0x1UL << RCC_PLLCFGR_PLLSRC_HSE_Pos) /*!< 0x00400000 */
N#define RCC_PLLCFGR_PLLSRC_HSE             RCC_PLLCFGR_PLLSRC_HSE_Msk          
N#define RCC_PLLCFGR_PLLSRC_HSI             0x00000000U                         
N
N#define RCC_PLLCFGR_PLLQ_Pos               (24U)                               
N#define RCC_PLLCFGR_PLLQ_Msk               (0xFUL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x0F000000 */
N#define RCC_PLLCFGR_PLLQ                   RCC_PLLCFGR_PLLQ_Msk                
N#define RCC_PLLCFGR_PLLQ_0                 (0x1UL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x01000000 */
N#define RCC_PLLCFGR_PLLQ_1                 (0x2UL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x02000000 */
N#define RCC_PLLCFGR_PLLQ_2                 (0x4UL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x04000000 */
N#define RCC_PLLCFGR_PLLQ_3                 (0x8UL << RCC_PLLCFGR_PLLQ_Pos)      /*!< 0x08000000 */
N
N
N/********************  Bit definition for RCC_CFGR register  ******************/
N/*!< SW configuration */
N#define RCC_CFGR_SW_Pos                    (0U)                                
N#define RCC_CFGR_SW_Msk                    (0x3UL << RCC_CFGR_SW_Pos)           /*!< 0x00000003 */
N#define RCC_CFGR_SW                        RCC_CFGR_SW_Msk                     /*!< SW[1:0] bits (System clock Switch) */
N#define RCC_CFGR_SW_0                      (0x1UL << RCC_CFGR_SW_Pos)           /*!< 0x00000001 */
N#define RCC_CFGR_SW_1                      (0x2UL << RCC_CFGR_SW_Pos)           /*!< 0x00000002 */
N
N#define RCC_CFGR_SW_HSI                    0x00000000U                         /*!< HSI selected as system clock */
N#define RCC_CFGR_SW_HSE                    0x00000001U                         /*!< HSE selected as system clock */
N#define RCC_CFGR_SW_PLL                    0x00000002U                         /*!< PLL selected as system clock */
N
N/*!< SWS configuration */
N#define RCC_CFGR_SWS_Pos                   (2U)                                
N#define RCC_CFGR_SWS_Msk                   (0x3UL << RCC_CFGR_SWS_Pos)          /*!< 0x0000000C */
N#define RCC_CFGR_SWS                       RCC_CFGR_SWS_Msk                    /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define RCC_CFGR_SWS_0                     (0x1UL << RCC_CFGR_SWS_Pos)          /*!< 0x00000004 */
N#define RCC_CFGR_SWS_1                     (0x2UL << RCC_CFGR_SWS_Pos)          /*!< 0x00000008 */
N
N#define RCC_CFGR_SWS_HSI                   0x00000000U                         /*!< HSI oscillator used as system clock        */
N#define RCC_CFGR_SWS_HSE                   0x00000004U                         /*!< HSE oscillator used as system clock        */
N#define RCC_CFGR_SWS_PLL                   0x00000008U                         /*!< PLL used as system clock                   */
N
N/*!< HPRE configuration */
N#define RCC_CFGR_HPRE_Pos                  (4U)                                
N#define RCC_CFGR_HPRE_Msk                  (0xFUL << RCC_CFGR_HPRE_Pos)         /*!< 0x000000F0 */
N#define RCC_CFGR_HPRE                      RCC_CFGR_HPRE_Msk                   /*!< HPRE[3:0] bits (AHB prescaler) */
N#define RCC_CFGR_HPRE_0                    (0x1UL << RCC_CFGR_HPRE_Pos)         /*!< 0x00000010 */
N#define RCC_CFGR_HPRE_1                    (0x2UL << RCC_CFGR_HPRE_Pos)         /*!< 0x00000020 */
N#define RCC_CFGR_HPRE_2                    (0x4UL << RCC_CFGR_HPRE_Pos)         /*!< 0x00000040 */
N#define RCC_CFGR_HPRE_3                    (0x8UL << RCC_CFGR_HPRE_Pos)         /*!< 0x00000080 */
N
N#define RCC_CFGR_HPRE_DIV1                 0x00000000U                         /*!< SYSCLK not divided    */
N#define RCC_CFGR_HPRE_DIV2                 0x00000080U                         /*!< SYSCLK divided by 2   */
N#define RCC_CFGR_HPRE_DIV4                 0x00000090U                         /*!< SYSCLK divided by 4   */
N#define RCC_CFGR_HPRE_DIV8                 0x000000A0U                         /*!< SYSCLK divided by 8   */
N#define RCC_CFGR_HPRE_DIV16                0x000000B0U                         /*!< SYSCLK divided by 16  */
N#define RCC_CFGR_HPRE_DIV64                0x000000C0U                         /*!< SYSCLK divided by 64  */
N#define RCC_CFGR_HPRE_DIV128               0x000000D0U                         /*!< SYSCLK divided by 128 */
N#define RCC_CFGR_HPRE_DIV256               0x000000E0U                         /*!< SYSCLK divided by 256 */
N#define RCC_CFGR_HPRE_DIV512               0x000000F0U                         /*!< SYSCLK divided by 512 */
N
N/*!< PPRE1 configuration */
N#define RCC_CFGR_PPRE1_Pos                 (10U)                               
N#define RCC_CFGR_PPRE1_Msk                 (0x7UL << RCC_CFGR_PPRE1_Pos)        /*!< 0x00001C00 */
N#define RCC_CFGR_PPRE1                     RCC_CFGR_PPRE1_Msk                  /*!< PRE1[2:0] bits (APB1 prescaler) */
N#define RCC_CFGR_PPRE1_0                   (0x1UL << RCC_CFGR_PPRE1_Pos)        /*!< 0x00000400 */
N#define RCC_CFGR_PPRE1_1                   (0x2UL << RCC_CFGR_PPRE1_Pos)        /*!< 0x00000800 */
N#define RCC_CFGR_PPRE1_2                   (0x4UL << RCC_CFGR_PPRE1_Pos)        /*!< 0x00001000 */
N
N#define RCC_CFGR_PPRE1_DIV1                0x00000000U                         /*!< HCLK not divided   */
N#define RCC_CFGR_PPRE1_DIV2                0x00001000U                         /*!< HCLK divided by 2  */
N#define RCC_CFGR_PPRE1_DIV4                0x00001400U                         /*!< HCLK divided by 4  */
N#define RCC_CFGR_PPRE1_DIV8                0x00001800U                         /*!< HCLK divided by 8  */
N#define RCC_CFGR_PPRE1_DIV16               0x00001C00U                         /*!< HCLK divided by 16 */
N
N/*!< PPRE2 configuration */
N#define RCC_CFGR_PPRE2_Pos                 (13U)                               
N#define RCC_CFGR_PPRE2_Msk                 (0x7UL << RCC_CFGR_PPRE2_Pos)        /*!< 0x0000E000 */
N#define RCC_CFGR_PPRE2                     RCC_CFGR_PPRE2_Msk                  /*!< PRE2[2:0] bits (APB2 prescaler) */
N#define RCC_CFGR_PPRE2_0                   (0x1UL << RCC_CFGR_PPRE2_Pos)        /*!< 0x00002000 */
N#define RCC_CFGR_PPRE2_1                   (0x2UL << RCC_CFGR_PPRE2_Pos)        /*!< 0x00004000 */
N#define RCC_CFGR_PPRE2_2                   (0x4UL << RCC_CFGR_PPRE2_Pos)        /*!< 0x00008000 */
N
N#define RCC_CFGR_PPRE2_DIV1                0x00000000U                         /*!< HCLK not divided   */
N#define RCC_CFGR_PPRE2_DIV2                0x00008000U                         /*!< HCLK divided by 2  */
N#define RCC_CFGR_PPRE2_DIV4                0x0000A000U                         /*!< HCLK divided by 4  */
N#define RCC_CFGR_PPRE2_DIV8                0x0000C000U                         /*!< HCLK divided by 8  */
N#define RCC_CFGR_PPRE2_DIV16               0x0000E000U                         /*!< HCLK divided by 16 */
N
N/*!< RTCPRE configuration */
N#define RCC_CFGR_RTCPRE_Pos                (16U)                               
N#define RCC_CFGR_RTCPRE_Msk                (0x1FUL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x001F0000 */
N#define RCC_CFGR_RTCPRE                    RCC_CFGR_RTCPRE_Msk                 
N#define RCC_CFGR_RTCPRE_0                  (0x01UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00010000 */
N#define RCC_CFGR_RTCPRE_1                  (0x02UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00020000 */
N#define RCC_CFGR_RTCPRE_2                  (0x04UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00040000 */
N#define RCC_CFGR_RTCPRE_3                  (0x08UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00080000 */
N#define RCC_CFGR_RTCPRE_4                  (0x10UL << RCC_CFGR_RTCPRE_Pos)      /*!< 0x00100000 */
N
N/*!< MCO1 configuration */
N#define RCC_CFGR_MCO1_Pos                  (21U)                               
N#define RCC_CFGR_MCO1_Msk                  (0x3UL << RCC_CFGR_MCO1_Pos)         /*!< 0x00600000 */
N#define RCC_CFGR_MCO1                      RCC_CFGR_MCO1_Msk                   
N#define RCC_CFGR_MCO1_0                    (0x1UL << RCC_CFGR_MCO1_Pos)         /*!< 0x00200000 */
N#define RCC_CFGR_MCO1_1                    (0x2UL << RCC_CFGR_MCO1_Pos)         /*!< 0x00400000 */
N
N#define RCC_CFGR_I2SSRC_Pos                (23U)                               
N#define RCC_CFGR_I2SSRC_Msk                (0x1UL << RCC_CFGR_I2SSRC_Pos)       /*!< 0x00800000 */
N#define RCC_CFGR_I2SSRC                    RCC_CFGR_I2SSRC_Msk                 
N
N#define RCC_CFGR_MCO1PRE_Pos               (24U)                               
N#define RCC_CFGR_MCO1PRE_Msk               (0x7UL << RCC_CFGR_MCO1PRE_Pos)      /*!< 0x07000000 */
N#define RCC_CFGR_MCO1PRE                   RCC_CFGR_MCO1PRE_Msk                
N#define RCC_CFGR_MCO1PRE_0                 (0x1UL << RCC_CFGR_MCO1PRE_Pos)      /*!< 0x01000000 */
N#define RCC_CFGR_MCO1PRE_1                 (0x2UL << RCC_CFGR_MCO1PRE_Pos)      /*!< 0x02000000 */
N#define RCC_CFGR_MCO1PRE_2                 (0x4UL << RCC_CFGR_MCO1PRE_Pos)      /*!< 0x04000000 */
N
N#define RCC_CFGR_MCO2PRE_Pos               (27U)                               
N#define RCC_CFGR_MCO2PRE_Msk               (0x7UL << RCC_CFGR_MCO2PRE_Pos)      /*!< 0x38000000 */
N#define RCC_CFGR_MCO2PRE                   RCC_CFGR_MCO2PRE_Msk                
N#define RCC_CFGR_MCO2PRE_0                 (0x1UL << RCC_CFGR_MCO2PRE_Pos)      /*!< 0x08000000 */
N#define RCC_CFGR_MCO2PRE_1                 (0x2UL << RCC_CFGR_MCO2PRE_Pos)      /*!< 0x10000000 */
N#define RCC_CFGR_MCO2PRE_2                 (0x4UL << RCC_CFGR_MCO2PRE_Pos)      /*!< 0x20000000 */
N
N#define RCC_CFGR_MCO2_Pos                  (30U)                               
N#define RCC_CFGR_MCO2_Msk                  (0x3UL << RCC_CFGR_MCO2_Pos)         /*!< 0xC0000000 */
N#define RCC_CFGR_MCO2                      RCC_CFGR_MCO2_Msk                   
N#define RCC_CFGR_MCO2_0                    (0x1UL << RCC_CFGR_MCO2_Pos)         /*!< 0x40000000 */
N#define RCC_CFGR_MCO2_1                    (0x2UL << RCC_CFGR_MCO2_Pos)         /*!< 0x80000000 */
N
N/********************  Bit definition for RCC_CIR register  *******************/
N#define RCC_CIR_LSIRDYF_Pos                (0U)                                
N#define RCC_CIR_LSIRDYF_Msk                (0x1UL << RCC_CIR_LSIRDYF_Pos)       /*!< 0x00000001 */
N#define RCC_CIR_LSIRDYF                    RCC_CIR_LSIRDYF_Msk                 
N#define RCC_CIR_LSERDYF_Pos                (1U)                                
N#define RCC_CIR_LSERDYF_Msk                (0x1UL << RCC_CIR_LSERDYF_Pos)       /*!< 0x00000002 */
N#define RCC_CIR_LSERDYF                    RCC_CIR_LSERDYF_Msk                 
N#define RCC_CIR_HSIRDYF_Pos                (2U)                                
N#define RCC_CIR_HSIRDYF_Msk                (0x1UL << RCC_CIR_HSIRDYF_Pos)       /*!< 0x00000004 */
N#define RCC_CIR_HSIRDYF                    RCC_CIR_HSIRDYF_Msk                 
N#define RCC_CIR_HSERDYF_Pos                (3U)                                
N#define RCC_CIR_HSERDYF_Msk                (0x1UL << RCC_CIR_HSERDYF_Pos)       /*!< 0x00000008 */
N#define RCC_CIR_HSERDYF                    RCC_CIR_HSERDYF_Msk                 
N#define RCC_CIR_PLLRDYF_Pos                (4U)                                
N#define RCC_CIR_PLLRDYF_Msk                (0x1UL << RCC_CIR_PLLRDYF_Pos)       /*!< 0x00000010 */
N#define RCC_CIR_PLLRDYF                    RCC_CIR_PLLRDYF_Msk                 
N#define RCC_CIR_PLLI2SRDYF_Pos             (5U)                                
N#define RCC_CIR_PLLI2SRDYF_Msk             (0x1UL << RCC_CIR_PLLI2SRDYF_Pos)    /*!< 0x00000020 */
N#define RCC_CIR_PLLI2SRDYF                 RCC_CIR_PLLI2SRDYF_Msk              
N
N#define RCC_CIR_CSSF_Pos                   (7U)                                
N#define RCC_CIR_CSSF_Msk                   (0x1UL << RCC_CIR_CSSF_Pos)          /*!< 0x00000080 */
N#define RCC_CIR_CSSF                       RCC_CIR_CSSF_Msk                    
N#define RCC_CIR_LSIRDYIE_Pos               (8U)                                
N#define RCC_CIR_LSIRDYIE_Msk               (0x1UL << RCC_CIR_LSIRDYIE_Pos)      /*!< 0x00000100 */
N#define RCC_CIR_LSIRDYIE                   RCC_CIR_LSIRDYIE_Msk                
N#define RCC_CIR_LSERDYIE_Pos               (9U)                                
N#define RCC_CIR_LSERDYIE_Msk               (0x1UL << RCC_CIR_LSERDYIE_Pos)      /*!< 0x00000200 */
N#define RCC_CIR_LSERDYIE                   RCC_CIR_LSERDYIE_Msk                
N#define RCC_CIR_HSIRDYIE_Pos               (10U)                               
N#define RCC_CIR_HSIRDYIE_Msk               (0x1UL << RCC_CIR_HSIRDYIE_Pos)      /*!< 0x00000400 */
N#define RCC_CIR_HSIRDYIE                   RCC_CIR_HSIRDYIE_Msk                
N#define RCC_CIR_HSERDYIE_Pos               (11U)                               
N#define RCC_CIR_HSERDYIE_Msk               (0x1UL << RCC_CIR_HSERDYIE_Pos)      /*!< 0x00000800 */
N#define RCC_CIR_HSERDYIE                   RCC_CIR_HSERDYIE_Msk                
N#define RCC_CIR_PLLRDYIE_Pos               (12U)                               
N#define RCC_CIR_PLLRDYIE_Msk               (0x1UL << RCC_CIR_PLLRDYIE_Pos)      /*!< 0x00001000 */
N#define RCC_CIR_PLLRDYIE                   RCC_CIR_PLLRDYIE_Msk                
N#define RCC_CIR_PLLI2SRDYIE_Pos            (13U)                               
N#define RCC_CIR_PLLI2SRDYIE_Msk            (0x1UL << RCC_CIR_PLLI2SRDYIE_Pos)   /*!< 0x00002000 */
N#define RCC_CIR_PLLI2SRDYIE                RCC_CIR_PLLI2SRDYIE_Msk             
N
N#define RCC_CIR_LSIRDYC_Pos                (16U)                               
N#define RCC_CIR_LSIRDYC_Msk                (0x1UL << RCC_CIR_LSIRDYC_Pos)       /*!< 0x00010000 */
N#define RCC_CIR_LSIRDYC                    RCC_CIR_LSIRDYC_Msk                 
N#define RCC_CIR_LSERDYC_Pos                (17U)                               
N#define RCC_CIR_LSERDYC_Msk                (0x1UL << RCC_CIR_LSERDYC_Pos)       /*!< 0x00020000 */
N#define RCC_CIR_LSERDYC                    RCC_CIR_LSERDYC_Msk                 
N#define RCC_CIR_HSIRDYC_Pos                (18U)                               
N#define RCC_CIR_HSIRDYC_Msk                (0x1UL << RCC_CIR_HSIRDYC_Pos)       /*!< 0x00040000 */
N#define RCC_CIR_HSIRDYC                    RCC_CIR_HSIRDYC_Msk                 
N#define RCC_CIR_HSERDYC_Pos                (19U)                               
N#define RCC_CIR_HSERDYC_Msk                (0x1UL << RCC_CIR_HSERDYC_Pos)       /*!< 0x00080000 */
N#define RCC_CIR_HSERDYC                    RCC_CIR_HSERDYC_Msk                 
N#define RCC_CIR_PLLRDYC_Pos                (20U)                               
N#define RCC_CIR_PLLRDYC_Msk                (0x1UL << RCC_CIR_PLLRDYC_Pos)       /*!< 0x00100000 */
N#define RCC_CIR_PLLRDYC                    RCC_CIR_PLLRDYC_Msk                 
N#define RCC_CIR_PLLI2SRDYC_Pos             (21U)                               
N#define RCC_CIR_PLLI2SRDYC_Msk             (0x1UL << RCC_CIR_PLLI2SRDYC_Pos)    /*!< 0x00200000 */
N#define RCC_CIR_PLLI2SRDYC                 RCC_CIR_PLLI2SRDYC_Msk              
N
N#define RCC_CIR_CSSC_Pos                   (23U)                               
N#define RCC_CIR_CSSC_Msk                   (0x1UL << RCC_CIR_CSSC_Pos)          /*!< 0x00800000 */
N#define RCC_CIR_CSSC                       RCC_CIR_CSSC_Msk                    
N
N/********************  Bit definition for RCC_AHB1RSTR register  **************/
N#define RCC_AHB1RSTR_GPIOARST_Pos          (0U)                                
N#define RCC_AHB1RSTR_GPIOARST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOARST_Pos) /*!< 0x00000001 */
N#define RCC_AHB1RSTR_GPIOARST              RCC_AHB1RSTR_GPIOARST_Msk           
N#define RCC_AHB1RSTR_GPIOBRST_Pos          (1U)                                
N#define RCC_AHB1RSTR_GPIOBRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOBRST_Pos) /*!< 0x00000002 */
N#define RCC_AHB1RSTR_GPIOBRST              RCC_AHB1RSTR_GPIOBRST_Msk           
N#define RCC_AHB1RSTR_GPIOCRST_Pos          (2U)                                
N#define RCC_AHB1RSTR_GPIOCRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOCRST_Pos) /*!< 0x00000004 */
N#define RCC_AHB1RSTR_GPIOCRST              RCC_AHB1RSTR_GPIOCRST_Msk           
N#define RCC_AHB1RSTR_GPIODRST_Pos          (3U)                                
N#define RCC_AHB1RSTR_GPIODRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIODRST_Pos) /*!< 0x00000008 */
N#define RCC_AHB1RSTR_GPIODRST              RCC_AHB1RSTR_GPIODRST_Msk           
N#define RCC_AHB1RSTR_GPIOERST_Pos          (4U)                                
N#define RCC_AHB1RSTR_GPIOERST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOERST_Pos) /*!< 0x00000010 */
N#define RCC_AHB1RSTR_GPIOERST              RCC_AHB1RSTR_GPIOERST_Msk           
N#define RCC_AHB1RSTR_GPIOHRST_Pos          (7U)                                
N#define RCC_AHB1RSTR_GPIOHRST_Msk          (0x1UL << RCC_AHB1RSTR_GPIOHRST_Pos) /*!< 0x00000080 */
N#define RCC_AHB1RSTR_GPIOHRST              RCC_AHB1RSTR_GPIOHRST_Msk           
N#define RCC_AHB1RSTR_CRCRST_Pos            (12U)                               
N#define RCC_AHB1RSTR_CRCRST_Msk            (0x1UL << RCC_AHB1RSTR_CRCRST_Pos)   /*!< 0x00001000 */
N#define RCC_AHB1RSTR_CRCRST                RCC_AHB1RSTR_CRCRST_Msk             
N#define RCC_AHB1RSTR_DMA1RST_Pos           (21U)                               
N#define RCC_AHB1RSTR_DMA1RST_Msk           (0x1UL << RCC_AHB1RSTR_DMA1RST_Pos)  /*!< 0x00200000 */
N#define RCC_AHB1RSTR_DMA1RST               RCC_AHB1RSTR_DMA1RST_Msk            
N#define RCC_AHB1RSTR_DMA2RST_Pos           (22U)                               
N#define RCC_AHB1RSTR_DMA2RST_Msk           (0x1UL << RCC_AHB1RSTR_DMA2RST_Pos)  /*!< 0x00400000 */
N#define RCC_AHB1RSTR_DMA2RST               RCC_AHB1RSTR_DMA2RST_Msk            
N
N/********************  Bit definition for RCC_AHB2RSTR register  **************/
N#define RCC_AHB2RSTR_OTGFSRST_Pos          (7U)                                
N#define RCC_AHB2RSTR_OTGFSRST_Msk          (0x1UL << RCC_AHB2RSTR_OTGFSRST_Pos) /*!< 0x00000080 */
N#define RCC_AHB2RSTR_OTGFSRST              RCC_AHB2RSTR_OTGFSRST_Msk           
N/********************  Bit definition for RCC_AHB3RSTR register  **************/
N
N
N/********************  Bit definition for RCC_APB1RSTR register  **************/
N#define RCC_APB1RSTR_TIM2RST_Pos           (0U)                                
N#define RCC_APB1RSTR_TIM2RST_Msk           (0x1UL << RCC_APB1RSTR_TIM2RST_Pos)  /*!< 0x00000001 */
N#define RCC_APB1RSTR_TIM2RST               RCC_APB1RSTR_TIM2RST_Msk            
N#define RCC_APB1RSTR_TIM3RST_Pos           (1U)                                
N#define RCC_APB1RSTR_TIM3RST_Msk           (0x1UL << RCC_APB1RSTR_TIM3RST_Pos)  /*!< 0x00000002 */
N#define RCC_APB1RSTR_TIM3RST               RCC_APB1RSTR_TIM3RST_Msk            
N#define RCC_APB1RSTR_TIM4RST_Pos           (2U)                                
N#define RCC_APB1RSTR_TIM4RST_Msk           (0x1UL << RCC_APB1RSTR_TIM4RST_Pos)  /*!< 0x00000004 */
N#define RCC_APB1RSTR_TIM4RST               RCC_APB1RSTR_TIM4RST_Msk            
N#define RCC_APB1RSTR_TIM5RST_Pos           (3U)                                
N#define RCC_APB1RSTR_TIM5RST_Msk           (0x1UL << RCC_APB1RSTR_TIM5RST_Pos)  /*!< 0x00000008 */
N#define RCC_APB1RSTR_TIM5RST               RCC_APB1RSTR_TIM5RST_Msk            
N#define RCC_APB1RSTR_WWDGRST_Pos           (11U)                               
N#define RCC_APB1RSTR_WWDGRST_Msk           (0x1UL << RCC_APB1RSTR_WWDGRST_Pos)  /*!< 0x00000800 */
N#define RCC_APB1RSTR_WWDGRST               RCC_APB1RSTR_WWDGRST_Msk            
N#define RCC_APB1RSTR_SPI2RST_Pos           (14U)                               
N#define RCC_APB1RSTR_SPI2RST_Msk           (0x1UL << RCC_APB1RSTR_SPI2RST_Pos)  /*!< 0x00004000 */
N#define RCC_APB1RSTR_SPI2RST               RCC_APB1RSTR_SPI2RST_Msk            
N#define RCC_APB1RSTR_SPI3RST_Pos           (15U)                               
N#define RCC_APB1RSTR_SPI3RST_Msk           (0x1UL << RCC_APB1RSTR_SPI3RST_Pos)  /*!< 0x00008000 */
N#define RCC_APB1RSTR_SPI3RST               RCC_APB1RSTR_SPI3RST_Msk            
N#define RCC_APB1RSTR_USART2RST_Pos         (17U)                               
N#define RCC_APB1RSTR_USART2RST_Msk         (0x1UL << RCC_APB1RSTR_USART2RST_Pos) /*!< 0x00020000 */
N#define RCC_APB1RSTR_USART2RST             RCC_APB1RSTR_USART2RST_Msk          
N#define RCC_APB1RSTR_I2C1RST_Pos           (21U)                               
N#define RCC_APB1RSTR_I2C1RST_Msk           (0x1UL << RCC_APB1RSTR_I2C1RST_Pos)  /*!< 0x00200000 */
N#define RCC_APB1RSTR_I2C1RST               RCC_APB1RSTR_I2C1RST_Msk            
N#define RCC_APB1RSTR_I2C2RST_Pos           (22U)                               
N#define RCC_APB1RSTR_I2C2RST_Msk           (0x1UL << RCC_APB1RSTR_I2C2RST_Pos)  /*!< 0x00400000 */
N#define RCC_APB1RSTR_I2C2RST               RCC_APB1RSTR_I2C2RST_Msk            
N#define RCC_APB1RSTR_I2C3RST_Pos           (23U)                               
N#define RCC_APB1RSTR_I2C3RST_Msk           (0x1UL << RCC_APB1RSTR_I2C3RST_Pos)  /*!< 0x00800000 */
N#define RCC_APB1RSTR_I2C3RST               RCC_APB1RSTR_I2C3RST_Msk            
N#define RCC_APB1RSTR_PWRRST_Pos            (28U)                               
N#define RCC_APB1RSTR_PWRRST_Msk            (0x1UL << RCC_APB1RSTR_PWRRST_Pos)   /*!< 0x10000000 */
N#define RCC_APB1RSTR_PWRRST                RCC_APB1RSTR_PWRRST_Msk             
N
N/********************  Bit definition for RCC_APB2RSTR register  **************/
N#define RCC_APB2RSTR_TIM1RST_Pos           (0U)                                
N#define RCC_APB2RSTR_TIM1RST_Msk           (0x1UL << RCC_APB2RSTR_TIM1RST_Pos)  /*!< 0x00000001 */
N#define RCC_APB2RSTR_TIM1RST               RCC_APB2RSTR_TIM1RST_Msk            
N#define RCC_APB2RSTR_USART1RST_Pos         (4U)                                
N#define RCC_APB2RSTR_USART1RST_Msk         (0x1UL << RCC_APB2RSTR_USART1RST_Pos) /*!< 0x00000010 */
N#define RCC_APB2RSTR_USART1RST             RCC_APB2RSTR_USART1RST_Msk          
N#define RCC_APB2RSTR_USART6RST_Pos         (5U)                                
N#define RCC_APB2RSTR_USART6RST_Msk         (0x1UL << RCC_APB2RSTR_USART6RST_Pos) /*!< 0x00000020 */
N#define RCC_APB2RSTR_USART6RST             RCC_APB2RSTR_USART6RST_Msk          
N#define RCC_APB2RSTR_ADCRST_Pos            (8U)                                
N#define RCC_APB2RSTR_ADCRST_Msk            (0x1UL << RCC_APB2RSTR_ADCRST_Pos)   /*!< 0x00000100 */
N#define RCC_APB2RSTR_ADCRST                RCC_APB2RSTR_ADCRST_Msk             
N#define RCC_APB2RSTR_SDIORST_Pos           (11U)                               
N#define RCC_APB2RSTR_SDIORST_Msk           (0x1UL << RCC_APB2RSTR_SDIORST_Pos)  /*!< 0x00000800 */
N#define RCC_APB2RSTR_SDIORST               RCC_APB2RSTR_SDIORST_Msk            
N#define RCC_APB2RSTR_SPI1RST_Pos           (12U)                               
N#define RCC_APB2RSTR_SPI1RST_Msk           (0x1UL << RCC_APB2RSTR_SPI1RST_Pos)  /*!< 0x00001000 */
N#define RCC_APB2RSTR_SPI1RST               RCC_APB2RSTR_SPI1RST_Msk            
N#define RCC_APB2RSTR_SPI4RST_Pos           (13U)                               
N#define RCC_APB2RSTR_SPI4RST_Msk           (0x1UL << RCC_APB2RSTR_SPI4RST_Pos)  /*!< 0x00002000 */
N#define RCC_APB2RSTR_SPI4RST               RCC_APB2RSTR_SPI4RST_Msk            
N#define RCC_APB2RSTR_SYSCFGRST_Pos         (14U)                               
N#define RCC_APB2RSTR_SYSCFGRST_Msk         (0x1UL << RCC_APB2RSTR_SYSCFGRST_Pos) /*!< 0x00004000 */
N#define RCC_APB2RSTR_SYSCFGRST             RCC_APB2RSTR_SYSCFGRST_Msk          
N#define RCC_APB2RSTR_TIM9RST_Pos           (16U)                               
N#define RCC_APB2RSTR_TIM9RST_Msk           (0x1UL << RCC_APB2RSTR_TIM9RST_Pos)  /*!< 0x00010000 */
N#define RCC_APB2RSTR_TIM9RST               RCC_APB2RSTR_TIM9RST_Msk            
N#define RCC_APB2RSTR_TIM10RST_Pos          (17U)                               
N#define RCC_APB2RSTR_TIM10RST_Msk          (0x1UL << RCC_APB2RSTR_TIM10RST_Pos) /*!< 0x00020000 */
N#define RCC_APB2RSTR_TIM10RST              RCC_APB2RSTR_TIM10RST_Msk           
N#define RCC_APB2RSTR_TIM11RST_Pos          (18U)                               
N#define RCC_APB2RSTR_TIM11RST_Msk          (0x1UL << RCC_APB2RSTR_TIM11RST_Pos) /*!< 0x00040000 */
N#define RCC_APB2RSTR_TIM11RST              RCC_APB2RSTR_TIM11RST_Msk           
N
N/* Old SPI1RST bit definition, maintained for legacy purpose */
N#define  RCC_APB2RSTR_SPI1                   RCC_APB2RSTR_SPI1RST
N
N/********************  Bit definition for RCC_AHB1ENR register  ***************/
N#define RCC_AHB1ENR_GPIOAEN_Pos            (0U)                                
N#define RCC_AHB1ENR_GPIOAEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOAEN_Pos)   /*!< 0x00000001 */
N#define RCC_AHB1ENR_GPIOAEN                RCC_AHB1ENR_GPIOAEN_Msk             
N#define RCC_AHB1ENR_GPIOBEN_Pos            (1U)                                
N#define RCC_AHB1ENR_GPIOBEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOBEN_Pos)   /*!< 0x00000002 */
N#define RCC_AHB1ENR_GPIOBEN                RCC_AHB1ENR_GPIOBEN_Msk             
N#define RCC_AHB1ENR_GPIOCEN_Pos            (2U)                                
N#define RCC_AHB1ENR_GPIOCEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOCEN_Pos)   /*!< 0x00000004 */
N#define RCC_AHB1ENR_GPIOCEN                RCC_AHB1ENR_GPIOCEN_Msk             
N#define RCC_AHB1ENR_GPIODEN_Pos            (3U)                                
N#define RCC_AHB1ENR_GPIODEN_Msk            (0x1UL << RCC_AHB1ENR_GPIODEN_Pos)   /*!< 0x00000008 */
N#define RCC_AHB1ENR_GPIODEN                RCC_AHB1ENR_GPIODEN_Msk             
N#define RCC_AHB1ENR_GPIOEEN_Pos            (4U)                                
N#define RCC_AHB1ENR_GPIOEEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOEEN_Pos)   /*!< 0x00000010 */
N#define RCC_AHB1ENR_GPIOEEN                RCC_AHB1ENR_GPIOEEN_Msk             
N#define RCC_AHB1ENR_GPIOHEN_Pos            (7U)                                
N#define RCC_AHB1ENR_GPIOHEN_Msk            (0x1UL << RCC_AHB1ENR_GPIOHEN_Pos)   /*!< 0x00000080 */
N#define RCC_AHB1ENR_GPIOHEN                RCC_AHB1ENR_GPIOHEN_Msk             
N#define RCC_AHB1ENR_CRCEN_Pos              (12U)                               
N#define RCC_AHB1ENR_CRCEN_Msk              (0x1UL << RCC_AHB1ENR_CRCEN_Pos)     /*!< 0x00001000 */
N#define RCC_AHB1ENR_CRCEN                  RCC_AHB1ENR_CRCEN_Msk               
N#define RCC_AHB1ENR_DMA1EN_Pos             (21U)                               
N#define RCC_AHB1ENR_DMA1EN_Msk             (0x1UL << RCC_AHB1ENR_DMA1EN_Pos)    /*!< 0x00200000 */
N#define RCC_AHB1ENR_DMA1EN                 RCC_AHB1ENR_DMA1EN_Msk              
N#define RCC_AHB1ENR_DMA2EN_Pos             (22U)                               
N#define RCC_AHB1ENR_DMA2EN_Msk             (0x1UL << RCC_AHB1ENR_DMA2EN_Pos)    /*!< 0x00400000 */
N#define RCC_AHB1ENR_DMA2EN                 RCC_AHB1ENR_DMA2EN_Msk              
N/********************  Bit definition for RCC_AHB2ENR register  ***************/
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F4 serie)
N */
N#define RCC_AHB2_SUPPORT                   /*!< AHB2 Bus is supported */
N
N#define RCC_AHB2ENR_OTGFSEN_Pos            (7U)                                
N#define RCC_AHB2ENR_OTGFSEN_Msk            (0x1UL << RCC_AHB2ENR_OTGFSEN_Pos)   /*!< 0x00000080 */
N#define RCC_AHB2ENR_OTGFSEN                RCC_AHB2ENR_OTGFSEN_Msk             
N
N/********************  Bit definition for RCC_APB1ENR register  ***************/
N#define RCC_APB1ENR_TIM2EN_Pos             (0U)                                
N#define RCC_APB1ENR_TIM2EN_Msk             (0x1UL << RCC_APB1ENR_TIM2EN_Pos)    /*!< 0x00000001 */
N#define RCC_APB1ENR_TIM2EN                 RCC_APB1ENR_TIM2EN_Msk              
N#define RCC_APB1ENR_TIM3EN_Pos             (1U)                                
N#define RCC_APB1ENR_TIM3EN_Msk             (0x1UL << RCC_APB1ENR_TIM3EN_Pos)    /*!< 0x00000002 */
N#define RCC_APB1ENR_TIM3EN                 RCC_APB1ENR_TIM3EN_Msk              
N#define RCC_APB1ENR_TIM4EN_Pos             (2U)                                
N#define RCC_APB1ENR_TIM4EN_Msk             (0x1UL << RCC_APB1ENR_TIM4EN_Pos)    /*!< 0x00000004 */
N#define RCC_APB1ENR_TIM4EN                 RCC_APB1ENR_TIM4EN_Msk              
N#define RCC_APB1ENR_TIM5EN_Pos             (3U)                                
N#define RCC_APB1ENR_TIM5EN_Msk             (0x1UL << RCC_APB1ENR_TIM5EN_Pos)    /*!< 0x00000008 */
N#define RCC_APB1ENR_TIM5EN                 RCC_APB1ENR_TIM5EN_Msk              
N#define RCC_APB1ENR_WWDGEN_Pos             (11U)                               
N#define RCC_APB1ENR_WWDGEN_Msk             (0x1UL << RCC_APB1ENR_WWDGEN_Pos)    /*!< 0x00000800 */
N#define RCC_APB1ENR_WWDGEN                 RCC_APB1ENR_WWDGEN_Msk              
N#define RCC_APB1ENR_SPI2EN_Pos             (14U)                               
N#define RCC_APB1ENR_SPI2EN_Msk             (0x1UL << RCC_APB1ENR_SPI2EN_Pos)    /*!< 0x00004000 */
N#define RCC_APB1ENR_SPI2EN                 RCC_APB1ENR_SPI2EN_Msk              
N#define RCC_APB1ENR_SPI3EN_Pos             (15U)                               
N#define RCC_APB1ENR_SPI3EN_Msk             (0x1UL << RCC_APB1ENR_SPI3EN_Pos)    /*!< 0x00008000 */
N#define RCC_APB1ENR_SPI3EN                 RCC_APB1ENR_SPI3EN_Msk              
N#define RCC_APB1ENR_USART2EN_Pos           (17U)                               
N#define RCC_APB1ENR_USART2EN_Msk           (0x1UL << RCC_APB1ENR_USART2EN_Pos)  /*!< 0x00020000 */
N#define RCC_APB1ENR_USART2EN               RCC_APB1ENR_USART2EN_Msk            
N#define RCC_APB1ENR_I2C1EN_Pos             (21U)                               
N#define RCC_APB1ENR_I2C1EN_Msk             (0x1UL << RCC_APB1ENR_I2C1EN_Pos)    /*!< 0x00200000 */
N#define RCC_APB1ENR_I2C1EN                 RCC_APB1ENR_I2C1EN_Msk              
N#define RCC_APB1ENR_I2C2EN_Pos             (22U)                               
N#define RCC_APB1ENR_I2C2EN_Msk             (0x1UL << RCC_APB1ENR_I2C2EN_Pos)    /*!< 0x00400000 */
N#define RCC_APB1ENR_I2C2EN                 RCC_APB1ENR_I2C2EN_Msk              
N#define RCC_APB1ENR_I2C3EN_Pos             (23U)                               
N#define RCC_APB1ENR_I2C3EN_Msk             (0x1UL << RCC_APB1ENR_I2C3EN_Pos)    /*!< 0x00800000 */
N#define RCC_APB1ENR_I2C3EN                 RCC_APB1ENR_I2C3EN_Msk              
N#define RCC_APB1ENR_PWREN_Pos              (28U)                               
N#define RCC_APB1ENR_PWREN_Msk              (0x1UL << RCC_APB1ENR_PWREN_Pos)     /*!< 0x10000000 */
N#define RCC_APB1ENR_PWREN                  RCC_APB1ENR_PWREN_Msk               
N
N/********************  Bit definition for RCC_APB2ENR register  ***************/
N#define RCC_APB2ENR_TIM1EN_Pos             (0U)                                
N#define RCC_APB2ENR_TIM1EN_Msk             (0x1UL << RCC_APB2ENR_TIM1EN_Pos)    /*!< 0x00000001 */
N#define RCC_APB2ENR_TIM1EN                 RCC_APB2ENR_TIM1EN_Msk              
N#define RCC_APB2ENR_USART1EN_Pos           (4U)                                
N#define RCC_APB2ENR_USART1EN_Msk           (0x1UL << RCC_APB2ENR_USART1EN_Pos)  /*!< 0x00000010 */
N#define RCC_APB2ENR_USART1EN               RCC_APB2ENR_USART1EN_Msk            
N#define RCC_APB2ENR_USART6EN_Pos           (5U)                                
N#define RCC_APB2ENR_USART6EN_Msk           (0x1UL << RCC_APB2ENR_USART6EN_Pos)  /*!< 0x00000020 */
N#define RCC_APB2ENR_USART6EN               RCC_APB2ENR_USART6EN_Msk            
N#define RCC_APB2ENR_ADC1EN_Pos             (8U)                                
N#define RCC_APB2ENR_ADC1EN_Msk             (0x1UL << RCC_APB2ENR_ADC1EN_Pos)    /*!< 0x00000100 */
N#define RCC_APB2ENR_ADC1EN                 RCC_APB2ENR_ADC1EN_Msk              
N#define RCC_APB2ENR_SDIOEN_Pos             (11U)                               
N#define RCC_APB2ENR_SDIOEN_Msk             (0x1UL << RCC_APB2ENR_SDIOEN_Pos)    /*!< 0x00000800 */
N#define RCC_APB2ENR_SDIOEN                 RCC_APB2ENR_SDIOEN_Msk              
N#define RCC_APB2ENR_SPI1EN_Pos             (12U)                               
N#define RCC_APB2ENR_SPI1EN_Msk             (0x1UL << RCC_APB2ENR_SPI1EN_Pos)    /*!< 0x00001000 */
N#define RCC_APB2ENR_SPI1EN                 RCC_APB2ENR_SPI1EN_Msk              
N#define RCC_APB2ENR_SPI4EN_Pos             (13U)                               
N#define RCC_APB2ENR_SPI4EN_Msk             (0x1UL << RCC_APB2ENR_SPI4EN_Pos)    /*!< 0x00002000 */
N#define RCC_APB2ENR_SPI4EN                 RCC_APB2ENR_SPI4EN_Msk              
N#define RCC_APB2ENR_SYSCFGEN_Pos           (14U)                               
N#define RCC_APB2ENR_SYSCFGEN_Msk           (0x1UL << RCC_APB2ENR_SYSCFGEN_Pos)  /*!< 0x00004000 */
N#define RCC_APB2ENR_SYSCFGEN               RCC_APB2ENR_SYSCFGEN_Msk            
N#define RCC_APB2ENR_TIM9EN_Pos             (16U)                               
N#define RCC_APB2ENR_TIM9EN_Msk             (0x1UL << RCC_APB2ENR_TIM9EN_Pos)    /*!< 0x00010000 */
N#define RCC_APB2ENR_TIM9EN                 RCC_APB2ENR_TIM9EN_Msk              
N#define RCC_APB2ENR_TIM10EN_Pos            (17U)                               
N#define RCC_APB2ENR_TIM10EN_Msk            (0x1UL << RCC_APB2ENR_TIM10EN_Pos)   /*!< 0x00020000 */
N#define RCC_APB2ENR_TIM10EN                RCC_APB2ENR_TIM10EN_Msk             
N#define RCC_APB2ENR_TIM11EN_Pos            (18U)                               
N#define RCC_APB2ENR_TIM11EN_Msk            (0x1UL << RCC_APB2ENR_TIM11EN_Pos)   /*!< 0x00040000 */
N#define RCC_APB2ENR_TIM11EN                RCC_APB2ENR_TIM11EN_Msk             
N
N/********************  Bit definition for RCC_AHB1LPENR register  *************/
N#define RCC_AHB1LPENR_GPIOALPEN_Pos        (0U)                                
N#define RCC_AHB1LPENR_GPIOALPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOALPEN_Pos) /*!< 0x00000001 */
N#define RCC_AHB1LPENR_GPIOALPEN            RCC_AHB1LPENR_GPIOALPEN_Msk         
N#define RCC_AHB1LPENR_GPIOBLPEN_Pos        (1U)                                
N#define RCC_AHB1LPENR_GPIOBLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOBLPEN_Pos) /*!< 0x00000002 */
N#define RCC_AHB1LPENR_GPIOBLPEN            RCC_AHB1LPENR_GPIOBLPEN_Msk         
N#define RCC_AHB1LPENR_GPIOCLPEN_Pos        (2U)                                
N#define RCC_AHB1LPENR_GPIOCLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOCLPEN_Pos) /*!< 0x00000004 */
N#define RCC_AHB1LPENR_GPIOCLPEN            RCC_AHB1LPENR_GPIOCLPEN_Msk         
N#define RCC_AHB1LPENR_GPIODLPEN_Pos        (3U)                                
N#define RCC_AHB1LPENR_GPIODLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIODLPEN_Pos) /*!< 0x00000008 */
N#define RCC_AHB1LPENR_GPIODLPEN            RCC_AHB1LPENR_GPIODLPEN_Msk         
N#define RCC_AHB1LPENR_GPIOELPEN_Pos        (4U)                                
N#define RCC_AHB1LPENR_GPIOELPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOELPEN_Pos) /*!< 0x00000010 */
N#define RCC_AHB1LPENR_GPIOELPEN            RCC_AHB1LPENR_GPIOELPEN_Msk         
N#define RCC_AHB1LPENR_GPIOHLPEN_Pos        (7U)                                
N#define RCC_AHB1LPENR_GPIOHLPEN_Msk        (0x1UL << RCC_AHB1LPENR_GPIOHLPEN_Pos) /*!< 0x00000080 */
N#define RCC_AHB1LPENR_GPIOHLPEN            RCC_AHB1LPENR_GPIOHLPEN_Msk         
N#define RCC_AHB1LPENR_CRCLPEN_Pos          (12U)                               
N#define RCC_AHB1LPENR_CRCLPEN_Msk          (0x1UL << RCC_AHB1LPENR_CRCLPEN_Pos) /*!< 0x00001000 */
N#define RCC_AHB1LPENR_CRCLPEN              RCC_AHB1LPENR_CRCLPEN_Msk           
N#define RCC_AHB1LPENR_FLITFLPEN_Pos        (15U)                               
N#define RCC_AHB1LPENR_FLITFLPEN_Msk        (0x1UL << RCC_AHB1LPENR_FLITFLPEN_Pos) /*!< 0x00008000 */
N#define RCC_AHB1LPENR_FLITFLPEN            RCC_AHB1LPENR_FLITFLPEN_Msk         
N#define RCC_AHB1LPENR_SRAM1LPEN_Pos        (16U)                               
N#define RCC_AHB1LPENR_SRAM1LPEN_Msk        (0x1UL << RCC_AHB1LPENR_SRAM1LPEN_Pos) /*!< 0x00010000 */
N#define RCC_AHB1LPENR_SRAM1LPEN            RCC_AHB1LPENR_SRAM1LPEN_Msk         
N#define RCC_AHB1LPENR_DMA1LPEN_Pos         (21U)                               
N#define RCC_AHB1LPENR_DMA1LPEN_Msk         (0x1UL << RCC_AHB1LPENR_DMA1LPEN_Pos) /*!< 0x00200000 */
N#define RCC_AHB1LPENR_DMA1LPEN             RCC_AHB1LPENR_DMA1LPEN_Msk          
N#define RCC_AHB1LPENR_DMA2LPEN_Pos         (22U)                               
N#define RCC_AHB1LPENR_DMA2LPEN_Msk         (0x1UL << RCC_AHB1LPENR_DMA2LPEN_Pos) /*!< 0x00400000 */
N#define RCC_AHB1LPENR_DMA2LPEN             RCC_AHB1LPENR_DMA2LPEN_Msk          
N
N
N/********************  Bit definition for RCC_AHB2LPENR register  *************/
N#define RCC_AHB2LPENR_OTGFSLPEN_Pos        (7U)                                
N#define RCC_AHB2LPENR_OTGFSLPEN_Msk        (0x1UL << RCC_AHB2LPENR_OTGFSLPEN_Pos) /*!< 0x00000080 */
N#define RCC_AHB2LPENR_OTGFSLPEN            RCC_AHB2LPENR_OTGFSLPEN_Msk         
N
N/********************  Bit definition for RCC_AHB3LPENR register  *************/
N
N/********************  Bit definition for RCC_APB1LPENR register  *************/
N#define RCC_APB1LPENR_TIM2LPEN_Pos         (0U)                                
N#define RCC_APB1LPENR_TIM2LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM2LPEN_Pos) /*!< 0x00000001 */
N#define RCC_APB1LPENR_TIM2LPEN             RCC_APB1LPENR_TIM2LPEN_Msk          
N#define RCC_APB1LPENR_TIM3LPEN_Pos         (1U)                                
N#define RCC_APB1LPENR_TIM3LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM3LPEN_Pos) /*!< 0x00000002 */
N#define RCC_APB1LPENR_TIM3LPEN             RCC_APB1LPENR_TIM3LPEN_Msk          
N#define RCC_APB1LPENR_TIM4LPEN_Pos         (2U)                                
N#define RCC_APB1LPENR_TIM4LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM4LPEN_Pos) /*!< 0x00000004 */
N#define RCC_APB1LPENR_TIM4LPEN             RCC_APB1LPENR_TIM4LPEN_Msk          
N#define RCC_APB1LPENR_TIM5LPEN_Pos         (3U)                                
N#define RCC_APB1LPENR_TIM5LPEN_Msk         (0x1UL << RCC_APB1LPENR_TIM5LPEN_Pos) /*!< 0x00000008 */
N#define RCC_APB1LPENR_TIM5LPEN             RCC_APB1LPENR_TIM5LPEN_Msk          
N#define RCC_APB1LPENR_WWDGLPEN_Pos         (11U)                               
N#define RCC_APB1LPENR_WWDGLPEN_Msk         (0x1UL << RCC_APB1LPENR_WWDGLPEN_Pos) /*!< 0x00000800 */
N#define RCC_APB1LPENR_WWDGLPEN             RCC_APB1LPENR_WWDGLPEN_Msk          
N#define RCC_APB1LPENR_SPI2LPEN_Pos         (14U)                               
N#define RCC_APB1LPENR_SPI2LPEN_Msk         (0x1UL << RCC_APB1LPENR_SPI2LPEN_Pos) /*!< 0x00004000 */
N#define RCC_APB1LPENR_SPI2LPEN             RCC_APB1LPENR_SPI2LPEN_Msk          
N#define RCC_APB1LPENR_SPI3LPEN_Pos         (15U)                               
N#define RCC_APB1LPENR_SPI3LPEN_Msk         (0x1UL << RCC_APB1LPENR_SPI3LPEN_Pos) /*!< 0x00008000 */
N#define RCC_APB1LPENR_SPI3LPEN             RCC_APB1LPENR_SPI3LPEN_Msk          
N#define RCC_APB1LPENR_USART2LPEN_Pos       (17U)                               
N#define RCC_APB1LPENR_USART2LPEN_Msk       (0x1UL << RCC_APB1LPENR_USART2LPEN_Pos) /*!< 0x00020000 */
N#define RCC_APB1LPENR_USART2LPEN           RCC_APB1LPENR_USART2LPEN_Msk        
N#define RCC_APB1LPENR_I2C1LPEN_Pos         (21U)                               
N#define RCC_APB1LPENR_I2C1LPEN_Msk         (0x1UL << RCC_APB1LPENR_I2C1LPEN_Pos) /*!< 0x00200000 */
N#define RCC_APB1LPENR_I2C1LPEN             RCC_APB1LPENR_I2C1LPEN_Msk          
N#define RCC_APB1LPENR_I2C2LPEN_Pos         (22U)                               
N#define RCC_APB1LPENR_I2C2LPEN_Msk         (0x1UL << RCC_APB1LPENR_I2C2LPEN_Pos) /*!< 0x00400000 */
N#define RCC_APB1LPENR_I2C2LPEN             RCC_APB1LPENR_I2C2LPEN_Msk          
N#define RCC_APB1LPENR_I2C3LPEN_Pos         (23U)                               
N#define RCC_APB1LPENR_I2C3LPEN_Msk         (0x1UL << RCC_APB1LPENR_I2C3LPEN_Pos) /*!< 0x00800000 */
N#define RCC_APB1LPENR_I2C3LPEN             RCC_APB1LPENR_I2C3LPEN_Msk          
N#define RCC_APB1LPENR_PWRLPEN_Pos          (28U)                               
N#define RCC_APB1LPENR_PWRLPEN_Msk          (0x1UL << RCC_APB1LPENR_PWRLPEN_Pos) /*!< 0x10000000 */
N#define RCC_APB1LPENR_PWRLPEN              RCC_APB1LPENR_PWRLPEN_Msk           
N
N/********************  Bit definition for RCC_APB2LPENR register  *************/
N#define RCC_APB2LPENR_TIM1LPEN_Pos         (0U)                                
N#define RCC_APB2LPENR_TIM1LPEN_Msk         (0x1UL << RCC_APB2LPENR_TIM1LPEN_Pos) /*!< 0x00000001 */
N#define RCC_APB2LPENR_TIM1LPEN             RCC_APB2LPENR_TIM1LPEN_Msk          
N#define RCC_APB2LPENR_USART1LPEN_Pos       (4U)                                
N#define RCC_APB2LPENR_USART1LPEN_Msk       (0x1UL << RCC_APB2LPENR_USART1LPEN_Pos) /*!< 0x00000010 */
N#define RCC_APB2LPENR_USART1LPEN           RCC_APB2LPENR_USART1LPEN_Msk        
N#define RCC_APB2LPENR_USART6LPEN_Pos       (5U)                                
N#define RCC_APB2LPENR_USART6LPEN_Msk       (0x1UL << RCC_APB2LPENR_USART6LPEN_Pos) /*!< 0x00000020 */
N#define RCC_APB2LPENR_USART6LPEN           RCC_APB2LPENR_USART6LPEN_Msk        
N#define RCC_APB2LPENR_ADC1LPEN_Pos         (8U)                                
N#define RCC_APB2LPENR_ADC1LPEN_Msk         (0x1UL << RCC_APB2LPENR_ADC1LPEN_Pos) /*!< 0x00000100 */
N#define RCC_APB2LPENR_ADC1LPEN             RCC_APB2LPENR_ADC1LPEN_Msk          
N#define RCC_APB2LPENR_SDIOLPEN_Pos         (11U)                               
N#define RCC_APB2LPENR_SDIOLPEN_Msk         (0x1UL << RCC_APB2LPENR_SDIOLPEN_Pos) /*!< 0x00000800 */
N#define RCC_APB2LPENR_SDIOLPEN             RCC_APB2LPENR_SDIOLPEN_Msk          
N#define RCC_APB2LPENR_SPI1LPEN_Pos         (12U)                               
N#define RCC_APB2LPENR_SPI1LPEN_Msk         (0x1UL << RCC_APB2LPENR_SPI1LPEN_Pos) /*!< 0x00001000 */
N#define RCC_APB2LPENR_SPI1LPEN             RCC_APB2LPENR_SPI1LPEN_Msk          
N#define RCC_APB2LPENR_SPI4LPEN_Pos         (13U)                               
N#define RCC_APB2LPENR_SPI4LPEN_Msk         (0x1UL << RCC_APB2LPENR_SPI4LPEN_Pos) /*!< 0x00002000 */
N#define RCC_APB2LPENR_SPI4LPEN             RCC_APB2LPENR_SPI4LPEN_Msk          
N#define RCC_APB2LPENR_SYSCFGLPEN_Pos       (14U)                               
N#define RCC_APB2LPENR_SYSCFGLPEN_Msk       (0x1UL << RCC_APB2LPENR_SYSCFGLPEN_Pos) /*!< 0x00004000 */
N#define RCC_APB2LPENR_SYSCFGLPEN           RCC_APB2LPENR_SYSCFGLPEN_Msk        
N#define RCC_APB2LPENR_TIM9LPEN_Pos         (16U)                               
N#define RCC_APB2LPENR_TIM9LPEN_Msk         (0x1UL << RCC_APB2LPENR_TIM9LPEN_Pos) /*!< 0x00010000 */
N#define RCC_APB2LPENR_TIM9LPEN             RCC_APB2LPENR_TIM9LPEN_Msk          
N#define RCC_APB2LPENR_TIM10LPEN_Pos        (17U)                               
N#define RCC_APB2LPENR_TIM10LPEN_Msk        (0x1UL << RCC_APB2LPENR_TIM10LPEN_Pos) /*!< 0x00020000 */
N#define RCC_APB2LPENR_TIM10LPEN            RCC_APB2LPENR_TIM10LPEN_Msk         
N#define RCC_APB2LPENR_TIM11LPEN_Pos        (18U)                               
N#define RCC_APB2LPENR_TIM11LPEN_Msk        (0x1UL << RCC_APB2LPENR_TIM11LPEN_Pos) /*!< 0x00040000 */
N#define RCC_APB2LPENR_TIM11LPEN            RCC_APB2LPENR_TIM11LPEN_Msk         
N
N/********************  Bit definition for RCC_BDCR register  ******************/
N#define RCC_BDCR_LSEON_Pos                 (0U)                                
N#define RCC_BDCR_LSEON_Msk                 (0x1UL << RCC_BDCR_LSEON_Pos)        /*!< 0x00000001 */
N#define RCC_BDCR_LSEON                     RCC_BDCR_LSEON_Msk                  
N#define RCC_BDCR_LSERDY_Pos                (1U)                                
N#define RCC_BDCR_LSERDY_Msk                (0x1UL << RCC_BDCR_LSERDY_Pos)       /*!< 0x00000002 */
N#define RCC_BDCR_LSERDY                    RCC_BDCR_LSERDY_Msk                 
N#define RCC_BDCR_LSEBYP_Pos                (2U)                                
N#define RCC_BDCR_LSEBYP_Msk                (0x1UL << RCC_BDCR_LSEBYP_Pos)       /*!< 0x00000004 */
N#define RCC_BDCR_LSEBYP                    RCC_BDCR_LSEBYP_Msk                 
N
N#define RCC_BDCR_RTCSEL_Pos                (8U)                                
N#define RCC_BDCR_RTCSEL_Msk                (0x3UL << RCC_BDCR_RTCSEL_Pos)       /*!< 0x00000300 */
N#define RCC_BDCR_RTCSEL                    RCC_BDCR_RTCSEL_Msk                 
N#define RCC_BDCR_RTCSEL_0                  (0x1UL << RCC_BDCR_RTCSEL_Pos)       /*!< 0x00000100 */
N#define RCC_BDCR_RTCSEL_1                  (0x2UL << RCC_BDCR_RTCSEL_Pos)       /*!< 0x00000200 */
N
N#define RCC_BDCR_RTCEN_Pos                 (15U)                               
N#define RCC_BDCR_RTCEN_Msk                 (0x1UL << RCC_BDCR_RTCEN_Pos)        /*!< 0x00008000 */
N#define RCC_BDCR_RTCEN                     RCC_BDCR_RTCEN_Msk                  
N#define RCC_BDCR_BDRST_Pos                 (16U)                               
N#define RCC_BDCR_BDRST_Msk                 (0x1UL << RCC_BDCR_BDRST_Pos)        /*!< 0x00010000 */
N#define RCC_BDCR_BDRST                     RCC_BDCR_BDRST_Msk                  
N
N/********************  Bit definition for RCC_CSR register  *******************/
N#define RCC_CSR_LSION_Pos                  (0U)                                
N#define RCC_CSR_LSION_Msk                  (0x1UL << RCC_CSR_LSION_Pos)         /*!< 0x00000001 */
N#define RCC_CSR_LSION                      RCC_CSR_LSION_Msk                   
N#define RCC_CSR_LSIRDY_Pos                 (1U)                                
N#define RCC_CSR_LSIRDY_Msk                 (0x1UL << RCC_CSR_LSIRDY_Pos)        /*!< 0x00000002 */
N#define RCC_CSR_LSIRDY                     RCC_CSR_LSIRDY_Msk                  
N#define RCC_CSR_RMVF_Pos                   (24U)                               
N#define RCC_CSR_RMVF_Msk                   (0x1UL << RCC_CSR_RMVF_Pos)          /*!< 0x01000000 */
N#define RCC_CSR_RMVF                       RCC_CSR_RMVF_Msk                    
N#define RCC_CSR_BORRSTF_Pos                (25U)                               
N#define RCC_CSR_BORRSTF_Msk                (0x1UL << RCC_CSR_BORRSTF_Pos)       /*!< 0x02000000 */
N#define RCC_CSR_BORRSTF                    RCC_CSR_BORRSTF_Msk                 
N#define RCC_CSR_PINRSTF_Pos                (26U)
N#define RCC_CSR_PINRSTF_Msk                (0x1UL << RCC_CSR_PINRSTF_Pos)       /*!< 0x04000000 */
N#define RCC_CSR_PINRSTF                    RCC_CSR_PINRSTF_Msk
N#define RCC_CSR_PORRSTF_Pos                (27U)                               
N#define RCC_CSR_PORRSTF_Msk                (0x1UL << RCC_CSR_PORRSTF_Pos)       /*!< 0x08000000 */
N#define RCC_CSR_PORRSTF                    RCC_CSR_PORRSTF_Msk                 
N#define RCC_CSR_SFTRSTF_Pos                (28U)                               
N#define RCC_CSR_SFTRSTF_Msk                (0x1UL << RCC_CSR_SFTRSTF_Pos)       /*!< 0x10000000 */
N#define RCC_CSR_SFTRSTF                    RCC_CSR_SFTRSTF_Msk                 
N#define RCC_CSR_IWDGRSTF_Pos               (29U)
N#define RCC_CSR_IWDGRSTF_Msk               (0x1UL << RCC_CSR_IWDGRSTF_Pos)      /*!< 0x20000000 */
N#define RCC_CSR_IWDGRSTF                   RCC_CSR_IWDGRSTF_Msk
N#define RCC_CSR_WWDGRSTF_Pos               (30U)                               
N#define RCC_CSR_WWDGRSTF_Msk               (0x1UL << RCC_CSR_WWDGRSTF_Pos)      /*!< 0x40000000 */
N#define RCC_CSR_WWDGRSTF                   RCC_CSR_WWDGRSTF_Msk                
N#define RCC_CSR_LPWRRSTF_Pos               (31U)                               
N#define RCC_CSR_LPWRRSTF_Msk               (0x1UL << RCC_CSR_LPWRRSTF_Pos)      /*!< 0x80000000 */
N#define RCC_CSR_LPWRRSTF                   RCC_CSR_LPWRRSTF_Msk
N/* Legacy defines */
N#define RCC_CSR_PADRSTF                    RCC_CSR_PINRSTF
N#define RCC_CSR_WDGRSTF                    RCC_CSR_IWDGRSTF
N
N/********************  Bit definition for RCC_SSCGR register  *****************/
N#define RCC_SSCGR_MODPER_Pos               (0U)                                
N#define RCC_SSCGR_MODPER_Msk               (0x1FFFUL << RCC_SSCGR_MODPER_Pos)   /*!< 0x00001FFF */
N#define RCC_SSCGR_MODPER                   RCC_SSCGR_MODPER_Msk                
N#define RCC_SSCGR_INCSTEP_Pos              (13U)                               
N#define RCC_SSCGR_INCSTEP_Msk              (0x7FFFUL << RCC_SSCGR_INCSTEP_Pos)  /*!< 0x0FFFE000 */
N#define RCC_SSCGR_INCSTEP                  RCC_SSCGR_INCSTEP_Msk               
N#define RCC_SSCGR_SPREADSEL_Pos            (30U)                               
N#define RCC_SSCGR_SPREADSEL_Msk            (0x1UL << RCC_SSCGR_SPREADSEL_Pos)   /*!< 0x40000000 */
N#define RCC_SSCGR_SPREADSEL                RCC_SSCGR_SPREADSEL_Msk             
N#define RCC_SSCGR_SSCGEN_Pos               (31U)                               
N#define RCC_SSCGR_SSCGEN_Msk               (0x1UL << RCC_SSCGR_SSCGEN_Pos)      /*!< 0x80000000 */
N#define RCC_SSCGR_SSCGEN                   RCC_SSCGR_SSCGEN_Msk                
N
N/********************  Bit definition for RCC_PLLI2SCFGR register  ************/
N#define RCC_PLLI2SCFGR_PLLI2SN_Pos         (6U)                                
N#define RCC_PLLI2SCFGR_PLLI2SN_Msk         (0x1FFUL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00007FC0 */
N#define RCC_PLLI2SCFGR_PLLI2SN             RCC_PLLI2SCFGR_PLLI2SN_Msk          
N#define RCC_PLLI2SCFGR_PLLI2SN_0           (0x001UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000040 */
N#define RCC_PLLI2SCFGR_PLLI2SN_1           (0x002UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000080 */
N#define RCC_PLLI2SCFGR_PLLI2SN_2           (0x004UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000100 */
N#define RCC_PLLI2SCFGR_PLLI2SN_3           (0x008UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000200 */
N#define RCC_PLLI2SCFGR_PLLI2SN_4           (0x010UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000400 */
N#define RCC_PLLI2SCFGR_PLLI2SN_5           (0x020UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00000800 */
N#define RCC_PLLI2SCFGR_PLLI2SN_6           (0x040UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00001000 */
N#define RCC_PLLI2SCFGR_PLLI2SN_7           (0x080UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00002000 */
N#define RCC_PLLI2SCFGR_PLLI2SN_8           (0x100UL << RCC_PLLI2SCFGR_PLLI2SN_Pos) /*!< 0x00004000 */
N
N#define RCC_PLLI2SCFGR_PLLI2SR_Pos         (28U)                               
N#define RCC_PLLI2SCFGR_PLLI2SR_Msk         (0x7UL << RCC_PLLI2SCFGR_PLLI2SR_Pos) /*!< 0x70000000 */
N#define RCC_PLLI2SCFGR_PLLI2SR             RCC_PLLI2SCFGR_PLLI2SR_Msk          
N#define RCC_PLLI2SCFGR_PLLI2SR_0           (0x1UL << RCC_PLLI2SCFGR_PLLI2SR_Pos) /*!< 0x10000000 */
N#define RCC_PLLI2SCFGR_PLLI2SR_1           (0x2UL << RCC_PLLI2SCFGR_PLLI2SR_Pos) /*!< 0x20000000 */
N#define RCC_PLLI2SCFGR_PLLI2SR_2           (0x4UL << RCC_PLLI2SCFGR_PLLI2SR_Pos) /*!< 0x40000000 */
N
N/********************  Bit definition for RCC_DCKCFGR register  ***************/
N
N#define RCC_DCKCFGR_TIMPRE_Pos             (24U)                               
N#define RCC_DCKCFGR_TIMPRE_Msk             (0x1UL << RCC_DCKCFGR_TIMPRE_Pos)    /*!< 0x01000000 */
N#define RCC_DCKCFGR_TIMPRE                 RCC_DCKCFGR_TIMPRE_Msk              
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RTC_TR register  *******************/
N#define RTC_TR_PM_Pos                 (22U)                                    
N#define RTC_TR_PM_Msk                 (0x1UL << RTC_TR_PM_Pos)                  /*!< 0x00400000 */
N#define RTC_TR_PM                     RTC_TR_PM_Msk                            
N#define RTC_TR_HT_Pos                 (20U)                                    
N#define RTC_TR_HT_Msk                 (0x3UL << RTC_TR_HT_Pos)                  /*!< 0x00300000 */
N#define RTC_TR_HT                     RTC_TR_HT_Msk                            
N#define RTC_TR_HT_0                   (0x1UL << RTC_TR_HT_Pos)                  /*!< 0x00100000 */
N#define RTC_TR_HT_1                   (0x2UL << RTC_TR_HT_Pos)                  /*!< 0x00200000 */
N#define RTC_TR_HU_Pos                 (16U)                                    
N#define RTC_TR_HU_Msk                 (0xFUL << RTC_TR_HU_Pos)                  /*!< 0x000F0000 */
N#define RTC_TR_HU                     RTC_TR_HU_Msk                            
N#define RTC_TR_HU_0                   (0x1UL << RTC_TR_HU_Pos)                  /*!< 0x00010000 */
N#define RTC_TR_HU_1                   (0x2UL << RTC_TR_HU_Pos)                  /*!< 0x00020000 */
N#define RTC_TR_HU_2                   (0x4UL << RTC_TR_HU_Pos)                  /*!< 0x00040000 */
N#define RTC_TR_HU_3                   (0x8UL << RTC_TR_HU_Pos)                  /*!< 0x00080000 */
N#define RTC_TR_MNT_Pos                (12U)                                    
N#define RTC_TR_MNT_Msk                (0x7UL << RTC_TR_MNT_Pos)                 /*!< 0x00007000 */
N#define RTC_TR_MNT                    RTC_TR_MNT_Msk                           
N#define RTC_TR_MNT_0                  (0x1UL << RTC_TR_MNT_Pos)                 /*!< 0x00001000 */
N#define RTC_TR_MNT_1                  (0x2UL << RTC_TR_MNT_Pos)                 /*!< 0x00002000 */
N#define RTC_TR_MNT_2                  (0x4UL << RTC_TR_MNT_Pos)                 /*!< 0x00004000 */
N#define RTC_TR_MNU_Pos                (8U)                                     
N#define RTC_TR_MNU_Msk                (0xFUL << RTC_TR_MNU_Pos)                 /*!< 0x00000F00 */
N#define RTC_TR_MNU                    RTC_TR_MNU_Msk                           
N#define RTC_TR_MNU_0                  (0x1UL << RTC_TR_MNU_Pos)                 /*!< 0x00000100 */
N#define RTC_TR_MNU_1                  (0x2UL << RTC_TR_MNU_Pos)                 /*!< 0x00000200 */
N#define RTC_TR_MNU_2                  (0x4UL << RTC_TR_MNU_Pos)                 /*!< 0x00000400 */
N#define RTC_TR_MNU_3                  (0x8UL << RTC_TR_MNU_Pos)                 /*!< 0x00000800 */
N#define RTC_TR_ST_Pos                 (4U)                                     
N#define RTC_TR_ST_Msk                 (0x7UL << RTC_TR_ST_Pos)                  /*!< 0x00000070 */
N#define RTC_TR_ST                     RTC_TR_ST_Msk                            
N#define RTC_TR_ST_0                   (0x1UL << RTC_TR_ST_Pos)                  /*!< 0x00000010 */
N#define RTC_TR_ST_1                   (0x2UL << RTC_TR_ST_Pos)                  /*!< 0x00000020 */
N#define RTC_TR_ST_2                   (0x4UL << RTC_TR_ST_Pos)                  /*!< 0x00000040 */
N#define RTC_TR_SU_Pos                 (0U)                                     
N#define RTC_TR_SU_Msk                 (0xFUL << RTC_TR_SU_Pos)                  /*!< 0x0000000F */
N#define RTC_TR_SU                     RTC_TR_SU_Msk                            
N#define RTC_TR_SU_0                   (0x1UL << RTC_TR_SU_Pos)                  /*!< 0x00000001 */
N#define RTC_TR_SU_1                   (0x2UL << RTC_TR_SU_Pos)                  /*!< 0x00000002 */
N#define RTC_TR_SU_2                   (0x4UL << RTC_TR_SU_Pos)                  /*!< 0x00000004 */
N#define RTC_TR_SU_3                   (0x8UL << RTC_TR_SU_Pos)                  /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_DR register  *******************/
N#define RTC_DR_YT_Pos                 (20U)                                    
N#define RTC_DR_YT_Msk                 (0xFUL << RTC_DR_YT_Pos)                  /*!< 0x00F00000 */
N#define RTC_DR_YT                     RTC_DR_YT_Msk                            
N#define RTC_DR_YT_0                   (0x1UL << RTC_DR_YT_Pos)                  /*!< 0x00100000 */
N#define RTC_DR_YT_1                   (0x2UL << RTC_DR_YT_Pos)                  /*!< 0x00200000 */
N#define RTC_DR_YT_2                   (0x4UL << RTC_DR_YT_Pos)                  /*!< 0x00400000 */
N#define RTC_DR_YT_3                   (0x8UL << RTC_DR_YT_Pos)                  /*!< 0x00800000 */
N#define RTC_DR_YU_Pos                 (16U)                                    
N#define RTC_DR_YU_Msk                 (0xFUL << RTC_DR_YU_Pos)                  /*!< 0x000F0000 */
N#define RTC_DR_YU                     RTC_DR_YU_Msk                            
N#define RTC_DR_YU_0                   (0x1UL << RTC_DR_YU_Pos)                  /*!< 0x00010000 */
N#define RTC_DR_YU_1                   (0x2UL << RTC_DR_YU_Pos)                  /*!< 0x00020000 */
N#define RTC_DR_YU_2                   (0x4UL << RTC_DR_YU_Pos)                  /*!< 0x00040000 */
N#define RTC_DR_YU_3                   (0x8UL << RTC_DR_YU_Pos)                  /*!< 0x00080000 */
N#define RTC_DR_WDU_Pos                (13U)                                    
N#define RTC_DR_WDU_Msk                (0x7UL << RTC_DR_WDU_Pos)                 /*!< 0x0000E000 */
N#define RTC_DR_WDU                    RTC_DR_WDU_Msk                           
N#define RTC_DR_WDU_0                  (0x1UL << RTC_DR_WDU_Pos)                 /*!< 0x00002000 */
N#define RTC_DR_WDU_1                  (0x2UL << RTC_DR_WDU_Pos)                 /*!< 0x00004000 */
N#define RTC_DR_WDU_2                  (0x4UL << RTC_DR_WDU_Pos)                 /*!< 0x00008000 */
N#define RTC_DR_MT_Pos                 (12U)                                    
N#define RTC_DR_MT_Msk                 (0x1UL << RTC_DR_MT_Pos)                  /*!< 0x00001000 */
N#define RTC_DR_MT                     RTC_DR_MT_Msk                            
N#define RTC_DR_MU_Pos                 (8U)                                     
N#define RTC_DR_MU_Msk                 (0xFUL << RTC_DR_MU_Pos)                  /*!< 0x00000F00 */
N#define RTC_DR_MU                     RTC_DR_MU_Msk                            
N#define RTC_DR_MU_0                   (0x1UL << RTC_DR_MU_Pos)                  /*!< 0x00000100 */
N#define RTC_DR_MU_1                   (0x2UL << RTC_DR_MU_Pos)                  /*!< 0x00000200 */
N#define RTC_DR_MU_2                   (0x4UL << RTC_DR_MU_Pos)                  /*!< 0x00000400 */
N#define RTC_DR_MU_3                   (0x8UL << RTC_DR_MU_Pos)                  /*!< 0x00000800 */
N#define RTC_DR_DT_Pos                 (4U)                                     
N#define RTC_DR_DT_Msk                 (0x3UL << RTC_DR_DT_Pos)                  /*!< 0x00000030 */
N#define RTC_DR_DT                     RTC_DR_DT_Msk                            
N#define RTC_DR_DT_0                   (0x1UL << RTC_DR_DT_Pos)                  /*!< 0x00000010 */
N#define RTC_DR_DT_1                   (0x2UL << RTC_DR_DT_Pos)                  /*!< 0x00000020 */
N#define RTC_DR_DU_Pos                 (0U)                                     
N#define RTC_DR_DU_Msk                 (0xFUL << RTC_DR_DU_Pos)                  /*!< 0x0000000F */
N#define RTC_DR_DU                     RTC_DR_DU_Msk                            
N#define RTC_DR_DU_0                   (0x1UL << RTC_DR_DU_Pos)                  /*!< 0x00000001 */
N#define RTC_DR_DU_1                   (0x2UL << RTC_DR_DU_Pos)                  /*!< 0x00000002 */
N#define RTC_DR_DU_2                   (0x4UL << RTC_DR_DU_Pos)                  /*!< 0x00000004 */
N#define RTC_DR_DU_3                   (0x8UL << RTC_DR_DU_Pos)                  /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_CR register  *******************/
N#define RTC_CR_COE_Pos                (23U)                                    
N#define RTC_CR_COE_Msk                (0x1UL << RTC_CR_COE_Pos)                 /*!< 0x00800000 */
N#define RTC_CR_COE                    RTC_CR_COE_Msk                           
N#define RTC_CR_OSEL_Pos               (21U)                                    
N#define RTC_CR_OSEL_Msk               (0x3UL << RTC_CR_OSEL_Pos)                /*!< 0x00600000 */
N#define RTC_CR_OSEL                   RTC_CR_OSEL_Msk                          
N#define RTC_CR_OSEL_0                 (0x1UL << RTC_CR_OSEL_Pos)                /*!< 0x00200000 */
N#define RTC_CR_OSEL_1                 (0x2UL << RTC_CR_OSEL_Pos)                /*!< 0x00400000 */
N#define RTC_CR_POL_Pos                (20U)                                    
N#define RTC_CR_POL_Msk                (0x1UL << RTC_CR_POL_Pos)                 /*!< 0x00100000 */
N#define RTC_CR_POL                    RTC_CR_POL_Msk                           
N#define RTC_CR_COSEL_Pos              (19U)                                    
N#define RTC_CR_COSEL_Msk              (0x1UL << RTC_CR_COSEL_Pos)               /*!< 0x00080000 */
N#define RTC_CR_COSEL                  RTC_CR_COSEL_Msk                         
N#define RTC_CR_BKP_Pos                 (18U)                                   
N#define RTC_CR_BKP_Msk                 (0x1UL << RTC_CR_BKP_Pos)                /*!< 0x00040000 */
N#define RTC_CR_BKP                     RTC_CR_BKP_Msk                          
N#define RTC_CR_SUB1H_Pos              (17U)                                    
N#define RTC_CR_SUB1H_Msk              (0x1UL << RTC_CR_SUB1H_Pos)               /*!< 0x00020000 */
N#define RTC_CR_SUB1H                  RTC_CR_SUB1H_Msk                         
N#define RTC_CR_ADD1H_Pos              (16U)                                    
N#define RTC_CR_ADD1H_Msk              (0x1UL << RTC_CR_ADD1H_Pos)               /*!< 0x00010000 */
N#define RTC_CR_ADD1H                  RTC_CR_ADD1H_Msk                         
N#define RTC_CR_TSIE_Pos               (15U)                                    
N#define RTC_CR_TSIE_Msk               (0x1UL << RTC_CR_TSIE_Pos)                /*!< 0x00008000 */
N#define RTC_CR_TSIE                   RTC_CR_TSIE_Msk                          
N#define RTC_CR_WUTIE_Pos              (14U)                                    
N#define RTC_CR_WUTIE_Msk              (0x1UL << RTC_CR_WUTIE_Pos)               /*!< 0x00004000 */
N#define RTC_CR_WUTIE                  RTC_CR_WUTIE_Msk                         
N#define RTC_CR_ALRBIE_Pos             (13U)                                    
N#define RTC_CR_ALRBIE_Msk             (0x1UL << RTC_CR_ALRBIE_Pos)              /*!< 0x00002000 */
N#define RTC_CR_ALRBIE                 RTC_CR_ALRBIE_Msk                        
N#define RTC_CR_ALRAIE_Pos             (12U)                                    
N#define RTC_CR_ALRAIE_Msk             (0x1UL << RTC_CR_ALRAIE_Pos)              /*!< 0x00001000 */
N#define RTC_CR_ALRAIE                 RTC_CR_ALRAIE_Msk                        
N#define RTC_CR_TSE_Pos                (11U)                                    
N#define RTC_CR_TSE_Msk                (0x1UL << RTC_CR_TSE_Pos)                 /*!< 0x00000800 */
N#define RTC_CR_TSE                    RTC_CR_TSE_Msk                           
N#define RTC_CR_WUTE_Pos               (10U)                                    
N#define RTC_CR_WUTE_Msk               (0x1UL << RTC_CR_WUTE_Pos)                /*!< 0x00000400 */
N#define RTC_CR_WUTE                   RTC_CR_WUTE_Msk                          
N#define RTC_CR_ALRBE_Pos              (9U)                                     
N#define RTC_CR_ALRBE_Msk              (0x1UL << RTC_CR_ALRBE_Pos)               /*!< 0x00000200 */
N#define RTC_CR_ALRBE                  RTC_CR_ALRBE_Msk                         
N#define RTC_CR_ALRAE_Pos              (8U)                                     
N#define RTC_CR_ALRAE_Msk              (0x1UL << RTC_CR_ALRAE_Pos)               /*!< 0x00000100 */
N#define RTC_CR_ALRAE                  RTC_CR_ALRAE_Msk                         
N#define RTC_CR_DCE_Pos                (7U)                                     
N#define RTC_CR_DCE_Msk                (0x1UL << RTC_CR_DCE_Pos)                 /*!< 0x00000080 */
N#define RTC_CR_DCE                    RTC_CR_DCE_Msk                           
N#define RTC_CR_FMT_Pos                (6U)                                     
N#define RTC_CR_FMT_Msk                (0x1UL << RTC_CR_FMT_Pos)                 /*!< 0x00000040 */
N#define RTC_CR_FMT                    RTC_CR_FMT_Msk                           
N#define RTC_CR_BYPSHAD_Pos            (5U)                                     
N#define RTC_CR_BYPSHAD_Msk            (0x1UL << RTC_CR_BYPSHAD_Pos)             /*!< 0x00000020 */
N#define RTC_CR_BYPSHAD                RTC_CR_BYPSHAD_Msk                       
N#define RTC_CR_REFCKON_Pos            (4U)                                     
N#define RTC_CR_REFCKON_Msk            (0x1UL << RTC_CR_REFCKON_Pos)             /*!< 0x00000010 */
N#define RTC_CR_REFCKON                RTC_CR_REFCKON_Msk                       
N#define RTC_CR_TSEDGE_Pos             (3U)                                     
N#define RTC_CR_TSEDGE_Msk             (0x1UL << RTC_CR_TSEDGE_Pos)              /*!< 0x00000008 */
N#define RTC_CR_TSEDGE                 RTC_CR_TSEDGE_Msk                        
N#define RTC_CR_WUCKSEL_Pos            (0U)                                     
N#define RTC_CR_WUCKSEL_Msk            (0x7UL << RTC_CR_WUCKSEL_Pos)             /*!< 0x00000007 */
N#define RTC_CR_WUCKSEL                RTC_CR_WUCKSEL_Msk                       
N#define RTC_CR_WUCKSEL_0              (0x1UL << RTC_CR_WUCKSEL_Pos)             /*!< 0x00000001 */
N#define RTC_CR_WUCKSEL_1              (0x2UL << RTC_CR_WUCKSEL_Pos)             /*!< 0x00000002 */
N#define RTC_CR_WUCKSEL_2              (0x4UL << RTC_CR_WUCKSEL_Pos)             /*!< 0x00000004 */
N
N/* Legacy defines */
N#define RTC_CR_BCK                     RTC_CR_BKP
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_RECALPF_Pos           (16U)                                    
N#define RTC_ISR_RECALPF_Msk           (0x1UL << RTC_ISR_RECALPF_Pos)            /*!< 0x00010000 */
N#define RTC_ISR_RECALPF               RTC_ISR_RECALPF_Msk                      
N#define RTC_ISR_TAMP1F_Pos            (13U)                                    
N#define RTC_ISR_TAMP1F_Msk            (0x1UL << RTC_ISR_TAMP1F_Pos)             /*!< 0x00002000 */
N#define RTC_ISR_TAMP1F                RTC_ISR_TAMP1F_Msk                       
N#define RTC_ISR_TAMP2F_Pos            (14U)                                    
N#define RTC_ISR_TAMP2F_Msk            (0x1UL << RTC_ISR_TAMP2F_Pos)             /*!< 0x00004000 */
N#define RTC_ISR_TAMP2F                RTC_ISR_TAMP2F_Msk                       
N#define RTC_ISR_TSOVF_Pos             (12U)                                    
N#define RTC_ISR_TSOVF_Msk             (0x1UL << RTC_ISR_TSOVF_Pos)              /*!< 0x00001000 */
N#define RTC_ISR_TSOVF                 RTC_ISR_TSOVF_Msk                        
N#define RTC_ISR_TSF_Pos               (11U)                                    
N#define RTC_ISR_TSF_Msk               (0x1UL << RTC_ISR_TSF_Pos)                /*!< 0x00000800 */
N#define RTC_ISR_TSF                   RTC_ISR_TSF_Msk                          
N#define RTC_ISR_WUTF_Pos              (10U)                                    
N#define RTC_ISR_WUTF_Msk              (0x1UL << RTC_ISR_WUTF_Pos)               /*!< 0x00000400 */
N#define RTC_ISR_WUTF                  RTC_ISR_WUTF_Msk                         
N#define RTC_ISR_ALRBF_Pos             (9U)                                     
N#define RTC_ISR_ALRBF_Msk             (0x1UL << RTC_ISR_ALRBF_Pos)              /*!< 0x00000200 */
N#define RTC_ISR_ALRBF                 RTC_ISR_ALRBF_Msk                        
N#define RTC_ISR_ALRAF_Pos             (8U)                                     
N#define RTC_ISR_ALRAF_Msk             (0x1UL << RTC_ISR_ALRAF_Pos)              /*!< 0x00000100 */
N#define RTC_ISR_ALRAF                 RTC_ISR_ALRAF_Msk                        
N#define RTC_ISR_INIT_Pos              (7U)                                     
N#define RTC_ISR_INIT_Msk              (0x1UL << RTC_ISR_INIT_Pos)               /*!< 0x00000080 */
N#define RTC_ISR_INIT                  RTC_ISR_INIT_Msk                         
N#define RTC_ISR_INITF_Pos             (6U)                                     
N#define RTC_ISR_INITF_Msk             (0x1UL << RTC_ISR_INITF_Pos)              /*!< 0x00000040 */
N#define RTC_ISR_INITF                 RTC_ISR_INITF_Msk                        
N#define RTC_ISR_RSF_Pos               (5U)                                     
N#define RTC_ISR_RSF_Msk               (0x1UL << RTC_ISR_RSF_Pos)                /*!< 0x00000020 */
N#define RTC_ISR_RSF                   RTC_ISR_RSF_Msk                          
N#define RTC_ISR_INITS_Pos             (4U)                                     
N#define RTC_ISR_INITS_Msk             (0x1UL << RTC_ISR_INITS_Pos)              /*!< 0x00000010 */
N#define RTC_ISR_INITS                 RTC_ISR_INITS_Msk                        
N#define RTC_ISR_SHPF_Pos              (3U)                                     
N#define RTC_ISR_SHPF_Msk              (0x1UL << RTC_ISR_SHPF_Pos)               /*!< 0x00000008 */
N#define RTC_ISR_SHPF                  RTC_ISR_SHPF_Msk                         
N#define RTC_ISR_WUTWF_Pos             (2U)                                     
N#define RTC_ISR_WUTWF_Msk             (0x1UL << RTC_ISR_WUTWF_Pos)              /*!< 0x00000004 */
N#define RTC_ISR_WUTWF                 RTC_ISR_WUTWF_Msk                        
N#define RTC_ISR_ALRBWF_Pos            (1U)                                     
N#define RTC_ISR_ALRBWF_Msk            (0x1UL << RTC_ISR_ALRBWF_Pos)             /*!< 0x00000002 */
N#define RTC_ISR_ALRBWF                RTC_ISR_ALRBWF_Msk                       
N#define RTC_ISR_ALRAWF_Pos            (0U)                                     
N#define RTC_ISR_ALRAWF_Msk            (0x1UL << RTC_ISR_ALRAWF_Pos)             /*!< 0x00000001 */
N#define RTC_ISR_ALRAWF                RTC_ISR_ALRAWF_Msk                       
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A_Pos         (16U)                                    
N#define RTC_PRER_PREDIV_A_Msk         (0x7FUL << RTC_PRER_PREDIV_A_Pos)         /*!< 0x007F0000 */
N#define RTC_PRER_PREDIV_A             RTC_PRER_PREDIV_A_Msk                    
N#define RTC_PRER_PREDIV_S_Pos         (0U)                                     
N#define RTC_PRER_PREDIV_S_Msk         (0x7FFFUL << RTC_PRER_PREDIV_S_Pos)       /*!< 0x00007FFF */
N#define RTC_PRER_PREDIV_S             RTC_PRER_PREDIV_S_Msk                    
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N#define RTC_WUTR_WUT_Pos              (0U)                                     
N#define RTC_WUTR_WUT_Msk              (0xFFFFUL << RTC_WUTR_WUT_Pos)            /*!< 0x0000FFFF */
N#define RTC_WUTR_WUT                  RTC_WUTR_WUT_Msk                         
N
N/********************  Bits definition for RTC_CALIBR register  ***************/
N#define RTC_CALIBR_DCS_Pos            (7U)                                     
N#define RTC_CALIBR_DCS_Msk            (0x1UL << RTC_CALIBR_DCS_Pos)             /*!< 0x00000080 */
N#define RTC_CALIBR_DCS                RTC_CALIBR_DCS_Msk                       
N#define RTC_CALIBR_DC_Pos             (0U)                                     
N#define RTC_CALIBR_DC_Msk             (0x1FUL << RTC_CALIBR_DC_Pos)             /*!< 0x0000001F */
N#define RTC_CALIBR_DC                 RTC_CALIBR_DC_Msk                        
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4_Pos           (31U)                                    
N#define RTC_ALRMAR_MSK4_Msk           (0x1UL << RTC_ALRMAR_MSK4_Pos)            /*!< 0x80000000 */
N#define RTC_ALRMAR_MSK4               RTC_ALRMAR_MSK4_Msk                      
N#define RTC_ALRMAR_WDSEL_Pos          (30U)                                    
N#define RTC_ALRMAR_WDSEL_Msk          (0x1UL << RTC_ALRMAR_WDSEL_Pos)           /*!< 0x40000000 */
N#define RTC_ALRMAR_WDSEL              RTC_ALRMAR_WDSEL_Msk                     
N#define RTC_ALRMAR_DT_Pos             (28U)                                    
N#define RTC_ALRMAR_DT_Msk             (0x3UL << RTC_ALRMAR_DT_Pos)              /*!< 0x30000000 */
N#define RTC_ALRMAR_DT                 RTC_ALRMAR_DT_Msk                        
N#define RTC_ALRMAR_DT_0               (0x1UL << RTC_ALRMAR_DT_Pos)              /*!< 0x10000000 */
N#define RTC_ALRMAR_DT_1               (0x2UL << RTC_ALRMAR_DT_Pos)              /*!< 0x20000000 */
N#define RTC_ALRMAR_DU_Pos             (24U)                                    
N#define RTC_ALRMAR_DU_Msk             (0xFUL << RTC_ALRMAR_DU_Pos)              /*!< 0x0F000000 */
N#define RTC_ALRMAR_DU                 RTC_ALRMAR_DU_Msk                        
N#define RTC_ALRMAR_DU_0               (0x1UL << RTC_ALRMAR_DU_Pos)              /*!< 0x01000000 */
N#define RTC_ALRMAR_DU_1               (0x2UL << RTC_ALRMAR_DU_Pos)              /*!< 0x02000000 */
N#define RTC_ALRMAR_DU_2               (0x4UL << RTC_ALRMAR_DU_Pos)              /*!< 0x04000000 */
N#define RTC_ALRMAR_DU_3               (0x8UL << RTC_ALRMAR_DU_Pos)              /*!< 0x08000000 */
N#define RTC_ALRMAR_MSK3_Pos           (23U)                                    
N#define RTC_ALRMAR_MSK3_Msk           (0x1UL << RTC_ALRMAR_MSK3_Pos)            /*!< 0x00800000 */
N#define RTC_ALRMAR_MSK3               RTC_ALRMAR_MSK3_Msk                      
N#define RTC_ALRMAR_PM_Pos             (22U)                                    
N#define RTC_ALRMAR_PM_Msk             (0x1UL << RTC_ALRMAR_PM_Pos)              /*!< 0x00400000 */
N#define RTC_ALRMAR_PM                 RTC_ALRMAR_PM_Msk                        
N#define RTC_ALRMAR_HT_Pos             (20U)                                    
N#define RTC_ALRMAR_HT_Msk             (0x3UL << RTC_ALRMAR_HT_Pos)              /*!< 0x00300000 */
N#define RTC_ALRMAR_HT                 RTC_ALRMAR_HT_Msk                        
N#define RTC_ALRMAR_HT_0               (0x1UL << RTC_ALRMAR_HT_Pos)              /*!< 0x00100000 */
N#define RTC_ALRMAR_HT_1               (0x2UL << RTC_ALRMAR_HT_Pos)              /*!< 0x00200000 */
N#define RTC_ALRMAR_HU_Pos             (16U)                                    
N#define RTC_ALRMAR_HU_Msk             (0xFUL << RTC_ALRMAR_HU_Pos)              /*!< 0x000F0000 */
N#define RTC_ALRMAR_HU                 RTC_ALRMAR_HU_Msk                        
N#define RTC_ALRMAR_HU_0               (0x1UL << RTC_ALRMAR_HU_Pos)              /*!< 0x00010000 */
N#define RTC_ALRMAR_HU_1               (0x2UL << RTC_ALRMAR_HU_Pos)              /*!< 0x00020000 */
N#define RTC_ALRMAR_HU_2               (0x4UL << RTC_ALRMAR_HU_Pos)              /*!< 0x00040000 */
N#define RTC_ALRMAR_HU_3               (0x8UL << RTC_ALRMAR_HU_Pos)              /*!< 0x00080000 */
N#define RTC_ALRMAR_MSK2_Pos           (15U)                                    
N#define RTC_ALRMAR_MSK2_Msk           (0x1UL << RTC_ALRMAR_MSK2_Pos)            /*!< 0x00008000 */
N#define RTC_ALRMAR_MSK2               RTC_ALRMAR_MSK2_Msk                      
N#define RTC_ALRMAR_MNT_Pos            (12U)                                    
N#define RTC_ALRMAR_MNT_Msk            (0x7UL << RTC_ALRMAR_MNT_Pos)             /*!< 0x00007000 */
N#define RTC_ALRMAR_MNT                RTC_ALRMAR_MNT_Msk                       
N#define RTC_ALRMAR_MNT_0              (0x1UL << RTC_ALRMAR_MNT_Pos)             /*!< 0x00001000 */
N#define RTC_ALRMAR_MNT_1              (0x2UL << RTC_ALRMAR_MNT_Pos)             /*!< 0x00002000 */
N#define RTC_ALRMAR_MNT_2              (0x4UL << RTC_ALRMAR_MNT_Pos)             /*!< 0x00004000 */
N#define RTC_ALRMAR_MNU_Pos            (8U)                                     
N#define RTC_ALRMAR_MNU_Msk            (0xFUL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000F00 */
N#define RTC_ALRMAR_MNU                RTC_ALRMAR_MNU_Msk                       
N#define RTC_ALRMAR_MNU_0              (0x1UL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000100 */
N#define RTC_ALRMAR_MNU_1              (0x2UL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000200 */
N#define RTC_ALRMAR_MNU_2              (0x4UL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000400 */
N#define RTC_ALRMAR_MNU_3              (0x8UL << RTC_ALRMAR_MNU_Pos)             /*!< 0x00000800 */
N#define RTC_ALRMAR_MSK1_Pos           (7U)                                     
N#define RTC_ALRMAR_MSK1_Msk           (0x1UL << RTC_ALRMAR_MSK1_Pos)            /*!< 0x00000080 */
N#define RTC_ALRMAR_MSK1               RTC_ALRMAR_MSK1_Msk                      
N#define RTC_ALRMAR_ST_Pos             (4U)                                     
N#define RTC_ALRMAR_ST_Msk             (0x7UL << RTC_ALRMAR_ST_Pos)              /*!< 0x00000070 */
N#define RTC_ALRMAR_ST                 RTC_ALRMAR_ST_Msk                        
N#define RTC_ALRMAR_ST_0               (0x1UL << RTC_ALRMAR_ST_Pos)              /*!< 0x00000010 */
N#define RTC_ALRMAR_ST_1               (0x2UL << RTC_ALRMAR_ST_Pos)              /*!< 0x00000020 */
N#define RTC_ALRMAR_ST_2               (0x4UL << RTC_ALRMAR_ST_Pos)              /*!< 0x00000040 */
N#define RTC_ALRMAR_SU_Pos             (0U)                                     
N#define RTC_ALRMAR_SU_Msk             (0xFUL << RTC_ALRMAR_SU_Pos)              /*!< 0x0000000F */
N#define RTC_ALRMAR_SU                 RTC_ALRMAR_SU_Msk                        
N#define RTC_ALRMAR_SU_0               (0x1UL << RTC_ALRMAR_SU_Pos)              /*!< 0x00000001 */
N#define RTC_ALRMAR_SU_1               (0x2UL << RTC_ALRMAR_SU_Pos)              /*!< 0x00000002 */
N#define RTC_ALRMAR_SU_2               (0x4UL << RTC_ALRMAR_SU_Pos)              /*!< 0x00000004 */
N#define RTC_ALRMAR_SU_3               (0x8UL << RTC_ALRMAR_SU_Pos)              /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_ALRMBR register  ***************/
N#define RTC_ALRMBR_MSK4_Pos           (31U)                                    
N#define RTC_ALRMBR_MSK4_Msk           (0x1UL << RTC_ALRMBR_MSK4_Pos)            /*!< 0x80000000 */
N#define RTC_ALRMBR_MSK4               RTC_ALRMBR_MSK4_Msk                      
N#define RTC_ALRMBR_WDSEL_Pos          (30U)                                    
N#define RTC_ALRMBR_WDSEL_Msk          (0x1UL << RTC_ALRMBR_WDSEL_Pos)           /*!< 0x40000000 */
N#define RTC_ALRMBR_WDSEL              RTC_ALRMBR_WDSEL_Msk                     
N#define RTC_ALRMBR_DT_Pos             (28U)                                    
N#define RTC_ALRMBR_DT_Msk             (0x3UL << RTC_ALRMBR_DT_Pos)              /*!< 0x30000000 */
N#define RTC_ALRMBR_DT                 RTC_ALRMBR_DT_Msk                        
N#define RTC_ALRMBR_DT_0               (0x1UL << RTC_ALRMBR_DT_Pos)              /*!< 0x10000000 */
N#define RTC_ALRMBR_DT_1               (0x2UL << RTC_ALRMBR_DT_Pos)              /*!< 0x20000000 */
N#define RTC_ALRMBR_DU_Pos             (24U)                                    
N#define RTC_ALRMBR_DU_Msk             (0xFUL << RTC_ALRMBR_DU_Pos)              /*!< 0x0F000000 */
N#define RTC_ALRMBR_DU                 RTC_ALRMBR_DU_Msk                        
N#define RTC_ALRMBR_DU_0               (0x1UL << RTC_ALRMBR_DU_Pos)              /*!< 0x01000000 */
N#define RTC_ALRMBR_DU_1               (0x2UL << RTC_ALRMBR_DU_Pos)              /*!< 0x02000000 */
N#define RTC_ALRMBR_DU_2               (0x4UL << RTC_ALRMBR_DU_Pos)              /*!< 0x04000000 */
N#define RTC_ALRMBR_DU_3               (0x8UL << RTC_ALRMBR_DU_Pos)              /*!< 0x08000000 */
N#define RTC_ALRMBR_MSK3_Pos           (23U)                                    
N#define RTC_ALRMBR_MSK3_Msk           (0x1UL << RTC_ALRMBR_MSK3_Pos)            /*!< 0x00800000 */
N#define RTC_ALRMBR_MSK3               RTC_ALRMBR_MSK3_Msk                      
N#define RTC_ALRMBR_PM_Pos             (22U)                                    
N#define RTC_ALRMBR_PM_Msk             (0x1UL << RTC_ALRMBR_PM_Pos)              /*!< 0x00400000 */
N#define RTC_ALRMBR_PM                 RTC_ALRMBR_PM_Msk                        
N#define RTC_ALRMBR_HT_Pos             (20U)                                    
N#define RTC_ALRMBR_HT_Msk             (0x3UL << RTC_ALRMBR_HT_Pos)              /*!< 0x00300000 */
N#define RTC_ALRMBR_HT                 RTC_ALRMBR_HT_Msk                        
N#define RTC_ALRMBR_HT_0               (0x1UL << RTC_ALRMBR_HT_Pos)              /*!< 0x00100000 */
N#define RTC_ALRMBR_HT_1               (0x2UL << RTC_ALRMBR_HT_Pos)              /*!< 0x00200000 */
N#define RTC_ALRMBR_HU_Pos             (16U)                                    
N#define RTC_ALRMBR_HU_Msk             (0xFUL << RTC_ALRMBR_HU_Pos)              /*!< 0x000F0000 */
N#define RTC_ALRMBR_HU                 RTC_ALRMBR_HU_Msk                        
N#define RTC_ALRMBR_HU_0               (0x1UL << RTC_ALRMBR_HU_Pos)              /*!< 0x00010000 */
N#define RTC_ALRMBR_HU_1               (0x2UL << RTC_ALRMBR_HU_Pos)              /*!< 0x00020000 */
N#define RTC_ALRMBR_HU_2               (0x4UL << RTC_ALRMBR_HU_Pos)              /*!< 0x00040000 */
N#define RTC_ALRMBR_HU_3               (0x8UL << RTC_ALRMBR_HU_Pos)              /*!< 0x00080000 */
N#define RTC_ALRMBR_MSK2_Pos           (15U)                                    
N#define RTC_ALRMBR_MSK2_Msk           (0x1UL << RTC_ALRMBR_MSK2_Pos)            /*!< 0x00008000 */
N#define RTC_ALRMBR_MSK2               RTC_ALRMBR_MSK2_Msk                      
N#define RTC_ALRMBR_MNT_Pos            (12U)                                    
N#define RTC_ALRMBR_MNT_Msk            (0x7UL << RTC_ALRMBR_MNT_Pos)             /*!< 0x00007000 */
N#define RTC_ALRMBR_MNT                RTC_ALRMBR_MNT_Msk                       
N#define RTC_ALRMBR_MNT_0              (0x1UL << RTC_ALRMBR_MNT_Pos)             /*!< 0x00001000 */
N#define RTC_ALRMBR_MNT_1              (0x2UL << RTC_ALRMBR_MNT_Pos)             /*!< 0x00002000 */
N#define RTC_ALRMBR_MNT_2              (0x4UL << RTC_ALRMBR_MNT_Pos)             /*!< 0x00004000 */
N#define RTC_ALRMBR_MNU_Pos            (8U)                                     
N#define RTC_ALRMBR_MNU_Msk            (0xFUL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000F00 */
N#define RTC_ALRMBR_MNU                RTC_ALRMBR_MNU_Msk                       
N#define RTC_ALRMBR_MNU_0              (0x1UL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000100 */
N#define RTC_ALRMBR_MNU_1              (0x2UL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000200 */
N#define RTC_ALRMBR_MNU_2              (0x4UL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000400 */
N#define RTC_ALRMBR_MNU_3              (0x8UL << RTC_ALRMBR_MNU_Pos)             /*!< 0x00000800 */
N#define RTC_ALRMBR_MSK1_Pos           (7U)                                     
N#define RTC_ALRMBR_MSK1_Msk           (0x1UL << RTC_ALRMBR_MSK1_Pos)            /*!< 0x00000080 */
N#define RTC_ALRMBR_MSK1               RTC_ALRMBR_MSK1_Msk                      
N#define RTC_ALRMBR_ST_Pos             (4U)                                     
N#define RTC_ALRMBR_ST_Msk             (0x7UL << RTC_ALRMBR_ST_Pos)              /*!< 0x00000070 */
N#define RTC_ALRMBR_ST                 RTC_ALRMBR_ST_Msk                        
N#define RTC_ALRMBR_ST_0               (0x1UL << RTC_ALRMBR_ST_Pos)              /*!< 0x00000010 */
N#define RTC_ALRMBR_ST_1               (0x2UL << RTC_ALRMBR_ST_Pos)              /*!< 0x00000020 */
N#define RTC_ALRMBR_ST_2               (0x4UL << RTC_ALRMBR_ST_Pos)              /*!< 0x00000040 */
N#define RTC_ALRMBR_SU_Pos             (0U)                                     
N#define RTC_ALRMBR_SU_Msk             (0xFUL << RTC_ALRMBR_SU_Pos)              /*!< 0x0000000F */
N#define RTC_ALRMBR_SU                 RTC_ALRMBR_SU_Msk                        
N#define RTC_ALRMBR_SU_0               (0x1UL << RTC_ALRMBR_SU_Pos)              /*!< 0x00000001 */
N#define RTC_ALRMBR_SU_1               (0x2UL << RTC_ALRMBR_SU_Pos)              /*!< 0x00000002 */
N#define RTC_ALRMBR_SU_2               (0x4UL << RTC_ALRMBR_SU_Pos)              /*!< 0x00000004 */
N#define RTC_ALRMBR_SU_3               (0x8UL << RTC_ALRMBR_SU_Pos)              /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY_Pos               (0U)                                     
N#define RTC_WPR_KEY_Msk               (0xFFUL << RTC_WPR_KEY_Pos)               /*!< 0x000000FF */
N#define RTC_WPR_KEY                   RTC_WPR_KEY_Msk                          
N
N/********************  Bits definition for RTC_SSR register  ******************/
N#define RTC_SSR_SS_Pos                (0U)                                     
N#define RTC_SSR_SS_Msk                (0xFFFFUL << RTC_SSR_SS_Pos)              /*!< 0x0000FFFF */
N#define RTC_SSR_SS                    RTC_SSR_SS_Msk                           
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS_Pos          (0U)                                     
N#define RTC_SHIFTR_SUBFS_Msk          (0x7FFFUL << RTC_SHIFTR_SUBFS_Pos)        /*!< 0x00007FFF */
N#define RTC_SHIFTR_SUBFS              RTC_SHIFTR_SUBFS_Msk                     
N#define RTC_SHIFTR_ADD1S_Pos          (31U)                                    
N#define RTC_SHIFTR_ADD1S_Msk          (0x1UL << RTC_SHIFTR_ADD1S_Pos)           /*!< 0x80000000 */
N#define RTC_SHIFTR_ADD1S              RTC_SHIFTR_ADD1S_Msk                     
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM_Pos               (22U)                                    
N#define RTC_TSTR_PM_Msk               (0x1UL << RTC_TSTR_PM_Pos)                /*!< 0x00400000 */
N#define RTC_TSTR_PM                   RTC_TSTR_PM_Msk                          
N#define RTC_TSTR_HT_Pos               (20U)                                    
N#define RTC_TSTR_HT_Msk               (0x3UL << RTC_TSTR_HT_Pos)                /*!< 0x00300000 */
N#define RTC_TSTR_HT                   RTC_TSTR_HT_Msk                          
N#define RTC_TSTR_HT_0                 (0x1UL << RTC_TSTR_HT_Pos)                /*!< 0x00100000 */
N#define RTC_TSTR_HT_1                 (0x2UL << RTC_TSTR_HT_Pos)                /*!< 0x00200000 */
N#define RTC_TSTR_HU_Pos               (16U)                                    
N#define RTC_TSTR_HU_Msk               (0xFUL << RTC_TSTR_HU_Pos)                /*!< 0x000F0000 */
N#define RTC_TSTR_HU                   RTC_TSTR_HU_Msk                          
N#define RTC_TSTR_HU_0                 (0x1UL << RTC_TSTR_HU_Pos)                /*!< 0x00010000 */
N#define RTC_TSTR_HU_1                 (0x2UL << RTC_TSTR_HU_Pos)                /*!< 0x00020000 */
N#define RTC_TSTR_HU_2                 (0x4UL << RTC_TSTR_HU_Pos)                /*!< 0x00040000 */
N#define RTC_TSTR_HU_3                 (0x8UL << RTC_TSTR_HU_Pos)                /*!< 0x00080000 */
N#define RTC_TSTR_MNT_Pos              (12U)                                    
N#define RTC_TSTR_MNT_Msk              (0x7UL << RTC_TSTR_MNT_Pos)               /*!< 0x00007000 */
N#define RTC_TSTR_MNT                  RTC_TSTR_MNT_Msk                         
N#define RTC_TSTR_MNT_0                (0x1UL << RTC_TSTR_MNT_Pos)               /*!< 0x00001000 */
N#define RTC_TSTR_MNT_1                (0x2UL << RTC_TSTR_MNT_Pos)               /*!< 0x00002000 */
N#define RTC_TSTR_MNT_2                (0x4UL << RTC_TSTR_MNT_Pos)               /*!< 0x00004000 */
N#define RTC_TSTR_MNU_Pos              (8U)                                     
N#define RTC_TSTR_MNU_Msk              (0xFUL << RTC_TSTR_MNU_Pos)               /*!< 0x00000F00 */
N#define RTC_TSTR_MNU                  RTC_TSTR_MNU_Msk                         
N#define RTC_TSTR_MNU_0                (0x1UL << RTC_TSTR_MNU_Pos)               /*!< 0x00000100 */
N#define RTC_TSTR_MNU_1                (0x2UL << RTC_TSTR_MNU_Pos)               /*!< 0x00000200 */
N#define RTC_TSTR_MNU_2                (0x4UL << RTC_TSTR_MNU_Pos)               /*!< 0x00000400 */
N#define RTC_TSTR_MNU_3                (0x8UL << RTC_TSTR_MNU_Pos)               /*!< 0x00000800 */
N#define RTC_TSTR_ST_Pos               (4U)                                     
N#define RTC_TSTR_ST_Msk               (0x7UL << RTC_TSTR_ST_Pos)                /*!< 0x00000070 */
N#define RTC_TSTR_ST                   RTC_TSTR_ST_Msk                          
N#define RTC_TSTR_ST_0                 (0x1UL << RTC_TSTR_ST_Pos)                /*!< 0x00000010 */
N#define RTC_TSTR_ST_1                 (0x2UL << RTC_TSTR_ST_Pos)                /*!< 0x00000020 */
N#define RTC_TSTR_ST_2                 (0x4UL << RTC_TSTR_ST_Pos)                /*!< 0x00000040 */
N#define RTC_TSTR_SU_Pos               (0U)                                     
N#define RTC_TSTR_SU_Msk               (0xFUL << RTC_TSTR_SU_Pos)                /*!< 0x0000000F */
N#define RTC_TSTR_SU                   RTC_TSTR_SU_Msk                          
N#define RTC_TSTR_SU_0                 (0x1UL << RTC_TSTR_SU_Pos)                /*!< 0x00000001 */
N#define RTC_TSTR_SU_1                 (0x2UL << RTC_TSTR_SU_Pos)                /*!< 0x00000002 */
N#define RTC_TSTR_SU_2                 (0x4UL << RTC_TSTR_SU_Pos)                /*!< 0x00000004 */
N#define RTC_TSTR_SU_3                 (0x8UL << RTC_TSTR_SU_Pos)                /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU_Pos              (13U)                                    
N#define RTC_TSDR_WDU_Msk              (0x7UL << RTC_TSDR_WDU_Pos)               /*!< 0x0000E000 */
N#define RTC_TSDR_WDU                  RTC_TSDR_WDU_Msk                         
N#define RTC_TSDR_WDU_0                (0x1UL << RTC_TSDR_WDU_Pos)               /*!< 0x00002000 */
N#define RTC_TSDR_WDU_1                (0x2UL << RTC_TSDR_WDU_Pos)               /*!< 0x00004000 */
N#define RTC_TSDR_WDU_2                (0x4UL << RTC_TSDR_WDU_Pos)               /*!< 0x00008000 */
N#define RTC_TSDR_MT_Pos               (12U)                                    
N#define RTC_TSDR_MT_Msk               (0x1UL << RTC_TSDR_MT_Pos)                /*!< 0x00001000 */
N#define RTC_TSDR_MT                   RTC_TSDR_MT_Msk                          
N#define RTC_TSDR_MU_Pos               (8U)                                     
N#define RTC_TSDR_MU_Msk               (0xFUL << RTC_TSDR_MU_Pos)                /*!< 0x00000F00 */
N#define RTC_TSDR_MU                   RTC_TSDR_MU_Msk                          
N#define RTC_TSDR_MU_0                 (0x1UL << RTC_TSDR_MU_Pos)                /*!< 0x00000100 */
N#define RTC_TSDR_MU_1                 (0x2UL << RTC_TSDR_MU_Pos)                /*!< 0x00000200 */
N#define RTC_TSDR_MU_2                 (0x4UL << RTC_TSDR_MU_Pos)                /*!< 0x00000400 */
N#define RTC_TSDR_MU_3                 (0x8UL << RTC_TSDR_MU_Pos)                /*!< 0x00000800 */
N#define RTC_TSDR_DT_Pos               (4U)                                     
N#define RTC_TSDR_DT_Msk               (0x3UL << RTC_TSDR_DT_Pos)                /*!< 0x00000030 */
N#define RTC_TSDR_DT                   RTC_TSDR_DT_Msk                          
N#define RTC_TSDR_DT_0                 (0x1UL << RTC_TSDR_DT_Pos)                /*!< 0x00000010 */
N#define RTC_TSDR_DT_1                 (0x2UL << RTC_TSDR_DT_Pos)                /*!< 0x00000020 */
N#define RTC_TSDR_DU_Pos               (0U)                                     
N#define RTC_TSDR_DU_Msk               (0xFUL << RTC_TSDR_DU_Pos)                /*!< 0x0000000F */
N#define RTC_TSDR_DU                   RTC_TSDR_DU_Msk                          
N#define RTC_TSDR_DU_0                 (0x1UL << RTC_TSDR_DU_Pos)                /*!< 0x00000001 */
N#define RTC_TSDR_DU_1                 (0x2UL << RTC_TSDR_DU_Pos)                /*!< 0x00000002 */
N#define RTC_TSDR_DU_2                 (0x4UL << RTC_TSDR_DU_Pos)                /*!< 0x00000004 */
N#define RTC_TSDR_DU_3                 (0x8UL << RTC_TSDR_DU_Pos)                /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N#define RTC_TSSSR_SS_Pos              (0U)                                     
N#define RTC_TSSSR_SS_Msk              (0xFFFFUL << RTC_TSSSR_SS_Pos)            /*!< 0x0000FFFF */
N#define RTC_TSSSR_SS                  RTC_TSSSR_SS_Msk                         
N
N/********************  Bits definition for RTC_CAL register  *****************/
N#define RTC_CALR_CALP_Pos             (15U)                                    
N#define RTC_CALR_CALP_Msk             (0x1UL << RTC_CALR_CALP_Pos)              /*!< 0x00008000 */
N#define RTC_CALR_CALP                 RTC_CALR_CALP_Msk                        
N#define RTC_CALR_CALW8_Pos            (14U)                                    
N#define RTC_CALR_CALW8_Msk            (0x1UL << RTC_CALR_CALW8_Pos)             /*!< 0x00004000 */
N#define RTC_CALR_CALW8                RTC_CALR_CALW8_Msk                       
N#define RTC_CALR_CALW16_Pos           (13U)                                    
N#define RTC_CALR_CALW16_Msk           (0x1UL << RTC_CALR_CALW16_Pos)            /*!< 0x00002000 */
N#define RTC_CALR_CALW16               RTC_CALR_CALW16_Msk                      
N#define RTC_CALR_CALM_Pos             (0U)                                     
N#define RTC_CALR_CALM_Msk             (0x1FFUL << RTC_CALR_CALM_Pos)            /*!< 0x000001FF */
N#define RTC_CALR_CALM                 RTC_CALR_CALM_Msk                        
N#define RTC_CALR_CALM_0               (0x001UL << RTC_CALR_CALM_Pos)            /*!< 0x00000001 */
N#define RTC_CALR_CALM_1               (0x002UL << RTC_CALR_CALM_Pos)            /*!< 0x00000002 */
N#define RTC_CALR_CALM_2               (0x004UL << RTC_CALR_CALM_Pos)            /*!< 0x00000004 */
N#define RTC_CALR_CALM_3               (0x008UL << RTC_CALR_CALM_Pos)            /*!< 0x00000008 */
N#define RTC_CALR_CALM_4               (0x010UL << RTC_CALR_CALM_Pos)            /*!< 0x00000010 */
N#define RTC_CALR_CALM_5               (0x020UL << RTC_CALR_CALM_Pos)            /*!< 0x00000020 */
N#define RTC_CALR_CALM_6               (0x040UL << RTC_CALR_CALM_Pos)            /*!< 0x00000040 */
N#define RTC_CALR_CALM_7               (0x080UL << RTC_CALR_CALM_Pos)            /*!< 0x00000080 */
N#define RTC_CALR_CALM_8               (0x100UL << RTC_CALR_CALM_Pos)            /*!< 0x00000100 */
N
N/********************  Bits definition for RTC_TAFCR register  ****************/
N#define RTC_TAFCR_ALARMOUTTYPE_Pos    (18U)                                    
N#define RTC_TAFCR_ALARMOUTTYPE_Msk    (0x1UL << RTC_TAFCR_ALARMOUTTYPE_Pos)     /*!< 0x00040000 */
N#define RTC_TAFCR_ALARMOUTTYPE        RTC_TAFCR_ALARMOUTTYPE_Msk               
N#define RTC_TAFCR_TSINSEL_Pos         (17U)                                    
N#define RTC_TAFCR_TSINSEL_Msk         (0x1UL << RTC_TAFCR_TSINSEL_Pos)          /*!< 0x00020000 */
N#define RTC_TAFCR_TSINSEL             RTC_TAFCR_TSINSEL_Msk                    
N#define RTC_TAFCR_TAMP1INSEL_Pos      (16U)                                    
N#define RTC_TAFCR_TAMP1INSEL_Msk      (0x1UL << RTC_TAFCR_TAMP1INSEL_Pos)        /*!< 0x00010000 */
N#define RTC_TAFCR_TAMP1INSEL          RTC_TAFCR_TAMP1INSEL_Msk                  
N#define RTC_TAFCR_TAMPPUDIS_Pos       (15U)                                    
N#define RTC_TAFCR_TAMPPUDIS_Msk       (0x1UL << RTC_TAFCR_TAMPPUDIS_Pos)        /*!< 0x00008000 */
N#define RTC_TAFCR_TAMPPUDIS           RTC_TAFCR_TAMPPUDIS_Msk                  
N#define RTC_TAFCR_TAMPPRCH_Pos        (13U)                                    
N#define RTC_TAFCR_TAMPPRCH_Msk        (0x3UL << RTC_TAFCR_TAMPPRCH_Pos)         /*!< 0x00006000 */
N#define RTC_TAFCR_TAMPPRCH            RTC_TAFCR_TAMPPRCH_Msk                   
N#define RTC_TAFCR_TAMPPRCH_0          (0x1UL << RTC_TAFCR_TAMPPRCH_Pos)         /*!< 0x00002000 */
N#define RTC_TAFCR_TAMPPRCH_1          (0x2UL << RTC_TAFCR_TAMPPRCH_Pos)         /*!< 0x00004000 */
N#define RTC_TAFCR_TAMPFLT_Pos         (11U)                                    
N#define RTC_TAFCR_TAMPFLT_Msk         (0x3UL << RTC_TAFCR_TAMPFLT_Pos)          /*!< 0x00001800 */
N#define RTC_TAFCR_TAMPFLT             RTC_TAFCR_TAMPFLT_Msk                    
N#define RTC_TAFCR_TAMPFLT_0           (0x1UL << RTC_TAFCR_TAMPFLT_Pos)          /*!< 0x00000800 */
N#define RTC_TAFCR_TAMPFLT_1           (0x2UL << RTC_TAFCR_TAMPFLT_Pos)          /*!< 0x00001000 */
N#define RTC_TAFCR_TAMPFREQ_Pos        (8U)                                     
N#define RTC_TAFCR_TAMPFREQ_Msk        (0x7UL << RTC_TAFCR_TAMPFREQ_Pos)         /*!< 0x00000700 */
N#define RTC_TAFCR_TAMPFREQ            RTC_TAFCR_TAMPFREQ_Msk                   
N#define RTC_TAFCR_TAMPFREQ_0          (0x1UL << RTC_TAFCR_TAMPFREQ_Pos)         /*!< 0x00000100 */
N#define RTC_TAFCR_TAMPFREQ_1          (0x2UL << RTC_TAFCR_TAMPFREQ_Pos)         /*!< 0x00000200 */
N#define RTC_TAFCR_TAMPFREQ_2          (0x4UL << RTC_TAFCR_TAMPFREQ_Pos)         /*!< 0x00000400 */
N#define RTC_TAFCR_TAMPTS_Pos          (7U)                                     
N#define RTC_TAFCR_TAMPTS_Msk          (0x1UL << RTC_TAFCR_TAMPTS_Pos)           /*!< 0x00000080 */
N#define RTC_TAFCR_TAMPTS              RTC_TAFCR_TAMPTS_Msk                     
N#define RTC_TAFCR_TAMP2TRG_Pos        (4U)                                     
N#define RTC_TAFCR_TAMP2TRG_Msk        (0x1UL << RTC_TAFCR_TAMP2TRG_Pos)         /*!< 0x00000010 */
N#define RTC_TAFCR_TAMP2TRG            RTC_TAFCR_TAMP2TRG_Msk                   
N#define RTC_TAFCR_TAMP2E_Pos          (3U)                                     
N#define RTC_TAFCR_TAMP2E_Msk          (0x1UL << RTC_TAFCR_TAMP2E_Pos)           /*!< 0x00000008 */
N#define RTC_TAFCR_TAMP2E              RTC_TAFCR_TAMP2E_Msk                     
N#define RTC_TAFCR_TAMPIE_Pos          (2U)                                     
N#define RTC_TAFCR_TAMPIE_Msk          (0x1UL << RTC_TAFCR_TAMPIE_Pos)           /*!< 0x00000004 */
N#define RTC_TAFCR_TAMPIE              RTC_TAFCR_TAMPIE_Msk                     
N#define RTC_TAFCR_TAMP1TRG_Pos        (1U)                                     
N#define RTC_TAFCR_TAMP1TRG_Msk        (0x1UL << RTC_TAFCR_TAMP1TRG_Pos)         /*!< 0x00000002 */
N#define RTC_TAFCR_TAMP1TRG            RTC_TAFCR_TAMP1TRG_Msk                   
N#define RTC_TAFCR_TAMP1E_Pos          (0U)                                     
N#define RTC_TAFCR_TAMP1E_Msk          (0x1UL << RTC_TAFCR_TAMP1E_Pos)           /*!< 0x00000001 */
N#define RTC_TAFCR_TAMP1E              RTC_TAFCR_TAMP1E_Msk                     
N
N/* Legacy defines */
N#define RTC_TAFCR_TAMPINSEL           RTC_TAFCR_TAMP1INSEL
N
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS_Pos       (24U)                                    
N#define RTC_ALRMASSR_MASKSS_Msk       (0xFUL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x0F000000 */
N#define RTC_ALRMASSR_MASKSS           RTC_ALRMASSR_MASKSS_Msk                  
N#define RTC_ALRMASSR_MASKSS_0         (0x1UL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x01000000 */
N#define RTC_ALRMASSR_MASKSS_1         (0x2UL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x02000000 */
N#define RTC_ALRMASSR_MASKSS_2         (0x4UL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x04000000 */
N#define RTC_ALRMASSR_MASKSS_3         (0x8UL << RTC_ALRMASSR_MASKSS_Pos)        /*!< 0x08000000 */
N#define RTC_ALRMASSR_SS_Pos           (0U)                                     
N#define RTC_ALRMASSR_SS_Msk           (0x7FFFUL << RTC_ALRMASSR_SS_Pos)         /*!< 0x00007FFF */
N#define RTC_ALRMASSR_SS               RTC_ALRMASSR_SS_Msk                      
N
N/********************  Bits definition for RTC_ALRMBSSR register  *************/
N#define RTC_ALRMBSSR_MASKSS_Pos       (24U)                                    
N#define RTC_ALRMBSSR_MASKSS_Msk       (0xFUL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x0F000000 */
N#define RTC_ALRMBSSR_MASKSS           RTC_ALRMBSSR_MASKSS_Msk                  
N#define RTC_ALRMBSSR_MASKSS_0         (0x1UL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x01000000 */
N#define RTC_ALRMBSSR_MASKSS_1         (0x2UL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x02000000 */
N#define RTC_ALRMBSSR_MASKSS_2         (0x4UL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x04000000 */
N#define RTC_ALRMBSSR_MASKSS_3         (0x8UL << RTC_ALRMBSSR_MASKSS_Pos)        /*!< 0x08000000 */
N#define RTC_ALRMBSSR_SS_Pos           (0U)                                     
N#define RTC_ALRMBSSR_SS_Msk           (0x7FFFUL << RTC_ALRMBSSR_SS_Pos)         /*!< 0x00007FFF */
N#define RTC_ALRMBSSR_SS               RTC_ALRMBSSR_SS_Msk                      
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R_Pos                 (0U)                                     
N#define RTC_BKP0R_Msk                 (0xFFFFFFFFUL << RTC_BKP0R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP0R                     RTC_BKP0R_Msk                            
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R_Pos                 (0U)                                     
N#define RTC_BKP1R_Msk                 (0xFFFFFFFFUL << RTC_BKP1R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP1R                     RTC_BKP1R_Msk                            
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R_Pos                 (0U)                                     
N#define RTC_BKP2R_Msk                 (0xFFFFFFFFUL << RTC_BKP2R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP2R                     RTC_BKP2R_Msk                            
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R_Pos                 (0U)                                     
N#define RTC_BKP3R_Msk                 (0xFFFFFFFFUL << RTC_BKP3R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP3R                     RTC_BKP3R_Msk                            
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R_Pos                 (0U)                                     
N#define RTC_BKP4R_Msk                 (0xFFFFFFFFUL << RTC_BKP4R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP4R                     RTC_BKP4R_Msk                            
N
N/********************  Bits definition for RTC_BKP5R register  ****************/
N#define RTC_BKP5R_Pos                 (0U)                                     
N#define RTC_BKP5R_Msk                 (0xFFFFFFFFUL << RTC_BKP5R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP5R                     RTC_BKP5R_Msk                            
N
N/********************  Bits definition for RTC_BKP6R register  ****************/
N#define RTC_BKP6R_Pos                 (0U)                                     
N#define RTC_BKP6R_Msk                 (0xFFFFFFFFUL << RTC_BKP6R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP6R                     RTC_BKP6R_Msk                            
N
N/********************  Bits definition for RTC_BKP7R register  ****************/
N#define RTC_BKP7R_Pos                 (0U)                                     
N#define RTC_BKP7R_Msk                 (0xFFFFFFFFUL << RTC_BKP7R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP7R                     RTC_BKP7R_Msk                            
N
N/********************  Bits definition for RTC_BKP8R register  ****************/
N#define RTC_BKP8R_Pos                 (0U)                                     
N#define RTC_BKP8R_Msk                 (0xFFFFFFFFUL << RTC_BKP8R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP8R                     RTC_BKP8R_Msk                            
N
N/********************  Bits definition for RTC_BKP9R register  ****************/
N#define RTC_BKP9R_Pos                 (0U)                                     
N#define RTC_BKP9R_Msk                 (0xFFFFFFFFUL << RTC_BKP9R_Pos)           /*!< 0xFFFFFFFF */
N#define RTC_BKP9R                     RTC_BKP9R_Msk                            
N
N/********************  Bits definition for RTC_BKP10R register  ***************/
N#define RTC_BKP10R_Pos                (0U)                                     
N#define RTC_BKP10R_Msk                (0xFFFFFFFFUL << RTC_BKP10R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP10R                    RTC_BKP10R_Msk                           
N
N/********************  Bits definition for RTC_BKP11R register  ***************/
N#define RTC_BKP11R_Pos                (0U)                                     
N#define RTC_BKP11R_Msk                (0xFFFFFFFFUL << RTC_BKP11R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP11R                    RTC_BKP11R_Msk                           
N
N/********************  Bits definition for RTC_BKP12R register  ***************/
N#define RTC_BKP12R_Pos                (0U)                                     
N#define RTC_BKP12R_Msk                (0xFFFFFFFFUL << RTC_BKP12R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP12R                    RTC_BKP12R_Msk                           
N
N/********************  Bits definition for RTC_BKP13R register  ***************/
N#define RTC_BKP13R_Pos                (0U)                                     
N#define RTC_BKP13R_Msk                (0xFFFFFFFFUL << RTC_BKP13R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP13R                    RTC_BKP13R_Msk                           
N
N/********************  Bits definition for RTC_BKP14R register  ***************/
N#define RTC_BKP14R_Pos                (0U)                                     
N#define RTC_BKP14R_Msk                (0xFFFFFFFFUL << RTC_BKP14R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP14R                    RTC_BKP14R_Msk                           
N
N/********************  Bits definition for RTC_BKP15R register  ***************/
N#define RTC_BKP15R_Pos                (0U)                                     
N#define RTC_BKP15R_Msk                (0xFFFFFFFFUL << RTC_BKP15R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP15R                    RTC_BKP15R_Msk                           
N
N/********************  Bits definition for RTC_BKP16R register  ***************/
N#define RTC_BKP16R_Pos                (0U)                                     
N#define RTC_BKP16R_Msk                (0xFFFFFFFFUL << RTC_BKP16R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP16R                    RTC_BKP16R_Msk                           
N
N/********************  Bits definition for RTC_BKP17R register  ***************/
N#define RTC_BKP17R_Pos                (0U)                                     
N#define RTC_BKP17R_Msk                (0xFFFFFFFFUL << RTC_BKP17R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP17R                    RTC_BKP17R_Msk                           
N
N/********************  Bits definition for RTC_BKP18R register  ***************/
N#define RTC_BKP18R_Pos                (0U)                                     
N#define RTC_BKP18R_Msk                (0xFFFFFFFFUL << RTC_BKP18R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP18R                    RTC_BKP18R_Msk                           
N
N/********************  Bits definition for RTC_BKP19R register  ***************/
N#define RTC_BKP19R_Pos                (0U)                                     
N#define RTC_BKP19R_Msk                (0xFFFFFFFFUL << RTC_BKP19R_Pos)          /*!< 0xFFFFFFFF */
N#define RTC_BKP19R                    RTC_BKP19R_Msk                           
N
N/******************** Number of backup registers ******************************/
N#define RTC_BKP_NUMBER                       0x000000014U
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                          SD host Interface                                 */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SDIO_POWER register  ******************/
N#define SDIO_POWER_PWRCTRL_Pos         (0U)                                    
N#define SDIO_POWER_PWRCTRL_Msk         (0x3UL << SDIO_POWER_PWRCTRL_Pos)        /*!< 0x00000003 */
N#define SDIO_POWER_PWRCTRL             SDIO_POWER_PWRCTRL_Msk                  /*!<PWRCTRL[1:0] bits (Power supply control bits) */
N#define SDIO_POWER_PWRCTRL_0           (0x1UL << SDIO_POWER_PWRCTRL_Pos)        /*!< 0x01 */
N#define SDIO_POWER_PWRCTRL_1           (0x2UL << SDIO_POWER_PWRCTRL_Pos)        /*!< 0x02 */
N
N/******************  Bit definition for SDIO_CLKCR register  ******************/
N#define SDIO_CLKCR_CLKDIV_Pos          (0U)                                    
N#define SDIO_CLKCR_CLKDIV_Msk          (0xFFUL << SDIO_CLKCR_CLKDIV_Pos)        /*!< 0x000000FF */
N#define SDIO_CLKCR_CLKDIV              SDIO_CLKCR_CLKDIV_Msk                   /*!<Clock divide factor             */
N#define SDIO_CLKCR_CLKEN_Pos           (8U)                                    
N#define SDIO_CLKCR_CLKEN_Msk           (0x1UL << SDIO_CLKCR_CLKEN_Pos)          /*!< 0x00000100 */
N#define SDIO_CLKCR_CLKEN               SDIO_CLKCR_CLKEN_Msk                    /*!<Clock enable bit                */
N#define SDIO_CLKCR_PWRSAV_Pos          (9U)                                    
N#define SDIO_CLKCR_PWRSAV_Msk          (0x1UL << SDIO_CLKCR_PWRSAV_Pos)         /*!< 0x00000200 */
N#define SDIO_CLKCR_PWRSAV              SDIO_CLKCR_PWRSAV_Msk                   /*!<Power saving configuration bit  */
N#define SDIO_CLKCR_BYPASS_Pos          (10U)                                   
N#define SDIO_CLKCR_BYPASS_Msk          (0x1UL << SDIO_CLKCR_BYPASS_Pos)         /*!< 0x00000400 */
N#define SDIO_CLKCR_BYPASS              SDIO_CLKCR_BYPASS_Msk                   /*!<Clock divider bypass enable bit */
N
N#define SDIO_CLKCR_WIDBUS_Pos          (11U)                                   
N#define SDIO_CLKCR_WIDBUS_Msk          (0x3UL << SDIO_CLKCR_WIDBUS_Pos)         /*!< 0x00001800 */
N#define SDIO_CLKCR_WIDBUS              SDIO_CLKCR_WIDBUS_Msk                   /*!<WIDBUS[1:0] bits (Wide bus mode enable bit) */
N#define SDIO_CLKCR_WIDBUS_0            (0x1UL << SDIO_CLKCR_WIDBUS_Pos)         /*!< 0x0800 */
N#define SDIO_CLKCR_WIDBUS_1            (0x2UL << SDIO_CLKCR_WIDBUS_Pos)         /*!< 0x1000 */
N
N#define SDIO_CLKCR_NEGEDGE_Pos         (13U)                                   
N#define SDIO_CLKCR_NEGEDGE_Msk         (0x1UL << SDIO_CLKCR_NEGEDGE_Pos)        /*!< 0x00002000 */
N#define SDIO_CLKCR_NEGEDGE             SDIO_CLKCR_NEGEDGE_Msk                  /*!<SDIO_CK dephasing selection bit */
N#define SDIO_CLKCR_HWFC_EN_Pos         (14U)                                   
N#define SDIO_CLKCR_HWFC_EN_Msk         (0x1UL << SDIO_CLKCR_HWFC_EN_Pos)        /*!< 0x00004000 */
N#define SDIO_CLKCR_HWFC_EN             SDIO_CLKCR_HWFC_EN_Msk                  /*!<HW Flow Control enable          */
N
N/*******************  Bit definition for SDIO_ARG register  *******************/
N#define SDIO_ARG_CMDARG_Pos            (0U)                                    
N#define SDIO_ARG_CMDARG_Msk            (0xFFFFFFFFUL << SDIO_ARG_CMDARG_Pos)    /*!< 0xFFFFFFFF */
N#define SDIO_ARG_CMDARG                SDIO_ARG_CMDARG_Msk                     /*!<Command argument */
N
N/*******************  Bit definition for SDIO_CMD register  *******************/
N#define SDIO_CMD_CMDINDEX_Pos          (0U)                                    
N#define SDIO_CMD_CMDINDEX_Msk          (0x3FUL << SDIO_CMD_CMDINDEX_Pos)        /*!< 0x0000003F */
N#define SDIO_CMD_CMDINDEX              SDIO_CMD_CMDINDEX_Msk                   /*!<Command Index                               */
N
N#define SDIO_CMD_WAITRESP_Pos          (6U)                                    
N#define SDIO_CMD_WAITRESP_Msk          (0x3UL << SDIO_CMD_WAITRESP_Pos)         /*!< 0x000000C0 */
N#define SDIO_CMD_WAITRESP              SDIO_CMD_WAITRESP_Msk                   /*!<WAITRESP[1:0] bits (Wait for response bits) */
N#define SDIO_CMD_WAITRESP_0            (0x1UL << SDIO_CMD_WAITRESP_Pos)         /*!< 0x0040 */
N#define SDIO_CMD_WAITRESP_1            (0x2UL << SDIO_CMD_WAITRESP_Pos)         /*!< 0x0080 */
N
N#define SDIO_CMD_WAITINT_Pos           (8U)                                    
N#define SDIO_CMD_WAITINT_Msk           (0x1UL << SDIO_CMD_WAITINT_Pos)          /*!< 0x00000100 */
N#define SDIO_CMD_WAITINT               SDIO_CMD_WAITINT_Msk                    /*!<CPSM Waits for Interrupt Request                               */
N#define SDIO_CMD_WAITPEND_Pos          (9U)                                    
N#define SDIO_CMD_WAITPEND_Msk          (0x1UL << SDIO_CMD_WAITPEND_Pos)         /*!< 0x00000200 */
N#define SDIO_CMD_WAITPEND              SDIO_CMD_WAITPEND_Msk                   /*!<CPSM Waits for ends of data transfer (CmdPend internal signal) */
N#define SDIO_CMD_CPSMEN_Pos            (10U)                                   
N#define SDIO_CMD_CPSMEN_Msk            (0x1UL << SDIO_CMD_CPSMEN_Pos)           /*!< 0x00000400 */
N#define SDIO_CMD_CPSMEN                SDIO_CMD_CPSMEN_Msk                     /*!<Command path state machine (CPSM) Enable bit                   */
N#define SDIO_CMD_SDIOSUSPEND_Pos       (11U)                                   
N#define SDIO_CMD_SDIOSUSPEND_Msk       (0x1UL << SDIO_CMD_SDIOSUSPEND_Pos)      /*!< 0x00000800 */
N#define SDIO_CMD_SDIOSUSPEND           SDIO_CMD_SDIOSUSPEND_Msk                /*!<SD I/O suspend command                                         */
N#define SDIO_CMD_ENCMDCOMPL_Pos        (12U)                                   
N#define SDIO_CMD_ENCMDCOMPL_Msk        (0x1UL << SDIO_CMD_ENCMDCOMPL_Pos)       /*!< 0x00001000 */
N#define SDIO_CMD_ENCMDCOMPL            SDIO_CMD_ENCMDCOMPL_Msk                 /*!<Enable CMD completion                                          */
N#define SDIO_CMD_NIEN_Pos              (13U)                                   
N#define SDIO_CMD_NIEN_Msk              (0x1UL << SDIO_CMD_NIEN_Pos)             /*!< 0x00002000 */
N#define SDIO_CMD_NIEN                  SDIO_CMD_NIEN_Msk                       /*!<Not Interrupt Enable                                           */
N#define SDIO_CMD_CEATACMD_Pos          (14U)                                   
N#define SDIO_CMD_CEATACMD_Msk          (0x1UL << SDIO_CMD_CEATACMD_Pos)         /*!< 0x00004000 */
N#define SDIO_CMD_CEATACMD              SDIO_CMD_CEATACMD_Msk                   /*!<CE-ATA command                                                 */
N
N/*****************  Bit definition for SDIO_RESPCMD register  *****************/
N#define SDIO_RESPCMD_RESPCMD_Pos       (0U)                                    
N#define SDIO_RESPCMD_RESPCMD_Msk       (0x3FUL << SDIO_RESPCMD_RESPCMD_Pos)     /*!< 0x0000003F */
N#define SDIO_RESPCMD_RESPCMD           SDIO_RESPCMD_RESPCMD_Msk                /*!<Response command index */
N
N/******************  Bit definition for SDIO_RESP0 register  ******************/
N#define SDIO_RESP0_CARDSTATUS0_Pos     (0U)                                    
N#define SDIO_RESP0_CARDSTATUS0_Msk     (0xFFFFFFFFUL << SDIO_RESP0_CARDSTATUS0_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP0_CARDSTATUS0         SDIO_RESP0_CARDSTATUS0_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP1 register  ******************/
N#define SDIO_RESP1_CARDSTATUS1_Pos     (0U)                                    
N#define SDIO_RESP1_CARDSTATUS1_Msk     (0xFFFFFFFFUL << SDIO_RESP1_CARDSTATUS1_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP1_CARDSTATUS1         SDIO_RESP1_CARDSTATUS1_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP2 register  ******************/
N#define SDIO_RESP2_CARDSTATUS2_Pos     (0U)                                    
N#define SDIO_RESP2_CARDSTATUS2_Msk     (0xFFFFFFFFUL << SDIO_RESP2_CARDSTATUS2_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP2_CARDSTATUS2         SDIO_RESP2_CARDSTATUS2_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP3 register  ******************/
N#define SDIO_RESP3_CARDSTATUS3_Pos     (0U)                                    
N#define SDIO_RESP3_CARDSTATUS3_Msk     (0xFFFFFFFFUL << SDIO_RESP3_CARDSTATUS3_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP3_CARDSTATUS3         SDIO_RESP3_CARDSTATUS3_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP4 register  ******************/
N#define SDIO_RESP4_CARDSTATUS4_Pos     (0U)                                    
N#define SDIO_RESP4_CARDSTATUS4_Msk     (0xFFFFFFFFUL << SDIO_RESP4_CARDSTATUS4_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_RESP4_CARDSTATUS4         SDIO_RESP4_CARDSTATUS4_Msk              /*!<Card Status */
N
N/******************  Bit definition for SDIO_DTIMER register  *****************/
N#define SDIO_DTIMER_DATATIME_Pos       (0U)                                    
N#define SDIO_DTIMER_DATATIME_Msk       (0xFFFFFFFFUL << SDIO_DTIMER_DATATIME_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_DTIMER_DATATIME           SDIO_DTIMER_DATATIME_Msk                /*!<Data timeout period. */
N
N/******************  Bit definition for SDIO_DLEN register  *******************/
N#define SDIO_DLEN_DATALENGTH_Pos       (0U)                                    
N#define SDIO_DLEN_DATALENGTH_Msk       (0x1FFFFFFUL << SDIO_DLEN_DATALENGTH_Pos) /*!< 0x01FFFFFF */
N#define SDIO_DLEN_DATALENGTH           SDIO_DLEN_DATALENGTH_Msk                /*!<Data length value    */
N
N/******************  Bit definition for SDIO_DCTRL register  ******************/
N#define SDIO_DCTRL_DTEN_Pos            (0U)                                    
N#define SDIO_DCTRL_DTEN_Msk            (0x1UL << SDIO_DCTRL_DTEN_Pos)           /*!< 0x00000001 */
N#define SDIO_DCTRL_DTEN                SDIO_DCTRL_DTEN_Msk                     /*!<Data transfer enabled bit         */
N#define SDIO_DCTRL_DTDIR_Pos           (1U)                                    
N#define SDIO_DCTRL_DTDIR_Msk           (0x1UL << SDIO_DCTRL_DTDIR_Pos)          /*!< 0x00000002 */
N#define SDIO_DCTRL_DTDIR               SDIO_DCTRL_DTDIR_Msk                    /*!<Data transfer direction selection */
N#define SDIO_DCTRL_DTMODE_Pos          (2U)                                    
N#define SDIO_DCTRL_DTMODE_Msk          (0x1UL << SDIO_DCTRL_DTMODE_Pos)         /*!< 0x00000004 */
N#define SDIO_DCTRL_DTMODE              SDIO_DCTRL_DTMODE_Msk                   /*!<Data transfer mode selection      */
N#define SDIO_DCTRL_DMAEN_Pos           (3U)                                    
N#define SDIO_DCTRL_DMAEN_Msk           (0x1UL << SDIO_DCTRL_DMAEN_Pos)          /*!< 0x00000008 */
N#define SDIO_DCTRL_DMAEN               SDIO_DCTRL_DMAEN_Msk                    /*!<DMA enabled bit                   */
N
N#define SDIO_DCTRL_DBLOCKSIZE_Pos      (4U)                                    
N#define SDIO_DCTRL_DBLOCKSIZE_Msk      (0xFUL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x000000F0 */
N#define SDIO_DCTRL_DBLOCKSIZE          SDIO_DCTRL_DBLOCKSIZE_Msk               /*!<DBLOCKSIZE[3:0] bits (Data block size) */
N#define SDIO_DCTRL_DBLOCKSIZE_0        (0x1UL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x0010 */
N#define SDIO_DCTRL_DBLOCKSIZE_1        (0x2UL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x0020 */
N#define SDIO_DCTRL_DBLOCKSIZE_2        (0x4UL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x0040 */
N#define SDIO_DCTRL_DBLOCKSIZE_3        (0x8UL << SDIO_DCTRL_DBLOCKSIZE_Pos)     /*!< 0x0080 */
N
N#define SDIO_DCTRL_RWSTART_Pos         (8U)                                    
N#define SDIO_DCTRL_RWSTART_Msk         (0x1UL << SDIO_DCTRL_RWSTART_Pos)        /*!< 0x00000100 */
N#define SDIO_DCTRL_RWSTART             SDIO_DCTRL_RWSTART_Msk                  /*!<Read wait start         */
N#define SDIO_DCTRL_RWSTOP_Pos          (9U)                                    
N#define SDIO_DCTRL_RWSTOP_Msk          (0x1UL << SDIO_DCTRL_RWSTOP_Pos)         /*!< 0x00000200 */
N#define SDIO_DCTRL_RWSTOP              SDIO_DCTRL_RWSTOP_Msk                   /*!<Read wait stop          */
N#define SDIO_DCTRL_RWMOD_Pos           (10U)                                   
N#define SDIO_DCTRL_RWMOD_Msk           (0x1UL << SDIO_DCTRL_RWMOD_Pos)          /*!< 0x00000400 */
N#define SDIO_DCTRL_RWMOD               SDIO_DCTRL_RWMOD_Msk                    /*!<Read wait mode          */
N#define SDIO_DCTRL_SDIOEN_Pos          (11U)                                   
N#define SDIO_DCTRL_SDIOEN_Msk          (0x1UL << SDIO_DCTRL_SDIOEN_Pos)         /*!< 0x00000800 */
N#define SDIO_DCTRL_SDIOEN              SDIO_DCTRL_SDIOEN_Msk                   /*!<SD I/O enable functions */
N
N/******************  Bit definition for SDIO_DCOUNT register  *****************/
N#define SDIO_DCOUNT_DATACOUNT_Pos      (0U)                                    
N#define SDIO_DCOUNT_DATACOUNT_Msk      (0x1FFFFFFUL << SDIO_DCOUNT_DATACOUNT_Pos) /*!< 0x01FFFFFF */
N#define SDIO_DCOUNT_DATACOUNT          SDIO_DCOUNT_DATACOUNT_Msk               /*!<Data count value */
N
N/******************  Bit definition for SDIO_STA register  ********************/
N#define SDIO_STA_CCRCFAIL_Pos          (0U)                                    
N#define SDIO_STA_CCRCFAIL_Msk          (0x1UL << SDIO_STA_CCRCFAIL_Pos)         /*!< 0x00000001 */
N#define SDIO_STA_CCRCFAIL              SDIO_STA_CCRCFAIL_Msk                   /*!<Command response received (CRC check failed)  */
N#define SDIO_STA_DCRCFAIL_Pos          (1U)                                    
N#define SDIO_STA_DCRCFAIL_Msk          (0x1UL << SDIO_STA_DCRCFAIL_Pos)         /*!< 0x00000002 */
N#define SDIO_STA_DCRCFAIL              SDIO_STA_DCRCFAIL_Msk                   /*!<Data block sent/received (CRC check failed)   */
N#define SDIO_STA_CTIMEOUT_Pos          (2U)                                    
N#define SDIO_STA_CTIMEOUT_Msk          (0x1UL << SDIO_STA_CTIMEOUT_Pos)         /*!< 0x00000004 */
N#define SDIO_STA_CTIMEOUT              SDIO_STA_CTIMEOUT_Msk                   /*!<Command response timeout                      */
N#define SDIO_STA_DTIMEOUT_Pos          (3U)                                    
N#define SDIO_STA_DTIMEOUT_Msk          (0x1UL << SDIO_STA_DTIMEOUT_Pos)         /*!< 0x00000008 */
N#define SDIO_STA_DTIMEOUT              SDIO_STA_DTIMEOUT_Msk                   /*!<Data timeout                                  */
N#define SDIO_STA_TXUNDERR_Pos          (4U)                                    
N#define SDIO_STA_TXUNDERR_Msk          (0x1UL << SDIO_STA_TXUNDERR_Pos)         /*!< 0x00000010 */
N#define SDIO_STA_TXUNDERR              SDIO_STA_TXUNDERR_Msk                   /*!<Transmit FIFO underrun error                  */
N#define SDIO_STA_RXOVERR_Pos           (5U)                                    
N#define SDIO_STA_RXOVERR_Msk           (0x1UL << SDIO_STA_RXOVERR_Pos)          /*!< 0x00000020 */
N#define SDIO_STA_RXOVERR               SDIO_STA_RXOVERR_Msk                    /*!<Received FIFO overrun error                   */
N#define SDIO_STA_CMDREND_Pos           (6U)                                    
N#define SDIO_STA_CMDREND_Msk           (0x1UL << SDIO_STA_CMDREND_Pos)          /*!< 0x00000040 */
N#define SDIO_STA_CMDREND               SDIO_STA_CMDREND_Msk                    /*!<Command response received (CRC check passed)  */
N#define SDIO_STA_CMDSENT_Pos           (7U)                                    
N#define SDIO_STA_CMDSENT_Msk           (0x1UL << SDIO_STA_CMDSENT_Pos)          /*!< 0x00000080 */
N#define SDIO_STA_CMDSENT               SDIO_STA_CMDSENT_Msk                    /*!<Command sent (no response required)           */
N#define SDIO_STA_DATAEND_Pos           (8U)                                    
N#define SDIO_STA_DATAEND_Msk           (0x1UL << SDIO_STA_DATAEND_Pos)          /*!< 0x00000100 */
N#define SDIO_STA_DATAEND               SDIO_STA_DATAEND_Msk                    /*!<Data end (data counter, SDIDCOUNT, is zero)   */
N#define SDIO_STA_STBITERR_Pos          (9U)                                    
N#define SDIO_STA_STBITERR_Msk          (0x1UL << SDIO_STA_STBITERR_Pos)         /*!< 0x00000200 */
N#define SDIO_STA_STBITERR              SDIO_STA_STBITERR_Msk                   /*!<Start bit not detected on all data signals in wide bus mode */
N#define SDIO_STA_DBCKEND_Pos           (10U)                                   
N#define SDIO_STA_DBCKEND_Msk           (0x1UL << SDIO_STA_DBCKEND_Pos)          /*!< 0x00000400 */
N#define SDIO_STA_DBCKEND               SDIO_STA_DBCKEND_Msk                    /*!<Data block sent/received (CRC check passed)   */
N#define SDIO_STA_CMDACT_Pos            (11U)                                   
N#define SDIO_STA_CMDACT_Msk            (0x1UL << SDIO_STA_CMDACT_Pos)           /*!< 0x00000800 */
N#define SDIO_STA_CMDACT                SDIO_STA_CMDACT_Msk                     /*!<Command transfer in progress                  */
N#define SDIO_STA_TXACT_Pos             (12U)                                   
N#define SDIO_STA_TXACT_Msk             (0x1UL << SDIO_STA_TXACT_Pos)            /*!< 0x00001000 */
N#define SDIO_STA_TXACT                 SDIO_STA_TXACT_Msk                      /*!<Data transmit in progress                     */
N#define SDIO_STA_RXACT_Pos             (13U)                                   
N#define SDIO_STA_RXACT_Msk             (0x1UL << SDIO_STA_RXACT_Pos)            /*!< 0x00002000 */
N#define SDIO_STA_RXACT                 SDIO_STA_RXACT_Msk                      /*!<Data receive in progress                      */
N#define SDIO_STA_TXFIFOHE_Pos          (14U)                                   
N#define SDIO_STA_TXFIFOHE_Msk          (0x1UL << SDIO_STA_TXFIFOHE_Pos)         /*!< 0x00004000 */
N#define SDIO_STA_TXFIFOHE              SDIO_STA_TXFIFOHE_Msk                   /*!<Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
N#define SDIO_STA_RXFIFOHF_Pos          (15U)                                   
N#define SDIO_STA_RXFIFOHF_Msk          (0x1UL << SDIO_STA_RXFIFOHF_Pos)         /*!< 0x00008000 */
N#define SDIO_STA_RXFIFOHF              SDIO_STA_RXFIFOHF_Msk                   /*!<Receive FIFO Half Full: there are at least 8 words in the FIFO */
N#define SDIO_STA_TXFIFOF_Pos           (16U)                                   
N#define SDIO_STA_TXFIFOF_Msk           (0x1UL << SDIO_STA_TXFIFOF_Pos)          /*!< 0x00010000 */
N#define SDIO_STA_TXFIFOF               SDIO_STA_TXFIFOF_Msk                    /*!<Transmit FIFO full                            */
N#define SDIO_STA_RXFIFOF_Pos           (17U)                                   
N#define SDIO_STA_RXFIFOF_Msk           (0x1UL << SDIO_STA_RXFIFOF_Pos)          /*!< 0x00020000 */
N#define SDIO_STA_RXFIFOF               SDIO_STA_RXFIFOF_Msk                    /*!<Receive FIFO full                             */
N#define SDIO_STA_TXFIFOE_Pos           (18U)                                   
N#define SDIO_STA_TXFIFOE_Msk           (0x1UL << SDIO_STA_TXFIFOE_Pos)          /*!< 0x00040000 */
N#define SDIO_STA_TXFIFOE               SDIO_STA_TXFIFOE_Msk                    /*!<Transmit FIFO empty                           */
N#define SDIO_STA_RXFIFOE_Pos           (19U)                                   
N#define SDIO_STA_RXFIFOE_Msk           (0x1UL << SDIO_STA_RXFIFOE_Pos)          /*!< 0x00080000 */
N#define SDIO_STA_RXFIFOE               SDIO_STA_RXFIFOE_Msk                    /*!<Receive FIFO empty                            */
N#define SDIO_STA_TXDAVL_Pos            (20U)                                   
N#define SDIO_STA_TXDAVL_Msk            (0x1UL << SDIO_STA_TXDAVL_Pos)           /*!< 0x00100000 */
N#define SDIO_STA_TXDAVL                SDIO_STA_TXDAVL_Msk                     /*!<Data available in transmit FIFO               */
N#define SDIO_STA_RXDAVL_Pos            (21U)                                   
N#define SDIO_STA_RXDAVL_Msk            (0x1UL << SDIO_STA_RXDAVL_Pos)           /*!< 0x00200000 */
N#define SDIO_STA_RXDAVL                SDIO_STA_RXDAVL_Msk                     /*!<Data available in receive FIFO                */
N#define SDIO_STA_SDIOIT_Pos            (22U)                                   
N#define SDIO_STA_SDIOIT_Msk            (0x1UL << SDIO_STA_SDIOIT_Pos)           /*!< 0x00400000 */
N#define SDIO_STA_SDIOIT                SDIO_STA_SDIOIT_Msk                     /*!<SDIO interrupt received                       */
N#define SDIO_STA_CEATAEND_Pos          (23U)                                   
N#define SDIO_STA_CEATAEND_Msk          (0x1UL << SDIO_STA_CEATAEND_Pos)         /*!< 0x00800000 */
N#define SDIO_STA_CEATAEND              SDIO_STA_CEATAEND_Msk                   /*!<CE-ATA command completion signal received for CMD61 */
N
N/*******************  Bit definition for SDIO_ICR register  *******************/
N#define SDIO_ICR_CCRCFAILC_Pos         (0U)                                    
N#define SDIO_ICR_CCRCFAILC_Msk         (0x1UL << SDIO_ICR_CCRCFAILC_Pos)        /*!< 0x00000001 */
N#define SDIO_ICR_CCRCFAILC             SDIO_ICR_CCRCFAILC_Msk                  /*!<CCRCFAIL flag clear bit */
N#define SDIO_ICR_DCRCFAILC_Pos         (1U)                                    
N#define SDIO_ICR_DCRCFAILC_Msk         (0x1UL << SDIO_ICR_DCRCFAILC_Pos)        /*!< 0x00000002 */
N#define SDIO_ICR_DCRCFAILC             SDIO_ICR_DCRCFAILC_Msk                  /*!<DCRCFAIL flag clear bit */
N#define SDIO_ICR_CTIMEOUTC_Pos         (2U)                                    
N#define SDIO_ICR_CTIMEOUTC_Msk         (0x1UL << SDIO_ICR_CTIMEOUTC_Pos)        /*!< 0x00000004 */
N#define SDIO_ICR_CTIMEOUTC             SDIO_ICR_CTIMEOUTC_Msk                  /*!<CTIMEOUT flag clear bit */
N#define SDIO_ICR_DTIMEOUTC_Pos         (3U)                                    
N#define SDIO_ICR_DTIMEOUTC_Msk         (0x1UL << SDIO_ICR_DTIMEOUTC_Pos)        /*!< 0x00000008 */
N#define SDIO_ICR_DTIMEOUTC             SDIO_ICR_DTIMEOUTC_Msk                  /*!<DTIMEOUT flag clear bit */
N#define SDIO_ICR_TXUNDERRC_Pos         (4U)                                    
N#define SDIO_ICR_TXUNDERRC_Msk         (0x1UL << SDIO_ICR_TXUNDERRC_Pos)        /*!< 0x00000010 */
N#define SDIO_ICR_TXUNDERRC             SDIO_ICR_TXUNDERRC_Msk                  /*!<TXUNDERR flag clear bit */
N#define SDIO_ICR_RXOVERRC_Pos          (5U)                                    
N#define SDIO_ICR_RXOVERRC_Msk          (0x1UL << SDIO_ICR_RXOVERRC_Pos)         /*!< 0x00000020 */
N#define SDIO_ICR_RXOVERRC              SDIO_ICR_RXOVERRC_Msk                   /*!<RXOVERR flag clear bit  */
N#define SDIO_ICR_CMDRENDC_Pos          (6U)                                    
N#define SDIO_ICR_CMDRENDC_Msk          (0x1UL << SDIO_ICR_CMDRENDC_Pos)         /*!< 0x00000040 */
N#define SDIO_ICR_CMDRENDC              SDIO_ICR_CMDRENDC_Msk                   /*!<CMDREND flag clear bit  */
N#define SDIO_ICR_CMDSENTC_Pos          (7U)                                    
N#define SDIO_ICR_CMDSENTC_Msk          (0x1UL << SDIO_ICR_CMDSENTC_Pos)         /*!< 0x00000080 */
N#define SDIO_ICR_CMDSENTC              SDIO_ICR_CMDSENTC_Msk                   /*!<CMDSENT flag clear bit  */
N#define SDIO_ICR_DATAENDC_Pos          (8U)                                    
N#define SDIO_ICR_DATAENDC_Msk          (0x1UL << SDIO_ICR_DATAENDC_Pos)         /*!< 0x00000100 */
N#define SDIO_ICR_DATAENDC              SDIO_ICR_DATAENDC_Msk                   /*!<DATAEND flag clear bit  */
N#define SDIO_ICR_STBITERRC_Pos         (9U)                                    
N#define SDIO_ICR_STBITERRC_Msk         (0x1UL << SDIO_ICR_STBITERRC_Pos)        /*!< 0x00000200 */
N#define SDIO_ICR_STBITERRC             SDIO_ICR_STBITERRC_Msk                  /*!<STBITERR flag clear bit */
N#define SDIO_ICR_DBCKENDC_Pos          (10U)                                   
N#define SDIO_ICR_DBCKENDC_Msk          (0x1UL << SDIO_ICR_DBCKENDC_Pos)         /*!< 0x00000400 */
N#define SDIO_ICR_DBCKENDC              SDIO_ICR_DBCKENDC_Msk                   /*!<DBCKEND flag clear bit  */
N#define SDIO_ICR_SDIOITC_Pos           (22U)                                   
N#define SDIO_ICR_SDIOITC_Msk           (0x1UL << SDIO_ICR_SDIOITC_Pos)          /*!< 0x00400000 */
N#define SDIO_ICR_SDIOITC               SDIO_ICR_SDIOITC_Msk                    /*!<SDIOIT flag clear bit   */
N#define SDIO_ICR_CEATAENDC_Pos         (23U)                                   
N#define SDIO_ICR_CEATAENDC_Msk         (0x1UL << SDIO_ICR_CEATAENDC_Pos)        /*!< 0x00800000 */
N#define SDIO_ICR_CEATAENDC             SDIO_ICR_CEATAENDC_Msk                  /*!<CEATAEND flag clear bit */
N
N/******************  Bit definition for SDIO_MASK register  *******************/
N#define SDIO_MASK_CCRCFAILIE_Pos       (0U)                                    
N#define SDIO_MASK_CCRCFAILIE_Msk       (0x1UL << SDIO_MASK_CCRCFAILIE_Pos)      /*!< 0x00000001 */
N#define SDIO_MASK_CCRCFAILIE           SDIO_MASK_CCRCFAILIE_Msk                /*!<Command CRC Fail Interrupt Enable          */
N#define SDIO_MASK_DCRCFAILIE_Pos       (1U)                                    
N#define SDIO_MASK_DCRCFAILIE_Msk       (0x1UL << SDIO_MASK_DCRCFAILIE_Pos)      /*!< 0x00000002 */
N#define SDIO_MASK_DCRCFAILIE           SDIO_MASK_DCRCFAILIE_Msk                /*!<Data CRC Fail Interrupt Enable             */
N#define SDIO_MASK_CTIMEOUTIE_Pos       (2U)                                    
N#define SDIO_MASK_CTIMEOUTIE_Msk       (0x1UL << SDIO_MASK_CTIMEOUTIE_Pos)      /*!< 0x00000004 */
N#define SDIO_MASK_CTIMEOUTIE           SDIO_MASK_CTIMEOUTIE_Msk                /*!<Command TimeOut Interrupt Enable           */
N#define SDIO_MASK_DTIMEOUTIE_Pos       (3U)                                    
N#define SDIO_MASK_DTIMEOUTIE_Msk       (0x1UL << SDIO_MASK_DTIMEOUTIE_Pos)      /*!< 0x00000008 */
N#define SDIO_MASK_DTIMEOUTIE           SDIO_MASK_DTIMEOUTIE_Msk                /*!<Data TimeOut Interrupt Enable              */
N#define SDIO_MASK_TXUNDERRIE_Pos       (4U)                                    
N#define SDIO_MASK_TXUNDERRIE_Msk       (0x1UL << SDIO_MASK_TXUNDERRIE_Pos)      /*!< 0x00000010 */
N#define SDIO_MASK_TXUNDERRIE           SDIO_MASK_TXUNDERRIE_Msk                /*!<Tx FIFO UnderRun Error Interrupt Enable    */
N#define SDIO_MASK_RXOVERRIE_Pos        (5U)                                    
N#define SDIO_MASK_RXOVERRIE_Msk        (0x1UL << SDIO_MASK_RXOVERRIE_Pos)       /*!< 0x00000020 */
N#define SDIO_MASK_RXOVERRIE            SDIO_MASK_RXOVERRIE_Msk                 /*!<Rx FIFO OverRun Error Interrupt Enable     */
N#define SDIO_MASK_CMDRENDIE_Pos        (6U)                                    
N#define SDIO_MASK_CMDRENDIE_Msk        (0x1UL << SDIO_MASK_CMDRENDIE_Pos)       /*!< 0x00000040 */
N#define SDIO_MASK_CMDRENDIE            SDIO_MASK_CMDRENDIE_Msk                 /*!<Command Response Received Interrupt Enable */
N#define SDIO_MASK_CMDSENTIE_Pos        (7U)                                    
N#define SDIO_MASK_CMDSENTIE_Msk        (0x1UL << SDIO_MASK_CMDSENTIE_Pos)       /*!< 0x00000080 */
N#define SDIO_MASK_CMDSENTIE            SDIO_MASK_CMDSENTIE_Msk                 /*!<Command Sent Interrupt Enable              */
N#define SDIO_MASK_DATAENDIE_Pos        (8U)                                    
N#define SDIO_MASK_DATAENDIE_Msk        (0x1UL << SDIO_MASK_DATAENDIE_Pos)       /*!< 0x00000100 */
N#define SDIO_MASK_DATAENDIE            SDIO_MASK_DATAENDIE_Msk                 /*!<Data End Interrupt Enable                  */
N#define SDIO_MASK_STBITERRIE_Pos       (9U)                                    
N#define SDIO_MASK_STBITERRIE_Msk       (0x1UL << SDIO_MASK_STBITERRIE_Pos)      /*!< 0x00000200 */
N#define SDIO_MASK_STBITERRIE           SDIO_MASK_STBITERRIE_Msk                /*!<Start Bit Error Interrupt Enable           */
N#define SDIO_MASK_DBCKENDIE_Pos        (10U)                                   
N#define SDIO_MASK_DBCKENDIE_Msk        (0x1UL << SDIO_MASK_DBCKENDIE_Pos)       /*!< 0x00000400 */
N#define SDIO_MASK_DBCKENDIE            SDIO_MASK_DBCKENDIE_Msk                 /*!<Data Block End Interrupt Enable            */
N#define SDIO_MASK_CMDACTIE_Pos         (11U)                                   
N#define SDIO_MASK_CMDACTIE_Msk         (0x1UL << SDIO_MASK_CMDACTIE_Pos)        /*!< 0x00000800 */
N#define SDIO_MASK_CMDACTIE             SDIO_MASK_CMDACTIE_Msk                  /*!<CCommand Acting Interrupt Enable           */
N#define SDIO_MASK_TXACTIE_Pos          (12U)                                   
N#define SDIO_MASK_TXACTIE_Msk          (0x1UL << SDIO_MASK_TXACTIE_Pos)         /*!< 0x00001000 */
N#define SDIO_MASK_TXACTIE              SDIO_MASK_TXACTIE_Msk                   /*!<Data Transmit Acting Interrupt Enable      */
N#define SDIO_MASK_RXACTIE_Pos          (13U)                                   
N#define SDIO_MASK_RXACTIE_Msk          (0x1UL << SDIO_MASK_RXACTIE_Pos)         /*!< 0x00002000 */
N#define SDIO_MASK_RXACTIE              SDIO_MASK_RXACTIE_Msk                   /*!<Data receive acting interrupt enabled      */
N#define SDIO_MASK_TXFIFOHEIE_Pos       (14U)                                   
N#define SDIO_MASK_TXFIFOHEIE_Msk       (0x1UL << SDIO_MASK_TXFIFOHEIE_Pos)      /*!< 0x00004000 */
N#define SDIO_MASK_TXFIFOHEIE           SDIO_MASK_TXFIFOHEIE_Msk                /*!<Tx FIFO Half Empty interrupt Enable        */
N#define SDIO_MASK_RXFIFOHFIE_Pos       (15U)                                   
N#define SDIO_MASK_RXFIFOHFIE_Msk       (0x1UL << SDIO_MASK_RXFIFOHFIE_Pos)      /*!< 0x00008000 */
N#define SDIO_MASK_RXFIFOHFIE           SDIO_MASK_RXFIFOHFIE_Msk                /*!<Rx FIFO Half Full interrupt Enable         */
N#define SDIO_MASK_TXFIFOFIE_Pos        (16U)                                   
N#define SDIO_MASK_TXFIFOFIE_Msk        (0x1UL << SDIO_MASK_TXFIFOFIE_Pos)       /*!< 0x00010000 */
N#define SDIO_MASK_TXFIFOFIE            SDIO_MASK_TXFIFOFIE_Msk                 /*!<Tx FIFO Full interrupt Enable              */
N#define SDIO_MASK_RXFIFOFIE_Pos        (17U)                                   
N#define SDIO_MASK_RXFIFOFIE_Msk        (0x1UL << SDIO_MASK_RXFIFOFIE_Pos)       /*!< 0x00020000 */
N#define SDIO_MASK_RXFIFOFIE            SDIO_MASK_RXFIFOFIE_Msk                 /*!<Rx FIFO Full interrupt Enable              */
N#define SDIO_MASK_TXFIFOEIE_Pos        (18U)                                   
N#define SDIO_MASK_TXFIFOEIE_Msk        (0x1UL << SDIO_MASK_TXFIFOEIE_Pos)       /*!< 0x00040000 */
N#define SDIO_MASK_TXFIFOEIE            SDIO_MASK_TXFIFOEIE_Msk                 /*!<Tx FIFO Empty interrupt Enable             */
N#define SDIO_MASK_RXFIFOEIE_Pos        (19U)                                   
N#define SDIO_MASK_RXFIFOEIE_Msk        (0x1UL << SDIO_MASK_RXFIFOEIE_Pos)       /*!< 0x00080000 */
N#define SDIO_MASK_RXFIFOEIE            SDIO_MASK_RXFIFOEIE_Msk                 /*!<Rx FIFO Empty interrupt Enable             */
N#define SDIO_MASK_TXDAVLIE_Pos         (20U)                                   
N#define SDIO_MASK_TXDAVLIE_Msk         (0x1UL << SDIO_MASK_TXDAVLIE_Pos)        /*!< 0x00100000 */
N#define SDIO_MASK_TXDAVLIE             SDIO_MASK_TXDAVLIE_Msk                  /*!<Data available in Tx FIFO interrupt Enable */
N#define SDIO_MASK_RXDAVLIE_Pos         (21U)                                   
N#define SDIO_MASK_RXDAVLIE_Msk         (0x1UL << SDIO_MASK_RXDAVLIE_Pos)        /*!< 0x00200000 */
N#define SDIO_MASK_RXDAVLIE             SDIO_MASK_RXDAVLIE_Msk                  /*!<Data available in Rx FIFO interrupt Enable */
N#define SDIO_MASK_SDIOITIE_Pos         (22U)                                   
N#define SDIO_MASK_SDIOITIE_Msk         (0x1UL << SDIO_MASK_SDIOITIE_Pos)        /*!< 0x00400000 */
N#define SDIO_MASK_SDIOITIE             SDIO_MASK_SDIOITIE_Msk                  /*!<SDIO Mode Interrupt Received interrupt Enable */
N#define SDIO_MASK_CEATAENDIE_Pos       (23U)                                   
N#define SDIO_MASK_CEATAENDIE_Msk       (0x1UL << SDIO_MASK_CEATAENDIE_Pos)      /*!< 0x00800000 */
N#define SDIO_MASK_CEATAENDIE           SDIO_MASK_CEATAENDIE_Msk                /*!<CE-ATA command completion signal received Interrupt Enable */
N
N/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
N#define SDIO_FIFOCNT_FIFOCOUNT_Pos     (0U)                                    
N#define SDIO_FIFOCNT_FIFOCOUNT_Msk     (0xFFFFFFUL << SDIO_FIFOCNT_FIFOCOUNT_Pos) /*!< 0x00FFFFFF */
N#define SDIO_FIFOCNT_FIFOCOUNT         SDIO_FIFOCNT_FIFOCOUNT_Msk              /*!<Remaining number of words to be written to or read from the FIFO */
N
N/******************  Bit definition for SDIO_FIFO register  *******************/
N#define SDIO_FIFO_FIFODATA_Pos         (0U)                                    
N#define SDIO_FIFO_FIFODATA_Msk         (0xFFFFFFFFUL << SDIO_FIFO_FIFODATA_Pos) /*!< 0xFFFFFFFF */
N#define SDIO_FIFO_FIFODATA             SDIO_FIFO_FIFODATA_Msk                  /*!<Receive and transmit FIFO data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface                         */
N/*                                                                            */
N/******************************************************************************/
N#define SPI_I2S_FULLDUPLEX_SUPPORT                                             /*!< I2S Full-Duplex support */
N
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define SPI_CR1_CPHA_Pos            (0U)                                       
N#define SPI_CR1_CPHA_Msk            (0x1UL << SPI_CR1_CPHA_Pos)                 /*!< 0x00000001 */
N#define SPI_CR1_CPHA                SPI_CR1_CPHA_Msk                           /*!<Clock Phase      */
N#define SPI_CR1_CPOL_Pos            (1U)                                       
N#define SPI_CR1_CPOL_Msk            (0x1UL << SPI_CR1_CPOL_Pos)                 /*!< 0x00000002 */
N#define SPI_CR1_CPOL                SPI_CR1_CPOL_Msk                           /*!<Clock Polarity   */
N#define SPI_CR1_MSTR_Pos            (2U)                                       
N#define SPI_CR1_MSTR_Msk            (0x1UL << SPI_CR1_MSTR_Pos)                 /*!< 0x00000004 */
N#define SPI_CR1_MSTR                SPI_CR1_MSTR_Msk                           /*!<Master Selection */
N
N#define SPI_CR1_BR_Pos              (3U)                                       
N#define SPI_CR1_BR_Msk              (0x7UL << SPI_CR1_BR_Pos)                   /*!< 0x00000038 */
N#define SPI_CR1_BR                  SPI_CR1_BR_Msk                             /*!<BR[2:0] bits (Baud Rate Control) */
N#define SPI_CR1_BR_0                (0x1UL << SPI_CR1_BR_Pos)                   /*!< 0x00000008 */
N#define SPI_CR1_BR_1                (0x2UL << SPI_CR1_BR_Pos)                   /*!< 0x00000010 */
N#define SPI_CR1_BR_2                (0x4UL << SPI_CR1_BR_Pos)                   /*!< 0x00000020 */
N
N#define SPI_CR1_SPE_Pos             (6U)                                       
N#define SPI_CR1_SPE_Msk             (0x1UL << SPI_CR1_SPE_Pos)                  /*!< 0x00000040 */
N#define SPI_CR1_SPE                 SPI_CR1_SPE_Msk                            /*!<SPI Enable                          */
N#define SPI_CR1_LSBFIRST_Pos        (7U)                                       
N#define SPI_CR1_LSBFIRST_Msk        (0x1UL << SPI_CR1_LSBFIRST_Pos)             /*!< 0x00000080 */
N#define SPI_CR1_LSBFIRST            SPI_CR1_LSBFIRST_Msk                       /*!<Frame Format                        */
N#define SPI_CR1_SSI_Pos             (8U)                                       
N#define SPI_CR1_SSI_Msk             (0x1UL << SPI_CR1_SSI_Pos)                  /*!< 0x00000100 */
N#define SPI_CR1_SSI                 SPI_CR1_SSI_Msk                            /*!<Internal slave select               */
N#define SPI_CR1_SSM_Pos             (9U)                                       
N#define SPI_CR1_SSM_Msk             (0x1UL << SPI_CR1_SSM_Pos)                  /*!< 0x00000200 */
N#define SPI_CR1_SSM                 SPI_CR1_SSM_Msk                            /*!<Software slave management           */
N#define SPI_CR1_RXONLY_Pos          (10U)                                      
N#define SPI_CR1_RXONLY_Msk          (0x1UL << SPI_CR1_RXONLY_Pos)               /*!< 0x00000400 */
N#define SPI_CR1_RXONLY              SPI_CR1_RXONLY_Msk                         /*!<Receive only                        */
N#define SPI_CR1_DFF_Pos             (11U)                                      
N#define SPI_CR1_DFF_Msk             (0x1UL << SPI_CR1_DFF_Pos)                  /*!< 0x00000800 */
N#define SPI_CR1_DFF                 SPI_CR1_DFF_Msk                            /*!<Data Frame Format                   */
N#define SPI_CR1_CRCNEXT_Pos         (12U)                                      
N#define SPI_CR1_CRCNEXT_Msk         (0x1UL << SPI_CR1_CRCNEXT_Pos)              /*!< 0x00001000 */
N#define SPI_CR1_CRCNEXT             SPI_CR1_CRCNEXT_Msk                        /*!<Transmit CRC next                   */
N#define SPI_CR1_CRCEN_Pos           (13U)                                      
N#define SPI_CR1_CRCEN_Msk           (0x1UL << SPI_CR1_CRCEN_Pos)                /*!< 0x00002000 */
N#define SPI_CR1_CRCEN               SPI_CR1_CRCEN_Msk                          /*!<Hardware CRC calculation enable     */
N#define SPI_CR1_BIDIOE_Pos          (14U)                                      
N#define SPI_CR1_BIDIOE_Msk          (0x1UL << SPI_CR1_BIDIOE_Pos)               /*!< 0x00004000 */
N#define SPI_CR1_BIDIOE              SPI_CR1_BIDIOE_Msk                         /*!<Output enable in bidirectional mode */
N#define SPI_CR1_BIDIMODE_Pos        (15U)                                      
N#define SPI_CR1_BIDIMODE_Msk        (0x1UL << SPI_CR1_BIDIMODE_Pos)             /*!< 0x00008000 */
N#define SPI_CR1_BIDIMODE            SPI_CR1_BIDIMODE_Msk                       /*!<Bidirectional data mode enable      */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define SPI_CR2_RXDMAEN_Pos         (0U)                                       
N#define SPI_CR2_RXDMAEN_Msk         (0x1UL << SPI_CR2_RXDMAEN_Pos)              /*!< 0x00000001 */
N#define SPI_CR2_RXDMAEN             SPI_CR2_RXDMAEN_Msk                        /*!<Rx Buffer DMA Enable                 */
N#define SPI_CR2_TXDMAEN_Pos         (1U)                                       
N#define SPI_CR2_TXDMAEN_Msk         (0x1UL << SPI_CR2_TXDMAEN_Pos)              /*!< 0x00000002 */
N#define SPI_CR2_TXDMAEN             SPI_CR2_TXDMAEN_Msk                        /*!<Tx Buffer DMA Enable                 */
N#define SPI_CR2_SSOE_Pos            (2U)                                       
N#define SPI_CR2_SSOE_Msk            (0x1UL << SPI_CR2_SSOE_Pos)                 /*!< 0x00000004 */
N#define SPI_CR2_SSOE                SPI_CR2_SSOE_Msk                           /*!<SS Output Enable                     */
N#define SPI_CR2_FRF_Pos             (4U)                                       
N#define SPI_CR2_FRF_Msk             (0x1UL << SPI_CR2_FRF_Pos)                  /*!< 0x00000010 */
N#define SPI_CR2_FRF                 SPI_CR2_FRF_Msk                            /*!<Frame Format                         */
N#define SPI_CR2_ERRIE_Pos           (5U)                                       
N#define SPI_CR2_ERRIE_Msk           (0x1UL << SPI_CR2_ERRIE_Pos)                /*!< 0x00000020 */
N#define SPI_CR2_ERRIE               SPI_CR2_ERRIE_Msk                          /*!<Error Interrupt Enable               */
N#define SPI_CR2_RXNEIE_Pos          (6U)                                       
N#define SPI_CR2_RXNEIE_Msk          (0x1UL << SPI_CR2_RXNEIE_Pos)               /*!< 0x00000040 */
N#define SPI_CR2_RXNEIE              SPI_CR2_RXNEIE_Msk                         /*!<RX buffer Not Empty Interrupt Enable */
N#define SPI_CR2_TXEIE_Pos           (7U)                                       
N#define SPI_CR2_TXEIE_Msk           (0x1UL << SPI_CR2_TXEIE_Pos)                /*!< 0x00000080 */
N#define SPI_CR2_TXEIE               SPI_CR2_TXEIE_Msk                          /*!<Tx buffer Empty Interrupt Enable     */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define SPI_SR_RXNE_Pos             (0U)                                       
N#define SPI_SR_RXNE_Msk             (0x1UL << SPI_SR_RXNE_Pos)                  /*!< 0x00000001 */
N#define SPI_SR_RXNE                 SPI_SR_RXNE_Msk                            /*!<Receive buffer Not Empty */
N#define SPI_SR_TXE_Pos              (1U)                                       
N#define SPI_SR_TXE_Msk              (0x1UL << SPI_SR_TXE_Pos)                   /*!< 0x00000002 */
N#define SPI_SR_TXE                  SPI_SR_TXE_Msk                             /*!<Transmit buffer Empty    */
N#define SPI_SR_CHSIDE_Pos           (2U)                                       
N#define SPI_SR_CHSIDE_Msk           (0x1UL << SPI_SR_CHSIDE_Pos)                /*!< 0x00000004 */
N#define SPI_SR_CHSIDE               SPI_SR_CHSIDE_Msk                          /*!<Channel side             */
N#define SPI_SR_UDR_Pos              (3U)                                       
N#define SPI_SR_UDR_Msk              (0x1UL << SPI_SR_UDR_Pos)                   /*!< 0x00000008 */
N#define SPI_SR_UDR                  SPI_SR_UDR_Msk                             /*!<Underrun flag            */
N#define SPI_SR_CRCERR_Pos           (4U)                                       
N#define SPI_SR_CRCERR_Msk           (0x1UL << SPI_SR_CRCERR_Pos)                /*!< 0x00000010 */
N#define SPI_SR_CRCERR               SPI_SR_CRCERR_Msk                          /*!<CRC Error flag           */
N#define SPI_SR_MODF_Pos             (5U)                                       
N#define SPI_SR_MODF_Msk             (0x1UL << SPI_SR_MODF_Pos)                  /*!< 0x00000020 */
N#define SPI_SR_MODF                 SPI_SR_MODF_Msk                            /*!<Mode fault               */
N#define SPI_SR_OVR_Pos              (6U)                                       
N#define SPI_SR_OVR_Msk              (0x1UL << SPI_SR_OVR_Pos)                   /*!< 0x00000040 */
N#define SPI_SR_OVR                  SPI_SR_OVR_Msk                             /*!<Overrun flag             */
N#define SPI_SR_BSY_Pos              (7U)                                       
N#define SPI_SR_BSY_Msk              (0x1UL << SPI_SR_BSY_Pos)                   /*!< 0x00000080 */
N#define SPI_SR_BSY                  SPI_SR_BSY_Msk                             /*!<Busy flag                */
N#define SPI_SR_FRE_Pos              (8U)                                       
N#define SPI_SR_FRE_Msk              (0x1UL << SPI_SR_FRE_Pos)                   /*!< 0x00000100 */
N#define SPI_SR_FRE                  SPI_SR_FRE_Msk                             /*!<Frame format error flag  */
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define SPI_DR_DR_Pos               (0U)                                       
N#define SPI_DR_DR_Msk               (0xFFFFUL << SPI_DR_DR_Pos)                 /*!< 0x0000FFFF */
N#define SPI_DR_DR                   SPI_DR_DR_Msk                              /*!<Data Register           */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define SPI_CRCPR_CRCPOLY_Pos       (0U)                                       
N#define SPI_CRCPR_CRCPOLY_Msk       (0xFFFFUL << SPI_CRCPR_CRCPOLY_Pos)         /*!< 0x0000FFFF */
N#define SPI_CRCPR_CRCPOLY           SPI_CRCPR_CRCPOLY_Msk                      /*!<CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define SPI_RXCRCR_RXCRC_Pos        (0U)                                       
N#define SPI_RXCRCR_RXCRC_Msk        (0xFFFFUL << SPI_RXCRCR_RXCRC_Pos)          /*!< 0x0000FFFF */
N#define SPI_RXCRCR_RXCRC            SPI_RXCRCR_RXCRC_Msk                       /*!<Rx CRC Register         */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define SPI_TXCRCR_TXCRC_Pos        (0U)                                       
N#define SPI_TXCRCR_TXCRC_Msk        (0xFFFFUL << SPI_TXCRCR_TXCRC_Pos)          /*!< 0x0000FFFF */
N#define SPI_TXCRCR_TXCRC            SPI_TXCRCR_TXCRC_Msk                       /*!<Tx CRC Register         */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N#define SPI_I2SCFGR_CHLEN_Pos       (0U)                                       
N#define SPI_I2SCFGR_CHLEN_Msk       (0x1UL << SPI_I2SCFGR_CHLEN_Pos)            /*!< 0x00000001 */
N#define SPI_I2SCFGR_CHLEN           SPI_I2SCFGR_CHLEN_Msk                      /*!<Channel length (number of bits per audio channel) */
N
N#define SPI_I2SCFGR_DATLEN_Pos      (1U)                                       
N#define SPI_I2SCFGR_DATLEN_Msk      (0x3UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000006 */
N#define SPI_I2SCFGR_DATLEN          SPI_I2SCFGR_DATLEN_Msk                     /*!<DATLEN[1:0] bits (Data length to be transferred)  */
N#define SPI_I2SCFGR_DATLEN_0        (0x1UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000002 */
N#define SPI_I2SCFGR_DATLEN_1        (0x2UL << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000004 */
N
N#define SPI_I2SCFGR_CKPOL_Pos       (3U)                                       
N#define SPI_I2SCFGR_CKPOL_Msk       (0x1UL << SPI_I2SCFGR_CKPOL_Pos)            /*!< 0x00000008 */
N#define SPI_I2SCFGR_CKPOL           SPI_I2SCFGR_CKPOL_Msk                      /*!<steady state clock polarity               */
N
N#define SPI_I2SCFGR_I2SSTD_Pos      (4U)                                       
N#define SPI_I2SCFGR_I2SSTD_Msk      (0x3UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000030 */
N#define SPI_I2SCFGR_I2SSTD          SPI_I2SCFGR_I2SSTD_Msk                     /*!<I2SSTD[1:0] bits (I2S standard selection) */
N#define SPI_I2SCFGR_I2SSTD_0        (0x1UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000010 */
N#define SPI_I2SCFGR_I2SSTD_1        (0x2UL << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000020 */
N
N#define SPI_I2SCFGR_PCMSYNC_Pos     (7U)                                       
N#define SPI_I2SCFGR_PCMSYNC_Msk     (0x1UL << SPI_I2SCFGR_PCMSYNC_Pos)          /*!< 0x00000080 */
N#define SPI_I2SCFGR_PCMSYNC         SPI_I2SCFGR_PCMSYNC_Msk                    /*!<PCM frame synchronization                 */
N
N#define SPI_I2SCFGR_I2SCFG_Pos      (8U)                                       
N#define SPI_I2SCFGR_I2SCFG_Msk      (0x3UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000300 */
N#define SPI_I2SCFGR_I2SCFG          SPI_I2SCFGR_I2SCFG_Msk                     /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N#define SPI_I2SCFGR_I2SCFG_0        (0x1UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000100 */
N#define SPI_I2SCFGR_I2SCFG_1        (0x2UL << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000200 */
N
N#define SPI_I2SCFGR_I2SE_Pos        (10U)                                      
N#define SPI_I2SCFGR_I2SE_Msk        (0x1UL << SPI_I2SCFGR_I2SE_Pos)             /*!< 0x00000400 */
N#define SPI_I2SCFGR_I2SE            SPI_I2SCFGR_I2SE_Msk                       /*!<I2S Enable         */
N#define SPI_I2SCFGR_I2SMOD_Pos      (11U)                                      
N#define SPI_I2SCFGR_I2SMOD_Msk      (0x1UL << SPI_I2SCFGR_I2SMOD_Pos)           /*!< 0x00000800 */
N#define SPI_I2SCFGR_I2SMOD          SPI_I2SCFGR_I2SMOD_Msk                     /*!<I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N#define SPI_I2SPR_I2SDIV_Pos        (0U)                                       
N#define SPI_I2SPR_I2SDIV_Msk        (0xFFUL << SPI_I2SPR_I2SDIV_Pos)            /*!< 0x000000FF */
N#define SPI_I2SPR_I2SDIV            SPI_I2SPR_I2SDIV_Msk                       /*!<I2S Linear prescaler         */
N#define SPI_I2SPR_ODD_Pos           (8U)                                       
N#define SPI_I2SPR_ODD_Msk           (0x1UL << SPI_I2SPR_ODD_Pos)                /*!< 0x00000100 */
N#define SPI_I2SPR_ODD               SPI_I2SPR_ODD_Msk                          /*!<Odd factor for the prescaler */
N#define SPI_I2SPR_MCKOE_Pos         (9U)                                       
N#define SPI_I2SPR_MCKOE_Msk         (0x1UL << SPI_I2SPR_MCKOE_Pos)              /*!< 0x00000200 */
N#define SPI_I2SPR_MCKOE             SPI_I2SPR_MCKOE_Msk                        /*!<Master Clock Output Enable   */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 SYSCFG                                     */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SYSCFG_MEMRMP register  ***************/
N#define SYSCFG_MEMRMP_MEM_MODE_Pos           (0U)                              
N#define SYSCFG_MEMRMP_MEM_MODE_Msk           (0x3UL << SYSCFG_MEMRMP_MEM_MODE_Pos) /*!< 0x00000003 */
N#define SYSCFG_MEMRMP_MEM_MODE               SYSCFG_MEMRMP_MEM_MODE_Msk        /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_MEMRMP_MEM_MODE_0             (0x1UL << SYSCFG_MEMRMP_MEM_MODE_Pos) /*!< 0x00000001 */
N#define SYSCFG_MEMRMP_MEM_MODE_1             (0x2UL << SYSCFG_MEMRMP_MEM_MODE_Pos) /*!< 0x00000002 */
N/******************  Bit definition for SYSCFG_PMC register  ******************/
N#define SYSCFG_PMC_ADC1DC2_Pos               (16U)                             
N#define SYSCFG_PMC_ADC1DC2_Msk               (0x1UL << SYSCFG_PMC_ADC1DC2_Pos)  /*!< 0x00010000 */
N#define SYSCFG_PMC_ADC1DC2                   SYSCFG_PMC_ADC1DC2_Msk            /*!< Refer to AN4073 on how to use this bit  */
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0_Pos             (0U)                              
N#define SYSCFG_EXTICR1_EXTI0_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI0_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR1_EXTI0                 SYSCFG_EXTICR1_EXTI0_Msk          /*!<EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1_Pos             (4U)                              
N#define SYSCFG_EXTICR1_EXTI1_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI1_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR1_EXTI1                 SYSCFG_EXTICR1_EXTI1_Msk          /*!<EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2_Pos             (8U)                              
N#define SYSCFG_EXTICR1_EXTI2_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI2_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR1_EXTI2                 SYSCFG_EXTICR1_EXTI2_Msk          /*!<EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3_Pos             (12U)                             
N#define SYSCFG_EXTICR1_EXTI3_Msk             (0xFUL << SYSCFG_EXTICR1_EXTI3_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR1_EXTI3                 SYSCFG_EXTICR1_EXTI3_Msk          /*!<EXTI 3 configuration */
N/**
N  * @brief   EXTI0 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI0_PA              0x0000U                           /*!<PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB              0x0001U                           /*!<PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC              0x0002U                           /*!<PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD              0x0003U                           /*!<PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PE              0x0004U                           /*!<PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PH              0x0007U                           /*!<PH[0] pin */
N
N/**
N  * @brief   EXTI1 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI1_PA              0x0000U                           /*!<PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB              0x0010U                           /*!<PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC              0x0020U                           /*!<PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD              0x0030U                           /*!<PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PE              0x0040U                           /*!<PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PH              0x0070U                           /*!<PH[1] pin */
N
N/**
N  * @brief   EXTI2 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI2_PA              0x0000U                           /*!<PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB              0x0100U                           /*!<PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC              0x0200U                           /*!<PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD              0x0300U                           /*!<PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PE              0x0400U                           /*!<PE[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PH              0x0700U                           /*!<PH[2] pin */
N
N/**
N  * @brief   EXTI3 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI3_PA              0x0000U                           /*!<PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB              0x1000U                           /*!<PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC              0x2000U                           /*!<PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD              0x3000U                           /*!<PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PE              0x4000U                           /*!<PE[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PH              0x7000U                           /*!<PH[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  ***************/
N#define SYSCFG_EXTICR2_EXTI4_Pos             (0U)                              
N#define SYSCFG_EXTICR2_EXTI4_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI4_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR2_EXTI4                 SYSCFG_EXTICR2_EXTI4_Msk          /*!<EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5_Pos             (4U)                              
N#define SYSCFG_EXTICR2_EXTI5_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI5_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR2_EXTI5                 SYSCFG_EXTICR2_EXTI5_Msk          /*!<EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6_Pos             (8U)                              
N#define SYSCFG_EXTICR2_EXTI6_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI6_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR2_EXTI6                 SYSCFG_EXTICR2_EXTI6_Msk          /*!<EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7_Pos             (12U)                             
N#define SYSCFG_EXTICR2_EXTI7_Msk             (0xFUL << SYSCFG_EXTICR2_EXTI7_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR2_EXTI7                 SYSCFG_EXTICR2_EXTI7_Msk          /*!<EXTI 7 configuration */
N
N/**
N  * @brief   EXTI4 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI4_PA              0x0000U                           /*!<PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB              0x0001U                           /*!<PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC              0x0002U                           /*!<PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD              0x0003U                           /*!<PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PE              0x0004U                           /*!<PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PH              0x0007U                           /*!<PH[4] pin */
N
N/**
N  * @brief   EXTI5 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI5_PA              0x0000U                           /*!<PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB              0x0010U                           /*!<PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC              0x0020U                           /*!<PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD              0x0030U                           /*!<PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PE              0x0040U                           /*!<PE[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PH              0x0070U                           /*!<PH[5] pin */
N
N/**
N  * @brief   EXTI6 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI6_PA              0x0000U                           /*!<PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB              0x0100U                           /*!<PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC              0x0200U                           /*!<PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD              0x0300U                           /*!<PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PE              0x0400U                           /*!<PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PH              0x0700U                           /*!<PH[6] pin */
N
N/**
N  * @brief   EXTI7 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI7_PA              0x0000U                           /*!<PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB              0x1000U                           /*!<PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC              0x2000U                           /*!<PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD              0x3000U                           /*!<PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PE              0x4000U                           /*!<PE[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PH              0x7000U                           /*!<PH[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  ***************/
N#define SYSCFG_EXTICR3_EXTI8_Pos             (0U)                              
N#define SYSCFG_EXTICR3_EXTI8_Msk             (0xFUL << SYSCFG_EXTICR3_EXTI8_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR3_EXTI8                 SYSCFG_EXTICR3_EXTI8_Msk          /*!<EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9_Pos             (4U)                              
N#define SYSCFG_EXTICR3_EXTI9_Msk             (0xFUL << SYSCFG_EXTICR3_EXTI9_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR3_EXTI9                 SYSCFG_EXTICR3_EXTI9_Msk          /*!<EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10_Pos            (8U)                              
N#define SYSCFG_EXTICR3_EXTI10_Msk            (0xFUL << SYSCFG_EXTICR3_EXTI10_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR3_EXTI10                SYSCFG_EXTICR3_EXTI10_Msk         /*!<EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11_Pos            (12U)                             
N#define SYSCFG_EXTICR3_EXTI11_Msk            (0xFUL << SYSCFG_EXTICR3_EXTI11_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR3_EXTI11                SYSCFG_EXTICR3_EXTI11_Msk         /*!<EXTI 11 configuration */
N
N/**
N  * @brief   EXTI8 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI8_PA              0x0000U                           /*!<PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB              0x0001U                           /*!<PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC              0x0002U                           /*!<PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD              0x0003U                           /*!<PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PE              0x0004U                           /*!<PE[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PH              0x0007U                           /*!<PH[8] pin */
N
N/**
N  * @brief   EXTI9 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI9_PA              0x0000U                           /*!<PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB              0x0010U                           /*!<PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC              0x0020U                           /*!<PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD              0x0030U                           /*!<PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PE              0x0040U                           /*!<PE[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PH              0x0070U                           /*!<PH[9] pin */
N
N/**
N  * @brief   EXTI10 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI10_PA             0x0000U                           /*!<PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB             0x0100U                           /*!<PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC             0x0200U                           /*!<PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD             0x0300U                           /*!<PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PE             0x0400U                           /*!<PE[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PH             0x0700U                           /*!<PH[10] pin */
N
N/**
N  * @brief   EXTI11 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI11_PA             0x0000U                           /*!<PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB             0x1000U                           /*!<PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC             0x2000U                           /*!<PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD             0x3000U                           /*!<PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PE             0x4000U                           /*!<PE[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PH             0x7000U                           /*!<PH[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  ***************/
N#define SYSCFG_EXTICR4_EXTI12_Pos            (0U)                              
N#define SYSCFG_EXTICR4_EXTI12_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI12_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR4_EXTI12                SYSCFG_EXTICR4_EXTI12_Msk         /*!<EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13_Pos            (4U)                              
N#define SYSCFG_EXTICR4_EXTI13_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI13_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR4_EXTI13                SYSCFG_EXTICR4_EXTI13_Msk         /*!<EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14_Pos            (8U)                              
N#define SYSCFG_EXTICR4_EXTI14_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI14_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR4_EXTI14                SYSCFG_EXTICR4_EXTI14_Msk         /*!<EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15_Pos            (12U)                             
N#define SYSCFG_EXTICR4_EXTI15_Msk            (0xFUL << SYSCFG_EXTICR4_EXTI15_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR4_EXTI15                SYSCFG_EXTICR4_EXTI15_Msk         /*!<EXTI 15 configuration */
N
N/**
N  * @brief   EXTI12 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI12_PA             0x0000U                           /*!<PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB             0x0001U                           /*!<PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC             0x0002U                           /*!<PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD             0x0003U                           /*!<PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PE             0x0004U                           /*!<PE[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PH             0x0007U                           /*!<PH[12] pin */
N
N/**
N  * @brief   EXTI13 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI13_PA             0x0000U                           /*!<PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB             0x0010U                           /*!<PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC             0x0020U                           /*!<PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD             0x0030U                           /*!<PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PE             0x0040U                           /*!<PE[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PH             0x0070U                           /*!<PH[13] pin */
N
N/**
N  * @brief   EXTI14 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI14_PA             0x0000U                           /*!<PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB             0x0100U                           /*!<PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC             0x0200U                           /*!<PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD             0x0300U                           /*!<PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PE             0x0400U                           /*!<PE[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PH             0x0700U                           /*!<PH[14] pin */
N
N/**
N  * @brief   EXTI15 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI15_PA             0x0000U                           /*!<PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB             0x1000U                           /*!<PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC             0x2000U                           /*!<PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD             0x3000U                           /*!<PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PE             0x4000U                           /*!<PE[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PH             0x7000U                           /*!<PH[15] pin */
N
N/******************  Bit definition for SYSCFG_CMPCR register  ****************/
N#define SYSCFG_CMPCR_CMP_PD_Pos              (0U)                              
N#define SYSCFG_CMPCR_CMP_PD_Msk              (0x1UL << SYSCFG_CMPCR_CMP_PD_Pos) /*!< 0x00000001 */
N#define SYSCFG_CMPCR_CMP_PD                  SYSCFG_CMPCR_CMP_PD_Msk           /*!<Compensation cell ready flag */
N#define SYSCFG_CMPCR_READY_Pos               (8U)                              
N#define SYSCFG_CMPCR_READY_Msk               (0x1UL << SYSCFG_CMPCR_READY_Pos)  /*!< 0x00000100 */
N#define SYSCFG_CMPCR_READY                   SYSCFG_CMPCR_READY_Msk            /*!<Compensation cell power-down */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    TIM                                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define TIM_CR1_CEN_Pos           (0U)                                         
N#define TIM_CR1_CEN_Msk           (0x1UL << TIM_CR1_CEN_Pos)                    /*!< 0x00000001 */
N#define TIM_CR1_CEN               TIM_CR1_CEN_Msk                              /*!<Counter enable        */
N#define TIM_CR1_UDIS_Pos          (1U)                                         
N#define TIM_CR1_UDIS_Msk          (0x1UL << TIM_CR1_UDIS_Pos)                   /*!< 0x00000002 */
N#define TIM_CR1_UDIS              TIM_CR1_UDIS_Msk                             /*!<Update disable        */
N#define TIM_CR1_URS_Pos           (2U)                                         
N#define TIM_CR1_URS_Msk           (0x1UL << TIM_CR1_URS_Pos)                    /*!< 0x00000004 */
N#define TIM_CR1_URS               TIM_CR1_URS_Msk                              /*!<Update request source */
N#define TIM_CR1_OPM_Pos           (3U)                                         
N#define TIM_CR1_OPM_Msk           (0x1UL << TIM_CR1_OPM_Pos)                    /*!< 0x00000008 */
N#define TIM_CR1_OPM               TIM_CR1_OPM_Msk                              /*!<One pulse mode        */
N#define TIM_CR1_DIR_Pos           (4U)                                         
N#define TIM_CR1_DIR_Msk           (0x1UL << TIM_CR1_DIR_Pos)                    /*!< 0x00000010 */
N#define TIM_CR1_DIR               TIM_CR1_DIR_Msk                              /*!<Direction             */
N
N#define TIM_CR1_CMS_Pos           (5U)                                         
N#define TIM_CR1_CMS_Msk           (0x3UL << TIM_CR1_CMS_Pos)                    /*!< 0x00000060 */
N#define TIM_CR1_CMS               TIM_CR1_CMS_Msk                              /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define TIM_CR1_CMS_0             (0x1UL << TIM_CR1_CMS_Pos)                    /*!< 0x0020 */
N#define TIM_CR1_CMS_1             (0x2UL << TIM_CR1_CMS_Pos)                    /*!< 0x0040 */
N
N#define TIM_CR1_ARPE_Pos          (7U)                                         
N#define TIM_CR1_ARPE_Msk          (0x1UL << TIM_CR1_ARPE_Pos)                   /*!< 0x00000080 */
N#define TIM_CR1_ARPE              TIM_CR1_ARPE_Msk                             /*!<Auto-reload preload enable     */
N
N#define TIM_CR1_CKD_Pos           (8U)                                         
N#define TIM_CR1_CKD_Msk           (0x3UL << TIM_CR1_CKD_Pos)                    /*!< 0x00000300 */
N#define TIM_CR1_CKD               TIM_CR1_CKD_Msk                              /*!<CKD[1:0] bits (clock division) */
N#define TIM_CR1_CKD_0             (0x1UL << TIM_CR1_CKD_Pos)                    /*!< 0x0100 */
N#define TIM_CR1_CKD_1             (0x2UL << TIM_CR1_CKD_Pos)                    /*!< 0x0200 */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define TIM_CR2_CCPC_Pos          (0U)                                         
N#define TIM_CR2_CCPC_Msk          (0x1UL << TIM_CR2_CCPC_Pos)                   /*!< 0x00000001 */
N#define TIM_CR2_CCPC              TIM_CR2_CCPC_Msk                             /*!<Capture/Compare Preloaded Control        */
N#define TIM_CR2_CCUS_Pos          (2U)                                         
N#define TIM_CR2_CCUS_Msk          (0x1UL << TIM_CR2_CCUS_Pos)                   /*!< 0x00000004 */
N#define TIM_CR2_CCUS              TIM_CR2_CCUS_Msk                             /*!<Capture/Compare Control Update Selection */
N#define TIM_CR2_CCDS_Pos          (3U)                                         
N#define TIM_CR2_CCDS_Msk          (0x1UL << TIM_CR2_CCDS_Pos)                   /*!< 0x00000008 */
N#define TIM_CR2_CCDS              TIM_CR2_CCDS_Msk                             /*!<Capture/Compare DMA Selection            */
N
N#define TIM_CR2_MMS_Pos           (4U)                                         
N#define TIM_CR2_MMS_Msk           (0x7UL << TIM_CR2_MMS_Pos)                    /*!< 0x00000070 */
N#define TIM_CR2_MMS               TIM_CR2_MMS_Msk                              /*!<MMS[2:0] bits (Master Mode Selection) */
N#define TIM_CR2_MMS_0             (0x1UL << TIM_CR2_MMS_Pos)                    /*!< 0x0010 */
N#define TIM_CR2_MMS_1             (0x2UL << TIM_CR2_MMS_Pos)                    /*!< 0x0020 */
N#define TIM_CR2_MMS_2             (0x4UL << TIM_CR2_MMS_Pos)                    /*!< 0x0040 */
N
N#define TIM_CR2_TI1S_Pos          (7U)                                         
N#define TIM_CR2_TI1S_Msk          (0x1UL << TIM_CR2_TI1S_Pos)                   /*!< 0x00000080 */
N#define TIM_CR2_TI1S              TIM_CR2_TI1S_Msk                             /*!<TI1 Selection */
N#define TIM_CR2_OIS1_Pos          (8U)                                         
N#define TIM_CR2_OIS1_Msk          (0x1UL << TIM_CR2_OIS1_Pos)                   /*!< 0x00000100 */
N#define TIM_CR2_OIS1              TIM_CR2_OIS1_Msk                             /*!<Output Idle state 1 (OC1 output)  */
N#define TIM_CR2_OIS1N_Pos         (9U)                                         
N#define TIM_CR2_OIS1N_Msk         (0x1UL << TIM_CR2_OIS1N_Pos)                  /*!< 0x00000200 */
N#define TIM_CR2_OIS1N             TIM_CR2_OIS1N_Msk                            /*!<Output Idle state 1 (OC1N output) */
N#define TIM_CR2_OIS2_Pos          (10U)                                        
N#define TIM_CR2_OIS2_Msk          (0x1UL << TIM_CR2_OIS2_Pos)                   /*!< 0x00000400 */
N#define TIM_CR2_OIS2              TIM_CR2_OIS2_Msk                             /*!<Output Idle state 2 (OC2 output)  */
N#define TIM_CR2_OIS2N_Pos         (11U)                                        
N#define TIM_CR2_OIS2N_Msk         (0x1UL << TIM_CR2_OIS2N_Pos)                  /*!< 0x00000800 */
N#define TIM_CR2_OIS2N             TIM_CR2_OIS2N_Msk                            /*!<Output Idle state 2 (OC2N output) */
N#define TIM_CR2_OIS3_Pos          (12U)                                        
N#define TIM_CR2_OIS3_Msk          (0x1UL << TIM_CR2_OIS3_Pos)                   /*!< 0x00001000 */
N#define TIM_CR2_OIS3              TIM_CR2_OIS3_Msk                             /*!<Output Idle state 3 (OC3 output)  */
N#define TIM_CR2_OIS3N_Pos         (13U)                                        
N#define TIM_CR2_OIS3N_Msk         (0x1UL << TIM_CR2_OIS3N_Pos)                  /*!< 0x00002000 */
N#define TIM_CR2_OIS3N             TIM_CR2_OIS3N_Msk                            /*!<Output Idle state 3 (OC3N output) */
N#define TIM_CR2_OIS4_Pos          (14U)                                        
N#define TIM_CR2_OIS4_Msk          (0x1UL << TIM_CR2_OIS4_Pos)                   /*!< 0x00004000 */
N#define TIM_CR2_OIS4              TIM_CR2_OIS4_Msk                             /*!<Output Idle state 4 (OC4 output)  */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define TIM_SMCR_SMS_Pos          (0U)                                         
N#define TIM_SMCR_SMS_Msk          (0x7UL << TIM_SMCR_SMS_Pos)                   /*!< 0x00000007 */
N#define TIM_SMCR_SMS              TIM_SMCR_SMS_Msk                             /*!<SMS[2:0] bits (Slave mode selection)    */
N#define TIM_SMCR_SMS_0            (0x1UL << TIM_SMCR_SMS_Pos)                   /*!< 0x0001 */
N#define TIM_SMCR_SMS_1            (0x2UL << TIM_SMCR_SMS_Pos)                   /*!< 0x0002 */
N#define TIM_SMCR_SMS_2            (0x4UL << TIM_SMCR_SMS_Pos)                   /*!< 0x0004 */
N
N#define TIM_SMCR_TS_Pos           (4U)                                         
N#define TIM_SMCR_TS_Msk           (0x7UL << TIM_SMCR_TS_Pos)                    /*!< 0x00000070 */
N#define TIM_SMCR_TS               TIM_SMCR_TS_Msk                              /*!<TS[2:0] bits (Trigger selection)        */
N#define TIM_SMCR_TS_0             (0x1UL << TIM_SMCR_TS_Pos)                    /*!< 0x0010 */
N#define TIM_SMCR_TS_1             (0x2UL << TIM_SMCR_TS_Pos)                    /*!< 0x0020 */
N#define TIM_SMCR_TS_2             (0x4UL << TIM_SMCR_TS_Pos)                    /*!< 0x0040 */
N
N#define TIM_SMCR_MSM_Pos          (7U)                                         
N#define TIM_SMCR_MSM_Msk          (0x1UL << TIM_SMCR_MSM_Pos)                   /*!< 0x00000080 */
N#define TIM_SMCR_MSM              TIM_SMCR_MSM_Msk                             /*!<Master/slave mode                       */
N
N#define TIM_SMCR_ETF_Pos          (8U)                                         
N#define TIM_SMCR_ETF_Msk          (0xFUL << TIM_SMCR_ETF_Pos)                   /*!< 0x00000F00 */
N#define TIM_SMCR_ETF              TIM_SMCR_ETF_Msk                             /*!<ETF[3:0] bits (External trigger filter) */
N#define TIM_SMCR_ETF_0            (0x1UL << TIM_SMCR_ETF_Pos)                   /*!< 0x0100 */
N#define TIM_SMCR_ETF_1            (0x2UL << TIM_SMCR_ETF_Pos)                   /*!< 0x0200 */
N#define TIM_SMCR_ETF_2            (0x4UL << TIM_SMCR_ETF_Pos)                   /*!< 0x0400 */
N#define TIM_SMCR_ETF_3            (0x8UL << TIM_SMCR_ETF_Pos)                   /*!< 0x0800 */
N
N#define TIM_SMCR_ETPS_Pos         (12U)                                        
N#define TIM_SMCR_ETPS_Msk         (0x3UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x00003000 */
N#define TIM_SMCR_ETPS             TIM_SMCR_ETPS_Msk                            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define TIM_SMCR_ETPS_0           (0x1UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x1000 */
N#define TIM_SMCR_ETPS_1           (0x2UL << TIM_SMCR_ETPS_Pos)                  /*!< 0x2000 */
N
N#define TIM_SMCR_ECE_Pos          (14U)                                        
N#define TIM_SMCR_ECE_Msk          (0x1UL << TIM_SMCR_ECE_Pos)                   /*!< 0x00004000 */
N#define TIM_SMCR_ECE              TIM_SMCR_ECE_Msk                             /*!<External clock enable     */
N#define TIM_SMCR_ETP_Pos          (15U)                                        
N#define TIM_SMCR_ETP_Msk          (0x1UL << TIM_SMCR_ETP_Pos)                   /*!< 0x00008000 */
N#define TIM_SMCR_ETP              TIM_SMCR_ETP_Msk                             /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define TIM_DIER_UIE_Pos          (0U)                                         
N#define TIM_DIER_UIE_Msk          (0x1UL << TIM_DIER_UIE_Pos)                   /*!< 0x00000001 */
N#define TIM_DIER_UIE              TIM_DIER_UIE_Msk                             /*!<Update interrupt enable */
N#define TIM_DIER_CC1IE_Pos        (1U)                                         
N#define TIM_DIER_CC1IE_Msk        (0x1UL << TIM_DIER_CC1IE_Pos)                 /*!< 0x00000002 */
N#define TIM_DIER_CC1IE            TIM_DIER_CC1IE_Msk                           /*!<Capture/Compare 1 interrupt enable   */
N#define TIM_DIER_CC2IE_Pos        (2U)                                         
N#define TIM_DIER_CC2IE_Msk        (0x1UL << TIM_DIER_CC2IE_Pos)                 /*!< 0x00000004 */
N#define TIM_DIER_CC2IE            TIM_DIER_CC2IE_Msk                           /*!<Capture/Compare 2 interrupt enable   */
N#define TIM_DIER_CC3IE_Pos        (3U)                                         
N#define TIM_DIER_CC3IE_Msk        (0x1UL << TIM_DIER_CC3IE_Pos)                 /*!< 0x00000008 */
N#define TIM_DIER_CC3IE            TIM_DIER_CC3IE_Msk                           /*!<Capture/Compare 3 interrupt enable   */
N#define TIM_DIER_CC4IE_Pos        (4U)                                         
N#define TIM_DIER_CC4IE_Msk        (0x1UL << TIM_DIER_CC4IE_Pos)                 /*!< 0x00000010 */
N#define TIM_DIER_CC4IE            TIM_DIER_CC4IE_Msk                           /*!<Capture/Compare 4 interrupt enable   */
N#define TIM_DIER_COMIE_Pos        (5U)                                         
N#define TIM_DIER_COMIE_Msk        (0x1UL << TIM_DIER_COMIE_Pos)                 /*!< 0x00000020 */
N#define TIM_DIER_COMIE            TIM_DIER_COMIE_Msk                           /*!<COM interrupt enable                 */
N#define TIM_DIER_TIE_Pos          (6U)                                         
N#define TIM_DIER_TIE_Msk          (0x1UL << TIM_DIER_TIE_Pos)                   /*!< 0x00000040 */
N#define TIM_DIER_TIE              TIM_DIER_TIE_Msk                             /*!<Trigger interrupt enable             */
N#define TIM_DIER_BIE_Pos          (7U)                                         
N#define TIM_DIER_BIE_Msk          (0x1UL << TIM_DIER_BIE_Pos)                   /*!< 0x00000080 */
N#define TIM_DIER_BIE              TIM_DIER_BIE_Msk                             /*!<Break interrupt enable               */
N#define TIM_DIER_UDE_Pos          (8U)                                         
N#define TIM_DIER_UDE_Msk          (0x1UL << TIM_DIER_UDE_Pos)                   /*!< 0x00000100 */
N#define TIM_DIER_UDE              TIM_DIER_UDE_Msk                             /*!<Update DMA request enable            */
N#define TIM_DIER_CC1DE_Pos        (9U)                                         
N#define TIM_DIER_CC1DE_Msk        (0x1UL << TIM_DIER_CC1DE_Pos)                 /*!< 0x00000200 */
N#define TIM_DIER_CC1DE            TIM_DIER_CC1DE_Msk                           /*!<Capture/Compare 1 DMA request enable */
N#define TIM_DIER_CC2DE_Pos        (10U)                                        
N#define TIM_DIER_CC2DE_Msk        (0x1UL << TIM_DIER_CC2DE_Pos)                 /*!< 0x00000400 */
N#define TIM_DIER_CC2DE            TIM_DIER_CC2DE_Msk                           /*!<Capture/Compare 2 DMA request enable */
N#define TIM_DIER_CC3DE_Pos        (11U)                                        
N#define TIM_DIER_CC3DE_Msk        (0x1UL << TIM_DIER_CC3DE_Pos)                 /*!< 0x00000800 */
N#define TIM_DIER_CC3DE            TIM_DIER_CC3DE_Msk                           /*!<Capture/Compare 3 DMA request enable */
N#define TIM_DIER_CC4DE_Pos        (12U)                                        
N#define TIM_DIER_CC4DE_Msk        (0x1UL << TIM_DIER_CC4DE_Pos)                 /*!< 0x00001000 */
N#define TIM_DIER_CC4DE            TIM_DIER_CC4DE_Msk                           /*!<Capture/Compare 4 DMA request enable */
N#define TIM_DIER_COMDE_Pos        (13U)                                        
N#define TIM_DIER_COMDE_Msk        (0x1UL << TIM_DIER_COMDE_Pos)                 /*!< 0x00002000 */
N#define TIM_DIER_COMDE            TIM_DIER_COMDE_Msk                           /*!<COM DMA request enable               */
N#define TIM_DIER_TDE_Pos          (14U)                                        
N#define TIM_DIER_TDE_Msk          (0x1UL << TIM_DIER_TDE_Pos)                   /*!< 0x00004000 */
N#define TIM_DIER_TDE              TIM_DIER_TDE_Msk                             /*!<Trigger DMA request enable           */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define TIM_SR_UIF_Pos            (0U)                                         
N#define TIM_SR_UIF_Msk            (0x1UL << TIM_SR_UIF_Pos)                     /*!< 0x00000001 */
N#define TIM_SR_UIF                TIM_SR_UIF_Msk                               /*!<Update interrupt Flag              */
N#define TIM_SR_CC1IF_Pos          (1U)                                         
N#define TIM_SR_CC1IF_Msk          (0x1UL << TIM_SR_CC1IF_Pos)                   /*!< 0x00000002 */
N#define TIM_SR_CC1IF              TIM_SR_CC1IF_Msk                             /*!<Capture/Compare 1 interrupt Flag   */
N#define TIM_SR_CC2IF_Pos          (2U)                                         
N#define TIM_SR_CC2IF_Msk          (0x1UL << TIM_SR_CC2IF_Pos)                   /*!< 0x00000004 */
N#define TIM_SR_CC2IF              TIM_SR_CC2IF_Msk                             /*!<Capture/Compare 2 interrupt Flag   */
N#define TIM_SR_CC3IF_Pos          (3U)                                         
N#define TIM_SR_CC3IF_Msk          (0x1UL << TIM_SR_CC3IF_Pos)                   /*!< 0x00000008 */
N#define TIM_SR_CC3IF              TIM_SR_CC3IF_Msk                             /*!<Capture/Compare 3 interrupt Flag   */
N#define TIM_SR_CC4IF_Pos          (4U)                                         
N#define TIM_SR_CC4IF_Msk          (0x1UL << TIM_SR_CC4IF_Pos)                   /*!< 0x00000010 */
N#define TIM_SR_CC4IF              TIM_SR_CC4IF_Msk                             /*!<Capture/Compare 4 interrupt Flag   */
N#define TIM_SR_COMIF_Pos          (5U)                                         
N#define TIM_SR_COMIF_Msk          (0x1UL << TIM_SR_COMIF_Pos)                   /*!< 0x00000020 */
N#define TIM_SR_COMIF              TIM_SR_COMIF_Msk                             /*!<COM interrupt Flag                 */
N#define TIM_SR_TIF_Pos            (6U)                                         
N#define TIM_SR_TIF_Msk            (0x1UL << TIM_SR_TIF_Pos)                     /*!< 0x00000040 */
N#define TIM_SR_TIF                TIM_SR_TIF_Msk                               /*!<Trigger interrupt Flag             */
N#define TIM_SR_BIF_Pos            (7U)                                         
N#define TIM_SR_BIF_Msk            (0x1UL << TIM_SR_BIF_Pos)                     /*!< 0x00000080 */
N#define TIM_SR_BIF                TIM_SR_BIF_Msk                               /*!<Break interrupt Flag               */
N#define TIM_SR_CC1OF_Pos          (9U)                                         
N#define TIM_SR_CC1OF_Msk          (0x1UL << TIM_SR_CC1OF_Pos)                   /*!< 0x00000200 */
N#define TIM_SR_CC1OF              TIM_SR_CC1OF_Msk                             /*!<Capture/Compare 1 Overcapture Flag */
N#define TIM_SR_CC2OF_Pos          (10U)                                        
N#define TIM_SR_CC2OF_Msk          (0x1UL << TIM_SR_CC2OF_Pos)                   /*!< 0x00000400 */
N#define TIM_SR_CC2OF              TIM_SR_CC2OF_Msk                             /*!<Capture/Compare 2 Overcapture Flag */
N#define TIM_SR_CC3OF_Pos          (11U)                                        
N#define TIM_SR_CC3OF_Msk          (0x1UL << TIM_SR_CC3OF_Pos)                   /*!< 0x00000800 */
N#define TIM_SR_CC3OF              TIM_SR_CC3OF_Msk                             /*!<Capture/Compare 3 Overcapture Flag */
N#define TIM_SR_CC4OF_Pos          (12U)                                        
N#define TIM_SR_CC4OF_Msk          (0x1UL << TIM_SR_CC4OF_Pos)                   /*!< 0x00001000 */
N#define TIM_SR_CC4OF              TIM_SR_CC4OF_Msk                             /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define TIM_EGR_UG_Pos            (0U)                                         
N#define TIM_EGR_UG_Msk            (0x1UL << TIM_EGR_UG_Pos)                     /*!< 0x00000001 */
N#define TIM_EGR_UG                TIM_EGR_UG_Msk                               /*!<Update Generation                         */
N#define TIM_EGR_CC1G_Pos          (1U)                                         
N#define TIM_EGR_CC1G_Msk          (0x1UL << TIM_EGR_CC1G_Pos)                   /*!< 0x00000002 */
N#define TIM_EGR_CC1G              TIM_EGR_CC1G_Msk                             /*!<Capture/Compare 1 Generation              */
N#define TIM_EGR_CC2G_Pos          (2U)                                         
N#define TIM_EGR_CC2G_Msk          (0x1UL << TIM_EGR_CC2G_Pos)                   /*!< 0x00000004 */
N#define TIM_EGR_CC2G              TIM_EGR_CC2G_Msk                             /*!<Capture/Compare 2 Generation              */
N#define TIM_EGR_CC3G_Pos          (3U)                                         
N#define TIM_EGR_CC3G_Msk          (0x1UL << TIM_EGR_CC3G_Pos)                   /*!< 0x00000008 */
N#define TIM_EGR_CC3G              TIM_EGR_CC3G_Msk                             /*!<Capture/Compare 3 Generation              */
N#define TIM_EGR_CC4G_Pos          (4U)                                         
N#define TIM_EGR_CC4G_Msk          (0x1UL << TIM_EGR_CC4G_Pos)                   /*!< 0x00000010 */
N#define TIM_EGR_CC4G              TIM_EGR_CC4G_Msk                             /*!<Capture/Compare 4 Generation              */
N#define TIM_EGR_COMG_Pos          (5U)                                         
N#define TIM_EGR_COMG_Msk          (0x1UL << TIM_EGR_COMG_Pos)                   /*!< 0x00000020 */
N#define TIM_EGR_COMG              TIM_EGR_COMG_Msk                             /*!<Capture/Compare Control Update Generation */
N#define TIM_EGR_TG_Pos            (6U)                                         
N#define TIM_EGR_TG_Msk            (0x1UL << TIM_EGR_TG_Pos)                     /*!< 0x00000040 */
N#define TIM_EGR_TG                TIM_EGR_TG_Msk                               /*!<Trigger Generation                        */
N#define TIM_EGR_BG_Pos            (7U)                                         
N#define TIM_EGR_BG_Msk            (0x1UL << TIM_EGR_BG_Pos)                     /*!< 0x00000080 */
N#define TIM_EGR_BG                TIM_EGR_BG_Msk                               /*!<Break Generation                          */
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define TIM_CCMR1_CC1S_Pos        (0U)                                         
N#define TIM_CCMR1_CC1S_Msk        (0x3UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x00000003 */
N#define TIM_CCMR1_CC1S            TIM_CCMR1_CC1S_Msk                           /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define TIM_CCMR1_CC1S_0          (0x1UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x0001 */
N#define TIM_CCMR1_CC1S_1          (0x2UL << TIM_CCMR1_CC1S_Pos)                 /*!< 0x0002 */
N
N#define TIM_CCMR1_OC1FE_Pos       (2U)                                         
N#define TIM_CCMR1_OC1FE_Msk       (0x1UL << TIM_CCMR1_OC1FE_Pos)                /*!< 0x00000004 */
N#define TIM_CCMR1_OC1FE           TIM_CCMR1_OC1FE_Msk                          /*!<Output Compare 1 Fast enable                 */
N#define TIM_CCMR1_OC1PE_Pos       (3U)                                         
N#define TIM_CCMR1_OC1PE_Msk       (0x1UL << TIM_CCMR1_OC1PE_Pos)                /*!< 0x00000008 */
N#define TIM_CCMR1_OC1PE           TIM_CCMR1_OC1PE_Msk                          /*!<Output Compare 1 Preload enable              */
N
N#define TIM_CCMR1_OC1M_Pos        (4U)                                         
N#define TIM_CCMR1_OC1M_Msk        (0x7UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000070 */
N#define TIM_CCMR1_OC1M            TIM_CCMR1_OC1M_Msk                           /*!<OC1M[2:0] bits (Output Compare 1 Mode)       */
N#define TIM_CCMR1_OC1M_0          (0x1UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x0010 */
N#define TIM_CCMR1_OC1M_1          (0x2UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x0020 */
N#define TIM_CCMR1_OC1M_2          (0x4UL << TIM_CCMR1_OC1M_Pos)                 /*!< 0x0040 */
N
N#define TIM_CCMR1_OC1CE_Pos       (7U)                                         
N#define TIM_CCMR1_OC1CE_Msk       (0x1UL << TIM_CCMR1_OC1CE_Pos)                /*!< 0x00000080 */
N#define TIM_CCMR1_OC1CE           TIM_CCMR1_OC1CE_Msk                          /*!<Output Compare 1Clear Enable                 */
N
N#define TIM_CCMR1_CC2S_Pos        (8U)                                         
N#define TIM_CCMR1_CC2S_Msk        (0x3UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x00000300 */
N#define TIM_CCMR1_CC2S            TIM_CCMR1_CC2S_Msk                           /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define TIM_CCMR1_CC2S_0          (0x1UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x0100 */
N#define TIM_CCMR1_CC2S_1          (0x2UL << TIM_CCMR1_CC2S_Pos)                 /*!< 0x0200 */
N
N#define TIM_CCMR1_OC2FE_Pos       (10U)                                        
N#define TIM_CCMR1_OC2FE_Msk       (0x1UL << TIM_CCMR1_OC2FE_Pos)                /*!< 0x00000400 */
N#define TIM_CCMR1_OC2FE           TIM_CCMR1_OC2FE_Msk                          /*!<Output Compare 2 Fast enable                 */
N#define TIM_CCMR1_OC2PE_Pos       (11U)                                        
N#define TIM_CCMR1_OC2PE_Msk       (0x1UL << TIM_CCMR1_OC2PE_Pos)                /*!< 0x00000800 */
N#define TIM_CCMR1_OC2PE           TIM_CCMR1_OC2PE_Msk                          /*!<Output Compare 2 Preload enable              */
N
N#define TIM_CCMR1_OC2M_Pos        (12U)                                        
N#define TIM_CCMR1_OC2M_Msk        (0x7UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00007000 */
N#define TIM_CCMR1_OC2M            TIM_CCMR1_OC2M_Msk                           /*!<OC2M[2:0] bits (Output Compare 2 Mode)       */
N#define TIM_CCMR1_OC2M_0          (0x1UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x1000 */
N#define TIM_CCMR1_OC2M_1          (0x2UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x2000 */
N#define TIM_CCMR1_OC2M_2          (0x4UL << TIM_CCMR1_OC2M_Pos)                 /*!< 0x4000 */
N
N#define TIM_CCMR1_OC2CE_Pos       (15U)                                        
N#define TIM_CCMR1_OC2CE_Msk       (0x1UL << TIM_CCMR1_OC2CE_Pos)                /*!< 0x00008000 */
N#define TIM_CCMR1_OC2CE           TIM_CCMR1_OC2CE_Msk                          /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define TIM_CCMR1_IC1PSC_Pos      (2U)                                         
N#define TIM_CCMR1_IC1PSC_Msk      (0x3UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x0000000C */
N#define TIM_CCMR1_IC1PSC          TIM_CCMR1_IC1PSC_Msk                         /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define TIM_CCMR1_IC1PSC_0        (0x1UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x0004 */
N#define TIM_CCMR1_IC1PSC_1        (0x2UL << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x0008 */
N
N#define TIM_CCMR1_IC1F_Pos        (4U)                                         
N#define TIM_CCMR1_IC1F_Msk        (0xFUL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x000000F0 */
N#define TIM_CCMR1_IC1F            TIM_CCMR1_IC1F_Msk                           /*!<IC1F[3:0] bits (Input Capture 1 Filter)      */
N#define TIM_CCMR1_IC1F_0          (0x1UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x0010 */
N#define TIM_CCMR1_IC1F_1          (0x2UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x0020 */
N#define TIM_CCMR1_IC1F_2          (0x4UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x0040 */
N#define TIM_CCMR1_IC1F_3          (0x8UL << TIM_CCMR1_IC1F_Pos)                 /*!< 0x0080 */
N
N#define TIM_CCMR1_IC2PSC_Pos      (10U)                                        
N#define TIM_CCMR1_IC2PSC_Msk      (0x3UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x00000C00 */
N#define TIM_CCMR1_IC2PSC          TIM_CCMR1_IC2PSC_Msk                         /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler)  */
N#define TIM_CCMR1_IC2PSC_0        (0x1UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x0400 */
N#define TIM_CCMR1_IC2PSC_1        (0x2UL << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x0800 */
N
N#define TIM_CCMR1_IC2F_Pos        (12U)                                        
N#define TIM_CCMR1_IC2F_Msk        (0xFUL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x0000F000 */
N#define TIM_CCMR1_IC2F            TIM_CCMR1_IC2F_Msk                           /*!<IC2F[3:0] bits (Input Capture 2 Filter)       */
N#define TIM_CCMR1_IC2F_0          (0x1UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x1000 */
N#define TIM_CCMR1_IC2F_1          (0x2UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x2000 */
N#define TIM_CCMR1_IC2F_2          (0x4UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x4000 */
N#define TIM_CCMR1_IC2F_3          (0x8UL << TIM_CCMR1_IC2F_Pos)                 /*!< 0x8000 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define TIM_CCMR2_CC3S_Pos        (0U)                                         
N#define TIM_CCMR2_CC3S_Msk        (0x3UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x00000003 */
N#define TIM_CCMR2_CC3S            TIM_CCMR2_CC3S_Msk                           /*!<CC3S[1:0] bits (Capture/Compare 3 Selection)  */
N#define TIM_CCMR2_CC3S_0          (0x1UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x0001 */
N#define TIM_CCMR2_CC3S_1          (0x2UL << TIM_CCMR2_CC3S_Pos)                 /*!< 0x0002 */
N
N#define TIM_CCMR2_OC3FE_Pos       (2U)                                         
N#define TIM_CCMR2_OC3FE_Msk       (0x1UL << TIM_CCMR2_OC3FE_Pos)                /*!< 0x00000004 */
N#define TIM_CCMR2_OC3FE           TIM_CCMR2_OC3FE_Msk                          /*!<Output Compare 3 Fast enable           */
N#define TIM_CCMR2_OC3PE_Pos       (3U)                                         
N#define TIM_CCMR2_OC3PE_Msk       (0x1UL << TIM_CCMR2_OC3PE_Pos)                /*!< 0x00000008 */
N#define TIM_CCMR2_OC3PE           TIM_CCMR2_OC3PE_Msk                          /*!<Output Compare 3 Preload enable        */
N
N#define TIM_CCMR2_OC3M_Pos        (4U)                                         
N#define TIM_CCMR2_OC3M_Msk        (0x7UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000070 */
N#define TIM_CCMR2_OC3M            TIM_CCMR2_OC3M_Msk                           /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define TIM_CCMR2_OC3M_0          (0x1UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x0010 */
N#define TIM_CCMR2_OC3M_1          (0x2UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x0020 */
N#define TIM_CCMR2_OC3M_2          (0x4UL << TIM_CCMR2_OC3M_Pos)                 /*!< 0x0040 */
N
N#define TIM_CCMR2_OC3CE_Pos       (7U)                                         
N#define TIM_CCMR2_OC3CE_Msk       (0x1UL << TIM_CCMR2_OC3CE_Pos)                /*!< 0x00000080 */
N#define TIM_CCMR2_OC3CE           TIM_CCMR2_OC3CE_Msk                          /*!<Output Compare 3 Clear Enable */
N
N#define TIM_CCMR2_CC4S_Pos        (8U)                                         
N#define TIM_CCMR2_CC4S_Msk        (0x3UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x00000300 */
N#define TIM_CCMR2_CC4S            TIM_CCMR2_CC4S_Msk                           /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define TIM_CCMR2_CC4S_0          (0x1UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x0100 */
N#define TIM_CCMR2_CC4S_1          (0x2UL << TIM_CCMR2_CC4S_Pos)                 /*!< 0x0200 */
N
N#define TIM_CCMR2_OC4FE_Pos       (10U)                                        
N#define TIM_CCMR2_OC4FE_Msk       (0x1UL << TIM_CCMR2_OC4FE_Pos)                /*!< 0x00000400 */
N#define TIM_CCMR2_OC4FE           TIM_CCMR2_OC4FE_Msk                          /*!<Output Compare 4 Fast enable    */
N#define TIM_CCMR2_OC4PE_Pos       (11U)                                        
N#define TIM_CCMR2_OC4PE_Msk       (0x1UL << TIM_CCMR2_OC4PE_Pos)                /*!< 0x00000800 */
N#define TIM_CCMR2_OC4PE           TIM_CCMR2_OC4PE_Msk                          /*!<Output Compare 4 Preload enable */
N
N#define TIM_CCMR2_OC4M_Pos        (12U)                                        
N#define TIM_CCMR2_OC4M_Msk        (0x7UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00007000 */
N#define TIM_CCMR2_OC4M            TIM_CCMR2_OC4M_Msk                           /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define TIM_CCMR2_OC4M_0          (0x1UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x1000 */
N#define TIM_CCMR2_OC4M_1          (0x2UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x2000 */
N#define TIM_CCMR2_OC4M_2          (0x4UL << TIM_CCMR2_OC4M_Pos)                 /*!< 0x4000 */
N
N#define TIM_CCMR2_OC4CE_Pos       (15U)                                        
N#define TIM_CCMR2_OC4CE_Msk       (0x1UL << TIM_CCMR2_OC4CE_Pos)                /*!< 0x00008000 */
N#define TIM_CCMR2_OC4CE           TIM_CCMR2_OC4CE_Msk                          /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define TIM_CCMR2_IC3PSC_Pos      (2U)                                         
N#define TIM_CCMR2_IC3PSC_Msk      (0x3UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x0000000C */
N#define TIM_CCMR2_IC3PSC          TIM_CCMR2_IC3PSC_Msk                         /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define TIM_CCMR2_IC3PSC_0        (0x1UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x0004 */
N#define TIM_CCMR2_IC3PSC_1        (0x2UL << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x0008 */
N
N#define TIM_CCMR2_IC3F_Pos        (4U)                                         
N#define TIM_CCMR2_IC3F_Msk        (0xFUL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x000000F0 */
N#define TIM_CCMR2_IC3F            TIM_CCMR2_IC3F_Msk                           /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define TIM_CCMR2_IC3F_0          (0x1UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x0010 */
N#define TIM_CCMR2_IC3F_1          (0x2UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x0020 */
N#define TIM_CCMR2_IC3F_2          (0x4UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x0040 */
N#define TIM_CCMR2_IC3F_3          (0x8UL << TIM_CCMR2_IC3F_Pos)                 /*!< 0x0080 */
N
N#define TIM_CCMR2_IC4PSC_Pos      (10U)                                        
N#define TIM_CCMR2_IC4PSC_Msk      (0x3UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x00000C00 */
N#define TIM_CCMR2_IC4PSC          TIM_CCMR2_IC4PSC_Msk                         /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define TIM_CCMR2_IC4PSC_0        (0x1UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x0400 */
N#define TIM_CCMR2_IC4PSC_1        (0x2UL << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x0800 */
N
N#define TIM_CCMR2_IC4F_Pos        (12U)                                        
N#define TIM_CCMR2_IC4F_Msk        (0xFUL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x0000F000 */
N#define TIM_CCMR2_IC4F            TIM_CCMR2_IC4F_Msk                           /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define TIM_CCMR2_IC4F_0          (0x1UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x1000 */
N#define TIM_CCMR2_IC4F_1          (0x2UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x2000 */
N#define TIM_CCMR2_IC4F_2          (0x4UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x4000 */
N#define TIM_CCMR2_IC4F_3          (0x8UL << TIM_CCMR2_IC4F_Pos)                 /*!< 0x8000 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define TIM_CCER_CC1E_Pos         (0U)                                         
N#define TIM_CCER_CC1E_Msk         (0x1UL << TIM_CCER_CC1E_Pos)                  /*!< 0x00000001 */
N#define TIM_CCER_CC1E             TIM_CCER_CC1E_Msk                            /*!<Capture/Compare 1 output enable                 */
N#define TIM_CCER_CC1P_Pos         (1U)                                         
N#define TIM_CCER_CC1P_Msk         (0x1UL << TIM_CCER_CC1P_Pos)                  /*!< 0x00000002 */
N#define TIM_CCER_CC1P             TIM_CCER_CC1P_Msk                            /*!<Capture/Compare 1 output Polarity               */
N#define TIM_CCER_CC1NE_Pos        (2U)                                         
N#define TIM_CCER_CC1NE_Msk        (0x1UL << TIM_CCER_CC1NE_Pos)                 /*!< 0x00000004 */
N#define TIM_CCER_CC1NE            TIM_CCER_CC1NE_Msk                           /*!<Capture/Compare 1 Complementary output enable   */
N#define TIM_CCER_CC1NP_Pos        (3U)                                         
N#define TIM_CCER_CC1NP_Msk        (0x1UL << TIM_CCER_CC1NP_Pos)                 /*!< 0x00000008 */
N#define TIM_CCER_CC1NP            TIM_CCER_CC1NP_Msk                           /*!<Capture/Compare 1 Complementary output Polarity */
N#define TIM_CCER_CC2E_Pos         (4U)                                         
N#define TIM_CCER_CC2E_Msk         (0x1UL << TIM_CCER_CC2E_Pos)                  /*!< 0x00000010 */
N#define TIM_CCER_CC2E             TIM_CCER_CC2E_Msk                            /*!<Capture/Compare 2 output enable                 */
N#define TIM_CCER_CC2P_Pos         (5U)                                         
N#define TIM_CCER_CC2P_Msk         (0x1UL << TIM_CCER_CC2P_Pos)                  /*!< 0x00000020 */
N#define TIM_CCER_CC2P             TIM_CCER_CC2P_Msk                            /*!<Capture/Compare 2 output Polarity               */
N#define TIM_CCER_CC2NE_Pos        (6U)                                         
N#define TIM_CCER_CC2NE_Msk        (0x1UL << TIM_CCER_CC2NE_Pos)                 /*!< 0x00000040 */
N#define TIM_CCER_CC2NE            TIM_CCER_CC2NE_Msk                           /*!<Capture/Compare 2 Complementary output enable   */
N#define TIM_CCER_CC2NP_Pos        (7U)                                         
N#define TIM_CCER_CC2NP_Msk        (0x1UL << TIM_CCER_CC2NP_Pos)                 /*!< 0x00000080 */
N#define TIM_CCER_CC2NP            TIM_CCER_CC2NP_Msk                           /*!<Capture/Compare 2 Complementary output Polarity */
N#define TIM_CCER_CC3E_Pos         (8U)                                         
N#define TIM_CCER_CC3E_Msk         (0x1UL << TIM_CCER_CC3E_Pos)                  /*!< 0x00000100 */
N#define TIM_CCER_CC3E             TIM_CCER_CC3E_Msk                            /*!<Capture/Compare 3 output enable                 */
N#define TIM_CCER_CC3P_Pos         (9U)                                         
N#define TIM_CCER_CC3P_Msk         (0x1UL << TIM_CCER_CC3P_Pos)                  /*!< 0x00000200 */
N#define TIM_CCER_CC3P             TIM_CCER_CC3P_Msk                            /*!<Capture/Compare 3 output Polarity               */
N#define TIM_CCER_CC3NE_Pos        (10U)                                        
N#define TIM_CCER_CC3NE_Msk        (0x1UL << TIM_CCER_CC3NE_Pos)                 /*!< 0x00000400 */
N#define TIM_CCER_CC3NE            TIM_CCER_CC3NE_Msk                           /*!<Capture/Compare 3 Complementary output enable   */
N#define TIM_CCER_CC3NP_Pos        (11U)                                        
N#define TIM_CCER_CC3NP_Msk        (0x1UL << TIM_CCER_CC3NP_Pos)                 /*!< 0x00000800 */
N#define TIM_CCER_CC3NP            TIM_CCER_CC3NP_Msk                           /*!<Capture/Compare 3 Complementary output Polarity */
N#define TIM_CCER_CC4E_Pos         (12U)                                        
N#define TIM_CCER_CC4E_Msk         (0x1UL << TIM_CCER_CC4E_Pos)                  /*!< 0x00001000 */
N#define TIM_CCER_CC4E             TIM_CCER_CC4E_Msk                            /*!<Capture/Compare 4 output enable                 */
N#define TIM_CCER_CC4P_Pos         (13U)                                        
N#define TIM_CCER_CC4P_Msk         (0x1UL << TIM_CCER_CC4P_Pos)                  /*!< 0x00002000 */
N#define TIM_CCER_CC4P             TIM_CCER_CC4P_Msk                            /*!<Capture/Compare 4 output Polarity               */
N#define TIM_CCER_CC4NP_Pos        (15U)                                        
N#define TIM_CCER_CC4NP_Msk        (0x1UL << TIM_CCER_CC4NP_Pos)                 /*!< 0x00008000 */
N#define TIM_CCER_CC4NP            TIM_CCER_CC4NP_Msk                           /*!<Capture/Compare 4 Complementary output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define TIM_CNT_CNT_Pos           (0U)                                             
N#define TIM_CNT_CNT_Msk           (0xFFFFFFFFUL << TIM_CNT_CNT_Pos)                 /*!< 0xFFFFFFFF */
N#define TIM_CNT_CNT               TIM_CNT_CNT_Msk                                  /*!<Counter Value            */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define TIM_PSC_PSC_Pos           (0U)                                         
N#define TIM_PSC_PSC_Msk           (0xFFFFUL << TIM_PSC_PSC_Pos)                 /*!< 0x0000FFFF */
N#define TIM_PSC_PSC               TIM_PSC_PSC_Msk                              /*!<Prescaler Value          */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define TIM_ARR_ARR_Pos           (0U)                                         
N#define TIM_ARR_ARR_Msk           (0xFFFFFFFFUL << TIM_ARR_ARR_Pos)             /*!< 0xFFFFFFFF */
N#define TIM_ARR_ARR               TIM_ARR_ARR_Msk                              /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define TIM_RCR_REP_Pos           (0U)                                         
N#define TIM_RCR_REP_Msk           (0xFFUL << TIM_RCR_REP_Pos)                   /*!< 0x000000FF */
N#define TIM_RCR_REP               TIM_RCR_REP_Msk                              /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define TIM_CCR1_CCR1_Pos         (0U)                                         
N#define TIM_CCR1_CCR1_Msk         (0xFFFFUL << TIM_CCR1_CCR1_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR1_CCR1             TIM_CCR1_CCR1_Msk                            /*!<Capture/Compare 1 Value  */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define TIM_CCR2_CCR2_Pos         (0U)                                         
N#define TIM_CCR2_CCR2_Msk         (0xFFFFUL << TIM_CCR2_CCR2_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR2_CCR2             TIM_CCR2_CCR2_Msk                            /*!<Capture/Compare 2 Value  */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define TIM_CCR3_CCR3_Pos         (0U)                                         
N#define TIM_CCR3_CCR3_Msk         (0xFFFFUL << TIM_CCR3_CCR3_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR3_CCR3             TIM_CCR3_CCR3_Msk                            /*!<Capture/Compare 3 Value  */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define TIM_CCR4_CCR4_Pos         (0U)                                         
N#define TIM_CCR4_CCR4_Msk         (0xFFFFUL << TIM_CCR4_CCR4_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR4_CCR4             TIM_CCR4_CCR4_Msk                            /*!<Capture/Compare 4 Value  */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define TIM_BDTR_DTG_Pos          (0U)                                         
N#define TIM_BDTR_DTG_Msk          (0xFFUL << TIM_BDTR_DTG_Pos)                  /*!< 0x000000FF */
N#define TIM_BDTR_DTG              TIM_BDTR_DTG_Msk                             /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define TIM_BDTR_DTG_0            (0x01UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0001 */
N#define TIM_BDTR_DTG_1            (0x02UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0002 */
N#define TIM_BDTR_DTG_2            (0x04UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0004 */
N#define TIM_BDTR_DTG_3            (0x08UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0008 */
N#define TIM_BDTR_DTG_4            (0x10UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0010 */
N#define TIM_BDTR_DTG_5            (0x20UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0020 */
N#define TIM_BDTR_DTG_6            (0x40UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0040 */
N#define TIM_BDTR_DTG_7            (0x80UL << TIM_BDTR_DTG_Pos)                  /*!< 0x0080 */
N
N#define TIM_BDTR_LOCK_Pos         (8U)                                         
N#define TIM_BDTR_LOCK_Msk         (0x3UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x00000300 */
N#define TIM_BDTR_LOCK             TIM_BDTR_LOCK_Msk                            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define TIM_BDTR_LOCK_0           (0x1UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x0100 */
N#define TIM_BDTR_LOCK_1           (0x2UL << TIM_BDTR_LOCK_Pos)                  /*!< 0x0200 */
N
N#define TIM_BDTR_OSSI_Pos         (10U)                                        
N#define TIM_BDTR_OSSI_Msk         (0x1UL << TIM_BDTR_OSSI_Pos)                  /*!< 0x00000400 */
N#define TIM_BDTR_OSSI             TIM_BDTR_OSSI_Msk                            /*!<Off-State Selection for Idle mode */
N#define TIM_BDTR_OSSR_Pos         (11U)                                        
N#define TIM_BDTR_OSSR_Msk         (0x1UL << TIM_BDTR_OSSR_Pos)                  /*!< 0x00000800 */
N#define TIM_BDTR_OSSR             TIM_BDTR_OSSR_Msk                            /*!<Off-State Selection for Run mode  */
N#define TIM_BDTR_BKE_Pos          (12U)                                        
N#define TIM_BDTR_BKE_Msk          (0x1UL << TIM_BDTR_BKE_Pos)                   /*!< 0x00001000 */
N#define TIM_BDTR_BKE              TIM_BDTR_BKE_Msk                             /*!<Break enable                      */
N#define TIM_BDTR_BKP_Pos          (13U)                                        
N#define TIM_BDTR_BKP_Msk          (0x1UL << TIM_BDTR_BKP_Pos)                   /*!< 0x00002000 */
N#define TIM_BDTR_BKP              TIM_BDTR_BKP_Msk                             /*!<Break Polarity                    */
N#define TIM_BDTR_AOE_Pos          (14U)                                        
N#define TIM_BDTR_AOE_Msk          (0x1UL << TIM_BDTR_AOE_Pos)                   /*!< 0x00004000 */
N#define TIM_BDTR_AOE              TIM_BDTR_AOE_Msk                             /*!<Automatic Output enable           */
N#define TIM_BDTR_MOE_Pos          (15U)                                        
N#define TIM_BDTR_MOE_Msk          (0x1UL << TIM_BDTR_MOE_Pos)                   /*!< 0x00008000 */
N#define TIM_BDTR_MOE              TIM_BDTR_MOE_Msk                             /*!<Main Output enable                */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define TIM_DCR_DBA_Pos           (0U)                                         
N#define TIM_DCR_DBA_Msk           (0x1FUL << TIM_DCR_DBA_Pos)                   /*!< 0x0000001F */
N#define TIM_DCR_DBA               TIM_DCR_DBA_Msk                              /*!<DBA[4:0] bits (DMA Base Address) */
N#define TIM_DCR_DBA_0             (0x01UL << TIM_DCR_DBA_Pos)                   /*!< 0x0001 */
N#define TIM_DCR_DBA_1             (0x02UL << TIM_DCR_DBA_Pos)                   /*!< 0x0002 */
N#define TIM_DCR_DBA_2             (0x04UL << TIM_DCR_DBA_Pos)                   /*!< 0x0004 */
N#define TIM_DCR_DBA_3             (0x08UL << TIM_DCR_DBA_Pos)                   /*!< 0x0008 */
N#define TIM_DCR_DBA_4             (0x10UL << TIM_DCR_DBA_Pos)                   /*!< 0x0010 */
N
N#define TIM_DCR_DBL_Pos           (8U)                                         
N#define TIM_DCR_DBL_Msk           (0x1FUL << TIM_DCR_DBL_Pos)                   /*!< 0x00001F00 */
N#define TIM_DCR_DBL               TIM_DCR_DBL_Msk                              /*!<DBL[4:0] bits (DMA Burst Length) */
N#define TIM_DCR_DBL_0             (0x01UL << TIM_DCR_DBL_Pos)                   /*!< 0x0100 */
N#define TIM_DCR_DBL_1             (0x02UL << TIM_DCR_DBL_Pos)                   /*!< 0x0200 */
N#define TIM_DCR_DBL_2             (0x04UL << TIM_DCR_DBL_Pos)                   /*!< 0x0400 */
N#define TIM_DCR_DBL_3             (0x08UL << TIM_DCR_DBL_Pos)                   /*!< 0x0800 */
N#define TIM_DCR_DBL_4             (0x10UL << TIM_DCR_DBL_Pos)                   /*!< 0x1000 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define TIM_DMAR_DMAB_Pos         (0U)                                         
N#define TIM_DMAR_DMAB_Msk         (0xFFFFUL << TIM_DMAR_DMAB_Pos)               /*!< 0x0000FFFF */
N#define TIM_DMAR_DMAB             TIM_DMAR_DMAB_Msk                            /*!<DMA register for burst accesses                    */
N
N/*******************  Bit definition for TIM_OR register  *********************/
N#define TIM_OR_TI1_RMP_Pos        (0U)                                          
N#define TIM_OR_TI1_RMP_Msk        (0x3UL << TIM_OR_TI1_RMP_Pos)                 /*!< 0x00000003 */
N#define TIM_OR_TI1_RMP            TIM_OR_TI1_RMP_Msk                           /*!< TI1_RMP[1:0] bits (TIM11 Input Capture 1 remap) */
N#define TIM_OR_TI1_RMP_0          (0x1UL << TIM_OR_TI1_RMP_Pos)                 /*!< 0x00000001 */
N#define TIM_OR_TI1_RMP_1          (0x2UL << TIM_OR_TI1_RMP_Pos)                 /*!< 0x00000002 */
N
N#define TIM_OR_TI4_RMP_Pos        (6U)                                         
N#define TIM_OR_TI4_RMP_Msk        (0x3UL << TIM_OR_TI4_RMP_Pos)                 /*!< 0x000000C0 */
N#define TIM_OR_TI4_RMP            TIM_OR_TI4_RMP_Msk                           /*!<TI4_RMP[1:0] bits (TIM5 Input 4 remap)             */
N#define TIM_OR_TI4_RMP_0          (0x1UL << TIM_OR_TI4_RMP_Pos)                 /*!< 0x0040 */
N#define TIM_OR_TI4_RMP_1          (0x2UL << TIM_OR_TI4_RMP_Pos)                 /*!< 0x0080 */
N#define TIM_OR_ITR1_RMP_Pos       (10U)                                        
N#define TIM_OR_ITR1_RMP_Msk       (0x3UL << TIM_OR_ITR1_RMP_Pos)                /*!< 0x00000C00 */
N#define TIM_OR_ITR1_RMP           TIM_OR_ITR1_RMP_Msk                          /*!<ITR1_RMP[1:0] bits (TIM2 Internal trigger 1 remap) */
N#define TIM_OR_ITR1_RMP_0         (0x1UL << TIM_OR_ITR1_RMP_Pos)                /*!< 0x0400 */
N#define TIM_OR_ITR1_RMP_1         (0x2UL << TIM_OR_ITR1_RMP_Pos)                /*!< 0x0800 */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*         Universal Synchronous Asynchronous Receiver Transmitter            */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for USART_SR register  *******************/
N#define USART_SR_PE_Pos               (0U)                                     
N#define USART_SR_PE_Msk               (0x1UL << USART_SR_PE_Pos)                /*!< 0x00000001 */
N#define USART_SR_PE                   USART_SR_PE_Msk                          /*!<Parity Error                 */
N#define USART_SR_FE_Pos               (1U)                                     
N#define USART_SR_FE_Msk               (0x1UL << USART_SR_FE_Pos)                /*!< 0x00000002 */
N#define USART_SR_FE                   USART_SR_FE_Msk                          /*!<Framing Error                */
N#define USART_SR_NE_Pos               (2U)                                     
N#define USART_SR_NE_Msk               (0x1UL << USART_SR_NE_Pos)                /*!< 0x00000004 */
N#define USART_SR_NE                   USART_SR_NE_Msk                          /*!<Noise Error Flag             */
N#define USART_SR_ORE_Pos              (3U)                                     
N#define USART_SR_ORE_Msk              (0x1UL << USART_SR_ORE_Pos)               /*!< 0x00000008 */
N#define USART_SR_ORE                  USART_SR_ORE_Msk                         /*!<OverRun Error                */
N#define USART_SR_IDLE_Pos             (4U)                                     
N#define USART_SR_IDLE_Msk             (0x1UL << USART_SR_IDLE_Pos)              /*!< 0x00000010 */
N#define USART_SR_IDLE                 USART_SR_IDLE_Msk                        /*!<IDLE line detected           */
N#define USART_SR_RXNE_Pos             (5U)                                     
N#define USART_SR_RXNE_Msk             (0x1UL << USART_SR_RXNE_Pos)              /*!< 0x00000020 */
N#define USART_SR_RXNE                 USART_SR_RXNE_Msk                        /*!<Read Data Register Not Empty */
N#define USART_SR_TC_Pos               (6U)                                     
N#define USART_SR_TC_Msk               (0x1UL << USART_SR_TC_Pos)                /*!< 0x00000040 */
N#define USART_SR_TC                   USART_SR_TC_Msk                          /*!<Transmission Complete        */
N#define USART_SR_TXE_Pos              (7U)                                     
N#define USART_SR_TXE_Msk              (0x1UL << USART_SR_TXE_Pos)               /*!< 0x00000080 */
N#define USART_SR_TXE                  USART_SR_TXE_Msk                         /*!<Transmit Data Register Empty */
N#define USART_SR_LBD_Pos              (8U)                                     
N#define USART_SR_LBD_Msk              (0x1UL << USART_SR_LBD_Pos)               /*!< 0x00000100 */
N#define USART_SR_LBD                  USART_SR_LBD_Msk                         /*!<LIN Break Detection Flag     */
N#define USART_SR_CTS_Pos              (9U)                                     
N#define USART_SR_CTS_Msk              (0x1UL << USART_SR_CTS_Pos)               /*!< 0x00000200 */
N#define USART_SR_CTS                  USART_SR_CTS_Msk                         /*!<CTS Flag                     */
N
N/*******************  Bit definition for USART_DR register  *******************/
N#define USART_DR_DR_Pos               (0U)                                     
N#define USART_DR_DR_Msk               (0x1FFUL << USART_DR_DR_Pos)              /*!< 0x000001FF */
N#define USART_DR_DR                   USART_DR_DR_Msk                          /*!<Data value */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define USART_BRR_DIV_Fraction_Pos    (0U)                                     
N#define USART_BRR_DIV_Fraction_Msk    (0xFUL << USART_BRR_DIV_Fraction_Pos)     /*!< 0x0000000F */
N#define USART_BRR_DIV_Fraction        USART_BRR_DIV_Fraction_Msk               /*!<Fraction of USARTDIV */
N#define USART_BRR_DIV_Mantissa_Pos    (4U)                                     
N#define USART_BRR_DIV_Mantissa_Msk    (0xFFFUL << USART_BRR_DIV_Mantissa_Pos)   /*!< 0x0000FFF0 */
N#define USART_BRR_DIV_Mantissa        USART_BRR_DIV_Mantissa_Msk               /*!<Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_CR1 register  *******************/
N#define USART_CR1_SBK_Pos             (0U)                                     
N#define USART_CR1_SBK_Msk             (0x1UL << USART_CR1_SBK_Pos)              /*!< 0x00000001 */
N#define USART_CR1_SBK                 USART_CR1_SBK_Msk                        /*!<Send Break                             */
N#define USART_CR1_RWU_Pos             (1U)                                     
N#define USART_CR1_RWU_Msk             (0x1UL << USART_CR1_RWU_Pos)              /*!< 0x00000002 */
N#define USART_CR1_RWU                 USART_CR1_RWU_Msk                        /*!<Receiver wakeup                        */
N#define USART_CR1_RE_Pos              (2U)                                     
N#define USART_CR1_RE_Msk              (0x1UL << USART_CR1_RE_Pos)               /*!< 0x00000004 */
N#define USART_CR1_RE                  USART_CR1_RE_Msk                         /*!<Receiver Enable                        */
N#define USART_CR1_TE_Pos              (3U)                                     
N#define USART_CR1_TE_Msk              (0x1UL << USART_CR1_TE_Pos)               /*!< 0x00000008 */
N#define USART_CR1_TE                  USART_CR1_TE_Msk                         /*!<Transmitter Enable                     */
N#define USART_CR1_IDLEIE_Pos          (4U)                                     
N#define USART_CR1_IDLEIE_Msk          (0x1UL << USART_CR1_IDLEIE_Pos)           /*!< 0x00000010 */
N#define USART_CR1_IDLEIE              USART_CR1_IDLEIE_Msk                     /*!<IDLE Interrupt Enable                  */
N#define USART_CR1_RXNEIE_Pos          (5U)                                     
N#define USART_CR1_RXNEIE_Msk          (0x1UL << USART_CR1_RXNEIE_Pos)           /*!< 0x00000020 */
N#define USART_CR1_RXNEIE              USART_CR1_RXNEIE_Msk                     /*!<RXNE Interrupt Enable                  */
N#define USART_CR1_TCIE_Pos            (6U)                                     
N#define USART_CR1_TCIE_Msk            (0x1UL << USART_CR1_TCIE_Pos)             /*!< 0x00000040 */
N#define USART_CR1_TCIE                USART_CR1_TCIE_Msk                       /*!<Transmission Complete Interrupt Enable */
N#define USART_CR1_TXEIE_Pos           (7U)                                     
N#define USART_CR1_TXEIE_Msk           (0x1UL << USART_CR1_TXEIE_Pos)            /*!< 0x00000080 */
N#define USART_CR1_TXEIE               USART_CR1_TXEIE_Msk                      /*!<TXE Interrupt Enable                   */
N#define USART_CR1_PEIE_Pos            (8U)                                     
N#define USART_CR1_PEIE_Msk            (0x1UL << USART_CR1_PEIE_Pos)             /*!< 0x00000100 */
N#define USART_CR1_PEIE                USART_CR1_PEIE_Msk                       /*!<PE Interrupt Enable                    */
N#define USART_CR1_PS_Pos              (9U)                                     
N#define USART_CR1_PS_Msk              (0x1UL << USART_CR1_PS_Pos)               /*!< 0x00000200 */
N#define USART_CR1_PS                  USART_CR1_PS_Msk                         /*!<Parity Selection                       */
N#define USART_CR1_PCE_Pos             (10U)                                    
N#define USART_CR1_PCE_Msk             (0x1UL << USART_CR1_PCE_Pos)              /*!< 0x00000400 */
N#define USART_CR1_PCE                 USART_CR1_PCE_Msk                        /*!<Parity Control Enable                  */
N#define USART_CR1_WAKE_Pos            (11U)                                    
N#define USART_CR1_WAKE_Msk            (0x1UL << USART_CR1_WAKE_Pos)             /*!< 0x00000800 */
N#define USART_CR1_WAKE                USART_CR1_WAKE_Msk                       /*!<Wakeup method                          */
N#define USART_CR1_M_Pos               (12U)                                    
N#define USART_CR1_M_Msk               (0x1UL << USART_CR1_M_Pos)                /*!< 0x00001000 */
N#define USART_CR1_M                   USART_CR1_M_Msk                          /*!<Word length                            */
N#define USART_CR1_UE_Pos              (13U)                                    
N#define USART_CR1_UE_Msk              (0x1UL << USART_CR1_UE_Pos)               /*!< 0x00002000 */
N#define USART_CR1_UE                  USART_CR1_UE_Msk                         /*!<USART Enable                           */
N#define USART_CR1_OVER8_Pos           (15U)                                    
N#define USART_CR1_OVER8_Msk           (0x1UL << USART_CR1_OVER8_Pos)            /*!< 0x00008000 */
N#define USART_CR1_OVER8               USART_CR1_OVER8_Msk                      /*!<USART Oversampling by 8 enable         */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define USART_CR2_ADD_Pos             (0U)                                     
N#define USART_CR2_ADD_Msk             (0xFUL << USART_CR2_ADD_Pos)              /*!< 0x0000000F */
N#define USART_CR2_ADD                 USART_CR2_ADD_Msk                        /*!<Address of the USART node            */
N#define USART_CR2_LBDL_Pos            (5U)                                     
N#define USART_CR2_LBDL_Msk            (0x1UL << USART_CR2_LBDL_Pos)             /*!< 0x00000020 */
N#define USART_CR2_LBDL                USART_CR2_LBDL_Msk                       /*!<LIN Break Detection Length           */
N#define USART_CR2_LBDIE_Pos           (6U)                                     
N#define USART_CR2_LBDIE_Msk           (0x1UL << USART_CR2_LBDIE_Pos)            /*!< 0x00000040 */
N#define USART_CR2_LBDIE               USART_CR2_LBDIE_Msk                      /*!<LIN Break Detection Interrupt Enable */
N#define USART_CR2_LBCL_Pos            (8U)                                     
N#define USART_CR2_LBCL_Msk            (0x1UL << USART_CR2_LBCL_Pos)             /*!< 0x00000100 */
N#define USART_CR2_LBCL                USART_CR2_LBCL_Msk                       /*!<Last Bit Clock pulse                 */
N#define USART_CR2_CPHA_Pos            (9U)                                     
N#define USART_CR2_CPHA_Msk            (0x1UL << USART_CR2_CPHA_Pos)             /*!< 0x00000200 */
N#define USART_CR2_CPHA                USART_CR2_CPHA_Msk                       /*!<Clock Phase                          */
N#define USART_CR2_CPOL_Pos            (10U)                                    
N#define USART_CR2_CPOL_Msk            (0x1UL << USART_CR2_CPOL_Pos)             /*!< 0x00000400 */
N#define USART_CR2_CPOL                USART_CR2_CPOL_Msk                       /*!<Clock Polarity                       */
N#define USART_CR2_CLKEN_Pos           (11U)                                    
N#define USART_CR2_CLKEN_Msk           (0x1UL << USART_CR2_CLKEN_Pos)            /*!< 0x00000800 */
N#define USART_CR2_CLKEN               USART_CR2_CLKEN_Msk                      /*!<Clock Enable                         */
N
N#define USART_CR2_STOP_Pos            (12U)                                    
N#define USART_CR2_STOP_Msk            (0x3UL << USART_CR2_STOP_Pos)             /*!< 0x00003000 */
N#define USART_CR2_STOP                USART_CR2_STOP_Msk                       /*!<STOP[1:0] bits (STOP bits) */
N#define USART_CR2_STOP_0              (0x1UL << USART_CR2_STOP_Pos)             /*!< 0x1000 */
N#define USART_CR2_STOP_1              (0x2UL << USART_CR2_STOP_Pos)             /*!< 0x2000 */
N
N#define USART_CR2_LINEN_Pos           (14U)                                    
N#define USART_CR2_LINEN_Msk           (0x1UL << USART_CR2_LINEN_Pos)            /*!< 0x00004000 */
N#define USART_CR2_LINEN               USART_CR2_LINEN_Msk                      /*!<LIN mode enable */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define USART_CR3_EIE_Pos             (0U)                                     
N#define USART_CR3_EIE_Msk             (0x1UL << USART_CR3_EIE_Pos)              /*!< 0x00000001 */
N#define USART_CR3_EIE                 USART_CR3_EIE_Msk                        /*!<Error Interrupt Enable      */
N#define USART_CR3_IREN_Pos            (1U)                                     
N#define USART_CR3_IREN_Msk            (0x1UL << USART_CR3_IREN_Pos)             /*!< 0x00000002 */
N#define USART_CR3_IREN                USART_CR3_IREN_Msk                       /*!<IrDA mode Enable            */
N#define USART_CR3_IRLP_Pos            (2U)                                     
N#define USART_CR3_IRLP_Msk            (0x1UL << USART_CR3_IRLP_Pos)             /*!< 0x00000004 */
N#define USART_CR3_IRLP                USART_CR3_IRLP_Msk                       /*!<IrDA Low-Power              */
N#define USART_CR3_HDSEL_Pos           (3U)                                     
N#define USART_CR3_HDSEL_Msk           (0x1UL << USART_CR3_HDSEL_Pos)            /*!< 0x00000008 */
N#define USART_CR3_HDSEL               USART_CR3_HDSEL_Msk                      /*!<Half-Duplex Selection       */
N#define USART_CR3_NACK_Pos            (4U)                                     
N#define USART_CR3_NACK_Msk            (0x1UL << USART_CR3_NACK_Pos)             /*!< 0x00000010 */
N#define USART_CR3_NACK                USART_CR3_NACK_Msk                       /*!<Smartcard NACK enable       */
N#define USART_CR3_SCEN_Pos            (5U)                                     
N#define USART_CR3_SCEN_Msk            (0x1UL << USART_CR3_SCEN_Pos)             /*!< 0x00000020 */
N#define USART_CR3_SCEN                USART_CR3_SCEN_Msk                       /*!<Smartcard mode enable       */
N#define USART_CR3_DMAR_Pos            (6U)                                     
N#define USART_CR3_DMAR_Msk            (0x1UL << USART_CR3_DMAR_Pos)             /*!< 0x00000040 */
N#define USART_CR3_DMAR                USART_CR3_DMAR_Msk                       /*!<DMA Enable Receiver         */
N#define USART_CR3_DMAT_Pos            (7U)                                     
N#define USART_CR3_DMAT_Msk            (0x1UL << USART_CR3_DMAT_Pos)             /*!< 0x00000080 */
N#define USART_CR3_DMAT                USART_CR3_DMAT_Msk                       /*!<DMA Enable Transmitter      */
N#define USART_CR3_RTSE_Pos            (8U)                                     
N#define USART_CR3_RTSE_Msk            (0x1UL << USART_CR3_RTSE_Pos)             /*!< 0x00000100 */
N#define USART_CR3_RTSE                USART_CR3_RTSE_Msk                       /*!<RTS Enable                  */
N#define USART_CR3_CTSE_Pos            (9U)                                     
N#define USART_CR3_CTSE_Msk            (0x1UL << USART_CR3_CTSE_Pos)             /*!< 0x00000200 */
N#define USART_CR3_CTSE                USART_CR3_CTSE_Msk                       /*!<CTS Enable                  */
N#define USART_CR3_CTSIE_Pos           (10U)                                    
N#define USART_CR3_CTSIE_Msk           (0x1UL << USART_CR3_CTSIE_Pos)            /*!< 0x00000400 */
N#define USART_CR3_CTSIE               USART_CR3_CTSIE_Msk                      /*!<CTS Interrupt Enable        */
N#define USART_CR3_ONEBIT_Pos          (11U)                                    
N#define USART_CR3_ONEBIT_Msk          (0x1UL << USART_CR3_ONEBIT_Pos)           /*!< 0x00000800 */
N#define USART_CR3_ONEBIT              USART_CR3_ONEBIT_Msk                     /*!<USART One bit method enable */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define USART_GTPR_PSC_Pos            (0U)                                     
N#define USART_GTPR_PSC_Msk            (0xFFUL << USART_GTPR_PSC_Pos)            /*!< 0x000000FF */
N#define USART_GTPR_PSC                USART_GTPR_PSC_Msk                       /*!<PSC[7:0] bits (Prescaler value) */
N#define USART_GTPR_PSC_0              (0x01UL << USART_GTPR_PSC_Pos)            /*!< 0x0001 */
N#define USART_GTPR_PSC_1              (0x02UL << USART_GTPR_PSC_Pos)            /*!< 0x0002 */
N#define USART_GTPR_PSC_2              (0x04UL << USART_GTPR_PSC_Pos)            /*!< 0x0004 */
N#define USART_GTPR_PSC_3              (0x08UL << USART_GTPR_PSC_Pos)            /*!< 0x0008 */
N#define USART_GTPR_PSC_4              (0x10UL << USART_GTPR_PSC_Pos)            /*!< 0x0010 */
N#define USART_GTPR_PSC_5              (0x20UL << USART_GTPR_PSC_Pos)            /*!< 0x0020 */
N#define USART_GTPR_PSC_6              (0x40UL << USART_GTPR_PSC_Pos)            /*!< 0x0040 */
N#define USART_GTPR_PSC_7              (0x80UL << USART_GTPR_PSC_Pos)            /*!< 0x0080 */
N
N#define USART_GTPR_GT_Pos             (8U)                                     
N#define USART_GTPR_GT_Msk             (0xFFUL << USART_GTPR_GT_Pos)             /*!< 0x0000FF00 */
N#define USART_GTPR_GT                 USART_GTPR_GT_Msk                        /*!<Guard time value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Window WATCHDOG                                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define WWDG_CR_T_Pos           (0U)                                           
N#define WWDG_CR_T_Msk           (0x7FUL << WWDG_CR_T_Pos)                       /*!< 0x0000007F */
N#define WWDG_CR_T               WWDG_CR_T_Msk                                  /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define WWDG_CR_T_0             (0x01UL << WWDG_CR_T_Pos)                       /*!< 0x01 */
N#define WWDG_CR_T_1             (0x02UL << WWDG_CR_T_Pos)                       /*!< 0x02 */
N#define WWDG_CR_T_2             (0x04UL << WWDG_CR_T_Pos)                       /*!< 0x04 */
N#define WWDG_CR_T_3             (0x08UL << WWDG_CR_T_Pos)                       /*!< 0x08 */
N#define WWDG_CR_T_4             (0x10UL << WWDG_CR_T_Pos)                       /*!< 0x10 */
N#define WWDG_CR_T_5             (0x20UL << WWDG_CR_T_Pos)                       /*!< 0x20 */
N#define WWDG_CR_T_6             (0x40UL << WWDG_CR_T_Pos)                       /*!< 0x40 */
N/* Legacy defines */
N#define  WWDG_CR_T0                          WWDG_CR_T_0
N#define  WWDG_CR_T1                          WWDG_CR_T_1
N#define  WWDG_CR_T2                          WWDG_CR_T_2
N#define  WWDG_CR_T3                          WWDG_CR_T_3
N#define  WWDG_CR_T4                          WWDG_CR_T_4
N#define  WWDG_CR_T5                          WWDG_CR_T_5
N#define  WWDG_CR_T6                          WWDG_CR_T_6
N
N#define WWDG_CR_WDGA_Pos        (7U)                                           
N#define WWDG_CR_WDGA_Msk        (0x1UL << WWDG_CR_WDGA_Pos)                     /*!< 0x00000080 */
N#define WWDG_CR_WDGA            WWDG_CR_WDGA_Msk                               /*!<Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define WWDG_CFR_W_Pos          (0U)                                           
N#define WWDG_CFR_W_Msk          (0x7FUL << WWDG_CFR_W_Pos)                      /*!< 0x0000007F */
N#define WWDG_CFR_W              WWDG_CFR_W_Msk                                 /*!<W[6:0] bits (7-bit window value) */
N#define WWDG_CFR_W_0            (0x01UL << WWDG_CFR_W_Pos)                      /*!< 0x0001 */
N#define WWDG_CFR_W_1            (0x02UL << WWDG_CFR_W_Pos)                      /*!< 0x0002 */
N#define WWDG_CFR_W_2            (0x04UL << WWDG_CFR_W_Pos)                      /*!< 0x0004 */
N#define WWDG_CFR_W_3            (0x08UL << WWDG_CFR_W_Pos)                      /*!< 0x0008 */
N#define WWDG_CFR_W_4            (0x10UL << WWDG_CFR_W_Pos)                      /*!< 0x0010 */
N#define WWDG_CFR_W_5            (0x20UL << WWDG_CFR_W_Pos)                      /*!< 0x0020 */
N#define WWDG_CFR_W_6            (0x40UL << WWDG_CFR_W_Pos)                      /*!< 0x0040 */
N/* Legacy defines */
N#define  WWDG_CFR_W0                         WWDG_CFR_W_0
N#define  WWDG_CFR_W1                         WWDG_CFR_W_1
N#define  WWDG_CFR_W2                         WWDG_CFR_W_2
N#define  WWDG_CFR_W3                         WWDG_CFR_W_3
N#define  WWDG_CFR_W4                         WWDG_CFR_W_4
N#define  WWDG_CFR_W5                         WWDG_CFR_W_5
N#define  WWDG_CFR_W6                         WWDG_CFR_W_6
N
N#define WWDG_CFR_WDGTB_Pos      (7U)                                           
N#define WWDG_CFR_WDGTB_Msk      (0x3UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x00000180 */
N#define WWDG_CFR_WDGTB          WWDG_CFR_WDGTB_Msk                             /*!<WDGTB[1:0] bits (Timer Base) */
N#define WWDG_CFR_WDGTB_0        (0x1UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x0080 */
N#define WWDG_CFR_WDGTB_1        (0x2UL << WWDG_CFR_WDGTB_Pos)                   /*!< 0x0100 */
N/* Legacy defines */
N#define  WWDG_CFR_WDGTB0                     WWDG_CFR_WDGTB_0
N#define  WWDG_CFR_WDGTB1                     WWDG_CFR_WDGTB_1
N
N#define WWDG_CFR_EWI_Pos        (9U)                                           
N#define WWDG_CFR_EWI_Msk        (0x1UL << WWDG_CFR_EWI_Pos)                     /*!< 0x00000200 */
N#define WWDG_CFR_EWI            WWDG_CFR_EWI_Msk                               /*!<Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define WWDG_SR_EWIF_Pos        (0U)                                           
N#define WWDG_SR_EWIF_Msk        (0x1UL << WWDG_SR_EWIF_Pos)                     /*!< 0x00000001 */
N#define WWDG_SR_EWIF            WWDG_SR_EWIF_Msk                               /*!<Early Wakeup Interrupt Flag */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                                DBG                                         */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DBGMCU_IDCODE register  *************/
N#define DBGMCU_IDCODE_DEV_ID_Pos                     (0U)                      
N#define DBGMCU_IDCODE_DEV_ID_Msk                     (0xFFFUL << DBGMCU_IDCODE_DEV_ID_Pos) /*!< 0x00000FFF */
N#define DBGMCU_IDCODE_DEV_ID                         DBGMCU_IDCODE_DEV_ID_Msk  
N#define DBGMCU_IDCODE_REV_ID_Pos                     (16U)                     
N#define DBGMCU_IDCODE_REV_ID_Msk                     (0xFFFFUL << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0xFFFF0000 */
N#define DBGMCU_IDCODE_REV_ID                         DBGMCU_IDCODE_REV_ID_Msk  
N
N/********************  Bit definition for DBGMCU_CR register  *****************/
N#define DBGMCU_CR_DBG_SLEEP_Pos                      (0U)                      
N#define DBGMCU_CR_DBG_SLEEP_Msk                      (0x1UL << DBGMCU_CR_DBG_SLEEP_Pos) /*!< 0x00000001 */
N#define DBGMCU_CR_DBG_SLEEP                          DBGMCU_CR_DBG_SLEEP_Msk   
N#define DBGMCU_CR_DBG_STOP_Pos                       (1U)                      
N#define DBGMCU_CR_DBG_STOP_Msk                       (0x1UL << DBGMCU_CR_DBG_STOP_Pos) /*!< 0x00000002 */
N#define DBGMCU_CR_DBG_STOP                           DBGMCU_CR_DBG_STOP_Msk    
N#define DBGMCU_CR_DBG_STANDBY_Pos                    (2U)                      
N#define DBGMCU_CR_DBG_STANDBY_Msk                    (0x1UL << DBGMCU_CR_DBG_STANDBY_Pos) /*!< 0x00000004 */
N#define DBGMCU_CR_DBG_STANDBY                        DBGMCU_CR_DBG_STANDBY_Msk 
N#define DBGMCU_CR_TRACE_IOEN_Pos                     (5U)                      
N#define DBGMCU_CR_TRACE_IOEN_Msk                     (0x1UL << DBGMCU_CR_TRACE_IOEN_Pos) /*!< 0x00000020 */
N#define DBGMCU_CR_TRACE_IOEN                         DBGMCU_CR_TRACE_IOEN_Msk  
N
N#define DBGMCU_CR_TRACE_MODE_Pos                     (6U)                      
N#define DBGMCU_CR_TRACE_MODE_Msk                     (0x3UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x000000C0 */
N#define DBGMCU_CR_TRACE_MODE                         DBGMCU_CR_TRACE_MODE_Msk  
N#define DBGMCU_CR_TRACE_MODE_0                       (0x1UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x00000040 */
N#define DBGMCU_CR_TRACE_MODE_1                       (0x2UL << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x00000080 */
N
N/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos             (0U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos) /*!< 0x00000001 */
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP                 DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos             (1U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos) /*!< 0x00000002 */
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP                 DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM4_STOP_Pos             (2U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM4_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM4_STOP_Pos) /*!< 0x00000004 */
N#define DBGMCU_APB1_FZ_DBG_TIM4_STOP                 DBGMCU_APB1_FZ_DBG_TIM4_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_TIM5_STOP_Pos             (3U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM5_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_TIM5_STOP_Pos) /*!< 0x00000008 */
N#define DBGMCU_APB1_FZ_DBG_TIM5_STOP                 DBGMCU_APB1_FZ_DBG_TIM5_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos              (10U)                     
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk              (0x1UL << DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos) /*!< 0x00000400 */
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP                  DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos             (11U)                     
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos) /*!< 0x00000800 */
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP                 DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos             (12U)                     
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk             (0x1UL << DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos) /*!< 0x00001000 */
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP                 DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk 
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos    (21U)                     
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk    (0x1UL << DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos) /*!< 0x00200000 */
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT        DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk 
N#define DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Pos    (22U)                     
N#define DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Msk    (0x1UL << DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Pos) /*!< 0x00400000 */
N#define DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT        DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Msk 
N#define DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Pos    (23U)                     
N#define DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Msk    (0x1UL << DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Pos) /*!< 0x00800000 */
N#define DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT        DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Msk 
N/* Old IWDGSTOP bit definition, maintained for legacy purpose */
N#define  DBGMCU_APB1_FZ_DBG_IWDEG_STOP           DBGMCU_APB1_FZ_DBG_IWDG_STOP
N
N/********************  Bit definition for DBGMCU_APB2_FZ register  ************/
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos             (0U)                      
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk             (0x1UL << DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos) /*!< 0x00000001 */
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP                 DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk 
N#define DBGMCU_APB2_FZ_DBG_TIM9_STOP_Pos             (16U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM9_STOP_Msk             (0x1UL << DBGMCU_APB2_FZ_DBG_TIM9_STOP_Pos) /*!< 0x00010000 */
N#define DBGMCU_APB2_FZ_DBG_TIM9_STOP                 DBGMCU_APB2_FZ_DBG_TIM9_STOP_Msk 
N#define DBGMCU_APB2_FZ_DBG_TIM10_STOP_Pos            (17U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM10_STOP_Msk            (0x1UL << DBGMCU_APB2_FZ_DBG_TIM10_STOP_Pos) /*!< 0x00020000 */
N#define DBGMCU_APB2_FZ_DBG_TIM10_STOP                DBGMCU_APB2_FZ_DBG_TIM10_STOP_Msk 
N#define DBGMCU_APB2_FZ_DBG_TIM11_STOP_Pos            (18U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM11_STOP_Msk            (0x1UL << DBGMCU_APB2_FZ_DBG_TIM11_STOP_Pos) /*!< 0x00040000 */
N#define DBGMCU_APB2_FZ_DBG_TIM11_STOP                DBGMCU_APB2_FZ_DBG_TIM11_STOP_Msk 
N
N/******************************************************************************/
N/*                                                                            */
N/*                                       USB_OTG                              */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for USB_OTG_GOTGCTL register  ***********/
N#define USB_OTG_GOTGCTL_SRQSCS_Pos               (0U)                          
N#define USB_OTG_GOTGCTL_SRQSCS_Msk               (0x1UL << USB_OTG_GOTGCTL_SRQSCS_Pos) /*!< 0x00000001 */
N#define USB_OTG_GOTGCTL_SRQSCS                   USB_OTG_GOTGCTL_SRQSCS_Msk    /*!< Session request success */
N#define USB_OTG_GOTGCTL_SRQ_Pos                  (1U)                          
N#define USB_OTG_GOTGCTL_SRQ_Msk                  (0x1UL << USB_OTG_GOTGCTL_SRQ_Pos) /*!< 0x00000002 */
N#define USB_OTG_GOTGCTL_SRQ                      USB_OTG_GOTGCTL_SRQ_Msk       /*!< Session request */
N#define USB_OTG_GOTGCTL_HNGSCS_Pos               (8U)                          
N#define USB_OTG_GOTGCTL_HNGSCS_Msk               (0x1UL << USB_OTG_GOTGCTL_HNGSCS_Pos) /*!< 0x00000100 */
N#define USB_OTG_GOTGCTL_HNGSCS                   USB_OTG_GOTGCTL_HNGSCS_Msk    /*!< Host set HNP enable */
N#define USB_OTG_GOTGCTL_HNPRQ_Pos                (9U)                          
N#define USB_OTG_GOTGCTL_HNPRQ_Msk                (0x1UL << USB_OTG_GOTGCTL_HNPRQ_Pos) /*!< 0x00000200 */
N#define USB_OTG_GOTGCTL_HNPRQ                    USB_OTG_GOTGCTL_HNPRQ_Msk     /*!< HNP request */
N#define USB_OTG_GOTGCTL_HSHNPEN_Pos              (10U)                         
N#define USB_OTG_GOTGCTL_HSHNPEN_Msk              (0x1UL << USB_OTG_GOTGCTL_HSHNPEN_Pos) /*!< 0x00000400 */
N#define USB_OTG_GOTGCTL_HSHNPEN                  USB_OTG_GOTGCTL_HSHNPEN_Msk   /*!< Host set HNP enable */
N#define USB_OTG_GOTGCTL_DHNPEN_Pos               (11U)                         
N#define USB_OTG_GOTGCTL_DHNPEN_Msk               (0x1UL << USB_OTG_GOTGCTL_DHNPEN_Pos) /*!< 0x00000800 */
N#define USB_OTG_GOTGCTL_DHNPEN                   USB_OTG_GOTGCTL_DHNPEN_Msk    /*!< Device HNP enabled */
N#define USB_OTG_GOTGCTL_CIDSTS_Pos               (16U)                         
N#define USB_OTG_GOTGCTL_CIDSTS_Msk               (0x1UL << USB_OTG_GOTGCTL_CIDSTS_Pos) /*!< 0x00010000 */
N#define USB_OTG_GOTGCTL_CIDSTS                   USB_OTG_GOTGCTL_CIDSTS_Msk    /*!< Connector ID status */
N#define USB_OTG_GOTGCTL_DBCT_Pos                 (17U)                         
N#define USB_OTG_GOTGCTL_DBCT_Msk                 (0x1UL << USB_OTG_GOTGCTL_DBCT_Pos) /*!< 0x00020000 */
N#define USB_OTG_GOTGCTL_DBCT                     USB_OTG_GOTGCTL_DBCT_Msk      /*!< Long/short debounce time */
N#define USB_OTG_GOTGCTL_ASVLD_Pos                (18U)                         
N#define USB_OTG_GOTGCTL_ASVLD_Msk                (0x1UL << USB_OTG_GOTGCTL_ASVLD_Pos) /*!< 0x00040000 */
N#define USB_OTG_GOTGCTL_ASVLD                    USB_OTG_GOTGCTL_ASVLD_Msk     /*!< A-session valid  */
N#define USB_OTG_GOTGCTL_BSVLD_Pos                (19U)                         
N#define USB_OTG_GOTGCTL_BSVLD_Msk                (0x1UL << USB_OTG_GOTGCTL_BSVLD_Pos) /*!< 0x00080000 */
N#define USB_OTG_GOTGCTL_BSVLD                    USB_OTG_GOTGCTL_BSVLD_Msk     /*!< B-session valid */
N
N/********************  Bit definition forUSB_OTG_HCFG register  ********************/
N
N#define USB_OTG_HCFG_FSLSPCS_Pos                 (0U)                          
N#define USB_OTG_HCFG_FSLSPCS_Msk                 (0x3UL << USB_OTG_HCFG_FSLSPCS_Pos) /*!< 0x00000003 */
N#define USB_OTG_HCFG_FSLSPCS                     USB_OTG_HCFG_FSLSPCS_Msk      /*!< FS/LS PHY clock select  */
N#define USB_OTG_HCFG_FSLSPCS_0                   (0x1UL << USB_OTG_HCFG_FSLSPCS_Pos) /*!< 0x00000001 */
N#define USB_OTG_HCFG_FSLSPCS_1                   (0x2UL << USB_OTG_HCFG_FSLSPCS_Pos) /*!< 0x00000002 */
N#define USB_OTG_HCFG_FSLSS_Pos                   (2U)                          
N#define USB_OTG_HCFG_FSLSS_Msk                   (0x1UL << USB_OTG_HCFG_FSLSS_Pos) /*!< 0x00000004 */
N#define USB_OTG_HCFG_FSLSS                       USB_OTG_HCFG_FSLSS_Msk        /*!< FS- and LS-only support */
N
N/********************  Bit definition for USB_OTG_DCFG register  ********************/
N
N#define USB_OTG_DCFG_DSPD_Pos                    (0U)                          
N#define USB_OTG_DCFG_DSPD_Msk                    (0x3UL << USB_OTG_DCFG_DSPD_Pos) /*!< 0x00000003 */
N#define USB_OTG_DCFG_DSPD                        USB_OTG_DCFG_DSPD_Msk         /*!< Device speed */
N#define USB_OTG_DCFG_DSPD_0                      (0x1UL << USB_OTG_DCFG_DSPD_Pos) /*!< 0x00000001 */
N#define USB_OTG_DCFG_DSPD_1                      (0x2UL << USB_OTG_DCFG_DSPD_Pos) /*!< 0x00000002 */
N#define USB_OTG_DCFG_NZLSOHSK_Pos                (2U)                          
N#define USB_OTG_DCFG_NZLSOHSK_Msk                (0x1UL << USB_OTG_DCFG_NZLSOHSK_Pos) /*!< 0x00000004 */
N#define USB_OTG_DCFG_NZLSOHSK                    USB_OTG_DCFG_NZLSOHSK_Msk     /*!< Nonzero-length status OUT handshake */
N
N#define USB_OTG_DCFG_DAD_Pos                     (4U)                          
N#define USB_OTG_DCFG_DAD_Msk                     (0x7FUL << USB_OTG_DCFG_DAD_Pos) /*!< 0x000007F0 */
N#define USB_OTG_DCFG_DAD                         USB_OTG_DCFG_DAD_Msk          /*!< Device address */
N#define USB_OTG_DCFG_DAD_0                       (0x01UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000010 */
N#define USB_OTG_DCFG_DAD_1                       (0x02UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000020 */
N#define USB_OTG_DCFG_DAD_2                       (0x04UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000040 */
N#define USB_OTG_DCFG_DAD_3                       (0x08UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000080 */
N#define USB_OTG_DCFG_DAD_4                       (0x10UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000100 */
N#define USB_OTG_DCFG_DAD_5                       (0x20UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000200 */
N#define USB_OTG_DCFG_DAD_6                       (0x40UL << USB_OTG_DCFG_DAD_Pos) /*!< 0x00000400 */
N
N#define USB_OTG_DCFG_PFIVL_Pos                   (11U)                         
N#define USB_OTG_DCFG_PFIVL_Msk                   (0x3UL << USB_OTG_DCFG_PFIVL_Pos) /*!< 0x00001800 */
N#define USB_OTG_DCFG_PFIVL                       USB_OTG_DCFG_PFIVL_Msk        /*!< Periodic (micro)frame interval */
N#define USB_OTG_DCFG_PFIVL_0                     (0x1UL << USB_OTG_DCFG_PFIVL_Pos) /*!< 0x00000800 */
N#define USB_OTG_DCFG_PFIVL_1                     (0x2UL << USB_OTG_DCFG_PFIVL_Pos) /*!< 0x00001000 */
N
N#define USB_OTG_DCFG_XCVRDLY_Pos                 (14U)                         
N#define USB_OTG_DCFG_XCVRDLY_Msk                 (0x1UL << USB_OTG_DCFG_XCVRDLY_Pos) /*!< 0x00004000 */
N#define USB_OTG_DCFG_XCVRDLY                     USB_OTG_DCFG_XCVRDLY_Msk        /*!< Transceiver delay */
N
N#define USB_OTG_DCFG_ERRATIM_Pos                 (15U)                         
N#define USB_OTG_DCFG_ERRATIM_Msk                 (0x1UL << USB_OTG_DCFG_ERRATIM_Pos) /*!< 0x00008000 */
N#define USB_OTG_DCFG_ERRATIM                     USB_OTG_DCFG_ERRATIM_Msk        /*!< Erratic error interrupt mask */
N
N#define USB_OTG_DCFG_PERSCHIVL_Pos               (24U)                         
N#define USB_OTG_DCFG_PERSCHIVL_Msk               (0x3UL << USB_OTG_DCFG_PERSCHIVL_Pos) /*!< 0x03000000 */
N#define USB_OTG_DCFG_PERSCHIVL                   USB_OTG_DCFG_PERSCHIVL_Msk    /*!< Periodic scheduling interval */
N#define USB_OTG_DCFG_PERSCHIVL_0                 (0x1UL << USB_OTG_DCFG_PERSCHIVL_Pos) /*!< 0x01000000 */
N#define USB_OTG_DCFG_PERSCHIVL_1                 (0x2UL << USB_OTG_DCFG_PERSCHIVL_Pos) /*!< 0x02000000 */
N
N/********************  Bit definition for USB_OTG_PCGCR register  ********************/
N#define USB_OTG_PCGCR_STPPCLK_Pos                (0U)                          
N#define USB_OTG_PCGCR_STPPCLK_Msk                (0x1UL << USB_OTG_PCGCR_STPPCLK_Pos) /*!< 0x00000001 */
N#define USB_OTG_PCGCR_STPPCLK                    USB_OTG_PCGCR_STPPCLK_Msk     /*!< Stop PHY clock */
N#define USB_OTG_PCGCR_GATEHCLK_Pos               (1U)                          
N#define USB_OTG_PCGCR_GATEHCLK_Msk               (0x1UL << USB_OTG_PCGCR_GATEHCLK_Pos) /*!< 0x00000002 */
N#define USB_OTG_PCGCR_GATEHCLK                   USB_OTG_PCGCR_GATEHCLK_Msk    /*!< Gate HCLK */
N#define USB_OTG_PCGCR_PHYSUSP_Pos                (4U)                          
N#define USB_OTG_PCGCR_PHYSUSP_Msk                (0x1UL << USB_OTG_PCGCR_PHYSUSP_Pos) /*!< 0x00000010 */
N#define USB_OTG_PCGCR_PHYSUSP                    USB_OTG_PCGCR_PHYSUSP_Msk     /*!< PHY suspended */
N
N/********************  Bit definition for USB_OTG_GOTGINT register  ********************/
N#define USB_OTG_GOTGINT_SEDET_Pos                (2U)                          
N#define USB_OTG_GOTGINT_SEDET_Msk                (0x1UL << USB_OTG_GOTGINT_SEDET_Pos) /*!< 0x00000004 */
N#define USB_OTG_GOTGINT_SEDET                    USB_OTG_GOTGINT_SEDET_Msk     /*!< Session end detected                   */
N#define USB_OTG_GOTGINT_SRSSCHG_Pos              (8U)                          
N#define USB_OTG_GOTGINT_SRSSCHG_Msk              (0x1UL << USB_OTG_GOTGINT_SRSSCHG_Pos) /*!< 0x00000100 */
N#define USB_OTG_GOTGINT_SRSSCHG                  USB_OTG_GOTGINT_SRSSCHG_Msk   /*!< Session request success status change  */
N#define USB_OTG_GOTGINT_HNSSCHG_Pos              (9U)                          
N#define USB_OTG_GOTGINT_HNSSCHG_Msk              (0x1UL << USB_OTG_GOTGINT_HNSSCHG_Pos) /*!< 0x00000200 */
N#define USB_OTG_GOTGINT_HNSSCHG                  USB_OTG_GOTGINT_HNSSCHG_Msk   /*!< Host negotiation success status change */
N#define USB_OTG_GOTGINT_HNGDET_Pos               (17U)                         
N#define USB_OTG_GOTGINT_HNGDET_Msk               (0x1UL << USB_OTG_GOTGINT_HNGDET_Pos) /*!< 0x00020000 */
N#define USB_OTG_GOTGINT_HNGDET                   USB_OTG_GOTGINT_HNGDET_Msk    /*!< Host negotiation detected              */
N#define USB_OTG_GOTGINT_ADTOCHG_Pos              (18U)                         
N#define USB_OTG_GOTGINT_ADTOCHG_Msk              (0x1UL << USB_OTG_GOTGINT_ADTOCHG_Pos) /*!< 0x00040000 */
N#define USB_OTG_GOTGINT_ADTOCHG                  USB_OTG_GOTGINT_ADTOCHG_Msk   /*!< A-device timeout change                */
N#define USB_OTG_GOTGINT_DBCDNE_Pos               (19U)                         
N#define USB_OTG_GOTGINT_DBCDNE_Msk               (0x1UL << USB_OTG_GOTGINT_DBCDNE_Pos) /*!< 0x00080000 */
N#define USB_OTG_GOTGINT_DBCDNE                   USB_OTG_GOTGINT_DBCDNE_Msk    /*!< Debounce done                          */
N
N/********************  Bit definition for USB_OTG_DCTL register  ********************/
N#define USB_OTG_DCTL_RWUSIG_Pos                  (0U)                          
N#define USB_OTG_DCTL_RWUSIG_Msk                  (0x1UL << USB_OTG_DCTL_RWUSIG_Pos) /*!< 0x00000001 */
N#define USB_OTG_DCTL_RWUSIG                      USB_OTG_DCTL_RWUSIG_Msk       /*!< Remote wakeup signaling */
N#define USB_OTG_DCTL_SDIS_Pos                    (1U)                          
N#define USB_OTG_DCTL_SDIS_Msk                    (0x1UL << USB_OTG_DCTL_SDIS_Pos) /*!< 0x00000002 */
N#define USB_OTG_DCTL_SDIS                        USB_OTG_DCTL_SDIS_Msk         /*!< Soft disconnect         */
N#define USB_OTG_DCTL_GINSTS_Pos                  (2U)                          
N#define USB_OTG_DCTL_GINSTS_Msk                  (0x1UL << USB_OTG_DCTL_GINSTS_Pos) /*!< 0x00000004 */
N#define USB_OTG_DCTL_GINSTS                      USB_OTG_DCTL_GINSTS_Msk       /*!< Global IN NAK status    */
N#define USB_OTG_DCTL_GONSTS_Pos                  (3U)                          
N#define USB_OTG_DCTL_GONSTS_Msk                  (0x1UL << USB_OTG_DCTL_GONSTS_Pos) /*!< 0x00000008 */
N#define USB_OTG_DCTL_GONSTS                      USB_OTG_DCTL_GONSTS_Msk       /*!< Global OUT NAK status   */
N
N#define USB_OTG_DCTL_TCTL_Pos                    (4U)                          
N#define USB_OTG_DCTL_TCTL_Msk                    (0x7UL << USB_OTG_DCTL_TCTL_Pos) /*!< 0x00000070 */
N#define USB_OTG_DCTL_TCTL                        USB_OTG_DCTL_TCTL_Msk         /*!< Test control */
N#define USB_OTG_DCTL_TCTL_0                      (0x1UL << USB_OTG_DCTL_TCTL_Pos) /*!< 0x00000010 */
N#define USB_OTG_DCTL_TCTL_1                      (0x2UL << USB_OTG_DCTL_TCTL_Pos) /*!< 0x00000020 */
N#define USB_OTG_DCTL_TCTL_2                      (0x4UL << USB_OTG_DCTL_TCTL_Pos) /*!< 0x00000040 */
N#define USB_OTG_DCTL_SGINAK_Pos                  (7U)                          
N#define USB_OTG_DCTL_SGINAK_Msk                  (0x1UL << USB_OTG_DCTL_SGINAK_Pos) /*!< 0x00000080 */
N#define USB_OTG_DCTL_SGINAK                      USB_OTG_DCTL_SGINAK_Msk       /*!< Set global IN NAK         */
N#define USB_OTG_DCTL_CGINAK_Pos                  (8U)                          
N#define USB_OTG_DCTL_CGINAK_Msk                  (0x1UL << USB_OTG_DCTL_CGINAK_Pos) /*!< 0x00000100 */
N#define USB_OTG_DCTL_CGINAK                      USB_OTG_DCTL_CGINAK_Msk       /*!< Clear global IN NAK       */
N#define USB_OTG_DCTL_SGONAK_Pos                  (9U)                          
N#define USB_OTG_DCTL_SGONAK_Msk                  (0x1UL << USB_OTG_DCTL_SGONAK_Pos) /*!< 0x00000200 */
N#define USB_OTG_DCTL_SGONAK                      USB_OTG_DCTL_SGONAK_Msk       /*!< Set global OUT NAK        */
N#define USB_OTG_DCTL_CGONAK_Pos                  (10U)                         
N#define USB_OTG_DCTL_CGONAK_Msk                  (0x1UL << USB_OTG_DCTL_CGONAK_Pos) /*!< 0x00000400 */
N#define USB_OTG_DCTL_CGONAK                      USB_OTG_DCTL_CGONAK_Msk       /*!< Clear global OUT NAK      */
N#define USB_OTG_DCTL_POPRGDNE_Pos                (11U)                         
N#define USB_OTG_DCTL_POPRGDNE_Msk                (0x1UL << USB_OTG_DCTL_POPRGDNE_Pos) /*!< 0x00000800 */
N#define USB_OTG_DCTL_POPRGDNE                    USB_OTG_DCTL_POPRGDNE_Msk     /*!< Power-on programming done */
N
N/********************  Bit definition for USB_OTG_HFIR register  ********************/
N#define USB_OTG_HFIR_FRIVL_Pos                   (0U)                          
N#define USB_OTG_HFIR_FRIVL_Msk                   (0xFFFFUL << USB_OTG_HFIR_FRIVL_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HFIR_FRIVL                       USB_OTG_HFIR_FRIVL_Msk        /*!< Frame interval */
N
N/********************  Bit definition for USB_OTG_HFNUM register  ********************/
N#define USB_OTG_HFNUM_FRNUM_Pos                  (0U)                          
N#define USB_OTG_HFNUM_FRNUM_Msk                  (0xFFFFUL << USB_OTG_HFNUM_FRNUM_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HFNUM_FRNUM                      USB_OTG_HFNUM_FRNUM_Msk       /*!< Frame number         */
N#define USB_OTG_HFNUM_FTREM_Pos                  (16U)                         
N#define USB_OTG_HFNUM_FTREM_Msk                  (0xFFFFUL << USB_OTG_HFNUM_FTREM_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_HFNUM_FTREM                      USB_OTG_HFNUM_FTREM_Msk       /*!< Frame time remaining */
N
N/********************  Bit definition for USB_OTG_DSTS register  ********************/
N#define USB_OTG_DSTS_SUSPSTS_Pos                 (0U)                          
N#define USB_OTG_DSTS_SUSPSTS_Msk                 (0x1UL << USB_OTG_DSTS_SUSPSTS_Pos) /*!< 0x00000001 */
N#define USB_OTG_DSTS_SUSPSTS                     USB_OTG_DSTS_SUSPSTS_Msk      /*!< Suspend status   */
N
N#define USB_OTG_DSTS_ENUMSPD_Pos                 (1U)                          
N#define USB_OTG_DSTS_ENUMSPD_Msk                 (0x3UL << USB_OTG_DSTS_ENUMSPD_Pos) /*!< 0x00000006 */
N#define USB_OTG_DSTS_ENUMSPD                     USB_OTG_DSTS_ENUMSPD_Msk      /*!< Enumerated speed */
N#define USB_OTG_DSTS_ENUMSPD_0                   (0x1UL << USB_OTG_DSTS_ENUMSPD_Pos) /*!< 0x00000002 */
N#define USB_OTG_DSTS_ENUMSPD_1                   (0x2UL << USB_OTG_DSTS_ENUMSPD_Pos) /*!< 0x00000004 */
N#define USB_OTG_DSTS_EERR_Pos                    (3U)                          
N#define USB_OTG_DSTS_EERR_Msk                    (0x1UL << USB_OTG_DSTS_EERR_Pos) /*!< 0x00000008 */
N#define USB_OTG_DSTS_EERR                        USB_OTG_DSTS_EERR_Msk         /*!< Erratic error     */
N#define USB_OTG_DSTS_FNSOF_Pos                   (8U)                          
N#define USB_OTG_DSTS_FNSOF_Msk                   (0x3FFFUL << USB_OTG_DSTS_FNSOF_Pos) /*!< 0x003FFF00 */
N#define USB_OTG_DSTS_FNSOF                       USB_OTG_DSTS_FNSOF_Msk        /*!< Frame number of the received SOF */
N
N/********************  Bit definition for USB_OTG_GAHBCFG register  ********************/
N#define USB_OTG_GAHBCFG_GINT_Pos                 (0U)                          
N#define USB_OTG_GAHBCFG_GINT_Msk                 (0x1UL << USB_OTG_GAHBCFG_GINT_Pos) /*!< 0x00000001 */
N#define USB_OTG_GAHBCFG_GINT                     USB_OTG_GAHBCFG_GINT_Msk      /*!< Global interrupt mask */
N#define USB_OTG_GAHBCFG_HBSTLEN_Pos              (1U)                          
N#define USB_OTG_GAHBCFG_HBSTLEN_Msk              (0xFUL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< 0x0000001E */
N#define USB_OTG_GAHBCFG_HBSTLEN                  USB_OTG_GAHBCFG_HBSTLEN_Msk   /*!< Burst length/type */
N#define USB_OTG_GAHBCFG_HBSTLEN_0                (0x0UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< Single */
N#define USB_OTG_GAHBCFG_HBSTLEN_1                (0x1UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< INCR */
N#define USB_OTG_GAHBCFG_HBSTLEN_2                (0x3UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< INCR4 */
N#define USB_OTG_GAHBCFG_HBSTLEN_3                (0x5UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< INCR8 */
N#define USB_OTG_GAHBCFG_HBSTLEN_4                (0x7UL << USB_OTG_GAHBCFG_HBSTLEN_Pos) /*!< INCR16 */
N#define USB_OTG_GAHBCFG_DMAEN_Pos                (5U)                          
N#define USB_OTG_GAHBCFG_DMAEN_Msk                (0x1UL << USB_OTG_GAHBCFG_DMAEN_Pos) /*!< 0x00000020 */
N#define USB_OTG_GAHBCFG_DMAEN                    USB_OTG_GAHBCFG_DMAEN_Msk     /*!< DMA enable */
N#define USB_OTG_GAHBCFG_TXFELVL_Pos              (7U)                          
N#define USB_OTG_GAHBCFG_TXFELVL_Msk              (0x1UL << USB_OTG_GAHBCFG_TXFELVL_Pos) /*!< 0x00000080 */
N#define USB_OTG_GAHBCFG_TXFELVL                  USB_OTG_GAHBCFG_TXFELVL_Msk   /*!< TxFIFO empty level */
N#define USB_OTG_GAHBCFG_PTXFELVL_Pos             (8U)                          
N#define USB_OTG_GAHBCFG_PTXFELVL_Msk             (0x1UL << USB_OTG_GAHBCFG_PTXFELVL_Pos) /*!< 0x00000100 */
N#define USB_OTG_GAHBCFG_PTXFELVL                 USB_OTG_GAHBCFG_PTXFELVL_Msk  /*!< Periodic TxFIFO empty level */
N
N/********************  Bit definition for USB_OTG_GUSBCFG register  ********************/
N
N#define USB_OTG_GUSBCFG_TOCAL_Pos                (0U)                          
N#define USB_OTG_GUSBCFG_TOCAL_Msk                (0x7UL << USB_OTG_GUSBCFG_TOCAL_Pos) /*!< 0x00000007 */
N#define USB_OTG_GUSBCFG_TOCAL                    USB_OTG_GUSBCFG_TOCAL_Msk     /*!< FS timeout calibration */
N#define USB_OTG_GUSBCFG_TOCAL_0                  (0x1UL << USB_OTG_GUSBCFG_TOCAL_Pos) /*!< 0x00000001 */
N#define USB_OTG_GUSBCFG_TOCAL_1                  (0x2UL << USB_OTG_GUSBCFG_TOCAL_Pos) /*!< 0x00000002 */
N#define USB_OTG_GUSBCFG_TOCAL_2                  (0x4UL << USB_OTG_GUSBCFG_TOCAL_Pos) /*!< 0x00000004 */
N#define USB_OTG_GUSBCFG_PHYSEL_Pos               (6U)                          
N#define USB_OTG_GUSBCFG_PHYSEL_Msk               (0x1UL << USB_OTG_GUSBCFG_PHYSEL_Pos) /*!< 0x00000040 */
N#define USB_OTG_GUSBCFG_PHYSEL                   USB_OTG_GUSBCFG_PHYSEL_Msk    /*!< USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
N#define USB_OTG_GUSBCFG_SRPCAP_Pos               (8U)                          
N#define USB_OTG_GUSBCFG_SRPCAP_Msk               (0x1UL << USB_OTG_GUSBCFG_SRPCAP_Pos) /*!< 0x00000100 */
N#define USB_OTG_GUSBCFG_SRPCAP                   USB_OTG_GUSBCFG_SRPCAP_Msk    /*!< SRP-capable */
N#define USB_OTG_GUSBCFG_HNPCAP_Pos               (9U)                          
N#define USB_OTG_GUSBCFG_HNPCAP_Msk               (0x1UL << USB_OTG_GUSBCFG_HNPCAP_Pos) /*!< 0x00000200 */
N#define USB_OTG_GUSBCFG_HNPCAP                   USB_OTG_GUSBCFG_HNPCAP_Msk    /*!< HNP-capable */
N#define USB_OTG_GUSBCFG_TRDT_Pos                 (10U)                         
N#define USB_OTG_GUSBCFG_TRDT_Msk                 (0xFUL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00003C00 */
N#define USB_OTG_GUSBCFG_TRDT                     USB_OTG_GUSBCFG_TRDT_Msk      /*!< USB turnaround time */
N#define USB_OTG_GUSBCFG_TRDT_0                   (0x1UL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00000400 */
N#define USB_OTG_GUSBCFG_TRDT_1                   (0x2UL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00000800 */
N#define USB_OTG_GUSBCFG_TRDT_2                   (0x4UL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00001000 */
N#define USB_OTG_GUSBCFG_TRDT_3                   (0x8UL << USB_OTG_GUSBCFG_TRDT_Pos) /*!< 0x00002000 */
N#define USB_OTG_GUSBCFG_PHYLPCS_Pos              (15U)                         
N#define USB_OTG_GUSBCFG_PHYLPCS_Msk              (0x1UL << USB_OTG_GUSBCFG_PHYLPCS_Pos) /*!< 0x00008000 */
N#define USB_OTG_GUSBCFG_PHYLPCS                  USB_OTG_GUSBCFG_PHYLPCS_Msk   /*!< PHY Low-power clock select */
N#define USB_OTG_GUSBCFG_ULPIFSLS_Pos             (17U)                         
N#define USB_OTG_GUSBCFG_ULPIFSLS_Msk             (0x1UL << USB_OTG_GUSBCFG_ULPIFSLS_Pos) /*!< 0x00020000 */
N#define USB_OTG_GUSBCFG_ULPIFSLS                 USB_OTG_GUSBCFG_ULPIFSLS_Msk  /*!< ULPI FS/LS select               */
N#define USB_OTG_GUSBCFG_ULPIAR_Pos               (18U)                         
N#define USB_OTG_GUSBCFG_ULPIAR_Msk               (0x1UL << USB_OTG_GUSBCFG_ULPIAR_Pos) /*!< 0x00040000 */
N#define USB_OTG_GUSBCFG_ULPIAR                   USB_OTG_GUSBCFG_ULPIAR_Msk    /*!< ULPI Auto-resume                */
N#define USB_OTG_GUSBCFG_ULPICSM_Pos              (19U)                         
N#define USB_OTG_GUSBCFG_ULPICSM_Msk              (0x1UL << USB_OTG_GUSBCFG_ULPICSM_Pos) /*!< 0x00080000 */
N#define USB_OTG_GUSBCFG_ULPICSM                  USB_OTG_GUSBCFG_ULPICSM_Msk   /*!< ULPI Clock SuspendM             */
N#define USB_OTG_GUSBCFG_ULPIEVBUSD_Pos           (20U)                         
N#define USB_OTG_GUSBCFG_ULPIEVBUSD_Msk           (0x1UL << USB_OTG_GUSBCFG_ULPIEVBUSD_Pos) /*!< 0x00100000 */
N#define USB_OTG_GUSBCFG_ULPIEVBUSD               USB_OTG_GUSBCFG_ULPIEVBUSD_Msk /*!< ULPI External VBUS Drive        */
N#define USB_OTG_GUSBCFG_ULPIEVBUSI_Pos           (21U)                         
N#define USB_OTG_GUSBCFG_ULPIEVBUSI_Msk           (0x1UL << USB_OTG_GUSBCFG_ULPIEVBUSI_Pos) /*!< 0x00200000 */
N#define USB_OTG_GUSBCFG_ULPIEVBUSI               USB_OTG_GUSBCFG_ULPIEVBUSI_Msk /*!< ULPI external VBUS indicator    */
N#define USB_OTG_GUSBCFG_TSDPS_Pos                (22U)                         
N#define USB_OTG_GUSBCFG_TSDPS_Msk                (0x1UL << USB_OTG_GUSBCFG_TSDPS_Pos) /*!< 0x00400000 */
N#define USB_OTG_GUSBCFG_TSDPS                    USB_OTG_GUSBCFG_TSDPS_Msk     /*!< TermSel DLine pulsing selection */
N#define USB_OTG_GUSBCFG_PCCI_Pos                 (23U)                         
N#define USB_OTG_GUSBCFG_PCCI_Msk                 (0x1UL << USB_OTG_GUSBCFG_PCCI_Pos) /*!< 0x00800000 */
N#define USB_OTG_GUSBCFG_PCCI                     USB_OTG_GUSBCFG_PCCI_Msk      /*!< Indicator complement            */
N#define USB_OTG_GUSBCFG_PTCI_Pos                 (24U)                         
N#define USB_OTG_GUSBCFG_PTCI_Msk                 (0x1UL << USB_OTG_GUSBCFG_PTCI_Pos) /*!< 0x01000000 */
N#define USB_OTG_GUSBCFG_PTCI                     USB_OTG_GUSBCFG_PTCI_Msk      /*!< Indicator pass through          */
N#define USB_OTG_GUSBCFG_ULPIIPD_Pos              (25U)                         
N#define USB_OTG_GUSBCFG_ULPIIPD_Msk              (0x1UL << USB_OTG_GUSBCFG_ULPIIPD_Pos) /*!< 0x02000000 */
N#define USB_OTG_GUSBCFG_ULPIIPD                  USB_OTG_GUSBCFG_ULPIIPD_Msk   /*!< ULPI interface protect disable  */
N#define USB_OTG_GUSBCFG_FHMOD_Pos                (29U)                         
N#define USB_OTG_GUSBCFG_FHMOD_Msk                (0x1UL << USB_OTG_GUSBCFG_FHMOD_Pos) /*!< 0x20000000 */
N#define USB_OTG_GUSBCFG_FHMOD                    USB_OTG_GUSBCFG_FHMOD_Msk     /*!< Forced host mode                */
N#define USB_OTG_GUSBCFG_FDMOD_Pos                (30U)                         
N#define USB_OTG_GUSBCFG_FDMOD_Msk                (0x1UL << USB_OTG_GUSBCFG_FDMOD_Pos) /*!< 0x40000000 */
N#define USB_OTG_GUSBCFG_FDMOD                    USB_OTG_GUSBCFG_FDMOD_Msk     /*!< Forced peripheral mode          */
N#define USB_OTG_GUSBCFG_CTXPKT_Pos               (31U)                         
N#define USB_OTG_GUSBCFG_CTXPKT_Msk               (0x1UL << USB_OTG_GUSBCFG_CTXPKT_Pos) /*!< 0x80000000 */
N#define USB_OTG_GUSBCFG_CTXPKT                   USB_OTG_GUSBCFG_CTXPKT_Msk    /*!< Corrupt Tx packet               */
N
N/********************  Bit definition for USB_OTG_GRSTCTL register  ********************/
N#define USB_OTG_GRSTCTL_CSRST_Pos                (0U)                          
N#define USB_OTG_GRSTCTL_CSRST_Msk                (0x1UL << USB_OTG_GRSTCTL_CSRST_Pos) /*!< 0x00000001 */
N#define USB_OTG_GRSTCTL_CSRST                    USB_OTG_GRSTCTL_CSRST_Msk     /*!< Core soft reset          */
N#define USB_OTG_GRSTCTL_HSRST_Pos                (1U)                          
N#define USB_OTG_GRSTCTL_HSRST_Msk                (0x1UL << USB_OTG_GRSTCTL_HSRST_Pos) /*!< 0x00000002 */
N#define USB_OTG_GRSTCTL_HSRST                    USB_OTG_GRSTCTL_HSRST_Msk     /*!< HCLK soft reset          */
N#define USB_OTG_GRSTCTL_FCRST_Pos                (2U)                          
N#define USB_OTG_GRSTCTL_FCRST_Msk                (0x1UL << USB_OTG_GRSTCTL_FCRST_Pos) /*!< 0x00000004 */
N#define USB_OTG_GRSTCTL_FCRST                    USB_OTG_GRSTCTL_FCRST_Msk     /*!< Host frame counter reset */
N#define USB_OTG_GRSTCTL_RXFFLSH_Pos              (4U)                          
N#define USB_OTG_GRSTCTL_RXFFLSH_Msk              (0x1UL << USB_OTG_GRSTCTL_RXFFLSH_Pos) /*!< 0x00000010 */
N#define USB_OTG_GRSTCTL_RXFFLSH                  USB_OTG_GRSTCTL_RXFFLSH_Msk   /*!< RxFIFO flush             */
N#define USB_OTG_GRSTCTL_TXFFLSH_Pos              (5U)                          
N#define USB_OTG_GRSTCTL_TXFFLSH_Msk              (0x1UL << USB_OTG_GRSTCTL_TXFFLSH_Pos) /*!< 0x00000020 */
N#define USB_OTG_GRSTCTL_TXFFLSH                  USB_OTG_GRSTCTL_TXFFLSH_Msk   /*!< TxFIFO flush             */
N
N
N#define USB_OTG_GRSTCTL_TXFNUM_Pos               (6U)                          
N#define USB_OTG_GRSTCTL_TXFNUM_Msk               (0x1FUL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x000007C0 */
N#define USB_OTG_GRSTCTL_TXFNUM                   USB_OTG_GRSTCTL_TXFNUM_Msk    /*!< TxFIFO number */
N#define USB_OTG_GRSTCTL_TXFNUM_0                 (0x01UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000040 */
N#define USB_OTG_GRSTCTL_TXFNUM_1                 (0x02UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000080 */
N#define USB_OTG_GRSTCTL_TXFNUM_2                 (0x04UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000100 */
N#define USB_OTG_GRSTCTL_TXFNUM_3                 (0x08UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000200 */
N#define USB_OTG_GRSTCTL_TXFNUM_4                 (0x10UL << USB_OTG_GRSTCTL_TXFNUM_Pos) /*!< 0x00000400 */
N#define USB_OTG_GRSTCTL_DMAREQ_Pos               (30U)                         
N#define USB_OTG_GRSTCTL_DMAREQ_Msk               (0x1UL << USB_OTG_GRSTCTL_DMAREQ_Pos) /*!< 0x40000000 */
N#define USB_OTG_GRSTCTL_DMAREQ                   USB_OTG_GRSTCTL_DMAREQ_Msk    /*!< DMA request signal */
N#define USB_OTG_GRSTCTL_AHBIDL_Pos               (31U)                         
N#define USB_OTG_GRSTCTL_AHBIDL_Msk               (0x1UL << USB_OTG_GRSTCTL_AHBIDL_Pos) /*!< 0x80000000 */
N#define USB_OTG_GRSTCTL_AHBIDL                   USB_OTG_GRSTCTL_AHBIDL_Msk    /*!< AHB master idle */
N
N/********************  Bit definition for USB_OTG_DIEPMSK register  ********************/
N#define USB_OTG_DIEPMSK_XFRCM_Pos                (0U)                          
N#define USB_OTG_DIEPMSK_XFRCM_Msk                (0x1UL << USB_OTG_DIEPMSK_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_DIEPMSK_XFRCM                    USB_OTG_DIEPMSK_XFRCM_Msk     /*!< Transfer completed interrupt mask                 */
N#define USB_OTG_DIEPMSK_EPDM_Pos                 (1U)                          
N#define USB_OTG_DIEPMSK_EPDM_Msk                 (0x1UL << USB_OTG_DIEPMSK_EPDM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DIEPMSK_EPDM                     USB_OTG_DIEPMSK_EPDM_Msk      /*!< Endpoint disabled interrupt mask                  */
N#define USB_OTG_DIEPMSK_TOM_Pos                  (3U)                          
N#define USB_OTG_DIEPMSK_TOM_Msk                  (0x1UL << USB_OTG_DIEPMSK_TOM_Pos) /*!< 0x00000008 */
N#define USB_OTG_DIEPMSK_TOM                      USB_OTG_DIEPMSK_TOM_Msk       /*!< Timeout condition mask (nonisochronous endpoints) */
N#define USB_OTG_DIEPMSK_ITTXFEMSK_Pos            (4U)                          
N#define USB_OTG_DIEPMSK_ITTXFEMSK_Msk            (0x1UL << USB_OTG_DIEPMSK_ITTXFEMSK_Pos) /*!< 0x00000010 */
N#define USB_OTG_DIEPMSK_ITTXFEMSK                USB_OTG_DIEPMSK_ITTXFEMSK_Msk /*!< IN token received when TxFIFO empty mask          */
N#define USB_OTG_DIEPMSK_INEPNMM_Pos              (5U)                          
N#define USB_OTG_DIEPMSK_INEPNMM_Msk              (0x1UL << USB_OTG_DIEPMSK_INEPNMM_Pos) /*!< 0x00000020 */
N#define USB_OTG_DIEPMSK_INEPNMM                  USB_OTG_DIEPMSK_INEPNMM_Msk   /*!< IN token received with EP mismatch mask           */
N#define USB_OTG_DIEPMSK_INEPNEM_Pos              (6U)                          
N#define USB_OTG_DIEPMSK_INEPNEM_Msk              (0x1UL << USB_OTG_DIEPMSK_INEPNEM_Pos) /*!< 0x00000040 */
N#define USB_OTG_DIEPMSK_INEPNEM                  USB_OTG_DIEPMSK_INEPNEM_Msk   /*!< IN endpoint NAK effective mask                    */
N#define USB_OTG_DIEPMSK_TXFURM_Pos               (8U)                          
N#define USB_OTG_DIEPMSK_TXFURM_Msk               (0x1UL << USB_OTG_DIEPMSK_TXFURM_Pos) /*!< 0x00000100 */
N#define USB_OTG_DIEPMSK_TXFURM                   USB_OTG_DIEPMSK_TXFURM_Msk    /*!< FIFO underrun mask                                */
N#define USB_OTG_DIEPMSK_BIM_Pos                  (9U)                          
N#define USB_OTG_DIEPMSK_BIM_Msk                  (0x1UL << USB_OTG_DIEPMSK_BIM_Pos) /*!< 0x00000200 */
N#define USB_OTG_DIEPMSK_BIM                      USB_OTG_DIEPMSK_BIM_Msk       /*!< BNA interrupt mask                                */
N
N/********************  Bit definition for USB_OTG_HPTXSTS register  ********************/
N#define USB_OTG_HPTXSTS_PTXFSAVL_Pos             (0U)                          
N#define USB_OTG_HPTXSTS_PTXFSAVL_Msk             (0xFFFFUL << USB_OTG_HPTXSTS_PTXFSAVL_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HPTXSTS_PTXFSAVL                 USB_OTG_HPTXSTS_PTXFSAVL_Msk  /*!< Periodic transmit data FIFO space available     */
N#define USB_OTG_HPTXSTS_PTXQSAV_Pos              (16U)                         
N#define USB_OTG_HPTXSTS_PTXQSAV_Msk              (0xFFUL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00FF0000 */
N#define USB_OTG_HPTXSTS_PTXQSAV                  USB_OTG_HPTXSTS_PTXQSAV_Msk   /*!< Periodic transmit request queue space available */
N#define USB_OTG_HPTXSTS_PTXQSAV_0                (0x01UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00010000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_1                (0x02UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00020000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_2                (0x04UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00040000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_3                (0x08UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00080000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_4                (0x10UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00100000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_5                (0x20UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00200000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_6                (0x40UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00400000 */
N#define USB_OTG_HPTXSTS_PTXQSAV_7                (0x80UL << USB_OTG_HPTXSTS_PTXQSAV_Pos) /*!< 0x00800000 */
N
N#define USB_OTG_HPTXSTS_PTXQTOP_Pos              (24U)                         
N#define USB_OTG_HPTXSTS_PTXQTOP_Msk              (0xFFUL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0xFF000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP                  USB_OTG_HPTXSTS_PTXQTOP_Msk   /*!< Top of the periodic transmit request queue */
N#define USB_OTG_HPTXSTS_PTXQTOP_0                (0x01UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x01000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_1                (0x02UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x02000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_2                (0x04UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x04000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_3                (0x08UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x08000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_4                (0x10UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x10000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_5                (0x20UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x20000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_6                (0x40UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x40000000 */
N#define USB_OTG_HPTXSTS_PTXQTOP_7                (0x80UL << USB_OTG_HPTXSTS_PTXQTOP_Pos) /*!< 0x80000000 */
N
N/********************  Bit definition for USB_OTG_HAINT register  ********************/
N#define USB_OTG_HAINT_HAINT_Pos                  (0U)                          
N#define USB_OTG_HAINT_HAINT_Msk                  (0xFFFFUL << USB_OTG_HAINT_HAINT_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HAINT_HAINT                      USB_OTG_HAINT_HAINT_Msk       /*!< Channel interrupts */
N
N/********************  Bit definition for USB_OTG_DOEPMSK register  ********************/
N#define USB_OTG_DOEPMSK_XFRCM_Pos                (0U)                          
N#define USB_OTG_DOEPMSK_XFRCM_Msk                (0x1UL << USB_OTG_DOEPMSK_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_DOEPMSK_XFRCM                    USB_OTG_DOEPMSK_XFRCM_Msk     /*!< Transfer completed interrupt mask              */
N#define USB_OTG_DOEPMSK_EPDM_Pos                 (1U)                          
N#define USB_OTG_DOEPMSK_EPDM_Msk                 (0x1UL << USB_OTG_DOEPMSK_EPDM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DOEPMSK_EPDM                     USB_OTG_DOEPMSK_EPDM_Msk      /*!< Endpoint disabled interrupt mask               */
N#define USB_OTG_DOEPMSK_AHBERRM_Pos              (2U)
N#define USB_OTG_DOEPMSK_AHBERRM_Msk              (0x1UL << USB_OTG_DOEPMSK_AHBERRM_Pos) /*!< 0x00000004 */
N#define USB_OTG_DOEPMSK_AHBERRM                  USB_OTG_DOEPMSK_AHBERRM_Msk   /*!< OUT transaction AHB Error interrupt mask       */
N#define USB_OTG_DOEPMSK_STUPM_Pos                (3U)                          
N#define USB_OTG_DOEPMSK_STUPM_Msk                (0x1UL << USB_OTG_DOEPMSK_STUPM_Pos) /*!< 0x00000008 */
N#define USB_OTG_DOEPMSK_STUPM                    USB_OTG_DOEPMSK_STUPM_Msk     /*!< SETUP phase done mask                          */
N#define USB_OTG_DOEPMSK_OTEPDM_Pos               (4U)                          
N#define USB_OTG_DOEPMSK_OTEPDM_Msk               (0x1UL << USB_OTG_DOEPMSK_OTEPDM_Pos) /*!< 0x00000010 */
N#define USB_OTG_DOEPMSK_OTEPDM                   USB_OTG_DOEPMSK_OTEPDM_Msk    /*!< OUT token received when endpoint disabled mask */
N#define USB_OTG_DOEPMSK_OTEPSPRM_Pos             (5U)                          
N#define USB_OTG_DOEPMSK_OTEPSPRM_Msk             (0x1UL << USB_OTG_DOEPMSK_OTEPSPRM_Pos) /*!< 0x00000020 */
N#define USB_OTG_DOEPMSK_OTEPSPRM                 USB_OTG_DOEPMSK_OTEPSPRM_Msk  /*!< Status Phase Received mask                     */
N#define USB_OTG_DOEPMSK_B2BSTUP_Pos              (6U)                          
N#define USB_OTG_DOEPMSK_B2BSTUP_Msk              (0x1UL << USB_OTG_DOEPMSK_B2BSTUP_Pos) /*!< 0x00000040 */
N#define USB_OTG_DOEPMSK_B2BSTUP                  USB_OTG_DOEPMSK_B2BSTUP_Msk   /*!< Back-to-back SETUP packets received mask       */
N#define USB_OTG_DOEPMSK_OPEM_Pos                 (8U)                          
N#define USB_OTG_DOEPMSK_OPEM_Msk                 (0x1UL << USB_OTG_DOEPMSK_OPEM_Pos) /*!< 0x00000100 */
N#define USB_OTG_DOEPMSK_OPEM                     USB_OTG_DOEPMSK_OPEM_Msk      /*!< OUT packet error mask                          */
N#define USB_OTG_DOEPMSK_BOIM_Pos                 (9U)                          
N#define USB_OTG_DOEPMSK_BOIM_Msk                 (0x1UL << USB_OTG_DOEPMSK_BOIM_Pos) /*!< 0x00000200 */
N#define USB_OTG_DOEPMSK_BOIM                     USB_OTG_DOEPMSK_BOIM_Msk      /*!< BNA interrupt mask                             */
N#define USB_OTG_DOEPMSK_BERRM_Pos                (12U)
N#define USB_OTG_DOEPMSK_BERRM_Msk                (0x1UL << USB_OTG_DOEPMSK_BERRM_Pos) /*!< 0x00001000 */
N#define USB_OTG_DOEPMSK_BERRM                    USB_OTG_DOEPMSK_BERRM_Msk      /*!< Babble error interrupt mask                   */
N#define USB_OTG_DOEPMSK_NAKM_Pos                 (13U)
N#define USB_OTG_DOEPMSK_NAKM_Msk                 (0x1UL << USB_OTG_DOEPMSK_NAKM_Pos) /*!< 0x00002000 */
N#define USB_OTG_DOEPMSK_NAKM                     USB_OTG_DOEPMSK_NAKM_Msk      /*!< OUT Packet NAK interrupt mask                  */
N#define USB_OTG_DOEPMSK_NYETM_Pos                (14U)
N#define USB_OTG_DOEPMSK_NYETM_Msk                (0x1UL << USB_OTG_DOEPMSK_NYETM_Pos) /*!< 0x00004000 */
N#define USB_OTG_DOEPMSK_NYETM                    USB_OTG_DOEPMSK_NYETM_Msk     /*!< NYET interrupt mask                            */
N/********************  Bit definition for USB_OTG_GINTSTS register  ********************/
N#define USB_OTG_GINTSTS_CMOD_Pos                 (0U)                          
N#define USB_OTG_GINTSTS_CMOD_Msk                 (0x1UL << USB_OTG_GINTSTS_CMOD_Pos) /*!< 0x00000001 */
N#define USB_OTG_GINTSTS_CMOD                     USB_OTG_GINTSTS_CMOD_Msk      /*!< Current mode of operation                      */
N#define USB_OTG_GINTSTS_MMIS_Pos                 (1U)                          
N#define USB_OTG_GINTSTS_MMIS_Msk                 (0x1UL << USB_OTG_GINTSTS_MMIS_Pos) /*!< 0x00000002 */
N#define USB_OTG_GINTSTS_MMIS                     USB_OTG_GINTSTS_MMIS_Msk      /*!< Mode mismatch interrupt                        */
N#define USB_OTG_GINTSTS_OTGINT_Pos               (2U)                          
N#define USB_OTG_GINTSTS_OTGINT_Msk               (0x1UL << USB_OTG_GINTSTS_OTGINT_Pos) /*!< 0x00000004 */
N#define USB_OTG_GINTSTS_OTGINT                   USB_OTG_GINTSTS_OTGINT_Msk    /*!< OTG interrupt                                  */
N#define USB_OTG_GINTSTS_SOF_Pos                  (3U)                          
N#define USB_OTG_GINTSTS_SOF_Msk                  (0x1UL << USB_OTG_GINTSTS_SOF_Pos) /*!< 0x00000008 */
N#define USB_OTG_GINTSTS_SOF                      USB_OTG_GINTSTS_SOF_Msk       /*!< Start of frame                                 */
N#define USB_OTG_GINTSTS_RXFLVL_Pos               (4U)                          
N#define USB_OTG_GINTSTS_RXFLVL_Msk               (0x1UL << USB_OTG_GINTSTS_RXFLVL_Pos) /*!< 0x00000010 */
N#define USB_OTG_GINTSTS_RXFLVL                   USB_OTG_GINTSTS_RXFLVL_Msk    /*!< RxFIFO nonempty                                */
N#define USB_OTG_GINTSTS_NPTXFE_Pos               (5U)                          
N#define USB_OTG_GINTSTS_NPTXFE_Msk               (0x1UL << USB_OTG_GINTSTS_NPTXFE_Pos) /*!< 0x00000020 */
N#define USB_OTG_GINTSTS_NPTXFE                   USB_OTG_GINTSTS_NPTXFE_Msk    /*!< Nonperiodic TxFIFO empty                       */
N#define USB_OTG_GINTSTS_GINAKEFF_Pos             (6U)                          
N#define USB_OTG_GINTSTS_GINAKEFF_Msk             (0x1UL << USB_OTG_GINTSTS_GINAKEFF_Pos) /*!< 0x00000040 */
N#define USB_OTG_GINTSTS_GINAKEFF                 USB_OTG_GINTSTS_GINAKEFF_Msk  /*!< Global IN nonperiodic NAK effective            */
N#define USB_OTG_GINTSTS_BOUTNAKEFF_Pos           (7U)                          
N#define USB_OTG_GINTSTS_BOUTNAKEFF_Msk           (0x1UL << USB_OTG_GINTSTS_BOUTNAKEFF_Pos) /*!< 0x00000080 */
N#define USB_OTG_GINTSTS_BOUTNAKEFF               USB_OTG_GINTSTS_BOUTNAKEFF_Msk /*!< Global OUT NAK effective                       */
N#define USB_OTG_GINTSTS_ESUSP_Pos                (10U)                         
N#define USB_OTG_GINTSTS_ESUSP_Msk                (0x1UL << USB_OTG_GINTSTS_ESUSP_Pos) /*!< 0x00000400 */
N#define USB_OTG_GINTSTS_ESUSP                    USB_OTG_GINTSTS_ESUSP_Msk     /*!< Early suspend                                  */
N#define USB_OTG_GINTSTS_USBSUSP_Pos              (11U)                         
N#define USB_OTG_GINTSTS_USBSUSP_Msk              (0x1UL << USB_OTG_GINTSTS_USBSUSP_Pos) /*!< 0x00000800 */
N#define USB_OTG_GINTSTS_USBSUSP                  USB_OTG_GINTSTS_USBSUSP_Msk   /*!< USB suspend                                    */
N#define USB_OTG_GINTSTS_USBRST_Pos               (12U)                         
N#define USB_OTG_GINTSTS_USBRST_Msk               (0x1UL << USB_OTG_GINTSTS_USBRST_Pos) /*!< 0x00001000 */
N#define USB_OTG_GINTSTS_USBRST                   USB_OTG_GINTSTS_USBRST_Msk    /*!< USB reset                                      */
N#define USB_OTG_GINTSTS_ENUMDNE_Pos              (13U)                         
N#define USB_OTG_GINTSTS_ENUMDNE_Msk              (0x1UL << USB_OTG_GINTSTS_ENUMDNE_Pos) /*!< 0x00002000 */
N#define USB_OTG_GINTSTS_ENUMDNE                  USB_OTG_GINTSTS_ENUMDNE_Msk   /*!< Enumeration done                               */
N#define USB_OTG_GINTSTS_ISOODRP_Pos              (14U)                         
N#define USB_OTG_GINTSTS_ISOODRP_Msk              (0x1UL << USB_OTG_GINTSTS_ISOODRP_Pos) /*!< 0x00004000 */
N#define USB_OTG_GINTSTS_ISOODRP                  USB_OTG_GINTSTS_ISOODRP_Msk   /*!< Isochronous OUT packet dropped interrupt       */
N#define USB_OTG_GINTSTS_EOPF_Pos                 (15U)                         
N#define USB_OTG_GINTSTS_EOPF_Msk                 (0x1UL << USB_OTG_GINTSTS_EOPF_Pos) /*!< 0x00008000 */
N#define USB_OTG_GINTSTS_EOPF                     USB_OTG_GINTSTS_EOPF_Msk      /*!< End of periodic frame interrupt                */
N#define USB_OTG_GINTSTS_IEPINT_Pos               (18U)                         
N#define USB_OTG_GINTSTS_IEPINT_Msk               (0x1UL << USB_OTG_GINTSTS_IEPINT_Pos) /*!< 0x00040000 */
N#define USB_OTG_GINTSTS_IEPINT                   USB_OTG_GINTSTS_IEPINT_Msk    /*!< IN endpoint interrupt                          */
N#define USB_OTG_GINTSTS_OEPINT_Pos               (19U)                         
N#define USB_OTG_GINTSTS_OEPINT_Msk               (0x1UL << USB_OTG_GINTSTS_OEPINT_Pos) /*!< 0x00080000 */
N#define USB_OTG_GINTSTS_OEPINT                   USB_OTG_GINTSTS_OEPINT_Msk    /*!< OUT endpoint interrupt                         */
N#define USB_OTG_GINTSTS_IISOIXFR_Pos             (20U)                         
N#define USB_OTG_GINTSTS_IISOIXFR_Msk             (0x1UL << USB_OTG_GINTSTS_IISOIXFR_Pos) /*!< 0x00100000 */
N#define USB_OTG_GINTSTS_IISOIXFR                 USB_OTG_GINTSTS_IISOIXFR_Msk  /*!< Incomplete isochronous IN transfer             */
N#define USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Pos    (21U)                         
N#define USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Msk    (0x1UL << USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Pos) /*!< 0x00200000 */
N#define USB_OTG_GINTSTS_PXFR_INCOMPISOOUT        USB_OTG_GINTSTS_PXFR_INCOMPISOOUT_Msk /*!< Incomplete periodic transfer                   */
N#define USB_OTG_GINTSTS_DATAFSUSP_Pos            (22U)                         
N#define USB_OTG_GINTSTS_DATAFSUSP_Msk            (0x1UL << USB_OTG_GINTSTS_DATAFSUSP_Pos) /*!< 0x00400000 */
N#define USB_OTG_GINTSTS_DATAFSUSP                USB_OTG_GINTSTS_DATAFSUSP_Msk /*!< Data fetch suspended                           */
N#define USB_OTG_GINTSTS_HPRTINT_Pos              (24U)                         
N#define USB_OTG_GINTSTS_HPRTINT_Msk              (0x1UL << USB_OTG_GINTSTS_HPRTINT_Pos) /*!< 0x01000000 */
N#define USB_OTG_GINTSTS_HPRTINT                  USB_OTG_GINTSTS_HPRTINT_Msk   /*!< Host port interrupt                            */
N#define USB_OTG_GINTSTS_HCINT_Pos                (25U)                         
N#define USB_OTG_GINTSTS_HCINT_Msk                (0x1UL << USB_OTG_GINTSTS_HCINT_Pos) /*!< 0x02000000 */
N#define USB_OTG_GINTSTS_HCINT                    USB_OTG_GINTSTS_HCINT_Msk     /*!< Host channels interrupt                        */
N#define USB_OTG_GINTSTS_PTXFE_Pos                (26U)                         
N#define USB_OTG_GINTSTS_PTXFE_Msk                (0x1UL << USB_OTG_GINTSTS_PTXFE_Pos) /*!< 0x04000000 */
N#define USB_OTG_GINTSTS_PTXFE                    USB_OTG_GINTSTS_PTXFE_Msk     /*!< Periodic TxFIFO empty                          */
N#define USB_OTG_GINTSTS_CIDSCHG_Pos              (28U)                         
N#define USB_OTG_GINTSTS_CIDSCHG_Msk              (0x1UL << USB_OTG_GINTSTS_CIDSCHG_Pos) /*!< 0x10000000 */
N#define USB_OTG_GINTSTS_CIDSCHG                  USB_OTG_GINTSTS_CIDSCHG_Msk   /*!< Connector ID status change                     */
N#define USB_OTG_GINTSTS_DISCINT_Pos              (29U)                         
N#define USB_OTG_GINTSTS_DISCINT_Msk              (0x1UL << USB_OTG_GINTSTS_DISCINT_Pos) /*!< 0x20000000 */
N#define USB_OTG_GINTSTS_DISCINT                  USB_OTG_GINTSTS_DISCINT_Msk   /*!< Disconnect detected interrupt                  */
N#define USB_OTG_GINTSTS_SRQINT_Pos               (30U)                         
N#define USB_OTG_GINTSTS_SRQINT_Msk               (0x1UL << USB_OTG_GINTSTS_SRQINT_Pos) /*!< 0x40000000 */
N#define USB_OTG_GINTSTS_SRQINT                   USB_OTG_GINTSTS_SRQINT_Msk    /*!< Session request/new session detected interrupt */
N#define USB_OTG_GINTSTS_WKUINT_Pos               (31U)                         
N#define USB_OTG_GINTSTS_WKUINT_Msk               (0x1UL << USB_OTG_GINTSTS_WKUINT_Pos) /*!< 0x80000000 */
N#define USB_OTG_GINTSTS_WKUINT                   USB_OTG_GINTSTS_WKUINT_Msk    /*!< Resume/remote wakeup detected interrupt        */
N
N/********************  Bit definition for USB_OTG_GINTMSK register  ********************/
N#define USB_OTG_GINTMSK_MMISM_Pos                (1U)                          
N#define USB_OTG_GINTMSK_MMISM_Msk                (0x1UL << USB_OTG_GINTMSK_MMISM_Pos) /*!< 0x00000002 */
N#define USB_OTG_GINTMSK_MMISM                    USB_OTG_GINTMSK_MMISM_Msk     /*!< Mode mismatch interrupt mask                        */
N#define USB_OTG_GINTMSK_OTGINT_Pos               (2U)                          
N#define USB_OTG_GINTMSK_OTGINT_Msk               (0x1UL << USB_OTG_GINTMSK_OTGINT_Pos) /*!< 0x00000004 */
N#define USB_OTG_GINTMSK_OTGINT                   USB_OTG_GINTMSK_OTGINT_Msk    /*!< OTG interrupt mask                                  */
N#define USB_OTG_GINTMSK_SOFM_Pos                 (3U)                          
N#define USB_OTG_GINTMSK_SOFM_Msk                 (0x1UL << USB_OTG_GINTMSK_SOFM_Pos) /*!< 0x00000008 */
N#define USB_OTG_GINTMSK_SOFM                     USB_OTG_GINTMSK_SOFM_Msk      /*!< Start of frame mask                                 */
N#define USB_OTG_GINTMSK_RXFLVLM_Pos              (4U)                          
N#define USB_OTG_GINTMSK_RXFLVLM_Msk              (0x1UL << USB_OTG_GINTMSK_RXFLVLM_Pos) /*!< 0x00000010 */
N#define USB_OTG_GINTMSK_RXFLVLM                  USB_OTG_GINTMSK_RXFLVLM_Msk   /*!< Receive FIFO nonempty mask                          */
N#define USB_OTG_GINTMSK_NPTXFEM_Pos              (5U)                          
N#define USB_OTG_GINTMSK_NPTXFEM_Msk              (0x1UL << USB_OTG_GINTMSK_NPTXFEM_Pos) /*!< 0x00000020 */
N#define USB_OTG_GINTMSK_NPTXFEM                  USB_OTG_GINTMSK_NPTXFEM_Msk   /*!< Nonperiodic TxFIFO empty mask                       */
N#define USB_OTG_GINTMSK_GINAKEFFM_Pos            (6U)                          
N#define USB_OTG_GINTMSK_GINAKEFFM_Msk            (0x1UL << USB_OTG_GINTMSK_GINAKEFFM_Pos) /*!< 0x00000040 */
N#define USB_OTG_GINTMSK_GINAKEFFM                USB_OTG_GINTMSK_GINAKEFFM_Msk /*!< Global nonperiodic IN NAK effective mask            */
N#define USB_OTG_GINTMSK_GONAKEFFM_Pos            (7U)                          
N#define USB_OTG_GINTMSK_GONAKEFFM_Msk            (0x1UL << USB_OTG_GINTMSK_GONAKEFFM_Pos) /*!< 0x00000080 */
N#define USB_OTG_GINTMSK_GONAKEFFM                USB_OTG_GINTMSK_GONAKEFFM_Msk /*!< Global OUT NAK effective mask                       */
N#define USB_OTG_GINTMSK_ESUSPM_Pos               (10U)                         
N#define USB_OTG_GINTMSK_ESUSPM_Msk               (0x1UL << USB_OTG_GINTMSK_ESUSPM_Pos) /*!< 0x00000400 */
N#define USB_OTG_GINTMSK_ESUSPM                   USB_OTG_GINTMSK_ESUSPM_Msk    /*!< Early suspend mask                                  */
N#define USB_OTG_GINTMSK_USBSUSPM_Pos             (11U)                         
N#define USB_OTG_GINTMSK_USBSUSPM_Msk             (0x1UL << USB_OTG_GINTMSK_USBSUSPM_Pos) /*!< 0x00000800 */
N#define USB_OTG_GINTMSK_USBSUSPM                 USB_OTG_GINTMSK_USBSUSPM_Msk  /*!< USB suspend mask                                    */
N#define USB_OTG_GINTMSK_USBRST_Pos               (12U)                         
N#define USB_OTG_GINTMSK_USBRST_Msk               (0x1UL << USB_OTG_GINTMSK_USBRST_Pos) /*!< 0x00001000 */
N#define USB_OTG_GINTMSK_USBRST                   USB_OTG_GINTMSK_USBRST_Msk    /*!< USB reset mask                                      */
N#define USB_OTG_GINTMSK_ENUMDNEM_Pos             (13U)                         
N#define USB_OTG_GINTMSK_ENUMDNEM_Msk             (0x1UL << USB_OTG_GINTMSK_ENUMDNEM_Pos) /*!< 0x00002000 */
N#define USB_OTG_GINTMSK_ENUMDNEM                 USB_OTG_GINTMSK_ENUMDNEM_Msk  /*!< Enumeration done mask                               */
N#define USB_OTG_GINTMSK_ISOODRPM_Pos             (14U)                         
N#define USB_OTG_GINTMSK_ISOODRPM_Msk             (0x1UL << USB_OTG_GINTMSK_ISOODRPM_Pos) /*!< 0x00004000 */
N#define USB_OTG_GINTMSK_ISOODRPM                 USB_OTG_GINTMSK_ISOODRPM_Msk  /*!< Isochronous OUT packet dropped interrupt mask       */
N#define USB_OTG_GINTMSK_EOPFM_Pos                (15U)                         
N#define USB_OTG_GINTMSK_EOPFM_Msk                (0x1UL << USB_OTG_GINTMSK_EOPFM_Pos) /*!< 0x00008000 */
N#define USB_OTG_GINTMSK_EOPFM                    USB_OTG_GINTMSK_EOPFM_Msk     /*!< End of periodic frame interrupt mask                */
N#define USB_OTG_GINTMSK_EPMISM_Pos               (17U)                         
N#define USB_OTG_GINTMSK_EPMISM_Msk               (0x1UL << USB_OTG_GINTMSK_EPMISM_Pos) /*!< 0x00020000 */
N#define USB_OTG_GINTMSK_EPMISM                   USB_OTG_GINTMSK_EPMISM_Msk    /*!< Endpoint mismatch interrupt mask                    */
N#define USB_OTG_GINTMSK_IEPINT_Pos               (18U)                         
N#define USB_OTG_GINTMSK_IEPINT_Msk               (0x1UL << USB_OTG_GINTMSK_IEPINT_Pos) /*!< 0x00040000 */
N#define USB_OTG_GINTMSK_IEPINT                   USB_OTG_GINTMSK_IEPINT_Msk    /*!< IN endpoints interrupt mask                         */
N#define USB_OTG_GINTMSK_OEPINT_Pos               (19U)                         
N#define USB_OTG_GINTMSK_OEPINT_Msk               (0x1UL << USB_OTG_GINTMSK_OEPINT_Pos) /*!< 0x00080000 */
N#define USB_OTG_GINTMSK_OEPINT                   USB_OTG_GINTMSK_OEPINT_Msk    /*!< OUT endpoints interrupt mask                        */
N#define USB_OTG_GINTMSK_IISOIXFRM_Pos            (20U)                         
N#define USB_OTG_GINTMSK_IISOIXFRM_Msk            (0x1UL << USB_OTG_GINTMSK_IISOIXFRM_Pos) /*!< 0x00100000 */
N#define USB_OTG_GINTMSK_IISOIXFRM                USB_OTG_GINTMSK_IISOIXFRM_Msk /*!< Incomplete isochronous IN transfer mask             */
N#define USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Pos      (21U)                         
N#define USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Msk      (0x1UL << USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Pos) /*!< 0x00200000 */
N#define USB_OTG_GINTMSK_PXFRM_IISOOXFRM          USB_OTG_GINTMSK_PXFRM_IISOOXFRM_Msk /*!< Incomplete periodic transfer mask                   */
N#define USB_OTG_GINTMSK_FSUSPM_Pos               (22U)                         
N#define USB_OTG_GINTMSK_FSUSPM_Msk               (0x1UL << USB_OTG_GINTMSK_FSUSPM_Pos) /*!< 0x00400000 */
N#define USB_OTG_GINTMSK_FSUSPM                   USB_OTG_GINTMSK_FSUSPM_Msk    /*!< Data fetch suspended mask                           */
N#define USB_OTG_GINTMSK_PRTIM_Pos                (24U)                         
N#define USB_OTG_GINTMSK_PRTIM_Msk                (0x1UL << USB_OTG_GINTMSK_PRTIM_Pos) /*!< 0x01000000 */
N#define USB_OTG_GINTMSK_PRTIM                    USB_OTG_GINTMSK_PRTIM_Msk     /*!< Host port interrupt mask                            */
N#define USB_OTG_GINTMSK_HCIM_Pos                 (25U)                         
N#define USB_OTG_GINTMSK_HCIM_Msk                 (0x1UL << USB_OTG_GINTMSK_HCIM_Pos) /*!< 0x02000000 */
N#define USB_OTG_GINTMSK_HCIM                     USB_OTG_GINTMSK_HCIM_Msk      /*!< Host channels interrupt mask                        */
N#define USB_OTG_GINTMSK_PTXFEM_Pos               (26U)                         
N#define USB_OTG_GINTMSK_PTXFEM_Msk               (0x1UL << USB_OTG_GINTMSK_PTXFEM_Pos) /*!< 0x04000000 */
N#define USB_OTG_GINTMSK_PTXFEM                   USB_OTG_GINTMSK_PTXFEM_Msk    /*!< Periodic TxFIFO empty mask                          */
N#define USB_OTG_GINTMSK_CIDSCHGM_Pos             (28U)                         
N#define USB_OTG_GINTMSK_CIDSCHGM_Msk             (0x1UL << USB_OTG_GINTMSK_CIDSCHGM_Pos) /*!< 0x10000000 */
N#define USB_OTG_GINTMSK_CIDSCHGM                 USB_OTG_GINTMSK_CIDSCHGM_Msk  /*!< Connector ID status change mask                     */
N#define USB_OTG_GINTMSK_DISCINT_Pos              (29U)                         
N#define USB_OTG_GINTMSK_DISCINT_Msk              (0x1UL << USB_OTG_GINTMSK_DISCINT_Pos) /*!< 0x20000000 */
N#define USB_OTG_GINTMSK_DISCINT                  USB_OTG_GINTMSK_DISCINT_Msk   /*!< Disconnect detected interrupt mask                  */
N#define USB_OTG_GINTMSK_SRQIM_Pos                (30U)                         
N#define USB_OTG_GINTMSK_SRQIM_Msk                (0x1UL << USB_OTG_GINTMSK_SRQIM_Pos) /*!< 0x40000000 */
N#define USB_OTG_GINTMSK_SRQIM                    USB_OTG_GINTMSK_SRQIM_Msk     /*!< Session request/new session detected interrupt mask */
N#define USB_OTG_GINTMSK_WUIM_Pos                 (31U)                         
N#define USB_OTG_GINTMSK_WUIM_Msk                 (0x1UL << USB_OTG_GINTMSK_WUIM_Pos) /*!< 0x80000000 */
N#define USB_OTG_GINTMSK_WUIM                     USB_OTG_GINTMSK_WUIM_Msk      /*!< Resume/remote wakeup detected interrupt mask        */
N
N/********************  Bit definition for USB_OTG_DAINT register  ********************/
N#define USB_OTG_DAINT_IEPINT_Pos                 (0U)                          
N#define USB_OTG_DAINT_IEPINT_Msk                 (0xFFFFUL << USB_OTG_DAINT_IEPINT_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DAINT_IEPINT                     USB_OTG_DAINT_IEPINT_Msk      /*!< IN endpoint interrupt bits  */
N#define USB_OTG_DAINT_OEPINT_Pos                 (16U)                         
N#define USB_OTG_DAINT_OEPINT_Msk                 (0xFFFFUL << USB_OTG_DAINT_OEPINT_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_DAINT_OEPINT                     USB_OTG_DAINT_OEPINT_Msk      /*!< OUT endpoint interrupt bits */
N
N/********************  Bit definition for USB_OTG_HAINTMSK register  ********************/
N#define USB_OTG_HAINTMSK_HAINTM_Pos              (0U)                          
N#define USB_OTG_HAINTMSK_HAINTM_Msk              (0xFFFFUL << USB_OTG_HAINTMSK_HAINTM_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HAINTMSK_HAINTM                  USB_OTG_HAINTMSK_HAINTM_Msk   /*!< Channel interrupt mask */
N
N/********************  Bit definition for USB_OTG_GRXSTSP register  ********************/
N#define USB_OTG_GRXSTSP_EPNUM_Pos                (0U)                          
N#define USB_OTG_GRXSTSP_EPNUM_Msk                (0xFUL << USB_OTG_GRXSTSP_EPNUM_Pos) /*!< 0x0000000F */
N#define USB_OTG_GRXSTSP_EPNUM                    USB_OTG_GRXSTSP_EPNUM_Msk     /*!< IN EP interrupt mask bits  */
N#define USB_OTG_GRXSTSP_BCNT_Pos                 (4U)                          
N#define USB_OTG_GRXSTSP_BCNT_Msk                 (0x7FFUL << USB_OTG_GRXSTSP_BCNT_Pos) /*!< 0x00007FF0 */
N#define USB_OTG_GRXSTSP_BCNT                     USB_OTG_GRXSTSP_BCNT_Msk      /*!< OUT EP interrupt mask bits */
N#define USB_OTG_GRXSTSP_DPID_Pos                 (15U)                         
N#define USB_OTG_GRXSTSP_DPID_Msk                 (0x3UL << USB_OTG_GRXSTSP_DPID_Pos) /*!< 0x00018000 */
N#define USB_OTG_GRXSTSP_DPID                     USB_OTG_GRXSTSP_DPID_Msk      /*!< OUT EP interrupt mask bits */
N#define USB_OTG_GRXSTSP_PKTSTS_Pos               (17U)                         
N#define USB_OTG_GRXSTSP_PKTSTS_Msk               (0xFUL << USB_OTG_GRXSTSP_PKTSTS_Pos) /*!< 0x001E0000 */
N#define USB_OTG_GRXSTSP_PKTSTS                   USB_OTG_GRXSTSP_PKTSTS_Msk    /*!< OUT EP interrupt mask bits */
N
N/********************  Bit definition for USB_OTG_DAINTMSK register  ********************/
N#define USB_OTG_DAINTMSK_IEPM_Pos                (0U)                          
N#define USB_OTG_DAINTMSK_IEPM_Msk                (0xFFFFUL << USB_OTG_DAINTMSK_IEPM_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DAINTMSK_IEPM                    USB_OTG_DAINTMSK_IEPM_Msk     /*!< IN EP interrupt mask bits */
N#define USB_OTG_DAINTMSK_OEPM_Pos                (16U)                         
N#define USB_OTG_DAINTMSK_OEPM_Msk                (0xFFFFUL << USB_OTG_DAINTMSK_OEPM_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_DAINTMSK_OEPM                    USB_OTG_DAINTMSK_OEPM_Msk     /*!< OUT EP interrupt mask bits */
N
N/********************  Bit definition for USB_OTG_GRXFSIZ register  ********************/
N#define USB_OTG_GRXFSIZ_RXFD_Pos                 (0U)                          
N#define USB_OTG_GRXFSIZ_RXFD_Msk                 (0xFFFFUL << USB_OTG_GRXFSIZ_RXFD_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_GRXFSIZ_RXFD                     USB_OTG_GRXFSIZ_RXFD_Msk      /*!< RxFIFO depth */
N
N/********************  Bit definition for USB_OTG_DVBUSDIS register  ********************/
N#define USB_OTG_DVBUSDIS_VBUSDT_Pos              (0U)                          
N#define USB_OTG_DVBUSDIS_VBUSDT_Msk              (0xFFFFUL << USB_OTG_DVBUSDIS_VBUSDT_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DVBUSDIS_VBUSDT                  USB_OTG_DVBUSDIS_VBUSDT_Msk   /*!< Device VBUS discharge time */
N
N/********************  Bit definition for OTG register  ********************/
N#define USB_OTG_NPTXFSA_Pos                      (0U)                          
N#define USB_OTG_NPTXFSA_Msk                      (0xFFFFUL << USB_OTG_NPTXFSA_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_NPTXFSA                          USB_OTG_NPTXFSA_Msk           /*!< Nonperiodic transmit RAM start address */
N#define USB_OTG_NPTXFD_Pos                       (16U)                         
N#define USB_OTG_NPTXFD_Msk                       (0xFFFFUL << USB_OTG_NPTXFD_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_NPTXFD                           USB_OTG_NPTXFD_Msk            /*!< Nonperiodic TxFIFO depth               */
N#define USB_OTG_TX0FSA_Pos                       (0U)                          
N#define USB_OTG_TX0FSA_Msk                       (0xFFFFUL << USB_OTG_TX0FSA_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_TX0FSA                           USB_OTG_TX0FSA_Msk            /*!< Endpoint 0 transmit RAM start address  */
N#define USB_OTG_TX0FD_Pos                        (16U)                         
N#define USB_OTG_TX0FD_Msk                        (0xFFFFUL << USB_OTG_TX0FD_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_TX0FD                            USB_OTG_TX0FD_Msk             /*!< Endpoint 0 TxFIFO depth                */
N
N/********************  Bit definition forUSB_OTG_DVBUSPULSE register  ********************/
N#define USB_OTG_DVBUSPULSE_DVBUSP_Pos            (0U)                          
N#define USB_OTG_DVBUSPULSE_DVBUSP_Msk            (0xFFFUL << USB_OTG_DVBUSPULSE_DVBUSP_Pos) /*!< 0x00000FFF */
N#define USB_OTG_DVBUSPULSE_DVBUSP                USB_OTG_DVBUSPULSE_DVBUSP_Msk /*!< Device VBUS pulsing time */
N
N/********************  Bit definition for USB_OTG_GNPTXSTS register  ********************/
N#define USB_OTG_GNPTXSTS_NPTXFSAV_Pos            (0U)                          
N#define USB_OTG_GNPTXSTS_NPTXFSAV_Msk            (0xFFFFUL << USB_OTG_GNPTXSTS_NPTXFSAV_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_GNPTXSTS_NPTXFSAV                USB_OTG_GNPTXSTS_NPTXFSAV_Msk /*!< Nonperiodic TxFIFO space available */
N
N#define USB_OTG_GNPTXSTS_NPTQXSAV_Pos            (16U)                         
N#define USB_OTG_GNPTXSTS_NPTQXSAV_Msk            (0xFFUL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00FF0000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV                USB_OTG_GNPTXSTS_NPTQXSAV_Msk /*!< Nonperiodic transmit request queue space available */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_0              (0x01UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00010000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_1              (0x02UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00020000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_2              (0x04UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00040000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_3              (0x08UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00080000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_4              (0x10UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00100000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_5              (0x20UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00200000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_6              (0x40UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00400000 */
N#define USB_OTG_GNPTXSTS_NPTQXSAV_7              (0x80UL << USB_OTG_GNPTXSTS_NPTQXSAV_Pos) /*!< 0x00800000 */
N
N#define USB_OTG_GNPTXSTS_NPTXQTOP_Pos            (24U)                         
N#define USB_OTG_GNPTXSTS_NPTXQTOP_Msk            (0x7FUL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x7F000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP                USB_OTG_GNPTXSTS_NPTXQTOP_Msk /*!< Top of the nonperiodic transmit request queue */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_0              (0x01UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x01000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_1              (0x02UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x02000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_2              (0x04UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x04000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_3              (0x08UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x08000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_4              (0x10UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x10000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_5              (0x20UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x20000000 */
N#define USB_OTG_GNPTXSTS_NPTXQTOP_6              (0x40UL << USB_OTG_GNPTXSTS_NPTXQTOP_Pos) /*!< 0x40000000 */
N
N/********************  Bit definition for USB_OTG_DTHRCTL register  ********************/
N#define USB_OTG_DTHRCTL_NONISOTHREN_Pos          (0U)                          
N#define USB_OTG_DTHRCTL_NONISOTHREN_Msk          (0x1UL << USB_OTG_DTHRCTL_NONISOTHREN_Pos) /*!< 0x00000001 */
N#define USB_OTG_DTHRCTL_NONISOTHREN              USB_OTG_DTHRCTL_NONISOTHREN_Msk /*!< Nonisochronous IN endpoints threshold enable */
N#define USB_OTG_DTHRCTL_ISOTHREN_Pos             (1U)                          
N#define USB_OTG_DTHRCTL_ISOTHREN_Msk             (0x1UL << USB_OTG_DTHRCTL_ISOTHREN_Pos) /*!< 0x00000002 */
N#define USB_OTG_DTHRCTL_ISOTHREN                 USB_OTG_DTHRCTL_ISOTHREN_Msk  /*!< ISO IN endpoint threshold enable */
N
N#define USB_OTG_DTHRCTL_TXTHRLEN_Pos             (2U)                          
N#define USB_OTG_DTHRCTL_TXTHRLEN_Msk             (0x1FFUL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x000007FC */
N#define USB_OTG_DTHRCTL_TXTHRLEN                 USB_OTG_DTHRCTL_TXTHRLEN_Msk  /*!< Transmit threshold length */
N#define USB_OTG_DTHRCTL_TXTHRLEN_0               (0x001UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000004 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_1               (0x002UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000008 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_2               (0x004UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000010 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_3               (0x008UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000020 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_4               (0x010UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000040 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_5               (0x020UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000080 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_6               (0x040UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000100 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_7               (0x080UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000200 */
N#define USB_OTG_DTHRCTL_TXTHRLEN_8               (0x100UL << USB_OTG_DTHRCTL_TXTHRLEN_Pos) /*!< 0x00000400 */
N#define USB_OTG_DTHRCTL_RXTHREN_Pos              (16U)                         
N#define USB_OTG_DTHRCTL_RXTHREN_Msk              (0x1UL << USB_OTG_DTHRCTL_RXTHREN_Pos) /*!< 0x00010000 */
N#define USB_OTG_DTHRCTL_RXTHREN                  USB_OTG_DTHRCTL_RXTHREN_Msk   /*!< Receive threshold enable */
N
N#define USB_OTG_DTHRCTL_RXTHRLEN_Pos             (17U)                         
N#define USB_OTG_DTHRCTL_RXTHRLEN_Msk             (0x1FFUL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x03FE0000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN                 USB_OTG_DTHRCTL_RXTHRLEN_Msk  /*!< Receive threshold length */
N#define USB_OTG_DTHRCTL_RXTHRLEN_0               (0x001UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00020000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_1               (0x002UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00040000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_2               (0x004UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00080000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_3               (0x008UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00100000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_4               (0x010UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00200000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_5               (0x020UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00400000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_6               (0x040UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x00800000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_7               (0x080UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x01000000 */
N#define USB_OTG_DTHRCTL_RXTHRLEN_8               (0x100UL << USB_OTG_DTHRCTL_RXTHRLEN_Pos) /*!< 0x02000000 */
N#define USB_OTG_DTHRCTL_ARPEN_Pos                (27U)                         
N#define USB_OTG_DTHRCTL_ARPEN_Msk                (0x1UL << USB_OTG_DTHRCTL_ARPEN_Pos) /*!< 0x08000000 */
N#define USB_OTG_DTHRCTL_ARPEN                    USB_OTG_DTHRCTL_ARPEN_Msk     /*!< Arbiter parking enable */
N
N/********************  Bit definition for USB_OTG_DIEPEMPMSK register  ********************/
N#define USB_OTG_DIEPEMPMSK_INEPTXFEM_Pos         (0U)                          
N#define USB_OTG_DIEPEMPMSK_INEPTXFEM_Msk         (0xFFFFUL << USB_OTG_DIEPEMPMSK_INEPTXFEM_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DIEPEMPMSK_INEPTXFEM             USB_OTG_DIEPEMPMSK_INEPTXFEM_Msk /*!< IN EP Tx FIFO empty interrupt mask bits */
N
N/********************  Bit definition for USB_OTG_DEACHINT register  ********************/
N#define USB_OTG_DEACHINT_IEP1INT_Pos             (1U)                          
N#define USB_OTG_DEACHINT_IEP1INT_Msk             (0x1UL << USB_OTG_DEACHINT_IEP1INT_Pos) /*!< 0x00000002 */
N#define USB_OTG_DEACHINT_IEP1INT                 USB_OTG_DEACHINT_IEP1INT_Msk  /*!< IN endpoint 1interrupt bit   */
N#define USB_OTG_DEACHINT_OEP1INT_Pos             (17U)                         
N#define USB_OTG_DEACHINT_OEP1INT_Msk             (0x1UL << USB_OTG_DEACHINT_OEP1INT_Pos) /*!< 0x00020000 */
N#define USB_OTG_DEACHINT_OEP1INT                 USB_OTG_DEACHINT_OEP1INT_Msk  /*!< OUT endpoint 1 interrupt bit */
N
N/********************  Bit definition for USB_OTG_GCCFG register  ********************/
N#define USB_OTG_GCCFG_PWRDWN_Pos                 (16U)                         
N#define USB_OTG_GCCFG_PWRDWN_Msk                 (0x1UL << USB_OTG_GCCFG_PWRDWN_Pos) /*!< 0x00010000 */
N#define USB_OTG_GCCFG_PWRDWN                     USB_OTG_GCCFG_PWRDWN_Msk      /*!< Power down */
N#define USB_OTG_GCCFG_I2CPADEN_Pos               (17U)                         
N#define USB_OTG_GCCFG_I2CPADEN_Msk               (0x1UL << USB_OTG_GCCFG_I2CPADEN_Pos) /*!< 0x00020000 */
N#define USB_OTG_GCCFG_I2CPADEN                   USB_OTG_GCCFG_I2CPADEN_Msk    /*!< Enable I2C bus connection for the external I2C PHY interface*/ 
N#define USB_OTG_GCCFG_VBUSASEN_Pos               (18U)                         
N#define USB_OTG_GCCFG_VBUSASEN_Msk               (0x1UL << USB_OTG_GCCFG_VBUSASEN_Pos) /*!< 0x00040000 */
N#define USB_OTG_GCCFG_VBUSASEN                   USB_OTG_GCCFG_VBUSASEN_Msk    /*!< Enable the VBUS sensing device */
N#define USB_OTG_GCCFG_VBUSBSEN_Pos               (19U)                         
N#define USB_OTG_GCCFG_VBUSBSEN_Msk               (0x1UL << USB_OTG_GCCFG_VBUSBSEN_Pos) /*!< 0x00080000 */
N#define USB_OTG_GCCFG_VBUSBSEN                   USB_OTG_GCCFG_VBUSBSEN_Msk    /*!< Enable the VBUS sensing device */
N#define USB_OTG_GCCFG_SOFOUTEN_Pos               (20U)                         
N#define USB_OTG_GCCFG_SOFOUTEN_Msk               (0x1UL << USB_OTG_GCCFG_SOFOUTEN_Pos) /*!< 0x00100000 */
N#define USB_OTG_GCCFG_SOFOUTEN                   USB_OTG_GCCFG_SOFOUTEN_Msk    /*!< SOF output enable */
N#define USB_OTG_GCCFG_NOVBUSSENS_Pos             (21U)                         
N#define USB_OTG_GCCFG_NOVBUSSENS_Msk             (0x1UL << USB_OTG_GCCFG_NOVBUSSENS_Pos) /*!< 0x00200000 */
N#define USB_OTG_GCCFG_NOVBUSSENS                 USB_OTG_GCCFG_NOVBUSSENS_Msk  /*!< VBUS sensing disable option*/ 
N
N/********************  Bit definition forUSB_OTG_DEACHINTMSK register  ********************/
N#define USB_OTG_DEACHINTMSK_IEP1INTM_Pos         (1U)                          
N#define USB_OTG_DEACHINTMSK_IEP1INTM_Msk         (0x1UL << USB_OTG_DEACHINTMSK_IEP1INTM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DEACHINTMSK_IEP1INTM             USB_OTG_DEACHINTMSK_IEP1INTM_Msk /*!< IN Endpoint 1 interrupt mask bit  */
N#define USB_OTG_DEACHINTMSK_OEP1INTM_Pos         (17U)                         
N#define USB_OTG_DEACHINTMSK_OEP1INTM_Msk         (0x1UL << USB_OTG_DEACHINTMSK_OEP1INTM_Pos) /*!< 0x00020000 */
N#define USB_OTG_DEACHINTMSK_OEP1INTM             USB_OTG_DEACHINTMSK_OEP1INTM_Msk /*!< OUT Endpoint 1 interrupt mask bit */
N
N/********************  Bit definition for USB_OTG_CID register  ********************/
N#define USB_OTG_CID_PRODUCT_ID_Pos               (0U)                          
N#define USB_OTG_CID_PRODUCT_ID_Msk               (0xFFFFFFFFUL << USB_OTG_CID_PRODUCT_ID_Pos) /*!< 0xFFFFFFFF */
N#define USB_OTG_CID_PRODUCT_ID                   USB_OTG_CID_PRODUCT_ID_Msk    /*!< Product ID field */
N
N/********************  Bit definition for USB_OTG_DIEPEACHMSK1 register  ********************/
N#define USB_OTG_DIEPEACHMSK1_XFRCM_Pos           (0U)                          
N#define USB_OTG_DIEPEACHMSK1_XFRCM_Msk           (0x1UL << USB_OTG_DIEPEACHMSK1_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_DIEPEACHMSK1_XFRCM               USB_OTG_DIEPEACHMSK1_XFRCM_Msk /*!< Transfer completed interrupt mask                 */
N#define USB_OTG_DIEPEACHMSK1_EPDM_Pos            (1U)                          
N#define USB_OTG_DIEPEACHMSK1_EPDM_Msk            (0x1UL << USB_OTG_DIEPEACHMSK1_EPDM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DIEPEACHMSK1_EPDM                USB_OTG_DIEPEACHMSK1_EPDM_Msk /*!< Endpoint disabled interrupt mask                  */
N#define USB_OTG_DIEPEACHMSK1_TOM_Pos             (3U)                          
N#define USB_OTG_DIEPEACHMSK1_TOM_Msk             (0x1UL << USB_OTG_DIEPEACHMSK1_TOM_Pos) /*!< 0x00000008 */
N#define USB_OTG_DIEPEACHMSK1_TOM                 USB_OTG_DIEPEACHMSK1_TOM_Msk  /*!< Timeout condition mask (nonisochronous endpoints) */
N#define USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Pos       (4U)                          
N#define USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Msk       (0x1UL << USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Pos) /*!< 0x00000010 */
N#define USB_OTG_DIEPEACHMSK1_ITTXFEMSK           USB_OTG_DIEPEACHMSK1_ITTXFEMSK_Msk /*!< IN token received when TxFIFO empty mask          */
N#define USB_OTG_DIEPEACHMSK1_INEPNMM_Pos         (5U)                          
N#define USB_OTG_DIEPEACHMSK1_INEPNMM_Msk         (0x1UL << USB_OTG_DIEPEACHMSK1_INEPNMM_Pos) /*!< 0x00000020 */
N#define USB_OTG_DIEPEACHMSK1_INEPNMM             USB_OTG_DIEPEACHMSK1_INEPNMM_Msk /*!< IN token received with EP mismatch mask           */
N#define USB_OTG_DIEPEACHMSK1_INEPNEM_Pos         (6U)                          
N#define USB_OTG_DIEPEACHMSK1_INEPNEM_Msk         (0x1UL << USB_OTG_DIEPEACHMSK1_INEPNEM_Pos) /*!< 0x00000040 */
N#define USB_OTG_DIEPEACHMSK1_INEPNEM             USB_OTG_DIEPEACHMSK1_INEPNEM_Msk /*!< IN endpoint NAK effective mask                    */
N#define USB_OTG_DIEPEACHMSK1_TXFURM_Pos          (8U)                          
N#define USB_OTG_DIEPEACHMSK1_TXFURM_Msk          (0x1UL << USB_OTG_DIEPEACHMSK1_TXFURM_Pos) /*!< 0x00000100 */
N#define USB_OTG_DIEPEACHMSK1_TXFURM              USB_OTG_DIEPEACHMSK1_TXFURM_Msk /*!< FIFO underrun mask                                */
N#define USB_OTG_DIEPEACHMSK1_BIM_Pos             (9U)                          
N#define USB_OTG_DIEPEACHMSK1_BIM_Msk             (0x1UL << USB_OTG_DIEPEACHMSK1_BIM_Pos) /*!< 0x00000200 */
N#define USB_OTG_DIEPEACHMSK1_BIM                 USB_OTG_DIEPEACHMSK1_BIM_Msk  /*!< BNA interrupt mask                                */
N#define USB_OTG_DIEPEACHMSK1_NAKM_Pos            (13U)                         
N#define USB_OTG_DIEPEACHMSK1_NAKM_Msk            (0x1UL << USB_OTG_DIEPEACHMSK1_NAKM_Pos) /*!< 0x00002000 */
N#define USB_OTG_DIEPEACHMSK1_NAKM                USB_OTG_DIEPEACHMSK1_NAKM_Msk /*!< NAK interrupt mask                                */
N
N/********************  Bit definition for USB_OTG_HPRT register  ********************/
N#define USB_OTG_HPRT_PCSTS_Pos                   (0U)                          
N#define USB_OTG_HPRT_PCSTS_Msk                   (0x1UL << USB_OTG_HPRT_PCSTS_Pos) /*!< 0x00000001 */
N#define USB_OTG_HPRT_PCSTS                       USB_OTG_HPRT_PCSTS_Msk        /*!< Port connect status        */
N#define USB_OTG_HPRT_PCDET_Pos                   (1U)                          
N#define USB_OTG_HPRT_PCDET_Msk                   (0x1UL << USB_OTG_HPRT_PCDET_Pos) /*!< 0x00000002 */
N#define USB_OTG_HPRT_PCDET                       USB_OTG_HPRT_PCDET_Msk        /*!< Port connect detected      */
N#define USB_OTG_HPRT_PENA_Pos                    (2U)                          
N#define USB_OTG_HPRT_PENA_Msk                    (0x1UL << USB_OTG_HPRT_PENA_Pos) /*!< 0x00000004 */
N#define USB_OTG_HPRT_PENA                        USB_OTG_HPRT_PENA_Msk         /*!< Port enable                */
N#define USB_OTG_HPRT_PENCHNG_Pos                 (3U)                          
N#define USB_OTG_HPRT_PENCHNG_Msk                 (0x1UL << USB_OTG_HPRT_PENCHNG_Pos) /*!< 0x00000008 */
N#define USB_OTG_HPRT_PENCHNG                     USB_OTG_HPRT_PENCHNG_Msk      /*!< Port enable/disable change */
N#define USB_OTG_HPRT_POCA_Pos                    (4U)                          
N#define USB_OTG_HPRT_POCA_Msk                    (0x1UL << USB_OTG_HPRT_POCA_Pos) /*!< 0x00000010 */
N#define USB_OTG_HPRT_POCA                        USB_OTG_HPRT_POCA_Msk         /*!< Port overcurrent active    */
N#define USB_OTG_HPRT_POCCHNG_Pos                 (5U)                          
N#define USB_OTG_HPRT_POCCHNG_Msk                 (0x1UL << USB_OTG_HPRT_POCCHNG_Pos) /*!< 0x00000020 */
N#define USB_OTG_HPRT_POCCHNG                     USB_OTG_HPRT_POCCHNG_Msk      /*!< Port overcurrent change    */
N#define USB_OTG_HPRT_PRES_Pos                    (6U)                          
N#define USB_OTG_HPRT_PRES_Msk                    (0x1UL << USB_OTG_HPRT_PRES_Pos) /*!< 0x00000040 */
N#define USB_OTG_HPRT_PRES                        USB_OTG_HPRT_PRES_Msk         /*!< Port resume                */
N#define USB_OTG_HPRT_PSUSP_Pos                   (7U)                          
N#define USB_OTG_HPRT_PSUSP_Msk                   (0x1UL << USB_OTG_HPRT_PSUSP_Pos) /*!< 0x00000080 */
N#define USB_OTG_HPRT_PSUSP                       USB_OTG_HPRT_PSUSP_Msk        /*!< Port suspend               */
N#define USB_OTG_HPRT_PRST_Pos                    (8U)                          
N#define USB_OTG_HPRT_PRST_Msk                    (0x1UL << USB_OTG_HPRT_PRST_Pos) /*!< 0x00000100 */
N#define USB_OTG_HPRT_PRST                        USB_OTG_HPRT_PRST_Msk         /*!< Port reset                 */
N
N#define USB_OTG_HPRT_PLSTS_Pos                   (10U)                         
N#define USB_OTG_HPRT_PLSTS_Msk                   (0x3UL << USB_OTG_HPRT_PLSTS_Pos) /*!< 0x00000C00 */
N#define USB_OTG_HPRT_PLSTS                       USB_OTG_HPRT_PLSTS_Msk        /*!< Port line status           */
N#define USB_OTG_HPRT_PLSTS_0                     (0x1UL << USB_OTG_HPRT_PLSTS_Pos) /*!< 0x00000400 */
N#define USB_OTG_HPRT_PLSTS_1                     (0x2UL << USB_OTG_HPRT_PLSTS_Pos) /*!< 0x00000800 */
N#define USB_OTG_HPRT_PPWR_Pos                    (12U)                         
N#define USB_OTG_HPRT_PPWR_Msk                    (0x1UL << USB_OTG_HPRT_PPWR_Pos) /*!< 0x00001000 */
N#define USB_OTG_HPRT_PPWR                        USB_OTG_HPRT_PPWR_Msk         /*!< Port power                 */
N
N#define USB_OTG_HPRT_PTCTL_Pos                   (13U)                         
N#define USB_OTG_HPRT_PTCTL_Msk                   (0xFUL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x0001E000 */
N#define USB_OTG_HPRT_PTCTL                       USB_OTG_HPRT_PTCTL_Msk        /*!< Port test control          */
N#define USB_OTG_HPRT_PTCTL_0                     (0x1UL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x00002000 */
N#define USB_OTG_HPRT_PTCTL_1                     (0x2UL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x00004000 */
N#define USB_OTG_HPRT_PTCTL_2                     (0x4UL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x00008000 */
N#define USB_OTG_HPRT_PTCTL_3                     (0x8UL << USB_OTG_HPRT_PTCTL_Pos) /*!< 0x00010000 */
N
N#define USB_OTG_HPRT_PSPD_Pos                    (17U)                         
N#define USB_OTG_HPRT_PSPD_Msk                    (0x3UL << USB_OTG_HPRT_PSPD_Pos) /*!< 0x00060000 */
N#define USB_OTG_HPRT_PSPD                        USB_OTG_HPRT_PSPD_Msk         /*!< Port speed                 */
N#define USB_OTG_HPRT_PSPD_0                      (0x1UL << USB_OTG_HPRT_PSPD_Pos) /*!< 0x00020000 */
N#define USB_OTG_HPRT_PSPD_1                      (0x2UL << USB_OTG_HPRT_PSPD_Pos) /*!< 0x00040000 */
N
N/********************  Bit definition for USB_OTG_DOEPEACHMSK1 register  ********************/
N#define USB_OTG_DOEPEACHMSK1_XFRCM_Pos           (0U)                          
N#define USB_OTG_DOEPEACHMSK1_XFRCM_Msk           (0x1UL << USB_OTG_DOEPEACHMSK1_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_DOEPEACHMSK1_XFRCM               USB_OTG_DOEPEACHMSK1_XFRCM_Msk /*!< Transfer completed interrupt mask         */
N#define USB_OTG_DOEPEACHMSK1_EPDM_Pos            (1U)                          
N#define USB_OTG_DOEPEACHMSK1_EPDM_Msk            (0x1UL << USB_OTG_DOEPEACHMSK1_EPDM_Pos) /*!< 0x00000002 */
N#define USB_OTG_DOEPEACHMSK1_EPDM                USB_OTG_DOEPEACHMSK1_EPDM_Msk /*!< Endpoint disabled interrupt mask          */
N#define USB_OTG_DOEPEACHMSK1_TOM_Pos             (3U)                          
N#define USB_OTG_DOEPEACHMSK1_TOM_Msk             (0x1UL << USB_OTG_DOEPEACHMSK1_TOM_Pos) /*!< 0x00000008 */
N#define USB_OTG_DOEPEACHMSK1_TOM                 USB_OTG_DOEPEACHMSK1_TOM_Msk  /*!< Timeout condition mask                    */
N#define USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Pos       (4U)                          
N#define USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Msk       (0x1UL << USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Pos) /*!< 0x00000010 */
N#define USB_OTG_DOEPEACHMSK1_ITTXFEMSK           USB_OTG_DOEPEACHMSK1_ITTXFEMSK_Msk /*!< IN token received when TxFIFO empty mask  */
N#define USB_OTG_DOEPEACHMSK1_INEPNMM_Pos         (5U)                          
N#define USB_OTG_DOEPEACHMSK1_INEPNMM_Msk         (0x1UL << USB_OTG_DOEPEACHMSK1_INEPNMM_Pos) /*!< 0x00000020 */
N#define USB_OTG_DOEPEACHMSK1_INEPNMM             USB_OTG_DOEPEACHMSK1_INEPNMM_Msk /*!< IN token received with EP mismatch mask   */
N#define USB_OTG_DOEPEACHMSK1_INEPNEM_Pos         (6U)                          
N#define USB_OTG_DOEPEACHMSK1_INEPNEM_Msk         (0x1UL << USB_OTG_DOEPEACHMSK1_INEPNEM_Pos) /*!< 0x00000040 */
N#define USB_OTG_DOEPEACHMSK1_INEPNEM             USB_OTG_DOEPEACHMSK1_INEPNEM_Msk /*!< IN endpoint NAK effective mask            */
N#define USB_OTG_DOEPEACHMSK1_TXFURM_Pos          (8U)                          
N#define USB_OTG_DOEPEACHMSK1_TXFURM_Msk          (0x1UL << USB_OTG_DOEPEACHMSK1_TXFURM_Pos) /*!< 0x00000100 */
N#define USB_OTG_DOEPEACHMSK1_TXFURM              USB_OTG_DOEPEACHMSK1_TXFURM_Msk /*!< OUT packet error mask                     */
N#define USB_OTG_DOEPEACHMSK1_BIM_Pos             (9U)                          
N#define USB_OTG_DOEPEACHMSK1_BIM_Msk             (0x1UL << USB_OTG_DOEPEACHMSK1_BIM_Pos) /*!< 0x00000200 */
N#define USB_OTG_DOEPEACHMSK1_BIM                 USB_OTG_DOEPEACHMSK1_BIM_Msk  /*!< BNA interrupt mask                        */
N#define USB_OTG_DOEPEACHMSK1_BERRM_Pos           (12U)                         
N#define USB_OTG_DOEPEACHMSK1_BERRM_Msk           (0x1UL << USB_OTG_DOEPEACHMSK1_BERRM_Pos) /*!< 0x00001000 */
N#define USB_OTG_DOEPEACHMSK1_BERRM               USB_OTG_DOEPEACHMSK1_BERRM_Msk /*!< Bubble error interrupt mask               */
N#define USB_OTG_DOEPEACHMSK1_NAKM_Pos            (13U)                         
N#define USB_OTG_DOEPEACHMSK1_NAKM_Msk            (0x1UL << USB_OTG_DOEPEACHMSK1_NAKM_Pos) /*!< 0x00002000 */
N#define USB_OTG_DOEPEACHMSK1_NAKM                USB_OTG_DOEPEACHMSK1_NAKM_Msk /*!< NAK interrupt mask                        */
N#define USB_OTG_DOEPEACHMSK1_NYETM_Pos           (14U)                         
N#define USB_OTG_DOEPEACHMSK1_NYETM_Msk           (0x1UL << USB_OTG_DOEPEACHMSK1_NYETM_Pos) /*!< 0x00004000 */
N#define USB_OTG_DOEPEACHMSK1_NYETM               USB_OTG_DOEPEACHMSK1_NYETM_Msk /*!< NYET interrupt mask                       */
N
N/********************  Bit definition for USB_OTG_HPTXFSIZ register  ********************/
N#define USB_OTG_HPTXFSIZ_PTXSA_Pos               (0U)                          
N#define USB_OTG_HPTXFSIZ_PTXSA_Msk               (0xFFFFUL << USB_OTG_HPTXFSIZ_PTXSA_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_HPTXFSIZ_PTXSA                   USB_OTG_HPTXFSIZ_PTXSA_Msk    /*!< Host periodic TxFIFO start address            */
N#define USB_OTG_HPTXFSIZ_PTXFD_Pos               (16U)                         
N#define USB_OTG_HPTXFSIZ_PTXFD_Msk               (0xFFFFUL << USB_OTG_HPTXFSIZ_PTXFD_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_HPTXFSIZ_PTXFD                   USB_OTG_HPTXFSIZ_PTXFD_Msk    /*!< Host periodic TxFIFO depth                    */
N
N/********************  Bit definition for USB_OTG_DIEPCTL register  ********************/
N#define USB_OTG_DIEPCTL_MPSIZ_Pos                (0U)                          
N#define USB_OTG_DIEPCTL_MPSIZ_Msk                (0x7FFUL << USB_OTG_DIEPCTL_MPSIZ_Pos) /*!< 0x000007FF */
N#define USB_OTG_DIEPCTL_MPSIZ                    USB_OTG_DIEPCTL_MPSIZ_Msk     /*!< Maximum packet size              */
N#define USB_OTG_DIEPCTL_USBAEP_Pos               (15U)                         
N#define USB_OTG_DIEPCTL_USBAEP_Msk               (0x1UL << USB_OTG_DIEPCTL_USBAEP_Pos) /*!< 0x00008000 */
N#define USB_OTG_DIEPCTL_USBAEP                   USB_OTG_DIEPCTL_USBAEP_Msk    /*!< USB active endpoint              */
N#define USB_OTG_DIEPCTL_EONUM_DPID_Pos           (16U)                         
N#define USB_OTG_DIEPCTL_EONUM_DPID_Msk           (0x1UL << USB_OTG_DIEPCTL_EONUM_DPID_Pos) /*!< 0x00010000 */
N#define USB_OTG_DIEPCTL_EONUM_DPID               USB_OTG_DIEPCTL_EONUM_DPID_Msk /*!< Even/odd frame                   */
N#define USB_OTG_DIEPCTL_NAKSTS_Pos               (17U)                         
N#define USB_OTG_DIEPCTL_NAKSTS_Msk               (0x1UL << USB_OTG_DIEPCTL_NAKSTS_Pos) /*!< 0x00020000 */
N#define USB_OTG_DIEPCTL_NAKSTS                   USB_OTG_DIEPCTL_NAKSTS_Msk    /*!< NAK status                       */
N
N#define USB_OTG_DIEPCTL_EPTYP_Pos                (18U)                         
N#define USB_OTG_DIEPCTL_EPTYP_Msk                (0x3UL << USB_OTG_DIEPCTL_EPTYP_Pos) /*!< 0x000C0000 */
N#define USB_OTG_DIEPCTL_EPTYP                    USB_OTG_DIEPCTL_EPTYP_Msk     /*!< Endpoint type                    */
N#define USB_OTG_DIEPCTL_EPTYP_0                  (0x1UL << USB_OTG_DIEPCTL_EPTYP_Pos) /*!< 0x00040000 */
N#define USB_OTG_DIEPCTL_EPTYP_1                  (0x2UL << USB_OTG_DIEPCTL_EPTYP_Pos) /*!< 0x00080000 */
N#define USB_OTG_DIEPCTL_STALL_Pos                (21U)                         
N#define USB_OTG_DIEPCTL_STALL_Msk                (0x1UL << USB_OTG_DIEPCTL_STALL_Pos) /*!< 0x00200000 */
N#define USB_OTG_DIEPCTL_STALL                    USB_OTG_DIEPCTL_STALL_Msk     /*!< STALL handshake                  */
N
N#define USB_OTG_DIEPCTL_TXFNUM_Pos               (22U)                         
N#define USB_OTG_DIEPCTL_TXFNUM_Msk               (0xFUL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x03C00000 */
N#define USB_OTG_DIEPCTL_TXFNUM                   USB_OTG_DIEPCTL_TXFNUM_Msk    /*!< TxFIFO number                    */
N#define USB_OTG_DIEPCTL_TXFNUM_0                 (0x1UL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x00400000 */
N#define USB_OTG_DIEPCTL_TXFNUM_1                 (0x2UL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x00800000 */
N#define USB_OTG_DIEPCTL_TXFNUM_2                 (0x4UL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x01000000 */
N#define USB_OTG_DIEPCTL_TXFNUM_3                 (0x8UL << USB_OTG_DIEPCTL_TXFNUM_Pos) /*!< 0x02000000 */
N#define USB_OTG_DIEPCTL_CNAK_Pos                 (26U)                         
N#define USB_OTG_DIEPCTL_CNAK_Msk                 (0x1UL << USB_OTG_DIEPCTL_CNAK_Pos) /*!< 0x04000000 */
N#define USB_OTG_DIEPCTL_CNAK                     USB_OTG_DIEPCTL_CNAK_Msk      /*!< Clear NAK                        */
N#define USB_OTG_DIEPCTL_SNAK_Pos                 (27U)                         
N#define USB_OTG_DIEPCTL_SNAK_Msk                 (0x1UL << USB_OTG_DIEPCTL_SNAK_Pos) /*!< 0x08000000 */
N#define USB_OTG_DIEPCTL_SNAK                     USB_OTG_DIEPCTL_SNAK_Msk      /*!< Set NAK */
N#define USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Pos       (28U)                         
N#define USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Msk       (0x1UL << USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Pos) /*!< 0x10000000 */
N#define USB_OTG_DIEPCTL_SD0PID_SEVNFRM           USB_OTG_DIEPCTL_SD0PID_SEVNFRM_Msk /*!< Set DATA0 PID                    */
N#define USB_OTG_DIEPCTL_SODDFRM_Pos              (29U)                         
N#define USB_OTG_DIEPCTL_SODDFRM_Msk              (0x1UL << USB_OTG_DIEPCTL_SODDFRM_Pos) /*!< 0x20000000 */
N#define USB_OTG_DIEPCTL_SODDFRM                  USB_OTG_DIEPCTL_SODDFRM_Msk   /*!< Set odd frame                    */
N#define USB_OTG_DIEPCTL_EPDIS_Pos                (30U)                         
N#define USB_OTG_DIEPCTL_EPDIS_Msk                (0x1UL << USB_OTG_DIEPCTL_EPDIS_Pos) /*!< 0x40000000 */
N#define USB_OTG_DIEPCTL_EPDIS                    USB_OTG_DIEPCTL_EPDIS_Msk     /*!< Endpoint disable                 */
N#define USB_OTG_DIEPCTL_EPENA_Pos                (31U)                         
N#define USB_OTG_DIEPCTL_EPENA_Msk                (0x1UL << USB_OTG_DIEPCTL_EPENA_Pos) /*!< 0x80000000 */
N#define USB_OTG_DIEPCTL_EPENA                    USB_OTG_DIEPCTL_EPENA_Msk     /*!< Endpoint enable                  */
N
N/********************  Bit definition for USB_OTG_HCCHAR register  ********************/
N#define USB_OTG_HCCHAR_MPSIZ_Pos                 (0U)                          
N#define USB_OTG_HCCHAR_MPSIZ_Msk                 (0x7FFUL << USB_OTG_HCCHAR_MPSIZ_Pos) /*!< 0x000007FF */
N#define USB_OTG_HCCHAR_MPSIZ                     USB_OTG_HCCHAR_MPSIZ_Msk      /*!< Maximum packet size */
N
N#define USB_OTG_HCCHAR_EPNUM_Pos                 (11U)                         
N#define USB_OTG_HCCHAR_EPNUM_Msk                 (0xFUL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00007800 */
N#define USB_OTG_HCCHAR_EPNUM                     USB_OTG_HCCHAR_EPNUM_Msk      /*!< Endpoint number */
N#define USB_OTG_HCCHAR_EPNUM_0                   (0x1UL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00000800 */
N#define USB_OTG_HCCHAR_EPNUM_1                   (0x2UL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00001000 */
N#define USB_OTG_HCCHAR_EPNUM_2                   (0x4UL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00002000 */
N#define USB_OTG_HCCHAR_EPNUM_3                   (0x8UL << USB_OTG_HCCHAR_EPNUM_Pos) /*!< 0x00004000 */
N#define USB_OTG_HCCHAR_EPDIR_Pos                 (15U)                         
N#define USB_OTG_HCCHAR_EPDIR_Msk                 (0x1UL << USB_OTG_HCCHAR_EPDIR_Pos) /*!< 0x00008000 */
N#define USB_OTG_HCCHAR_EPDIR                     USB_OTG_HCCHAR_EPDIR_Msk      /*!< Endpoint direction */
N#define USB_OTG_HCCHAR_LSDEV_Pos                 (17U)                         
N#define USB_OTG_HCCHAR_LSDEV_Msk                 (0x1UL << USB_OTG_HCCHAR_LSDEV_Pos) /*!< 0x00020000 */
N#define USB_OTG_HCCHAR_LSDEV                     USB_OTG_HCCHAR_LSDEV_Msk      /*!< Low-speed device */
N
N#define USB_OTG_HCCHAR_EPTYP_Pos                 (18U)                         
N#define USB_OTG_HCCHAR_EPTYP_Msk                 (0x3UL << USB_OTG_HCCHAR_EPTYP_Pos) /*!< 0x000C0000 */
N#define USB_OTG_HCCHAR_EPTYP                     USB_OTG_HCCHAR_EPTYP_Msk      /*!< Endpoint type */
N#define USB_OTG_HCCHAR_EPTYP_0                   (0x1UL << USB_OTG_HCCHAR_EPTYP_Pos) /*!< 0x00040000 */
N#define USB_OTG_HCCHAR_EPTYP_1                   (0x2UL << USB_OTG_HCCHAR_EPTYP_Pos) /*!< 0x00080000 */
N
N#define USB_OTG_HCCHAR_MC_Pos                    (20U)                         
N#define USB_OTG_HCCHAR_MC_Msk                    (0x3UL << USB_OTG_HCCHAR_MC_Pos) /*!< 0x00300000 */
N#define USB_OTG_HCCHAR_MC                        USB_OTG_HCCHAR_MC_Msk         /*!< Multi Count (MC) / Error Count (EC) */
N#define USB_OTG_HCCHAR_MC_0                      (0x1UL << USB_OTG_HCCHAR_MC_Pos) /*!< 0x00100000 */
N#define USB_OTG_HCCHAR_MC_1                      (0x2UL << USB_OTG_HCCHAR_MC_Pos) /*!< 0x00200000 */
N
N#define USB_OTG_HCCHAR_DAD_Pos                   (22U)                         
N#define USB_OTG_HCCHAR_DAD_Msk                   (0x7FUL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x1FC00000 */
N#define USB_OTG_HCCHAR_DAD                       USB_OTG_HCCHAR_DAD_Msk        /*!< Device address */
N#define USB_OTG_HCCHAR_DAD_0                     (0x01UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x00400000 */
N#define USB_OTG_HCCHAR_DAD_1                     (0x02UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x00800000 */
N#define USB_OTG_HCCHAR_DAD_2                     (0x04UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x01000000 */
N#define USB_OTG_HCCHAR_DAD_3                     (0x08UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x02000000 */
N#define USB_OTG_HCCHAR_DAD_4                     (0x10UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x04000000 */
N#define USB_OTG_HCCHAR_DAD_5                     (0x20UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x08000000 */
N#define USB_OTG_HCCHAR_DAD_6                     (0x40UL << USB_OTG_HCCHAR_DAD_Pos) /*!< 0x10000000 */
N#define USB_OTG_HCCHAR_ODDFRM_Pos                (29U)                         
N#define USB_OTG_HCCHAR_ODDFRM_Msk                (0x1UL << USB_OTG_HCCHAR_ODDFRM_Pos) /*!< 0x20000000 */
N#define USB_OTG_HCCHAR_ODDFRM                    USB_OTG_HCCHAR_ODDFRM_Msk     /*!< Odd frame */
N#define USB_OTG_HCCHAR_CHDIS_Pos                 (30U)                         
N#define USB_OTG_HCCHAR_CHDIS_Msk                 (0x1UL << USB_OTG_HCCHAR_CHDIS_Pos) /*!< 0x40000000 */
N#define USB_OTG_HCCHAR_CHDIS                     USB_OTG_HCCHAR_CHDIS_Msk      /*!< Channel disable */
N#define USB_OTG_HCCHAR_CHENA_Pos                 (31U)                         
N#define USB_OTG_HCCHAR_CHENA_Msk                 (0x1UL << USB_OTG_HCCHAR_CHENA_Pos) /*!< 0x80000000 */
N#define USB_OTG_HCCHAR_CHENA                     USB_OTG_HCCHAR_CHENA_Msk      /*!< Channel enable */
N
N/********************  Bit definition for USB_OTG_HCSPLT register  ********************/
N
N#define USB_OTG_HCSPLT_PRTADDR_Pos               (0U)                          
N#define USB_OTG_HCSPLT_PRTADDR_Msk               (0x7FUL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x0000007F */
N#define USB_OTG_HCSPLT_PRTADDR                   USB_OTG_HCSPLT_PRTADDR_Msk    /*!< Port address */
N#define USB_OTG_HCSPLT_PRTADDR_0                 (0x01UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000001 */
N#define USB_OTG_HCSPLT_PRTADDR_1                 (0x02UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000002 */
N#define USB_OTG_HCSPLT_PRTADDR_2                 (0x04UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000004 */
N#define USB_OTG_HCSPLT_PRTADDR_3                 (0x08UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000008 */
N#define USB_OTG_HCSPLT_PRTADDR_4                 (0x10UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000010 */
N#define USB_OTG_HCSPLT_PRTADDR_5                 (0x20UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000020 */
N#define USB_OTG_HCSPLT_PRTADDR_6                 (0x40UL << USB_OTG_HCSPLT_PRTADDR_Pos) /*!< 0x00000040 */
N
N#define USB_OTG_HCSPLT_HUBADDR_Pos               (7U)                          
N#define USB_OTG_HCSPLT_HUBADDR_Msk               (0x7FUL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00003F80 */
N#define USB_OTG_HCSPLT_HUBADDR                   USB_OTG_HCSPLT_HUBADDR_Msk    /*!< Hub address */
N#define USB_OTG_HCSPLT_HUBADDR_0                 (0x01UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000080 */
N#define USB_OTG_HCSPLT_HUBADDR_1                 (0x02UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000100 */
N#define USB_OTG_HCSPLT_HUBADDR_2                 (0x04UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000200 */
N#define USB_OTG_HCSPLT_HUBADDR_3                 (0x08UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000400 */
N#define USB_OTG_HCSPLT_HUBADDR_4                 (0x10UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00000800 */
N#define USB_OTG_HCSPLT_HUBADDR_5                 (0x20UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00001000 */
N#define USB_OTG_HCSPLT_HUBADDR_6                 (0x40UL << USB_OTG_HCSPLT_HUBADDR_Pos) /*!< 0x00002000 */
N
N#define USB_OTG_HCSPLT_XACTPOS_Pos               (14U)                         
N#define USB_OTG_HCSPLT_XACTPOS_Msk               (0x3UL << USB_OTG_HCSPLT_XACTPOS_Pos) /*!< 0x0000C000 */
N#define USB_OTG_HCSPLT_XACTPOS                   USB_OTG_HCSPLT_XACTPOS_Msk    /*!< XACTPOS */
N#define USB_OTG_HCSPLT_XACTPOS_0                 (0x1UL << USB_OTG_HCSPLT_XACTPOS_Pos) /*!< 0x00004000 */
N#define USB_OTG_HCSPLT_XACTPOS_1                 (0x2UL << USB_OTG_HCSPLT_XACTPOS_Pos) /*!< 0x00008000 */
N#define USB_OTG_HCSPLT_COMPLSPLT_Pos             (16U)                         
N#define USB_OTG_HCSPLT_COMPLSPLT_Msk             (0x1UL << USB_OTG_HCSPLT_COMPLSPLT_Pos) /*!< 0x00010000 */
N#define USB_OTG_HCSPLT_COMPLSPLT                 USB_OTG_HCSPLT_COMPLSPLT_Msk  /*!< Do complete split */
N#define USB_OTG_HCSPLT_SPLITEN_Pos               (31U)                         
N#define USB_OTG_HCSPLT_SPLITEN_Msk               (0x1UL << USB_OTG_HCSPLT_SPLITEN_Pos) /*!< 0x80000000 */
N#define USB_OTG_HCSPLT_SPLITEN                   USB_OTG_HCSPLT_SPLITEN_Msk    /*!< Split enable */
N
N/********************  Bit definition for USB_OTG_HCINT register  ********************/
N#define USB_OTG_HCINT_XFRC_Pos                   (0U)                          
N#define USB_OTG_HCINT_XFRC_Msk                   (0x1UL << USB_OTG_HCINT_XFRC_Pos) /*!< 0x00000001 */
N#define USB_OTG_HCINT_XFRC                       USB_OTG_HCINT_XFRC_Msk        /*!< Transfer completed */
N#define USB_OTG_HCINT_CHH_Pos                    (1U)                          
N#define USB_OTG_HCINT_CHH_Msk                    (0x1UL << USB_OTG_HCINT_CHH_Pos) /*!< 0x00000002 */
N#define USB_OTG_HCINT_CHH                        USB_OTG_HCINT_CHH_Msk         /*!< Channel halted */
N#define USB_OTG_HCINT_AHBERR_Pos                 (2U)                          
N#define USB_OTG_HCINT_AHBERR_Msk                 (0x1UL << USB_OTG_HCINT_AHBERR_Pos) /*!< 0x00000004 */
N#define USB_OTG_HCINT_AHBERR                     USB_OTG_HCINT_AHBERR_Msk      /*!< AHB error */
N#define USB_OTG_HCINT_STALL_Pos                  (3U)                          
N#define USB_OTG_HCINT_STALL_Msk                  (0x1UL << USB_OTG_HCINT_STALL_Pos) /*!< 0x00000008 */
N#define USB_OTG_HCINT_STALL                      USB_OTG_HCINT_STALL_Msk       /*!< STALL response received interrupt */
N#define USB_OTG_HCINT_NAK_Pos                    (4U)                          
N#define USB_OTG_HCINT_NAK_Msk                    (0x1UL << USB_OTG_HCINT_NAK_Pos) /*!< 0x00000010 */
N#define USB_OTG_HCINT_NAK                        USB_OTG_HCINT_NAK_Msk         /*!< NAK response received interrupt */
N#define USB_OTG_HCINT_ACK_Pos                    (5U)                          
N#define USB_OTG_HCINT_ACK_Msk                    (0x1UL << USB_OTG_HCINT_ACK_Pos) /*!< 0x00000020 */
N#define USB_OTG_HCINT_ACK                        USB_OTG_HCINT_ACK_Msk         /*!< ACK response received/transmitted interrupt */
N#define USB_OTG_HCINT_NYET_Pos                   (6U)                          
N#define USB_OTG_HCINT_NYET_Msk                   (0x1UL << USB_OTG_HCINT_NYET_Pos) /*!< 0x00000040 */
N#define USB_OTG_HCINT_NYET                       USB_OTG_HCINT_NYET_Msk        /*!< Response received interrupt */
N#define USB_OTG_HCINT_TXERR_Pos                  (7U)                          
N#define USB_OTG_HCINT_TXERR_Msk                  (0x1UL << USB_OTG_HCINT_TXERR_Pos) /*!< 0x00000080 */
N#define USB_OTG_HCINT_TXERR                      USB_OTG_HCINT_TXERR_Msk       /*!< Transaction error */
N#define USB_OTG_HCINT_BBERR_Pos                  (8U)                          
N#define USB_OTG_HCINT_BBERR_Msk                  (0x1UL << USB_OTG_HCINT_BBERR_Pos) /*!< 0x00000100 */
N#define USB_OTG_HCINT_BBERR                      USB_OTG_HCINT_BBERR_Msk       /*!< Babble error */
N#define USB_OTG_HCINT_FRMOR_Pos                  (9U)                          
N#define USB_OTG_HCINT_FRMOR_Msk                  (0x1UL << USB_OTG_HCINT_FRMOR_Pos) /*!< 0x00000200 */
N#define USB_OTG_HCINT_FRMOR                      USB_OTG_HCINT_FRMOR_Msk       /*!< Frame overrun */
N#define USB_OTG_HCINT_DTERR_Pos                  (10U)                         
N#define USB_OTG_HCINT_DTERR_Msk                  (0x1UL << USB_OTG_HCINT_DTERR_Pos) /*!< 0x00000400 */
N#define USB_OTG_HCINT_DTERR                      USB_OTG_HCINT_DTERR_Msk       /*!< Data toggle error */
N
N/********************  Bit definition for USB_OTG_DIEPINT register  ********************/
N#define USB_OTG_DIEPINT_XFRC_Pos                 (0U)                          
N#define USB_OTG_DIEPINT_XFRC_Msk                 (0x1UL << USB_OTG_DIEPINT_XFRC_Pos) /*!< 0x00000001 */
N#define USB_OTG_DIEPINT_XFRC                     USB_OTG_DIEPINT_XFRC_Msk      /*!< Transfer completed interrupt */
N#define USB_OTG_DIEPINT_EPDISD_Pos               (1U)                          
N#define USB_OTG_DIEPINT_EPDISD_Msk               (0x1UL << USB_OTG_DIEPINT_EPDISD_Pos) /*!< 0x00000002 */
N#define USB_OTG_DIEPINT_EPDISD                   USB_OTG_DIEPINT_EPDISD_Msk    /*!< Endpoint disabled interrupt */
N#define USB_OTG_DIEPINT_AHBERR_Pos               (2U)
N#define USB_OTG_DIEPINT_AHBERR_Msk               (0x1UL << USB_OTG_DIEPINT_AHBERR_Pos) /*!< 0x00000004 */
N#define USB_OTG_DIEPINT_AHBERR                   USB_OTG_DIEPINT_AHBERR_Msk   /*!< AHB Error (AHBErr) during an IN transaction */
N#define USB_OTG_DIEPINT_TOC_Pos                  (3U)                          
N#define USB_OTG_DIEPINT_TOC_Msk                  (0x1UL << USB_OTG_DIEPINT_TOC_Pos) /*!< 0x00000008 */
N#define USB_OTG_DIEPINT_TOC                      USB_OTG_DIEPINT_TOC_Msk       /*!< Timeout condition */
N#define USB_OTG_DIEPINT_ITTXFE_Pos               (4U)                          
N#define USB_OTG_DIEPINT_ITTXFE_Msk               (0x1UL << USB_OTG_DIEPINT_ITTXFE_Pos) /*!< 0x00000010 */
N#define USB_OTG_DIEPINT_ITTXFE                   USB_OTG_DIEPINT_ITTXFE_Msk    /*!< IN token received when TxFIFO is empty */
N#define USB_OTG_DIEPINT_INEPNM_Pos               (5U)
N#define USB_OTG_DIEPINT_INEPNM_Msk               (0x1UL << USB_OTG_DIEPINT_INEPNM_Pos) /*!< 0x00000004 */
N#define USB_OTG_DIEPINT_INEPNM                   USB_OTG_DIEPINT_INEPNM_Msk   /*!< IN token received with EP mismatch */
N#define USB_OTG_DIEPINT_INEPNE_Pos               (6U)                          
N#define USB_OTG_DIEPINT_INEPNE_Msk               (0x1UL << USB_OTG_DIEPINT_INEPNE_Pos) /*!< 0x00000040 */
N#define USB_OTG_DIEPINT_INEPNE                   USB_OTG_DIEPINT_INEPNE_Msk    /*!< IN endpoint NAK effective */
N#define USB_OTG_DIEPINT_TXFE_Pos                 (7U)                          
N#define USB_OTG_DIEPINT_TXFE_Msk                 (0x1UL << USB_OTG_DIEPINT_TXFE_Pos) /*!< 0x00000080 */
N#define USB_OTG_DIEPINT_TXFE                     USB_OTG_DIEPINT_TXFE_Msk      /*!< Transmit FIFO empty */
N#define USB_OTG_DIEPINT_TXFIFOUDRN_Pos           (8U)                          
N#define USB_OTG_DIEPINT_TXFIFOUDRN_Msk           (0x1UL << USB_OTG_DIEPINT_TXFIFOUDRN_Pos) /*!< 0x00000100 */
N#define USB_OTG_DIEPINT_TXFIFOUDRN               USB_OTG_DIEPINT_TXFIFOUDRN_Msk /*!< Transmit Fifo Underrun */
N#define USB_OTG_DIEPINT_BNA_Pos                  (9U)                          
N#define USB_OTG_DIEPINT_BNA_Msk                  (0x1UL << USB_OTG_DIEPINT_BNA_Pos) /*!< 0x00000200 */
N#define USB_OTG_DIEPINT_BNA                      USB_OTG_DIEPINT_BNA_Msk       /*!< Buffer not available interrupt */
N#define USB_OTG_DIEPINT_PKTDRPSTS_Pos            (11U)                         
N#define USB_OTG_DIEPINT_PKTDRPSTS_Msk            (0x1UL << USB_OTG_DIEPINT_PKTDRPSTS_Pos) /*!< 0x00000800 */
N#define USB_OTG_DIEPINT_PKTDRPSTS                USB_OTG_DIEPINT_PKTDRPSTS_Msk /*!< Packet dropped status */
N#define USB_OTG_DIEPINT_BERR_Pos                 (12U)                         
N#define USB_OTG_DIEPINT_BERR_Msk                 (0x1UL << USB_OTG_DIEPINT_BERR_Pos) /*!< 0x00001000 */
N#define USB_OTG_DIEPINT_BERR                     USB_OTG_DIEPINT_BERR_Msk      /*!< Babble error interrupt */
N#define USB_OTG_DIEPINT_NAK_Pos                  (13U)                         
N#define USB_OTG_DIEPINT_NAK_Msk                  (0x1UL << USB_OTG_DIEPINT_NAK_Pos) /*!< 0x00002000 */
N#define USB_OTG_DIEPINT_NAK                      USB_OTG_DIEPINT_NAK_Msk       /*!< NAK interrupt */
N
N/********************  Bit definition forUSB_OTG_HCINTMSK register  ********************/
N#define USB_OTG_HCINTMSK_XFRCM_Pos               (0U)                          
N#define USB_OTG_HCINTMSK_XFRCM_Msk               (0x1UL << USB_OTG_HCINTMSK_XFRCM_Pos) /*!< 0x00000001 */
N#define USB_OTG_HCINTMSK_XFRCM                   USB_OTG_HCINTMSK_XFRCM_Msk    /*!< Transfer completed mask */
N#define USB_OTG_HCINTMSK_CHHM_Pos                (1U)                          
N#define USB_OTG_HCINTMSK_CHHM_Msk                (0x1UL << USB_OTG_HCINTMSK_CHHM_Pos) /*!< 0x00000002 */
N#define USB_OTG_HCINTMSK_CHHM                    USB_OTG_HCINTMSK_CHHM_Msk     /*!< Channel halted mask */
N#define USB_OTG_HCINTMSK_AHBERR_Pos              (2U)                          
N#define USB_OTG_HCINTMSK_AHBERR_Msk              (0x1UL << USB_OTG_HCINTMSK_AHBERR_Pos) /*!< 0x00000004 */
N#define USB_OTG_HCINTMSK_AHBERR                  USB_OTG_HCINTMSK_AHBERR_Msk   /*!< AHB error */
N#define USB_OTG_HCINTMSK_STALLM_Pos              (3U)                          
N#define USB_OTG_HCINTMSK_STALLM_Msk              (0x1UL << USB_OTG_HCINTMSK_STALLM_Pos) /*!< 0x00000008 */
N#define USB_OTG_HCINTMSK_STALLM                  USB_OTG_HCINTMSK_STALLM_Msk   /*!< STALL response received interrupt mask */
N#define USB_OTG_HCINTMSK_NAKM_Pos                (4U)                          
N#define USB_OTG_HCINTMSK_NAKM_Msk                (0x1UL << USB_OTG_HCINTMSK_NAKM_Pos) /*!< 0x00000010 */
N#define USB_OTG_HCINTMSK_NAKM                    USB_OTG_HCINTMSK_NAKM_Msk     /*!< NAK response received interrupt mask */
N#define USB_OTG_HCINTMSK_ACKM_Pos                (5U)                          
N#define USB_OTG_HCINTMSK_ACKM_Msk                (0x1UL << USB_OTG_HCINTMSK_ACKM_Pos) /*!< 0x00000020 */
N#define USB_OTG_HCINTMSK_ACKM                    USB_OTG_HCINTMSK_ACKM_Msk     /*!< ACK response received/transmitted interrupt mask */
N#define USB_OTG_HCINTMSK_NYET_Pos                (6U)                          
N#define USB_OTG_HCINTMSK_NYET_Msk                (0x1UL << USB_OTG_HCINTMSK_NYET_Pos) /*!< 0x00000040 */
N#define USB_OTG_HCINTMSK_NYET                    USB_OTG_HCINTMSK_NYET_Msk     /*!< response received interrupt mask */
N#define USB_OTG_HCINTMSK_TXERRM_Pos              (7U)                          
N#define USB_OTG_HCINTMSK_TXERRM_Msk              (0x1UL << USB_OTG_HCINTMSK_TXERRM_Pos) /*!< 0x00000080 */
N#define USB_OTG_HCINTMSK_TXERRM                  USB_OTG_HCINTMSK_TXERRM_Msk   /*!< Transaction error mask */
N#define USB_OTG_HCINTMSK_BBERRM_Pos              (8U)                          
N#define USB_OTG_HCINTMSK_BBERRM_Msk              (0x1UL << USB_OTG_HCINTMSK_BBERRM_Pos) /*!< 0x00000100 */
N#define USB_OTG_HCINTMSK_BBERRM                  USB_OTG_HCINTMSK_BBERRM_Msk   /*!< Babble error mask */
N#define USB_OTG_HCINTMSK_FRMORM_Pos              (9U)                          
N#define USB_OTG_HCINTMSK_FRMORM_Msk              (0x1UL << USB_OTG_HCINTMSK_FRMORM_Pos) /*!< 0x00000200 */
N#define USB_OTG_HCINTMSK_FRMORM                  USB_OTG_HCINTMSK_FRMORM_Msk   /*!< Frame overrun mask */
N#define USB_OTG_HCINTMSK_DTERRM_Pos              (10U)                         
N#define USB_OTG_HCINTMSK_DTERRM_Msk              (0x1UL << USB_OTG_HCINTMSK_DTERRM_Pos) /*!< 0x00000400 */
N#define USB_OTG_HCINTMSK_DTERRM                  USB_OTG_HCINTMSK_DTERRM_Msk   /*!< Data toggle error mask */
N
N/********************  Bit definition for USB_OTG_DIEPTSIZ register  ********************/
N
N#define USB_OTG_DIEPTSIZ_XFRSIZ_Pos              (0U)                          
N#define USB_OTG_DIEPTSIZ_XFRSIZ_Msk              (0x7FFFFUL << USB_OTG_DIEPTSIZ_XFRSIZ_Pos) /*!< 0x0007FFFF */
N#define USB_OTG_DIEPTSIZ_XFRSIZ                  USB_OTG_DIEPTSIZ_XFRSIZ_Msk   /*!< Transfer size */
N#define USB_OTG_DIEPTSIZ_PKTCNT_Pos              (19U)                         
N#define USB_OTG_DIEPTSIZ_PKTCNT_Msk              (0x3FFUL << USB_OTG_DIEPTSIZ_PKTCNT_Pos) /*!< 0x1FF80000 */
N#define USB_OTG_DIEPTSIZ_PKTCNT                  USB_OTG_DIEPTSIZ_PKTCNT_Msk   /*!< Packet count */
N#define USB_OTG_DIEPTSIZ_MULCNT_Pos              (29U)                         
N#define USB_OTG_DIEPTSIZ_MULCNT_Msk              (0x3UL << USB_OTG_DIEPTSIZ_MULCNT_Pos) /*!< 0x60000000 */
N#define USB_OTG_DIEPTSIZ_MULCNT                  USB_OTG_DIEPTSIZ_MULCNT_Msk   /*!< Packet count */
N/********************  Bit definition for USB_OTG_HCTSIZ register  ********************/
N#define USB_OTG_HCTSIZ_XFRSIZ_Pos                (0U)                          
N#define USB_OTG_HCTSIZ_XFRSIZ_Msk                (0x7FFFFUL << USB_OTG_HCTSIZ_XFRSIZ_Pos) /*!< 0x0007FFFF */
N#define USB_OTG_HCTSIZ_XFRSIZ                    USB_OTG_HCTSIZ_XFRSIZ_Msk     /*!< Transfer size */
N#define USB_OTG_HCTSIZ_PKTCNT_Pos                (19U)                         
N#define USB_OTG_HCTSIZ_PKTCNT_Msk                (0x3FFUL << USB_OTG_HCTSIZ_PKTCNT_Pos) /*!< 0x1FF80000 */
N#define USB_OTG_HCTSIZ_PKTCNT                    USB_OTG_HCTSIZ_PKTCNT_Msk     /*!< Packet count */
N#define USB_OTG_HCTSIZ_DOPING_Pos                (31U)                         
N#define USB_OTG_HCTSIZ_DOPING_Msk                (0x1UL << USB_OTG_HCTSIZ_DOPING_Pos) /*!< 0x80000000 */
N#define USB_OTG_HCTSIZ_DOPING                    USB_OTG_HCTSIZ_DOPING_Msk     /*!< Do PING */
N#define USB_OTG_HCTSIZ_DPID_Pos                  (29U)                         
N#define USB_OTG_HCTSIZ_DPID_Msk                  (0x3UL << USB_OTG_HCTSIZ_DPID_Pos) /*!< 0x60000000 */
N#define USB_OTG_HCTSIZ_DPID                      USB_OTG_HCTSIZ_DPID_Msk       /*!< Data PID */
N#define USB_OTG_HCTSIZ_DPID_0                    (0x1UL << USB_OTG_HCTSIZ_DPID_Pos) /*!< 0x20000000 */
N#define USB_OTG_HCTSIZ_DPID_1                    (0x2UL << USB_OTG_HCTSIZ_DPID_Pos) /*!< 0x40000000 */
N
N/********************  Bit definition for USB_OTG_DIEPDMA register  ********************/
N#define USB_OTG_DIEPDMA_DMAADDR_Pos              (0U)                          
N#define USB_OTG_DIEPDMA_DMAADDR_Msk              (0xFFFFFFFFUL << USB_OTG_DIEPDMA_DMAADDR_Pos) /*!< 0xFFFFFFFF */
N#define USB_OTG_DIEPDMA_DMAADDR                  USB_OTG_DIEPDMA_DMAADDR_Msk   /*!< DMA address */
N
N/********************  Bit definition for USB_OTG_HCDMA register  ********************/
N#define USB_OTG_HCDMA_DMAADDR_Pos                (0U)                          
N#define USB_OTG_HCDMA_DMAADDR_Msk                (0xFFFFFFFFUL << USB_OTG_HCDMA_DMAADDR_Pos) /*!< 0xFFFFFFFF */
N#define USB_OTG_HCDMA_DMAADDR                    USB_OTG_HCDMA_DMAADDR_Msk     /*!< DMA address */
N
N/********************  Bit definition for USB_OTG_DTXFSTS register  ********************/
N#define USB_OTG_DTXFSTS_INEPTFSAV_Pos            (0U)                          
N#define USB_OTG_DTXFSTS_INEPTFSAV_Msk            (0xFFFFUL << USB_OTG_DTXFSTS_INEPTFSAV_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DTXFSTS_INEPTFSAV                USB_OTG_DTXFSTS_INEPTFSAV_Msk /*!< IN endpoint TxFIFO space available */
N
N/********************  Bit definition for USB_OTG_DIEPTXF register  ********************/
N#define USB_OTG_DIEPTXF_INEPTXSA_Pos             (0U)                          
N#define USB_OTG_DIEPTXF_INEPTXSA_Msk             (0xFFFFUL << USB_OTG_DIEPTXF_INEPTXSA_Pos) /*!< 0x0000FFFF */
N#define USB_OTG_DIEPTXF_INEPTXSA                 USB_OTG_DIEPTXF_INEPTXSA_Msk  /*!< IN endpoint FIFOx transmit RAM start address */
N#define USB_OTG_DIEPTXF_INEPTXFD_Pos             (16U)                         
N#define USB_OTG_DIEPTXF_INEPTXFD_Msk             (0xFFFFUL << USB_OTG_DIEPTXF_INEPTXFD_Pos) /*!< 0xFFFF0000 */
N#define USB_OTG_DIEPTXF_INEPTXFD                 USB_OTG_DIEPTXF_INEPTXFD_Msk  /*!< IN endpoint TxFIFO depth */
N
N/********************  Bit definition for USB_OTG_DOEPCTL register  ********************/
N
N#define USB_OTG_DOEPCTL_MPSIZ_Pos                (0U)                          
N#define USB_OTG_DOEPCTL_MPSIZ_Msk                (0x7FFUL << USB_OTG_DOEPCTL_MPSIZ_Pos) /*!< 0x000007FF */
N#define USB_OTG_DOEPCTL_MPSIZ                    USB_OTG_DOEPCTL_MPSIZ_Msk     /*!< Maximum packet size */          /*!<Bit 1 */
N#define USB_OTG_DOEPCTL_USBAEP_Pos               (15U)                         
N#define USB_OTG_DOEPCTL_USBAEP_Msk               (0x1UL << USB_OTG_DOEPCTL_USBAEP_Pos) /*!< 0x00008000 */
N#define USB_OTG_DOEPCTL_USBAEP                   USB_OTG_DOEPCTL_USBAEP_Msk    /*!< USB active endpoint */
N#define USB_OTG_DOEPCTL_NAKSTS_Pos               (17U)                         
N#define USB_OTG_DOEPCTL_NAKSTS_Msk               (0x1UL << USB_OTG_DOEPCTL_NAKSTS_Pos) /*!< 0x00020000 */
N#define USB_OTG_DOEPCTL_NAKSTS                   USB_OTG_DOEPCTL_NAKSTS_Msk    /*!< NAK status */
N#define USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Pos       (28U)                         
N#define USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Msk       (0x1UL << USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Pos) /*!< 0x10000000 */
N#define USB_OTG_DOEPCTL_SD0PID_SEVNFRM           USB_OTG_DOEPCTL_SD0PID_SEVNFRM_Msk /*!< Set DATA0 PID */
N#define USB_OTG_DOEPCTL_SODDFRM_Pos              (29U)                         
N#define USB_OTG_DOEPCTL_SODDFRM_Msk              (0x1UL << USB_OTG_DOEPCTL_SODDFRM_Pos) /*!< 0x20000000 */
N#define USB_OTG_DOEPCTL_SODDFRM                  USB_OTG_DOEPCTL_SODDFRM_Msk   /*!< Set odd frame */
N#define USB_OTG_DOEPCTL_EPTYP_Pos                (18U)                         
N#define USB_OTG_DOEPCTL_EPTYP_Msk                (0x3UL << USB_OTG_DOEPCTL_EPTYP_Pos) /*!< 0x000C0000 */
N#define USB_OTG_DOEPCTL_EPTYP                    USB_OTG_DOEPCTL_EPTYP_Msk     /*!< Endpoint type */
N#define USB_OTG_DOEPCTL_EPTYP_0                  (0x1UL << USB_OTG_DOEPCTL_EPTYP_Pos) /*!< 0x00040000 */
N#define USB_OTG_DOEPCTL_EPTYP_1                  (0x2UL << USB_OTG_DOEPCTL_EPTYP_Pos) /*!< 0x00080000 */
N#define USB_OTG_DOEPCTL_SNPM_Pos                 (20U)                         
N#define USB_OTG_DOEPCTL_SNPM_Msk                 (0x1UL << USB_OTG_DOEPCTL_SNPM_Pos) /*!< 0x00100000 */
N#define USB_OTG_DOEPCTL_SNPM                     USB_OTG_DOEPCTL_SNPM_Msk      /*!< Snoop mode */
N#define USB_OTG_DOEPCTL_STALL_Pos                (21U)                         
N#define USB_OTG_DOEPCTL_STALL_Msk                (0x1UL << USB_OTG_DOEPCTL_STALL_Pos) /*!< 0x00200000 */
N#define USB_OTG_DOEPCTL_STALL                    USB_OTG_DOEPCTL_STALL_Msk     /*!< STALL handshake */
N#define USB_OTG_DOEPCTL_CNAK_Pos                 (26U)                         
N#define USB_OTG_DOEPCTL_CNAK_Msk                 (0x1UL << USB_OTG_DOEPCTL_CNAK_Pos) /*!< 0x04000000 */
N#define USB_OTG_DOEPCTL_CNAK                     USB_OTG_DOEPCTL_CNAK_Msk      /*!< Clear NAK */
N#define USB_OTG_DOEPCTL_SNAK_Pos                 (27U)                         
N#define USB_OTG_DOEPCTL_SNAK_Msk                 (0x1UL << USB_OTG_DOEPCTL_SNAK_Pos) /*!< 0x08000000 */
N#define USB_OTG_DOEPCTL_SNAK                     USB_OTG_DOEPCTL_SNAK_Msk      /*!< Set NAK */
N#define USB_OTG_DOEPCTL_EPDIS_Pos                (30U)                         
N#define USB_OTG_DOEPCTL_EPDIS_Msk                (0x1UL << USB_OTG_DOEPCTL_EPDIS_Pos) /*!< 0x40000000 */
N#define USB_OTG_DOEPCTL_EPDIS                    USB_OTG_DOEPCTL_EPDIS_Msk     /*!< Endpoint disable */
N#define USB_OTG_DOEPCTL_EPENA_Pos                (31U)                         
N#define USB_OTG_DOEPCTL_EPENA_Msk                (0x1UL << USB_OTG_DOEPCTL_EPENA_Pos) /*!< 0x80000000 */
N#define USB_OTG_DOEPCTL_EPENA                    USB_OTG_DOEPCTL_EPENA_Msk     /*!< Endpoint enable */
N
N/********************  Bit definition for USB_OTG_DOEPINT register  ********************/
N#define USB_OTG_DOEPINT_XFRC_Pos                 (0U)                          
N#define USB_OTG_DOEPINT_XFRC_Msk                 (0x1UL << USB_OTG_DOEPINT_XFRC_Pos) /*!< 0x00000001 */
N#define USB_OTG_DOEPINT_XFRC                     USB_OTG_DOEPINT_XFRC_Msk      /*!< Transfer completed interrupt */
N#define USB_OTG_DOEPINT_EPDISD_Pos               (1U)                          
N#define USB_OTG_DOEPINT_EPDISD_Msk               (0x1UL << USB_OTG_DOEPINT_EPDISD_Pos) /*!< 0x00000002 */
N#define USB_OTG_DOEPINT_EPDISD                   USB_OTG_DOEPINT_EPDISD_Msk    /*!< Endpoint disabled interrupt */
N#define USB_OTG_DOEPINT_AHBERR_Pos               (2U)
N#define USB_OTG_DOEPINT_AHBERR_Msk               (0x1UL << USB_OTG_DOEPINT_AHBERR_Pos) /*!< 0x00000004 */
N#define USB_OTG_DOEPINT_AHBERR                   USB_OTG_DOEPINT_AHBERR_Msk   /*!< AHB Error (AHBErr) during an OUT transaction */
N#define USB_OTG_DOEPINT_STUP_Pos                 (3U)                          
N#define USB_OTG_DOEPINT_STUP_Msk                 (0x1UL << USB_OTG_DOEPINT_STUP_Pos) /*!< 0x00000008 */
N#define USB_OTG_DOEPINT_STUP                     USB_OTG_DOEPINT_STUP_Msk      /*!< SETUP phase done */
N#define USB_OTG_DOEPINT_OTEPDIS_Pos              (4U)                          
N#define USB_OTG_DOEPINT_OTEPDIS_Msk              (0x1UL << USB_OTG_DOEPINT_OTEPDIS_Pos) /*!< 0x00000010 */
N#define USB_OTG_DOEPINT_OTEPDIS                  USB_OTG_DOEPINT_OTEPDIS_Msk   /*!< OUT token received when endpoint disabled */
N#define USB_OTG_DOEPINT_OTEPSPR_Pos              (5U)                          
N#define USB_OTG_DOEPINT_OTEPSPR_Msk              (0x1UL << USB_OTG_DOEPINT_OTEPSPR_Pos) /*!< 0x00000020 */
N#define USB_OTG_DOEPINT_OTEPSPR                  USB_OTG_DOEPINT_OTEPSPR_Msk   /*!< Status Phase Received For Control Write */
N#define USB_OTG_DOEPINT_B2BSTUP_Pos              (6U)                          
N#define USB_OTG_DOEPINT_B2BSTUP_Msk              (0x1UL << USB_OTG_DOEPINT_B2BSTUP_Pos) /*!< 0x00000040 */
N#define USB_OTG_DOEPINT_B2BSTUP                  USB_OTG_DOEPINT_B2BSTUP_Msk   /*!< Back-to-back SETUP packets received */
N#define USB_OTG_DOEPINT_OUTPKTERR_Pos            (8U)
N#define USB_OTG_DOEPINT_OUTPKTERR_Msk            (0x1UL << USB_OTG_DOEPINT_OUTPKTERR_Pos) /*!< 0x00000100 */
N#define USB_OTG_DOEPINT_OUTPKTERR                USB_OTG_DOEPINT_OUTPKTERR_Msk   /*!< OUT packet error */
N#define USB_OTG_DOEPINT_NAK_Pos                  (13U)
N#define USB_OTG_DOEPINT_NAK_Msk                  (0x1UL << USB_OTG_DOEPINT_NAK_Pos) /*!< 0x00002000 */
N#define USB_OTG_DOEPINT_NAK                      USB_OTG_DOEPINT_NAK_Msk   /*!< NAK Packet is transmitted by the device */
N#define USB_OTG_DOEPINT_NYET_Pos                 (14U)                         
N#define USB_OTG_DOEPINT_NYET_Msk                 (0x1UL << USB_OTG_DOEPINT_NYET_Pos) /*!< 0x00004000 */
N#define USB_OTG_DOEPINT_NYET                     USB_OTG_DOEPINT_NYET_Msk      /*!< NYET interrupt */
N#define USB_OTG_DOEPINT_STPKTRX_Pos              (15U)
N#define USB_OTG_DOEPINT_STPKTRX_Msk              (0x1UL << USB_OTG_DOEPINT_STPKTRX_Pos) /*!< 0x00008000 */
N#define USB_OTG_DOEPINT_STPKTRX                  USB_OTG_DOEPINT_STPKTRX_Msk   /*!< Setup Packet Received */
N/********************  Bit definition for USB_OTG_DOEPTSIZ register  ********************/
N
N#define USB_OTG_DOEPTSIZ_XFRSIZ_Pos              (0U)                          
N#define USB_OTG_DOEPTSIZ_XFRSIZ_Msk              (0x7FFFFUL << USB_OTG_DOEPTSIZ_XFRSIZ_Pos) /*!< 0x0007FFFF */
N#define USB_OTG_DOEPTSIZ_XFRSIZ                  USB_OTG_DOEPTSIZ_XFRSIZ_Msk   /*!< Transfer size */
N#define USB_OTG_DOEPTSIZ_PKTCNT_Pos              (19U)                         
N#define USB_OTG_DOEPTSIZ_PKTCNT_Msk              (0x3FFUL << USB_OTG_DOEPTSIZ_PKTCNT_Pos) /*!< 0x1FF80000 */
N#define USB_OTG_DOEPTSIZ_PKTCNT                  USB_OTG_DOEPTSIZ_PKTCNT_Msk   /*!< Packet count */
N
N#define USB_OTG_DOEPTSIZ_STUPCNT_Pos             (29U)                         
N#define USB_OTG_DOEPTSIZ_STUPCNT_Msk             (0x3UL << USB_OTG_DOEPTSIZ_STUPCNT_Pos) /*!< 0x60000000 */
N#define USB_OTG_DOEPTSIZ_STUPCNT                 USB_OTG_DOEPTSIZ_STUPCNT_Msk  /*!< SETUP packet count */
N#define USB_OTG_DOEPTSIZ_STUPCNT_0               (0x1UL << USB_OTG_DOEPTSIZ_STUPCNT_Pos) /*!< 0x20000000 */
N#define USB_OTG_DOEPTSIZ_STUPCNT_1               (0x2UL << USB_OTG_DOEPTSIZ_STUPCNT_Pos) /*!< 0x40000000 */
N
N/********************  Bit definition for PCGCCTL register  ********************/
N#define USB_OTG_PCGCCTL_STOPCLK_Pos              (0U)                          
N#define USB_OTG_PCGCCTL_STOPCLK_Msk              (0x1UL << USB_OTG_PCGCCTL_STOPCLK_Pos) /*!< 0x00000001 */
N#define USB_OTG_PCGCCTL_STOPCLK                  USB_OTG_PCGCCTL_STOPCLK_Msk   /*!< SETUP packet count */
N#define USB_OTG_PCGCCTL_GATECLK_Pos              (1U)                          
N#define USB_OTG_PCGCCTL_GATECLK_Msk              (0x1UL << USB_OTG_PCGCCTL_GATECLK_Pos) /*!< 0x00000002 */
N#define USB_OTG_PCGCCTL_GATECLK                  USB_OTG_PCGCCTL_GATECLK_Msk   /*!<Bit 0 */
N#define USB_OTG_PCGCCTL_PHYSUSP_Pos              (4U)                          
N#define USB_OTG_PCGCCTL_PHYSUSP_Msk              (0x1UL << USB_OTG_PCGCCTL_PHYSUSP_Pos) /*!< 0x00000010 */
N#define USB_OTG_PCGCCTL_PHYSUSP                  USB_OTG_PCGCCTL_PHYSUSP_Msk   /*!<Bit 1 */
N
N/* Legacy define */
N/********************  Bit definition for OTG register  ********************/
N#define USB_OTG_CHNUM_Pos                        (0U)                          
N#define USB_OTG_CHNUM_Msk                        (0xFUL << USB_OTG_CHNUM_Pos)   /*!< 0x0000000F */
N#define USB_OTG_CHNUM                            USB_OTG_CHNUM_Msk             /*!< Channel number */
N#define USB_OTG_CHNUM_0                          (0x1UL << USB_OTG_CHNUM_Pos)   /*!< 0x00000001 */
N#define USB_OTG_CHNUM_1                          (0x2UL << USB_OTG_CHNUM_Pos)   /*!< 0x00000002 */
N#define USB_OTG_CHNUM_2                          (0x4UL << USB_OTG_CHNUM_Pos)   /*!< 0x00000004 */
N#define USB_OTG_CHNUM_3                          (0x8UL << USB_OTG_CHNUM_Pos)   /*!< 0x00000008 */
N#define USB_OTG_BCNT_Pos                         (4U)                          
N#define USB_OTG_BCNT_Msk                         (0x7FFUL << USB_OTG_BCNT_Pos)  /*!< 0x00007FF0 */
N#define USB_OTG_BCNT                             USB_OTG_BCNT_Msk              /*!< Byte count */
N
N#define USB_OTG_DPID_Pos                         (15U)                         
N#define USB_OTG_DPID_Msk                         (0x3UL << USB_OTG_DPID_Pos)    /*!< 0x00018000 */
N#define USB_OTG_DPID                             USB_OTG_DPID_Msk              /*!< Data PID */
N#define USB_OTG_DPID_0                           (0x1UL << USB_OTG_DPID_Pos)    /*!< 0x00008000 */
N#define USB_OTG_DPID_1                           (0x2UL << USB_OTG_DPID_Pos)    /*!< 0x00010000 */
N
N#define USB_OTG_PKTSTS_Pos                       (17U)                         
N#define USB_OTG_PKTSTS_Msk                       (0xFUL << USB_OTG_PKTSTS_Pos)  /*!< 0x001E0000 */
N#define USB_OTG_PKTSTS                           USB_OTG_PKTSTS_Msk            /*!< Packet status */
N#define USB_OTG_PKTSTS_0                         (0x1UL << USB_OTG_PKTSTS_Pos)  /*!< 0x00020000 */
N#define USB_OTG_PKTSTS_1                         (0x2UL << USB_OTG_PKTSTS_Pos)  /*!< 0x00040000 */
N#define USB_OTG_PKTSTS_2                         (0x4UL << USB_OTG_PKTSTS_Pos)  /*!< 0x00080000 */
N#define USB_OTG_PKTSTS_3                         (0x8UL << USB_OTG_PKTSTS_Pos)  /*!< 0x00100000 */
N
N#define USB_OTG_EPNUM_Pos                        (0U)                          
N#define USB_OTG_EPNUM_Msk                        (0xFUL << USB_OTG_EPNUM_Pos)   /*!< 0x0000000F */
N#define USB_OTG_EPNUM                            USB_OTG_EPNUM_Msk             /*!< Endpoint number */
N#define USB_OTG_EPNUM_0                          (0x1UL << USB_OTG_EPNUM_Pos)   /*!< 0x00000001 */
N#define USB_OTG_EPNUM_1                          (0x2UL << USB_OTG_EPNUM_Pos)   /*!< 0x00000002 */
N#define USB_OTG_EPNUM_2                          (0x4UL << USB_OTG_EPNUM_Pos)   /*!< 0x00000004 */
N#define USB_OTG_EPNUM_3                          (0x8UL << USB_OTG_EPNUM_Pos)   /*!< 0x00000008 */
N
N#define USB_OTG_FRMNUM_Pos                       (21U)                         
N#define USB_OTG_FRMNUM_Msk                       (0xFUL << USB_OTG_FRMNUM_Pos)  /*!< 0x01E00000 */
N#define USB_OTG_FRMNUM                           USB_OTG_FRMNUM_Msk            /*!< Frame number */
N#define USB_OTG_FRMNUM_0                         (0x1UL << USB_OTG_FRMNUM_Pos)  /*!< 0x00200000 */
N#define USB_OTG_FRMNUM_1                         (0x2UL << USB_OTG_FRMNUM_Pos)  /*!< 0x00400000 */
N#define USB_OTG_FRMNUM_2                         (0x4UL << USB_OTG_FRMNUM_Pos)  /*!< 0x00800000 */
N#define USB_OTG_FRMNUM_3                         (0x8UL << USB_OTG_FRMNUM_Pos)  /*!< 0x01000000 */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N
N/******************************* ADC Instances ********************************/
N#define IS_ADC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == ADC1)
N
N#define IS_ADC_COMMON_INSTANCE(INSTANCE) ((INSTANCE) == ADC1_COMMON)
N/******************************* CRC Instances ********************************/
N#define IS_CRC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CRC)
N
N
N/******************************** DMA Instances *******************************/
N#define IS_DMA_STREAM_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Stream0) || \
N                                              ((INSTANCE) == DMA1_Stream1) || \
N                                              ((INSTANCE) == DMA1_Stream2) || \
N                                              ((INSTANCE) == DMA1_Stream3) || \
N                                              ((INSTANCE) == DMA1_Stream4) || \
N                                              ((INSTANCE) == DMA1_Stream5) || \
N                                              ((INSTANCE) == DMA1_Stream6) || \
N                                              ((INSTANCE) == DMA1_Stream7) || \
N                                              ((INSTANCE) == DMA2_Stream0) || \
N                                              ((INSTANCE) == DMA2_Stream1) || \
N                                              ((INSTANCE) == DMA2_Stream2) || \
N                                              ((INSTANCE) == DMA2_Stream3) || \
N                                              ((INSTANCE) == DMA2_Stream4) || \
N                                              ((INSTANCE) == DMA2_Stream5) || \
N                                              ((INSTANCE) == DMA2_Stream6) || \
N                                              ((INSTANCE) == DMA2_Stream7))
X#define IS_DMA_STREAM_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Stream0) ||                                               ((INSTANCE) == DMA1_Stream1) ||                                               ((INSTANCE) == DMA1_Stream2) ||                                               ((INSTANCE) == DMA1_Stream3) ||                                               ((INSTANCE) == DMA1_Stream4) ||                                               ((INSTANCE) == DMA1_Stream5) ||                                               ((INSTANCE) == DMA1_Stream6) ||                                               ((INSTANCE) == DMA1_Stream7) ||                                               ((INSTANCE) == DMA2_Stream0) ||                                               ((INSTANCE) == DMA2_Stream1) ||                                               ((INSTANCE) == DMA2_Stream2) ||                                               ((INSTANCE) == DMA2_Stream3) ||                                               ((INSTANCE) == DMA2_Stream4) ||                                               ((INSTANCE) == DMA2_Stream5) ||                                               ((INSTANCE) == DMA2_Stream6) ||                                               ((INSTANCE) == DMA2_Stream7))
N
N/******************************* GPIO Instances *******************************/
N#define IS_GPIO_ALL_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) || \
N                                        ((INSTANCE) == GPIOB) || \
N                                        ((INSTANCE) == GPIOC) || \
N                                        ((INSTANCE) == GPIOD) || \
N                                        ((INSTANCE) == GPIOE) || \
N                                        ((INSTANCE) == GPIOH))
X#define IS_GPIO_ALL_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) ||                                         ((INSTANCE) == GPIOB) ||                                         ((INSTANCE) == GPIOC) ||                                         ((INSTANCE) == GPIOD) ||                                         ((INSTANCE) == GPIOE) ||                                         ((INSTANCE) == GPIOH))
N
N/******************************** I2C Instances *******************************/
N#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) || \
N                                       ((INSTANCE) == I2C2) || \
N                                       ((INSTANCE) == I2C3))
X#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) ||                                        ((INSTANCE) == I2C2) ||                                        ((INSTANCE) == I2C3))
N
N/******************************* SMBUS Instances ******************************/
N#define IS_SMBUS_ALL_INSTANCE         IS_I2C_ALL_INSTANCE
N
N/******************************** I2S Instances *******************************/
N
N#define IS_I2S_ALL_INSTANCE(INSTANCE)  (((INSTANCE) == SPI2) || \
N                                       ((INSTANCE) == SPI3))
X#define IS_I2S_ALL_INSTANCE(INSTANCE)  (((INSTANCE) == SPI2) ||                                        ((INSTANCE) == SPI3))
N
N/*************************** I2S Extended Instances ***************************/
N#define IS_I2S_EXT_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2S2ext)|| \
N                                           ((INSTANCE) == I2S3ext))
X#define IS_I2S_EXT_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2S2ext)||                                            ((INSTANCE) == I2S3ext))
N/* Legacy Defines */
N#define IS_I2S_ALL_INSTANCE_EXT    IS_I2S_EXT_ALL_INSTANCE
N
N
N/****************************** RTC Instances *********************************/
N#define IS_RTC_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == RTC)
N
N
N/******************************** SPI Instances *******************************/
N#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) || \
N                                       ((INSTANCE) == SPI2) || \
N                                       ((INSTANCE) == SPI3) || \
N                                       ((INSTANCE) == SPI4))
X#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) ||                                        ((INSTANCE) == SPI2) ||                                        ((INSTANCE) == SPI3) ||                                        ((INSTANCE) == SPI4))
N
N
N/****************** TIM Instances : All supported instances *******************/
N#define IS_TIM_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   || \
N                                   ((INSTANCE) == TIM2)   || \
N                                   ((INSTANCE) == TIM3)   || \
N                                   ((INSTANCE) == TIM4)   || \
N                                   ((INSTANCE) == TIM5)   || \
N                                   ((INSTANCE) == TIM9)   || \
N                                   ((INSTANCE) == TIM10)  || \
N                                   ((INSTANCE) == TIM11))
X#define IS_TIM_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   ||                                    ((INSTANCE) == TIM2)   ||                                    ((INSTANCE) == TIM3)   ||                                    ((INSTANCE) == TIM4)   ||                                    ((INSTANCE) == TIM5)   ||                                    ((INSTANCE) == TIM9)   ||                                    ((INSTANCE) == TIM10)  ||                                    ((INSTANCE) == TIM11))
N
N
N/************* TIM Instances : at least 1 capture/compare channel *************/
N#define IS_TIM_CC1_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)  || \
N                                         ((INSTANCE) == TIM2)  || \
N                                         ((INSTANCE) == TIM3)  || \
N                                         ((INSTANCE) == TIM4)  || \
N                                         ((INSTANCE) == TIM5)  || \
N                                         ((INSTANCE) == TIM9)  || \
N                                         ((INSTANCE) == TIM10) || \
N                                         ((INSTANCE) == TIM11))
X#define IS_TIM_CC1_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1)  ||                                          ((INSTANCE) == TIM2)  ||                                          ((INSTANCE) == TIM3)  ||                                          ((INSTANCE) == TIM4)  ||                                          ((INSTANCE) == TIM5)  ||                                          ((INSTANCE) == TIM9)  ||                                          ((INSTANCE) == TIM10) ||                                          ((INSTANCE) == TIM11))
N
N/************ TIM Instances : at least 2 capture/compare channels *************/
N#define IS_TIM_CC2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                       ((INSTANCE) == TIM2) || \
N                                       ((INSTANCE) == TIM3) || \
N                                       ((INSTANCE) == TIM4) || \
N                                       ((INSTANCE) == TIM5) || \
N                                       ((INSTANCE) == TIM9))
X#define IS_TIM_CC2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                        ((INSTANCE) == TIM2) ||                                        ((INSTANCE) == TIM3) ||                                        ((INSTANCE) == TIM4) ||                                        ((INSTANCE) == TIM5) ||                                        ((INSTANCE) == TIM9))
N
N/************ TIM Instances : at least 3 capture/compare channels *************/
N#define IS_TIM_CC3_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1) || \
N                                         ((INSTANCE) == TIM2) || \
N                                         ((INSTANCE) == TIM3) || \
N                                         ((INSTANCE) == TIM4) || \
N                                         ((INSTANCE) == TIM5))
X#define IS_TIM_CC3_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1) ||                                          ((INSTANCE) == TIM2) ||                                          ((INSTANCE) == TIM3) ||                                          ((INSTANCE) == TIM4) ||                                          ((INSTANCE) == TIM5))
N
N/************ TIM Instances : at least 4 capture/compare channels *************/
N#define IS_TIM_CC4_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                       ((INSTANCE) == TIM2) || \
N                                       ((INSTANCE) == TIM3) || \
N                                       ((INSTANCE) == TIM4) || \
N                                       ((INSTANCE) == TIM5))
X#define IS_TIM_CC4_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                        ((INSTANCE) == TIM2) ||                                        ((INSTANCE) == TIM3) ||                                        ((INSTANCE) == TIM4) ||                                        ((INSTANCE) == TIM5))
N
N/******************** TIM Instances : Advanced-control timers *****************/
N#define IS_TIM_ADVANCED_INSTANCE(INSTANCE) ((INSTANCE) == TIM1)
N
N/******************* TIM Instances : Timer input XOR function *****************/
N#define IS_TIM_XOR_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1) || \
N                                         ((INSTANCE) == TIM2) || \
N                                         ((INSTANCE) == TIM3) || \
N                                         ((INSTANCE) == TIM4) || \
N                                         ((INSTANCE) == TIM5))
X#define IS_TIM_XOR_INSTANCE(INSTANCE)   (((INSTANCE) == TIM1) ||                                          ((INSTANCE) == TIM2) ||                                          ((INSTANCE) == TIM3) ||                                          ((INSTANCE) == TIM4) ||                                          ((INSTANCE) == TIM5))
N
N/****************** TIM Instances : DMA requests generation (UDE) *************/
N#define IS_TIM_DMA_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                       ((INSTANCE) == TIM2) || \
N                                       ((INSTANCE) == TIM3) || \
N                                       ((INSTANCE) == TIM4) || \
N                                       ((INSTANCE) == TIM5))
X#define IS_TIM_DMA_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                        ((INSTANCE) == TIM2) ||                                        ((INSTANCE) == TIM3) ||                                        ((INSTANCE) == TIM4) ||                                        ((INSTANCE) == TIM5))
N
N/************ TIM Instances : DMA requests generation (CCxDE) *****************/
N#define IS_TIM_DMA_CC_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                          ((INSTANCE) == TIM2) || \
N                                          ((INSTANCE) == TIM3) || \
N                                          ((INSTANCE) == TIM4) || \
N                                          ((INSTANCE) == TIM5))
X#define IS_TIM_DMA_CC_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                           ((INSTANCE) == TIM2) ||                                           ((INSTANCE) == TIM3) ||                                           ((INSTANCE) == TIM4) ||                                           ((INSTANCE) == TIM5))
N
N/************ TIM Instances : DMA requests generation (COMDE) *****************/
N#define IS_TIM_CCDMA_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                          ((INSTANCE) == TIM2) || \
N                                          ((INSTANCE) == TIM3) || \
N                                          ((INSTANCE) == TIM4) || \
N                                          ((INSTANCE) == TIM5)) 
X#define IS_TIM_CCDMA_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                           ((INSTANCE) == TIM2) ||                                           ((INSTANCE) == TIM3) ||                                           ((INSTANCE) == TIM4) ||                                           ((INSTANCE) == TIM5)) 
N
N/******************** TIM Instances : DMA burst feature ***********************/
N#define IS_TIM_DMABURST_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                             ((INSTANCE) == TIM2) || \
N                                             ((INSTANCE) == TIM3) || \
N                                             ((INSTANCE) == TIM4) || \
N                                             ((INSTANCE) == TIM5))
X#define IS_TIM_DMABURST_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                              ((INSTANCE) == TIM2) ||                                              ((INSTANCE) == TIM3) ||                                              ((INSTANCE) == TIM4) ||                                              ((INSTANCE) == TIM5))
N
N/****** TIM Instances : master mode available (TIMx_CR2.MMS available )********/
N#define IS_TIM_MASTER_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                          ((INSTANCE) == TIM2) || \
N                                          ((INSTANCE) == TIM3) || \
N                                          ((INSTANCE) == TIM4) || \
N                                          ((INSTANCE) == TIM5))
X#define IS_TIM_MASTER_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                           ((INSTANCE) == TIM2) ||                                           ((INSTANCE) == TIM3) ||                                           ((INSTANCE) == TIM4) ||                                           ((INSTANCE) == TIM5))
N
N/*********** TIM Instances : Slave mode available (TIMx_SMCR available )*******/
N#define IS_TIM_SLAVE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                         ((INSTANCE) == TIM2) || \
N                                         ((INSTANCE) == TIM3) || \
N                                         ((INSTANCE) == TIM4) || \
N                                         ((INSTANCE) == TIM5) || \
N                                         ((INSTANCE) == TIM9))
X#define IS_TIM_SLAVE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                          ((INSTANCE) == TIM2) ||                                          ((INSTANCE) == TIM3) ||                                          ((INSTANCE) == TIM4) ||                                          ((INSTANCE) == TIM5) ||                                          ((INSTANCE) == TIM9))
N
N/****************** TIM Instances : supporting synchronization ****************/
N#define IS_TIM_SYNCHRO_INSTANCE(INSTANCE)  IS_TIM_MASTER_INSTANCE(INSTANCE)
N
N/********************** TIM Instances : 32 bit Counter ************************/
N#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE)(((INSTANCE) == TIM2) || \
N                                              ((INSTANCE) == TIM5))
X#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE)(((INSTANCE) == TIM2) ||                                               ((INSTANCE) == TIM5))
N
N/***************** TIM Instances : external trigger input availabe ************/
N#define IS_TIM_ETR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                        ((INSTANCE) == TIM2) || \
N                                        ((INSTANCE) == TIM3) || \
N                                        ((INSTANCE) == TIM4) || \
N                                        ((INSTANCE) == TIM5))
X#define IS_TIM_ETR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                         ((INSTANCE) == TIM2) ||                                         ((INSTANCE) == TIM3) ||                                         ((INSTANCE) == TIM4) ||                                         ((INSTANCE) == TIM5))
N
N/****************** TIM Instances : remapping capability **********************/
N#define IS_TIM_REMAP_INSTANCE(INSTANCE) (((INSTANCE) == TIM2)  || \
N                                         ((INSTANCE) == TIM5)  || \
N                                         ((INSTANCE) == TIM11))
X#define IS_TIM_REMAP_INSTANCE(INSTANCE) (((INSTANCE) == TIM2)  ||                                          ((INSTANCE) == TIM5)  ||                                          ((INSTANCE) == TIM11))
N
N/******************* TIM Instances : output(s) available **********************/
N#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL) \
N    ((((INSTANCE) == TIM1) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM2) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM3) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM4) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM5) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM9) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2)))           \
N    ||                                         \
N    (((INSTANCE) == TIM10) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((INSTANCE) == TIM11) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1))))
X#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL)     ((((INSTANCE) == TIM1) &&                       (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM2) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM3) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM4) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM5) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM9) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2)))               ||                                             (((INSTANCE) == TIM10) &&                       (((CHANNEL) == TIM_CHANNEL_1)))               ||                                             (((INSTANCE) == TIM11) &&                       (((CHANNEL) == TIM_CHANNEL_1))))
N
N/************ TIM Instances : complementary output(s) available ***************/
N#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL) \
N   ((((INSTANCE) == TIM1) &&                    \
N     (((CHANNEL) == TIM_CHANNEL_1) ||           \
N      ((CHANNEL) == TIM_CHANNEL_2) ||           \
N      ((CHANNEL) == TIM_CHANNEL_3))))
X#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL)    ((((INSTANCE) == TIM1) &&                         (((CHANNEL) == TIM_CHANNEL_1) ||                 ((CHANNEL) == TIM_CHANNEL_2) ||                 ((CHANNEL) == TIM_CHANNEL_3))))
N
N/****************** TIM Instances : supporting counting mode selection ********/
N#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5))
X#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5))
N
N/****************** TIM Instances : supporting clock division *****************/
N#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   || \
N                                                  ((INSTANCE) == TIM2)   || \
N                                                  ((INSTANCE) == TIM3)   || \
N                                                  ((INSTANCE) == TIM4)   || \
N                                                  ((INSTANCE) == TIM5)   || \
N                                                  ((INSTANCE) == TIM9)   || \
N                                                  ((INSTANCE) == TIM10)  || \
N                                                  ((INSTANCE) == TIM11))
X#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)   ||                                                   ((INSTANCE) == TIM2)   ||                                                   ((INSTANCE) == TIM3)   ||                                                   ((INSTANCE) == TIM4)   ||                                                   ((INSTANCE) == TIM5)   ||                                                   ((INSTANCE) == TIM9)   ||                                                   ((INSTANCE) == TIM10)  ||                                                   ((INSTANCE) == TIM11))
N
N
N/****************** TIM Instances : supporting commutation event generation ***/
N
N#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE) ((INSTANCE) == TIM1)
N
N/****************** TIM Instances : supporting OCxREF clear *******************/
N#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)        (((INSTANCE) == TIM1) || \
N                                                       ((INSTANCE) == TIM2) || \
N                                                       ((INSTANCE) == TIM3) || \
N                                                       ((INSTANCE) == TIM4) || \
N                                                       ((INSTANCE) == TIM5))
X#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)        (((INSTANCE) == TIM1) ||                                                        ((INSTANCE) == TIM2) ||                                                        ((INSTANCE) == TIM3) ||                                                        ((INSTANCE) == TIM4) ||                                                        ((INSTANCE) == TIM5))
N
N/****** TIM Instances : supporting external clock mode 1 for ETRF input *******/
N#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5) || \
N                                                        ((INSTANCE) == TIM9))
X#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5) ||                                                         ((INSTANCE) == TIM9))
N
N/****** TIM Instances : supporting external clock mode 2 for ETRF input *******/
N#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)|| \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5))
X#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1)||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5))
N
N/****** TIM Instances : supporting external clock mode 1 for TIX inputs ******/
N#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5) || \
N                                                        ((INSTANCE) == TIM9))
X#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5) ||                                                         ((INSTANCE) == TIM9))
N
N/********** TIM Instances : supporting internal trigger inputs(ITRX) *********/
N#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)     (((INSTANCE) == TIM1) || \
N                                                        ((INSTANCE) == TIM2) || \
N                                                        ((INSTANCE) == TIM3) || \
N                                                        ((INSTANCE) == TIM4) || \
N                                                        ((INSTANCE) == TIM5) || \
N                                                        ((INSTANCE) == TIM9))
X#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)     (((INSTANCE) == TIM1) ||                                                         ((INSTANCE) == TIM2) ||                                                         ((INSTANCE) == TIM3) ||                                                         ((INSTANCE) == TIM4) ||                                                         ((INSTANCE) == TIM5) ||                                                         ((INSTANCE) == TIM9))
N
N/****************** TIM Instances : supporting repetition counter *************/
N#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1))
N
N/****************** TIM Instances : supporting encoder interface **************/
N#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                      ((INSTANCE) == TIM2) || \
N                                                      ((INSTANCE) == TIM3) || \
N                                                      ((INSTANCE) == TIM4) || \
N                                                      ((INSTANCE) == TIM5) || \
N                                                      ((INSTANCE) == TIM9))
X#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                       ((INSTANCE) == TIM2) ||                                                       ((INSTANCE) == TIM3) ||                                                       ((INSTANCE) == TIM4) ||                                                       ((INSTANCE) == TIM5) ||                                                       ((INSTANCE) == TIM9))
N/****************** TIM Instances : supporting Hall sensor interface **********/
N#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) || \
N                                                          ((INSTANCE) == TIM2) || \
N                                                          ((INSTANCE) == TIM3) || \
N                                                          ((INSTANCE) == TIM4) || \
N                                                          ((INSTANCE) == TIM5))
X#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1) ||                                                           ((INSTANCE) == TIM2) ||                                                           ((INSTANCE) == TIM3) ||                                                           ((INSTANCE) == TIM4) ||                                                           ((INSTANCE) == TIM5))
N/****************** TIM Instances : supporting the break function *************/
N#define IS_TIM_BREAK_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1))
N
N/******************** USART Instances : Synchronous mode **********************/
N#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                     ((INSTANCE) == USART2) || \
N                                     ((INSTANCE) == USART6))
X#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                      ((INSTANCE) == USART2) ||                                      ((INSTANCE) == USART6))
N
N/******************** UART Instances : Half-Duplex mode **********************/
N#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                               ((INSTANCE) == USART2) || \
N                                               ((INSTANCE) == USART6))
X#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                                ((INSTANCE) == USART2) ||                                                ((INSTANCE) == USART6))
N
N/* Legacy defines */
N#define IS_UART_INSTANCE          IS_UART_HALFDUPLEX_INSTANCE
N
N/****************** UART Instances : Hardware Flow control ********************/
N#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                           ((INSTANCE) == USART2) || \
N                                           ((INSTANCE) == USART6))
X#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                            ((INSTANCE) == USART2) ||                                            ((INSTANCE) == USART6))
N/******************** UART Instances : LIN mode **********************/
N#define IS_UART_LIN_INSTANCE          IS_UART_HALFDUPLEX_INSTANCE
N
N/********************* UART Instances : Smart card mode ***********************/
N#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                         ((INSTANCE) == USART2) || \
N                                         ((INSTANCE) == USART6))
X#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                          ((INSTANCE) == USART2) ||                                          ((INSTANCE) == USART6))
N
N/*********************** UART Instances : IRDA mode ***************************/
N#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                    ((INSTANCE) == USART2) || \
N                                    ((INSTANCE) == USART6))     
X#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                     ((INSTANCE) == USART2) ||                                     ((INSTANCE) == USART6))     
N
N/*********************** PCD Instances ****************************************/
N#define IS_PCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS))
N
N/*********************** HCD Instances ****************************************/
N#define IS_HCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS))
N
N/****************************** SDIO Instances ********************************/
N#define IS_SDIO_ALL_INSTANCE(INSTANCE) ((INSTANCE) == SDIO)
N
N/****************************** IWDG Instances ********************************/
N#define IS_IWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == IWDG)
N
N/****************************** WWDG Instances ********************************/
N#define IS_WWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == WWDG)
N
N/****************************** USB Exported Constants ************************/
N#define USB_OTG_FS_HOST_MAX_CHANNEL_NBR                8U
N#define USB_OTG_FS_MAX_IN_ENDPOINTS                    4U    /* Including EP0 */
N#define USB_OTG_FS_MAX_OUT_ENDPOINTS                   4U    /* Including EP0 */
N#define USB_OTG_FS_TOTAL_FIFO_SIZE                     1280U /* in Bytes */
N
N/*
N * @brief Specific devices reset values definitions
N */
N#define RCC_PLLCFGR_RST_VALUE              0x24003010U
N#define RCC_PLLI2SCFGR_RST_VALUE           0x20003000U
N
N#define RCC_MAX_FREQUENCY            84000000U         /*!< Max frequency of family in Hz*/
N#define RCC_MAX_FREQUENCY_SCALE3     60000000U         /*!< Maximum frequency for system clock at power scale3, in Hz */
N#define RCC_MAX_FREQUENCY_SCALE2    RCC_MAX_FREQUENCY  /*!< Maximum frequency for system clock at power scale2, in Hz */
N#define RCC_PLLVCO_OUTPUT_MIN       192000000U       /*!< Frequency min for PLLVCO output, in Hz */
N#define RCC_PLLVCO_INPUT_MIN           950000U       /*!< Frequency min for PLLVCO input, in Hz  */
N#define RCC_PLLVCO_INPUT_MAX          2100000U       /*!< Frequency max for PLLVCO input, in Hz  */
N#define RCC_PLLVCO_OUTPUT_MAX       432000000U       /*!< Frequency max for PLLVCO output, in Hz */
N
N#define RCC_PLLN_MIN_VALUE                192U
N#define RCC_PLLN_MAX_VALUE                432U
N
N#define FLASH_SCALE2_LATENCY1_FREQ    30000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 2  */
N#define FLASH_SCALE2_LATENCY2_FREQ    60000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 2  */
N
N#define FLASH_SCALE3_LATENCY1_FREQ    30000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 3  */
N#define FLASH_SCALE3_LATENCY2_FREQ    60000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 3  */
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F401xE_H */
N
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 164 "..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 2
N#elif defined(STM32F410Tx)
S  #include "stm32f410tx.h"
S#elif defined(STM32F410Cx)
S  #include "stm32f410cx.h"
S#elif defined(STM32F410Rx)
S  #include "stm32f410rx.h"
S#elif defined(STM32F411xE)
S  #include "stm32f411xe.h"
S#elif defined(STM32F446xx)
S  #include "stm32f446xx.h"
S#elif defined(STM32F469xx)
S  #include "stm32f469xx.h"
S#elif defined(STM32F479xx)
S  #include "stm32f479xx.h"
S#elif defined(STM32F412Cx)
S  #include "stm32f412cx.h"
S#elif defined(STM32F412Zx)
S  #include "stm32f412zx.h"
S#elif defined(STM32F412Rx)
S  #include "stm32f412rx.h"
S#elif defined(STM32F412Vx)
S  #include "stm32f412vx.h"
S#elif defined(STM32F413xx)
S  #include "stm32f413xx.h"
S#elif defined(STM32F423xx)
S  #include "stm32f423xx.h"
S#else
S #error "Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)"
N#endif
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_types
N  * @{
N  */ 
Ntypedef enum 
N{
N  RESET = 0U, 
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum 
N{
N  DISABLE = 0U, 
N  ENABLE = !DISABLE
N} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum
N{
N  SUCCESS = 0U,
N  ERROR = !SUCCESS
N} ErrorStatus;
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N#define POSITION_VAL(VAL)     (__CLZ(__RBIT(VAL))) 
N
N
N/**
N  * @}
N  */
N
N#if defined (USE_HAL_DRIVER)
X#if 1L
N #include "stm32f4xx_hal.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal.h
N  * @author  MCD Application Team
N  * @brief   This file contains all the functions prototypes for the HAL 
N  *          module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_H
S#define __STM32F4xx_HAL_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32f4xx_hal_conf.h"
S
S/** @addtogroup STM32F4xx_HAL_Driver
S  * @{
S  */
S
S/** @addtogroup HAL
S  * @{
S  */ 
S
S/* Exported types ------------------------------------------------------------*/
S/* Exported constants --------------------------------------------------------*/
S
S/** @defgroup HAL_Exported_Constants HAL Exported Constants
S  * @{
S  */
S
S/** @defgroup HAL_TICK_FREQ Tick Frequency
S  * @{
S  */
Stypedef enum
S{
S  HAL_TICK_FREQ_10HZ         = 100U,
S  HAL_TICK_FREQ_100HZ        = 10U,
S  HAL_TICK_FREQ_1KHZ         = 1U,
S  HAL_TICK_FREQ_DEFAULT      = HAL_TICK_FREQ_1KHZ
S} HAL_TickFreqTypeDef;
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S   
S/* Exported macro ------------------------------------------------------------*/
S/** @defgroup HAL_Exported_Macros HAL Exported Macros
S  * @{
S  */
S
S/** @brief  Freeze/Unfreeze Peripherals in Debug mode 
S  */
S#define __HAL_DBGMCU_FREEZE_TIM2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM2_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM3()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM3_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM4()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM4_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM5()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM5_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM6()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM6_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM7()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM7_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM12()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM12_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM13()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM13_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM14()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM14_STOP))
S#define __HAL_DBGMCU_FREEZE_RTC()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_RTC_STOP))
S#define __HAL_DBGMCU_FREEZE_WWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_WWDG_STOP))
S#define __HAL_DBGMCU_FREEZE_IWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_IWDG_STOP))
S#define __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
S#define __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
S#define __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
S#define __HAL_DBGMCU_FREEZE_CAN1()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN1_STOP))
S#define __HAL_DBGMCU_FREEZE_CAN2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN2_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM1()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM1_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM8()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM8_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM9()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM9_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM10()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM10_STOP))
S#define __HAL_DBGMCU_FREEZE_TIM11()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM11_STOP))
S
S#define __HAL_DBGMCU_UNFREEZE_TIM2()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM2_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM3()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM3_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM4()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM4_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM5()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM5_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM6()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM6_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM7()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM7_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM12()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM12_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM13()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM13_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM14()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM14_STOP))
S#define __HAL_DBGMCU_UNFREEZE_RTC()            (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_RTC_STOP))
S#define __HAL_DBGMCU_UNFREEZE_WWDG()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_WWDG_STOP))
S#define __HAL_DBGMCU_UNFREEZE_IWDG()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_IWDG_STOP))
S#define __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
S#define __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
S#define __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
S#define __HAL_DBGMCU_UNFREEZE_CAN1()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN1_STOP))
S#define __HAL_DBGMCU_UNFREEZE_CAN2()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN2_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM1()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM1_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM8()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM8_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM9()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM9_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM10()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM10_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM11()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM11_STOP))
S
S/** @brief  Main Flash memory mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FLASH()             (SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE))
S
S/** @brief  System Flash memory mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                         SYSCFG->MEMRMP |= SYSCFG_MEMRMP_MEM_MODE_0;\
S                                                        }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                         SYSCFG->MEMRMP |= SYSCFG_MEMRMP_MEM_MODE_0;                                                        }while(0);
S
S/** @brief  Embedded SRAM mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_SRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_0 | SYSCFG_MEMRMP_MEM_MODE_1);\
S                                                 }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_SRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_0 | SYSCFG_MEMRMP_MEM_MODE_1);                                                 }while(0);
S
S#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)
S/** @brief  FSMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FSMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);\
S                                                 }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FSMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);                                                 }while(0);
S#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
S
S#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
S    defined(STM32F469xx) || defined(STM32F479xx)
X#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||    defined(STM32F469xx) || defined(STM32F479xx)
S/** @brief  FMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                 SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);\
S                                                }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                 SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);                                                }while(0);
S
S/** @brief  FMC/SDRAM Bank 1 and 2 mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                       SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_2);\
S                                                      }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                       SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_2);                                                      }while(0);
S#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */ 
S
S#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S/** @defgroup Cortex_Lockup_Enable Cortex Lockup Enable
S  * @{
S  */
S/** @brief  SYSCFG Break Lockup lock
S  *         Enables and locks the connection of Cortex-M4 LOCKUP (Hardfault) output to TIM1/8 input
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK); \
S                                               SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;    \
S                                              }while(0)
X#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK);                                                SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;                                                  }while(0)
S/**
S * @}
S */
S
S/** @defgroup PVD_Lock_Enable PVD Lock
S  * @{
S  */
S/** @brief  SYSCFG Break PVD lock
S  *         Enables and locks the PVD connection with Timer1/8 Break Input, , as well as the PVDE and PLS[2:0] in the PWR_CR register
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()     do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK); \
S                                                 SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;    \
S                                                }while(0)
X#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()     do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK);                                                  SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;                                                    }while(0)
S/**
S * @}
S */
S#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx || STM32F413xx || STM32F423xx */
S/**
S  * @}
S  */
S
S/** @defgroup HAL_Private_Macros HAL Private Macros
S  * @{
S  */
S#define IS_TICKFREQ(FREQ) (((FREQ) == HAL_TICK_FREQ_10HZ)  || \
S                           ((FREQ) == HAL_TICK_FREQ_100HZ) || \
S                           ((FREQ) == HAL_TICK_FREQ_1KHZ))
X#define IS_TICKFREQ(FREQ) (((FREQ) == HAL_TICK_FREQ_10HZ)  ||                            ((FREQ) == HAL_TICK_FREQ_100HZ) ||                            ((FREQ) == HAL_TICK_FREQ_1KHZ))
S/**
S  * @}
S  */
S
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup HAL_Exported_Functions
S  * @{
S  */
S/** @addtogroup HAL_Exported_Functions_Group1
S  * @{
S  */
S/* Initialization and Configuration functions  ******************************/
SHAL_StatusTypeDef HAL_Init(void);
SHAL_StatusTypeDef HAL_DeInit(void);
Svoid HAL_MspInit(void);
Svoid HAL_MspDeInit(void);
SHAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority);
S/**
S  * @}
S  */
S
S/** @addtogroup HAL_Exported_Functions_Group2
S  * @{
S  */
S/* Peripheral Control functions  ************************************************/
Svoid HAL_IncTick(void);
Svoid HAL_Delay(uint32_t Delay);
Suint32_t HAL_GetTick(void);
Suint32_t HAL_GetTickPrio(void);
SHAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq);
SHAL_TickFreqTypeDef HAL_GetTickFreq(void);
Svoid HAL_SuspendTick(void);
Svoid HAL_ResumeTick(void);
Suint32_t HAL_GetHalVersion(void);
Suint32_t HAL_GetREVID(void);
Suint32_t HAL_GetDEVID(void);
Svoid HAL_DBGMCU_EnableDBGSleepMode(void);
Svoid HAL_DBGMCU_DisableDBGSleepMode(void);
Svoid HAL_DBGMCU_EnableDBGStopMode(void);
Svoid HAL_DBGMCU_DisableDBGStopMode(void);
Svoid HAL_DBGMCU_EnableDBGStandbyMode(void);
Svoid HAL_DBGMCU_DisableDBGStandbyMode(void);
Svoid HAL_EnableCompensationCell(void);
Svoid HAL_DisableCompensationCell(void);
Suint32_t HAL_GetUIDw0(void);
Suint32_t HAL_GetUIDw1(void);
Suint32_t HAL_GetUIDw2(void);
S#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
S    defined(STM32F469xx) || defined(STM32F479xx)
X#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||    defined(STM32F469xx) || defined(STM32F479xx)
Svoid HAL_EnableMemorySwappingBank(void);
Svoid HAL_DisableMemorySwappingBank(void);
S#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */ 
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S/* Private types -------------------------------------------------------------*/
S/* Private variables ---------------------------------------------------------*/
S/** @defgroup HAL_Private_Variables HAL Private Variables
S  * @{
S  */
S/**
S  * @}
S  */
S/* Private constants ---------------------------------------------------------*/
S/** @defgroup HAL_Private_Constants HAL Private Constants
S  * @{
S  */
S/**
S  * @}
S  */
S/* Private macros ------------------------------------------------------------*/
S/* Private functions ---------------------------------------------------------*/
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */ 
S  
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __STM32F4xx_HAL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 251 "..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 2
N#endif /* USE_HAL_DRIVER */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F4xx_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 31 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h" 2
N#include "Legacy/stm32_hal_legacy.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32_hal_legacy.h
N  * @author  MCD Application Team
N  * @brief   This file contains aliases definition for the STM32Cube HAL constants
N  *          macros and functions maintained for legacy purpose.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32_HAL_LEGACY
N#define STM32_HAL_LEGACY
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup HAL_AES_Aliased_Defines HAL CRYP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define AES_FLAG_RDERR                  CRYP_FLAG_RDERR
N#define AES_FLAG_WRERR                  CRYP_FLAG_WRERR
N#define AES_CLEARFLAG_CCF               CRYP_CLEARFLAG_CCF
N#define AES_CLEARFLAG_RDERR             CRYP_CLEARFLAG_RDERR
N#define AES_CLEARFLAG_WRERR             CRYP_CLEARFLAG_WRERR
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_ADC_Aliased_Defines HAL ADC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define ADC_RESOLUTION12b               ADC_RESOLUTION_12B
N#define ADC_RESOLUTION10b               ADC_RESOLUTION_10B
N#define ADC_RESOLUTION8b                ADC_RESOLUTION_8B
N#define ADC_RESOLUTION6b                ADC_RESOLUTION_6B
N#define OVR_DATA_OVERWRITTEN            ADC_OVR_DATA_OVERWRITTEN
N#define OVR_DATA_PRESERVED              ADC_OVR_DATA_PRESERVED
N#define EOC_SINGLE_CONV                 ADC_EOC_SINGLE_CONV
N#define EOC_SEQ_CONV                    ADC_EOC_SEQ_CONV
N#define EOC_SINGLE_SEQ_CONV             ADC_EOC_SINGLE_SEQ_CONV
N#define REGULAR_GROUP                   ADC_REGULAR_GROUP
N#define INJECTED_GROUP                  ADC_INJECTED_GROUP
N#define REGULAR_INJECTED_GROUP          ADC_REGULAR_INJECTED_GROUP
N#define AWD_EVENT                       ADC_AWD_EVENT
N#define AWD1_EVENT                      ADC_AWD1_EVENT
N#define AWD2_EVENT                      ADC_AWD2_EVENT
N#define AWD3_EVENT                      ADC_AWD3_EVENT
N#define OVR_EVENT                       ADC_OVR_EVENT
N#define JQOVF_EVENT                     ADC_JQOVF_EVENT
N#define ALL_CHANNELS                    ADC_ALL_CHANNELS
N#define REGULAR_CHANNELS                ADC_REGULAR_CHANNELS
N#define INJECTED_CHANNELS               ADC_INJECTED_CHANNELS
N#define SYSCFG_FLAG_SENSOR_ADC          ADC_FLAG_SENSOR
N#define SYSCFG_FLAG_VREF_ADC            ADC_FLAG_VREFINT
N#define ADC_CLOCKPRESCALER_PCLK_DIV1    ADC_CLOCK_SYNC_PCLK_DIV1
N#define ADC_CLOCKPRESCALER_PCLK_DIV2    ADC_CLOCK_SYNC_PCLK_DIV2
N#define ADC_CLOCKPRESCALER_PCLK_DIV4    ADC_CLOCK_SYNC_PCLK_DIV4
N#define ADC_CLOCKPRESCALER_PCLK_DIV6    ADC_CLOCK_SYNC_PCLK_DIV6
N#define ADC_CLOCKPRESCALER_PCLK_DIV8    ADC_CLOCK_SYNC_PCLK_DIV8
N#define ADC_EXTERNALTRIG0_T6_TRGO       ADC_EXTERNALTRIGCONV_T6_TRGO
N#define ADC_EXTERNALTRIG1_T21_CC2       ADC_EXTERNALTRIGCONV_T21_CC2
N#define ADC_EXTERNALTRIG2_T2_TRGO       ADC_EXTERNALTRIGCONV_T2_TRGO
N#define ADC_EXTERNALTRIG3_T2_CC4        ADC_EXTERNALTRIGCONV_T2_CC4
N#define ADC_EXTERNALTRIG4_T22_TRGO      ADC_EXTERNALTRIGCONV_T22_TRGO
N#define ADC_EXTERNALTRIG7_EXT_IT11      ADC_EXTERNALTRIGCONV_EXT_IT11
N#define ADC_CLOCK_ASYNC                 ADC_CLOCK_ASYNC_DIV1
N#define ADC_EXTERNALTRIG_EDGE_NONE      ADC_EXTERNALTRIGCONVEDGE_NONE
N#define ADC_EXTERNALTRIG_EDGE_RISING    ADC_EXTERNALTRIGCONVEDGE_RISING
N#define ADC_EXTERNALTRIG_EDGE_FALLING   ADC_EXTERNALTRIGCONVEDGE_FALLING
N#define ADC_EXTERNALTRIG_EDGE_RISINGFALLING ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING
N#define ADC_SAMPLETIME_2CYCLE_5         ADC_SAMPLETIME_2CYCLES_5
N
N#define HAL_ADC_STATE_BUSY_REG          HAL_ADC_STATE_REG_BUSY
N#define HAL_ADC_STATE_BUSY_INJ          HAL_ADC_STATE_INJ_BUSY
N#define HAL_ADC_STATE_EOC_REG           HAL_ADC_STATE_REG_EOC
N#define HAL_ADC_STATE_EOC_INJ           HAL_ADC_STATE_INJ_EOC
N#define HAL_ADC_STATE_ERROR             HAL_ADC_STATE_ERROR_INTERNAL
N#define HAL_ADC_STATE_BUSY              HAL_ADC_STATE_BUSY_INTERNAL
N#define HAL_ADC_STATE_AWD               HAL_ADC_STATE_AWD1
N
N#if defined(STM32H7)
X#if 0L
S#define ADC_CHANNEL_VBAT_DIV4           ADC_CHANNEL_VBAT
N#endif /* STM32H7 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CEC_Aliased_Defines HAL CEC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_CEC_GET_IT __HAL_CEC_GET_FLAG
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_COMP_Aliased_Defines HAL COMP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define COMP_WINDOWMODE_DISABLED       COMP_WINDOWMODE_DISABLE
N#define COMP_WINDOWMODE_ENABLED        COMP_WINDOWMODE_ENABLE
N#define COMP_EXTI_LINE_COMP1_EVENT     COMP_EXTI_LINE_COMP1
N#define COMP_EXTI_LINE_COMP2_EVENT     COMP_EXTI_LINE_COMP2
N#define COMP_EXTI_LINE_COMP3_EVENT     COMP_EXTI_LINE_COMP3
N#define COMP_EXTI_LINE_COMP4_EVENT     COMP_EXTI_LINE_COMP4
N#define COMP_EXTI_LINE_COMP5_EVENT     COMP_EXTI_LINE_COMP5
N#define COMP_EXTI_LINE_COMP6_EVENT     COMP_EXTI_LINE_COMP6
N#define COMP_EXTI_LINE_COMP7_EVENT     COMP_EXTI_LINE_COMP7
N#if defined(STM32L0)
X#if 0L
S#define COMP_LPTIMCONNECTION_ENABLED   ((uint32_t)0x00000003U)    /*!< COMPX output generic naming: connected to LPTIM input 1 for COMP1, LPTIM input 2 for COMP2 */
N#endif
N#define COMP_OUTPUT_COMP6TIM2OCREFCLR  COMP_OUTPUT_COMP6_TIM2OCREFCLR
N#if defined(STM32F373xC) || defined(STM32F378xx)
X#if 0L || 0L
S#define COMP_OUTPUT_TIM3IC1            COMP_OUTPUT_COMP1_TIM3IC1
S#define COMP_OUTPUT_TIM3OCREFCLR       COMP_OUTPUT_COMP1_TIM3OCREFCLR
N#endif /* STM32F373xC || STM32F378xx */
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S#define COMP_WINDOWMODE_ENABLE         COMP_WINDOWMODE_COMP1_INPUT_PLUS_COMMON
S
S#define COMP_NONINVERTINGINPUT_IO1      COMP_INPUT_PLUS_IO1
S#define COMP_NONINVERTINGINPUT_IO2      COMP_INPUT_PLUS_IO2
S#define COMP_NONINVERTINGINPUT_IO3      COMP_INPUT_PLUS_IO3
S#define COMP_NONINVERTINGINPUT_IO4      COMP_INPUT_PLUS_IO4
S#define COMP_NONINVERTINGINPUT_IO5      COMP_INPUT_PLUS_IO5
S#define COMP_NONINVERTINGINPUT_IO6      COMP_INPUT_PLUS_IO6
S
S#define COMP_INVERTINGINPUT_1_4VREFINT  COMP_INPUT_MINUS_1_4VREFINT
S#define COMP_INVERTINGINPUT_1_2VREFINT  COMP_INPUT_MINUS_1_2VREFINT
S#define COMP_INVERTINGINPUT_3_4VREFINT  COMP_INPUT_MINUS_3_4VREFINT
S#define COMP_INVERTINGINPUT_VREFINT     COMP_INPUT_MINUS_VREFINT
S#define COMP_INVERTINGINPUT_DAC1_CH1    COMP_INPUT_MINUS_DAC1_CH1
S#define COMP_INVERTINGINPUT_DAC1_CH2    COMP_INPUT_MINUS_DAC1_CH2
S#define COMP_INVERTINGINPUT_DAC1        COMP_INPUT_MINUS_DAC1_CH1
S#define COMP_INVERTINGINPUT_DAC2        COMP_INPUT_MINUS_DAC1_CH2
S#define COMP_INVERTINGINPUT_IO1         COMP_INPUT_MINUS_IO1
S#if defined(STM32L0)
S/* Issue fixed on STM32L0 COMP driver: only 2 dedicated IO (IO1 and IO2),     */
S/* IO2 was wrongly assigned to IO shared with DAC and IO3 was corresponding   */
S/* to the second dedicated IO (only for COMP2).                               */
S#define COMP_INVERTINGINPUT_IO2         COMP_INPUT_MINUS_DAC1_CH2
S#define COMP_INVERTINGINPUT_IO3         COMP_INPUT_MINUS_IO2
S#else
S#define COMP_INVERTINGINPUT_IO2         COMP_INPUT_MINUS_IO2
S#define COMP_INVERTINGINPUT_IO3         COMP_INPUT_MINUS_IO3
S#endif
S#define COMP_INVERTINGINPUT_IO4         COMP_INPUT_MINUS_IO4
S#define COMP_INVERTINGINPUT_IO5         COMP_INPUT_MINUS_IO5
S
S#define COMP_OUTPUTLEVEL_LOW            COMP_OUTPUT_LEVEL_LOW
S#define COMP_OUTPUTLEVEL_HIGH           COMP_OUTPUT_LEVEL_HIGH
S
S/* Note: Literal "COMP_FLAG_LOCK" kept for legacy purpose.                    */
S/*       To check COMP lock state, use macro "__HAL_COMP_IS_LOCKED()".        */
S#if defined(COMP_CSR_LOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_LOCK
S#elif defined(COMP_CSR_COMP1LOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_COMP1LOCK
S#elif defined(COMP_CSR_COMPxLOCK)
S#define COMP_FLAG_LOCK                 COMP_CSR_COMPxLOCK
S#endif
S
S#if defined(STM32L4)
S#define COMP_BLANKINGSRCE_TIM1OC5        COMP_BLANKINGSRC_TIM1_OC5_COMP1
S#define COMP_BLANKINGSRCE_TIM2OC3        COMP_BLANKINGSRC_TIM2_OC3_COMP1
S#define COMP_BLANKINGSRCE_TIM3OC3        COMP_BLANKINGSRC_TIM3_OC3_COMP1
S#define COMP_BLANKINGSRCE_TIM3OC4        COMP_BLANKINGSRC_TIM3_OC4_COMP2
S#define COMP_BLANKINGSRCE_TIM8OC5        COMP_BLANKINGSRC_TIM8_OC5_COMP2
S#define COMP_BLANKINGSRCE_TIM15OC1       COMP_BLANKINGSRC_TIM15_OC1_COMP2
S#define COMP_BLANKINGSRCE_NONE           COMP_BLANKINGSRC_NONE
S#endif
S
S#if defined(STM32L0)
S#define COMP_MODE_HIGHSPEED              COMP_POWERMODE_MEDIUMSPEED
S#define COMP_MODE_LOWSPEED               COMP_POWERMODE_ULTRALOWPOWER
S#else
S#define COMP_MODE_HIGHSPEED              COMP_POWERMODE_HIGHSPEED
S#define COMP_MODE_MEDIUMSPEED            COMP_POWERMODE_MEDIUMSPEED
S#define COMP_MODE_LOWPOWER               COMP_POWERMODE_LOWPOWER
S#define COMP_MODE_ULTRALOWPOWER          COMP_POWERMODE_ULTRALOWPOWER
S#endif
S
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CORTEX_Aliased_Defines HAL CORTEX Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define __HAL_CORTEX_SYSTICKCLK_CONFIG HAL_SYSTICK_CLKSourceConfig
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CRC_Aliased_Defines HAL CRC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define CRC_OUTPUTDATA_INVERSION_DISABLED    CRC_OUTPUTDATA_INVERSION_DISABLE
N#define CRC_OUTPUTDATA_INVERSION_ENABLED     CRC_OUTPUTDATA_INVERSION_ENABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DAC_Aliased_Defines HAL DAC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define DAC1_CHANNEL_1                                  DAC_CHANNEL_1
N#define DAC1_CHANNEL_2                                  DAC_CHANNEL_2
N#define DAC2_CHANNEL_1                                  DAC_CHANNEL_1
N#define DAC_WAVE_NONE                                   0x00000000U
N#define DAC_WAVE_NOISE                                  DAC_CR_WAVE1_0
N#define DAC_WAVE_TRIANGLE                               DAC_CR_WAVE1_1
N#define DAC_WAVEGENERATION_NONE                         DAC_WAVE_NONE
N#define DAC_WAVEGENERATION_NOISE                        DAC_WAVE_NOISE
N#define DAC_WAVEGENERATION_TRIANGLE                     DAC_WAVE_TRIANGLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DMA_Aliased_Defines HAL DMA Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_REMAPDMA_ADC_DMA_CH2                DMA_REMAP_ADC_DMA_CH2
N#define HAL_REMAPDMA_USART1_TX_DMA_CH4          DMA_REMAP_USART1_TX_DMA_CH4
N#define HAL_REMAPDMA_USART1_RX_DMA_CH5          DMA_REMAP_USART1_RX_DMA_CH5
N#define HAL_REMAPDMA_TIM16_DMA_CH4              DMA_REMAP_TIM16_DMA_CH4
N#define HAL_REMAPDMA_TIM17_DMA_CH2              DMA_REMAP_TIM17_DMA_CH2
N#define HAL_REMAPDMA_USART3_DMA_CH32            DMA_REMAP_USART3_DMA_CH32
N#define HAL_REMAPDMA_TIM16_DMA_CH6              DMA_REMAP_TIM16_DMA_CH6
N#define HAL_REMAPDMA_TIM17_DMA_CH7              DMA_REMAP_TIM17_DMA_CH7
N#define HAL_REMAPDMA_SPI2_DMA_CH67              DMA_REMAP_SPI2_DMA_CH67
N#define HAL_REMAPDMA_USART2_DMA_CH67            DMA_REMAP_USART2_DMA_CH67
N#define HAL_REMAPDMA_I2C1_DMA_CH76              DMA_REMAP_I2C1_DMA_CH76
N#define HAL_REMAPDMA_TIM1_DMA_CH6               DMA_REMAP_TIM1_DMA_CH6
N#define HAL_REMAPDMA_TIM2_DMA_CH7               DMA_REMAP_TIM2_DMA_CH7
N#define HAL_REMAPDMA_TIM3_DMA_CH6               DMA_REMAP_TIM3_DMA_CH6
N
N#define IS_HAL_REMAPDMA                          IS_DMA_REMAP
N#define __HAL_REMAPDMA_CHANNEL_ENABLE            __HAL_DMA_REMAP_CHANNEL_ENABLE
N#define __HAL_REMAPDMA_CHANNEL_DISABLE           __HAL_DMA_REMAP_CHANNEL_DISABLE
N
N#if defined(STM32L4)
X#if 0L
S
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI0            HAL_DMAMUX1_REQ_GEN_EXTI0
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI1            HAL_DMAMUX1_REQ_GEN_EXTI1
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI2            HAL_DMAMUX1_REQ_GEN_EXTI2
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI3            HAL_DMAMUX1_REQ_GEN_EXTI3
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI4            HAL_DMAMUX1_REQ_GEN_EXTI4
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI5            HAL_DMAMUX1_REQ_GEN_EXTI5
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI6            HAL_DMAMUX1_REQ_GEN_EXTI6
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI7            HAL_DMAMUX1_REQ_GEN_EXTI7
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI8            HAL_DMAMUX1_REQ_GEN_EXTI8
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI9            HAL_DMAMUX1_REQ_GEN_EXTI9
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI10           HAL_DMAMUX1_REQ_GEN_EXTI10
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI11           HAL_DMAMUX1_REQ_GEN_EXTI11
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI12           HAL_DMAMUX1_REQ_GEN_EXTI12
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI13           HAL_DMAMUX1_REQ_GEN_EXTI13
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI14           HAL_DMAMUX1_REQ_GEN_EXTI14
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI15           HAL_DMAMUX1_REQ_GEN_EXTI15
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH0_EVT  HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH0_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH1_EVT  HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH1_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH2_EVT  HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH2_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH3_EVT  HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH3_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM1_OUT       HAL_DMAMUX1_REQ_GEN_LPTIM1_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM2_OUT       HAL_DMAMUX1_REQ_GEN_LPTIM2_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_DSI_TE           HAL_DMAMUX1_REQ_GEN_DSI_TE
S#define HAL_DMAMUX1_REQUEST_GEN_DSI_EOT          HAL_DMAMUX1_REQ_GEN_DSI_EOT
S#define HAL_DMAMUX1_REQUEST_GEN_DMA2D_EOT        HAL_DMAMUX1_REQ_GEN_DMA2D_EOT
S#define HAL_DMAMUX1_REQUEST_GEN_LTDC_IT          HAL_DMAMUX1_REQ_GEN_LTDC_IT
S
S#define HAL_DMAMUX_REQUEST_GEN_NO_EVENT          HAL_DMAMUX_REQ_GEN_NO_EVENT
S#define HAL_DMAMUX_REQUEST_GEN_RISING            HAL_DMAMUX_REQ_GEN_RISING
S#define HAL_DMAMUX_REQUEST_GEN_FALLING           HAL_DMAMUX_REQ_GEN_FALLING
S#define HAL_DMAMUX_REQUEST_GEN_RISING_FALLING    HAL_DMAMUX_REQ_GEN_RISING_FALLING
S
N#endif /* STM32L4 */
N
N#if defined(STM32H7)
X#if 0L
S
S#define DMA_REQUEST_DAC1 DMA_REQUEST_DAC1_CH1
S#define DMA_REQUEST_DAC2 DMA_REQUEST_DAC1_CH2
S
S#define BDMA_REQUEST_LP_UART1_RX BDMA_REQUEST_LPUART1_RX
S#define BDMA_REQUEST_LP_UART1_TX BDMA_REQUEST_LPUART1_TX
S
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH0_EVT    HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH0_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH1_EVT    HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH1_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_DMAMUX1_CH2_EVT    HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH2_EVT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM1_OUT         HAL_DMAMUX1_REQ_GEN_LPTIM1_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM2_OUT         HAL_DMAMUX1_REQ_GEN_LPTIM2_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_LPTIM3_OUT         HAL_DMAMUX1_REQ_GEN_LPTIM3_OUT
S#define HAL_DMAMUX1_REQUEST_GEN_EXTI0              HAL_DMAMUX1_REQ_GEN_EXTI0
S#define HAL_DMAMUX1_REQUEST_GEN_TIM12_TRGO         HAL_DMAMUX1_REQ_GEN_TIM12_TRGO
S
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH0_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH0_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH1_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH1_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH2_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH2_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH3_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH3_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH4_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH4_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH5_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH5_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_DMAMUX2_CH6_EVT    HAL_DMAMUX2_REQ_GEN_DMAMUX2_CH6_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_LPUART1_RX_WKUP    HAL_DMAMUX2_REQ_GEN_LPUART1_RX_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPUART1_TX_WKUP    HAL_DMAMUX2_REQ_GEN_LPUART1_TX_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM2_WKUP        HAL_DMAMUX2_REQ_GEN_LPTIM2_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM2_OUT         HAL_DMAMUX2_REQ_GEN_LPTIM2_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM3_WKUP        HAL_DMAMUX2_REQ_GEN_LPTIM3_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM3_OUT         HAL_DMAMUX2_REQ_GEN_LPTIM3_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM4_WKUP        HAL_DMAMUX2_REQ_GEN_LPTIM4_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_LPTIM5_WKUP        HAL_DMAMUX2_REQ_GEN_LPTIM5_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_I2C4_WKUP          HAL_DMAMUX2_REQ_GEN_I2C4_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_SPI6_WKUP          HAL_DMAMUX2_REQ_GEN_SPI6_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_COMP1_OUT          HAL_DMAMUX2_REQ_GEN_COMP1_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_COMP2_OUT          HAL_DMAMUX2_REQ_GEN_COMP2_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_RTC_WKUP           HAL_DMAMUX2_REQ_GEN_RTC_WKUP
S#define HAL_DMAMUX2_REQUEST_GEN_EXTI0              HAL_DMAMUX2_REQ_GEN_EXTI0
S#define HAL_DMAMUX2_REQUEST_GEN_EXTI2              HAL_DMAMUX2_REQ_GEN_EXTI2
S#define HAL_DMAMUX2_REQUEST_GEN_I2C4_IT_EVT        HAL_DMAMUX2_REQ_GEN_I2C4_IT_EVT
S#define HAL_DMAMUX2_REQUEST_GEN_SPI6_IT            HAL_DMAMUX2_REQ_GEN_SPI6_IT
S#define HAL_DMAMUX2_REQUEST_GEN_LPUART1_TX_IT      HAL_DMAMUX2_REQ_GEN_LPUART1_TX_IT
S#define HAL_DMAMUX2_REQUEST_GEN_LPUART1_RX_IT      HAL_DMAMUX2_REQ_GEN_LPUART1_RX_IT
S#define HAL_DMAMUX2_REQUEST_GEN_ADC3_IT            HAL_DMAMUX2_REQ_GEN_ADC3_IT
S#define HAL_DMAMUX2_REQUEST_GEN_ADC3_AWD1_OUT      HAL_DMAMUX2_REQ_GEN_ADC3_AWD1_OUT
S#define HAL_DMAMUX2_REQUEST_GEN_BDMA_CH0_IT        HAL_DMAMUX2_REQ_GEN_BDMA_CH0_IT
S#define HAL_DMAMUX2_REQUEST_GEN_BDMA_CH1_IT        HAL_DMAMUX2_REQ_GEN_BDMA_CH1_IT
S
S#define HAL_DMAMUX_REQUEST_GEN_NO_EVENT            HAL_DMAMUX_REQ_GEN_NO_EVENT
S#define HAL_DMAMUX_REQUEST_GEN_RISING              HAL_DMAMUX_REQ_GEN_RISING
S#define HAL_DMAMUX_REQUEST_GEN_FALLING             HAL_DMAMUX_REQ_GEN_FALLING
S#define HAL_DMAMUX_REQUEST_GEN_RISING_FALLING      HAL_DMAMUX_REQ_GEN_RISING_FALLING
S
S#define DFSDM_FILTER_EXT_TRIG_LPTIM1               DFSDM_FILTER_EXT_TRIG_LPTIM1_OUT
S#define DFSDM_FILTER_EXT_TRIG_LPTIM2               DFSDM_FILTER_EXT_TRIG_LPTIM2_OUT
S#define DFSDM_FILTER_EXT_TRIG_LPTIM3               DFSDM_FILTER_EXT_TRIG_LPTIM3_OUT
S
N#endif /* STM32H7 */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Defines HAL FLASH Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define TYPEPROGRAM_BYTE              FLASH_TYPEPROGRAM_BYTE
N#define TYPEPROGRAM_HALFWORD          FLASH_TYPEPROGRAM_HALFWORD
N#define TYPEPROGRAM_WORD              FLASH_TYPEPROGRAM_WORD
N#define TYPEPROGRAM_DOUBLEWORD        FLASH_TYPEPROGRAM_DOUBLEWORD
N#define TYPEERASE_SECTORS             FLASH_TYPEERASE_SECTORS
N#define TYPEERASE_PAGES               FLASH_TYPEERASE_PAGES
N#define TYPEERASE_PAGEERASE           FLASH_TYPEERASE_PAGES
N#define TYPEERASE_MASSERASE           FLASH_TYPEERASE_MASSERASE
N#define WRPSTATE_DISABLE              OB_WRPSTATE_DISABLE
N#define WRPSTATE_ENABLE               OB_WRPSTATE_ENABLE
N#define HAL_FLASH_TIMEOUT_VALUE       FLASH_TIMEOUT_VALUE
N#define OBEX_PCROP                    OPTIONBYTE_PCROP
N#define OBEX_BOOTCONFIG               OPTIONBYTE_BOOTCONFIG
N#define PCROPSTATE_DISABLE            OB_PCROP_STATE_DISABLE
N#define PCROPSTATE_ENABLE             OB_PCROP_STATE_ENABLE
N#define TYPEERASEDATA_BYTE            FLASH_TYPEERASEDATA_BYTE
N#define TYPEERASEDATA_HALFWORD        FLASH_TYPEERASEDATA_HALFWORD
N#define TYPEERASEDATA_WORD            FLASH_TYPEERASEDATA_WORD
N#define TYPEPROGRAMDATA_BYTE          FLASH_TYPEPROGRAMDATA_BYTE
N#define TYPEPROGRAMDATA_HALFWORD      FLASH_TYPEPROGRAMDATA_HALFWORD
N#define TYPEPROGRAMDATA_WORD          FLASH_TYPEPROGRAMDATA_WORD
N#define TYPEPROGRAMDATA_FASTBYTE      FLASH_TYPEPROGRAMDATA_FASTBYTE
N#define TYPEPROGRAMDATA_FASTHALFWORD  FLASH_TYPEPROGRAMDATA_FASTHALFWORD
N#define TYPEPROGRAMDATA_FASTWORD      FLASH_TYPEPROGRAMDATA_FASTWORD
N#define PAGESIZE                      FLASH_PAGE_SIZE
N#define TYPEPROGRAM_FASTBYTE          FLASH_TYPEPROGRAM_BYTE
N#define TYPEPROGRAM_FASTHALFWORD      FLASH_TYPEPROGRAM_HALFWORD
N#define TYPEPROGRAM_FASTWORD          FLASH_TYPEPROGRAM_WORD
N#define VOLTAGE_RANGE_1               FLASH_VOLTAGE_RANGE_1
N#define VOLTAGE_RANGE_2               FLASH_VOLTAGE_RANGE_2
N#define VOLTAGE_RANGE_3               FLASH_VOLTAGE_RANGE_3
N#define VOLTAGE_RANGE_4               FLASH_VOLTAGE_RANGE_4
N#define TYPEPROGRAM_FAST              FLASH_TYPEPROGRAM_FAST
N#define TYPEPROGRAM_FAST_AND_LAST     FLASH_TYPEPROGRAM_FAST_AND_LAST
N#define WRPAREA_BANK1_AREAA           OB_WRPAREA_BANK1_AREAA
N#define WRPAREA_BANK1_AREAB           OB_WRPAREA_BANK1_AREAB
N#define WRPAREA_BANK2_AREAA           OB_WRPAREA_BANK2_AREAA
N#define WRPAREA_BANK2_AREAB           OB_WRPAREA_BANK2_AREAB
N#define IWDG_STDBY_FREEZE             OB_IWDG_STDBY_FREEZE
N#define IWDG_STDBY_ACTIVE             OB_IWDG_STDBY_RUN
N#define IWDG_STOP_FREEZE              OB_IWDG_STOP_FREEZE
N#define IWDG_STOP_ACTIVE              OB_IWDG_STOP_RUN
N#define FLASH_ERROR_NONE              HAL_FLASH_ERROR_NONE
N#define FLASH_ERROR_RD                HAL_FLASH_ERROR_RD
N#define FLASH_ERROR_PG                HAL_FLASH_ERROR_PROG
N#define FLASH_ERROR_PGP               HAL_FLASH_ERROR_PGS
N#define FLASH_ERROR_WRP               HAL_FLASH_ERROR_WRP
N#define FLASH_ERROR_OPTV              HAL_FLASH_ERROR_OPTV
N#define FLASH_ERROR_OPTVUSR           HAL_FLASH_ERROR_OPTVUSR
N#define FLASH_ERROR_PROG              HAL_FLASH_ERROR_PROG
N#define FLASH_ERROR_OP                HAL_FLASH_ERROR_OPERATION
N#define FLASH_ERROR_PGA               HAL_FLASH_ERROR_PGA
N#define FLASH_ERROR_SIZE              HAL_FLASH_ERROR_SIZE
N#define FLASH_ERROR_SIZ               HAL_FLASH_ERROR_SIZE
N#define FLASH_ERROR_PGS               HAL_FLASH_ERROR_PGS
N#define FLASH_ERROR_MIS               HAL_FLASH_ERROR_MIS
N#define FLASH_ERROR_FAST              HAL_FLASH_ERROR_FAST
N#define FLASH_ERROR_FWWERR            HAL_FLASH_ERROR_FWWERR
N#define FLASH_ERROR_NOTZERO           HAL_FLASH_ERROR_NOTZERO
N#define FLASH_ERROR_OPERATION         HAL_FLASH_ERROR_OPERATION
N#define FLASH_ERROR_ERS               HAL_FLASH_ERROR_ERS
N#define OB_WDG_SW                     OB_IWDG_SW
N#define OB_WDG_HW                     OB_IWDG_HW
N#define OB_SDADC12_VDD_MONITOR_SET    OB_SDACD_VDD_MONITOR_SET
N#define OB_SDADC12_VDD_MONITOR_RESET  OB_SDACD_VDD_MONITOR_RESET
N#define OB_RAM_PARITY_CHECK_SET       OB_SRAM_PARITY_SET
N#define OB_RAM_PARITY_CHECK_RESET     OB_SRAM_PARITY_RESET
N#define IS_OB_SDADC12_VDD_MONITOR     IS_OB_SDACD_VDD_MONITOR
N#define OB_RDP_LEVEL0                 OB_RDP_LEVEL_0
N#define OB_RDP_LEVEL1                 OB_RDP_LEVEL_1
N#define OB_RDP_LEVEL2                 OB_RDP_LEVEL_2
N#if defined(STM32G0)
X#if 0L
S#define OB_BOOT_LOCK_DISABLE          OB_BOOT_ENTRY_FORCED_NONE
S#define OB_BOOT_LOCK_ENABLE           OB_BOOT_ENTRY_FORCED_FLASH
N#else
N#define OB_BOOT_ENTRY_FORCED_NONE     OB_BOOT_LOCK_DISABLE
N#define OB_BOOT_ENTRY_FORCED_FLASH    OB_BOOT_LOCK_ENABLE
N#endif
N#if defined(STM32H7)
X#if 0L
S#define FLASH_FLAG_SNECCE_BANK1RR FLASH_FLAG_SNECCERR_BANK1
S#define FLASH_FLAG_DBECCE_BANK1RR FLASH_FLAG_DBECCERR_BANK1
S#define FLASH_FLAG_STRBER_BANK1R  FLASH_FLAG_STRBERR_BANK1
S#define FLASH_FLAG_SNECCE_BANK2RR FLASH_FLAG_SNECCERR_BANK2
S#define FLASH_FLAG_DBECCE_BANK2RR FLASH_FLAG_DBECCERR_BANK2
S#define FLASH_FLAG_STRBER_BANK2R  FLASH_FLAG_STRBERR_BANK2
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_JPEG_Aliased_Macros HAL JPEG Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#if defined(STM32H7)
X#if 0L
S#define __HAL_RCC_JPEG_CLK_ENABLE               __HAL_RCC_JPGDECEN_CLK_ENABLE
S#define __HAL_RCC_JPEG_CLK_DISABLE              __HAL_RCC_JPGDECEN_CLK_DISABLE
S#define __HAL_RCC_JPEG_FORCE_RESET              __HAL_RCC_JPGDECRST_FORCE_RESET
S#define __HAL_RCC_JPEG_RELEASE_RESET            __HAL_RCC_JPGDECRST_RELEASE_RESET
S#define __HAL_RCC_JPEG_CLK_SLEEP_ENABLE         __HAL_RCC_JPGDEC_CLK_SLEEP_ENABLE
S#define __HAL_RCC_JPEG_CLK_SLEEP_DISABLE        __HAL_RCC_JPGDEC_CLK_SLEEP_DISABLE
N#endif /* STM32H7 */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SYSCFG_Aliased_Defines HAL SYSCFG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PA9    I2C_FASTMODEPLUS_PA9
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PA10   I2C_FASTMODEPLUS_PA10
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB6    I2C_FASTMODEPLUS_PB6
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB7    I2C_FASTMODEPLUS_PB7
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB8    I2C_FASTMODEPLUS_PB8
N#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB9    I2C_FASTMODEPLUS_PB9
N#define HAL_SYSCFG_FASTMODEPLUS_I2C1       I2C_FASTMODEPLUS_I2C1
N#define HAL_SYSCFG_FASTMODEPLUS_I2C2       I2C_FASTMODEPLUS_I2C2
N#define HAL_SYSCFG_FASTMODEPLUS_I2C3       I2C_FASTMODEPLUS_I2C3
N/**
N  * @}
N  */
N
N
N/** @defgroup LL_FMC_Aliased_Defines LL FMC Aliased Defines maintained for compatibility purpose
N  * @{
N  */
N#if defined(STM32L4) || defined(STM32F7) || defined(STM32H7)
X#if 0L || 0L || 0L
S#define FMC_NAND_PCC_WAIT_FEATURE_DISABLE       FMC_NAND_WAIT_FEATURE_DISABLE
S#define FMC_NAND_PCC_WAIT_FEATURE_ENABLE        FMC_NAND_WAIT_FEATURE_ENABLE
S#define FMC_NAND_PCC_MEM_BUS_WIDTH_8            FMC_NAND_MEM_BUS_WIDTH_8
S#define FMC_NAND_PCC_MEM_BUS_WIDTH_16           FMC_NAND_MEM_BUS_WIDTH_16
N#elif defined(STM32F1) || defined(STM32F2) || defined(STM32F3) || defined(STM32F4)
X#elif 0L || 0L || 0L || 1L
N#define FMC_NAND_WAIT_FEATURE_DISABLE           FMC_NAND_PCC_WAIT_FEATURE_DISABLE
N#define FMC_NAND_WAIT_FEATURE_ENABLE            FMC_NAND_PCC_WAIT_FEATURE_ENABLE
N#define FMC_NAND_MEM_BUS_WIDTH_8                FMC_NAND_PCC_MEM_BUS_WIDTH_8
N#define FMC_NAND_MEM_BUS_WIDTH_16               FMC_NAND_PCC_MEM_BUS_WIDTH_16
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup LL_FSMC_Aliased_Defines LL FSMC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define FSMC_NORSRAM_TYPEDEF                      FSMC_NORSRAM_TypeDef
N#define FSMC_NORSRAM_EXTENDED_TYPEDEF             FSMC_NORSRAM_EXTENDED_TypeDef
N/**
N  * @}
N  */
N
N/** @defgroup HAL_GPIO_Aliased_Macros HAL GPIO Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define GET_GPIO_SOURCE                           GPIO_GET_INDEX
N#define GET_GPIO_INDEX                            GPIO_GET_INDEX
N
N#if defined(STM32F4)
X#if 1L
N#define GPIO_AF12_SDMMC                           GPIO_AF12_SDIO
N#define GPIO_AF12_SDMMC1                          GPIO_AF12_SDIO
N#endif
N
N#if defined(STM32F7)
X#if 0L
S#define GPIO_AF12_SDIO                            GPIO_AF12_SDMMC1
S#define GPIO_AF12_SDMMC                           GPIO_AF12_SDMMC1
N#endif
N
N#if defined(STM32L4)
X#if 0L
S#define GPIO_AF12_SDIO                            GPIO_AF12_SDMMC1
S#define GPIO_AF12_SDMMC                           GPIO_AF12_SDMMC1
N#endif
N
N#if defined(STM32H7)
X#if 0L
S#define GPIO_AF7_SDIO1                            GPIO_AF7_SDMMC1
S#define GPIO_AF8_SDIO1                            GPIO_AF8_SDMMC1
S#define GPIO_AF12_SDIO1                           GPIO_AF12_SDMMC1
S#define GPIO_AF9_SDIO2                            GPIO_AF9_SDMMC2
S#define GPIO_AF10_SDIO2                           GPIO_AF10_SDMMC2
S#define GPIO_AF11_SDIO2                           GPIO_AF11_SDMMC2
N#endif
N
N#define GPIO_AF0_LPTIM                            GPIO_AF0_LPTIM1
N#define GPIO_AF1_LPTIM                            GPIO_AF1_LPTIM1
N#define GPIO_AF2_LPTIM                            GPIO_AF2_LPTIM1
N
N#if defined(STM32L0) || defined(STM32L4) || defined(STM32F4) || defined(STM32F2) || defined(STM32F7) || defined(STM32H7)
X#if 0L || 0L || 1L || 0L || 0L || 0L
N#define  GPIO_SPEED_LOW                           GPIO_SPEED_FREQ_LOW
N#define  GPIO_SPEED_MEDIUM                        GPIO_SPEED_FREQ_MEDIUM
N#define  GPIO_SPEED_FAST                          GPIO_SPEED_FREQ_HIGH
N#define  GPIO_SPEED_HIGH                          GPIO_SPEED_FREQ_VERY_HIGH
N#endif /* STM32L0 || STM32L4 || STM32F4 || STM32F2 || STM32F7 || STM32H7*/
N
N#if defined(STM32L1)
X#if 0L
S #define  GPIO_SPEED_VERY_LOW    GPIO_SPEED_FREQ_LOW
S #define  GPIO_SPEED_LOW         GPIO_SPEED_FREQ_MEDIUM
S #define  GPIO_SPEED_MEDIUM      GPIO_SPEED_FREQ_HIGH
S #define  GPIO_SPEED_HIGH        GPIO_SPEED_FREQ_VERY_HIGH
N#endif /* STM32L1 */
N
N#if defined(STM32F0) || defined(STM32F3) || defined(STM32F1)
X#if 0L || 0L || 0L
S #define  GPIO_SPEED_LOW    GPIO_SPEED_FREQ_LOW
S #define  GPIO_SPEED_MEDIUM GPIO_SPEED_FREQ_MEDIUM
S #define  GPIO_SPEED_HIGH   GPIO_SPEED_FREQ_HIGH
N#endif /* STM32F0 || STM32F3 || STM32F1 */
N
N#define GPIO_AF6_DFSDM                            GPIO_AF6_DFSDM1
N/**
N  * @}
N  */
N
N/** @defgroup HAL_HRTIM_Aliased_Macros HAL HRTIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define HRTIM_TIMDELAYEDPROTECTION_DISABLED           HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DISABLED
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV68  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV68     HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV6
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_DEEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_DEEV7
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_DEEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_DEEV7
N#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV79  HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV7
N#define HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV79     HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV7
N
N#define __HAL_HRTIM_SetCounter        __HAL_HRTIM_SETCOUNTER
N#define __HAL_HRTIM_GetCounter        __HAL_HRTIM_GETCOUNTER
N#define __HAL_HRTIM_SetPeriod         __HAL_HRTIM_SETPERIOD
N#define __HAL_HRTIM_GetPeriod         __HAL_HRTIM_GETPERIOD
N#define __HAL_HRTIM_SetClockPrescaler __HAL_HRTIM_SETCLOCKPRESCALER
N#define __HAL_HRTIM_GetClockPrescaler __HAL_HRTIM_GETCLOCKPRESCALER
N#define __HAL_HRTIM_SetCompare        __HAL_HRTIM_SETCOMPARE
N#define __HAL_HRTIM_GetCompare        __HAL_HRTIM_GETCOMPARE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2C_Aliased_Defines HAL I2C Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define I2C_DUALADDRESS_DISABLED                I2C_DUALADDRESS_DISABLE
N#define I2C_DUALADDRESS_ENABLED                 I2C_DUALADDRESS_ENABLE
N#define I2C_GENERALCALL_DISABLED                I2C_GENERALCALL_DISABLE
N#define I2C_GENERALCALL_ENABLED                 I2C_GENERALCALL_ENABLE
N#define I2C_NOSTRETCH_DISABLED                  I2C_NOSTRETCH_DISABLE
N#define I2C_NOSTRETCH_ENABLED                   I2C_NOSTRETCH_ENABLE
N#define I2C_ANALOGFILTER_ENABLED                I2C_ANALOGFILTER_ENABLE
N#define I2C_ANALOGFILTER_DISABLED               I2C_ANALOGFILTER_DISABLE
N#if defined(STM32F0) || defined(STM32F1) || defined(STM32F3) || defined(STM32G0) || defined(STM32L4) || defined(STM32L1) || defined(STM32F7)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L
S#define HAL_I2C_STATE_MEM_BUSY_TX               HAL_I2C_STATE_BUSY_TX
S#define HAL_I2C_STATE_MEM_BUSY_RX               HAL_I2C_STATE_BUSY_RX
S#define HAL_I2C_STATE_MASTER_BUSY_TX            HAL_I2C_STATE_BUSY_TX
S#define HAL_I2C_STATE_MASTER_BUSY_RX            HAL_I2C_STATE_BUSY_RX
S#define HAL_I2C_STATE_SLAVE_BUSY_TX             HAL_I2C_STATE_BUSY_TX
S#define HAL_I2C_STATE_SLAVE_BUSY_RX             HAL_I2C_STATE_BUSY_RX
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IRDA_Aliased_Defines HAL IRDA Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define IRDA_ONE_BIT_SAMPLE_DISABLED            IRDA_ONE_BIT_SAMPLE_DISABLE
N#define IRDA_ONE_BIT_SAMPLE_ENABLED             IRDA_ONE_BIT_SAMPLE_ENABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IWDG_Aliased_Defines HAL IWDG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define KR_KEY_RELOAD                   IWDG_KEY_RELOAD
N#define KR_KEY_ENABLE                   IWDG_KEY_ENABLE
N#define KR_KEY_EWA                      IWDG_KEY_WRITE_ACCESS_ENABLE
N#define KR_KEY_DWA                      IWDG_KEY_WRITE_ACCESS_DISABLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_LPTIM_Aliased_Defines HAL LPTIM Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define LPTIM_CLOCKSAMPLETIME_DIRECTTRANSISTION LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION
N#define LPTIM_CLOCKSAMPLETIME_2TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_2TRANSITIONS
N#define LPTIM_CLOCKSAMPLETIME_4TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_4TRANSITIONS
N#define LPTIM_CLOCKSAMPLETIME_8TRANSISTIONS     LPTIM_CLOCKSAMPLETIME_8TRANSITIONS
N
N#define LPTIM_CLOCKPOLARITY_RISINGEDGE          LPTIM_CLOCKPOLARITY_RISING
N#define LPTIM_CLOCKPOLARITY_FALLINGEDGE         LPTIM_CLOCKPOLARITY_FALLING
N#define LPTIM_CLOCKPOLARITY_BOTHEDGES           LPTIM_CLOCKPOLARITY_RISING_FALLING
N
N#define LPTIM_TRIGSAMPLETIME_DIRECTTRANSISTION  LPTIM_TRIGSAMPLETIME_DIRECTTRANSITION
N#define LPTIM_TRIGSAMPLETIME_2TRANSISTIONS      LPTIM_TRIGSAMPLETIME_2TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_4TRANSISTIONS      LPTIM_TRIGSAMPLETIME_4TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_8TRANSISTIONS      LPTIM_TRIGSAMPLETIME_8TRANSITIONS
N
N/* The following 3 definition have also been present in a temporary version of lptim.h */
N/* They need to be renamed also to the right name, just in case */
N#define LPTIM_TRIGSAMPLETIME_2TRANSITION        LPTIM_TRIGSAMPLETIME_2TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_4TRANSITION        LPTIM_TRIGSAMPLETIME_4TRANSITIONS
N#define LPTIM_TRIGSAMPLETIME_8TRANSITION        LPTIM_TRIGSAMPLETIME_8TRANSITIONS
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_NAND_Aliased_Defines HAL NAND Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_NAND_Read_Page              HAL_NAND_Read_Page_8b
N#define HAL_NAND_Write_Page             HAL_NAND_Write_Page_8b
N#define HAL_NAND_Read_SpareArea         HAL_NAND_Read_SpareArea_8b
N#define HAL_NAND_Write_SpareArea        HAL_NAND_Write_SpareArea_8b
N
N#define NAND_AddressTypedef             NAND_AddressTypeDef
N
N#define __ARRAY_ADDRESS                 ARRAY_ADDRESS
N#define __ADDR_1st_CYCLE                ADDR_1ST_CYCLE
N#define __ADDR_2nd_CYCLE                ADDR_2ND_CYCLE
N#define __ADDR_3rd_CYCLE                ADDR_3RD_CYCLE
N#define __ADDR_4th_CYCLE                ADDR_4TH_CYCLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_NOR_Aliased_Defines HAL NOR Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define NOR_StatusTypedef              HAL_NOR_StatusTypeDef
N#define NOR_SUCCESS                    HAL_NOR_STATUS_SUCCESS
N#define NOR_ONGOING                    HAL_NOR_STATUS_ONGOING
N#define NOR_ERROR                      HAL_NOR_STATUS_ERROR
N#define NOR_TIMEOUT                    HAL_NOR_STATUS_TIMEOUT
N
N#define __NOR_WRITE                    NOR_WRITE
N#define __NOR_ADDR_SHIFT               NOR_ADDR_SHIFT
N/**
N  * @}
N  */
N
N/** @defgroup HAL_OPAMP_Aliased_Defines HAL OPAMP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define OPAMP_NONINVERTINGINPUT_VP0           OPAMP_NONINVERTINGINPUT_IO0
N#define OPAMP_NONINVERTINGINPUT_VP1           OPAMP_NONINVERTINGINPUT_IO1
N#define OPAMP_NONINVERTINGINPUT_VP2           OPAMP_NONINVERTINGINPUT_IO2
N#define OPAMP_NONINVERTINGINPUT_VP3           OPAMP_NONINVERTINGINPUT_IO3
N
N#define OPAMP_SEC_NONINVERTINGINPUT_VP0       OPAMP_SEC_NONINVERTINGINPUT_IO0
N#define OPAMP_SEC_NONINVERTINGINPUT_VP1       OPAMP_SEC_NONINVERTINGINPUT_IO1
N#define OPAMP_SEC_NONINVERTINGINPUT_VP2       OPAMP_SEC_NONINVERTINGINPUT_IO2
N#define OPAMP_SEC_NONINVERTINGINPUT_VP3       OPAMP_SEC_NONINVERTINGINPUT_IO3
N
N#define OPAMP_INVERTINGINPUT_VM0              OPAMP_INVERTINGINPUT_IO0
N#define OPAMP_INVERTINGINPUT_VM1              OPAMP_INVERTINGINPUT_IO1
N
N#define IOPAMP_INVERTINGINPUT_VM0             OPAMP_INVERTINGINPUT_IO0
N#define IOPAMP_INVERTINGINPUT_VM1             OPAMP_INVERTINGINPUT_IO1
N
N#define OPAMP_SEC_INVERTINGINPUT_VM0          OPAMP_SEC_INVERTINGINPUT_IO0
N#define OPAMP_SEC_INVERTINGINPUT_VM1          OPAMP_SEC_INVERTINGINPUT_IO1
N
N#define OPAMP_INVERTINGINPUT_VINM             OPAMP_SEC_INVERTINGINPUT_IO1
N
N#define OPAMP_PGACONNECT_NO                   OPAMP_PGA_CONNECT_INVERTINGINPUT_NO
N#define OPAMP_PGACONNECT_VM0                  OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0
N#define OPAMP_PGACONNECT_VM1                  OPAMP_PGA_CONNECT_INVERTINGINPUT_IO1
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2S_Aliased_Defines HAL I2S Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define I2S_STANDARD_PHILLIPS      I2S_STANDARD_PHILIPS
N
N#if defined(STM32H7)
X#if 0L
S  #define I2S_IT_TXE               I2S_IT_TXP
S  #define I2S_IT_RXNE              I2S_IT_RXP
S
S  #define I2S_FLAG_TXE             I2S_FLAG_TXP
S  #define I2S_FLAG_RXNE            I2S_FLAG_RXP
S  #define I2S_FLAG_FRE             I2S_FLAG_TIFRE
N#endif
N
N#if defined(STM32F7)
X#if 0L
S  #define I2S_CLOCK_SYSCLK           I2S_CLOCK_PLL
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_PCCARD_Aliased_Defines HAL PCCARD Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N/* Compact Flash-ATA registers description */
N#define CF_DATA                       ATA_DATA
N#define CF_SECTOR_COUNT               ATA_SECTOR_COUNT
N#define CF_SECTOR_NUMBER              ATA_SECTOR_NUMBER
N#define CF_CYLINDER_LOW               ATA_CYLINDER_LOW
N#define CF_CYLINDER_HIGH              ATA_CYLINDER_HIGH
N#define CF_CARD_HEAD                  ATA_CARD_HEAD
N#define CF_STATUS_CMD                 ATA_STATUS_CMD
N#define CF_STATUS_CMD_ALTERNATE       ATA_STATUS_CMD_ALTERNATE
N#define CF_COMMON_DATA_AREA           ATA_COMMON_DATA_AREA
N
N/* Compact Flash-ATA commands */
N#define CF_READ_SECTOR_CMD            ATA_READ_SECTOR_CMD
N#define CF_WRITE_SECTOR_CMD           ATA_WRITE_SECTOR_CMD
N#define CF_ERASE_SECTOR_CMD           ATA_ERASE_SECTOR_CMD
N#define CF_IDENTIFY_CMD               ATA_IDENTIFY_CMD
N
N#define PCCARD_StatusTypedef          HAL_PCCARD_StatusTypeDef
N#define PCCARD_SUCCESS                HAL_PCCARD_STATUS_SUCCESS
N#define PCCARD_ONGOING                HAL_PCCARD_STATUS_ONGOING
N#define PCCARD_ERROR                  HAL_PCCARD_STATUS_ERROR
N#define PCCARD_TIMEOUT                HAL_PCCARD_STATUS_TIMEOUT
N/**
N  * @}
N  */
N
N/** @defgroup HAL_RTC_Aliased_Defines HAL RTC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define FORMAT_BIN                  RTC_FORMAT_BIN
N#define FORMAT_BCD                  RTC_FORMAT_BCD
N
N#define RTC_ALARMSUBSECONDMASK_None     RTC_ALARMSUBSECONDMASK_NONE
N#define RTC_TAMPERERASEBACKUP_DISABLED  RTC_TAMPER_ERASE_BACKUP_DISABLE
N#define RTC_TAMPERMASK_FLAG_DISABLED    RTC_TAMPERMASK_FLAG_DISABLE
N#define RTC_TAMPERMASK_FLAG_ENABLED     RTC_TAMPERMASK_FLAG_ENABLE
N
N#define RTC_MASKTAMPERFLAG_DISABLED     RTC_TAMPERMASK_FLAG_DISABLE
N#define RTC_MASKTAMPERFLAG_ENABLED      RTC_TAMPERMASK_FLAG_ENABLE
N#define RTC_TAMPERERASEBACKUP_ENABLED   RTC_TAMPER_ERASE_BACKUP_ENABLE
N#define RTC_TAMPER1_2_INTERRUPT         RTC_ALL_TAMPER_INTERRUPT
N#define RTC_TAMPER1_2_3_INTERRUPT       RTC_ALL_TAMPER_INTERRUPT
N
N#define RTC_TIMESTAMPPIN_PC13  RTC_TIMESTAMPPIN_DEFAULT
N#define RTC_TIMESTAMPPIN_PA0 RTC_TIMESTAMPPIN_POS1
N#define RTC_TIMESTAMPPIN_PI8 RTC_TIMESTAMPPIN_POS1
N#define RTC_TIMESTAMPPIN_PC1   RTC_TIMESTAMPPIN_POS2
N
N#define RTC_OUTPUT_REMAP_PC13  RTC_OUTPUT_REMAP_NONE
N#define RTC_OUTPUT_REMAP_PB14  RTC_OUTPUT_REMAP_POS1
N#define RTC_OUTPUT_REMAP_PB2   RTC_OUTPUT_REMAP_POS1
N
N#define RTC_TAMPERPIN_PC13 RTC_TAMPERPIN_DEFAULT
N#define RTC_TAMPERPIN_PA0  RTC_TAMPERPIN_POS1
N#define RTC_TAMPERPIN_PI8  RTC_TAMPERPIN_POS1
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_SMARTCARD_Aliased_Defines HAL SMARTCARD Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SMARTCARD_NACK_ENABLED                  SMARTCARD_NACK_ENABLE
N#define SMARTCARD_NACK_DISABLED                 SMARTCARD_NACK_DISABLE
N
N#define SMARTCARD_ONEBIT_SAMPLING_DISABLED      SMARTCARD_ONE_BIT_SAMPLE_DISABLE
N#define SMARTCARD_ONEBIT_SAMPLING_ENABLED       SMARTCARD_ONE_BIT_SAMPLE_ENABLE
N#define SMARTCARD_ONEBIT_SAMPLING_DISABLE       SMARTCARD_ONE_BIT_SAMPLE_DISABLE
N#define SMARTCARD_ONEBIT_SAMPLING_ENABLE        SMARTCARD_ONE_BIT_SAMPLE_ENABLE
N
N#define SMARTCARD_TIMEOUT_DISABLED              SMARTCARD_TIMEOUT_DISABLE
N#define SMARTCARD_TIMEOUT_ENABLED               SMARTCARD_TIMEOUT_ENABLE
N
N#define SMARTCARD_LASTBIT_DISABLED              SMARTCARD_LASTBIT_DISABLE
N#define SMARTCARD_LASTBIT_ENABLED               SMARTCARD_LASTBIT_ENABLE
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_SMBUS_Aliased_Defines HAL SMBUS Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SMBUS_DUALADDRESS_DISABLED      SMBUS_DUALADDRESS_DISABLE
N#define SMBUS_DUALADDRESS_ENABLED       SMBUS_DUALADDRESS_ENABLE
N#define SMBUS_GENERALCALL_DISABLED      SMBUS_GENERALCALL_DISABLE
N#define SMBUS_GENERALCALL_ENABLED       SMBUS_GENERALCALL_ENABLE
N#define SMBUS_NOSTRETCH_DISABLED        SMBUS_NOSTRETCH_DISABLE
N#define SMBUS_NOSTRETCH_ENABLED         SMBUS_NOSTRETCH_ENABLE
N#define SMBUS_ANALOGFILTER_ENABLED      SMBUS_ANALOGFILTER_ENABLE
N#define SMBUS_ANALOGFILTER_DISABLED     SMBUS_ANALOGFILTER_DISABLE
N#define SMBUS_PEC_DISABLED              SMBUS_PEC_DISABLE
N#define SMBUS_PEC_ENABLED               SMBUS_PEC_ENABLE
N#define HAL_SMBUS_STATE_SLAVE_LISTEN    HAL_SMBUS_STATE_LISTEN
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPI_Aliased_Defines HAL SPI Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define SPI_TIMODE_DISABLED             SPI_TIMODE_DISABLE
N#define SPI_TIMODE_ENABLED              SPI_TIMODE_ENABLE
N
N#define SPI_CRCCALCULATION_DISABLED     SPI_CRCCALCULATION_DISABLE
N#define SPI_CRCCALCULATION_ENABLED      SPI_CRCCALCULATION_ENABLE
N
N#define SPI_NSS_PULSE_DISABLED          SPI_NSS_PULSE_DISABLE
N#define SPI_NSS_PULSE_ENABLED           SPI_NSS_PULSE_ENABLE
N
N#if defined(STM32H7)
X#if 0L
S
S #define SPI_FLAG_TXE                    SPI_FLAG_TXP
S #define SPI_FLAG_RXNE                   SPI_FLAG_RXP
S
S #define SPI_IT_TXE                      SPI_IT_TXP
S #define SPI_IT_RXNE                     SPI_IT_RXP
S
S #define SPI_FRLVL_EMPTY                 SPI_RX_FIFO_0PACKET
S #define SPI_FRLVL_QUARTER_FULL          SPI_RX_FIFO_1PACKET
S #define SPI_FRLVL_HALF_FULL             SPI_RX_FIFO_2PACKET
S #define SPI_FRLVL_FULL                  SPI_RX_FIFO_3PACKET
S
N#endif /* STM32H7 */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TIM_Aliased_Defines HAL TIM Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CCER_CCxE_MASK                   TIM_CCER_CCxE_MASK
N#define CCER_CCxNE_MASK                  TIM_CCER_CCxNE_MASK
N
N#define TIM_DMABase_CR1                  TIM_DMABASE_CR1
N#define TIM_DMABase_CR2                  TIM_DMABASE_CR2
N#define TIM_DMABase_SMCR                 TIM_DMABASE_SMCR
N#define TIM_DMABase_DIER                 TIM_DMABASE_DIER
N#define TIM_DMABase_SR                   TIM_DMABASE_SR
N#define TIM_DMABase_EGR                  TIM_DMABASE_EGR
N#define TIM_DMABase_CCMR1                TIM_DMABASE_CCMR1
N#define TIM_DMABase_CCMR2                TIM_DMABASE_CCMR2
N#define TIM_DMABase_CCER                 TIM_DMABASE_CCER
N#define TIM_DMABase_CNT                  TIM_DMABASE_CNT
N#define TIM_DMABase_PSC                  TIM_DMABASE_PSC
N#define TIM_DMABase_ARR                  TIM_DMABASE_ARR
N#define TIM_DMABase_RCR                  TIM_DMABASE_RCR
N#define TIM_DMABase_CCR1                 TIM_DMABASE_CCR1
N#define TIM_DMABase_CCR2                 TIM_DMABASE_CCR2
N#define TIM_DMABase_CCR3                 TIM_DMABASE_CCR3
N#define TIM_DMABase_CCR4                 TIM_DMABASE_CCR4
N#define TIM_DMABase_BDTR                 TIM_DMABASE_BDTR
N#define TIM_DMABase_DCR                  TIM_DMABASE_DCR
N#define TIM_DMABase_DMAR                 TIM_DMABASE_DMAR
N#define TIM_DMABase_OR1                  TIM_DMABASE_OR1
N#define TIM_DMABase_CCMR3                TIM_DMABASE_CCMR3
N#define TIM_DMABase_CCR5                 TIM_DMABASE_CCR5
N#define TIM_DMABase_CCR6                 TIM_DMABASE_CCR6
N#define TIM_DMABase_OR2                  TIM_DMABASE_OR2
N#define TIM_DMABase_OR3                  TIM_DMABASE_OR3
N#define TIM_DMABase_OR                   TIM_DMABASE_OR
N
N#define TIM_EventSource_Update           TIM_EVENTSOURCE_UPDATE
N#define TIM_EventSource_CC1              TIM_EVENTSOURCE_CC1
N#define TIM_EventSource_CC2              TIM_EVENTSOURCE_CC2
N#define TIM_EventSource_CC3              TIM_EVENTSOURCE_CC3
N#define TIM_EventSource_CC4              TIM_EVENTSOURCE_CC4
N#define TIM_EventSource_COM              TIM_EVENTSOURCE_COM
N#define TIM_EventSource_Trigger          TIM_EVENTSOURCE_TRIGGER
N#define TIM_EventSource_Break            TIM_EVENTSOURCE_BREAK
N#define TIM_EventSource_Break2           TIM_EVENTSOURCE_BREAK2
N
N#define TIM_DMABurstLength_1Transfer     TIM_DMABURSTLENGTH_1TRANSFER
N#define TIM_DMABurstLength_2Transfers    TIM_DMABURSTLENGTH_2TRANSFERS
N#define TIM_DMABurstLength_3Transfers    TIM_DMABURSTLENGTH_3TRANSFERS
N#define TIM_DMABurstLength_4Transfers    TIM_DMABURSTLENGTH_4TRANSFERS
N#define TIM_DMABurstLength_5Transfers    TIM_DMABURSTLENGTH_5TRANSFERS
N#define TIM_DMABurstLength_6Transfers    TIM_DMABURSTLENGTH_6TRANSFERS
N#define TIM_DMABurstLength_7Transfers    TIM_DMABURSTLENGTH_7TRANSFERS
N#define TIM_DMABurstLength_8Transfers    TIM_DMABURSTLENGTH_8TRANSFERS
N#define TIM_DMABurstLength_9Transfers    TIM_DMABURSTLENGTH_9TRANSFERS
N#define TIM_DMABurstLength_10Transfers   TIM_DMABURSTLENGTH_10TRANSFERS
N#define TIM_DMABurstLength_11Transfers   TIM_DMABURSTLENGTH_11TRANSFERS
N#define TIM_DMABurstLength_12Transfers   TIM_DMABURSTLENGTH_12TRANSFERS
N#define TIM_DMABurstLength_13Transfers   TIM_DMABURSTLENGTH_13TRANSFERS
N#define TIM_DMABurstLength_14Transfers   TIM_DMABURSTLENGTH_14TRANSFERS
N#define TIM_DMABurstLength_15Transfers   TIM_DMABURSTLENGTH_15TRANSFERS
N#define TIM_DMABurstLength_16Transfers   TIM_DMABURSTLENGTH_16TRANSFERS
N#define TIM_DMABurstLength_17Transfers   TIM_DMABURSTLENGTH_17TRANSFERS
N#define TIM_DMABurstLength_18Transfers   TIM_DMABURSTLENGTH_18TRANSFERS
N
N#if defined(STM32L0)
X#if 0L
S#define TIM22_TI1_GPIO1   TIM22_TI1_GPIO
S#define TIM22_TI1_GPIO2   TIM22_TI1_GPIO
N#endif
N
N#if defined(STM32F3)
X#if 0L
S#define IS_TIM_HALL_INTERFACE_INSTANCE   IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TSC_Aliased_Defines HAL TSC Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define TSC_SYNC_POL_FALL        TSC_SYNC_POLARITY_FALLING
N#define TSC_SYNC_POL_RISE_HIGH   TSC_SYNC_POLARITY_RISING
N/**
N  * @}
N  */
N
N/** @defgroup HAL_UART_Aliased_Defines HAL UART Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define UART_ONEBIT_SAMPLING_DISABLED   UART_ONE_BIT_SAMPLE_DISABLE
N#define UART_ONEBIT_SAMPLING_ENABLED    UART_ONE_BIT_SAMPLE_ENABLE
N#define UART_ONE_BIT_SAMPLE_DISABLED    UART_ONE_BIT_SAMPLE_DISABLE
N#define UART_ONE_BIT_SAMPLE_ENABLED     UART_ONE_BIT_SAMPLE_ENABLE
N
N#define __HAL_UART_ONEBIT_ENABLE        __HAL_UART_ONE_BIT_SAMPLE_ENABLE
N#define __HAL_UART_ONEBIT_DISABLE       __HAL_UART_ONE_BIT_SAMPLE_DISABLE
N
N#define __DIV_SAMPLING16                UART_DIV_SAMPLING16
N#define __DIVMANT_SAMPLING16            UART_DIVMANT_SAMPLING16
N#define __DIVFRAQ_SAMPLING16            UART_DIVFRAQ_SAMPLING16
N#define __UART_BRR_SAMPLING16           UART_BRR_SAMPLING16
N
N#define __DIV_SAMPLING8                 UART_DIV_SAMPLING8
N#define __DIVMANT_SAMPLING8             UART_DIVMANT_SAMPLING8
N#define __DIVFRAQ_SAMPLING8             UART_DIVFRAQ_SAMPLING8
N#define __UART_BRR_SAMPLING8            UART_BRR_SAMPLING8
N
N#define __DIV_LPUART                    UART_DIV_LPUART
N
N#define UART_WAKEUPMETHODE_IDLELINE     UART_WAKEUPMETHOD_IDLELINE
N#define UART_WAKEUPMETHODE_ADDRESSMARK  UART_WAKEUPMETHOD_ADDRESSMARK
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_USART_Aliased_Defines HAL USART Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define USART_CLOCK_DISABLED            USART_CLOCK_DISABLE
N#define USART_CLOCK_ENABLED             USART_CLOCK_ENABLE
N
N#define USARTNACK_ENABLED               USART_NACK_ENABLE
N#define USARTNACK_DISABLED              USART_NACK_DISABLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_WWDG_Aliased_Defines HAL WWDG Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CFR_BASE                    WWDG_CFR_BASE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_CAN_Aliased_Defines HAL CAN Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define CAN_FilterFIFO0             CAN_FILTER_FIFO0
N#define CAN_FilterFIFO1             CAN_FILTER_FIFO1
N#define CAN_IT_RQCP0                CAN_IT_TME
N#define CAN_IT_RQCP1                CAN_IT_TME
N#define CAN_IT_RQCP2                CAN_IT_TME
N#define INAK_TIMEOUT                CAN_TIMEOUT_VALUE
N#define SLAK_TIMEOUT                CAN_TIMEOUT_VALUE
N#define CAN_TXSTATUS_FAILED         ((uint8_t)0x00U)
N#define CAN_TXSTATUS_OK             ((uint8_t)0x01U)
N#define CAN_TXSTATUS_PENDING        ((uint8_t)0x02U)
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_ETH_Aliased_Defines HAL ETH Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N#define VLAN_TAG                ETH_VLAN_TAG
N#define MIN_ETH_PAYLOAD         ETH_MIN_ETH_PAYLOAD
N#define MAX_ETH_PAYLOAD         ETH_MAX_ETH_PAYLOAD
N#define JUMBO_FRAME_PAYLOAD     ETH_JUMBO_FRAME_PAYLOAD
N#define MACMIIAR_CR_MASK        ETH_MACMIIAR_CR_MASK
N#define MACCR_CLEAR_MASK        ETH_MACCR_CLEAR_MASK
N#define MACFCR_CLEAR_MASK       ETH_MACFCR_CLEAR_MASK
N#define DMAOMR_CLEAR_MASK       ETH_DMAOMR_CLEAR_MASK
N
N#define ETH_MMCCR              0x00000100U
N#define ETH_MMCRIR             0x00000104U
N#define ETH_MMCTIR             0x00000108U
N#define ETH_MMCRIMR            0x0000010CU
N#define ETH_MMCTIMR            0x00000110U
N#define ETH_MMCTGFSCCR         0x0000014CU
N#define ETH_MMCTGFMSCCR        0x00000150U
N#define ETH_MMCTGFCR           0x00000168U
N#define ETH_MMCRFCECR          0x00000194U
N#define ETH_MMCRFAECR          0x00000198U
N#define ETH_MMCRGUFCR          0x000001C4U
N
N#define ETH_MAC_TXFIFO_FULL                             0x02000000U  /* Tx FIFO full */
N#define ETH_MAC_TXFIFONOT_EMPTY                         0x01000000U  /* Tx FIFO not empty */
N#define ETH_MAC_TXFIFO_WRITE_ACTIVE                     0x00400000U  /* Tx FIFO write active */
N#define ETH_MAC_TXFIFO_IDLE                             0x00000000U  /* Tx FIFO read status: Idle */
N#define ETH_MAC_TXFIFO_READ                             0x00100000U  /* Tx FIFO read status: Read (transferring data to the MAC transmitter) */
N#define ETH_MAC_TXFIFO_WAITING                          0x00200000U  /* Tx FIFO read status: Waiting for TxStatus from MAC transmitter */
N#define ETH_MAC_TXFIFO_WRITING                          0x00300000U  /* Tx FIFO read status: Writing the received TxStatus or flushing the TxFIFO */
N#define ETH_MAC_TRANSMISSION_PAUSE                      0x00080000U  /* MAC transmitter in pause */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_IDLE            0x00000000U  /* MAC transmit frame controller: Idle */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_WAITING         0x00020000U  /* MAC transmit frame controller: Waiting for Status of previous frame or IFG/backoff period to be over */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_GENRATING_PCF   0x00040000U  /* MAC transmit frame controller: Generating and transmitting a Pause control frame (in full duplex mode) */
N#define ETH_MAC_TRANSMITFRAMECONTROLLER_TRANSFERRING    0x00060000U  /* MAC transmit frame controller: Transferring input frame for transmission */
N#define ETH_MAC_MII_TRANSMIT_ACTIVE           0x00010000U  /* MAC MII transmit engine active */
N#define ETH_MAC_RXFIFO_EMPTY                  0x00000000U  /* Rx FIFO fill level: empty */
N#define ETH_MAC_RXFIFO_BELOW_THRESHOLD        0x00000100U  /* Rx FIFO fill level: fill-level below flow-control de-activate threshold */
N#define ETH_MAC_RXFIFO_ABOVE_THRESHOLD        0x00000200U  /* Rx FIFO fill level: fill-level above flow-control activate threshold */
N#define ETH_MAC_RXFIFO_FULL                   0x00000300U  /* Rx FIFO fill level: full */
N#if defined(STM32F1)
X#if 0L
N#else
N#define ETH_MAC_READCONTROLLER_IDLE           0x00000000U  /* Rx FIFO read controller IDLE state */
N#define ETH_MAC_READCONTROLLER_READING_DATA   0x00000020U  /* Rx FIFO read controller Reading frame data */
N#define ETH_MAC_READCONTROLLER_READING_STATUS 0x00000040U  /* Rx FIFO read controller Reading frame status (or time-stamp) */
N#endif
N#define ETH_MAC_READCONTROLLER_FLUSHING       0x00000060U  /* Rx FIFO read controller Flushing the frame data and status */
N#define ETH_MAC_RXFIFO_WRITE_ACTIVE           0x00000010U  /* Rx FIFO write controller active */
N#define ETH_MAC_SMALL_FIFO_NOTACTIVE          0x00000000U  /* MAC small FIFO read / write controllers not active */
N#define ETH_MAC_SMALL_FIFO_READ_ACTIVE        0x00000002U  /* MAC small FIFO read controller active */
N#define ETH_MAC_SMALL_FIFO_WRITE_ACTIVE       0x00000004U  /* MAC small FIFO write controller active */
N#define ETH_MAC_SMALL_FIFO_RW_ACTIVE          0x00000006U  /* MAC small FIFO read / write controllers active */
N#define ETH_MAC_MII_RECEIVE_PROTOCOL_ACTIVE   0x00000001U  /* MAC MII receive protocol engine active */
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DCMI_Aliased_Defines HAL DCMI Aliased Defines maintained for legacy purpose
N  * @{
N  */
N#define HAL_DCMI_ERROR_OVF      HAL_DCMI_ERROR_OVR
N#define DCMI_IT_OVF             DCMI_IT_OVR
N#define DCMI_FLAG_OVFRI         DCMI_FLAG_OVRRI
N#define DCMI_FLAG_OVFMI         DCMI_FLAG_OVRMI
N
N#define HAL_DCMI_ConfigCROP     HAL_DCMI_ConfigCrop
N#define HAL_DCMI_EnableCROP     HAL_DCMI_EnableCrop
N#define HAL_DCMI_DisableCROP    HAL_DCMI_DisableCrop
N
N/**
N  * @}
N  */
N
N#if defined(STM32L4) || defined(STM32F7) || defined(STM32F427xx) || defined(STM32F437xx) \
N  || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx) \
N  || defined(STM32H7)
X#if 0L || 0L || 0L || 0L   || 0L || 0L || 0L || 0L   || 0L
S/** @defgroup HAL_DMA2D_Aliased_Defines HAL DMA2D Aliased Defines maintained for legacy purpose
S  * @{
S  */
S#define DMA2D_ARGB8888          DMA2D_OUTPUT_ARGB8888
S#define DMA2D_RGB888            DMA2D_OUTPUT_RGB888
S#define DMA2D_RGB565            DMA2D_OUTPUT_RGB565
S#define DMA2D_ARGB1555          DMA2D_OUTPUT_ARGB1555
S#define DMA2D_ARGB4444          DMA2D_OUTPUT_ARGB4444
S
S#define CM_ARGB8888             DMA2D_INPUT_ARGB8888
S#define CM_RGB888               DMA2D_INPUT_RGB888
S#define CM_RGB565               DMA2D_INPUT_RGB565
S#define CM_ARGB1555             DMA2D_INPUT_ARGB1555
S#define CM_ARGB4444             DMA2D_INPUT_ARGB4444
S#define CM_L8                   DMA2D_INPUT_L8
S#define CM_AL44                 DMA2D_INPUT_AL44
S#define CM_AL88                 DMA2D_INPUT_AL88
S#define CM_L4                   DMA2D_INPUT_L4
S#define CM_A8                   DMA2D_INPUT_A8
S#define CM_A4                   DMA2D_INPUT_A4
S/**
S  * @}
S  */
N#endif  /* STM32L4 ||  STM32F7 ||  STM32F4 ||  STM32H7 */
N
N/** @defgroup HAL_PPP_Aliased_Defines HAL PPP Aliased Defines maintained for legacy purpose
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @defgroup HAL_CRYP_Aliased_Functions HAL CRYP Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_CRYP_ComputationCpltCallback     HAL_CRYPEx_ComputationCpltCallback
N/**
N  * @}
N  */
N
N/** @defgroup HAL_HASH_Aliased_Functions HAL HASH Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_HASH_STATETypeDef        HAL_HASH_StateTypeDef
N#define HAL_HASHPhaseTypeDef         HAL_HASH_PhaseTypeDef
N#define HAL_HMAC_MD5_Finish          HAL_HASH_MD5_Finish
N#define HAL_HMAC_SHA1_Finish         HAL_HASH_SHA1_Finish
N#define HAL_HMAC_SHA224_Finish       HAL_HASH_SHA224_Finish
N#define HAL_HMAC_SHA256_Finish       HAL_HASH_SHA256_Finish
N
N/*HASH Algorithm Selection*/
N
N#define HASH_AlgoSelection_SHA1      HASH_ALGOSELECTION_SHA1
N#define HASH_AlgoSelection_SHA224    HASH_ALGOSELECTION_SHA224
N#define HASH_AlgoSelection_SHA256    HASH_ALGOSELECTION_SHA256
N#define HASH_AlgoSelection_MD5       HASH_ALGOSELECTION_MD5
N
N#define HASH_AlgoMode_HASH         HASH_ALGOMODE_HASH
N#define HASH_AlgoMode_HMAC         HASH_ALGOMODE_HMAC
N
N#define HASH_HMACKeyType_ShortKey  HASH_HMAC_KEYTYPE_SHORTKEY
N#define HASH_HMACKeyType_LongKey   HASH_HMAC_KEYTYPE_LONGKEY
N/**
N  * @}
N  */
N
N/** @defgroup HAL_Aliased_Functions HAL Generic Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_EnableDBGSleepMode HAL_DBGMCU_EnableDBGSleepMode
N#define HAL_DisableDBGSleepMode HAL_DBGMCU_DisableDBGSleepMode
N#define HAL_EnableDBGStopMode HAL_DBGMCU_EnableDBGStopMode
N#define HAL_DisableDBGStopMode HAL_DBGMCU_DisableDBGStopMode
N#define HAL_EnableDBGStandbyMode HAL_DBGMCU_EnableDBGStandbyMode
N#define HAL_DisableDBGStandbyMode HAL_DBGMCU_DisableDBGStandbyMode
N#define HAL_DBG_LowPowerConfig(Periph, cmd) (((cmd)==ENABLE)? HAL_DBGMCU_DBG_EnableLowPowerConfig(Periph) : HAL_DBGMCU_DBG_DisableLowPowerConfig(Periph))
N#define HAL_VREFINT_OutputSelect  HAL_SYSCFG_VREFINT_OutputSelect
N#define HAL_Lock_Cmd(cmd) (((cmd)==ENABLE) ? HAL_SYSCFG_Enable_Lock_VREFINT() : HAL_SYSCFG_Disable_Lock_VREFINT())
N#if defined(STM32L0)
X#if 0L
N#else
N#define HAL_VREFINT_Cmd(cmd) (((cmd)==ENABLE)? HAL_SYSCFG_EnableVREFINT() : HAL_SYSCFG_DisableVREFINT())
N#endif
N#define HAL_ADC_EnableBuffer_Cmd(cmd)  (((cmd)==ENABLE) ? HAL_ADCEx_EnableVREFINT() : HAL_ADCEx_DisableVREFINT())
N#define HAL_ADC_EnableBufferSensor_Cmd(cmd) (((cmd)==ENABLE) ?  HAL_ADCEx_EnableVREFINTTempSensor() : HAL_ADCEx_DisableVREFINTTempSensor())
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Functions HAL FLASH Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define FLASH_HalfPageProgram      HAL_FLASHEx_HalfPageProgram
N#define FLASH_EnableRunPowerDown   HAL_FLASHEx_EnableRunPowerDown
N#define FLASH_DisableRunPowerDown  HAL_FLASHEx_DisableRunPowerDown
N#define HAL_DATA_EEPROMEx_Unlock   HAL_FLASHEx_DATAEEPROM_Unlock
N#define HAL_DATA_EEPROMEx_Lock     HAL_FLASHEx_DATAEEPROM_Lock
N#define HAL_DATA_EEPROMEx_Erase    HAL_FLASHEx_DATAEEPROM_Erase
N#define HAL_DATA_EEPROMEx_Program  HAL_FLASHEx_DATAEEPROM_Program
N
N /**
N  * @}
N  */
N
N/** @defgroup HAL_I2C_Aliased_Functions HAL I2C Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_I2CEx_AnalogFilter_Config         HAL_I2CEx_ConfigAnalogFilter
N#define HAL_I2CEx_DigitalFilter_Config        HAL_I2CEx_ConfigDigitalFilter
N#define HAL_FMPI2CEx_AnalogFilter_Config      HAL_FMPI2CEx_ConfigAnalogFilter
N#define HAL_FMPI2CEx_DigitalFilter_Config     HAL_FMPI2CEx_ConfigDigitalFilter
N
N#define HAL_I2CFastModePlusConfig(SYSCFG_I2CFastModePlus, cmd) (((cmd)==ENABLE)? HAL_I2CEx_EnableFastModePlus(SYSCFG_I2CFastModePlus): HAL_I2CEx_DisableFastModePlus(SYSCFG_I2CFastModePlus))
N
N#if defined(STM32H7) || defined(STM32WB) || defined(STM32G0) || defined(STM32F4) || defined(STM32F7)
X#if 0L || 0L || 0L || 1L || 0L
N#define HAL_I2C_Master_Sequential_Transmit_IT  HAL_I2C_Master_Seq_Transmit_IT
N#define HAL_I2C_Master_Sequential_Receive_IT   HAL_I2C_Master_Seq_Receive_IT
N#define HAL_I2C_Slave_Sequential_Transmit_IT   HAL_I2C_Slave_Seq_Transmit_IT
N#define HAL_I2C_Slave_Sequential_Receive_IT    HAL_I2C_Slave_Seq_Receive_IT
N#define HAL_I2C_Master_Sequential_Transmit_DMA HAL_I2C_Master_Seq_Transmit_DMA
N#define HAL_I2C_Master_Sequential_Receive_DMA  HAL_I2C_Master_Seq_Receive_DMA
N#define HAL_I2C_Slave_Sequential_Transmit_DMA  HAL_I2C_Slave_Seq_Transmit_DMA
N#define HAL_I2C_Slave_Sequential_Receive_DMA   HAL_I2C_Slave_Seq_Receive_DMA
N#endif /* STM32H7 || STM32WB  || STM32G0 || STM32F4 || STM32F7 */
N
N#if defined(STM32F4)
X#if 1L
N#define HAL_FMPI2C_Master_Sequential_Transmit_IT  HAL_FMPI2C_Master_Seq_Transmit_IT
N#define HAL_FMPI2C_Master_Sequential_Receive_IT   HAL_FMPI2C_Master_Seq_Receive_IT
N#define HAL_FMPI2C_Slave_Sequential_Transmit_IT   HAL_FMPI2C_Slave_Seq_Transmit_IT
N#define HAL_FMPI2C_Slave_Sequential_Receive_IT    HAL_FMPI2C_Slave_Seq_Receive_IT
N#define HAL_FMPI2C_Master_Sequential_Transmit_DMA HAL_FMPI2C_Master_Seq_Transmit_DMA
N#define HAL_FMPI2C_Master_Sequential_Receive_DMA  HAL_FMPI2C_Master_Seq_Receive_DMA
N#define HAL_FMPI2C_Slave_Sequential_Transmit_DMA  HAL_FMPI2C_Slave_Seq_Transmit_DMA
N#define HAL_FMPI2C_Slave_Sequential_Receive_DMA   HAL_FMPI2C_Slave_Seq_Receive_DMA
N#endif /* STM32F4 */
N /**
N  * @}
N  */
N
N/** @defgroup HAL_PWR_Aliased HAL PWR Aliased maintained for legacy purpose
N  * @{
N  */
N#define HAL_PWR_PVDConfig                             HAL_PWR_ConfigPVD
N#define HAL_PWR_DisableBkUpReg                        HAL_PWREx_DisableBkUpReg
N#define HAL_PWR_DisableFlashPowerDown                 HAL_PWREx_DisableFlashPowerDown
N#define HAL_PWR_DisableVddio2Monitor                  HAL_PWREx_DisableVddio2Monitor
N#define HAL_PWR_EnableBkUpReg                         HAL_PWREx_EnableBkUpReg
N#define HAL_PWR_EnableFlashPowerDown                  HAL_PWREx_EnableFlashPowerDown
N#define HAL_PWR_EnableVddio2Monitor                   HAL_PWREx_EnableVddio2Monitor
N#define HAL_PWR_PVD_PVM_IRQHandler                    HAL_PWREx_PVD_PVM_IRQHandler
N#define HAL_PWR_PVDLevelConfig                        HAL_PWR_ConfigPVD
N#define HAL_PWR_Vddio2Monitor_IRQHandler              HAL_PWREx_Vddio2Monitor_IRQHandler
N#define HAL_PWR_Vddio2MonitorCallback                 HAL_PWREx_Vddio2MonitorCallback
N#define HAL_PWREx_ActivateOverDrive                   HAL_PWREx_EnableOverDrive
N#define HAL_PWREx_DeactivateOverDrive                 HAL_PWREx_DisableOverDrive
N#define HAL_PWREx_DisableSDADCAnalog                  HAL_PWREx_DisableSDADC
N#define HAL_PWREx_EnableSDADCAnalog                   HAL_PWREx_EnableSDADC
N#define HAL_PWREx_PVMConfig                           HAL_PWREx_ConfigPVM
N
N#define PWR_MODE_NORMAL                               PWR_PVD_MODE_NORMAL
N#define PWR_MODE_IT_RISING                            PWR_PVD_MODE_IT_RISING
N#define PWR_MODE_IT_FALLING                           PWR_PVD_MODE_IT_FALLING
N#define PWR_MODE_IT_RISING_FALLING                    PWR_PVD_MODE_IT_RISING_FALLING
N#define PWR_MODE_EVENT_RISING                         PWR_PVD_MODE_EVENT_RISING
N#define PWR_MODE_EVENT_FALLING                        PWR_PVD_MODE_EVENT_FALLING
N#define PWR_MODE_EVENT_RISING_FALLING                 PWR_PVD_MODE_EVENT_RISING_FALLING
N
N#define CR_OFFSET_BB                                  PWR_CR_OFFSET_BB
N#define CSR_OFFSET_BB                                 PWR_CSR_OFFSET_BB
N#define PMODE_BIT_NUMBER                              VOS_BIT_NUMBER
N#define CR_PMODE_BB                                   CR_VOS_BB
N
N#define DBP_BitNumber                                 DBP_BIT_NUMBER
N#define PVDE_BitNumber                                PVDE_BIT_NUMBER
N#define PMODE_BitNumber                               PMODE_BIT_NUMBER
N#define EWUP_BitNumber                                EWUP_BIT_NUMBER
N#define FPDS_BitNumber                                FPDS_BIT_NUMBER
N#define ODEN_BitNumber                                ODEN_BIT_NUMBER
N#define ODSWEN_BitNumber                              ODSWEN_BIT_NUMBER
N#define MRLVDS_BitNumber                              MRLVDS_BIT_NUMBER
N#define LPLVDS_BitNumber                              LPLVDS_BIT_NUMBER
N#define BRE_BitNumber                                 BRE_BIT_NUMBER
N
N#define PWR_MODE_EVT                                  PWR_PVD_MODE_NORMAL
N
N /**
N  * @}
N  */
N
N/** @defgroup HAL_SMBUS_Aliased_Functions HAL SMBUS Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_SMBUS_Slave_Listen_IT          HAL_SMBUS_EnableListen_IT
N#define HAL_SMBUS_SlaveAddrCallback        HAL_SMBUS_AddrCallback
N#define HAL_SMBUS_SlaveListenCpltCallback  HAL_SMBUS_ListenCpltCallback
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPI_Aliased_Functions HAL SPI Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_SPI_FlushRxFifo                HAL_SPIEx_FlushRxFifo
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TIM_Aliased_Functions HAL TIM Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_TIM_DMADelayPulseCplt                       TIM_DMADelayPulseCplt
N#define HAL_TIM_DMAError                                TIM_DMAError
N#define HAL_TIM_DMACaptureCplt                          TIM_DMACaptureCplt
N#define HAL_TIMEx_DMACommutationCplt                    TIMEx_DMACommutationCplt
N#if defined(STM32H7) || defined(STM32G0) || defined(STM32F7) || defined(STM32F4) || defined(STM32L0)
X#if 0L || 0L || 0L || 1L || 0L
N#define HAL_TIM_SlaveConfigSynchronization              HAL_TIM_SlaveConfigSynchro
N#define HAL_TIM_SlaveConfigSynchronization_IT           HAL_TIM_SlaveConfigSynchro_IT
N#define HAL_TIMEx_CommutationCallback                   HAL_TIMEx_CommutCallback
N#define HAL_TIMEx_ConfigCommutationEvent                HAL_TIMEx_ConfigCommutEvent
N#define HAL_TIMEx_ConfigCommutationEvent_IT             HAL_TIMEx_ConfigCommutEvent_IT
N#define HAL_TIMEx_ConfigCommutationEvent_DMA            HAL_TIMEx_ConfigCommutEvent_DMA
N#endif /* STM32H7 || STM32G0 || STM32F7 || STM32F4  || STM32L0 */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_UART_Aliased_Functions HAL UART Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_UART_WakeupCallback HAL_UARTEx_WakeupCallback
N/**
N  * @}
N  */
N
N/** @defgroup HAL_LTDC_Aliased_Functions HAL LTDC Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#define HAL_LTDC_LineEvenCallback HAL_LTDC_LineEventCallback
N#define HAL_LTDC_Relaod           HAL_LTDC_Reload
N#define HAL_LTDC_StructInitFromVideoConfig  HAL_LTDCEx_StructInitFromVideoConfig
N#define HAL_LTDC_StructInitFromAdaptedCommandConfig  HAL_LTDCEx_StructInitFromAdaptedCommandConfig
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_PPP_Aliased_Functions HAL PPP Aliased Functions maintained for legacy purpose
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros ------------------------------------------------------------*/
N
N/** @defgroup HAL_AES_Aliased_Macros HAL CRYP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define AES_IT_CC                      CRYP_IT_CC
N#define AES_IT_ERR                     CRYP_IT_ERR
N#define AES_FLAG_CCF                   CRYP_FLAG_CCF
N/**
N  * @}
N  */
N
N/** @defgroup HAL_Aliased_Macros HAL Generic Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_GET_BOOT_MODE                   __HAL_SYSCFG_GET_BOOT_MODE
N#define __HAL_REMAPMEMORY_FLASH               __HAL_SYSCFG_REMAPMEMORY_FLASH
N#define __HAL_REMAPMEMORY_SYSTEMFLASH         __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH
N#define __HAL_REMAPMEMORY_SRAM                __HAL_SYSCFG_REMAPMEMORY_SRAM
N#define __HAL_REMAPMEMORY_FMC                 __HAL_SYSCFG_REMAPMEMORY_FMC
N#define __HAL_REMAPMEMORY_FMC_SDRAM           __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM
N#define __HAL_REMAPMEMORY_FSMC                __HAL_SYSCFG_REMAPMEMORY_FSMC
N#define __HAL_REMAPMEMORY_QUADSPI             __HAL_SYSCFG_REMAPMEMORY_QUADSPI
N#define __HAL_FMC_BANK                        __HAL_SYSCFG_FMC_BANK
N#define __HAL_GET_FLAG                        __HAL_SYSCFG_GET_FLAG
N#define __HAL_CLEAR_FLAG                      __HAL_SYSCFG_CLEAR_FLAG
N#define __HAL_VREFINT_OUT_ENABLE              __HAL_SYSCFG_VREFINT_OUT_ENABLE
N#define __HAL_VREFINT_OUT_DISABLE             __HAL_SYSCFG_VREFINT_OUT_DISABLE
N#define __HAL_SYSCFG_SRAM2_WRP_ENABLE         __HAL_SYSCFG_SRAM2_WRP_0_31_ENABLE
N
N#define SYSCFG_FLAG_VREF_READY                SYSCFG_FLAG_VREFINT_READY
N#define SYSCFG_FLAG_RC48                      RCC_FLAG_HSI48
N#define IS_SYSCFG_FASTMODEPLUS_CONFIG         IS_I2C_FASTMODEPLUS
N#define UFB_MODE_BitNumber                    UFB_MODE_BIT_NUMBER
N#define CMP_PD_BitNumber                      CMP_PD_BIT_NUMBER
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_ADC_Aliased_Macros HAL ADC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __ADC_ENABLE                                     __HAL_ADC_ENABLE
N#define __ADC_DISABLE                                    __HAL_ADC_DISABLE
N#define __HAL_ADC_ENABLING_CONDITIONS                    ADC_ENABLING_CONDITIONS
N#define __HAL_ADC_DISABLING_CONDITIONS                   ADC_DISABLING_CONDITIONS
N#define __HAL_ADC_IS_ENABLED                             ADC_IS_ENABLE
N#define __ADC_IS_ENABLED                                 ADC_IS_ENABLE
N#define __HAL_ADC_IS_SOFTWARE_START_REGULAR              ADC_IS_SOFTWARE_START_REGULAR
N#define __HAL_ADC_IS_SOFTWARE_START_INJECTED             ADC_IS_SOFTWARE_START_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING_REGULAR          ADC_IS_CONVERSION_ONGOING_REGULAR
N#define __HAL_ADC_IS_CONVERSION_ONGOING_INJECTED         ADC_IS_CONVERSION_ONGOING_INJECTED
N#define __HAL_ADC_IS_CONVERSION_ONGOING                  ADC_IS_CONVERSION_ONGOING
N#define __HAL_ADC_CLEAR_ERRORCODE                        ADC_CLEAR_ERRORCODE
N
N#define __HAL_ADC_GET_RESOLUTION                         ADC_GET_RESOLUTION
N#define __HAL_ADC_JSQR_RK                                ADC_JSQR_RK
N#define __HAL_ADC_CFGR_AWD1CH                            ADC_CFGR_AWD1CH_SHIFT
N#define __HAL_ADC_CFGR_AWD23CR                           ADC_CFGR_AWD23CR
N#define __HAL_ADC_CFGR_INJECT_AUTO_CONVERSION            ADC_CFGR_INJECT_AUTO_CONVERSION
N#define __HAL_ADC_CFGR_INJECT_CONTEXT_QUEUE              ADC_CFGR_INJECT_CONTEXT_QUEUE
N#define __HAL_ADC_CFGR_INJECT_DISCCONTINUOUS             ADC_CFGR_INJECT_DISCCONTINUOUS
N#define __HAL_ADC_CFGR_REG_DISCCONTINUOUS                ADC_CFGR_REG_DISCCONTINUOUS
N#define __HAL_ADC_CFGR_DISCONTINUOUS_NUM                 ADC_CFGR_DISCONTINUOUS_NUM
N#define __HAL_ADC_CFGR_AUTOWAIT                          ADC_CFGR_AUTOWAIT
N#define __HAL_ADC_CFGR_CONTINUOUS                        ADC_CFGR_CONTINUOUS
N#define __HAL_ADC_CFGR_OVERRUN                           ADC_CFGR_OVERRUN
N#define __HAL_ADC_CFGR_DMACONTREQ                        ADC_CFGR_DMACONTREQ
N#define __HAL_ADC_CFGR_EXTSEL                            ADC_CFGR_EXTSEL_SET
N#define __HAL_ADC_JSQR_JEXTSEL                           ADC_JSQR_JEXTSEL_SET
N#define __HAL_ADC_OFR_CHANNEL                            ADC_OFR_CHANNEL
N#define __HAL_ADC_DIFSEL_CHANNEL                         ADC_DIFSEL_CHANNEL
N#define __HAL_ADC_CALFACT_DIFF_SET                       ADC_CALFACT_DIFF_SET
N#define __HAL_ADC_CALFACT_DIFF_GET                       ADC_CALFACT_DIFF_GET
N#define __HAL_ADC_TRX_HIGHTHRESHOLD                      ADC_TRX_HIGHTHRESHOLD
N
N#define __HAL_ADC_OFFSET_SHIFT_RESOLUTION                ADC_OFFSET_SHIFT_RESOLUTION
N#define __HAL_ADC_AWD1THRESHOLD_SHIFT_RESOLUTION         ADC_AWD1THRESHOLD_SHIFT_RESOLUTION
N#define __HAL_ADC_AWD23THRESHOLD_SHIFT_RESOLUTION        ADC_AWD23THRESHOLD_SHIFT_RESOLUTION
N#define __HAL_ADC_COMMON_REGISTER                        ADC_COMMON_REGISTER
N#define __HAL_ADC_COMMON_CCR_MULTI                       ADC_COMMON_CCR_MULTI
N#define __HAL_ADC_MULTIMODE_IS_ENABLED                   ADC_MULTIMODE_IS_ENABLE
N#define __ADC_MULTIMODE_IS_ENABLED                       ADC_MULTIMODE_IS_ENABLE
N#define __HAL_ADC_NONMULTIMODE_OR_MULTIMODEMASTER        ADC_NONMULTIMODE_OR_MULTIMODEMASTER
N#define __HAL_ADC_COMMON_ADC_OTHER                       ADC_COMMON_ADC_OTHER
N#define __HAL_ADC_MULTI_SLAVE                            ADC_MULTI_SLAVE
N
N#define __HAL_ADC_SQR1_L                                 ADC_SQR1_L_SHIFT
N#define __HAL_ADC_JSQR_JL                                ADC_JSQR_JL_SHIFT
N#define __HAL_ADC_JSQR_RK_JL                             ADC_JSQR_RK_JL
N#define __HAL_ADC_CR1_DISCONTINUOUS_NUM                  ADC_CR1_DISCONTINUOUS_NUM
N#define __HAL_ADC_CR1_SCAN                               ADC_CR1_SCAN_SET
N#define __HAL_ADC_CONVCYCLES_MAX_RANGE                   ADC_CONVCYCLES_MAX_RANGE
N#define __HAL_ADC_CLOCK_PRESCALER_RANGE                  ADC_CLOCK_PRESCALER_RANGE
N#define __HAL_ADC_GET_CLOCK_PRESCALER                    ADC_GET_CLOCK_PRESCALER
N
N#define __HAL_ADC_SQR1                                   ADC_SQR1
N#define __HAL_ADC_SMPR1                                  ADC_SMPR1
N#define __HAL_ADC_SMPR2                                  ADC_SMPR2
N#define __HAL_ADC_SQR3_RK                                ADC_SQR3_RK
N#define __HAL_ADC_SQR2_RK                                ADC_SQR2_RK
N#define __HAL_ADC_SQR1_RK                                ADC_SQR1_RK
N#define __HAL_ADC_CR2_CONTINUOUS                         ADC_CR2_CONTINUOUS
N#define __HAL_ADC_CR1_DISCONTINUOUS                      ADC_CR1_DISCONTINUOUS
N#define __HAL_ADC_CR1_SCANCONV                           ADC_CR1_SCANCONV
N#define __HAL_ADC_CR2_EOCSelection                       ADC_CR2_EOCSelection
N#define __HAL_ADC_CR2_DMAContReq                         ADC_CR2_DMAContReq
N#define __HAL_ADC_JSQR                                   ADC_JSQR
N
N#define __HAL_ADC_CHSELR_CHANNEL                         ADC_CHSELR_CHANNEL
N#define __HAL_ADC_CFGR1_REG_DISCCONTINUOUS               ADC_CFGR1_REG_DISCCONTINUOUS
N#define __HAL_ADC_CFGR1_AUTOOFF                          ADC_CFGR1_AUTOOFF
N#define __HAL_ADC_CFGR1_AUTOWAIT                         ADC_CFGR1_AUTOWAIT
N#define __HAL_ADC_CFGR1_CONTINUOUS                       ADC_CFGR1_CONTINUOUS
N#define __HAL_ADC_CFGR1_OVERRUN                          ADC_CFGR1_OVERRUN
N#define __HAL_ADC_CFGR1_SCANDIR                          ADC_CFGR1_SCANDIR
N#define __HAL_ADC_CFGR1_DMACONTREQ                       ADC_CFGR1_DMACONTREQ
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_DHR12R1_ALIGNEMENT                        DAC_DHR12R1_ALIGNMENT
N#define __HAL_DHR12R2_ALIGNEMENT                        DAC_DHR12R2_ALIGNMENT
N#define __HAL_DHR12RD_ALIGNEMENT                        DAC_DHR12RD_ALIGNMENT
N#define IS_DAC_GENERATE_WAVE                            IS_DAC_WAVE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_DBGMCU_Aliased_Macros HAL DBGMCU Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_FREEZE_TIM1_DBGMCU __HAL_DBGMCU_FREEZE_TIM1
N#define __HAL_UNFREEZE_TIM1_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM1
N#define __HAL_FREEZE_TIM2_DBGMCU __HAL_DBGMCU_FREEZE_TIM2
N#define __HAL_UNFREEZE_TIM2_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM2
N#define __HAL_FREEZE_TIM3_DBGMCU __HAL_DBGMCU_FREEZE_TIM3
N#define __HAL_UNFREEZE_TIM3_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM3
N#define __HAL_FREEZE_TIM4_DBGMCU __HAL_DBGMCU_FREEZE_TIM4
N#define __HAL_UNFREEZE_TIM4_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM4
N#define __HAL_FREEZE_TIM5_DBGMCU __HAL_DBGMCU_FREEZE_TIM5
N#define __HAL_UNFREEZE_TIM5_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM5
N#define __HAL_FREEZE_TIM6_DBGMCU __HAL_DBGMCU_FREEZE_TIM6
N#define __HAL_UNFREEZE_TIM6_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM6
N#define __HAL_FREEZE_TIM7_DBGMCU __HAL_DBGMCU_FREEZE_TIM7
N#define __HAL_UNFREEZE_TIM7_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM7
N#define __HAL_FREEZE_TIM8_DBGMCU __HAL_DBGMCU_FREEZE_TIM8
N#define __HAL_UNFREEZE_TIM8_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM8
N
N#define __HAL_FREEZE_TIM9_DBGMCU __HAL_DBGMCU_FREEZE_TIM9
N#define __HAL_UNFREEZE_TIM9_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM9
N#define __HAL_FREEZE_TIM10_DBGMCU __HAL_DBGMCU_FREEZE_TIM10
N#define __HAL_UNFREEZE_TIM10_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM10
N#define __HAL_FREEZE_TIM11_DBGMCU __HAL_DBGMCU_FREEZE_TIM11
N#define __HAL_UNFREEZE_TIM11_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM11
N#define __HAL_FREEZE_TIM12_DBGMCU __HAL_DBGMCU_FREEZE_TIM12
N#define __HAL_UNFREEZE_TIM12_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM12
N#define __HAL_FREEZE_TIM13_DBGMCU __HAL_DBGMCU_FREEZE_TIM13
N#define __HAL_UNFREEZE_TIM13_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM13
N#define __HAL_FREEZE_TIM14_DBGMCU __HAL_DBGMCU_FREEZE_TIM14
N#define __HAL_UNFREEZE_TIM14_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM14
N#define __HAL_FREEZE_CAN2_DBGMCU __HAL_DBGMCU_FREEZE_CAN2
N#define __HAL_UNFREEZE_CAN2_DBGMCU __HAL_DBGMCU_UNFREEZE_CAN2
N
N
N#define __HAL_FREEZE_TIM15_DBGMCU __HAL_DBGMCU_FREEZE_TIM15
N#define __HAL_UNFREEZE_TIM15_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM15
N#define __HAL_FREEZE_TIM16_DBGMCU __HAL_DBGMCU_FREEZE_TIM16
N#define __HAL_UNFREEZE_TIM16_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM16
N#define __HAL_FREEZE_TIM17_DBGMCU __HAL_DBGMCU_FREEZE_TIM17
N#define __HAL_UNFREEZE_TIM17_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM17
N#define __HAL_FREEZE_RTC_DBGMCU __HAL_DBGMCU_FREEZE_RTC
N#define __HAL_UNFREEZE_RTC_DBGMCU __HAL_DBGMCU_UNFREEZE_RTC
N#if defined(STM32H7)
X#if 0L
S  #define __HAL_FREEZE_WWDG_DBGMCU __HAL_DBGMCU_FREEZE_WWDG1
S  #define __HAL_UNFREEZE_WWDG_DBGMCU __HAL_DBGMCU_UnFreeze_WWDG1
S  #define __HAL_FREEZE_IWDG_DBGMCU __HAL_DBGMCU_FREEZE_IWDG1
S  #define __HAL_UNFREEZE_IWDG_DBGMCU __HAL_DBGMCU_UnFreeze_IWDG1
N#else
N  #define __HAL_FREEZE_WWDG_DBGMCU __HAL_DBGMCU_FREEZE_WWDG
N  #define __HAL_UNFREEZE_WWDG_DBGMCU __HAL_DBGMCU_UNFREEZE_WWDG
N  #define __HAL_FREEZE_IWDG_DBGMCU __HAL_DBGMCU_FREEZE_IWDG
N  #define __HAL_UNFREEZE_IWDG_DBGMCU __HAL_DBGMCU_UNFREEZE_IWDG
N#endif /* STM32H7 */
N#define __HAL_FREEZE_I2C1_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT
N#define __HAL_UNFREEZE_I2C1_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT
N#define __HAL_FREEZE_I2C2_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT
N#define __HAL_UNFREEZE_I2C2_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT
N#define __HAL_FREEZE_I2C3_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT
N#define __HAL_UNFREEZE_I2C3_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT
N#define __HAL_FREEZE_CAN1_DBGMCU __HAL_DBGMCU_FREEZE_CAN1
N#define __HAL_UNFREEZE_CAN1_DBGMCU __HAL_DBGMCU_UNFREEZE_CAN1
N#define __HAL_FREEZE_LPTIM1_DBGMCU __HAL_DBGMCU_FREEZE_LPTIM1
N#define __HAL_UNFREEZE_LPTIM1_DBGMCU __HAL_DBGMCU_UNFREEZE_LPTIM1
N#define __HAL_FREEZE_LPTIM2_DBGMCU __HAL_DBGMCU_FREEZE_LPTIM2
N#define __HAL_UNFREEZE_LPTIM2_DBGMCU __HAL_DBGMCU_UNFREEZE_LPTIM2
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_COMP_Aliased_Macros HAL COMP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#if defined(STM32F3)
X#if 0L
S#define COMP_START                                       __HAL_COMP_ENABLE
S#define COMP_STOP                                        __HAL_COMP_DISABLE
S#define COMP_LOCK                                        __HAL_COMP_LOCK
S
S#if defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx) || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F302xE) || defined(STM32F302xC)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP6_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP6_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP6_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F303xE) || defined(STM32F398xx) || defined(STM32F303xC) || defined(STM32F358xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_RISING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_RISING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_FALLING_EDGE() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP7_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_ENABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP7_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_IT() : \
S                                                          ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP7_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_DISABLE_IT() :                                                           ((__EXTILINE__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP7_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_GET_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP7_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_GET_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP7_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_CLEAR_FLAG() : \
S                                                          ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP7_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP2) ? __HAL_COMP_COMP2_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP3) ? __HAL_COMP_COMP3_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP4) ? __HAL_COMP_COMP4_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP5) ? __HAL_COMP_COMP5_EXTI_CLEAR_FLAG() :                                                           ((__FLAG__)  == COMP_EXTI_LINE_COMP6) ? __HAL_COMP_COMP6_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP7_EXTI_CLEAR_FLAG())
S# endif
S# if defined(STM32F373xC) ||defined(STM32F378xx)
S#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
S#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
S                                                          __HAL_COMP_COMP2_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_IT())
S#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
S                                                          __HAL_COMP_COMP2_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_IT())
S#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
S                                                          __HAL_COMP_COMP2_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_GET_FLAG())
S#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
S                                                          __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
S# endif
N#else
N#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)   (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())
N#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
X#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())
N#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)  (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())
N#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
X#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())
N#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : \
N                                                          __HAL_COMP_COMP2_EXTI_ENABLE_IT())
X#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)          (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_ENABLE_IT())
N#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : \
N                                                          __HAL_COMP_COMP2_EXTI_DISABLE_IT())
X#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)         (((__EXTILINE__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() :                                                           __HAL_COMP_COMP2_EXTI_DISABLE_IT())
N#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : \
N                                                          __HAL_COMP_COMP2_EXTI_GET_FLAG())
X#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__)               (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_GET_FLAG())
N#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : \
N                                                          __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
X#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)             (((__FLAG__)  == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() :                                                           __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())
N#endif
N
N#define __HAL_COMP_GET_EXTI_LINE  COMP_GET_EXTI_LINE
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S/* Note: On these STM32 families, the only argument of this macro             */
S/*       is COMP_FLAG_LOCK.                                                   */
S/*       This macro is replaced by __HAL_COMP_IS_LOCKED with only HAL handle  */
S/*       argument.                                                            */
S#define __HAL_COMP_GET_FLAG(__HANDLE__, __FLAG__)  (__HAL_COMP_IS_LOCKED(__HANDLE__))
N#endif
N/**
N  * @}
N  */
N
N#if defined(STM32L0) || defined(STM32L4)
X#if 0L || 0L
S/** @defgroup HAL_COMP_Aliased_Functions HAL COMP Aliased Functions maintained for legacy purpose
S  * @{
S  */
S#define HAL_COMP_Start_IT       HAL_COMP_Start /* Function considered as legacy as EXTI event or IT configuration is done into HAL_COMP_Init() */
S#define HAL_COMP_Stop_IT        HAL_COMP_Stop  /* Function considered as legacy as EXTI event or IT configuration is done into HAL_COMP_Init() */
S/**
S  * @}
S  */
N#endif
N
N/** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_WAVE_NONE) || \
N                          ((WAVE) == DAC_WAVE_NOISE)|| \
N                          ((WAVE) == DAC_WAVE_TRIANGLE))
X#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_WAVE_NONE) ||                           ((WAVE) == DAC_WAVE_NOISE)||                           ((WAVE) == DAC_WAVE_TRIANGLE))
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_FLASH_Aliased_Macros HAL FLASH Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define IS_WRPAREA          IS_OB_WRPAREA
N#define IS_TYPEPROGRAM      IS_FLASH_TYPEPROGRAM
N#define IS_TYPEPROGRAMFLASH IS_FLASH_TYPEPROGRAM
N#define IS_TYPEERASE        IS_FLASH_TYPEERASE
N#define IS_NBSECTORS        IS_FLASH_NBSECTORS
N#define IS_OB_WDG_SOURCE    IS_OB_IWDG_SOURCE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2C_Aliased_Macros HAL I2C Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_I2C_RESET_CR2             I2C_RESET_CR2
N#define __HAL_I2C_GENERATE_START        I2C_GENERATE_START
N#if defined(STM32F1)
X#if 0L
S#define __HAL_I2C_FREQ_RANGE            I2C_FREQRANGE
N#else
N#define __HAL_I2C_FREQ_RANGE            I2C_FREQ_RANGE
N#endif /* STM32F1 */
N#define __HAL_I2C_RISE_TIME             I2C_RISE_TIME
N#define __HAL_I2C_SPEED_STANDARD        I2C_SPEED_STANDARD
N#define __HAL_I2C_SPEED_FAST            I2C_SPEED_FAST
N#define __HAL_I2C_SPEED                 I2C_SPEED
N#define __HAL_I2C_7BIT_ADD_WRITE        I2C_7BIT_ADD_WRITE
N#define __HAL_I2C_7BIT_ADD_READ         I2C_7BIT_ADD_READ
N#define __HAL_I2C_10BIT_ADDRESS         I2C_10BIT_ADDRESS
N#define __HAL_I2C_10BIT_HEADER_WRITE    I2C_10BIT_HEADER_WRITE
N#define __HAL_I2C_10BIT_HEADER_READ     I2C_10BIT_HEADER_READ
N#define __HAL_I2C_MEM_ADD_MSB           I2C_MEM_ADD_MSB
N#define __HAL_I2C_MEM_ADD_LSB           I2C_MEM_ADD_LSB
N#define __HAL_I2C_FREQRANGE             I2C_FREQRANGE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_I2S_Aliased_Macros HAL I2S Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define IS_I2S_INSTANCE                 IS_I2S_ALL_INSTANCE
N#define IS_I2S_INSTANCE_EXT             IS_I2S_ALL_INSTANCE_EXT
N
N#if defined(STM32H7)
X#if 0L
S  #define __HAL_I2S_CLEAR_FREFLAG       __HAL_I2S_CLEAR_TIFREFLAG
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_IRDA_Aliased_Macros HAL IRDA Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __IRDA_DISABLE                  __HAL_IRDA_DISABLE
N#define __IRDA_ENABLE                   __HAL_IRDA_ENABLE
N
N#define __HAL_IRDA_GETCLOCKSOURCE       IRDA_GETCLOCKSOURCE
N#define __HAL_IRDA_MASK_COMPUTATION     IRDA_MASK_COMPUTATION
N#define __IRDA_GETCLOCKSOURCE           IRDA_GETCLOCKSOURCE
N#define __IRDA_MASK_COMPUTATION         IRDA_MASK_COMPUTATION
N
N#define IS_IRDA_ONEBIT_SAMPLE           IS_IRDA_ONE_BIT_SAMPLE
N
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_IWDG_Aliased_Macros HAL IWDG Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_IWDG_ENABLE_WRITE_ACCESS  IWDG_ENABLE_WRITE_ACCESS
N#define __HAL_IWDG_DISABLE_WRITE_ACCESS IWDG_DISABLE_WRITE_ACCESS
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_LPTIM_Aliased_Macros HAL LPTIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_LPTIM_ENABLE_INTERRUPT    __HAL_LPTIM_ENABLE_IT
N#define __HAL_LPTIM_DISABLE_INTERRUPT   __HAL_LPTIM_DISABLE_IT
N#define __HAL_LPTIM_GET_ITSTATUS        __HAL_LPTIM_GET_IT_SOURCE
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_OPAMP_Aliased_Macros HAL OPAMP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __OPAMP_CSR_OPAXPD                OPAMP_CSR_OPAXPD
N#define __OPAMP_CSR_S3SELX                OPAMP_CSR_S3SELX
N#define __OPAMP_CSR_S4SELX                OPAMP_CSR_S4SELX
N#define __OPAMP_CSR_S5SELX                OPAMP_CSR_S5SELX
N#define __OPAMP_CSR_S6SELX                OPAMP_CSR_S6SELX
N#define __OPAMP_CSR_OPAXCAL_L             OPAMP_CSR_OPAXCAL_L
N#define __OPAMP_CSR_OPAXCAL_H             OPAMP_CSR_OPAXCAL_H
N#define __OPAMP_CSR_OPAXLPM               OPAMP_CSR_OPAXLPM
N#define __OPAMP_CSR_ALL_SWITCHES          OPAMP_CSR_ALL_SWITCHES
N#define __OPAMP_CSR_ANAWSELX              OPAMP_CSR_ANAWSELX
N#define __OPAMP_CSR_OPAXCALOUT            OPAMP_CSR_OPAXCALOUT
N#define __OPAMP_OFFSET_TRIM_BITSPOSITION  OPAMP_OFFSET_TRIM_BITSPOSITION
N#define __OPAMP_OFFSET_TRIM_SET           OPAMP_OFFSET_TRIM_SET
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_PWR_Aliased_Macros HAL PWR Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_PVD_EVENT_DISABLE                                  __HAL_PWR_PVD_EXTI_DISABLE_EVENT
N#define __HAL_PVD_EVENT_ENABLE                                   __HAL_PWR_PVD_EXTI_ENABLE_EVENT
N#define __HAL_PVD_EXTI_FALLINGTRIGGER_DISABLE                    __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PVD_EXTI_FALLINGTRIGGER_ENABLE                     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PVD_EXTI_RISINGTRIGGER_DISABLE                     __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE
N#define __HAL_PVD_EXTI_RISINGTRIGGER_ENABLE                      __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PVM_EVENT_DISABLE                                  __HAL_PWR_PVM_EVENT_DISABLE
N#define __HAL_PVM_EVENT_ENABLE                                   __HAL_PWR_PVM_EVENT_ENABLE
N#define __HAL_PVM_EXTI_FALLINGTRIGGER_DISABLE                    __HAL_PWR_PVM_EXTI_FALLINGTRIGGER_DISABLE
N#define __HAL_PVM_EXTI_FALLINGTRIGGER_ENABLE                     __HAL_PWR_PVM_EXTI_FALLINGTRIGGER_ENABLE
N#define __HAL_PVM_EXTI_RISINGTRIGGER_DISABLE                     __HAL_PWR_PVM_EXTI_RISINGTRIGGER_DISABLE
N#define __HAL_PVM_EXTI_RISINGTRIGGER_ENABLE                      __HAL_PWR_PVM_EXTI_RISINGTRIGGER_ENABLE
N#define __HAL_PWR_INTERNALWAKEUP_DISABLE                         HAL_PWREx_DisableInternalWakeUpLine
N#define __HAL_PWR_INTERNALWAKEUP_ENABLE                          HAL_PWREx_EnableInternalWakeUpLine
N#define __HAL_PWR_PULL_UP_DOWN_CONFIG_DISABLE                    HAL_PWREx_DisablePullUpPullDownConfig
N#define __HAL_PWR_PULL_UP_DOWN_CONFIG_ENABLE                     HAL_PWREx_EnablePullUpPullDownConfig
N#define __HAL_PWR_PVD_EXTI_CLEAR_EGDE_TRIGGER()                  do { __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); } while(0)
N#define __HAL_PWR_PVD_EXTI_EVENT_DISABLE                         __HAL_PWR_PVD_EXTI_DISABLE_EVENT
N#define __HAL_PWR_PVD_EXTI_EVENT_ENABLE                          __HAL_PWR_PVD_EXTI_ENABLE_EVENT
N#define __HAL_PWR_PVD_EXTI_FALLINGTRIGGER_DISABLE                __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_FALLINGTRIGGER_ENABLE                 __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_RISINGTRIGGER_DISABLE                 __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE
N#define __HAL_PWR_PVD_EXTI_RISINGTRIGGER_ENABLE                  __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PWR_PVD_EXTI_SET_FALLING_EGDE_TRIGGER              __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_PVD_EXTI_SET_RISING_EDGE_TRIGGER               __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
N#define __HAL_PWR_PVM_DISABLE()                                  do { HAL_PWREx_DisablePVM1();HAL_PWREx_DisablePVM2();HAL_PWREx_DisablePVM3();HAL_PWREx_DisablePVM4(); } while(0)
N#define __HAL_PWR_PVM_ENABLE()                                   do { HAL_PWREx_EnablePVM1();HAL_PWREx_EnablePVM2();HAL_PWREx_EnablePVM3();HAL_PWREx_EnablePVM4(); } while(0)
N#define __HAL_PWR_SRAM2CONTENT_PRESERVE_DISABLE                  HAL_PWREx_DisableSRAM2ContentRetention
N#define __HAL_PWR_SRAM2CONTENT_PRESERVE_ENABLE                   HAL_PWREx_EnableSRAM2ContentRetention
N#define __HAL_PWR_VDDIO2_DISABLE                                 HAL_PWREx_DisableVddIO2
N#define __HAL_PWR_VDDIO2_ENABLE                                  HAL_PWREx_EnableVddIO2
N#define __HAL_PWR_VDDIO2_EXTI_CLEAR_EGDE_TRIGGER                 __HAL_PWR_VDDIO2_EXTI_DISABLE_FALLING_EDGE
N#define __HAL_PWR_VDDIO2_EXTI_SET_FALLING_EGDE_TRIGGER           __HAL_PWR_VDDIO2_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_PWR_VDDUSB_DISABLE                                 HAL_PWREx_DisableVddUSB
N#define __HAL_PWR_VDDUSB_ENABLE                                  HAL_PWREx_EnableVddUSB
N
N#if defined (STM32F4)
X#if 1L
N#define __HAL_PVD_EXTI_ENABLE_IT(PWR_EXTI_LINE_PVD)         __HAL_PWR_PVD_EXTI_ENABLE_IT()
N#define __HAL_PVD_EXTI_DISABLE_IT(PWR_EXTI_LINE_PVD)        __HAL_PWR_PVD_EXTI_DISABLE_IT()
N#define __HAL_PVD_EXTI_GET_FLAG(PWR_EXTI_LINE_PVD)          __HAL_PWR_PVD_EXTI_GET_FLAG()
N#define __HAL_PVD_EXTI_CLEAR_FLAG(PWR_EXTI_LINE_PVD)        __HAL_PWR_PVD_EXTI_CLEAR_FLAG()
N#define __HAL_PVD_EXTI_GENERATE_SWIT(PWR_EXTI_LINE_PVD)     __HAL_PWR_PVD_EXTI_GENERATE_SWIT()
N#else
S#define __HAL_PVD_EXTI_CLEAR_FLAG                                __HAL_PWR_PVD_EXTI_CLEAR_FLAG
S#define __HAL_PVD_EXTI_DISABLE_IT                                __HAL_PWR_PVD_EXTI_DISABLE_IT
S#define __HAL_PVD_EXTI_ENABLE_IT                                 __HAL_PWR_PVD_EXTI_ENABLE_IT
S#define __HAL_PVD_EXTI_GENERATE_SWIT                             __HAL_PWR_PVD_EXTI_GENERATE_SWIT
S#define __HAL_PVD_EXTI_GET_FLAG                                  __HAL_PWR_PVD_EXTI_GET_FLAG
N#endif /* STM32F4 */
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_RCC_Aliased HAL RCC Aliased maintained for legacy purpose
N  * @{
N  */
N
N#define RCC_StopWakeUpClock_MSI     RCC_STOP_WAKEUPCLOCK_MSI
N#define RCC_StopWakeUpClock_HSI     RCC_STOP_WAKEUPCLOCK_HSI
N
N#define HAL_RCC_CCSCallback HAL_RCC_CSSCallback
N#define HAL_RC48_EnableBuffer_Cmd(cmd) (((cmd)==ENABLE) ? HAL_RCCEx_EnableHSI48_VREFINT() : HAL_RCCEx_DisableHSI48_VREFINT())
N
N#define __ADC_CLK_DISABLE          __HAL_RCC_ADC_CLK_DISABLE
N#define __ADC_CLK_ENABLE           __HAL_RCC_ADC_CLK_ENABLE
N#define __ADC_CLK_SLEEP_DISABLE    __HAL_RCC_ADC_CLK_SLEEP_DISABLE
N#define __ADC_CLK_SLEEP_ENABLE     __HAL_RCC_ADC_CLK_SLEEP_ENABLE
N#define __ADC_FORCE_RESET          __HAL_RCC_ADC_FORCE_RESET
N#define __ADC_RELEASE_RESET        __HAL_RCC_ADC_RELEASE_RESET
N#define __ADC1_CLK_DISABLE         __HAL_RCC_ADC1_CLK_DISABLE
N#define __ADC1_CLK_ENABLE          __HAL_RCC_ADC1_CLK_ENABLE
N#define __ADC1_FORCE_RESET         __HAL_RCC_ADC1_FORCE_RESET
N#define __ADC1_RELEASE_RESET       __HAL_RCC_ADC1_RELEASE_RESET
N#define __ADC1_CLK_SLEEP_ENABLE    __HAL_RCC_ADC1_CLK_SLEEP_ENABLE
N#define __ADC1_CLK_SLEEP_DISABLE   __HAL_RCC_ADC1_CLK_SLEEP_DISABLE
N#define __ADC2_CLK_DISABLE         __HAL_RCC_ADC2_CLK_DISABLE
N#define __ADC2_CLK_ENABLE          __HAL_RCC_ADC2_CLK_ENABLE
N#define __ADC2_FORCE_RESET __HAL_RCC_ADC2_FORCE_RESET
N#define __ADC2_RELEASE_RESET __HAL_RCC_ADC2_RELEASE_RESET
N#define __ADC3_CLK_DISABLE __HAL_RCC_ADC3_CLK_DISABLE
N#define __ADC3_CLK_ENABLE __HAL_RCC_ADC3_CLK_ENABLE
N#define __ADC3_FORCE_RESET __HAL_RCC_ADC3_FORCE_RESET
N#define __ADC3_RELEASE_RESET __HAL_RCC_ADC3_RELEASE_RESET
N#define __AES_CLK_DISABLE __HAL_RCC_AES_CLK_DISABLE
N#define __AES_CLK_ENABLE __HAL_RCC_AES_CLK_ENABLE
N#define __AES_CLK_SLEEP_DISABLE __HAL_RCC_AES_CLK_SLEEP_DISABLE
N#define __AES_CLK_SLEEP_ENABLE __HAL_RCC_AES_CLK_SLEEP_ENABLE
N#define __AES_FORCE_RESET __HAL_RCC_AES_FORCE_RESET
N#define __AES_RELEASE_RESET __HAL_RCC_AES_RELEASE_RESET
N#define __CRYP_CLK_SLEEP_ENABLE      __HAL_RCC_CRYP_CLK_SLEEP_ENABLE
N#define __CRYP_CLK_SLEEP_DISABLE  __HAL_RCC_CRYP_CLK_SLEEP_DISABLE
N#define __CRYP_CLK_ENABLE  __HAL_RCC_CRYP_CLK_ENABLE
N#define __CRYP_CLK_DISABLE  __HAL_RCC_CRYP_CLK_DISABLE
N#define __CRYP_FORCE_RESET       __HAL_RCC_CRYP_FORCE_RESET
N#define __CRYP_RELEASE_RESET  __HAL_RCC_CRYP_RELEASE_RESET
N#define __AFIO_CLK_DISABLE __HAL_RCC_AFIO_CLK_DISABLE
N#define __AFIO_CLK_ENABLE __HAL_RCC_AFIO_CLK_ENABLE
N#define __AFIO_FORCE_RESET __HAL_RCC_AFIO_FORCE_RESET
N#define __AFIO_RELEASE_RESET __HAL_RCC_AFIO_RELEASE_RESET
N#define __AHB_FORCE_RESET __HAL_RCC_AHB_FORCE_RESET
N#define __AHB_RELEASE_RESET __HAL_RCC_AHB_RELEASE_RESET
N#define __AHB1_FORCE_RESET __HAL_RCC_AHB1_FORCE_RESET
N#define __AHB1_RELEASE_RESET __HAL_RCC_AHB1_RELEASE_RESET
N#define __AHB2_FORCE_RESET __HAL_RCC_AHB2_FORCE_RESET
N#define __AHB2_RELEASE_RESET __HAL_RCC_AHB2_RELEASE_RESET
N#define __AHB3_FORCE_RESET __HAL_RCC_AHB3_FORCE_RESET
N#define __AHB3_RELEASE_RESET __HAL_RCC_AHB3_RELEASE_RESET
N#define __APB1_FORCE_RESET __HAL_RCC_APB1_FORCE_RESET
N#define __APB1_RELEASE_RESET __HAL_RCC_APB1_RELEASE_RESET
N#define __APB2_FORCE_RESET __HAL_RCC_APB2_FORCE_RESET
N#define __APB2_RELEASE_RESET __HAL_RCC_APB2_RELEASE_RESET
N#define __BKP_CLK_DISABLE __HAL_RCC_BKP_CLK_DISABLE
N#define __BKP_CLK_ENABLE __HAL_RCC_BKP_CLK_ENABLE
N#define __BKP_FORCE_RESET __HAL_RCC_BKP_FORCE_RESET
N#define __BKP_RELEASE_RESET __HAL_RCC_BKP_RELEASE_RESET
N#define __CAN1_CLK_DISABLE __HAL_RCC_CAN1_CLK_DISABLE
N#define __CAN1_CLK_ENABLE __HAL_RCC_CAN1_CLK_ENABLE
N#define __CAN1_CLK_SLEEP_DISABLE __HAL_RCC_CAN1_CLK_SLEEP_DISABLE
N#define __CAN1_CLK_SLEEP_ENABLE __HAL_RCC_CAN1_CLK_SLEEP_ENABLE
N#define __CAN1_FORCE_RESET __HAL_RCC_CAN1_FORCE_RESET
N#define __CAN1_RELEASE_RESET __HAL_RCC_CAN1_RELEASE_RESET
N#define __CAN_CLK_DISABLE         __HAL_RCC_CAN1_CLK_DISABLE
N#define __CAN_CLK_ENABLE          __HAL_RCC_CAN1_CLK_ENABLE
N#define __CAN_FORCE_RESET         __HAL_RCC_CAN1_FORCE_RESET
N#define __CAN_RELEASE_RESET       __HAL_RCC_CAN1_RELEASE_RESET
N#define __CAN2_CLK_DISABLE __HAL_RCC_CAN2_CLK_DISABLE
N#define __CAN2_CLK_ENABLE __HAL_RCC_CAN2_CLK_ENABLE
N#define __CAN2_FORCE_RESET __HAL_RCC_CAN2_FORCE_RESET
N#define __CAN2_RELEASE_RESET __HAL_RCC_CAN2_RELEASE_RESET
N#define __CEC_CLK_DISABLE __HAL_RCC_CEC_CLK_DISABLE
N#define __CEC_CLK_ENABLE __HAL_RCC_CEC_CLK_ENABLE
N#define __COMP_CLK_DISABLE        __HAL_RCC_COMP_CLK_DISABLE
N#define __COMP_CLK_ENABLE         __HAL_RCC_COMP_CLK_ENABLE
N#define __COMP_FORCE_RESET        __HAL_RCC_COMP_FORCE_RESET
N#define __COMP_RELEASE_RESET      __HAL_RCC_COMP_RELEASE_RESET
N#define __COMP_CLK_SLEEP_ENABLE   __HAL_RCC_COMP_CLK_SLEEP_ENABLE
N#define __COMP_CLK_SLEEP_DISABLE  __HAL_RCC_COMP_CLK_SLEEP_DISABLE
N#define __CEC_FORCE_RESET __HAL_RCC_CEC_FORCE_RESET
N#define __CEC_RELEASE_RESET __HAL_RCC_CEC_RELEASE_RESET
N#define __CRC_CLK_DISABLE __HAL_RCC_CRC_CLK_DISABLE
N#define __CRC_CLK_ENABLE __HAL_RCC_CRC_CLK_ENABLE
N#define __CRC_CLK_SLEEP_DISABLE __HAL_RCC_CRC_CLK_SLEEP_DISABLE
N#define __CRC_CLK_SLEEP_ENABLE __HAL_RCC_CRC_CLK_SLEEP_ENABLE
N#define __CRC_FORCE_RESET __HAL_RCC_CRC_FORCE_RESET
N#define __CRC_RELEASE_RESET __HAL_RCC_CRC_RELEASE_RESET
N#define __DAC_CLK_DISABLE __HAL_RCC_DAC_CLK_DISABLE
N#define __DAC_CLK_ENABLE __HAL_RCC_DAC_CLK_ENABLE
N#define __DAC_FORCE_RESET __HAL_RCC_DAC_FORCE_RESET
N#define __DAC_RELEASE_RESET __HAL_RCC_DAC_RELEASE_RESET
N#define __DAC1_CLK_DISABLE __HAL_RCC_DAC1_CLK_DISABLE
N#define __DAC1_CLK_ENABLE __HAL_RCC_DAC1_CLK_ENABLE
N#define __DAC1_CLK_SLEEP_DISABLE __HAL_RCC_DAC1_CLK_SLEEP_DISABLE
N#define __DAC1_CLK_SLEEP_ENABLE __HAL_RCC_DAC1_CLK_SLEEP_ENABLE
N#define __DAC1_FORCE_RESET __HAL_RCC_DAC1_FORCE_RESET
N#define __DAC1_RELEASE_RESET __HAL_RCC_DAC1_RELEASE_RESET
N#define __DBGMCU_CLK_ENABLE     __HAL_RCC_DBGMCU_CLK_ENABLE
N#define __DBGMCU_CLK_DISABLE     __HAL_RCC_DBGMCU_CLK_DISABLE
N#define __DBGMCU_FORCE_RESET    __HAL_RCC_DBGMCU_FORCE_RESET
N#define __DBGMCU_RELEASE_RESET  __HAL_RCC_DBGMCU_RELEASE_RESET
N#define __DFSDM_CLK_DISABLE __HAL_RCC_DFSDM_CLK_DISABLE
N#define __DFSDM_CLK_ENABLE __HAL_RCC_DFSDM_CLK_ENABLE
N#define __DFSDM_CLK_SLEEP_DISABLE __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE
N#define __DFSDM_CLK_SLEEP_ENABLE __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE
N#define __DFSDM_FORCE_RESET __HAL_RCC_DFSDM_FORCE_RESET
N#define __DFSDM_RELEASE_RESET __HAL_RCC_DFSDM_RELEASE_RESET
N#define __DMA1_CLK_DISABLE __HAL_RCC_DMA1_CLK_DISABLE
N#define __DMA1_CLK_ENABLE __HAL_RCC_DMA1_CLK_ENABLE
N#define __DMA1_CLK_SLEEP_DISABLE __HAL_RCC_DMA1_CLK_SLEEP_DISABLE
N#define __DMA1_CLK_SLEEP_ENABLE __HAL_RCC_DMA1_CLK_SLEEP_ENABLE
N#define __DMA1_FORCE_RESET __HAL_RCC_DMA1_FORCE_RESET
N#define __DMA1_RELEASE_RESET __HAL_RCC_DMA1_RELEASE_RESET
N#define __DMA2_CLK_DISABLE __HAL_RCC_DMA2_CLK_DISABLE
N#define __DMA2_CLK_ENABLE __HAL_RCC_DMA2_CLK_ENABLE
N#define __DMA2_CLK_SLEEP_DISABLE __HAL_RCC_DMA2_CLK_SLEEP_DISABLE
N#define __DMA2_CLK_SLEEP_ENABLE __HAL_RCC_DMA2_CLK_SLEEP_ENABLE
N#define __DMA2_FORCE_RESET __HAL_RCC_DMA2_FORCE_RESET
N#define __DMA2_RELEASE_RESET __HAL_RCC_DMA2_RELEASE_RESET
N#define __ETHMAC_CLK_DISABLE __HAL_RCC_ETHMAC_CLK_DISABLE
N#define __ETHMAC_CLK_ENABLE __HAL_RCC_ETHMAC_CLK_ENABLE
N#define __ETHMAC_FORCE_RESET __HAL_RCC_ETHMAC_FORCE_RESET
N#define __ETHMAC_RELEASE_RESET __HAL_RCC_ETHMAC_RELEASE_RESET
N#define __ETHMACRX_CLK_DISABLE __HAL_RCC_ETHMACRX_CLK_DISABLE
N#define __ETHMACRX_CLK_ENABLE __HAL_RCC_ETHMACRX_CLK_ENABLE
N#define __ETHMACTX_CLK_DISABLE __HAL_RCC_ETHMACTX_CLK_DISABLE
N#define __ETHMACTX_CLK_ENABLE __HAL_RCC_ETHMACTX_CLK_ENABLE
N#define __FIREWALL_CLK_DISABLE __HAL_RCC_FIREWALL_CLK_DISABLE
N#define __FIREWALL_CLK_ENABLE __HAL_RCC_FIREWALL_CLK_ENABLE
N#define __FLASH_CLK_DISABLE __HAL_RCC_FLASH_CLK_DISABLE
N#define __FLASH_CLK_ENABLE __HAL_RCC_FLASH_CLK_ENABLE
N#define __FLASH_CLK_SLEEP_DISABLE __HAL_RCC_FLASH_CLK_SLEEP_DISABLE
N#define __FLASH_CLK_SLEEP_ENABLE __HAL_RCC_FLASH_CLK_SLEEP_ENABLE
N#define __FLASH_FORCE_RESET __HAL_RCC_FLASH_FORCE_RESET
N#define __FLASH_RELEASE_RESET __HAL_RCC_FLASH_RELEASE_RESET
N#define __FLITF_CLK_DISABLE       __HAL_RCC_FLITF_CLK_DISABLE
N#define __FLITF_CLK_ENABLE        __HAL_RCC_FLITF_CLK_ENABLE
N#define __FLITF_FORCE_RESET       __HAL_RCC_FLITF_FORCE_RESET
N#define __FLITF_RELEASE_RESET     __HAL_RCC_FLITF_RELEASE_RESET
N#define __FLITF_CLK_SLEEP_ENABLE  __HAL_RCC_FLITF_CLK_SLEEP_ENABLE
N#define __FLITF_CLK_SLEEP_DISABLE __HAL_RCC_FLITF_CLK_SLEEP_DISABLE
N#define __FMC_CLK_DISABLE __HAL_RCC_FMC_CLK_DISABLE
N#define __FMC_CLK_ENABLE __HAL_RCC_FMC_CLK_ENABLE
N#define __FMC_CLK_SLEEP_DISABLE __HAL_RCC_FMC_CLK_SLEEP_DISABLE
N#define __FMC_CLK_SLEEP_ENABLE __HAL_RCC_FMC_CLK_SLEEP_ENABLE
N#define __FMC_FORCE_RESET __HAL_RCC_FMC_FORCE_RESET
N#define __FMC_RELEASE_RESET __HAL_RCC_FMC_RELEASE_RESET
N#define __FSMC_CLK_DISABLE __HAL_RCC_FSMC_CLK_DISABLE
N#define __FSMC_CLK_ENABLE __HAL_RCC_FSMC_CLK_ENABLE
N#define __GPIOA_CLK_DISABLE __HAL_RCC_GPIOA_CLK_DISABLE
N#define __GPIOA_CLK_ENABLE __HAL_RCC_GPIOA_CLK_ENABLE
N#define __GPIOA_CLK_SLEEP_DISABLE __HAL_RCC_GPIOA_CLK_SLEEP_DISABLE
N#define __GPIOA_CLK_SLEEP_ENABLE __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE
N#define __GPIOA_FORCE_RESET __HAL_RCC_GPIOA_FORCE_RESET
N#define __GPIOA_RELEASE_RESET __HAL_RCC_GPIOA_RELEASE_RESET
N#define __GPIOB_CLK_DISABLE __HAL_RCC_GPIOB_CLK_DISABLE
N#define __GPIOB_CLK_ENABLE __HAL_RCC_GPIOB_CLK_ENABLE
N#define __GPIOB_CLK_SLEEP_DISABLE __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE
N#define __GPIOB_CLK_SLEEP_ENABLE __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE
N#define __GPIOB_FORCE_RESET __HAL_RCC_GPIOB_FORCE_RESET
N#define __GPIOB_RELEASE_RESET __HAL_RCC_GPIOB_RELEASE_RESET
N#define __GPIOC_CLK_DISABLE __HAL_RCC_GPIOC_CLK_DISABLE
N#define __GPIOC_CLK_ENABLE __HAL_RCC_GPIOC_CLK_ENABLE
N#define __GPIOC_CLK_SLEEP_DISABLE __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE
N#define __GPIOC_CLK_SLEEP_ENABLE __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE
N#define __GPIOC_FORCE_RESET __HAL_RCC_GPIOC_FORCE_RESET
N#define __GPIOC_RELEASE_RESET __HAL_RCC_GPIOC_RELEASE_RESET
N#define __GPIOD_CLK_DISABLE __HAL_RCC_GPIOD_CLK_DISABLE
N#define __GPIOD_CLK_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE
N#define __GPIOD_CLK_SLEEP_DISABLE __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE
N#define __GPIOD_CLK_SLEEP_ENABLE __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE
N#define __GPIOD_FORCE_RESET __HAL_RCC_GPIOD_FORCE_RESET
N#define __GPIOD_RELEASE_RESET __HAL_RCC_GPIOD_RELEASE_RESET
N#define __GPIOE_CLK_DISABLE __HAL_RCC_GPIOE_CLK_DISABLE
N#define __GPIOE_CLK_ENABLE __HAL_RCC_GPIOE_CLK_ENABLE
N#define __GPIOE_CLK_SLEEP_DISABLE __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE
N#define __GPIOE_CLK_SLEEP_ENABLE __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE
N#define __GPIOE_FORCE_RESET __HAL_RCC_GPIOE_FORCE_RESET
N#define __GPIOE_RELEASE_RESET __HAL_RCC_GPIOE_RELEASE_RESET
N#define __GPIOF_CLK_DISABLE __HAL_RCC_GPIOF_CLK_DISABLE
N#define __GPIOF_CLK_ENABLE __HAL_RCC_GPIOF_CLK_ENABLE
N#define __GPIOF_CLK_SLEEP_DISABLE __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE
N#define __GPIOF_CLK_SLEEP_ENABLE __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE
N#define __GPIOF_FORCE_RESET __HAL_RCC_GPIOF_FORCE_RESET
N#define __GPIOF_RELEASE_RESET __HAL_RCC_GPIOF_RELEASE_RESET
N#define __GPIOG_CLK_DISABLE __HAL_RCC_GPIOG_CLK_DISABLE
N#define __GPIOG_CLK_ENABLE __HAL_RCC_GPIOG_CLK_ENABLE
N#define __GPIOG_CLK_SLEEP_DISABLE __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE
N#define __GPIOG_CLK_SLEEP_ENABLE __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE
N#define __GPIOG_FORCE_RESET __HAL_RCC_GPIOG_FORCE_RESET
N#define __GPIOG_RELEASE_RESET __HAL_RCC_GPIOG_RELEASE_RESET
N#define __GPIOH_CLK_DISABLE __HAL_RCC_GPIOH_CLK_DISABLE
N#define __GPIOH_CLK_ENABLE __HAL_RCC_GPIOH_CLK_ENABLE
N#define __GPIOH_CLK_SLEEP_DISABLE __HAL_RCC_GPIOH_CLK_SLEEP_DISABLE
N#define __GPIOH_CLK_SLEEP_ENABLE __HAL_RCC_GPIOH_CLK_SLEEP_ENABLE
N#define __GPIOH_FORCE_RESET __HAL_RCC_GPIOH_FORCE_RESET
N#define __GPIOH_RELEASE_RESET __HAL_RCC_GPIOH_RELEASE_RESET
N#define __I2C1_CLK_DISABLE __HAL_RCC_I2C1_CLK_DISABLE
N#define __I2C1_CLK_ENABLE __HAL_RCC_I2C1_CLK_ENABLE
N#define __I2C1_CLK_SLEEP_DISABLE __HAL_RCC_I2C1_CLK_SLEEP_DISABLE
N#define __I2C1_CLK_SLEEP_ENABLE __HAL_RCC_I2C1_CLK_SLEEP_ENABLE
N#define __I2C1_FORCE_RESET __HAL_RCC_I2C1_FORCE_RESET
N#define __I2C1_RELEASE_RESET __HAL_RCC_I2C1_RELEASE_RESET
N#define __I2C2_CLK_DISABLE __HAL_RCC_I2C2_CLK_DISABLE
N#define __I2C2_CLK_ENABLE __HAL_RCC_I2C2_CLK_ENABLE
N#define __I2C2_CLK_SLEEP_DISABLE __HAL_RCC_I2C2_CLK_SLEEP_DISABLE
N#define __I2C2_CLK_SLEEP_ENABLE __HAL_RCC_I2C2_CLK_SLEEP_ENABLE
N#define __I2C2_FORCE_RESET __HAL_RCC_I2C2_FORCE_RESET
N#define __I2C2_RELEASE_RESET __HAL_RCC_I2C2_RELEASE_RESET
N#define __I2C3_CLK_DISABLE __HAL_RCC_I2C3_CLK_DISABLE
N#define __I2C3_CLK_ENABLE __HAL_RCC_I2C3_CLK_ENABLE
N#define __I2C3_CLK_SLEEP_DISABLE __HAL_RCC_I2C3_CLK_SLEEP_DISABLE
N#define __I2C3_CLK_SLEEP_ENABLE __HAL_RCC_I2C3_CLK_SLEEP_ENABLE
N#define __I2C3_FORCE_RESET __HAL_RCC_I2C3_FORCE_RESET
N#define __I2C3_RELEASE_RESET __HAL_RCC_I2C3_RELEASE_RESET
N#define __LCD_CLK_DISABLE __HAL_RCC_LCD_CLK_DISABLE
N#define __LCD_CLK_ENABLE __HAL_RCC_LCD_CLK_ENABLE
N#define __LCD_CLK_SLEEP_DISABLE __HAL_RCC_LCD_CLK_SLEEP_DISABLE
N#define __LCD_CLK_SLEEP_ENABLE __HAL_RCC_LCD_CLK_SLEEP_ENABLE
N#define __LCD_FORCE_RESET __HAL_RCC_LCD_FORCE_RESET
N#define __LCD_RELEASE_RESET __HAL_RCC_LCD_RELEASE_RESET
N#define __LPTIM1_CLK_DISABLE __HAL_RCC_LPTIM1_CLK_DISABLE
N#define __LPTIM1_CLK_ENABLE __HAL_RCC_LPTIM1_CLK_ENABLE
N#define __LPTIM1_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE
N#define __LPTIM1_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE
N#define __LPTIM1_FORCE_RESET __HAL_RCC_LPTIM1_FORCE_RESET
N#define __LPTIM1_RELEASE_RESET __HAL_RCC_LPTIM1_RELEASE_RESET
N#define __LPTIM2_CLK_DISABLE __HAL_RCC_LPTIM2_CLK_DISABLE
N#define __LPTIM2_CLK_ENABLE __HAL_RCC_LPTIM2_CLK_ENABLE
N#define __LPTIM2_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM2_CLK_SLEEP_DISABLE
N#define __LPTIM2_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM2_CLK_SLEEP_ENABLE
N#define __LPTIM2_FORCE_RESET __HAL_RCC_LPTIM2_FORCE_RESET
N#define __LPTIM2_RELEASE_RESET __HAL_RCC_LPTIM2_RELEASE_RESET
N#define __LPUART1_CLK_DISABLE __HAL_RCC_LPUART1_CLK_DISABLE
N#define __LPUART1_CLK_ENABLE __HAL_RCC_LPUART1_CLK_ENABLE
N#define __LPUART1_CLK_SLEEP_DISABLE __HAL_RCC_LPUART1_CLK_SLEEP_DISABLE
N#define __LPUART1_CLK_SLEEP_ENABLE __HAL_RCC_LPUART1_CLK_SLEEP_ENABLE
N#define __LPUART1_FORCE_RESET __HAL_RCC_LPUART1_FORCE_RESET
N#define __LPUART1_RELEASE_RESET __HAL_RCC_LPUART1_RELEASE_RESET
N#define __OPAMP_CLK_DISABLE __HAL_RCC_OPAMP_CLK_DISABLE
N#define __OPAMP_CLK_ENABLE __HAL_RCC_OPAMP_CLK_ENABLE
N#define __OPAMP_CLK_SLEEP_DISABLE __HAL_RCC_OPAMP_CLK_SLEEP_DISABLE
N#define __OPAMP_CLK_SLEEP_ENABLE __HAL_RCC_OPAMP_CLK_SLEEP_ENABLE
N#define __OPAMP_FORCE_RESET __HAL_RCC_OPAMP_FORCE_RESET
N#define __OPAMP_RELEASE_RESET __HAL_RCC_OPAMP_RELEASE_RESET
N#define __OTGFS_CLK_DISABLE __HAL_RCC_OTGFS_CLK_DISABLE
N#define __OTGFS_CLK_ENABLE __HAL_RCC_OTGFS_CLK_ENABLE
N#define __OTGFS_CLK_SLEEP_DISABLE __HAL_RCC_OTGFS_CLK_SLEEP_DISABLE
N#define __OTGFS_CLK_SLEEP_ENABLE __HAL_RCC_OTGFS_CLK_SLEEP_ENABLE
N#define __OTGFS_FORCE_RESET __HAL_RCC_OTGFS_FORCE_RESET
N#define __OTGFS_RELEASE_RESET __HAL_RCC_OTGFS_RELEASE_RESET
N#define __PWR_CLK_DISABLE __HAL_RCC_PWR_CLK_DISABLE
N#define __PWR_CLK_ENABLE __HAL_RCC_PWR_CLK_ENABLE
N#define __PWR_CLK_SLEEP_DISABLE __HAL_RCC_PWR_CLK_SLEEP_DISABLE
N#define __PWR_CLK_SLEEP_ENABLE __HAL_RCC_PWR_CLK_SLEEP_ENABLE
N#define __PWR_FORCE_RESET __HAL_RCC_PWR_FORCE_RESET
N#define __PWR_RELEASE_RESET __HAL_RCC_PWR_RELEASE_RESET
N#define __QSPI_CLK_DISABLE __HAL_RCC_QSPI_CLK_DISABLE
N#define __QSPI_CLK_ENABLE __HAL_RCC_QSPI_CLK_ENABLE
N#define __QSPI_CLK_SLEEP_DISABLE __HAL_RCC_QSPI_CLK_SLEEP_DISABLE
N#define __QSPI_CLK_SLEEP_ENABLE __HAL_RCC_QSPI_CLK_SLEEP_ENABLE
N#define __QSPI_FORCE_RESET __HAL_RCC_QSPI_FORCE_RESET
N#define __QSPI_RELEASE_RESET __HAL_RCC_QSPI_RELEASE_RESET
N
N#if defined(STM32WB)
X#if 0L
S#define __HAL_RCC_QSPI_CLK_DISABLE            __HAL_RCC_QUADSPI_CLK_DISABLE
S#define __HAL_RCC_QSPI_CLK_ENABLE             __HAL_RCC_QUADSPI_CLK_ENABLE
S#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE      __HAL_RCC_QUADSPI_CLK_SLEEP_DISABLE
S#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE       __HAL_RCC_QUADSPI_CLK_SLEEP_ENABLE
S#define __HAL_RCC_QSPI_FORCE_RESET            __HAL_RCC_QUADSPI_FORCE_RESET
S#define __HAL_RCC_QSPI_RELEASE_RESET          __HAL_RCC_QUADSPI_RELEASE_RESET
S#define __HAL_RCC_QSPI_IS_CLK_ENABLED         __HAL_RCC_QUADSPI_IS_CLK_ENABLED
S#define __HAL_RCC_QSPI_IS_CLK_DISABLED        __HAL_RCC_QUADSPI_IS_CLK_DISABLED
S#define __HAL_RCC_QSPI_IS_CLK_SLEEP_ENABLED   __HAL_RCC_QUADSPI_IS_CLK_SLEEP_ENABLED
S#define __HAL_RCC_QSPI_IS_CLK_SLEEP_DISABLED  __HAL_RCC_QUADSPI_IS_CLK_SLEEP_DISABLED
S#define QSPI_IRQHandler QUADSPI_IRQHandler
N#endif /* __HAL_RCC_QUADSPI_CLK_ENABLE */
N
N#define __RNG_CLK_DISABLE __HAL_RCC_RNG_CLK_DISABLE
N#define __RNG_CLK_ENABLE __HAL_RCC_RNG_CLK_ENABLE
N#define __RNG_CLK_SLEEP_DISABLE __HAL_RCC_RNG_CLK_SLEEP_DISABLE
N#define __RNG_CLK_SLEEP_ENABLE __HAL_RCC_RNG_CLK_SLEEP_ENABLE
N#define __RNG_FORCE_RESET __HAL_RCC_RNG_FORCE_RESET
N#define __RNG_RELEASE_RESET __HAL_RCC_RNG_RELEASE_RESET
N#define __SAI1_CLK_DISABLE __HAL_RCC_SAI1_CLK_DISABLE
N#define __SAI1_CLK_ENABLE __HAL_RCC_SAI1_CLK_ENABLE
N#define __SAI1_CLK_SLEEP_DISABLE __HAL_RCC_SAI1_CLK_SLEEP_DISABLE
N#define __SAI1_CLK_SLEEP_ENABLE __HAL_RCC_SAI1_CLK_SLEEP_ENABLE
N#define __SAI1_FORCE_RESET __HAL_RCC_SAI1_FORCE_RESET
N#define __SAI1_RELEASE_RESET __HAL_RCC_SAI1_RELEASE_RESET
N#define __SAI2_CLK_DISABLE __HAL_RCC_SAI2_CLK_DISABLE
N#define __SAI2_CLK_ENABLE __HAL_RCC_SAI2_CLK_ENABLE
N#define __SAI2_CLK_SLEEP_DISABLE __HAL_RCC_SAI2_CLK_SLEEP_DISABLE
N#define __SAI2_CLK_SLEEP_ENABLE __HAL_RCC_SAI2_CLK_SLEEP_ENABLE
N#define __SAI2_FORCE_RESET __HAL_RCC_SAI2_FORCE_RESET
N#define __SAI2_RELEASE_RESET __HAL_RCC_SAI2_RELEASE_RESET
N#define __SDIO_CLK_DISABLE __HAL_RCC_SDIO_CLK_DISABLE
N#define __SDIO_CLK_ENABLE __HAL_RCC_SDIO_CLK_ENABLE
N#define __SDMMC_CLK_DISABLE __HAL_RCC_SDMMC_CLK_DISABLE
N#define __SDMMC_CLK_ENABLE __HAL_RCC_SDMMC_CLK_ENABLE
N#define __SDMMC_CLK_SLEEP_DISABLE __HAL_RCC_SDMMC_CLK_SLEEP_DISABLE
N#define __SDMMC_CLK_SLEEP_ENABLE __HAL_RCC_SDMMC_CLK_SLEEP_ENABLE
N#define __SDMMC_FORCE_RESET __HAL_RCC_SDMMC_FORCE_RESET
N#define __SDMMC_RELEASE_RESET __HAL_RCC_SDMMC_RELEASE_RESET
N#define __SPI1_CLK_DISABLE __HAL_RCC_SPI1_CLK_DISABLE
N#define __SPI1_CLK_ENABLE __HAL_RCC_SPI1_CLK_ENABLE
N#define __SPI1_CLK_SLEEP_DISABLE __HAL_RCC_SPI1_CLK_SLEEP_DISABLE
N#define __SPI1_CLK_SLEEP_ENABLE __HAL_RCC_SPI1_CLK_SLEEP_ENABLE
N#define __SPI1_FORCE_RESET __HAL_RCC_SPI1_FORCE_RESET
N#define __SPI1_RELEASE_RESET __HAL_RCC_SPI1_RELEASE_RESET
N#define __SPI2_CLK_DISABLE __HAL_RCC_SPI2_CLK_DISABLE
N#define __SPI2_CLK_ENABLE __HAL_RCC_SPI2_CLK_ENABLE
N#define __SPI2_CLK_SLEEP_DISABLE __HAL_RCC_SPI2_CLK_SLEEP_DISABLE
N#define __SPI2_CLK_SLEEP_ENABLE __HAL_RCC_SPI2_CLK_SLEEP_ENABLE
N#define __SPI2_FORCE_RESET __HAL_RCC_SPI2_FORCE_RESET
N#define __SPI2_RELEASE_RESET __HAL_RCC_SPI2_RELEASE_RESET
N#define __SPI3_CLK_DISABLE __HAL_RCC_SPI3_CLK_DISABLE
N#define __SPI3_CLK_ENABLE __HAL_RCC_SPI3_CLK_ENABLE
N#define __SPI3_CLK_SLEEP_DISABLE __HAL_RCC_SPI3_CLK_SLEEP_DISABLE
N#define __SPI3_CLK_SLEEP_ENABLE __HAL_RCC_SPI3_CLK_SLEEP_ENABLE
N#define __SPI3_FORCE_RESET __HAL_RCC_SPI3_FORCE_RESET
N#define __SPI3_RELEASE_RESET __HAL_RCC_SPI3_RELEASE_RESET
N#define __SRAM_CLK_DISABLE __HAL_RCC_SRAM_CLK_DISABLE
N#define __SRAM_CLK_ENABLE __HAL_RCC_SRAM_CLK_ENABLE
N#define __SRAM1_CLK_SLEEP_DISABLE __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE
N#define __SRAM1_CLK_SLEEP_ENABLE __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE
N#define __SRAM2_CLK_SLEEP_DISABLE __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE
N#define __SRAM2_CLK_SLEEP_ENABLE __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE
N#define __SWPMI1_CLK_DISABLE __HAL_RCC_SWPMI1_CLK_DISABLE
N#define __SWPMI1_CLK_ENABLE __HAL_RCC_SWPMI1_CLK_ENABLE
N#define __SWPMI1_CLK_SLEEP_DISABLE __HAL_RCC_SWPMI1_CLK_SLEEP_DISABLE
N#define __SWPMI1_CLK_SLEEP_ENABLE __HAL_RCC_SWPMI1_CLK_SLEEP_ENABLE
N#define __SWPMI1_FORCE_RESET __HAL_RCC_SWPMI1_FORCE_RESET
N#define __SWPMI1_RELEASE_RESET __HAL_RCC_SWPMI1_RELEASE_RESET
N#define __SYSCFG_CLK_DISABLE __HAL_RCC_SYSCFG_CLK_DISABLE
N#define __SYSCFG_CLK_ENABLE __HAL_RCC_SYSCFG_CLK_ENABLE
N#define __SYSCFG_CLK_SLEEP_DISABLE __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE
N#define __SYSCFG_CLK_SLEEP_ENABLE __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE
N#define __SYSCFG_FORCE_RESET __HAL_RCC_SYSCFG_FORCE_RESET
N#define __SYSCFG_RELEASE_RESET __HAL_RCC_SYSCFG_RELEASE_RESET
N#define __TIM1_CLK_DISABLE __HAL_RCC_TIM1_CLK_DISABLE
N#define __TIM1_CLK_ENABLE __HAL_RCC_TIM1_CLK_ENABLE
N#define __TIM1_CLK_SLEEP_DISABLE __HAL_RCC_TIM1_CLK_SLEEP_DISABLE
N#define __TIM1_CLK_SLEEP_ENABLE __HAL_RCC_TIM1_CLK_SLEEP_ENABLE
N#define __TIM1_FORCE_RESET __HAL_RCC_TIM1_FORCE_RESET
N#define __TIM1_RELEASE_RESET __HAL_RCC_TIM1_RELEASE_RESET
N#define __TIM10_CLK_DISABLE __HAL_RCC_TIM10_CLK_DISABLE
N#define __TIM10_CLK_ENABLE __HAL_RCC_TIM10_CLK_ENABLE
N#define __TIM10_FORCE_RESET __HAL_RCC_TIM10_FORCE_RESET
N#define __TIM10_RELEASE_RESET __HAL_RCC_TIM10_RELEASE_RESET
N#define __TIM11_CLK_DISABLE __HAL_RCC_TIM11_CLK_DISABLE
N#define __TIM11_CLK_ENABLE __HAL_RCC_TIM11_CLK_ENABLE
N#define __TIM11_FORCE_RESET __HAL_RCC_TIM11_FORCE_RESET
N#define __TIM11_RELEASE_RESET __HAL_RCC_TIM11_RELEASE_RESET
N#define __TIM12_CLK_DISABLE __HAL_RCC_TIM12_CLK_DISABLE
N#define __TIM12_CLK_ENABLE __HAL_RCC_TIM12_CLK_ENABLE
N#define __TIM12_FORCE_RESET __HAL_RCC_TIM12_FORCE_RESET
N#define __TIM12_RELEASE_RESET __HAL_RCC_TIM12_RELEASE_RESET
N#define __TIM13_CLK_DISABLE __HAL_RCC_TIM13_CLK_DISABLE
N#define __TIM13_CLK_ENABLE __HAL_RCC_TIM13_CLK_ENABLE
N#define __TIM13_FORCE_RESET __HAL_RCC_TIM13_FORCE_RESET
N#define __TIM13_RELEASE_RESET __HAL_RCC_TIM13_RELEASE_RESET
N#define __TIM14_CLK_DISABLE __HAL_RCC_TIM14_CLK_DISABLE
N#define __TIM14_CLK_ENABLE __HAL_RCC_TIM14_CLK_ENABLE
N#define __TIM14_FORCE_RESET __HAL_RCC_TIM14_FORCE_RESET
N#define __TIM14_RELEASE_RESET __HAL_RCC_TIM14_RELEASE_RESET
N#define __TIM15_CLK_DISABLE __HAL_RCC_TIM15_CLK_DISABLE
N#define __TIM15_CLK_ENABLE __HAL_RCC_TIM15_CLK_ENABLE
N#define __TIM15_CLK_SLEEP_DISABLE __HAL_RCC_TIM15_CLK_SLEEP_DISABLE
N#define __TIM15_CLK_SLEEP_ENABLE __HAL_RCC_TIM15_CLK_SLEEP_ENABLE
N#define __TIM15_FORCE_RESET __HAL_RCC_TIM15_FORCE_RESET
N#define __TIM15_RELEASE_RESET __HAL_RCC_TIM15_RELEASE_RESET
N#define __TIM16_CLK_DISABLE __HAL_RCC_TIM16_CLK_DISABLE
N#define __TIM16_CLK_ENABLE __HAL_RCC_TIM16_CLK_ENABLE
N#define __TIM16_CLK_SLEEP_DISABLE __HAL_RCC_TIM16_CLK_SLEEP_DISABLE
N#define __TIM16_CLK_SLEEP_ENABLE __HAL_RCC_TIM16_CLK_SLEEP_ENABLE
N#define __TIM16_FORCE_RESET __HAL_RCC_TIM16_FORCE_RESET
N#define __TIM16_RELEASE_RESET __HAL_RCC_TIM16_RELEASE_RESET
N#define __TIM17_CLK_DISABLE __HAL_RCC_TIM17_CLK_DISABLE
N#define __TIM17_CLK_ENABLE __HAL_RCC_TIM17_CLK_ENABLE
N#define __TIM17_CLK_SLEEP_DISABLE __HAL_RCC_TIM17_CLK_SLEEP_DISABLE
N#define __TIM17_CLK_SLEEP_ENABLE __HAL_RCC_TIM17_CLK_SLEEP_ENABLE
N#define __TIM17_FORCE_RESET __HAL_RCC_TIM17_FORCE_RESET
N#define __TIM17_RELEASE_RESET __HAL_RCC_TIM17_RELEASE_RESET
N#define __TIM2_CLK_DISABLE __HAL_RCC_TIM2_CLK_DISABLE
N#define __TIM2_CLK_ENABLE __HAL_RCC_TIM2_CLK_ENABLE
N#define __TIM2_CLK_SLEEP_DISABLE __HAL_RCC_TIM2_CLK_SLEEP_DISABLE
N#define __TIM2_CLK_SLEEP_ENABLE __HAL_RCC_TIM2_CLK_SLEEP_ENABLE
N#define __TIM2_FORCE_RESET __HAL_RCC_TIM2_FORCE_RESET
N#define __TIM2_RELEASE_RESET __HAL_RCC_TIM2_RELEASE_RESET
N#define __TIM3_CLK_DISABLE __HAL_RCC_TIM3_CLK_DISABLE
N#define __TIM3_CLK_ENABLE __HAL_RCC_TIM3_CLK_ENABLE
N#define __TIM3_CLK_SLEEP_DISABLE __HAL_RCC_TIM3_CLK_SLEEP_DISABLE
N#define __TIM3_CLK_SLEEP_ENABLE __HAL_RCC_TIM3_CLK_SLEEP_ENABLE
N#define __TIM3_FORCE_RESET __HAL_RCC_TIM3_FORCE_RESET
N#define __TIM3_RELEASE_RESET __HAL_RCC_TIM3_RELEASE_RESET
N#define __TIM4_CLK_DISABLE __HAL_RCC_TIM4_CLK_DISABLE
N#define __TIM4_CLK_ENABLE __HAL_RCC_TIM4_CLK_ENABLE
N#define __TIM4_CLK_SLEEP_DISABLE __HAL_RCC_TIM4_CLK_SLEEP_DISABLE
N#define __TIM4_CLK_SLEEP_ENABLE __HAL_RCC_TIM4_CLK_SLEEP_ENABLE
N#define __TIM4_FORCE_RESET __HAL_RCC_TIM4_FORCE_RESET
N#define __TIM4_RELEASE_RESET __HAL_RCC_TIM4_RELEASE_RESET
N#define __TIM5_CLK_DISABLE __HAL_RCC_TIM5_CLK_DISABLE
N#define __TIM5_CLK_ENABLE __HAL_RCC_TIM5_CLK_ENABLE
N#define __TIM5_CLK_SLEEP_DISABLE __HAL_RCC_TIM5_CLK_SLEEP_DISABLE
N#define __TIM5_CLK_SLEEP_ENABLE __HAL_RCC_TIM5_CLK_SLEEP_ENABLE
N#define __TIM5_FORCE_RESET __HAL_RCC_TIM5_FORCE_RESET
N#define __TIM5_RELEASE_RESET __HAL_RCC_TIM5_RELEASE_RESET
N#define __TIM6_CLK_DISABLE __HAL_RCC_TIM6_CLK_DISABLE
N#define __TIM6_CLK_ENABLE __HAL_RCC_TIM6_CLK_ENABLE
N#define __TIM6_CLK_SLEEP_DISABLE __HAL_RCC_TIM6_CLK_SLEEP_DISABLE
N#define __TIM6_CLK_SLEEP_ENABLE __HAL_RCC_TIM6_CLK_SLEEP_ENABLE
N#define __TIM6_FORCE_RESET __HAL_RCC_TIM6_FORCE_RESET
N#define __TIM6_RELEASE_RESET __HAL_RCC_TIM6_RELEASE_RESET
N#define __TIM7_CLK_DISABLE __HAL_RCC_TIM7_CLK_DISABLE
N#define __TIM7_CLK_ENABLE __HAL_RCC_TIM7_CLK_ENABLE
N#define __TIM7_CLK_SLEEP_DISABLE __HAL_RCC_TIM7_CLK_SLEEP_DISABLE
N#define __TIM7_CLK_SLEEP_ENABLE __HAL_RCC_TIM7_CLK_SLEEP_ENABLE
N#define __TIM7_FORCE_RESET __HAL_RCC_TIM7_FORCE_RESET
N#define __TIM7_RELEASE_RESET __HAL_RCC_TIM7_RELEASE_RESET
N#define __TIM8_CLK_DISABLE __HAL_RCC_TIM8_CLK_DISABLE
N#define __TIM8_CLK_ENABLE __HAL_RCC_TIM8_CLK_ENABLE
N#define __TIM8_CLK_SLEEP_DISABLE __HAL_RCC_TIM8_CLK_SLEEP_DISABLE
N#define __TIM8_CLK_SLEEP_ENABLE __HAL_RCC_TIM8_CLK_SLEEP_ENABLE
N#define __TIM8_FORCE_RESET __HAL_RCC_TIM8_FORCE_RESET
N#define __TIM8_RELEASE_RESET __HAL_RCC_TIM8_RELEASE_RESET
N#define __TIM9_CLK_DISABLE __HAL_RCC_TIM9_CLK_DISABLE
N#define __TIM9_CLK_ENABLE __HAL_RCC_TIM9_CLK_ENABLE
N#define __TIM9_FORCE_RESET __HAL_RCC_TIM9_FORCE_RESET
N#define __TIM9_RELEASE_RESET __HAL_RCC_TIM9_RELEASE_RESET
N#define __TSC_CLK_DISABLE __HAL_RCC_TSC_CLK_DISABLE
N#define __TSC_CLK_ENABLE __HAL_RCC_TSC_CLK_ENABLE
N#define __TSC_CLK_SLEEP_DISABLE __HAL_RCC_TSC_CLK_SLEEP_DISABLE
N#define __TSC_CLK_SLEEP_ENABLE __HAL_RCC_TSC_CLK_SLEEP_ENABLE
N#define __TSC_FORCE_RESET __HAL_RCC_TSC_FORCE_RESET
N#define __TSC_RELEASE_RESET __HAL_RCC_TSC_RELEASE_RESET
N#define __UART4_CLK_DISABLE __HAL_RCC_UART4_CLK_DISABLE
N#define __UART4_CLK_ENABLE __HAL_RCC_UART4_CLK_ENABLE
N#define __UART4_CLK_SLEEP_DISABLE __HAL_RCC_UART4_CLK_SLEEP_DISABLE
N#define __UART4_CLK_SLEEP_ENABLE __HAL_RCC_UART4_CLK_SLEEP_ENABLE
N#define __UART4_FORCE_RESET __HAL_RCC_UART4_FORCE_RESET
N#define __UART4_RELEASE_RESET __HAL_RCC_UART4_RELEASE_RESET
N#define __UART5_CLK_DISABLE __HAL_RCC_UART5_CLK_DISABLE
N#define __UART5_CLK_ENABLE __HAL_RCC_UART5_CLK_ENABLE
N#define __UART5_CLK_SLEEP_DISABLE __HAL_RCC_UART5_CLK_SLEEP_DISABLE
N#define __UART5_CLK_SLEEP_ENABLE __HAL_RCC_UART5_CLK_SLEEP_ENABLE
N#define __UART5_FORCE_RESET __HAL_RCC_UART5_FORCE_RESET
N#define __UART5_RELEASE_RESET __HAL_RCC_UART5_RELEASE_RESET
N#define __USART1_CLK_DISABLE __HAL_RCC_USART1_CLK_DISABLE
N#define __USART1_CLK_ENABLE __HAL_RCC_USART1_CLK_ENABLE
N#define __USART1_CLK_SLEEP_DISABLE __HAL_RCC_USART1_CLK_SLEEP_DISABLE
N#define __USART1_CLK_SLEEP_ENABLE __HAL_RCC_USART1_CLK_SLEEP_ENABLE
N#define __USART1_FORCE_RESET __HAL_RCC_USART1_FORCE_RESET
N#define __USART1_RELEASE_RESET __HAL_RCC_USART1_RELEASE_RESET
N#define __USART2_CLK_DISABLE __HAL_RCC_USART2_CLK_DISABLE
N#define __USART2_CLK_ENABLE __HAL_RCC_USART2_CLK_ENABLE
N#define __USART2_CLK_SLEEP_DISABLE __HAL_RCC_USART2_CLK_SLEEP_DISABLE
N#define __USART2_CLK_SLEEP_ENABLE __HAL_RCC_USART2_CLK_SLEEP_ENABLE
N#define __USART2_FORCE_RESET __HAL_RCC_USART2_FORCE_RESET
N#define __USART2_RELEASE_RESET __HAL_RCC_USART2_RELEASE_RESET
N#define __USART3_CLK_DISABLE __HAL_RCC_USART3_CLK_DISABLE
N#define __USART3_CLK_ENABLE __HAL_RCC_USART3_CLK_ENABLE
N#define __USART3_CLK_SLEEP_DISABLE __HAL_RCC_USART3_CLK_SLEEP_DISABLE
N#define __USART3_CLK_SLEEP_ENABLE __HAL_RCC_USART3_CLK_SLEEP_ENABLE
N#define __USART3_FORCE_RESET __HAL_RCC_USART3_FORCE_RESET
N#define __USART3_RELEASE_RESET __HAL_RCC_USART3_RELEASE_RESET
N#define __USART4_CLK_DISABLE        __HAL_RCC_UART4_CLK_DISABLE
N#define __USART4_CLK_ENABLE         __HAL_RCC_UART4_CLK_ENABLE
N#define __USART4_CLK_SLEEP_ENABLE   __HAL_RCC_UART4_CLK_SLEEP_ENABLE
N#define __USART4_CLK_SLEEP_DISABLE  __HAL_RCC_UART4_CLK_SLEEP_DISABLE
N#define __USART4_FORCE_RESET        __HAL_RCC_UART4_FORCE_RESET
N#define __USART4_RELEASE_RESET      __HAL_RCC_UART4_RELEASE_RESET
N#define __USART5_CLK_DISABLE        __HAL_RCC_UART5_CLK_DISABLE
N#define __USART5_CLK_ENABLE         __HAL_RCC_UART5_CLK_ENABLE
N#define __USART5_CLK_SLEEP_ENABLE   __HAL_RCC_UART5_CLK_SLEEP_ENABLE
N#define __USART5_CLK_SLEEP_DISABLE  __HAL_RCC_UART5_CLK_SLEEP_DISABLE
N#define __USART5_FORCE_RESET        __HAL_RCC_UART5_FORCE_RESET
N#define __USART5_RELEASE_RESET      __HAL_RCC_UART5_RELEASE_RESET
N#define __USART7_CLK_DISABLE        __HAL_RCC_UART7_CLK_DISABLE
N#define __USART7_CLK_ENABLE         __HAL_RCC_UART7_CLK_ENABLE
N#define __USART7_FORCE_RESET        __HAL_RCC_UART7_FORCE_RESET
N#define __USART7_RELEASE_RESET      __HAL_RCC_UART7_RELEASE_RESET
N#define __USART8_CLK_DISABLE        __HAL_RCC_UART8_CLK_DISABLE
N#define __USART8_CLK_ENABLE         __HAL_RCC_UART8_CLK_ENABLE
N#define __USART8_FORCE_RESET        __HAL_RCC_UART8_FORCE_RESET
N#define __USART8_RELEASE_RESET      __HAL_RCC_UART8_RELEASE_RESET
N#define __USB_CLK_DISABLE         __HAL_RCC_USB_CLK_DISABLE
N#define __USB_CLK_ENABLE          __HAL_RCC_USB_CLK_ENABLE
N#define __USB_FORCE_RESET         __HAL_RCC_USB_FORCE_RESET
N#define __USB_CLK_SLEEP_ENABLE    __HAL_RCC_USB_CLK_SLEEP_ENABLE
N#define __USB_CLK_SLEEP_DISABLE   __HAL_RCC_USB_CLK_SLEEP_DISABLE
N#define __USB_OTG_FS_CLK_DISABLE __HAL_RCC_USB_OTG_FS_CLK_DISABLE
N#define __USB_OTG_FS_CLK_ENABLE __HAL_RCC_USB_OTG_FS_CLK_ENABLE
N#define __USB_RELEASE_RESET __HAL_RCC_USB_RELEASE_RESET
N#define __WWDG_CLK_DISABLE __HAL_RCC_WWDG_CLK_DISABLE
N#define __WWDG_CLK_ENABLE __HAL_RCC_WWDG_CLK_ENABLE
N#define __WWDG_CLK_SLEEP_DISABLE __HAL_RCC_WWDG_CLK_SLEEP_DISABLE
N#define __WWDG_CLK_SLEEP_ENABLE __HAL_RCC_WWDG_CLK_SLEEP_ENABLE
N#define __WWDG_FORCE_RESET __HAL_RCC_WWDG_FORCE_RESET
N#define __WWDG_RELEASE_RESET __HAL_RCC_WWDG_RELEASE_RESET
N#define __TIM21_CLK_ENABLE   __HAL_RCC_TIM21_CLK_ENABLE
N#define __TIM21_CLK_DISABLE   __HAL_RCC_TIM21_CLK_DISABLE
N#define __TIM21_FORCE_RESET   __HAL_RCC_TIM21_FORCE_RESET
N#define __TIM21_RELEASE_RESET  __HAL_RCC_TIM21_RELEASE_RESET
N#define __TIM21_CLK_SLEEP_ENABLE   __HAL_RCC_TIM21_CLK_SLEEP_ENABLE
N#define __TIM21_CLK_SLEEP_DISABLE   __HAL_RCC_TIM21_CLK_SLEEP_DISABLE
N#define __TIM22_CLK_ENABLE   __HAL_RCC_TIM22_CLK_ENABLE
N#define __TIM22_CLK_DISABLE   __HAL_RCC_TIM22_CLK_DISABLE
N#define __TIM22_FORCE_RESET   __HAL_RCC_TIM22_FORCE_RESET
N#define __TIM22_RELEASE_RESET  __HAL_RCC_TIM22_RELEASE_RESET
N#define __TIM22_CLK_SLEEP_ENABLE   __HAL_RCC_TIM22_CLK_SLEEP_ENABLE
N#define __TIM22_CLK_SLEEP_DISABLE   __HAL_RCC_TIM22_CLK_SLEEP_DISABLE
N#define __CRS_CLK_DISABLE __HAL_RCC_CRS_CLK_DISABLE
N#define __CRS_CLK_ENABLE __HAL_RCC_CRS_CLK_ENABLE
N#define __CRS_CLK_SLEEP_DISABLE __HAL_RCC_CRS_CLK_SLEEP_DISABLE
N#define __CRS_CLK_SLEEP_ENABLE __HAL_RCC_CRS_CLK_SLEEP_ENABLE
N#define __CRS_FORCE_RESET __HAL_RCC_CRS_FORCE_RESET
N#define __CRS_RELEASE_RESET __HAL_RCC_CRS_RELEASE_RESET
N#define __RCC_BACKUPRESET_FORCE __HAL_RCC_BACKUPRESET_FORCE
N#define __RCC_BACKUPRESET_RELEASE __HAL_RCC_BACKUPRESET_RELEASE
N
N#define __USB_OTG_FS_FORCE_RESET  __HAL_RCC_USB_OTG_FS_FORCE_RESET
N#define __USB_OTG_FS_RELEASE_RESET  __HAL_RCC_USB_OTG_FS_RELEASE_RESET
N#define __USB_OTG_FS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE
N#define __USB_OTG_FS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE
N#define __USB_OTG_HS_CLK_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_DISABLE
N#define __USB_OTG_HS_CLK_ENABLE          __HAL_RCC_USB_OTG_HS_CLK_ENABLE
N#define __USB_OTG_HS_ULPI_CLK_ENABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE
N#define __USB_OTG_HS_ULPI_CLK_DISABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE
N#define __TIM9_CLK_SLEEP_ENABLE          __HAL_RCC_TIM9_CLK_SLEEP_ENABLE
N#define __TIM9_CLK_SLEEP_DISABLE  __HAL_RCC_TIM9_CLK_SLEEP_DISABLE
N#define __TIM10_CLK_SLEEP_ENABLE  __HAL_RCC_TIM10_CLK_SLEEP_ENABLE
N#define __TIM10_CLK_SLEEP_DISABLE  __HAL_RCC_TIM10_CLK_SLEEP_DISABLE
N#define __TIM11_CLK_SLEEP_ENABLE  __HAL_RCC_TIM11_CLK_SLEEP_ENABLE
N#define __TIM11_CLK_SLEEP_DISABLE  __HAL_RCC_TIM11_CLK_SLEEP_DISABLE
N#define __ETHMACPTP_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE
N#define __ETHMACPTP_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE
N#define __ETHMACPTP_CLK_ENABLE          __HAL_RCC_ETHMACPTP_CLK_ENABLE
N#define __ETHMACPTP_CLK_DISABLE          __HAL_RCC_ETHMACPTP_CLK_DISABLE
N#define __HASH_CLK_ENABLE          __HAL_RCC_HASH_CLK_ENABLE
N#define __HASH_FORCE_RESET          __HAL_RCC_HASH_FORCE_RESET
N#define __HASH_RELEASE_RESET          __HAL_RCC_HASH_RELEASE_RESET
N#define __HASH_CLK_SLEEP_ENABLE          __HAL_RCC_HASH_CLK_SLEEP_ENABLE
N#define __HASH_CLK_SLEEP_DISABLE  __HAL_RCC_HASH_CLK_SLEEP_DISABLE
N#define __HASH_CLK_DISABLE            __HAL_RCC_HASH_CLK_DISABLE
N#define __SPI5_CLK_ENABLE          __HAL_RCC_SPI5_CLK_ENABLE
N#define __SPI5_CLK_DISABLE              __HAL_RCC_SPI5_CLK_DISABLE
N#define __SPI5_FORCE_RESET          __HAL_RCC_SPI5_FORCE_RESET
N#define __SPI5_RELEASE_RESET          __HAL_RCC_SPI5_RELEASE_RESET
N#define __SPI5_CLK_SLEEP_ENABLE          __HAL_RCC_SPI5_CLK_SLEEP_ENABLE
N#define __SPI5_CLK_SLEEP_DISABLE  __HAL_RCC_SPI5_CLK_SLEEP_DISABLE
N#define __SPI6_CLK_ENABLE          __HAL_RCC_SPI6_CLK_ENABLE
N#define __SPI6_CLK_DISABLE          __HAL_RCC_SPI6_CLK_DISABLE
N#define __SPI6_FORCE_RESET          __HAL_RCC_SPI6_FORCE_RESET
N#define __SPI6_RELEASE_RESET         __HAL_RCC_SPI6_RELEASE_RESET
N#define __SPI6_CLK_SLEEP_ENABLE          __HAL_RCC_SPI6_CLK_SLEEP_ENABLE
N#define __SPI6_CLK_SLEEP_DISABLE  __HAL_RCC_SPI6_CLK_SLEEP_DISABLE
N#define __LTDC_CLK_ENABLE          __HAL_RCC_LTDC_CLK_ENABLE
N#define __LTDC_CLK_DISABLE          __HAL_RCC_LTDC_CLK_DISABLE
N#define __LTDC_FORCE_RESET          __HAL_RCC_LTDC_FORCE_RESET
N#define __LTDC_RELEASE_RESET          __HAL_RCC_LTDC_RELEASE_RESET
N#define __LTDC_CLK_SLEEP_ENABLE          __HAL_RCC_LTDC_CLK_SLEEP_ENABLE
N#define __ETHMAC_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE
N#define __ETHMAC_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE
N#define __ETHMACTX_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE
N#define __ETHMACTX_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE
N#define __ETHMACRX_CLK_SLEEP_ENABLE  __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE
N#define __ETHMACRX_CLK_SLEEP_DISABLE  __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE
N#define __TIM12_CLK_SLEEP_ENABLE  __HAL_RCC_TIM12_CLK_SLEEP_ENABLE
N#define __TIM12_CLK_SLEEP_DISABLE  __HAL_RCC_TIM12_CLK_SLEEP_DISABLE
N#define __TIM13_CLK_SLEEP_ENABLE  __HAL_RCC_TIM13_CLK_SLEEP_ENABLE
N#define __TIM13_CLK_SLEEP_DISABLE  __HAL_RCC_TIM13_CLK_SLEEP_DISABLE
N#define __TIM14_CLK_SLEEP_ENABLE  __HAL_RCC_TIM14_CLK_SLEEP_ENABLE
N#define __TIM14_CLK_SLEEP_DISABLE  __HAL_RCC_TIM14_CLK_SLEEP_DISABLE
N#define __BKPSRAM_CLK_ENABLE          __HAL_RCC_BKPSRAM_CLK_ENABLE
N#define __BKPSRAM_CLK_DISABLE          __HAL_RCC_BKPSRAM_CLK_DISABLE
N#define __BKPSRAM_CLK_SLEEP_ENABLE  __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE
N#define __BKPSRAM_CLK_SLEEP_DISABLE  __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE
N#define __CCMDATARAMEN_CLK_ENABLE  __HAL_RCC_CCMDATARAMEN_CLK_ENABLE
N#define __CCMDATARAMEN_CLK_DISABLE  __HAL_RCC_CCMDATARAMEN_CLK_DISABLE
N#define __USART6_CLK_ENABLE          __HAL_RCC_USART6_CLK_ENABLE
N#define __USART6_CLK_DISABLE          __HAL_RCC_USART6_CLK_DISABLE
N#define __USART6_FORCE_RESET        __HAL_RCC_USART6_FORCE_RESET
N#define __USART6_RELEASE_RESET        __HAL_RCC_USART6_RELEASE_RESET
N#define __USART6_CLK_SLEEP_ENABLE  __HAL_RCC_USART6_CLK_SLEEP_ENABLE
N#define __USART6_CLK_SLEEP_DISABLE  __HAL_RCC_USART6_CLK_SLEEP_DISABLE
N#define __SPI4_CLK_ENABLE          __HAL_RCC_SPI4_CLK_ENABLE
N#define __SPI4_CLK_DISABLE          __HAL_RCC_SPI4_CLK_DISABLE
N#define __SPI4_FORCE_RESET          __HAL_RCC_SPI4_FORCE_RESET
N#define __SPI4_RELEASE_RESET        __HAL_RCC_SPI4_RELEASE_RESET
N#define __SPI4_CLK_SLEEP_ENABLE   __HAL_RCC_SPI4_CLK_SLEEP_ENABLE
N#define __SPI4_CLK_SLEEP_DISABLE  __HAL_RCC_SPI4_CLK_SLEEP_DISABLE
N#define __GPIOI_CLK_ENABLE          __HAL_RCC_GPIOI_CLK_ENABLE
N#define __GPIOI_CLK_DISABLE          __HAL_RCC_GPIOI_CLK_DISABLE
N#define __GPIOI_FORCE_RESET          __HAL_RCC_GPIOI_FORCE_RESET
N#define __GPIOI_RELEASE_RESET          __HAL_RCC_GPIOI_RELEASE_RESET
N#define __GPIOI_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE
N#define __GPIOI_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE
N#define __GPIOJ_CLK_ENABLE          __HAL_RCC_GPIOJ_CLK_ENABLE
N#define __GPIOJ_CLK_DISABLE          __HAL_RCC_GPIOJ_CLK_DISABLE
N#define __GPIOJ_FORCE_RESET         __HAL_RCC_GPIOJ_FORCE_RESET
N#define __GPIOJ_RELEASE_RESET          __HAL_RCC_GPIOJ_RELEASE_RESET
N#define __GPIOJ_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE
N#define __GPIOJ_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE
N#define __GPIOK_CLK_ENABLE          __HAL_RCC_GPIOK_CLK_ENABLE
N#define __GPIOK_CLK_DISABLE          __HAL_RCC_GPIOK_CLK_DISABLE
N#define __GPIOK_RELEASE_RESET          __HAL_RCC_GPIOK_RELEASE_RESET
N#define __GPIOK_CLK_SLEEP_ENABLE  __HAL_RCC_GPIOK_CLK_SLEEP_ENABLE
N#define __GPIOK_CLK_SLEEP_DISABLE  __HAL_RCC_GPIOK_CLK_SLEEP_DISABLE
N#define __ETH_CLK_ENABLE          __HAL_RCC_ETH_CLK_ENABLE
N#define __ETH_CLK_DISABLE          __HAL_RCC_ETH_CLK_DISABLE
N#define __DCMI_CLK_ENABLE          __HAL_RCC_DCMI_CLK_ENABLE
N#define __DCMI_CLK_DISABLE          __HAL_RCC_DCMI_CLK_DISABLE
N#define __DCMI_FORCE_RESET          __HAL_RCC_DCMI_FORCE_RESET
N#define __DCMI_RELEASE_RESET          __HAL_RCC_DCMI_RELEASE_RESET
N#define __DCMI_CLK_SLEEP_ENABLE   __HAL_RCC_DCMI_CLK_SLEEP_ENABLE
N#define __DCMI_CLK_SLEEP_DISABLE  __HAL_RCC_DCMI_CLK_SLEEP_DISABLE
N#define __UART7_CLK_ENABLE          __HAL_RCC_UART7_CLK_ENABLE
N#define __UART7_CLK_DISABLE          __HAL_RCC_UART7_CLK_DISABLE
N#define __UART7_RELEASE_RESET       __HAL_RCC_UART7_RELEASE_RESET
N#define __UART7_FORCE_RESET       __HAL_RCC_UART7_FORCE_RESET
N#define __UART7_CLK_SLEEP_ENABLE  __HAL_RCC_UART7_CLK_SLEEP_ENABLE
N#define __UART7_CLK_SLEEP_DISABLE  __HAL_RCC_UART7_CLK_SLEEP_DISABLE
N#define __UART8_CLK_ENABLE          __HAL_RCC_UART8_CLK_ENABLE
N#define __UART8_CLK_DISABLE          __HAL_RCC_UART8_CLK_DISABLE
N#define __UART8_FORCE_RESET          __HAL_RCC_UART8_FORCE_RESET
N#define __UART8_RELEASE_RESET          __HAL_RCC_UART8_RELEASE_RESET
N#define __UART8_CLK_SLEEP_ENABLE  __HAL_RCC_UART8_CLK_SLEEP_ENABLE
N#define __UART8_CLK_SLEEP_DISABLE  __HAL_RCC_UART8_CLK_SLEEP_DISABLE
N#define __OTGHS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
N#define __OTGHS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
N#define __OTGHS_FORCE_RESET          __HAL_RCC_USB_OTG_HS_FORCE_RESET
N#define __OTGHS_RELEASE_RESET          __HAL_RCC_USB_OTG_HS_RELEASE_RESET
N#define __OTGHSULPI_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
N#define __OTGHSULPI_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
N#define __HAL_RCC_OTGHS_CLK_SLEEP_ENABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
N#define __HAL_RCC_OTGHS_CLK_SLEEP_DISABLE  __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
N#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_ENABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_DISABLED
N#define __HAL_RCC_OTGHS_FORCE_RESET          __HAL_RCC_USB_OTG_HS_FORCE_RESET
N#define __HAL_RCC_OTGHS_RELEASE_RESET          __HAL_RCC_USB_OTG_HS_RELEASE_RESET
N#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_ENABLE      __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
N#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_DISABLE     __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
N#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_ENABLED  __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_DISABLED
N#define __SRAM3_CLK_SLEEP_ENABLE       __HAL_RCC_SRAM3_CLK_SLEEP_ENABLE
N#define __CAN2_CLK_SLEEP_ENABLE        __HAL_RCC_CAN2_CLK_SLEEP_ENABLE
N#define __CAN2_CLK_SLEEP_DISABLE       __HAL_RCC_CAN2_CLK_SLEEP_DISABLE
N#define __DAC_CLK_SLEEP_ENABLE         __HAL_RCC_DAC_CLK_SLEEP_ENABLE
N#define __DAC_CLK_SLEEP_DISABLE        __HAL_RCC_DAC_CLK_SLEEP_DISABLE
N#define __ADC2_CLK_SLEEP_ENABLE        __HAL_RCC_ADC2_CLK_SLEEP_ENABLE
N#define __ADC2_CLK_SLEEP_DISABLE       __HAL_RCC_ADC2_CLK_SLEEP_DISABLE
N#define __ADC3_CLK_SLEEP_ENABLE        __HAL_RCC_ADC3_CLK_SLEEP_ENABLE
N#define __ADC3_CLK_SLEEP_DISABLE       __HAL_RCC_ADC3_CLK_SLEEP_DISABLE
N#define __FSMC_FORCE_RESET             __HAL_RCC_FSMC_FORCE_RESET
N#define __FSMC_RELEASE_RESET           __HAL_RCC_FSMC_RELEASE_RESET
N#define __FSMC_CLK_SLEEP_ENABLE        __HAL_RCC_FSMC_CLK_SLEEP_ENABLE
N#define __FSMC_CLK_SLEEP_DISABLE       __HAL_RCC_FSMC_CLK_SLEEP_DISABLE
N#define __SDIO_FORCE_RESET             __HAL_RCC_SDIO_FORCE_RESET
N#define __SDIO_RELEASE_RESET           __HAL_RCC_SDIO_RELEASE_RESET
N#define __SDIO_CLK_SLEEP_DISABLE       __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
N#define __SDIO_CLK_SLEEP_ENABLE        __HAL_RCC_SDIO_CLK_SLEEP_ENABLE
N#define __DMA2D_CLK_ENABLE             __HAL_RCC_DMA2D_CLK_ENABLE
N#define __DMA2D_CLK_DISABLE            __HAL_RCC_DMA2D_CLK_DISABLE
N#define __DMA2D_FORCE_RESET            __HAL_RCC_DMA2D_FORCE_RESET
N#define __DMA2D_RELEASE_RESET          __HAL_RCC_DMA2D_RELEASE_RESET
N#define __DMA2D_CLK_SLEEP_ENABLE       __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE
N#define __DMA2D_CLK_SLEEP_DISABLE      __HAL_RCC_DMA2D_CLK_SLEEP_DISABLE
N
N/* alias define maintained for legacy */
N#define __HAL_RCC_OTGFS_FORCE_RESET    __HAL_RCC_USB_OTG_FS_FORCE_RESET
N#define __HAL_RCC_OTGFS_RELEASE_RESET  __HAL_RCC_USB_OTG_FS_RELEASE_RESET
N
N#define __ADC12_CLK_ENABLE          __HAL_RCC_ADC12_CLK_ENABLE
N#define __ADC12_CLK_DISABLE         __HAL_RCC_ADC12_CLK_DISABLE
N#define __ADC34_CLK_ENABLE          __HAL_RCC_ADC34_CLK_ENABLE
N#define __ADC34_CLK_DISABLE         __HAL_RCC_ADC34_CLK_DISABLE
N#define __DAC2_CLK_ENABLE           __HAL_RCC_DAC2_CLK_ENABLE
N#define __DAC2_CLK_DISABLE          __HAL_RCC_DAC2_CLK_DISABLE
N#define __TIM18_CLK_ENABLE          __HAL_RCC_TIM18_CLK_ENABLE
N#define __TIM18_CLK_DISABLE         __HAL_RCC_TIM18_CLK_DISABLE
N#define __TIM19_CLK_ENABLE          __HAL_RCC_TIM19_CLK_ENABLE
N#define __TIM19_CLK_DISABLE         __HAL_RCC_TIM19_CLK_DISABLE
N#define __TIM20_CLK_ENABLE          __HAL_RCC_TIM20_CLK_ENABLE
N#define __TIM20_CLK_DISABLE         __HAL_RCC_TIM20_CLK_DISABLE
N#define __HRTIM1_CLK_ENABLE         __HAL_RCC_HRTIM1_CLK_ENABLE
N#define __HRTIM1_CLK_DISABLE        __HAL_RCC_HRTIM1_CLK_DISABLE
N#define __SDADC1_CLK_ENABLE         __HAL_RCC_SDADC1_CLK_ENABLE
N#define __SDADC2_CLK_ENABLE         __HAL_RCC_SDADC2_CLK_ENABLE
N#define __SDADC3_CLK_ENABLE         __HAL_RCC_SDADC3_CLK_ENABLE
N#define __SDADC1_CLK_DISABLE        __HAL_RCC_SDADC1_CLK_DISABLE
N#define __SDADC2_CLK_DISABLE        __HAL_RCC_SDADC2_CLK_DISABLE
N#define __SDADC3_CLK_DISABLE        __HAL_RCC_SDADC3_CLK_DISABLE
N
N#define __ADC12_FORCE_RESET         __HAL_RCC_ADC12_FORCE_RESET
N#define __ADC12_RELEASE_RESET       __HAL_RCC_ADC12_RELEASE_RESET
N#define __ADC34_FORCE_RESET         __HAL_RCC_ADC34_FORCE_RESET
N#define __ADC34_RELEASE_RESET       __HAL_RCC_ADC34_RELEASE_RESET
N#define __DAC2_FORCE_RESET          __HAL_RCC_DAC2_FORCE_RESET
N#define __DAC2_RELEASE_RESET        __HAL_RCC_DAC2_RELEASE_RESET
N#define __TIM18_FORCE_RESET         __HAL_RCC_TIM18_FORCE_RESET
N#define __TIM18_RELEASE_RESET       __HAL_RCC_TIM18_RELEASE_RESET
N#define __TIM19_FORCE_RESET         __HAL_RCC_TIM19_FORCE_RESET
N#define __TIM19_RELEASE_RESET       __HAL_RCC_TIM19_RELEASE_RESET
N#define __TIM20_FORCE_RESET         __HAL_RCC_TIM20_FORCE_RESET
N#define __TIM20_RELEASE_RESET       __HAL_RCC_TIM20_RELEASE_RESET
N#define __HRTIM1_FORCE_RESET        __HAL_RCC_HRTIM1_FORCE_RESET
N#define __HRTIM1_RELEASE_RESET      __HAL_RCC_HRTIM1_RELEASE_RESET
N#define __SDADC1_FORCE_RESET        __HAL_RCC_SDADC1_FORCE_RESET
N#define __SDADC2_FORCE_RESET        __HAL_RCC_SDADC2_FORCE_RESET
N#define __SDADC3_FORCE_RESET        __HAL_RCC_SDADC3_FORCE_RESET
N#define __SDADC1_RELEASE_RESET      __HAL_RCC_SDADC1_RELEASE_RESET
N#define __SDADC2_RELEASE_RESET      __HAL_RCC_SDADC2_RELEASE_RESET
N#define __SDADC3_RELEASE_RESET      __HAL_RCC_SDADC3_RELEASE_RESET
N
N#define __ADC1_IS_CLK_ENABLED       __HAL_RCC_ADC1_IS_CLK_ENABLED
N#define __ADC1_IS_CLK_DISABLED      __HAL_RCC_ADC1_IS_CLK_DISABLED
N#define __ADC12_IS_CLK_ENABLED      __HAL_RCC_ADC12_IS_CLK_ENABLED
N#define __ADC12_IS_CLK_DISABLED     __HAL_RCC_ADC12_IS_CLK_DISABLED
N#define __ADC34_IS_CLK_ENABLED      __HAL_RCC_ADC34_IS_CLK_ENABLED
N#define __ADC34_IS_CLK_DISABLED     __HAL_RCC_ADC34_IS_CLK_DISABLED
N#define __CEC_IS_CLK_ENABLED        __HAL_RCC_CEC_IS_CLK_ENABLED
N#define __CEC_IS_CLK_DISABLED       __HAL_RCC_CEC_IS_CLK_DISABLED
N#define __CRC_IS_CLK_ENABLED        __HAL_RCC_CRC_IS_CLK_ENABLED
N#define __CRC_IS_CLK_DISABLED       __HAL_RCC_CRC_IS_CLK_DISABLED
N#define __DAC1_IS_CLK_ENABLED       __HAL_RCC_DAC1_IS_CLK_ENABLED
N#define __DAC1_IS_CLK_DISABLED      __HAL_RCC_DAC1_IS_CLK_DISABLED
N#define __DAC2_IS_CLK_ENABLED       __HAL_RCC_DAC2_IS_CLK_ENABLED
N#define __DAC2_IS_CLK_DISABLED      __HAL_RCC_DAC2_IS_CLK_DISABLED
N#define __DMA1_IS_CLK_ENABLED       __HAL_RCC_DMA1_IS_CLK_ENABLED
N#define __DMA1_IS_CLK_DISABLED      __HAL_RCC_DMA1_IS_CLK_DISABLED
N#define __DMA2_IS_CLK_ENABLED       __HAL_RCC_DMA2_IS_CLK_ENABLED
N#define __DMA2_IS_CLK_DISABLED      __HAL_RCC_DMA2_IS_CLK_DISABLED
N#define __FLITF_IS_CLK_ENABLED      __HAL_RCC_FLITF_IS_CLK_ENABLED
N#define __FLITF_IS_CLK_DISABLED     __HAL_RCC_FLITF_IS_CLK_DISABLED
N#define __FMC_IS_CLK_ENABLED        __HAL_RCC_FMC_IS_CLK_ENABLED
N#define __FMC_IS_CLK_DISABLED       __HAL_RCC_FMC_IS_CLK_DISABLED
N#define __GPIOA_IS_CLK_ENABLED      __HAL_RCC_GPIOA_IS_CLK_ENABLED
N#define __GPIOA_IS_CLK_DISABLED     __HAL_RCC_GPIOA_IS_CLK_DISABLED
N#define __GPIOB_IS_CLK_ENABLED      __HAL_RCC_GPIOB_IS_CLK_ENABLED
N#define __GPIOB_IS_CLK_DISABLED     __HAL_RCC_GPIOB_IS_CLK_DISABLED
N#define __GPIOC_IS_CLK_ENABLED      __HAL_RCC_GPIOC_IS_CLK_ENABLED
N#define __GPIOC_IS_CLK_DISABLED     __HAL_RCC_GPIOC_IS_CLK_DISABLED
N#define __GPIOD_IS_CLK_ENABLED      __HAL_RCC_GPIOD_IS_CLK_ENABLED
N#define __GPIOD_IS_CLK_DISABLED     __HAL_RCC_GPIOD_IS_CLK_DISABLED
N#define __GPIOE_IS_CLK_ENABLED      __HAL_RCC_GPIOE_IS_CLK_ENABLED
N#define __GPIOE_IS_CLK_DISABLED     __HAL_RCC_GPIOE_IS_CLK_DISABLED
N#define __GPIOF_IS_CLK_ENABLED      __HAL_RCC_GPIOF_IS_CLK_ENABLED
N#define __GPIOF_IS_CLK_DISABLED     __HAL_RCC_GPIOF_IS_CLK_DISABLED
N#define __GPIOG_IS_CLK_ENABLED      __HAL_RCC_GPIOG_IS_CLK_ENABLED
N#define __GPIOG_IS_CLK_DISABLED     __HAL_RCC_GPIOG_IS_CLK_DISABLED
N#define __GPIOH_IS_CLK_ENABLED      __HAL_RCC_GPIOH_IS_CLK_ENABLED
N#define __GPIOH_IS_CLK_DISABLED     __HAL_RCC_GPIOH_IS_CLK_DISABLED
N#define __HRTIM1_IS_CLK_ENABLED     __HAL_RCC_HRTIM1_IS_CLK_ENABLED
N#define __HRTIM1_IS_CLK_DISABLED    __HAL_RCC_HRTIM1_IS_CLK_DISABLED
N#define __I2C1_IS_CLK_ENABLED       __HAL_RCC_I2C1_IS_CLK_ENABLED
N#define __I2C1_IS_CLK_DISABLED      __HAL_RCC_I2C1_IS_CLK_DISABLED
N#define __I2C2_IS_CLK_ENABLED       __HAL_RCC_I2C2_IS_CLK_ENABLED
N#define __I2C2_IS_CLK_DISABLED      __HAL_RCC_I2C2_IS_CLK_DISABLED
N#define __I2C3_IS_CLK_ENABLED       __HAL_RCC_I2C3_IS_CLK_ENABLED
N#define __I2C3_IS_CLK_DISABLED      __HAL_RCC_I2C3_IS_CLK_DISABLED
N#define __PWR_IS_CLK_ENABLED        __HAL_RCC_PWR_IS_CLK_ENABLED
N#define __PWR_IS_CLK_DISABLED       __HAL_RCC_PWR_IS_CLK_DISABLED
N#define __SYSCFG_IS_CLK_ENABLED     __HAL_RCC_SYSCFG_IS_CLK_ENABLED
N#define __SYSCFG_IS_CLK_DISABLED    __HAL_RCC_SYSCFG_IS_CLK_DISABLED
N#define __SPI1_IS_CLK_ENABLED       __HAL_RCC_SPI1_IS_CLK_ENABLED
N#define __SPI1_IS_CLK_DISABLED      __HAL_RCC_SPI1_IS_CLK_DISABLED
N#define __SPI2_IS_CLK_ENABLED       __HAL_RCC_SPI2_IS_CLK_ENABLED
N#define __SPI2_IS_CLK_DISABLED      __HAL_RCC_SPI2_IS_CLK_DISABLED
N#define __SPI3_IS_CLK_ENABLED       __HAL_RCC_SPI3_IS_CLK_ENABLED
N#define __SPI3_IS_CLK_DISABLED      __HAL_RCC_SPI3_IS_CLK_DISABLED
N#define __SPI4_IS_CLK_ENABLED       __HAL_RCC_SPI4_IS_CLK_ENABLED
N#define __SPI4_IS_CLK_DISABLED      __HAL_RCC_SPI4_IS_CLK_DISABLED
N#define __SDADC1_IS_CLK_ENABLED     __HAL_RCC_SDADC1_IS_CLK_ENABLED
N#define __SDADC1_IS_CLK_DISABLED    __HAL_RCC_SDADC1_IS_CLK_DISABLED
N#define __SDADC2_IS_CLK_ENABLED     __HAL_RCC_SDADC2_IS_CLK_ENABLED
N#define __SDADC2_IS_CLK_DISABLED    __HAL_RCC_SDADC2_IS_CLK_DISABLED
N#define __SDADC3_IS_CLK_ENABLED     __HAL_RCC_SDADC3_IS_CLK_ENABLED
N#define __SDADC3_IS_CLK_DISABLED    __HAL_RCC_SDADC3_IS_CLK_DISABLED
N#define __SRAM_IS_CLK_ENABLED       __HAL_RCC_SRAM_IS_CLK_ENABLED
N#define __SRAM_IS_CLK_DISABLED      __HAL_RCC_SRAM_IS_CLK_DISABLED
N#define __TIM1_IS_CLK_ENABLED       __HAL_RCC_TIM1_IS_CLK_ENABLED
N#define __TIM1_IS_CLK_DISABLED      __HAL_RCC_TIM1_IS_CLK_DISABLED
N#define __TIM2_IS_CLK_ENABLED       __HAL_RCC_TIM2_IS_CLK_ENABLED
N#define __TIM2_IS_CLK_DISABLED      __HAL_RCC_TIM2_IS_CLK_DISABLED
N#define __TIM3_IS_CLK_ENABLED       __HAL_RCC_TIM3_IS_CLK_ENABLED
N#define __TIM3_IS_CLK_DISABLED      __HAL_RCC_TIM3_IS_CLK_DISABLED
N#define __TIM4_IS_CLK_ENABLED       __HAL_RCC_TIM4_IS_CLK_ENABLED
N#define __TIM4_IS_CLK_DISABLED      __HAL_RCC_TIM4_IS_CLK_DISABLED
N#define __TIM5_IS_CLK_ENABLED       __HAL_RCC_TIM5_IS_CLK_ENABLED
N#define __TIM5_IS_CLK_DISABLED      __HAL_RCC_TIM5_IS_CLK_DISABLED
N#define __TIM6_IS_CLK_ENABLED       __HAL_RCC_TIM6_IS_CLK_ENABLED
N#define __TIM6_IS_CLK_DISABLED      __HAL_RCC_TIM6_IS_CLK_DISABLED
N#define __TIM7_IS_CLK_ENABLED       __HAL_RCC_TIM7_IS_CLK_ENABLED
N#define __TIM7_IS_CLK_DISABLED      __HAL_RCC_TIM7_IS_CLK_DISABLED
N#define __TIM8_IS_CLK_ENABLED       __HAL_RCC_TIM8_IS_CLK_ENABLED
N#define __TIM8_IS_CLK_DISABLED      __HAL_RCC_TIM8_IS_CLK_DISABLED
N#define __TIM12_IS_CLK_ENABLED      __HAL_RCC_TIM12_IS_CLK_ENABLED
N#define __TIM12_IS_CLK_DISABLED     __HAL_RCC_TIM12_IS_CLK_DISABLED
N#define __TIM13_IS_CLK_ENABLED      __HAL_RCC_TIM13_IS_CLK_ENABLED
N#define __TIM13_IS_CLK_DISABLED     __HAL_RCC_TIM13_IS_CLK_DISABLED
N#define __TIM14_IS_CLK_ENABLED      __HAL_RCC_TIM14_IS_CLK_ENABLED
N#define __TIM14_IS_CLK_DISABLED     __HAL_RCC_TIM14_IS_CLK_DISABLED
N#define __TIM15_IS_CLK_ENABLED      __HAL_RCC_TIM15_IS_CLK_ENABLED
N#define __TIM15_IS_CLK_DISABLED     __HAL_RCC_TIM15_IS_CLK_DISABLED
N#define __TIM16_IS_CLK_ENABLED      __HAL_RCC_TIM16_IS_CLK_ENABLED
N#define __TIM16_IS_CLK_DISABLED     __HAL_RCC_TIM16_IS_CLK_DISABLED
N#define __TIM17_IS_CLK_ENABLED      __HAL_RCC_TIM17_IS_CLK_ENABLED
N#define __TIM17_IS_CLK_DISABLED     __HAL_RCC_TIM17_IS_CLK_DISABLED
N#define __TIM18_IS_CLK_ENABLED      __HAL_RCC_TIM18_IS_CLK_ENABLED
N#define __TIM18_IS_CLK_DISABLED     __HAL_RCC_TIM18_IS_CLK_DISABLED
N#define __TIM19_IS_CLK_ENABLED      __HAL_RCC_TIM19_IS_CLK_ENABLED
N#define __TIM19_IS_CLK_DISABLED     __HAL_RCC_TIM19_IS_CLK_DISABLED
N#define __TIM20_IS_CLK_ENABLED      __HAL_RCC_TIM20_IS_CLK_ENABLED
N#define __TIM20_IS_CLK_DISABLED     __HAL_RCC_TIM20_IS_CLK_DISABLED
N#define __TSC_IS_CLK_ENABLED        __HAL_RCC_TSC_IS_CLK_ENABLED
N#define __TSC_IS_CLK_DISABLED       __HAL_RCC_TSC_IS_CLK_DISABLED
N#define __UART4_IS_CLK_ENABLED      __HAL_RCC_UART4_IS_CLK_ENABLED
N#define __UART4_IS_CLK_DISABLED     __HAL_RCC_UART4_IS_CLK_DISABLED
N#define __UART5_IS_CLK_ENABLED      __HAL_RCC_UART5_IS_CLK_ENABLED
N#define __UART5_IS_CLK_DISABLED     __HAL_RCC_UART5_IS_CLK_DISABLED
N#define __USART1_IS_CLK_ENABLED     __HAL_RCC_USART1_IS_CLK_ENABLED
N#define __USART1_IS_CLK_DISABLED    __HAL_RCC_USART1_IS_CLK_DISABLED
N#define __USART2_IS_CLK_ENABLED     __HAL_RCC_USART2_IS_CLK_ENABLED
N#define __USART2_IS_CLK_DISABLED    __HAL_RCC_USART2_IS_CLK_DISABLED
N#define __USART3_IS_CLK_ENABLED     __HAL_RCC_USART3_IS_CLK_ENABLED
N#define __USART3_IS_CLK_DISABLED    __HAL_RCC_USART3_IS_CLK_DISABLED
N#define __USB_IS_CLK_ENABLED        __HAL_RCC_USB_IS_CLK_ENABLED
N#define __USB_IS_CLK_DISABLED       __HAL_RCC_USB_IS_CLK_DISABLED
N#define __WWDG_IS_CLK_ENABLED       __HAL_RCC_WWDG_IS_CLK_ENABLED
N#define __WWDG_IS_CLK_DISABLED      __HAL_RCC_WWDG_IS_CLK_DISABLED
N
N#if defined(STM32F4)
X#if 1L
N#define __HAL_RCC_SDMMC1_FORCE_RESET       __HAL_RCC_SDIO_FORCE_RESET
N#define __HAL_RCC_SDMMC1_RELEASE_RESET     __HAL_RCC_SDIO_RELEASE_RESET
N#define __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE  __HAL_RCC_SDIO_CLK_SLEEP_ENABLE
N#define __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
N#define __HAL_RCC_SDMMC1_CLK_ENABLE        __HAL_RCC_SDIO_CLK_ENABLE
N#define __HAL_RCC_SDMMC1_CLK_DISABLE       __HAL_RCC_SDIO_CLK_DISABLE
N#define __HAL_RCC_SDMMC1_IS_CLK_ENABLED    __HAL_RCC_SDIO_IS_CLK_ENABLED
N#define __HAL_RCC_SDMMC1_IS_CLK_DISABLED   __HAL_RCC_SDIO_IS_CLK_DISABLED
N#define Sdmmc1ClockSelection               SdioClockSelection
N#define RCC_PERIPHCLK_SDMMC1               RCC_PERIPHCLK_SDIO
N#define RCC_SDMMC1CLKSOURCE_CLK48          RCC_SDIOCLKSOURCE_CK48
N#define RCC_SDMMC1CLKSOURCE_SYSCLK         RCC_SDIOCLKSOURCE_SYSCLK
N#define __HAL_RCC_SDMMC1_CONFIG            __HAL_RCC_SDIO_CONFIG
N#define __HAL_RCC_GET_SDMMC1_SOURCE        __HAL_RCC_GET_SDIO_SOURCE
N#endif
N
N#if defined(STM32F7) || defined(STM32L4)
X#if 0L || 0L
S#define __HAL_RCC_SDIO_FORCE_RESET         __HAL_RCC_SDMMC1_FORCE_RESET
S#define __HAL_RCC_SDIO_RELEASE_RESET       __HAL_RCC_SDMMC1_RELEASE_RESET
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE    __HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE   __HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE
S#define __HAL_RCC_SDIO_CLK_ENABLE          __HAL_RCC_SDMMC1_CLK_ENABLE
S#define __HAL_RCC_SDIO_CLK_DISABLE         __HAL_RCC_SDMMC1_CLK_DISABLE
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED      __HAL_RCC_SDMMC1_IS_CLK_ENABLED
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED     __HAL_RCC_SDMMC1_IS_CLK_DISABLED
S#define SdioClockSelection                 Sdmmc1ClockSelection
S#define RCC_PERIPHCLK_SDIO                 RCC_PERIPHCLK_SDMMC1
S#define __HAL_RCC_SDIO_CONFIG              __HAL_RCC_SDMMC1_CONFIG
S#define __HAL_RCC_GET_SDIO_SOURCE          __HAL_RCC_GET_SDMMC1_SOURCE
N#endif
N
N#if defined(STM32F7)
X#if 0L
S#define RCC_SDIOCLKSOURCE_CLK48             RCC_SDMMC1CLKSOURCE_CLK48
S#define RCC_SDIOCLKSOURCE_SYSCLK           RCC_SDMMC1CLKSOURCE_SYSCLK
N#endif
N
N#if defined(STM32H7)
X#if 0L
S#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()              __HAL_RCC_USB1_OTG_HS_CLK_ENABLE()
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()         __HAL_RCC_USB1_OTG_HS_ULPI_CLK_ENABLE()
S#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()             __HAL_RCC_USB1_OTG_HS_CLK_DISABLE()
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE()        __HAL_RCC_USB1_OTG_HS_ULPI_CLK_DISABLE()
S#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()             __HAL_RCC_USB1_OTG_HS_FORCE_RESET()
S#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()           __HAL_RCC_USB1_OTG_HS_RELEASE_RESET()
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()        __HAL_RCC_USB1_OTG_HS_CLK_SLEEP_ENABLE()
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()   __HAL_RCC_USB1_OTG_HS_ULPI_CLK_SLEEP_ENABLE()
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()       __HAL_RCC_USB1_OTG_HS_CLK_SLEEP_DISABLE()
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE()  __HAL_RCC_USB1_OTG_HS_ULPI_CLK_SLEEP_DISABLE()
S
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()             __HAL_RCC_USB2_OTG_FS_CLK_ENABLE()
S#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_ENABLE()        __HAL_RCC_USB2_OTG_FS_ULPI_CLK_ENABLE()
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE()            __HAL_RCC_USB2_OTG_FS_CLK_DISABLE()
S#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_DISABLE()       __HAL_RCC_USB2_OTG_FS_ULPI_CLK_DISABLE()
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()            __HAL_RCC_USB2_OTG_FS_FORCE_RESET()
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET()          __HAL_RCC_USB2_OTG_FS_RELEASE_RESET()
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()       __HAL_RCC_USB2_OTG_FS_CLK_SLEEP_ENABLE()
S#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_SLEEP_ENABLE()  __HAL_RCC_USB2_OTG_FS_ULPI_CLK_SLEEP_ENABLE()
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()      __HAL_RCC_USB2_OTG_FS_CLK_SLEEP_DISABLE()
S#define __HAL_RCC_USB_OTG_FS_ULPI_CLK_SLEEP_DISABLE() __HAL_RCC_USB2_OTG_FS_ULPI_CLK_SLEEP_DISABLE()
N#endif
N
N#define __HAL_RCC_I2SCLK            __HAL_RCC_I2S_CONFIG
N#define __HAL_RCC_I2SCLK_CONFIG     __HAL_RCC_I2S_CONFIG
N
N#define __RCC_PLLSRC                RCC_GET_PLL_OSCSOURCE
N
N#define IS_RCC_MSIRANGE             IS_RCC_MSI_CLOCK_RANGE
N#define IS_RCC_RTCCLK_SOURCE        IS_RCC_RTCCLKSOURCE
N#define IS_RCC_SYSCLK_DIV           IS_RCC_HCLK
N#define IS_RCC_HCLK_DIV             IS_RCC_PCLK
N#define IS_RCC_PERIPHCLK            IS_RCC_PERIPHCLOCK
N
N#define RCC_IT_HSI14                RCC_IT_HSI14RDY
N
N#define RCC_IT_CSSLSE               RCC_IT_LSECSS
N#define RCC_IT_CSSHSE               RCC_IT_CSS
N
N#define RCC_PLLMUL_3                RCC_PLL_MUL3
N#define RCC_PLLMUL_4                RCC_PLL_MUL4
N#define RCC_PLLMUL_6                RCC_PLL_MUL6
N#define RCC_PLLMUL_8                RCC_PLL_MUL8
N#define RCC_PLLMUL_12               RCC_PLL_MUL12
N#define RCC_PLLMUL_16               RCC_PLL_MUL16
N#define RCC_PLLMUL_24               RCC_PLL_MUL24
N#define RCC_PLLMUL_32               RCC_PLL_MUL32
N#define RCC_PLLMUL_48               RCC_PLL_MUL48
N
N#define RCC_PLLDIV_2                RCC_PLL_DIV2
N#define RCC_PLLDIV_3                RCC_PLL_DIV3
N#define RCC_PLLDIV_4                RCC_PLL_DIV4
N
N#define IS_RCC_MCOSOURCE            IS_RCC_MCO1SOURCE
N#define __HAL_RCC_MCO_CONFIG        __HAL_RCC_MCO1_CONFIG
N#define RCC_MCO_NODIV               RCC_MCODIV_1
N#define RCC_MCO_DIV1                RCC_MCODIV_1
N#define RCC_MCO_DIV2                RCC_MCODIV_2
N#define RCC_MCO_DIV4                RCC_MCODIV_4
N#define RCC_MCO_DIV8                RCC_MCODIV_8
N#define RCC_MCO_DIV16               RCC_MCODIV_16
N#define RCC_MCO_DIV32               RCC_MCODIV_32
N#define RCC_MCO_DIV64               RCC_MCODIV_64
N#define RCC_MCO_DIV128              RCC_MCODIV_128
N#define RCC_MCOSOURCE_NONE          RCC_MCO1SOURCE_NOCLOCK
N#define RCC_MCOSOURCE_LSI           RCC_MCO1SOURCE_LSI
N#define RCC_MCOSOURCE_LSE           RCC_MCO1SOURCE_LSE
N#define RCC_MCOSOURCE_SYSCLK        RCC_MCO1SOURCE_SYSCLK
N#define RCC_MCOSOURCE_HSI           RCC_MCO1SOURCE_HSI
N#define RCC_MCOSOURCE_HSI14         RCC_MCO1SOURCE_HSI14
N#define RCC_MCOSOURCE_HSI48         RCC_MCO1SOURCE_HSI48
N#define RCC_MCOSOURCE_HSE           RCC_MCO1SOURCE_HSE
N#define RCC_MCOSOURCE_PLLCLK_DIV1   RCC_MCO1SOURCE_PLLCLK
N#define RCC_MCOSOURCE_PLLCLK_NODIV  RCC_MCO1SOURCE_PLLCLK
N#define RCC_MCOSOURCE_PLLCLK_DIV2   RCC_MCO1SOURCE_PLLCLK_DIV2
N
N#if defined(STM32L4)
X#if 0L
S#define RCC_RTCCLKSOURCE_NO_CLK     RCC_RTCCLKSOURCE_NONE
S#elif defined(STM32WB) || defined(STM32G0)
X#elif 0L || 0L
N#else
N#define RCC_RTCCLKSOURCE_NONE       RCC_RTCCLKSOURCE_NO_CLK
N#endif
N
N#define RCC_USBCLK_PLLSAI1          RCC_USBCLKSOURCE_PLLSAI1
N#define RCC_USBCLK_PLL              RCC_USBCLKSOURCE_PLL
N#define RCC_USBCLK_MSI              RCC_USBCLKSOURCE_MSI
N#define RCC_USBCLKSOURCE_PLLCLK     RCC_USBCLKSOURCE_PLL
N#define RCC_USBPLLCLK_DIV1          RCC_USBCLKSOURCE_PLL
N#define RCC_USBPLLCLK_DIV1_5        RCC_USBCLKSOURCE_PLL_DIV1_5
N#define RCC_USBPLLCLK_DIV2          RCC_USBCLKSOURCE_PLL_DIV2
N#define RCC_USBPLLCLK_DIV3          RCC_USBCLKSOURCE_PLL_DIV3
N
N#define HSION_BitNumber        RCC_HSION_BIT_NUMBER
N#define HSION_BITNUMBER        RCC_HSION_BIT_NUMBER
N#define HSEON_BitNumber        RCC_HSEON_BIT_NUMBER
N#define HSEON_BITNUMBER        RCC_HSEON_BIT_NUMBER
N#define MSION_BITNUMBER        RCC_MSION_BIT_NUMBER
N#define CSSON_BitNumber        RCC_CSSON_BIT_NUMBER
N#define CSSON_BITNUMBER        RCC_CSSON_BIT_NUMBER
N#define PLLON_BitNumber        RCC_PLLON_BIT_NUMBER
N#define PLLON_BITNUMBER        RCC_PLLON_BIT_NUMBER
N#define PLLI2SON_BitNumber     RCC_PLLI2SON_BIT_NUMBER
N#define I2SSRC_BitNumber       RCC_I2SSRC_BIT_NUMBER
N#define RTCEN_BitNumber        RCC_RTCEN_BIT_NUMBER
N#define RTCEN_BITNUMBER        RCC_RTCEN_BIT_NUMBER
N#define BDRST_BitNumber        RCC_BDRST_BIT_NUMBER
N#define BDRST_BITNUMBER        RCC_BDRST_BIT_NUMBER
N#define RTCRST_BITNUMBER       RCC_RTCRST_BIT_NUMBER
N#define LSION_BitNumber        RCC_LSION_BIT_NUMBER
N#define LSION_BITNUMBER        RCC_LSION_BIT_NUMBER
N#define LSEON_BitNumber        RCC_LSEON_BIT_NUMBER
N#define LSEON_BITNUMBER        RCC_LSEON_BIT_NUMBER
N#define LSEBYP_BITNUMBER       RCC_LSEBYP_BIT_NUMBER
N#define PLLSAION_BitNumber     RCC_PLLSAION_BIT_NUMBER
N#define TIMPRE_BitNumber       RCC_TIMPRE_BIT_NUMBER
N#define RMVF_BitNumber         RCC_RMVF_BIT_NUMBER
N#define RMVF_BITNUMBER         RCC_RMVF_BIT_NUMBER
N#define RCC_CR2_HSI14TRIM_BitNumber RCC_HSI14TRIM_BIT_NUMBER
N#define CR_BYTE2_ADDRESS       RCC_CR_BYTE2_ADDRESS
N#define CIR_BYTE1_ADDRESS      RCC_CIR_BYTE1_ADDRESS
N#define CIR_BYTE2_ADDRESS      RCC_CIR_BYTE2_ADDRESS
N#define BDCR_BYTE0_ADDRESS     RCC_BDCR_BYTE0_ADDRESS
N#define DBP_TIMEOUT_VALUE      RCC_DBP_TIMEOUT_VALUE
N#define LSE_TIMEOUT_VALUE      RCC_LSE_TIMEOUT_VALUE
N
N#define CR_HSION_BB            RCC_CR_HSION_BB
N#define CR_CSSON_BB            RCC_CR_CSSON_BB
N#define CR_PLLON_BB            RCC_CR_PLLON_BB
N#define CR_PLLI2SON_BB         RCC_CR_PLLI2SON_BB
N#define CR_MSION_BB            RCC_CR_MSION_BB
N#define CSR_LSION_BB           RCC_CSR_LSION_BB
N#define CSR_LSEON_BB           RCC_CSR_LSEON_BB
N#define CSR_LSEBYP_BB          RCC_CSR_LSEBYP_BB
N#define CSR_RTCEN_BB           RCC_CSR_RTCEN_BB
N#define CSR_RTCRST_BB          RCC_CSR_RTCRST_BB
N#define CFGR_I2SSRC_BB         RCC_CFGR_I2SSRC_BB
N#define BDCR_RTCEN_BB          RCC_BDCR_RTCEN_BB
N#define BDCR_BDRST_BB          RCC_BDCR_BDRST_BB
N#define CR_HSEON_BB            RCC_CR_HSEON_BB
N#define CSR_RMVF_BB            RCC_CSR_RMVF_BB
N#define CR_PLLSAION_BB         RCC_CR_PLLSAION_BB
N#define DCKCFGR_TIMPRE_BB      RCC_DCKCFGR_TIMPRE_BB
N
N#define __HAL_RCC_CRS_ENABLE_FREQ_ERROR_COUNTER     __HAL_RCC_CRS_FREQ_ERROR_COUNTER_ENABLE
N#define __HAL_RCC_CRS_DISABLE_FREQ_ERROR_COUNTER    __HAL_RCC_CRS_FREQ_ERROR_COUNTER_DISABLE
N#define __HAL_RCC_CRS_ENABLE_AUTOMATIC_CALIB        __HAL_RCC_CRS_AUTOMATIC_CALIB_ENABLE
N#define __HAL_RCC_CRS_DISABLE_AUTOMATIC_CALIB       __HAL_RCC_CRS_AUTOMATIC_CALIB_DISABLE
N#define __HAL_RCC_CRS_CALCULATE_RELOADVALUE         __HAL_RCC_CRS_RELOADVALUE_CALCULATE
N
N#define __HAL_RCC_GET_IT_SOURCE                     __HAL_RCC_GET_IT
N
N#define RCC_CRS_SYNCWARM       RCC_CRS_SYNCWARN
N#define RCC_CRS_TRIMOV         RCC_CRS_TRIMOVF
N
N#define RCC_PERIPHCLK_CK48               RCC_PERIPHCLK_CLK48
N#define RCC_CK48CLKSOURCE_PLLQ           RCC_CLK48CLKSOURCE_PLLQ
N#define RCC_CK48CLKSOURCE_PLLSAIP        RCC_CLK48CLKSOURCE_PLLSAIP
N#define RCC_CK48CLKSOURCE_PLLI2SQ        RCC_CLK48CLKSOURCE_PLLI2SQ
N#define IS_RCC_CK48CLKSOURCE             IS_RCC_CLK48CLKSOURCE
N#define RCC_SDIOCLKSOURCE_CK48           RCC_SDIOCLKSOURCE_CLK48
N
N#define __HAL_RCC_DFSDM_CLK_ENABLE             __HAL_RCC_DFSDM1_CLK_ENABLE
N#define __HAL_RCC_DFSDM_CLK_DISABLE            __HAL_RCC_DFSDM1_CLK_DISABLE
N#define __HAL_RCC_DFSDM_IS_CLK_ENABLED         __HAL_RCC_DFSDM1_IS_CLK_ENABLED
N#define __HAL_RCC_DFSDM_IS_CLK_DISABLED        __HAL_RCC_DFSDM1_IS_CLK_DISABLED
N#define __HAL_RCC_DFSDM_FORCE_RESET            __HAL_RCC_DFSDM1_FORCE_RESET
N#define __HAL_RCC_DFSDM_RELEASE_RESET          __HAL_RCC_DFSDM1_RELEASE_RESET
N#define __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE       __HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE
N#define __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE      __HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE
N#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_ENABLED   __HAL_RCC_DFSDM1_IS_CLK_SLEEP_ENABLED
N#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_DISABLED  __HAL_RCC_DFSDM1_IS_CLK_SLEEP_DISABLED
N#define DfsdmClockSelection         Dfsdm1ClockSelection
N#define RCC_PERIPHCLK_DFSDM         RCC_PERIPHCLK_DFSDM1
N#define RCC_DFSDMCLKSOURCE_PCLK     RCC_DFSDM1CLKSOURCE_PCLK2
N#define RCC_DFSDMCLKSOURCE_SYSCLK   RCC_DFSDM1CLKSOURCE_SYSCLK
N#define __HAL_RCC_DFSDM_CONFIG      __HAL_RCC_DFSDM1_CONFIG
N#define __HAL_RCC_GET_DFSDM_SOURCE  __HAL_RCC_GET_DFSDM1_SOURCE
N#define RCC_DFSDM1CLKSOURCE_PCLK    RCC_DFSDM1CLKSOURCE_PCLK2
N#define RCC_SWPMI1CLKSOURCE_PCLK    RCC_SWPMI1CLKSOURCE_PCLK1
N#define RCC_LPTIM1CLKSOURCE_PCLK    RCC_LPTIM1CLKSOURCE_PCLK1
N#define RCC_LPTIM2CLKSOURCE_PCLK    RCC_LPTIM2CLKSOURCE_PCLK1
N
N#define RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB1    RCC_DFSDM1AUDIOCLKSOURCE_I2S1
N#define RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB2    RCC_DFSDM1AUDIOCLKSOURCE_I2S2
N#define RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB1    RCC_DFSDM2AUDIOCLKSOURCE_I2S1
N#define RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB2    RCC_DFSDM2AUDIOCLKSOURCE_I2S2
N#define RCC_DFSDM1CLKSOURCE_APB2            RCC_DFSDM1CLKSOURCE_PCLK2
N#define RCC_DFSDM2CLKSOURCE_APB2            RCC_DFSDM2CLKSOURCE_PCLK2
N#define RCC_FMPI2C1CLKSOURCE_APB            RCC_FMPI2C1CLKSOURCE_PCLK1
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_RNG_Aliased_Macros HAL RNG Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define  HAL_RNG_ReadyCallback(__HANDLE__)  HAL_RNG_ReadyDataCallback((__HANDLE__), uint32_t random32bit)
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_RTC_Aliased_Macros HAL RTC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#if defined (STM32G0) || defined (STM32L412xx) || defined (STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
X#if 0L || 0L || 0L || 0L || 0L
N#else
N#define __HAL_RTC_CLEAR_FLAG                      __HAL_RTC_EXTI_CLEAR_FLAG
N#endif
N#define __HAL_RTC_DISABLE_IT                      __HAL_RTC_EXTI_DISABLE_IT
N#define __HAL_RTC_ENABLE_IT                       __HAL_RTC_EXTI_ENABLE_IT
N
N#if defined (STM32F1)
X#if 0L
S#define __HAL_RTC_EXTI_CLEAR_FLAG(RTC_EXTI_LINE_ALARM_EVENT)  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG()
S
S#define __HAL_RTC_EXTI_ENABLE_IT(RTC_EXTI_LINE_ALARM_EVENT)   __HAL_RTC_ALARM_EXTI_ENABLE_IT()
S
S#define __HAL_RTC_EXTI_DISABLE_IT(RTC_EXTI_LINE_ALARM_EVENT)  __HAL_RTC_ALARM_EXTI_DISABLE_IT()
S
S#define __HAL_RTC_EXTI_GET_FLAG(RTC_EXTI_LINE_ALARM_EVENT)    __HAL_RTC_ALARM_EXTI_GET_FLAG()
S
S#define __HAL_RTC_EXTI_GENERATE_SWIT(RTC_EXTI_LINE_ALARM_EVENT)   __HAL_RTC_ALARM_EXTI_GENERATE_SWIT()
N#else
N#define __HAL_RTC_EXTI_CLEAR_FLAG(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_CLEAR_FLAG() : \
N                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG() : \
N                                                      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()))
X#define __HAL_RTC_EXTI_CLEAR_FLAG(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_CLEAR_FLAG() :                                                    (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG() :                                                       __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()))
N#define __HAL_RTC_EXTI_ENABLE_IT(__EXTI_LINE__)   (((__EXTI_LINE__)  == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_ENABLE_IT() : \
N                                                  (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT() : \
N                                                      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()))
X#define __HAL_RTC_EXTI_ENABLE_IT(__EXTI_LINE__)   (((__EXTI_LINE__)  == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_ENABLE_IT() :                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT() :                                                       __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()))
N#define __HAL_RTC_EXTI_DISABLE_IT(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_DISABLE_IT() : \
N                                                  (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT() : \
N                                                      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()))
X#define __HAL_RTC_EXTI_DISABLE_IT(__EXTI_LINE__)  (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_DISABLE_IT() :                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT() :                                                       __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()))
N#define __HAL_RTC_EXTI_GET_FLAG(__EXTI_LINE__)    (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GET_FLAG() : \
N                                                  (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG() : \
N                                                      __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()))
X#define __HAL_RTC_EXTI_GET_FLAG(__EXTI_LINE__)    (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GET_FLAG() :                                                   (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG() :                                                       __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()))
N#define __HAL_RTC_EXTI_GENERATE_SWIT(__EXTI_LINE__)   (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GENERATE_SWIT() : \
N                                                      (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT() :  \
N                                                          __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()))
X#define __HAL_RTC_EXTI_GENERATE_SWIT(__EXTI_LINE__)   (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GENERATE_SWIT() :                                                       (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT() :                                                            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()))
N#endif   /* STM32F1 */
N
N#define IS_ALARM                                  IS_RTC_ALARM
N#define IS_ALARM_MASK                             IS_RTC_ALARM_MASK
N#define IS_TAMPER                                 IS_RTC_TAMPER
N#define IS_TAMPER_ERASE_MODE                      IS_RTC_TAMPER_ERASE_MODE
N#define IS_TAMPER_FILTER                          IS_RTC_TAMPER_FILTER
N#define IS_TAMPER_INTERRUPT                       IS_RTC_TAMPER_INTERRUPT
N#define IS_TAMPER_MASKFLAG_STATE                  IS_RTC_TAMPER_MASKFLAG_STATE
N#define IS_TAMPER_PRECHARGE_DURATION              IS_RTC_TAMPER_PRECHARGE_DURATION
N#define IS_TAMPER_PULLUP_STATE                    IS_RTC_TAMPER_PULLUP_STATE
N#define IS_TAMPER_SAMPLING_FREQ                   IS_RTC_TAMPER_SAMPLING_FREQ
N#define IS_TAMPER_TIMESTAMPONTAMPER_DETECTION     IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION
N#define IS_TAMPER_TRIGGER                         IS_RTC_TAMPER_TRIGGER
N#define IS_WAKEUP_CLOCK                           IS_RTC_WAKEUP_CLOCK
N#define IS_WAKEUP_COUNTER                         IS_RTC_WAKEUP_COUNTER
N
N#define __RTC_WRITEPROTECTION_ENABLE  __HAL_RTC_WRITEPROTECTION_ENABLE
N#define __RTC_WRITEPROTECTION_DISABLE  __HAL_RTC_WRITEPROTECTION_DISABLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SD_Aliased_Macros HAL SD Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define SD_OCR_CID_CSD_OVERWRIETE   SD_OCR_CID_CSD_OVERWRITE
N#define SD_CMD_SD_APP_STAUS         SD_CMD_SD_APP_STATUS
N
N#if defined(STM32F4) || defined(STM32F2)
X#if 1L || 0L
N#define  SD_SDMMC_DISABLED          SD_SDIO_DISABLED
N#define  SD_SDMMC_FUNCTION_BUSY     SD_SDIO_FUNCTION_BUSY
N#define  SD_SDMMC_FUNCTION_FAILED   SD_SDIO_FUNCTION_FAILED
N#define  SD_SDMMC_UNKNOWN_FUNCTION  SD_SDIO_UNKNOWN_FUNCTION
N#define  SD_CMD_SDMMC_SEN_OP_COND   SD_CMD_SDIO_SEN_OP_COND
N#define  SD_CMD_SDMMC_RW_DIRECT     SD_CMD_SDIO_RW_DIRECT
N#define  SD_CMD_SDMMC_RW_EXTENDED   SD_CMD_SDIO_RW_EXTENDED
N#define  __HAL_SD_SDMMC_ENABLE      __HAL_SD_SDIO_ENABLE
N#define  __HAL_SD_SDMMC_DISABLE     __HAL_SD_SDIO_DISABLE
N#define  __HAL_SD_SDMMC_DMA_ENABLE  __HAL_SD_SDIO_DMA_ENABLE
N#define  __HAL_SD_SDMMC_DMA_DISABLE __HAL_SD_SDIO_DMA_DISABL
N#define  __HAL_SD_SDMMC_ENABLE_IT   __HAL_SD_SDIO_ENABLE_IT
N#define  __HAL_SD_SDMMC_DISABLE_IT  __HAL_SD_SDIO_DISABLE_IT
N#define  __HAL_SD_SDMMC_GET_FLAG    __HAL_SD_SDIO_GET_FLAG
N#define  __HAL_SD_SDMMC_CLEAR_FLAG  __HAL_SD_SDIO_CLEAR_FLAG
N#define  __HAL_SD_SDMMC_GET_IT      __HAL_SD_SDIO_GET_IT
N#define  __HAL_SD_SDMMC_CLEAR_IT    __HAL_SD_SDIO_CLEAR_IT
N#define  SDMMC_STATIC_FLAGS         SDIO_STATIC_FLAGS
N#define  SDMMC_CMD0TIMEOUT          SDIO_CMD0TIMEOUT
N#define  SD_SDMMC_SEND_IF_COND      SD_SDIO_SEND_IF_COND
N/* alias CMSIS */
N#define  SDMMC1_IRQn                SDIO_IRQn
N#define  SDMMC1_IRQHandler          SDIO_IRQHandler
N#endif
N
N#if defined(STM32F7) || defined(STM32L4)
X#if 0L || 0L
S#define  SD_SDIO_DISABLED           SD_SDMMC_DISABLED
S#define  SD_SDIO_FUNCTION_BUSY      SD_SDMMC_FUNCTION_BUSY
S#define  SD_SDIO_FUNCTION_FAILED    SD_SDMMC_FUNCTION_FAILED
S#define  SD_SDIO_UNKNOWN_FUNCTION   SD_SDMMC_UNKNOWN_FUNCTION
S#define  SD_CMD_SDIO_SEN_OP_COND    SD_CMD_SDMMC_SEN_OP_COND
S#define  SD_CMD_SDIO_RW_DIRECT      SD_CMD_SDMMC_RW_DIRECT
S#define  SD_CMD_SDIO_RW_EXTENDED    SD_CMD_SDMMC_RW_EXTENDED
S#define  __HAL_SD_SDIO_ENABLE       __HAL_SD_SDMMC_ENABLE
S#define  __HAL_SD_SDIO_DISABLE      __HAL_SD_SDMMC_DISABLE
S#define  __HAL_SD_SDIO_DMA_ENABLE   __HAL_SD_SDMMC_DMA_ENABLE
S#define  __HAL_SD_SDIO_DMA_DISABL   __HAL_SD_SDMMC_DMA_DISABLE
S#define  __HAL_SD_SDIO_ENABLE_IT    __HAL_SD_SDMMC_ENABLE_IT
S#define  __HAL_SD_SDIO_DISABLE_IT   __HAL_SD_SDMMC_DISABLE_IT
S#define  __HAL_SD_SDIO_GET_FLAG     __HAL_SD_SDMMC_GET_FLAG
S#define  __HAL_SD_SDIO_CLEAR_FLAG   __HAL_SD_SDMMC_CLEAR_FLAG
S#define  __HAL_SD_SDIO_GET_IT       __HAL_SD_SDMMC_GET_IT
S#define  __HAL_SD_SDIO_CLEAR_IT     __HAL_SD_SDMMC_CLEAR_IT
S#define  SDIO_STATIC_FLAGS	        SDMMC_STATIC_FLAGS
S#define  SDIO_CMD0TIMEOUT	          SDMMC_CMD0TIMEOUT
S#define  SD_SDIO_SEND_IF_COND	      SD_SDMMC_SEND_IF_COND
S/* alias CMSIS for compatibilities */
S#define  SDIO_IRQn                  SDMMC1_IRQn
S#define  SDIO_IRQHandler            SDMMC1_IRQHandler
N#endif
N
N#if defined(STM32F7) || defined(STM32F4) || defined(STM32F2)
X#if 0L || 1L || 0L
N#define  HAL_SD_CardCIDTypedef       HAL_SD_CardCIDTypeDef
N#define  HAL_SD_CardCSDTypedef       HAL_SD_CardCSDTypeDef
N#define  HAL_SD_CardStatusTypedef    HAL_SD_CardStatusTypeDef
N#define  HAL_SD_CardStateTypedef     HAL_SD_CardStateTypeDef
N#endif
N
N#if defined(STM32H7)
X#if 0L
S#define HAL_MMCEx_Read_DMADoubleBuffer0CpltCallback   HAL_MMCEx_Read_DMADoubleBuf0CpltCallback
S#define HAL_MMCEx_Read_DMADoubleBuffer1CpltCallback   HAL_MMCEx_Read_DMADoubleBuf1CpltCallback
S#define HAL_MMCEx_Write_DMADoubleBuffer0CpltCallback  HAL_MMCEx_Write_DMADoubleBuf0CpltCallback
S#define HAL_MMCEx_Write_DMADoubleBuffer1CpltCallback  HAL_MMCEx_Write_DMADoubleBuf1CpltCallback
S#define HAL_SDEx_Read_DMADoubleBuffer0CpltCallback    HAL_SDEx_Read_DMADoubleBuf0CpltCallback
S#define HAL_SDEx_Read_DMADoubleBuffer1CpltCallback    HAL_SDEx_Read_DMADoubleBuf1CpltCallback
S#define HAL_SDEx_Write_DMADoubleBuffer0CpltCallback   HAL_SDEx_Write_DMADoubleBuf0CpltCallback
S#define HAL_SDEx_Write_DMADoubleBuffer1CpltCallback   HAL_SDEx_Write_DMADoubleBuf1CpltCallback
S#define HAL_SD_DriveTransciver_1_8V_Callback          HAL_SD_DriveTransceiver_1_8V_Callback
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SMARTCARD_Aliased_Macros HAL SMARTCARD Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __SMARTCARD_ENABLE_IT           __HAL_SMARTCARD_ENABLE_IT
N#define __SMARTCARD_DISABLE_IT          __HAL_SMARTCARD_DISABLE_IT
N#define __SMARTCARD_ENABLE              __HAL_SMARTCARD_ENABLE
N#define __SMARTCARD_DISABLE             __HAL_SMARTCARD_DISABLE
N#define __SMARTCARD_DMA_REQUEST_ENABLE  __HAL_SMARTCARD_DMA_REQUEST_ENABLE
N#define __SMARTCARD_DMA_REQUEST_DISABLE __HAL_SMARTCARD_DMA_REQUEST_DISABLE
N
N#define __HAL_SMARTCARD_GETCLOCKSOURCE  SMARTCARD_GETCLOCKSOURCE
N#define __SMARTCARD_GETCLOCKSOURCE      SMARTCARD_GETCLOCKSOURCE
N
N#define IS_SMARTCARD_ONEBIT_SAMPLING    IS_SMARTCARD_ONE_BIT_SAMPLE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SMBUS_Aliased_Macros HAL SMBUS Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_SMBUS_RESET_CR1           SMBUS_RESET_CR1
N#define __HAL_SMBUS_RESET_CR2           SMBUS_RESET_CR2
N#define __HAL_SMBUS_GENERATE_START      SMBUS_GENERATE_START
N#define __HAL_SMBUS_GET_ADDR_MATCH      SMBUS_GET_ADDR_MATCH
N#define __HAL_SMBUS_GET_DIR             SMBUS_GET_DIR
N#define __HAL_SMBUS_GET_STOP_MODE       SMBUS_GET_STOP_MODE
N#define __HAL_SMBUS_GET_PEC_MODE        SMBUS_GET_PEC_MODE
N#define __HAL_SMBUS_GET_ALERT_ENABLED   SMBUS_GET_ALERT_ENABLED
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPI_Aliased_Macros HAL SPI Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_SPI_1LINE_TX              SPI_1LINE_TX
N#define __HAL_SPI_1LINE_RX              SPI_1LINE_RX
N#define __HAL_SPI_RESET_CRC             SPI_RESET_CRC
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_UART_Aliased_Macros HAL UART Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_UART_GETCLOCKSOURCE       UART_GETCLOCKSOURCE
N#define __HAL_UART_MASK_COMPUTATION     UART_MASK_COMPUTATION
N#define __UART_GETCLOCKSOURCE           UART_GETCLOCKSOURCE
N#define __UART_MASK_COMPUTATION         UART_MASK_COMPUTATION
N
N#define IS_UART_WAKEUPMETHODE           IS_UART_WAKEUPMETHOD
N
N#define IS_UART_ONEBIT_SAMPLE           IS_UART_ONE_BIT_SAMPLE
N#define IS_UART_ONEBIT_SAMPLING         IS_UART_ONE_BIT_SAMPLE
N
N/**
N  * @}
N  */
N
N
N/** @defgroup HAL_USART_Aliased_Macros HAL USART Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __USART_ENABLE_IT               __HAL_USART_ENABLE_IT
N#define __USART_DISABLE_IT              __HAL_USART_DISABLE_IT
N#define __USART_ENABLE                  __HAL_USART_ENABLE
N#define __USART_DISABLE                 __HAL_USART_DISABLE
N
N#define __HAL_USART_GETCLOCKSOURCE      USART_GETCLOCKSOURCE
N#define __USART_GETCLOCKSOURCE          USART_GETCLOCKSOURCE
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_USB_Aliased_Macros HAL USB Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define USB_EXTI_LINE_WAKEUP                               USB_WAKEUP_EXTI_LINE
N
N#define USB_FS_EXTI_TRIGGER_RISING_EDGE                    USB_OTG_FS_WAKEUP_EXTI_RISING_EDGE
N#define USB_FS_EXTI_TRIGGER_FALLING_EDGE                   USB_OTG_FS_WAKEUP_EXTI_FALLING_EDGE
N#define USB_FS_EXTI_TRIGGER_BOTH_EDGE                      USB_OTG_FS_WAKEUP_EXTI_RISING_FALLING_EDGE
N#define USB_FS_EXTI_LINE_WAKEUP                            USB_OTG_FS_WAKEUP_EXTI_LINE
N
N#define USB_HS_EXTI_TRIGGER_RISING_EDGE                    USB_OTG_HS_WAKEUP_EXTI_RISING_EDGE
N#define USB_HS_EXTI_TRIGGER_FALLING_EDGE                   USB_OTG_HS_WAKEUP_EXTI_FALLING_EDGE
N#define USB_HS_EXTI_TRIGGER_BOTH_EDGE                      USB_OTG_HS_WAKEUP_EXTI_RISING_FALLING_EDGE
N#define USB_HS_EXTI_LINE_WAKEUP                            USB_OTG_HS_WAKEUP_EXTI_LINE
N
N#define __HAL_USB_EXTI_ENABLE_IT                           __HAL_USB_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_EXTI_DISABLE_IT                          __HAL_USB_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_EXTI_GET_FLAG                            __HAL_USB_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_EXTI_CLEAR_FLAG                          __HAL_USB_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_EXTI_SET_RISING_EDGE_TRIGGER             __HAL_USB_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_EXTI_SET_FALLING_EDGE_TRIGGER            __HAL_USB_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_EXTI_SET_FALLINGRISING_TRIGGER           __HAL_USB_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N
N#define __HAL_USB_FS_EXTI_ENABLE_IT                        __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_FS_EXTI_DISABLE_IT                       __HAL_USB_OTG_FS_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_FS_EXTI_GET_FLAG                         __HAL_USB_OTG_FS_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_FS_EXTI_CLEAR_FLAG                       __HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_FS_EXTI_SET_RISING_EGDE_TRIGGER          __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_FS_EXTI_SET_FALLING_EGDE_TRIGGER         __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_FS_EXTI_SET_FALLINGRISING_TRIGGER        __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N#define __HAL_USB_FS_EXTI_GENERATE_SWIT                    __HAL_USB_OTG_FS_WAKEUP_EXTI_GENERATE_SWIT
N
N#define __HAL_USB_HS_EXTI_ENABLE_IT                        __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_USB_HS_EXTI_DISABLE_IT                       __HAL_USB_OTG_HS_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_USB_HS_EXTI_GET_FLAG                         __HAL_USB_OTG_HS_WAKEUP_EXTI_GET_FLAG
N#define __HAL_USB_HS_EXTI_CLEAR_FLAG                       __HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_USB_HS_EXTI_SET_RISING_EGDE_TRIGGER          __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_EDGE
N#define __HAL_USB_HS_EXTI_SET_FALLING_EGDE_TRIGGER         __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_FALLING_EDGE
N#define __HAL_USB_HS_EXTI_SET_FALLINGRISING_TRIGGER        __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
N#define __HAL_USB_HS_EXTI_GENERATE_SWIT                    __HAL_USB_OTG_HS_WAKEUP_EXTI_GENERATE_SWIT
N
N#define HAL_PCD_ActiveRemoteWakeup                         HAL_PCD_ActivateRemoteWakeup
N#define HAL_PCD_DeActiveRemoteWakeup                       HAL_PCD_DeActivateRemoteWakeup
N
N#define HAL_PCD_SetTxFiFo                                  HAL_PCDEx_SetTxFiFo
N#define HAL_PCD_SetRxFiFo                                  HAL_PCDEx_SetRxFiFo
N/**
N  * @}
N  */
N
N/** @defgroup HAL_TIM_Aliased_Macros HAL TIM Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_TIM_SetICPrescalerValue   TIM_SET_ICPRESCALERVALUE
N#define __HAL_TIM_ResetICPrescalerValue TIM_RESET_ICPRESCALERVALUE
N
N#define TIM_GET_ITSTATUS                __HAL_TIM_GET_IT_SOURCE
N#define TIM_GET_CLEAR_IT                __HAL_TIM_CLEAR_IT
N
N#define __HAL_TIM_GET_ITSTATUS          __HAL_TIM_GET_IT_SOURCE
N
N#define __HAL_TIM_DIRECTION_STATUS      __HAL_TIM_IS_TIM_COUNTING_DOWN
N#define __HAL_TIM_PRESCALER             __HAL_TIM_SET_PRESCALER
N#define __HAL_TIM_SetCounter            __HAL_TIM_SET_COUNTER
N#define __HAL_TIM_GetCounter            __HAL_TIM_GET_COUNTER
N#define __HAL_TIM_SetAutoreload         __HAL_TIM_SET_AUTORELOAD
N#define __HAL_TIM_GetAutoreload         __HAL_TIM_GET_AUTORELOAD
N#define __HAL_TIM_SetClockDivision      __HAL_TIM_SET_CLOCKDIVISION
N#define __HAL_TIM_GetClockDivision      __HAL_TIM_GET_CLOCKDIVISION
N#define __HAL_TIM_SetICPrescaler        __HAL_TIM_SET_ICPRESCALER
N#define __HAL_TIM_GetICPrescaler        __HAL_TIM_GET_ICPRESCALER
N#define __HAL_TIM_SetCompare            __HAL_TIM_SET_COMPARE
N#define __HAL_TIM_GetCompare            __HAL_TIM_GET_COMPARE
N
N#define TIM_BREAKINPUTSOURCE_DFSDM  TIM_BREAKINPUTSOURCE_DFSDM1
N/**
N  * @}
N  */
N
N/** @defgroup HAL_ETH_Aliased_Macros HAL ETH Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N#define __HAL_ETH_EXTI_ENABLE_IT                   __HAL_ETH_WAKEUP_EXTI_ENABLE_IT
N#define __HAL_ETH_EXTI_DISABLE_IT                  __HAL_ETH_WAKEUP_EXTI_DISABLE_IT
N#define __HAL_ETH_EXTI_GET_FLAG                    __HAL_ETH_WAKEUP_EXTI_GET_FLAG
N#define __HAL_ETH_EXTI_CLEAR_FLAG                  __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG
N#define __HAL_ETH_EXTI_SET_RISING_EGDE_TRIGGER     __HAL_ETH_WAKEUP_EXTI_ENABLE_RISING_EDGE_TRIGGER
N#define __HAL_ETH_EXTI_SET_FALLING_EGDE_TRIGGER    __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLING_EDGE_TRIGGER
N#define __HAL_ETH_EXTI_SET_FALLINGRISING_TRIGGER   __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER
N
N#define ETH_PROMISCIOUSMODE_ENABLE   ETH_PROMISCUOUS_MODE_ENABLE
N#define ETH_PROMISCIOUSMODE_DISABLE  ETH_PROMISCUOUS_MODE_DISABLE
N#define IS_ETH_PROMISCIOUS_MODE      IS_ETH_PROMISCUOUS_MODE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_LTDC_Aliased_Macros HAL LTDC Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define __HAL_LTDC_LAYER LTDC_LAYER
N#define __HAL_LTDC_RELOAD_CONFIG  __HAL_LTDC_RELOAD_IMMEDIATE_CONFIG
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SAI_Aliased_Macros HAL SAI Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#define SAI_OUTPUTDRIVE_DISABLED          SAI_OUTPUTDRIVE_DISABLE
N#define SAI_OUTPUTDRIVE_ENABLED           SAI_OUTPUTDRIVE_ENABLE
N#define SAI_MASTERDIVIDER_ENABLED         SAI_MASTERDIVIDER_ENABLE
N#define SAI_MASTERDIVIDER_DISABLED        SAI_MASTERDIVIDER_DISABLE
N#define SAI_STREOMODE                     SAI_STEREOMODE
N#define SAI_FIFOStatus_Empty              SAI_FIFOSTATUS_EMPTY
N#define SAI_FIFOStatus_Less1QuarterFull   SAI_FIFOSTATUS_LESS1QUARTERFULL
N#define SAI_FIFOStatus_1QuarterFull       SAI_FIFOSTATUS_1QUARTERFULL
N#define SAI_FIFOStatus_HalfFull           SAI_FIFOSTATUS_HALFFULL
N#define SAI_FIFOStatus_3QuartersFull      SAI_FIFOSTATUS_3QUARTERFULL
N#define SAI_FIFOStatus_Full               SAI_FIFOSTATUS_FULL
N#define IS_SAI_BLOCK_MONO_STREO_MODE      IS_SAI_BLOCK_MONO_STEREO_MODE
N#define SAI_SYNCHRONOUS_EXT               SAI_SYNCHRONOUS_EXT_SAI1
N#define SAI_SYNCEXT_IN_ENABLE             SAI_SYNCEXT_OUTBLOCKA_ENABLE
N/**
N  * @}
N  */
N
N/** @defgroup HAL_SPDIFRX_Aliased_Macros HAL SPDIFRX Aliased Macros maintained for legacy purpose
N  * @{
N  */
N#if defined(STM32H7)
X#if 0L
S#define HAL_SPDIFRX_ReceiveControlFlow      HAL_SPDIFRX_ReceiveCtrlFlow
S#define HAL_SPDIFRX_ReceiveControlFlow_IT   HAL_SPDIFRX_ReceiveCtrlFlow_IT
S#define HAL_SPDIFRX_ReceiveControlFlow_DMA  HAL_SPDIFRX_ReceiveCtrlFlow_DMA
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_HRTIM_Aliased_Functions HAL HRTIM Aliased Functions maintained for legacy purpose
N  * @{
N  */
N#if defined (STM32H7) || defined (STM32F3)
X#if 0L || 0L
S#define HAL_HRTIM_WaveformCounterStart_IT HAL_HRTIM_WaveformCountStart_IT
S#define HAL_HRTIM_WaveformCounterStart_DMA HAL_HRTIM_WaveformCountStart_DMA
S#define HAL_HRTIM_WaveformCounterStart HAL_HRTIM_WaveformCountStart
S#define HAL_HRTIM_WaveformCounterStop_IT HAL_HRTIM_WaveformCountStop_IT
S#define HAL_HRTIM_WaveformCounterStop_DMA HAL_HRTIM_WaveformCountStop_DMA
S#define HAL_HRTIM_WaveformCounterStop HAL_HRTIM_WaveformCountStop
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup HAL_PPP_Aliased_Macros HAL PPP Aliased Macros maintained for legacy purpose
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32_HAL_LEGACY */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 32 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h" 2
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 33 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  HAL Status structures definition  
N  */  
Ntypedef enum 
N{
N  HAL_OK       = 0x00U,
N  HAL_ERROR    = 0x01U,
N  HAL_BUSY     = 0x02U,
N  HAL_TIMEOUT  = 0x03U
N} HAL_StatusTypeDef;
N
N/** 
N  * @brief  HAL Lock structures definition  
N  */
Ntypedef enum 
N{
N  HAL_UNLOCKED = 0x00U,
N  HAL_LOCKED   = 0x01U  
N} HAL_LockTypeDef;
N
N/* Exported macro ------------------------------------------------------------*/
N
N#define UNUSED(X) (void)X      /* To avoid gcc/g++ warnings */
N
N#define HAL_MAX_DELAY      0xFFFFFFFFU
N
N#define HAL_IS_BIT_SET(REG, BIT)         (((REG) & (BIT)) == (BIT))
N#define HAL_IS_BIT_CLR(REG, BIT)         (((REG) & (BIT)) == 0U)
N
N#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \
N                        do{                                                      \
N                              (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__); \
N                              (__DMA_HANDLE__).Parent = (__HANDLE__);             \
N                          } while(0U)
X#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)                                       do{                                                                                    (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__);                               (__DMA_HANDLE__).Parent = (__HANDLE__);                                       } while(0U)
N
N/** @brief Reset the Handle's State field.
N  * @param __HANDLE__ specifies the Peripheral Handle.
N  * @note  This macro can be used for the following purpose: 
N  *          - When the Handle is declared as local variable; before passing it as parameter
N  *            to HAL_PPP_Init() for the first time, it is mandatory to use this macro 
N  *            to set to 0 the Handle's "State" field.
N  *            Otherwise, "State" field may have any random value and the first time the function 
N  *            HAL_PPP_Init() is called, the low level hardware initialization will be missed
N  *            (i.e. HAL_PPP_MspInit() will not be executed).
N  *          - When there is a need to reconfigure the low level hardware: instead of calling
N  *            HAL_PPP_DeInit() then HAL_PPP_Init(), user can make a call to this macro then HAL_PPP_Init().
N  *            In this later function, when the Handle's "State" field is set to 0, it will execute the function
N  *            HAL_PPP_MspInit() which will reconfigure the low level hardware.
N  * @retval None
N  */
N#define __HAL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0U)
N
N#if (USE_RTOS == 1U)
X#if (0U == 1U)
S  /* Reserved for future use */
S  #error "USE_RTOS should be 0 in the current HAL release"
N#else
N  #define __HAL_LOCK(__HANDLE__)                                           \
N                                do{                                        \
N                                    if((__HANDLE__)->Lock == HAL_LOCKED)   \
N                                    {                                      \
N                                       return HAL_BUSY;                    \
N                                    }                                      \
N                                    else                                   \
N                                    {                                      \
N                                       (__HANDLE__)->Lock = HAL_LOCKED;    \
N                                    }                                      \
N                                  }while (0U)
X  #define __HAL_LOCK(__HANDLE__)                                                                           do{                                                                            if((__HANDLE__)->Lock == HAL_LOCKED)                                       {                                                                             return HAL_BUSY;                                                        }                                                                          else                                                                       {                                                                             (__HANDLE__)->Lock = HAL_LOCKED;                                        }                                                                        }while (0U)
N
N  #define __HAL_UNLOCK(__HANDLE__)                                          \
N                                  do{                                       \
N                                      (__HANDLE__)->Lock = HAL_UNLOCKED;    \
N                                    }while (0U)
X  #define __HAL_UNLOCK(__HANDLE__)                                                                            do{                                                                             (__HANDLE__)->Lock = HAL_UNLOCKED;                                        }while (0U)
N#endif /* USE_RTOS */
N
N#if defined ( __GNUC__ ) && !defined (__CC_ARM) /* GNU Compiler */
X#if 0L && !1L  
S  #ifndef __weak
S    #define __weak   __attribute__((weak))
S  #endif /* __weak */
S  #ifndef __packed
S    #define __packed __attribute__((__packed__))
S  #endif /* __packed */
N#endif /* __GNUC__ */
N
N
N/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
N#if defined ( __GNUC__ ) && !defined (__CC_ARM) /* GNU Compiler */
X#if 0L && !1L  
S  #ifndef __ALIGN_END
S#define __ALIGN_END    __attribute__ ((aligned (4)))
S  #endif /* __ALIGN_END */
S  #ifndef __ALIGN_BEGIN  
S    #define __ALIGN_BEGIN
S  #endif /* __ALIGN_BEGIN */
N#else
N  #ifndef __ALIGN_END
N    #define __ALIGN_END
N  #endif /* __ALIGN_END */
N  #ifndef __ALIGN_BEGIN      
N    #if defined   (__CC_ARM)      /* ARM Compiler */
X    #if 1L       
N#define __ALIGN_BEGIN    __align(4)
N    #elif defined (__ICCARM__)    /* IAR Compiler */
S      #define __ALIGN_BEGIN 
N    #endif /* __CC_ARM */
N  #endif /* __ALIGN_BEGIN */
N#endif /* __GNUC__ */
N
N
N/** 
N  * @brief  __RAM_FUNC definition
N  */ 
N#if defined ( __CC_ARM   )
X#if 1L
N/* ARM Compiler
N   ------------
N   RAM functions are defined using the toolchain options. 
N   Functions that are executed in RAM should reside in a separate source module.
N   Using the 'Options for File' dialog you can simply change the 'Code / Const' 
N   area of a module to a memory space in physical RAM.
N   Available memory areas are declared in the 'Target' tab of the 'Options for Target'
N   dialog. 
N*/
N#define __RAM_FUNC
N
N#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S   RAM functions are defined using a specific toolchain keyword "__ramfunc". 
S*/
S#define __RAM_FUNC __ramfunc
S
S#elif defined   (  __GNUC__  )
S/* GNU Compiler
S   ------------
S  RAM functions are defined using a specific toolchain attribute 
S   "__attribute__((section(".RamFunc")))".
S*/
S#define __RAM_FUNC __attribute__((section(".RamFunc")))
S
N#endif
N
N/** 
N  * @brief  __NOINLINE definition
N  */ 
N#if defined ( __CC_ARM   ) || defined   (  __GNUC__  )
X#if 1L || 0L
N/* ARM & GNUCompiler 
N   ---------------- 
N*/
N#define __NOINLINE __attribute__ ( (noinline) )
N
N#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S*/
S#define __NOINLINE _Pragma("optimize = no_inline")
S
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ___STM32F4xx_HAL_DEF */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 30 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rcc.h" 2
N
N/* Include RCC HAL Extended module */
N/* (include on top of file since RCC structures are defined in extended file) */
N#include "stm32f4xx_hal_rcc_ex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rcc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_rcc_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of RCC HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_RCC_EX_H
N#define __STM32F4xx_HAL_RCC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RCCEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Types RCCEx Exported Types
N  * @{
N  */
N
N/**
N  * @brief  RCC PLL configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t PLLState;   /*!< The new state of the PLL.
N                            This parameter can be a value of @ref RCC_PLL_Config                      */
N
N  uint32_t PLLSource;  /*!< RCC_PLLSource: PLL entry clock source.
N                            This parameter must be a value of @ref RCC_PLL_Clock_Source               */
N
N  uint32_t PLLM;       /*!< PLLM: Division factor for PLL VCO input clock.
N                            This parameter must be a number between Min_Data = 0 and Max_Data = 63    */
N
N  uint32_t PLLN;       /*!< PLLN: Multiplication factor for PLL VCO output clock.
N                            This parameter must be a number between Min_Data = 50 and Max_Data = 432 
N                            except for STM32F411xE devices where the Min_Data = 192 */
N
N  uint32_t PLLP;       /*!< PLLP: Division factor for main system clock (SYSCLK).
N                            This parameter must be a value of @ref RCC_PLLP_Clock_Divider             */
N
N  uint32_t PLLQ;       /*!< PLLQ: Division factor for OTG FS, SDIO and RNG clocks.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 15    */
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L || 0L ||    0L || 0L
S  uint32_t PLLR;       /*!< PLLR: PLL division factor for I2S, SAI, SYSTEM, SPDIFRX clocks.
S                            This parameter is only available in STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx
S                            and STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/STM32F413xx/STM32F423xx devices. 
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7     */
N#endif /* STM32F410xx || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */ 
N}RCC_PLLInitTypeDef;
N
N#if defined(STM32F446xx)
X#if 0L
S/** 
S  * @brief  PLLI2S Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLI2SM;    /*!< Specifies division factor for PLL VCO input clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 63       */
S
S  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432    */
S
S  uint32_t PLLI2SP;    /*!< Specifies division factor for SPDIFRX Clock.
S                            This parameter must be a value of @ref RCCEx_PLLI2SP_Clock_Divider           */
S
S  uint32_t PLLI2SQ;    /*!< Specifies the division factor for SAI clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S                           
S  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source I2S */
S}RCC_PLLI2SInitTypeDef;
S
S/** 
S  * @brief  PLLSAI Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLSAIM;    /*!< Spcifies division factor for PLL VCO input clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 63       */
S
S  uint32_t PLLSAIN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432    */
S
S  uint32_t PLLSAIP;    /*!< Specifies division factor for OTG FS, SDIO and RNG clocks.
S                            This parameter must be a value of @ref RCCEx_PLLSAIP_Clock_Divider           */
S                                                             
S  uint32_t PLLSAIQ;    /*!< Specifies the division factor for SAI clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S                            This parameter will be used only when PLLSAI is selected as Clock Source SAI */
S}RCC_PLLSAIInitTypeDef;
S
S/** 
S  * @brief  RCC extended clocks structure definition  
S  */
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
S
S  RCC_PLLSAIInitTypeDef PLLSAI;  /*!< PLL SAI structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI or LTDC */
S
S  uint32_t PLLI2SDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S
S  uint32_t PLLSAIDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLSAI is selected as Clock Source SAI */
S
S  uint32_t Sai1ClockSelection;    /*!< Specifies SAI1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SAI1_Clock_Source */
S
S  uint32_t Sai2ClockSelection;    /*!< Specifies SAI2 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SAI2_Clock_Source */
S                                      
S  uint32_t I2sApb1ClockSelection;    /*!< Specifies I2S APB1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2SAPB1_Clock_Source */
S
S  uint32_t I2sApb2ClockSelection;    /*!< Specifies I2S APB2 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2SAPB2_Clock_Source */
S
S  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t SdioClockSelection;    /*!< Specifies SDIO Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SDIO_Clock_Source */
S
S  uint32_t CecClockSelection;      /*!< Specifies CEC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_CEC_Clock_Source */
S
S  uint32_t Fmpi2c1ClockSelection;  /*!< Specifies FMPI2C1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_FMPI2C1_Clock_Source */
S
S  uint32_t SpdifClockSelection;    /*!< Specifies SPDIFRX Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SPDIFRX_Clock_Source */
S
S  uint32_t Clk48ClockSelection;     /*!< Specifies CLK48 Clock Selection this clock used OTG FS, SDIO and RNG clocks. 
S                                      This parameter can be a value of @ref RCCEx_CLK48_Clock_Source */
S  
S  uint8_t TIMPresSelection;      /*!< Specifies TIM Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F446xx */   
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** 
S  * @brief  RCC extended clocks structure definition
S  */
Stypedef struct
S{
S  uint32_t PeriphClockSelection;   /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  uint32_t I2SClockSelection;      /*!< Specifies RTC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2S_APB_Clock_Source */
S                                      
S  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t Lptim1ClockSelection;   /*!< Specifies LPTIM1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source */
S  
S  uint32_t Fmpi2c1ClockSelection;  /*!< Specifies FMPI2C1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_FMPI2C1_Clock_Source */
S
S  uint8_t TIMPresSelection;        /*!< Specifies TIM Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** 
S  * @brief  PLLI2S Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLI2SM;    /*!< Specifies division factor for PLL VCO input clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 63       */
S
S  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432    */
S
S  uint32_t PLLI2SQ;    /*!< Specifies the division factor for SAI clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S                           
S  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source I2S */
S}RCC_PLLI2SInitTypeDef;
S
S/** 
S  * @brief  RCC extended clocks structure definition
S  */
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S */
S  
S#if defined(STM32F413xx) || defined(STM32F423xx)
S  uint32_t PLLDivR;              /*!< Specifies the PLL division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLL is selected as Clock Source SAI */
S
S  uint32_t PLLI2SDivR;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S#endif /* STM32F413xx || STM32F423xx */  
S                                      
S  uint32_t I2sApb1ClockSelection;    /*!< Specifies I2S APB1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2SAPB1_Clock_Source */
S
S  uint32_t I2sApb2ClockSelection;    /*!< Specifies I2S APB2 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_I2SAPB2_Clock_Source */
S
S  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Source Selection. 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t SdioClockSelection;    /*!< Specifies SDIO Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SDIO_Clock_Source */
S
S  uint32_t Fmpi2c1ClockSelection;  /*!< Specifies FMPI2C1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_FMPI2C1_Clock_Source */
S
S  uint32_t Clk48ClockSelection;     /*!< Specifies CLK48 Clock Selection this clock used OTG FS, SDIO and RNG clocks.
S                                      This parameter can be a value of @ref RCCEx_CLK48_Clock_Source */
S  
S  uint32_t Dfsdm1ClockSelection;    /*!< Specifies DFSDM1 Clock Selection.
S                                      This parameter can be a value of @ref RCCEx_DFSDM1_Kernel_Clock_Source */
S
S  uint32_t Dfsdm1AudioClockSelection;/*!< Specifies DFSDM1 Audio Clock Selection.
S                                      This parameter can be a value of @ref RCCEx_DFSDM1_Audio_Clock_Source */
S  
S#if defined(STM32F413xx) || defined(STM32F423xx)
S  uint32_t Dfsdm2ClockSelection;    /*!< Specifies DFSDM2 Clock Selection.
S                                      This parameter can be a value of @ref RCCEx_DFSDM2_Kernel_Clock_Source */
S
S  uint32_t Dfsdm2AudioClockSelection;/*!< Specifies DFSDM2 Audio Clock Selection.
S                                      This parameter can be a value of @ref RCCEx_DFSDM2_Audio_Clock_Source */
S  
S  uint32_t Lptim1ClockSelection;   /*!< Specifies LPTIM1 Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source */
S  
S  uint32_t SaiAClockSelection;     /*!< Specifies SAI1_A Clock Prescalers Selection
S                                        This parameter can be a value of @ref RCCEx_SAI1_BlockA_Clock_Source */
S
S  uint32_t SaiBClockSelection;     /*!< Specifies SAI1_B Clock Prescalers Selection
S                                        This parameter can be a value of @ref RCCEx_SAI1_BlockB_Clock_Source */
S#endif /* STM32F413xx || STM32F423xx */
S
S  uint32_t PLLI2SSelection;      /*!< Specifies PLL I2S Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_PLL_I2S_Clock_Source */
S
S  uint8_t TIMPresSelection;      /*!< Specifies TIM Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S
S/** 
S  * @brief  PLLI2S Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
S
S  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
S
S  uint32_t PLLI2SQ;    /*!< Specifies the division factor for SAI1 clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
S                            This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S}RCC_PLLI2SInitTypeDef;
S
S/** 
S  * @brief  PLLSAI Clock structure definition  
S  */
Stypedef struct
S{
S  uint32_t PLLSAIN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
S                            This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S                            This parameter will be used only when PLLSAI is selected as Clock Source SAI or LTDC */ 
S#if defined(STM32F469xx) || defined(STM32F479xx)
S  uint32_t PLLSAIP;    /*!< Specifies division factor for OTG FS and SDIO clocks.
S                            This parameter is only available in STM32F469xx/STM32F479xx devices.
S                            This parameter must be a value of @ref RCCEx_PLLSAIP_Clock_Divider  */  
S#endif /* STM32F469xx || STM32F479xx */
S                                 
S  uint32_t PLLSAIQ;    /*!< Specifies the division factor for SAI1 clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S                            This parameter will be used only when PLLSAI is selected as Clock Source SAI or LTDC */
S                              
S  uint32_t PLLSAIR;    /*!< specifies the division factor for LTDC clock
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S                            This parameter will be used only when PLLSAI is selected as Clock Source LTDC */
S
S}RCC_PLLSAIInitTypeDef;
S
S/** 
S  * @brief  RCC extended clocks structure definition  
S  */
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
S
S  RCC_PLLSAIInitTypeDef PLLSAI;  /*!< PLL SAI structure parameters. 
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI or LTDC */
S
S  uint32_t PLLI2SDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI */
S
S  uint32_t PLLSAIDivQ;           /*!< Specifies the PLLI2S division factor for SAI1 clock.
S                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
S                                      This parameter will be used only when PLLSAI is selected as Clock Source SAI */
S
S  uint32_t PLLSAIDivR;           /*!< Specifies the PLLSAI division factor for LTDC clock.
S                                      This parameter must be one value of @ref RCCEx_PLLSAI_DIVR */
S
S  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Prescalers Selection. 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint8_t TIMPresSelection;      /*!< Specifies TIM Clock Prescalers Selection. 
S                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
S#if defined(STM32F469xx) || defined(STM32F479xx)
S  uint32_t Clk48ClockSelection;  /*!< Specifies CLK48 Clock Selection this clock used OTG FS, SDIO and RNG clocks. 
S                                      This parameter can be a value of @ref RCCEx_CLK48_Clock_Source */
S
S  uint32_t SdioClockSelection;   /*!< Specifies SDIO Clock Source Selection. 
S                                      This parameter can be a value of @ref RCCEx_SDIO_Clock_Source */  
S#endif /* STM32F469xx || STM32F479xx */  
S}RCC_PeriphCLKInitTypeDef;
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L
N/** 
N  * @brief  PLLI2S Clock structure definition  
N  */
Ntypedef struct
N{
N#if defined(STM32F411xE)
X#if 0L
S  uint32_t PLLI2SM;    /*!< PLLM: Division factor for PLLI2S VCO input clock.
S                            This parameter must be a number between Min_Data = 2 and Max_Data = 62  */
N#endif /* STM32F411xE */
N                                
N  uint32_t PLLI2SN;    /*!< Specifies the multiplication factor for PLLI2S VCO output clock.
N                            This parameter must be a number between Min_Data = 50 and Max_Data = 432
N                            Except for STM32F411xE devices where the Min_Data = 192. 
N                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N  uint32_t PLLI2SR;    /*!< Specifies the division factor for I2S clock.
N                            This parameter must be a number between Min_Data = 2 and Max_Data = 7. 
N                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N}RCC_PLLI2SInitTypeDef;
N 
N/** 
N  * @brief  RCC extended clocks structure definition  
N  */
Ntypedef struct
N{
N  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
N                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
N
N  RCC_PLLI2SInitTypeDef PLLI2S;  /*!< PLL I2S structure parameters.
N                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI */
N
N  uint32_t RTCClockSelection;      /*!< Specifies RTC Clock Prescalers Selection.
N                                       This parameter can be a value of @ref RCC_RTC_Clock_Source */
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) 
X#if 0L || 1L || 0L 
N  uint8_t TIMPresSelection;        /*!< Specifies TIM Clock Source Selection. 
N                                      This parameter can be a value of @ref RCCEx_TIM_PRescaler_Selection */
N#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
N}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F411xE */
N/**
N  * @}
N  */ 
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Constants RCCEx Exported Constants
N  * @{
N  */
N
N/** @defgroup RCCEx_Periph_Clock_Selection RCC Periph Clock Selection
N  * @{
N  */
N/* Peripheral Clock source for STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx */
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define RCC_PERIPHCLK_I2S_APB1        0x00000001U
S#define RCC_PERIPHCLK_I2S_APB2        0x00000002U
S#define RCC_PERIPHCLK_TIM             0x00000004U
S#define RCC_PERIPHCLK_RTC             0x00000008U
S#define RCC_PERIPHCLK_FMPI2C1         0x00000010U
S#define RCC_PERIPHCLK_CLK48           0x00000020U
S#define RCC_PERIPHCLK_SDIO            0x00000040U
S#define RCC_PERIPHCLK_PLLI2S          0x00000080U
S#define RCC_PERIPHCLK_DFSDM1          0x00000100U
S#define RCC_PERIPHCLK_DFSDM1_AUDIO    0x00000200U
N#endif /* STM32F412Zx || STM32F412Vx) || STM32F412Rx || STM32F412Cx */
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define RCC_PERIPHCLK_DFSDM2          0x00000400U
S#define RCC_PERIPHCLK_DFSDM2_AUDIO    0x00000800U
S#define RCC_PERIPHCLK_LPTIM1          0x00001000U
S#define RCC_PERIPHCLK_SAIA            0x00002000U
S#define RCC_PERIPHCLK_SAIB            0x00004000U
N#endif /* STM32F413xx || STM32F423xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------- Peripheral Clock source for STM32F410xx ----------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define RCC_PERIPHCLK_I2S             0x00000001U
S#define RCC_PERIPHCLK_TIM             0x00000002U
S#define RCC_PERIPHCLK_RTC             0x00000004U
S#define RCC_PERIPHCLK_FMPI2C1         0x00000008U
S#define RCC_PERIPHCLK_LPTIM1          0x00000010U
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------- Peripheral Clock source for STM32F446xx ----------------*/
N#if defined(STM32F446xx)
X#if 0L
S#define RCC_PERIPHCLK_I2S_APB1        0x00000001U
S#define RCC_PERIPHCLK_I2S_APB2        0x00000002U
S#define RCC_PERIPHCLK_SAI1            0x00000004U
S#define RCC_PERIPHCLK_SAI2            0x00000008U
S#define RCC_PERIPHCLK_TIM             0x00000010U
S#define RCC_PERIPHCLK_RTC             0x00000020U
S#define RCC_PERIPHCLK_CEC             0x00000040U
S#define RCC_PERIPHCLK_FMPI2C1         0x00000080U
S#define RCC_PERIPHCLK_CLK48           0x00000100U
S#define RCC_PERIPHCLK_SDIO            0x00000200U
S#define RCC_PERIPHCLK_SPDIFRX         0x00000400U
S#define RCC_PERIPHCLK_PLLI2S          0x00000800U
N#endif /* STM32F446xx */
N/*-----------------------------------------------------------------------------*/
N    
N/*----------- Peripheral Clock source for STM32F469xx/STM32F479xx -------------*/
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S#define RCC_PERIPHCLK_I2S             0x00000001U
S#define RCC_PERIPHCLK_SAI_PLLI2S      0x00000002U
S#define RCC_PERIPHCLK_SAI_PLLSAI      0x00000004U
S#define RCC_PERIPHCLK_LTDC            0x00000008U
S#define RCC_PERIPHCLK_TIM             0x00000010U
S#define RCC_PERIPHCLK_RTC             0x00000020U
S#define RCC_PERIPHCLK_PLLI2S          0x00000040U
S#define RCC_PERIPHCLK_CLK48           0x00000080U
S#define RCC_PERIPHCLK_SDIO            0x00000100U
N#endif /* STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*-------- Peripheral Clock source for STM32F42xxx/STM32F43xxx ---------------*/
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
X#if 0L || 0L || 0L || 0L
S#define RCC_PERIPHCLK_I2S             0x00000001U
S#define RCC_PERIPHCLK_SAI_PLLI2S      0x00000002U
S#define RCC_PERIPHCLK_SAI_PLLSAI      0x00000004U
S#define RCC_PERIPHCLK_LTDC            0x00000008U
S#define RCC_PERIPHCLK_TIM             0x00000010U
S#define RCC_PERIPHCLK_RTC             0x00000020U
S#define RCC_PERIPHCLK_PLLI2S          0x00000040U
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */
N/*----------------------------------------------------------------------------*/
N
N/*-------- Peripheral Clock source for STM32F40xxx/STM32F41xxx ---------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) 
X#if 0L || 0L || 0L|| 0L ||    0L || 1L || 0L 
N#define RCC_PERIPHCLK_I2S             0x00000001U
N#define RCC_PERIPHCLK_RTC             0x00000002U
N#define RCC_PERIPHCLK_PLLI2S          0x00000004U
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F411xE */
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
X#if 0L || 1L || 0L
N#define RCC_PERIPHCLK_TIM             0x00000008U
N#endif /* STM32F401xC || STM32F401xE || STM32F411xE */      
N/*----------------------------------------------------------------------------*/
N/**
N  * @}
N  */
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F469xx) || \
N    defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 1L || 0L || 0L ||     0L 
N/** @defgroup RCCEx_I2S_Clock_Source I2S Clock Source
N  * @{
N  */
N#define RCC_I2SCLKSOURCE_PLLI2S         0x00000000U
N#define RCC_I2SCLKSOURCE_EXT            0x00000001U
N/**
N  * @}
N  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F469xx || STM32F479xx */
N
N/** @defgroup RCCEx_PLLSAI_DIVR RCC PLLSAI DIVR
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L 
S#define RCC_PLLSAIDIVR_2                0x00000000U
S#define RCC_PLLSAIDIVR_4                0x00010000U
S#define RCC_PLLSAIDIVR_8                0x00020000U
S#define RCC_PLLSAIDIVR_16               0x00030000U
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_PLLI2SP_Clock_Divider RCC PLLI2SP Clock Divider
N  * @{
N  */
N#if defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx)
X#if 0L || 0L || 0L ||     0L || 0L
S#define RCC_PLLI2SP_DIV2                  0x00000002U
S#define RCC_PLLI2SP_DIV4                  0x00000004U
S#define RCC_PLLI2SP_DIV6                  0x00000006U
S#define RCC_PLLI2SP_DIV8                  0x00000008U
N#endif /* STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_PLLSAIP_Clock_Divider RCC PLLSAIP Clock Divider
N  * @{
N  */
N#if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L 
S#define RCC_PLLSAIP_DIV2                  0x00000002U
S#define RCC_PLLSAIP_DIV4                  0x00000004U
S#define RCC_PLLSAIP_DIV6                  0x00000006U
S#define RCC_PLLSAIP_DIV8                  0x00000008U
N#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** @defgroup RCCEx_SAI_BlockA_Clock_Source  RCC SAI BlockA Clock Source
S  * @{
S  */
S#define RCC_SAIACLKSOURCE_PLLSAI             0x00000000U
S#define RCC_SAIACLKSOURCE_PLLI2S             0x00100000U
S#define RCC_SAIACLKSOURCE_EXT                0x00200000U
S/**
S  * @}
S  */ 
S
S/** @defgroup RCCEx_SAI_BlockB_Clock_Source  RCC SAI BlockB Clock Source
S  * @{
S  */
S#define RCC_SAIBCLKSOURCE_PLLSAI             0x00000000U
S#define RCC_SAIBCLKSOURCE_PLLI2S             0x00400000U
S#define RCC_SAIBCLKSOURCE_EXT                0x00800000U
S/**
S  * @}
S  */ 
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N      
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S/** @defgroup RCCEx_CLK48_Clock_Source  RCC CLK48 Clock Source
S  * @{
S  */
S#define RCC_CLK48CLKSOURCE_PLLQ              0x00000000U
S#define RCC_CLK48CLKSOURCE_PLLSAIP           ((uint32_t)RCC_DCKCFGR_CK48MSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_SDIO_Clock_Source  RCC SDIO Clock Source
S  * @{
S  */
S#define RCC_SDIOCLKSOURCE_CLK48             0x00000000U
S#define RCC_SDIOCLKSOURCE_SYSCLK            ((uint32_t)RCC_DCKCFGR_SDIOSEL)
S/**
S  * @}
S  */    
S  
S/** @defgroup RCCEx_DSI_Clock_Source  RCC DSI Clock Source
S  * @{
S  */
S#define RCC_DSICLKSOURCE_DSIPHY             0x00000000U
S#define RCC_DSICLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_DSISEL)
S/**
S  * @}
S  */
N#endif /* STM32F469xx || STM32F479xx */
N
N#if defined(STM32F446xx)
X#if 0L
S/** @defgroup RCCEx_SAI1_Clock_Source RCC SAI1 Clock Source 
S  * @{
S  */
S#define RCC_SAI1CLKSOURCE_PLLSAI             0x00000000U
S#define RCC_SAI1CLKSOURCE_PLLI2S             ((uint32_t)RCC_DCKCFGR_SAI1SRC_0)
S#define RCC_SAI1CLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_SAI1SRC_1)
S#define RCC_SAI1CLKSOURCE_EXT                ((uint32_t)RCC_DCKCFGR_SAI1SRC)
S/**
S  * @}
S  */ 
S
S/** @defgroup RCCEx_SAI2_Clock_Source  RCC SAI2 Clock Source
S  * @{
S  */
S#define RCC_SAI2CLKSOURCE_PLLSAI             0x00000000U
S#define RCC_SAI2CLKSOURCE_PLLI2S             ((uint32_t)RCC_DCKCFGR_SAI2SRC_0)
S#define RCC_SAI2CLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_SAI2SRC_1)
S#define RCC_SAI2CLKSOURCE_PLLSRC             ((uint32_t)RCC_DCKCFGR_SAI2SRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_I2SAPB1_Clock_Source  RCC I2S APB1 Clock Source
S  * @{
S  */
S#define RCC_I2SAPB1CLKSOURCE_PLLI2S          0x00000000U
S#define RCC_I2SAPB1CLKSOURCE_EXT             ((uint32_t)RCC_DCKCFGR_I2S1SRC_0)
S#define RCC_I2SAPB1CLKSOURCE_PLLR            ((uint32_t)RCC_DCKCFGR_I2S1SRC_1)
S#define RCC_I2SAPB1CLKSOURCE_PLLSRC          ((uint32_t)RCC_DCKCFGR_I2S1SRC)
S/**
S  * @}
S  */ 
S
S/** @defgroup RCCEx_I2SAPB2_Clock_Source  RCC I2S APB2 Clock Source
S  * @{
S  */
S#define RCC_I2SAPB2CLKSOURCE_PLLI2S          0x00000000U
S#define RCC_I2SAPB2CLKSOURCE_EXT             ((uint32_t)RCC_DCKCFGR_I2S2SRC_0)
S#define RCC_I2SAPB2CLKSOURCE_PLLR            ((uint32_t)RCC_DCKCFGR_I2S2SRC_1)
S#define RCC_I2SAPB2CLKSOURCE_PLLSRC          ((uint32_t)RCC_DCKCFGR_I2S2SRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_FMPI2C1_Clock_Source  RCC FMPI2C1 Clock Source
S  * @{
S  */
S#define RCC_FMPI2C1CLKSOURCE_PCLK1            0x00000000U
S#define RCC_FMPI2C1CLKSOURCE_SYSCLK           ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_0)
S#define RCC_FMPI2C1CLKSOURCE_HSI              ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_1)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_CEC_Clock_Source  RCC CEC Clock Source
S  * @{
S  */
S#define RCC_CECCLKSOURCE_HSI                0x00000000U
S#define RCC_CECCLKSOURCE_LSE                ((uint32_t)RCC_DCKCFGR2_CECSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_CLK48_Clock_Source  RCC CLK48 Clock Source
S  * @{
S  */
S#define RCC_CLK48CLKSOURCE_PLLQ              0x00000000U
S#define RCC_CLK48CLKSOURCE_PLLSAIP           ((uint32_t)RCC_DCKCFGR2_CK48MSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_SDIO_Clock_Source  RCC SDIO Clock Source
S  * @{
S  */
S#define RCC_SDIOCLKSOURCE_CLK48             0x00000000U
S#define RCC_SDIOCLKSOURCE_SYSCLK            ((uint32_t)RCC_DCKCFGR2_SDIOSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_SPDIFRX_Clock_Source   RCC SPDIFRX Clock Source
S  * @{
S  */
S#define RCC_SPDIFRXCLKSOURCE_PLLR           0x00000000U
S#define RCC_SPDIFRXCLKSOURCE_PLLI2SP        ((uint32_t)RCC_DCKCFGR2_SPDIFRXSEL)
S/**
S  * @}
S  */
S
N#endif /* STM32F446xx */
N
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S/** @defgroup RCCEx_SAI1_BlockA_Clock_Source  RCC SAI BlockA Clock Source
S  * @{
S  */
S#define RCC_SAIACLKSOURCE_PLLI2SR            0x00000000U
S#define RCC_SAIACLKSOURCE_EXT                ((uint32_t)RCC_DCKCFGR_SAI1ASRC_0)
S#define RCC_SAIACLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_SAI1ASRC_1)
S#define RCC_SAIACLKSOURCE_PLLSRC             ((uint32_t)RCC_DCKCFGR_SAI1ASRC_0 | RCC_DCKCFGR_SAI1ASRC_1)
S/**
S  * @}
S  */ 
S
S/** @defgroup RCCEx_SAI1_BlockB_Clock_Source  RCC SAI BlockB Clock Source
S  * @{
S  */
S#define RCC_SAIBCLKSOURCE_PLLI2SR            0x00000000U
S#define RCC_SAIBCLKSOURCE_EXT                ((uint32_t)RCC_DCKCFGR_SAI1BSRC_0)
S#define RCC_SAIBCLKSOURCE_PLLR               ((uint32_t)RCC_DCKCFGR_SAI1BSRC_1)
S#define RCC_SAIBCLKSOURCE_PLLSRC             ((uint32_t)RCC_DCKCFGR_SAI1BSRC_0 | RCC_DCKCFGR_SAI1BSRC_1)
S/**
S  * @}
S  */ 
S      
S/** @defgroup RCCEx_LPTIM1_Clock_Source  RCC LPTIM1 Clock Source
S  * @{
S  */
S#define RCC_LPTIM1CLKSOURCE_PCLK1           0x00000000U
S#define RCC_LPTIM1CLKSOURCE_HSI             ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0)
S#define RCC_LPTIM1CLKSOURCE_LSI             ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_1)
S#define RCC_LPTIM1CLKSOURCE_LSE             ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0 | RCC_DCKCFGR2_LPTIM1SEL_1)
S/**
S  * @}
S  */
S      
S
S/** @defgroup RCCEx_DFSDM2_Audio_Clock_Source  RCC DFSDM2 Audio Clock Source
S  * @{
S  */
S#define RCC_DFSDM2AUDIOCLKSOURCE_I2S1       0x00000000U
S#define RCC_DFSDM2AUDIOCLKSOURCE_I2S2       ((uint32_t)RCC_DCKCFGR_CKDFSDM2ASEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_DFSDM2_Kernel_Clock_Source  RCC DFSDM2 Kernel Clock Source
S  * @{
S  */
S#define RCC_DFSDM2CLKSOURCE_PCLK2           0x00000000U
S#define RCC_DFSDM2CLKSOURCE_SYSCLK          ((uint32_t)RCC_DCKCFGR_CKDFSDM1SEL)
S/**
S  * @}
S  */
S
N#endif /* STM32F413xx || STM32F423xx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** @defgroup RCCEx_PLL_I2S_Clock_Source PLL I2S Clock Source
S  * @{
S  */
S#define RCC_PLLI2SCLKSOURCE_PLLSRC          0x00000000U 
S#define RCC_PLLI2SCLKSOURCE_EXT             ((uint32_t)RCC_PLLI2SCFGR_PLLI2SSRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_DFSDM1_Audio_Clock_Source  RCC DFSDM1 Audio Clock Source
S  * @{
S  */
S#define RCC_DFSDM1AUDIOCLKSOURCE_I2S1       0x00000000U
S#define RCC_DFSDM1AUDIOCLKSOURCE_I2S2       ((uint32_t)RCC_DCKCFGR_CKDFSDM1ASEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_DFSDM1_Kernel_Clock_Source  RCC DFSDM1 Kernel Clock Source
S  * @{
S  */
S#define RCC_DFSDM1CLKSOURCE_PCLK2           0x00000000U
S#define RCC_DFSDM1CLKSOURCE_SYSCLK          ((uint32_t)RCC_DCKCFGR_CKDFSDM1SEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_I2SAPB1_Clock_Source  RCC I2S APB1 Clock Source
S  * @{
S  */
S#define RCC_I2SAPB1CLKSOURCE_PLLI2S         0x00000000U
S#define RCC_I2SAPB1CLKSOURCE_EXT            ((uint32_t)RCC_DCKCFGR_I2S1SRC_0)
S#define RCC_I2SAPB1CLKSOURCE_PLLR           ((uint32_t)RCC_DCKCFGR_I2S1SRC_1)
S#define RCC_I2SAPB1CLKSOURCE_PLLSRC         ((uint32_t)RCC_DCKCFGR_I2S1SRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_I2SAPB2_Clock_Source  RCC I2S APB2 Clock Source
S  * @{
S  */
S#define RCC_I2SAPB2CLKSOURCE_PLLI2S         0x00000000U
S#define RCC_I2SAPB2CLKSOURCE_EXT            ((uint32_t)RCC_DCKCFGR_I2S2SRC_0)
S#define RCC_I2SAPB2CLKSOURCE_PLLR           ((uint32_t)RCC_DCKCFGR_I2S2SRC_1)
S#define RCC_I2SAPB2CLKSOURCE_PLLSRC         ((uint32_t)RCC_DCKCFGR_I2S2SRC)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_FMPI2C1_Clock_Source  RCC FMPI2C1 Clock Source
S  * @{
S  */
S#define RCC_FMPI2C1CLKSOURCE_PCLK1          0x00000000U
S#define RCC_FMPI2C1CLKSOURCE_SYSCLK         ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_0)
S#define RCC_FMPI2C1CLKSOURCE_HSI            ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_1)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_CLK48_Clock_Source  RCC CLK48 Clock Source
S  * @{
S  */
S#define RCC_CLK48CLKSOURCE_PLLQ             0x00000000U
S#define RCC_CLK48CLKSOURCE_PLLI2SQ          ((uint32_t)RCC_DCKCFGR2_CK48MSEL)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_SDIO_Clock_Source  RCC SDIO Clock Source
S  * @{
S  */
S#define RCC_SDIOCLKSOURCE_CLK48             0x00000000U
S#define RCC_SDIOCLKSOURCE_SYSCLK            ((uint32_t)RCC_DCKCFGR2_SDIOSEL)
S/**
S  * @}
S  */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S
S/** @defgroup RCCEx_I2S_APB_Clock_Source  RCC I2S APB Clock Source
S  * @{
S  */
S#define RCC_I2SAPBCLKSOURCE_PLLR            0x00000000U
S#define RCC_I2SAPBCLKSOURCE_EXT             ((uint32_t)RCC_DCKCFGR_I2SSRC_0)
S#define RCC_I2SAPBCLKSOURCE_PLLSRC          ((uint32_t)RCC_DCKCFGR_I2SSRC_1)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_FMPI2C1_Clock_Source  RCC FMPI2C1 Clock Source
S  * @{
S  */
S#define RCC_FMPI2C1CLKSOURCE_PCLK1              0x00000000U
S#define RCC_FMPI2C1CLKSOURCE_SYSCLK             ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_0)
S#define RCC_FMPI2C1CLKSOURCE_HSI                ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_1)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_LPTIM1_Clock_Source  RCC LPTIM1 Clock Source
S  * @{
S  */
S#define RCC_LPTIM1CLKSOURCE_PCLK1          0x00000000U
S#define RCC_LPTIM1CLKSOURCE_HSI            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0)
S#define RCC_LPTIM1CLKSOURCE_LSI            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_1)
S#define RCC_LPTIM1CLKSOURCE_LSE            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0 | RCC_DCKCFGR2_LPTIM1SEL_1)
S/**
S  * @}
S  */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
N/** @defgroup RCCEx_TIM_PRescaler_Selection  RCC TIM PRescaler Selection
N  * @{
N  */
N#define RCC_TIMPRES_DESACTIVATED        ((uint8_t)0x00)
N#define RCC_TIMPRES_ACTIVATED           ((uint8_t)0x01)
N/**
N  * @}
N  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
S/** @defgroup RCCEx_LSE_Dual_Mode_Selection  RCC LSE Dual Mode Selection
S  * @{
S  */
S#define RCC_LSE_LOWPOWER_MODE           ((uint8_t)0x00)
S#define RCC_LSE_HIGHDRIVE_MODE          ((uint8_t)0x01)
S/**
S  * @}
S  */
N#endif /* STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx ||\
N          STM32F412Rx || STM32F412Cx */
X#endif  
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 1L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L
N/** @defgroup RCC_MCO2_Clock_Source MCO2 Clock Source
N  * @{
N  */
N#define RCC_MCO2SOURCE_SYSCLK            0x00000000U
N#define RCC_MCO2SOURCE_PLLI2SCLK         RCC_CFGR_MCO2_0
N#define RCC_MCO2SOURCE_HSE               RCC_CFGR_MCO2_1
N#define RCC_MCO2SOURCE_PLLCLK            RCC_CFGR_MCO2
N/**
N  * @}
N  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx ||
N          STM32F412Rx || STM32F413xx | STM32F423xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** @defgroup RCC_MCO2_Clock_Source MCO2 Clock Source
S  * @{
S  */
S#define RCC_MCO2SOURCE_SYSCLK            0x00000000U
S#define RCC_MCO2SOURCE_I2SCLK            RCC_CFGR_MCO2_0
S#define RCC_MCO2SOURCE_HSE               RCC_CFGR_MCO2_1
S#define RCC_MCO2SOURCE_PLLCLK            RCC_CFGR_MCO2
S/**
S  * @}
S  */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/**
N  * @}
N  */
N     
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Macros RCCEx Exported Macros
N  * @{
N  */
N/*------------------- STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx --------*/
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L || 0L || 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOI_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOI_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOF_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOJ_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOJ_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOK_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOK_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_DMA2D_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_DMA2D_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETHMAC_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_ETHMAC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETHMACTX_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_ETHMACTX_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETHMACRX_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
S                                         UNUSED(tmpreg); \
S                                         } while(0U)
X#define __HAL_RCC_ETHMACRX_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                         UNUSED(tmpreg);                                          } while(0U)
S#define __HAL_RCC_ETHMACPTP_CLK_ENABLE() do { \
S                                         __IO uint32_t tmpreg = 0x00U; \
S                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
S                                         /* Delay after an RCC peripheral clock enabling */ \
S                                         tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
S                                         UNUSED(tmpreg); \
S                                         } while(0U)
X#define __HAL_RCC_ETHMACPTP_CLK_ENABLE() do {                                          __IO uint32_t tmpreg = 0x00U;                                          SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                                                                    tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                         UNUSED(tmpreg);                                          } while(0U)
S#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#define __HAL_RCC_GPIOF_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
S#define __HAL_RCC_GPIOG_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
S#define __HAL_RCC_GPIOI_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOIEN))
S#define __HAL_RCC_GPIOJ_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOJEN))
S#define __HAL_RCC_GPIOK_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOKEN))
S#define __HAL_RCC_DMA2D_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA2DEN))
S#define __HAL_RCC_ETHMAC_CLK_DISABLE()          (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACEN))
S#define __HAL_RCC_ETHMACTX_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACTXEN))
S#define __HAL_RCC_ETHMACRX_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACRXEN))
S#define __HAL_RCC_ETHMACPTP_CLK_DISABLE()       (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACPTPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()      (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSULPIEN))
S#define __HAL_RCC_BKPSRAM_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_BKPSRAMEN))
S#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
S#define __HAL_RCC_CRC_CLK_DISABLE()             (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S
S/**
S  * @brief  Enable ETHERNET clock.
S  */
S#define __HAL_RCC_ETH_CLK_ENABLE() do {                                     \
S                                        __HAL_RCC_ETHMAC_CLK_ENABLE();      \
S                                        __HAL_RCC_ETHMACTX_CLK_ENABLE();    \
S                                        __HAL_RCC_ETHMACRX_CLK_ENABLE();    \
S                                      } while(0U)
X#define __HAL_RCC_ETH_CLK_ENABLE() do {                                                                             __HAL_RCC_ETHMAC_CLK_ENABLE();                                              __HAL_RCC_ETHMACTX_CLK_ENABLE();                                            __HAL_RCC_ETHMACRX_CLK_ENABLE();                                          } while(0U)
S/**
S  * @brief  Disable ETHERNET clock.
S  */
S#define __HAL_RCC_ETH_CLK_DISABLE()  do {                                      \
S                                          __HAL_RCC_ETHMACTX_CLK_DISABLE();    \
S                                          __HAL_RCC_ETHMACRX_CLK_DISABLE();    \
S                                          __HAL_RCC_ETHMAC_CLK_DISABLE();      \
S                                        } while(0U)
X#define __HAL_RCC_ETH_CLK_DISABLE()  do {                                                                                __HAL_RCC_ETHMACTX_CLK_DISABLE();                                              __HAL_RCC_ETHMACRX_CLK_DISABLE();                                              __HAL_RCC_ETHMAC_CLK_DISABLE();                                              } while(0U)
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET) 
S#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET) 
S#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET)
S#define __HAL_RCC_GPIOI_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) != RESET) 
S#define __HAL_RCC_GPIOJ_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOJEN)) != RESET) 
S#define __HAL_RCC_GPIOK_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOKEN)) != RESET)
S#define __HAL_RCC_DMA2D_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2DEN)) != RESET) 
S#define __HAL_RCC_ETHMAC_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) != RESET) 
S#define __HAL_RCC_ETHMACTX_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) != RESET)
S#define __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) != RESET)
S#define __HAL_RCC_ETHMACPTP_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) != RESET)
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_ENABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_ENABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) != RESET)
S#define __HAL_RCC_BKPSRAM_IS_CLK_ENABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) != RESET)
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) != RESET) 
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)
S#define __HAL_RCC_ETH_IS_CLK_ENABLED()             (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   && \
S                                                    __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() && \
S                                                    __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()) 
X#define __HAL_RCC_ETH_IS_CLK_ENABLED()             (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   &&                                                     __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() &&                                                     __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()) 
S
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET) 
S#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET) 
S#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET)
S#define __HAL_RCC_GPIOI_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) == RESET) 
S#define __HAL_RCC_GPIOJ_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOJEN)) == RESET) 
S#define __HAL_RCC_GPIOK_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOKEN)) == RESET)
S#define __HAL_RCC_DMA2D_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2DEN)) == RESET) 
S#define __HAL_RCC_ETHMAC_IS_CLK_DISABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) == RESET) 
S#define __HAL_RCC_ETHMACTX_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) == RESET)
S#define __HAL_RCC_ETHMACRX_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) == RESET)
S#define __HAL_RCC_ETHMACPTP_IS_CLK_DISABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) == RESET)
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_DISABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) == RESET)
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) == RESET)
S#define __HAL_RCC_BKPSRAM_IS_CLK_DISABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) == RESET)
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET) 
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
S#define __HAL_RCC_ETH_IS_CLK_DISABLED()             (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   && \
S                                                     __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() && \
S                                                     __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
X#define __HAL_RCC_ETH_IS_CLK_DISABLED()             (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   &&                                                      __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() &&                                                      __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S #define __HAL_RCC_DCMI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X #define __HAL_RCC_DCMI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DCMI_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_DCMIEN))
S
S#if defined(STM32F437xx)|| defined(STM32F439xx) || defined(STM32F479xx)
S#define __HAL_RCC_CRYP_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CRYP_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_HASH_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_HASH_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_CRYP_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_CRYPEN))
S#define __HAL_RCC_HASH_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_HASHEN))
S#endif /* STM32F437xx || STM32F439xx || STM32F479xx */
S
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S
S#define __HAL_RCC_RNG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */ 
S#define __HAL_RCC_DCMI_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) != RESET)
S#define __HAL_RCC_DCMI_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) == RESET)
S
S#if defined(STM32F437xx)|| defined(STM32F439xx) || defined(STM32F479xx)
S#define __HAL_RCC_CRYP_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) != RESET)
S#define __HAL_RCC_CRYP_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) == RESET)
S
S#define __HAL_RCC_HASH_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) != RESET)
S#define __HAL_RCC_HASH_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) == RESET)
S#endif /* STM32F437xx || STM32F439xx || STM32F479xx */
S
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()         ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET) 
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET)     
S/**
S  * @}
S  */   
S
S/** @defgroup RCCEx_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{  
S  */
S#define __HAL_RCC_FMC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FMC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_FMC_CLK_DISABLE()  (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FMCEN))
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_QSPI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_QSPI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_QSPI_CLK_DISABLE()  (RCC->AHB3ENR &= ~(RCC_AHB3ENR_QSPIEN))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S
S/** @defgroup RCCEx_AHB3_Peripheral_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_FMC_IS_CLK_ENABLED()   ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) != RESET)
S#define __HAL_RCC_FMC_IS_CLK_DISABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) == RESET)
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_QSPI_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) != RESET)
S#define __HAL_RCC_QSPI_IS_CLK_DISABLED() ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) == RESET)
S#endif /* STM32F469xx || STM32F479xx */  
S/**
S  * @}
S  */
S    
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM12_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM12_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM13_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM13_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USART3_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART4_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART4_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART5_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART5_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DAC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART7_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART7_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART8_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART8_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S#define __HAL_RCC_TIM6_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_TIM7_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
S#define __HAL_RCC_TIM12_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
S#define __HAL_RCC_TIM13_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
S#define __HAL_RCC_TIM14_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))
S#define __HAL_RCC_USART3_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
S#define __HAL_RCC_UART4_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
S#define __HAL_RCC_UART5_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
S#define __HAL_RCC_CAN1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
S#define __HAL_RCC_CAN2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
S#define __HAL_RCC_DAC_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S#define __HAL_RCC_UART7_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART7EN))
S#define __HAL_RCC_UART8_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART8EN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET)
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET) 
S#define __HAL_RCC_TIM7_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET) 
S#define __HAL_RCC_TIM12_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET) 
S#define __HAL_RCC_TIM13_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET)  
S#define __HAL_RCC_TIM14_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET) 
S#define __HAL_RCC_USART3_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET) 
S#define __HAL_RCC_UART4_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET) 
S#define __HAL_RCC_UART5_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET) 
S#define __HAL_RCC_CAN1_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET)
S#define __HAL_RCC_CAN2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET)
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET) 
S#define __HAL_RCC_UART7_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) != RESET)
S#define __HAL_RCC_UART8_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) != RESET) 
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET)
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET) 
S#define __HAL_RCC_TIM7_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET) 
S#define __HAL_RCC_TIM12_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET) 
S#define __HAL_RCC_TIM13_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET)  
S#define __HAL_RCC_TIM14_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET) 
S#define __HAL_RCC_USART3_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET) 
S#define __HAL_RCC_UART4_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET) 
S#define __HAL_RCC_UART5_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET) 
S#define __HAL_RCC_CAN1_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)
S#define __HAL_RCC_CAN2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET)
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET) 
S#define __HAL_RCC_UART7_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) == RESET)
S#define __HAL_RCC_UART8_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) == RESET) 
S/**
S  * @}
S  */
S    
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC3_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC3_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SAI1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SAI1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_TIM8_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
S#define __HAL_RCC_ADC2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC2EN))
S#define __HAL_RCC_ADC3_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC3EN))
S#define __HAL_RCC_SPI5_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
S#define __HAL_RCC_SPI6_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI6EN))
S#define __HAL_RCC_SAI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI1EN))
S
S#if defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_LTDC_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_LTDC_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_LTDC_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_LTDCEN))
S#endif /* STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_DSI_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DSI_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_DSI_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_DSIEN))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */  
S#define __HAL_RCC_TIM8_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET)
S#define __HAL_RCC_ADC2_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) != RESET)
S#define __HAL_RCC_ADC3_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) != RESET) 
S#define __HAL_RCC_SPI5_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET) 
S#define __HAL_RCC_SPI6_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI6EN)) != RESET) 
S#define __HAL_RCC_SAI1_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) != RESET) 
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET)
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN))!= RESET)  
S
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET)
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN))== RESET)
S#define __HAL_RCC_TIM8_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET)
S#define __HAL_RCC_ADC2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) == RESET)
S#define __HAL_RCC_ADC3_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) == RESET)
S#define __HAL_RCC_SPI5_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)
S#define __HAL_RCC_SPI6_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI6EN)) == RESET)
S#define __HAL_RCC_SAI1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) == RESET)
S
S#if defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_LTDC_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_LTDCEN)) != RESET)
S#define __HAL_RCC_LTDC_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_LTDCEN)) == RESET)
S#endif /* STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_DSI_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_DSIEN)) != RESET)
S#define __HAL_RCC_DSI_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_DSIEN)) == RESET)
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_GPIOI_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOIRST))
S#define __HAL_RCC_ETHMAC_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_ETHMACRST))
S#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_GPIOJ_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOJRST))
S#define __HAL_RCC_GPIOK_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOKRST))
S#define __HAL_RCC_DMA2D_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA2DRST))
S#define __HAL_RCC_CRC_FORCE_RESET()      (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_GPIOI_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOIRST))
S#define __HAL_RCC_ETHMAC_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_ETHMACRST))
S#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_GPIOJ_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOJRST))
S#define __HAL_RCC_GPIOK_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOKRST))
S#define __HAL_RCC_DMA2D_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA2DRST))
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_DCMI_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_DCMIRST))
S
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_DCMI_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_DCMIRST))
S
S#if defined(STM32F437xx)|| defined(STM32F439xx) || defined(STM32F479xx) 
S#define __HAL_RCC_CRYP_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_HASHRST))
S
S#define __HAL_RCC_CRYP_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_HASHRST))
S#endif /* STM32F437xx || STM32F439xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S#define __HAL_RCC_FMC_FORCE_RESET()    (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FMCRST))
S#define __HAL_RCC_FMC_RELEASE_RESET()  (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FMCRST))
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_QSPI_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_QSPIRST))
S#define __HAL_RCC_QSPI_RELEASE_RESET()   (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_QSPIRST))  
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_UART7_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART7RST))
S#define __HAL_RCC_UART8_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART8RST))
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
S
S#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
S#define __HAL_RCC_TIM6_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_USART3_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_CAN1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_DAC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_UART7_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART7RST))
S#define __HAL_RCC_UART8_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART8RST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM8_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SPI5_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
S#define __HAL_RCC_SPI6_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI6RST))
S#define __HAL_RCC_SAI1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI1RST))
S#define __HAL_RCC_SDIO_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()  (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
S
S#define __HAL_RCC_SDIO_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_TIM8_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SPI5_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))
S#define __HAL_RCC_SPI6_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI6RST))
S#define __HAL_RCC_SAI1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI1RST))
S
S#if defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_LTDC_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_LTDCRST))
S#define __HAL_RCC_LTDC_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_LTDCRST))
S#endif /* STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_DSI_FORCE_RESET()   (RCC->APB2RSTR |=  (RCC_APB2RSTR_DSIRST))
S#define __HAL_RCC_DSI_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DSIRST))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOILPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACLPEN))
S#define __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACTXLPEN))
S#define __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACRXLPEN))
S#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACPTPLPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOJLPEN))
S#define __HAL_RCC_GPIOK_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOKLPEN))
S#define __HAL_RCC_SRAM3_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM3LPEN))
S#define __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA2DLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()        (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_BKPSRAMLPEN))
S
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOILPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACLPEN))
S#define __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACTXLPEN))
S#define __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACRXLPEN))
S#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACPTPLPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOJLPEN))
S#define __HAL_RCC_GPIOK_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOKLPEN))
S#define __HAL_RCC_DMA2D_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA2DLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_BKPSRAMLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()   (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()  (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
S
S#define __HAL_RCC_DCMI_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_DCMILPEN))
S#define __HAL_RCC_DCMI_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_DCMILPEN))
S
S#if defined(STM32F437xx)|| defined(STM32F439xx) || defined(STM32F479xx) 
S#define __HAL_RCC_CRYP_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_HASHLPEN))
S
S#define __HAL_RCC_CRYP_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_HASHLPEN))
S#endif /* STM32F437xx || STM32F439xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_LowPower_Enable_Disable AHB3 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_FMC_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FMCLPEN))
S#define __HAL_RCC_FMC_CLK_SLEEP_DISABLE() (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FMCLPEN))
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_QSPILPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE()  (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_QSPILPEN))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */  
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_UART7_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART7LPEN))
S#define __HAL_RCC_UART8_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART8LPEN))
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_UART7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART7LPEN))
S#define __HAL_RCC_UART8_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART8LPEN))
S/**
S  * @}
S  */
S                                        
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */ 
S#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
S#define __HAL_RCC_SPI6_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI6LPEN))
S#define __HAL_RCC_SAI1_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI1LPEN))
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
S
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
S#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))
S#define __HAL_RCC_SPI6_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI6LPEN))
S#define __HAL_RCC_SAI1_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI1LPEN))
S
S#if defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_LTDC_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_LTDCLPEN))
S
S#define __HAL_RCC_LTDC_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_LTDCLPEN))
S#endif /* STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
S
S#if defined(STM32F469xx) || defined(STM32F479xx)
S#define __HAL_RCC_DSI_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |=  (RCC_APB2LPENR_DSILPEN))
S#define __HAL_RCC_DSI_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_DSILPEN))
S#endif /* STM32F469xx || STM32F479xx */
S/**
S  * @}
S  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*----------------------------------- STM32F40xxx/STM32F41xxx-----------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)
X#if 0L || 0L || 0L|| 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOI_CLK_ENABLE()   do { \
S                                       __IO uint32_t tmpreg = 0x00U; \
S                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
S                                       /* Delay after an RCC peripheral clock enabling */ \
S                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);\
S                                       UNUSED(tmpreg); \
S                                       } while(0U)
X#define __HAL_RCC_GPIOI_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN);                                       UNUSED(tmpreg);                                        } while(0U)
S#define __HAL_RCC_GPIOF_CLK_ENABLE()   do { \
S                                       __IO uint32_t tmpreg = 0x00U; \
S                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                       /* Delay after an RCC peripheral clock enabling */ \
S                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                       UNUSED(tmpreg); \
S                                       } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                       UNUSED(tmpreg);                                        } while(0U)
S#define __HAL_RCC_GPIOG_CLK_ENABLE()   do { \
S                                       __IO uint32_t tmpreg = 0x00U; \
S                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                       /* Delay after an RCC peripheral clock enabling */ \
S                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                       UNUSED(tmpreg); \
S                                       } while(0U)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                       UNUSED(tmpreg);                                        } while(0U)
S#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do { \
S                                       __IO uint32_t tmpreg = 0x00U; \
S                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                       /* Delay after an RCC peripheral clock enabling */ \
S                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                       UNUSED(tmpreg); \
S                                       } while(0U)
X#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                       UNUSED(tmpreg);                                        } while(0U)
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do { \
S                                       __IO uint32_t tmpreg = 0x00U; \
S                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                       /* Delay after an RCC peripheral clock enabling */ \
S                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                       UNUSED(tmpreg); \
S                                       } while(0U)
X#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                       UNUSED(tmpreg);                                        } while(0U)
S#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#define __HAL_RCC_GPIOF_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
S#define __HAL_RCC_GPIOG_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
S#define __HAL_RCC_GPIOI_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOIEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()      (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSULPIEN))
S#define __HAL_RCC_BKPSRAM_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_BKPSRAMEN))
S#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
S#define __HAL_RCC_CRC_CLK_DISABLE()             (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S#if defined(STM32F407xx)|| defined(STM32F417xx)
S/**
S  * @brief  Enable ETHERNET clock.
S  */
S#define __HAL_RCC_ETHMAC_CLK_ENABLE()  do { \
S                                       __IO uint32_t tmpreg = 0x00U; \
S                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
S                                       /* Delay after an RCC peripheral clock enabling */ \
S                                       tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);\
S                                       UNUSED(tmpreg); \
S                                       } while(0U)
X#define __HAL_RCC_ETHMAC_CLK_ENABLE()  do {                                        __IO uint32_t tmpreg = 0x00U;                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                                                                tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN);                                       UNUSED(tmpreg);                                        } while(0U)
S#define __HAL_RCC_ETHMACTX_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_ETHMACTX_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETHMACRX_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_ETHMACRX_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETHMACPTP_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_ETHMACPTP_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_ETH_CLK_ENABLE()      do {                            \
S                                        __HAL_RCC_ETHMAC_CLK_ENABLE();      \
S                                        __HAL_RCC_ETHMACTX_CLK_ENABLE();    \
S                                        __HAL_RCC_ETHMACRX_CLK_ENABLE();    \
S                                        } while(0U)
X#define __HAL_RCC_ETH_CLK_ENABLE()      do {                                                                    __HAL_RCC_ETHMAC_CLK_ENABLE();                                              __HAL_RCC_ETHMACTX_CLK_ENABLE();                                            __HAL_RCC_ETHMACRX_CLK_ENABLE();                                            } while(0U)
S
S/**
S  * @brief  Disable ETHERNET clock.
S  */
S#define __HAL_RCC_ETHMAC_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACEN))
S#define __HAL_RCC_ETHMACTX_CLK_DISABLE()  (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACTXEN))
S#define __HAL_RCC_ETHMACRX_CLK_DISABLE()  (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACRXEN))
S#define __HAL_RCC_ETHMACPTP_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACPTPEN))  
S#define __HAL_RCC_ETH_CLK_DISABLE()       do {                             \
S                                           __HAL_RCC_ETHMACTX_CLK_DISABLE();    \
S                                           __HAL_RCC_ETHMACRX_CLK_DISABLE();    \
S                                           __HAL_RCC_ETHMAC_CLK_DISABLE();      \
S                                          } while(0U)
X#define __HAL_RCC_ETH_CLK_DISABLE()       do {                                                                        __HAL_RCC_ETHMACTX_CLK_DISABLE();                                               __HAL_RCC_ETHMACRX_CLK_DISABLE();                                               __HAL_RCC_ETHMAC_CLK_DISABLE();                                                } while(0U)
S#endif /* STM32F407xx || STM32F417xx */
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */  
S#define __HAL_RCC_BKPSRAM_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) != RESET)
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) != RESET)
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()              ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET)
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET)
S#define __HAL_RCC_GPIOI_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) != RESET)
S#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET)
S#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET)
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_ENABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) != RESET)
S
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET)
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET)
S#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET)
S#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET)
S#define __HAL_RCC_GPIOI_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) == RESET)
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_DISABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) == RESET)
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN))== RESET)
S#define __HAL_RCC_BKPSRAM_IS_CLK_DISABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) == RESET)
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET)
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
S#if defined(STM32F407xx)|| defined(STM32F417xx)
S/**
S  * @brief  Enable ETHERNET clock.
S  */
S#define __HAL_RCC_ETHMAC_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) != RESET)
S#define __HAL_RCC_ETHMACTX_IS_CLK_ENABLED()   ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) != RESET)
S#define __HAL_RCC_ETHMACRX_IS_CLK_ENABLED()   ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) != RESET)
S#define __HAL_RCC_ETHMACPTP_IS_CLK_ENABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) != RESET)
S#define __HAL_RCC_ETH_IS_CLK_ENABLED()        (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   && \
S                                               __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() && \
S                                               __HAL_RCC_ETHMACRX_IS_CLK_ENABLED())
X#define __HAL_RCC_ETH_IS_CLK_ENABLED()        (__HAL_RCC_ETHMAC_IS_CLK_ENABLED()   &&                                                __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() &&                                                __HAL_RCC_ETHMACRX_IS_CLK_ENABLED())
S/**
S  * @brief  Disable ETHERNET clock.
S  */
S#define __HAL_RCC_ETHMAC_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) == RESET)
S#define __HAL_RCC_ETHMACTX_IS_CLK_DISABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) == RESET)
S#define __HAL_RCC_ETHMACRX_IS_CLK_DISABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) == RESET)
S#define __HAL_RCC_ETHMACPTP_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) == RESET)
S#define __HAL_RCC_ETH_IS_CLK_DISABLED()        (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   && \
S                                                __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() && \
S                                                __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
X#define __HAL_RCC_ETH_IS_CLK_DISABLED()        (__HAL_RCC_ETHMAC_IS_CLK_DISABLED()   &&                                                 __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() &&                                                 __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())
S#endif /* STM32F407xx || STM32F417xx */
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable 
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S
S#define __HAL_RCC_RNG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))
S
S#if defined(STM32F407xx)|| defined(STM32F417xx) 
S#define __HAL_RCC_DCMI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DCMI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DCMI_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_DCMIEN))
S#endif /* STM32F407xx || STM32F417xx */
S
S#if defined(STM32F415xx) || defined(STM32F417xx)
S#define __HAL_RCC_CRYP_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CRYP_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_CRYPEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_HASH_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_HASH_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_HASHEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CRYP_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_CRYPEN))
S#define __HAL_RCC_HASH_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_HASHEN))
S#endif /* STM32F415xx || STM32F417xx */
S/**
S  * @}
S  */
S
S
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET) 
S
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET)   
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET) 
S
S#if defined(STM32F407xx)|| defined(STM32F417xx) 
S#define __HAL_RCC_DCMI_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) != RESET) 
S#define __HAL_RCC_DCMI_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) == RESET) 
S#endif /* STM32F407xx || STM32F417xx */
S
S#if defined(STM32F415xx) || defined(STM32F417xx)
S#define __HAL_RCC_CRYP_IS_CLK_ENABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) != RESET) 
S#define __HAL_RCC_HASH_IS_CLK_ENABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) != RESET) 
S
S#define __HAL_RCC_CRYP_IS_CLK_DISABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_CRYPEN)) == RESET) 
S#define __HAL_RCC_HASH_IS_CLK_DISABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_HASHEN)) == RESET) 
S#endif /* STM32F415xx || STM32F417xx */  
S/**
S  * @}
S  */  
S  
S/** @defgroup RCCEx_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{  
S  */
S#define __HAL_RCC_FSMC_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FSMC_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_FSMC_CLK_DISABLE() (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FSMCEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Peripheral_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_FSMC_IS_CLK_ENABLED()   ((RCC->AHB3ENR & (RCC_AHB3ENR_FSMCEN)) != RESET) 
S#define __HAL_RCC_FSMC_IS_CLK_DISABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_FSMCEN)) == RESET) 
S/**
S  * @}
S  */   
S   
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{  
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM12_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM12_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM13_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM13_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USART3_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART4_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART4_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART5_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART5_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DAC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S#define __HAL_RCC_TIM6_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_TIM7_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
S#define __HAL_RCC_TIM12_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
S#define __HAL_RCC_TIM13_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
S#define __HAL_RCC_TIM14_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))
S#define __HAL_RCC_USART3_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
S#define __HAL_RCC_UART4_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
S#define __HAL_RCC_UART5_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
S#define __HAL_RCC_CAN1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
S#define __HAL_RCC_CAN2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
S#define __HAL_RCC_DAC_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S/**
S  * @}
S  */
S 
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */ 
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET)
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET) 
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET) 
S#define __HAL_RCC_TIM7_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET) 
S#define __HAL_RCC_TIM12_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET) 
S#define __HAL_RCC_TIM13_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET) 
S#define __HAL_RCC_TIM14_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET) 
S#define __HAL_RCC_USART3_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET) 
S#define __HAL_RCC_UART4_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET) 
S#define __HAL_RCC_UART5_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET) 
S#define __HAL_RCC_CAN1_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET) 
S#define __HAL_RCC_CAN2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET) 
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET) 
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET)
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET) 
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET) 
S#define __HAL_RCC_TIM7_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET) 
S#define __HAL_RCC_TIM12_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET) 
S#define __HAL_RCC_TIM13_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET) 
S#define __HAL_RCC_TIM14_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET) 
S#define __HAL_RCC_USART3_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET) 
S#define __HAL_RCC_UART4_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET) 
S#define __HAL_RCC_UART5_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET) 
S#define __HAL_RCC_CAN1_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET) 
S#define __HAL_RCC_CAN2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET) 
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET) 
S  /**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */ 
S#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC3_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC3_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_TIM8_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
S#define __HAL_RCC_ADC2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC2EN))
S#define __HAL_RCC_ADC3_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC3EN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET)  
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)  
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET) 
S#define __HAL_RCC_TIM8_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET) 
S#define __HAL_RCC_ADC2_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) != RESET) 
S#define __HAL_RCC_ADC3_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) != RESET)
S  
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET)  
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)  
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET) 
S#define __HAL_RCC_TIM8_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET) 
S#define __HAL_RCC_ADC2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) == RESET) 
S#define __HAL_RCC_ADC3_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) == RESET)
S/**
S  * @}
S  */
S    
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_GPIOI_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOIRST))
S#define __HAL_RCC_ETHMAC_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_ETHMACRST))
S#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_GPIOI_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOIRST))
S#define __HAL_RCC_ETHMAC_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_ETHMACRST))
S#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()         (RCC->AHB2RSTR = 0xFFFFFFFFU) 
S#define __HAL_RCC_AHB2_RELEASE_RESET()       (RCC->AHB2RSTR = 0x00U)
S
S#if defined(STM32F407xx)|| defined(STM32F417xx)  
S#define __HAL_RCC_DCMI_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_DCMIRST))
S#define __HAL_RCC_DCMI_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_DCMIRST))
S#endif /* STM32F407xx || STM32F417xx */
S
S#if defined(STM32F415xx) || defined(STM32F417xx) 
S#define __HAL_RCC_CRYP_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_HASHRST))
S
S#define __HAL_RCC_CRYP_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_CRYPRST))
S#define __HAL_RCC_HASH_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_HASHRST))
S#endif /* STM32F415xx || STM32F417xx */
S   
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S
S#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S
S#define __HAL_RCC_FSMC_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FSMCRST))
S#define __HAL_RCC_FSMC_RELEASE_RESET() (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FSMCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
S
S#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
S#define __HAL_RCC_TIM6_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_USART3_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_CAN1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_DAC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM8_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SDIO_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()  (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
S                                          
S#define __HAL_RCC_SDIO_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_TIM8_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
S/**
S  * @}
S  */
S                                        
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOILPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACLPEN))
S#define __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACTXLPEN))
S#define __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE()   (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACRXLPEN))
S#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACPTPLPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_BKPSRAMLPEN))
S
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOILPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACLPEN))
S#define __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACTXLPEN))
S#define __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE()  (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACRXLPEN))
S#define __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACPTPLPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_BKPSRAMLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()   (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()  (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
S
S#if defined(STM32F407xx)|| defined(STM32F417xx) 
S#define __HAL_RCC_DCMI_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_DCMILPEN))
S#define __HAL_RCC_DCMI_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_DCMILPEN))
S#endif /* STM32F407xx || STM32F417xx */
S
S#if defined(STM32F415xx) || defined(STM32F417xx) 
S#define __HAL_RCC_CRYP_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_HASHLPEN))
S
S#define __HAL_RCC_CRYP_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_CRYPLPEN))
S#define __HAL_RCC_HASH_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_HASHLPEN))
S#endif /* STM32F415xx || STM32F417xx */
S/**
S  * @}
S  */
S                                        
S/** @defgroup RCCEx_AHB3_LowPower_Enable_Disable AHB3 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_FSMC_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FSMCLPEN))
S#define __HAL_RCC_FSMC_CLK_SLEEP_DISABLE() (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FSMCLPEN))
S/**
S  * @}
S  */
S                                        
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S/**
S  * @}
S  */
S                                        
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
S
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
S#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC3LPEN))
S/**
S  * @}
S  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------------- STM32F401xE/STM32F401xC --------------------------*/
N#if defined(STM32F401xC) || defined(STM32F401xE)
X#if 0L || 1L
N/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.   
N  * @{
N  */
N#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_CRC_CLK_ENABLE()    do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE()  do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE()  do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_GPIOD_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
N#define __HAL_RCC_GPIOE_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
N#define __HAL_RCC_CRC_CLK_DISABLE()          (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
N#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET) 
N#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET)  
N#define __HAL_RCC_CRC_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)  
N#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) != RESET)  
N
N#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET) 
N#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()        ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET)  
N#define __HAL_RCC_CRC_IS_CLK_DISABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)  
N#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET)  
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the AHB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
N                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
N                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
N                                        
N#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
N#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
N/**
N  * @}
N  */  
N  
N/** @defgroup RCC_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
N#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
N#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
N#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
N#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET) 
N#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET) 
N#define __HAL_RCC_TIM4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET) 
N#define __HAL_RCC_SPI3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET) 
N#define __HAL_RCC_I2C3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
N
N#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET) 
N#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET) 
N#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET) 
N#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET) 
N#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
N#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
N#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
N/**
N  * @}
N  */
N  
N/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_SDIO_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET)  
N#define __HAL_RCC_SPI4_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)   
N#define __HAL_RCC_TIM10_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)  
N
N#define __HAL_RCC_SDIO_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET)
N#define __HAL_RCC_SPI4_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET) 
N#define __HAL_RCC_TIM10_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET) 
N/**
N  * @}
N  */
N/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
N  * @brief  Force or release AHB1 peripheral reset.
N  * @{
N  */  
N#define __HAL_RCC_AHB1_FORCE_RESET()    (RCC->AHB1RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_GPIOD_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
N#define __HAL_RCC_GPIOE_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
N#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
N
N#define __HAL_RCC_AHB1_RELEASE_RESET()  (RCC->AHB1RSTR = 0x00U)
N#define __HAL_RCC_GPIOD_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
N#define __HAL_RCC_GPIOE_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
N#define __HAL_RCC_CRC_RELEASE_RESET()   (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
N  * @brief  Force or release AHB2 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
N#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
N
N#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
N#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
N  * @brief  Force or release APB1 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_APB1_FORCE_RESET()     (RCC->APB1RSTR = 0xFFFFFFFFU)  
N#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
N#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
N#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
N#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
N#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
N
N#define __HAL_RCC_APB1_RELEASE_RESET()   (RCC->APB1RSTR = 0x00U) 
N#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
N#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
N#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
N#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
N#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
N  * @brief  Force or release APB2 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_APB2_FORCE_RESET()     (RCC->APB2RSTR = 0xFFFFFFFFU)  
N#define __HAL_RCC_SDIO_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
N#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
N#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
N
N#define __HAL_RCC_APB2_RELEASE_RESET()   (RCC->APB2RSTR = 0x00U)
N#define __HAL_RCC_SDIO_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
N#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
N#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
N  * @brief  Force or release AHB3 peripheral reset.
N  * @{
N  */ 
N#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable 
N  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
N#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
N#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
N#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
N#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
N
N#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
N#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
N#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
N#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
N#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
N
N#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()   (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
N#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
N#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
N#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
N#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
N
N#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
N#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
N#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
N#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
N#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
N#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
N#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
N
N#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
N#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
N#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
N/**
N  * @}
N  */
N#endif /* STM32F401xC || STM32F401xE*/
N/*----------------------------------------------------------------------------*/
N
N/*-------------------------------- STM32F410xx -------------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable     
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_RNG_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_RNGEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_DISABLE()     (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S#define __HAL_RCC_RNG_CLK_DISABLE()     (RCC->AHB1ENR &= ~(RCC_AHB1ENR_RNGEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_RNGEN)) != RESET)
S      
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_RNGEN)) == RESET)
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable  
S  * @brief  Enable or disable the High Speed APB (APB1) peripheral clock.
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RTCAPB_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RTCAPB_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U) 
X#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                      UNUSED(tmpreg);                                       } while(0U) 
S#define __HAL_RCC_DAC_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S                                        
S#define __HAL_RCC_TIM6_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_RTCAPB_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_RTCAPBEN))
S#define __HAL_RCC_LPTIM1_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_LPTIM1EN))
S#define __HAL_RCC_FMPI2C1_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_FMPI2C1EN))
S#define __HAL_RCC_DAC_CLK_DISABLE()     (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */  
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET) 
S#define __HAL_RCC_RTCAPB_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_RTCAPBEN)) != RESET)
S#define __HAL_RCC_LPTIM1_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) != RESET) 
S#define __HAL_RCC_FMPI2C1_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) != RESET)  
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET) 
S
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET) 
S#define __HAL_RCC_RTCAPB_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_RTCAPBEN)) == RESET)
S#define __HAL_RCC_LPTIM1_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) == RESET) 
S#define __HAL_RCC_FMPI2C1_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) == RESET)  
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET)  
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable  
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @{
S  */  
S#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_EXTIT_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_EXTIT_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI5_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
S#define __HAL_RCC_EXTIT_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_EXTITEN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SPI5_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET)  
S#define __HAL_RCC_EXTIT_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_EXTITEN)) != RESET)  
S  
S#define __HAL_RCC_SPI5_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)  
S#define __HAL_RCC_EXTIT_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_EXTITEN)) == RESET)  
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S#define __HAL_RCC_RNG_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_RNGRST))
S#define __HAL_RCC_CRC_RELEASE_RESET()   (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()   (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_RNGRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()
S#define __HAL_RCC_AHB2_RELEASE_RESET()
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET()
S#define __HAL_RCC_AHB3_RELEASE_RESET()
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM6_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_LPTIM1_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_LPTIM1RST))
S#define __HAL_RCC_FMPI2C1_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_DAC_FORCE_RESET()       (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S
S#define __HAL_RCC_TIM6_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_LPTIM1_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_LPTIM1RST))
S#define __HAL_RCC_FMPI2C1_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_DAC_RELEASE_RESET()     (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_SPI5_FORCE_RESET()      (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
S#define __HAL_RCC_SPI5_RELEASE_RESET()    (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))                                        
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable  
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_RNGLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_RNGLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable                                         
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_LPTIM1LPEN))
S#define __HAL_RCC_RTCAPB_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_RTCAPBLPEN))
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_LPTIM1LPEN))
S#define __HAL_RCC_RTCAPB_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_RTCAPBLPEN))
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()     (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable                                         
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @{
S  */
S#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE()     (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
S#define __HAL_RCC_EXTIT_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_EXTITLPEN))                                
S#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))                                        
S#define __HAL_RCC_EXTIT_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_EXTITLPEN))
S/**
S  * @}
S  */
S
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*----------------------------------------------------------------------------*/
N
N/*-------------------------------- STM32F411xx -------------------------------*/
N#if defined(STM32F411xE)
X#if 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
S#define __HAL_RCC_CRC_CLK_DISABLE()             (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */  
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET) 
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) != RESET) 
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET) 
S
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET) 
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET) 
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET) 
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEX_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S/**
S  * @}
S  */  
S
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S/**
S  * @}
S  */ 
S  
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET) 
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET) 
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET) 
S/**
S  * @}
S  */ 
S  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @{
S  */
S#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_SPI5_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET)  
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)   
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)  
S#define __HAL_RCC_SPI5_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET) 
S
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET)  
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)   
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET)  
S#define __HAL_RCC_SPI5_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)   
S/**
S  * @}
S  */  
S  
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_GPIOD_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_CRC_FORCE_RESET()     (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
S
S#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_SPI5_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
S#define __HAL_RCC_SDIO_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
S
S#define __HAL_RCC_SDIO_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_SPI5_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S                                        
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))                                        
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()   (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @{
S  */
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @{
S  */
S#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
S
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
S#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))
S/**
S  * @}
S  */
N#endif /* STM32F411xE */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F446xx -----------------------------*/
N#if defined(STM32F446xx)
X#if 0L
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_BKPSRAM_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CCMDATARAMEN_CLK_ENABLE() do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CCMDATARAMEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_CRC_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                        UNUSED(tmpreg); \
S                                        } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                        UNUSED(tmpreg);                                         } while(0U)
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOF_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOG_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USB_OTG_HS_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOD_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#define __HAL_RCC_GPIOE_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#define __HAL_RCC_GPIOF_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
S#define __HAL_RCC_GPIOG_CLK_DISABLE()           (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_DISABLE()      (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE() (RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSULPIEN))
S#define __HAL_RCC_BKPSRAM_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_BKPSRAMEN))
S#define __HAL_RCC_CCMDATARAMEN_CLK_DISABLE()    (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CCMDATARAMEN))
S#define __HAL_RCC_CRC_CLK_DISABLE()             (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET) 
S#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET) 
S#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()            ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET) 
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) != RESET)  
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_ENABLED()  ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) != RESET) 
S#define __HAL_RCC_BKPSRAM_IS_CLK_ENABLED()          ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) != RESET)  
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN))!= RESET)  
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()              ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET) 
S
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET) 
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET) 
S#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET) 
S#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()           ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET) 
S#define __HAL_RCC_USB_OTG_HS_IS_CLK_DISABLED()      ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) == RESET)  
S#define __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_DISABLED() ((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) == RESET) 
S#define __HAL_RCC_BKPSRAM_IS_CLK_DISABLED()         ((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) == RESET)  
S#define __HAL_RCC_CCMDATARAMEN_IS_CLK_DISABLED()    ((RCC->AHB1ENR & (RCC_AHB1ENR_CCMDATARAMEN)) == RESET)  
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()             ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET) 
S/**
S  * @}
S  */  
S  
S/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_DCMI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DCMI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DCMI_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_DCMIEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S
S#define __HAL_RCC_RNG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_DCMI_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) != RESET)
S#define __HAL_RCC_DCMI_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) == RESET)
S
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()    ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET) 
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()   ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET) 
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#define __HAL_RCC_FMC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FMC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_QSPI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_QSPI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_FMC_CLK_DISABLE()    (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FMCEN))
S#define __HAL_RCC_QSPI_CLK_DISABLE()   (RCC->AHB3ENR &= ~(RCC_AHB3ENR_QSPIEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Peripheral_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_FMC_IS_CLK_ENABLED()   ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) != RESET)
S#define __HAL_RCC_QSPI_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) != RESET)
S
S#define __HAL_RCC_FMC_IS_CLK_DISABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) == RESET)
S#define __HAL_RCC_QSPI_IS_CLK_DISABLED() ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) == RESET)
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM12_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM12_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM13_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM13_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPDIFRX_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPDIFRX_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_USART3_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART4_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART4_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART5_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART5_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CEC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CEC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_DAC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_SPI3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#define __HAL_RCC_I2C3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S#define __HAL_RCC_TIM6_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_TIM7_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
S#define __HAL_RCC_TIM12_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
S#define __HAL_RCC_TIM13_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
S#define __HAL_RCC_TIM14_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))
S#define __HAL_RCC_SPDIFRX_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPDIFRXEN))
S#define __HAL_RCC_USART3_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
S#define __HAL_RCC_UART4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
S#define __HAL_RCC_UART5_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
S#define __HAL_RCC_FMPI2C1_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_FMPI2C1EN))
S#define __HAL_RCC_CAN1_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
S#define __HAL_RCC_CAN2_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
S#define __HAL_RCC_CEC_CLK_DISABLE()     (RCC->APB1ENR &= ~(RCC_APB1ENR_CECEN))
S#define __HAL_RCC_DAC_CLK_DISABLE()     (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET)
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET)
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET)
S#define __HAL_RCC_TIM7_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET)
S#define __HAL_RCC_TIM12_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET)
S#define __HAL_RCC_TIM13_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET)
S#define __HAL_RCC_TIM14_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET)
S#define __HAL_RCC_SPDIFRX_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_SPDIFRXEN)) != RESET)
S#define __HAL_RCC_USART3_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET)
S#define __HAL_RCC_UART4_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET)
S#define __HAL_RCC_UART5_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET)
S#define __HAL_RCC_FMPI2C1_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) != RESET)
S#define __HAL_RCC_CAN1_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET)
S#define __HAL_RCC_CAN2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET)
S#define __HAL_RCC_CEC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) != RESET)
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET)
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)  
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET)
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET) 
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET)
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET)
S#define __HAL_RCC_TIM7_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET)
S#define __HAL_RCC_TIM12_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET)
S#define __HAL_RCC_TIM13_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET)
S#define __HAL_RCC_TIM14_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET)
S#define __HAL_RCC_SPDIFRX_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_SPDIFRXEN)) == RESET)
S#define __HAL_RCC_USART3_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET)
S#define __HAL_RCC_UART4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET)
S#define __HAL_RCC_UART5_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET)
S#define __HAL_RCC_FMPI2C1_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) == RESET)
S#define __HAL_RCC_CAN1_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)
S#define __HAL_RCC_CAN2_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET)
S#define __HAL_RCC_CEC_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) == RESET)
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET)
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_ADC3_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_ADC3_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SAI1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SAI1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SAI2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SAI2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SDIO_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_TIM8_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
S#define __HAL_RCC_ADC2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC2EN))
S#define __HAL_RCC_ADC3_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC3EN))
S#define __HAL_RCC_SAI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI1EN))
S#define __HAL_RCC_SAI2_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI2EN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET) 
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET) 
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)  
S#define __HAL_RCC_TIM8_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET)
S#define __HAL_RCC_ADC2_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) != RESET) 
S#define __HAL_RCC_ADC3_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) != RESET) 
S#define __HAL_RCC_SAI1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) != RESET)
S#define __HAL_RCC_SAI2_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI2EN)) != RESET)
S
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET) 
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET) 
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET)  
S#define __HAL_RCC_TIM8_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET)
S#define __HAL_RCC_ADC2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) == RESET) 
S#define __HAL_RCC_ADC3_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) == RESET) 
S#define __HAL_RCC_SAI1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) == RESET)
S#define __HAL_RCC_SAI2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SAI2EN)) == RESET) 
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_USB_OTG_HS_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_CRC_FORCE_RESET()      (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#define __HAL_RCC_GPIOF_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
S#define __HAL_RCC_USB_OTG_HS_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_OTGHRST))
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU) 
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_DCMI_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_DCMIRST))
S
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_DCMI_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_DCMIRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S
S#define __HAL_RCC_FMC_FORCE_RESET()    (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FMCRST))
S#define __HAL_RCC_QSPI_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_QSPIRST))
S
S#define __HAL_RCC_FMC_RELEASE_RESET()    (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FMCRST))
S#define __HAL_RCC_QSPI_RELEASE_RESET()   (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_QSPIRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_SPDIFRX_FORCE_RESET()  (RCC->APB1RSTR |= (RCC_APB1RSTR_SPDIFRXRST))
S#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_FMPI2C1_FORCE_RESET()  (RCC->APB1RSTR |= (RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_CEC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_CECRST))
S#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))
S                                          
S#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_SPI3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#define __HAL_RCC_I2C3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))
S#define __HAL_RCC_TIM6_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))
S#define __HAL_RCC_SPDIFRX_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPDIFRXRST))
S#define __HAL_RCC_USART3_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
S#define __HAL_RCC_UART4_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
S#define __HAL_RCC_FMPI2C1_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_CAN1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
S#define __HAL_RCC_CEC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CECRST))
S#define __HAL_RCC_DAC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset 
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM8_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SAI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI1RST)) 
S#define __HAL_RCC_SAI2_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI2RST))
S#define __HAL_RCC_SDIO_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))
S
S#define __HAL_RCC_SDIO_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_TIM8_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
S#define __HAL_RCC_SAI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI1RST))
S#define __HAL_RCC_SAI2_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI2RST)) 
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable 
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()  (RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()        (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_BKPSRAMLPEN))
S
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
S#define __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSLPEN))
S#define __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE() (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSULPILPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S#define __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_BKPSRAMLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()   (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()  (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
S
S#define __HAL_RCC_DCMI_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_DCMILPEN))
S#define __HAL_RCC_DCMI_CLK_SLEEP_DISABLE() (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_DCMILPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_LowPower_Enable_Disable AHB3 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_FMC_CLK_SLEEP_ENABLE()   (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FMCLPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_QSPILPEN))
S
S#define __HAL_RCC_FMC_CLK_SLEEP_DISABLE()   (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FMCLPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE()  (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_QSPILPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */ 
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_SPDIFRX_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_SPDIFRXLPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_CEC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_CECLPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
S#define __HAL_RCC_SPDIFRX_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPDIFRXLPEN))
S#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
S#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
S#define __HAL_RCC_CEC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CECLPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SAI1_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI1LPEN))
S#define __HAL_RCC_SAI2_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI2LPEN))
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE() (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))
S
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))
S#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
S#define __HAL_RCC_ADC2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC2LPEN))
S#define __HAL_RCC_ADC3_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC3LPEN))
S#define __HAL_RCC_SAI1_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI1LPEN))
S#define __HAL_RCC_SAI2_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI2LPEN))
S/**
S  * @}
S  */
S
N#endif /* STM32F446xx */
N/*----------------------------------------------------------------------------*/
N
N/*-------STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx-------*/
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) 
X#if 0L || 0L || 0L || 0L || 0L || 0L 
S/** @defgroup RCCEx_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define __HAL_RCC_GPIOE_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)                                        
S#define __HAL_RCC_GPIOF_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_GPIOG_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_GPIOG_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */                                       
S#define __HAL_RCC_CRC_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                        
X#define __HAL_RCC_CRC_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                                                              tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN);                                      UNUSED(tmpreg);                                       } while(0U)                                        
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define __HAL_RCC_GPIOD_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define __HAL_RCC_GPIOE_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))
S#define __HAL_RCC_GPIOG_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_CLK_DISABLE()          (RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET)
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET)
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET)
S#define __HAL_RCC_GPIOG_IS_CLK_ENABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET)
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_IS_CLK_ENABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)
S
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET)
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET)
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET)
S#define __HAL_RCC_GPIOG_IS_CLK_DISABLED()     ((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET)
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_IS_CLK_DISABLED()       ((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#if defined(STM32F423xx)
S#define __HAL_RCC_AES_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_AESEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_AESEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_AES_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_AESEN);                                                                              tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_AESEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_AES_CLK_DISABLE()  (RCC->AHB2ENR &= ~(RCC_AHB2ENR_AESEN))
S#endif /* STM32F423xx */
S                                        
S#define __HAL_RCC_RNG_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RNG_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                                                                  tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_RNG_CLK_DISABLE()   (RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))
S                                     
S#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));\
S                                               __HAL_RCC_SYSCFG_CLK_ENABLE();\
S                                              }while(0U)
X#define __HAL_RCC_USB_OTG_FS_CLK_ENABLE()  do {(RCC->AHB2ENR |= (RCC_AHB2ENR_OTGFSEN));                                               __HAL_RCC_SYSCFG_CLK_ENABLE();                                              }while(0U)
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_DISABLE() (RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Peripheral_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#if defined(STM32F423xx)
S#define __HAL_RCC_AES_IS_CLK_ENABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_AESEN)) != RESET)
S#define __HAL_RCC_AES_IS_CLK_DISABLED()       ((RCC->AHB2ENR & (RCC_AHB2ENR_AESEN)) == RESET)
S#endif /* STM32F423xx */
S                                        
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()  ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)
S#define __HAL_RCC_USB_OTG_FS_IS_CLK_DISABLED() ((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)
S          
S#define __HAL_RCC_RNG_IS_CLK_ENABLED()         ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET)   
S#define __HAL_RCC_RNG_IS_CLK_DISABLED()        ((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET)   
S/**
S  * @}
S  */  
S
S/** @defgroup RCCEx_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
S  * @brief  Enables or disables the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_FSMC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FSMC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_QSPI_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_QSPI_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                                                              tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN);                                      UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_FSMC_CLK_DISABLE()    (RCC->AHB3ENR &= ~(RCC_AHB3ENR_FSMCEN))
S#define __HAL_RCC_QSPI_CLK_DISABLE()    (RCC->AHB3ENR &= ~(RCC_AHB3ENR_QSPIEN))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */ 
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Peripheral_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the AHB3 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_FSMC_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_FSMCEN)) != RESET) 
S#define __HAL_RCC_QSPI_IS_CLK_ENABLED()  ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) != RESET) 
S
S#define __HAL_RCC_FSMC_IS_CLK_DISABLED() ((RCC->AHB3ENR & (RCC_AHB3ENR_FSMCEN)) == RESET)
S#define __HAL_RCC_QSPI_IS_CLK_DISABLED() ((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) == RESET)
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it. 
S  * @{
S  */
S#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM12_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM12_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM13_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM13_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM14_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)                                        
S#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_LPTIM1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F413xx || STM32F423xx */  
S#define __HAL_RCC_RTCAPB_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_RTCAPB_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCAPBEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_USART3_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART4_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART5_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART5_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F413xx || STM32F423xx */
S                                        
S#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_FMPI2C1_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_FMPI2C1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_CAN2_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN2_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_CAN3_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F413xx || STM32F423xx */
S#define __HAL_RCC_TIM2_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_TIM4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_SPI3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_I2C3_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_I2C3_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DAC_CLK_ENABLE()    do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DAC_CLK_ENABLE()    do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART7_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART7_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART8_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART8_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                                                              tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#endif /* STM32F413xx || STM32F423xx */
S                                        
S#define __HAL_RCC_TIM2_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
S#define __HAL_RCC_TIM3_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
S#define __HAL_RCC_TIM4_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))
S#define __HAL_RCC_TIM6_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
S#define __HAL_RCC_TIM7_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
S#define __HAL_RCC_TIM12_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))
S#define __HAL_RCC_TIM13_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))
S#define __HAL_RCC_TIM14_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN)) 
S#if defined(STM32F413xx) || defined(STM32F423xx)                 
S#define __HAL_RCC_LPTIM1_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_LPTIM1EN))
S#endif /* STM32F413xx || STM32F423xx */
S#define __HAL_RCC_RTCAPB_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_RTCAPBEN))                                       
S#define __HAL_RCC_SPI3_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_USART3_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S#if defined(STM32F413xx) || defined(STM32F423xx)   
S#define __HAL_RCC_UART4_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))
S#define __HAL_RCC_UART5_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_I2C3_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))
S#define __HAL_RCC_FMPI2C1_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_FMPI2C1EN))
S#define __HAL_RCC_CAN1_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))
S#define __HAL_RCC_CAN2_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CAN3EN))                                        
S#define __HAL_RCC_DAC_CLK_DISABLE()     (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
S#define __HAL_RCC_UART7_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART7EN))
S#define __HAL_RCC_UART8_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_UART8EN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S                                        
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB1 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET)
S#define __HAL_RCC_TIM4_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET)
S#define __HAL_RCC_TIM6_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET)
S#define __HAL_RCC_TIM7_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET)
S#define __HAL_RCC_TIM12_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET)
S#define __HAL_RCC_TIM13_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET)
S#define __HAL_RCC_TIM14_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET) 
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) != RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                            
S#define __HAL_RCC_RTCAPB_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_RTCAPBEN)) != RESET)                                    
S#define __HAL_RCC_SPI3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET)
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_USART3_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET)
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx | STM32F423xx */
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET) 
S#define __HAL_RCC_UART5_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_I2C3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)
S#define __HAL_RCC_FMPI2C1_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) != RESET)
S#define __HAL_RCC_CAN1_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN))!= RESET)
S#define __HAL_RCC_CAN2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN3EN)) != RESET)
S#define __HAL_RCC_DAC_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET) 
S#define __HAL_RCC_UART7_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) != RESET)
S#define __HAL_RCC_UART8_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) != RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                         
S
S#define __HAL_RCC_TIM2_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET) 
S#define __HAL_RCC_TIM3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET)
S#define __HAL_RCC_TIM4_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET)
S#define __HAL_RCC_TIM6_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET)
S#define __HAL_RCC_TIM7_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET)
S#define __HAL_RCC_TIM12_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET)
S#define __HAL_RCC_TIM13_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET)
S#define __HAL_RCC_TIM14_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)                                          
S#define __HAL_RCC_LPTIM1_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) == RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_RTCAPB_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_RTCAPBEN)) == RESET)                                        
S#define __HAL_RCC_SPI3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET)
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_USART3_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET)
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx | STM32F423xx */
S#if defined(STM32F413xx) || defined(STM32F423xx)                                           
S#define __HAL_RCC_UART4_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET) 
S#define __HAL_RCC_UART5_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET) 
S#endif /* STM32F413xx || STM32F423xx */                                          
S#define __HAL_RCC_I2C3_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)
S#define __HAL_RCC_FMPI2C1_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_FMPI2C1EN)) == RESET)
S#define __HAL_RCC_CAN1_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)
S#define __HAL_RCC_CAN2_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)                                        
S#define __HAL_RCC_CAN3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_CAN3EN)) == RESET)
S#define __HAL_RCC_DAC_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET) 
S#define __HAL_RCC_UART7_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) == RESET)
S#define __HAL_RCC_UART8_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) == RESET)
S#endif /* STM32F413xx || STM32F423xx */                                         
S/**
S  * @}
S  */  
S/** @defgroup RCCEx_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
S  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before 
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_TIM8_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_UART9EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_UART9EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_UART9_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_UART9EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_UART9EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_UART10_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_UART10EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_UART10EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                          
X#define __HAL_RCC_UART10_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_UART10EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_UART10EN);                                      UNUSED(tmpreg);                                       } while(0U)                                          
S#endif /* STM32F413xx || STM32F423xx */                                   
S#define __HAL_RCC_SDIO_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U) 
X#define __HAL_RCC_SDIO_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDIOEN);                                        UNUSED(tmpreg);                                       } while(0U) 
S#define __HAL_RCC_SPI4_CLK_ENABLE()     do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI4_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN);                                        UNUSED(tmpreg);                                       } while(0U)
S#define __HAL_RCC_EXTIT_CLK_ENABLE()  do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                        
X#define __HAL_RCC_EXTIT_CLK_ENABLE()  do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_EXTITEN);                                      UNUSED(tmpreg);                                       } while(0U)                                        
S#define __HAL_RCC_TIM10_CLK_ENABLE()    do { \
S                                        __IO uint32_t tmpreg = 0x00U; \
S                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U) 
X#define __HAL_RCC_TIM10_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN);                                        UNUSED(tmpreg);                                       } while(0U) 
S#define __HAL_RCC_SPI5_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_SPI5_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_CLK_ENABLE()   do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                         
X#define __HAL_RCC_SAI1_CLK_ENABLE()   do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN);                                      UNUSED(tmpreg);                                       } while(0U)                                         
S#endif /* STM32F413xx || STM32F423xx */                                          
S#define __HAL_RCC_DFSDM1_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_DFSDM1_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN);                                      UNUSED(tmpreg);                                       } while(0U)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_CLK_ENABLE() do { \
S                                      __IO uint32_t tmpreg = 0x00U; \
S                                      SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM2EN);\
S                                      /* Delay after an RCC peripheral clock enabling */ \
S                                      tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM2EN);\
S                                      UNUSED(tmpreg); \
S                                      } while(0U)                                        
X#define __HAL_RCC_DFSDM2_CLK_ENABLE() do {                                       __IO uint32_t tmpreg = 0x00U;                                       SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM2EN);                                                                              tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM2EN);                                      UNUSED(tmpreg);                                       } while(0U)                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S 
S#define __HAL_RCC_TIM8_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_UART9EN))
S#define __HAL_RCC_UART10_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_UART10EN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_SDIO_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SDIOEN))
S#define __HAL_RCC_SPI4_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))
S#define __HAL_RCC_EXTIT_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_EXTITEN))
S#define __HAL_RCC_TIM10_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))
S#define __HAL_RCC_SPI5_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_CLK_DISABLE()    (RCC->APB2ENR &= ~(RCC_APB2ENR_SAI1EN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_DFSDM1EN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_DFSDM2EN))                                      
S#endif /* STM32F413xx || STM32F423xx */                                         
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
S  * @brief  Get the enable or disable status of the APB2 peripheral clock.
S  * @note   After reset, the peripheral clock (used for registers read/write access)
S  *         is disabled and the application software has to enable this clock before
S  *         using it.
S  * @{
S  */
S#define __HAL_RCC_TIM8_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_UART9EN)) != RESET)
S#define __HAL_RCC_UART10_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_UART10EN)) != RESET)                                        
S#endif /* STM32F413xx || STM32F423xx */                                          
S#define __HAL_RCC_SDIO_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) != RESET) 
S#define __HAL_RCC_SPI4_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)
S#define __HAL_RCC_EXTIT_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_EXTITEN)) != RESET)
S#define __HAL_RCC_TIM10_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)
S#define __HAL_RCC_SPI5_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) != RESET)                                    
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_DFSDM1_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM1EN)) != RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM2EN)) != RESET)                                  
S#endif /* STM32F413xx || STM32F423xx */                                         
S
S#define __HAL_RCC_TIM8_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_UART9EN)) == RESET) 
S#define __HAL_RCC_UART10_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_UART10EN)) == RESET)                                         
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_SDIO_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SDIOEN)) == RESET) 
S#define __HAL_RCC_SPI4_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)
S#define __HAL_RCC_EXTIT_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_EXTITEN)) == RESET)
S#define __HAL_RCC_TIM10_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET)
S#define __HAL_RCC_SPI5_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) == RESET)                                       
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM1EN)) == RESET)
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_DFSDM2EN)) == RESET)                                       
S#endif /* STM32F413xx || STM32F423xx */                                         
S/**
S  * @}
S  */
S  
S/** @defgroup RCCEx_AHB1_Force_Release_Reset AHB1 Force Release Reset 
S  * @brief  Force or release AHB1 peripheral reset.
S  * @{
S  */
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOD_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOE_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_FORCE_RESET()      (RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))
S
S#if defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOD_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))
S#endif /* STM32F412Rx || STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOE_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))
S#endif /* STM32F412Vx || STM32F412Zx ||  STM32F413xx || STM32F423xx */
S#if defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_GPIOF_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))
S#define __HAL_RCC_GPIOG_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))
S#endif /*  STM32F412Zx || STM32F413xx || STM32F423xx */
S#define __HAL_RCC_CRC_RELEASE_RESET()    (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_Force_Release_Reset AHB2 Force Release Reset 
S  * @brief  Force or release AHB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_AHB2_FORCE_RESET()    (RCC->AHB2RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB2_RELEASE_RESET()  (RCC->AHB2RSTR = 0x00U)
S
S#if defined(STM32F423xx)
S#define __HAL_RCC_AES_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_AESRST))
S#define __HAL_RCC_AES_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_AESRST))                                        
S#endif /* STM32F423xx */ 
S                                        
S#define __HAL_RCC_USB_OTG_FS_FORCE_RESET()   (RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))
S#define __HAL_RCC_USB_OTG_FS_RELEASE_RESET() (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))
S
S#define __HAL_RCC_RNG_FORCE_RESET()    (RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))
S#define __HAL_RCC_RNG_RELEASE_RESET()  (RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_Force_Release_Reset AHB3 Force Release Reset 
S  * @brief  Force or release AHB3 peripheral reset.
S  * @{
S  */ 
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_AHB3_FORCE_RESET() (RCC->AHB3RSTR = 0xFFFFFFFFU)
S#define __HAL_RCC_AHB3_RELEASE_RESET() (RCC->AHB3RSTR = 0x00U) 
S
S#define __HAL_RCC_FSMC_FORCE_RESET()    (RCC->AHB3RSTR |= (RCC_AHB3RSTR_FSMCRST))
S#define __HAL_RCC_QSPI_FORCE_RESET()   (RCC->AHB3RSTR |= (RCC_AHB3RSTR_QSPIRST))
S
S#define __HAL_RCC_FSMC_RELEASE_RESET()    (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FSMCRST))
S#define __HAL_RCC_QSPI_RELEASE_RESET()   (RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_QSPIRST))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */ 
S#if defined(STM32F412Cx)
S#define __HAL_RCC_AHB3_FORCE_RESET()
S#define __HAL_RCC_AHB3_RELEASE_RESET()
S
S#define __HAL_RCC_FSMC_FORCE_RESET()
S#define __HAL_RCC_QSPI_FORCE_RESET()
S
S#define __HAL_RCC_FSMC_RELEASE_RESET()
S#define __HAL_RCC_QSPI_RELEASE_RESET()
S#endif /* STM32F412Cx */
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_Force_Release_Reset APB1 Force Release Reset 
S  * @brief  Force or release APB1 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST)) 
S#define __HAL_RCC_TIM4_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))                                        
S#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST)) 
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_LPTIM1RST)) 
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SPI3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))                                        
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))                                        
S#endif /* STM32F413xx || STM32F423xx */                                          
S#define __HAL_RCC_I2C3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))                                        
S#define __HAL_RCC_FMPI2C1_FORCE_RESET()  (RCC->APB1RSTR |= (RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_CAN1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_CAN3RST))
S#define __HAL_RCC_DAC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_UART7_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART7RST))
S#define __HAL_RCC_UART8_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_UART8RST))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S
S#define __HAL_RCC_TIM2_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
S#define __HAL_RCC_TIM3_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
S#define __HAL_RCC_TIM4_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))
S#define __HAL_RCC_TIM6_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
S#define __HAL_RCC_TIM7_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
S#define __HAL_RCC_TIM12_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))
S#define __HAL_RCC_TIM13_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))
S#define __HAL_RCC_TIM14_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST)) 
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_LPTIM1RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SPI3_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_USART3_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))
S#define __HAL_RCC_UART5_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_I2C3_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))                                        
S#define __HAL_RCC_FMPI2C1_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_FMPI2C1RST))
S#define __HAL_RCC_CAN1_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))
S#define __HAL_RCC_CAN2_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN3RST))
S#define __HAL_RCC_DAC_RELEASE_RESET()     (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
S#define __HAL_RCC_UART7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART7RST))
S#define __HAL_RCC_UART8_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART8RST))                                      
S#endif /* STM32F413xx || STM32F423xx */                                         
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_Force_Release_Reset APB2 Force Release Reset
S  * @brief  Force or release APB2 peripheral reset.
S  * @{
S  */
S#define __HAL_RCC_TIM8_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_UART9RST))
S#define __HAL_RCC_UART10_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_UART10RST))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SDIO_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))                                        
S#define __HAL_RCC_SPI5_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SAI1RST))
S#endif /* STM32F413xx || STM32F423xx */                                         
S#define __HAL_RCC_DFSDM1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_DFSDM1RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_DFSDM2RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S
S#define __HAL_RCC_TIM8_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_UART9RST))
S#define __HAL_RCC_UART10_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_UART10RST))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SDIO_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDIORST))
S#define __HAL_RCC_SPI4_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))
S#define __HAL_RCC_TIM10_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))
S#define __HAL_RCC_SPI5_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI1RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DFSDM1RST))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DFSDM2RST))
S#endif /* STM32F413xx || STM32F423xx */                                        
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE()        (RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()      (RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S
S#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))
S#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))
S#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))
S#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))
S#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE()       (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))
S#define __HAL_RCC_FLITF_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))
S#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()     (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB2_LowPower_Enable_Disable AHB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#if defined(STM32F423xx)
S#define __HAL_RCC_AES_CLK_SLEEP_ENABLE()      (RCC->AHB2LPENR |= (RCC_AHB2LPENR_AESLPEN))                                        
S#define __HAL_RCC_AES_CLK_SLEEP_DISABLE()     (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_AESLPEN))
S#endif /* STM32F423xx */
S                                        
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()  (RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))
S#define __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()   (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))
S
S#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE()   (RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))
S#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE()  (RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_AHB3_LowPower_Enable_Disable AHB3 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_FSMC_CLK_SLEEP_ENABLE()   (RCC->AHB3LPENR |= (RCC_AHB3LPENR_FSMCLPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE()  (RCC->AHB3LPENR |= (RCC_AHB3LPENR_QSPILPEN))
S
S#define __HAL_RCC_FSMC_CLK_SLEEP_DISABLE()   (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FSMCLPEN))
S#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE()  (RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_QSPILPEN))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))                                        
S#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_LPTIM1LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_RTCAPB_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_RTCAPBLPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))                                       
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))                                        
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_ENABLE() (RCC->APB1LPENR |= (RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_CAN3LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_UART7_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART7LPEN))
S#define __HAL_RCC_UART8_CLK_SLEEP_ENABLE()   (RCC->APB1LPENR |= (RCC_APB1LPENR_UART8LPEN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S
S#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))
S#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))
S#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))
S#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))
S#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))
S#define __HAL_RCC_TIM12_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))
S#define __HAL_RCC_TIM13_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))
S#define __HAL_RCC_TIM14_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_LPTIM1LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_RTCAPB_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_RTCAPBLPEN))
S#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))                                        
S#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))
S#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F413xx || STM32F423xx */
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))
S#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                
S#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))                                        
S#define __HAL_RCC_FMPI2C1_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_FMPI2C1LPEN))
S#define __HAL_RCC_CAN1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))
S#define __HAL_RCC_CAN2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_CAN3_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN3LPEN))
S#define __HAL_RCC_DAC_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))
S#define __HAL_RCC_UART7_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART7LPEN))
S#define __HAL_RCC_UART8_CLK_SLEEP_DISABLE()  (RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART8LPEN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                     
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
S  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
S  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
S  *         power consumption.
S  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
S  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
S  * @{
S  */
S#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_UART9LPEN))
S#define __HAL_RCC_UART10_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_UART10LPEN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SDIO_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))  
S#define __HAL_RCC_EXTIT_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_EXTITLPEN)) 
S#define __HAL_RCC_TIM10_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))                                        
S#define __HAL_RCC_SPI5_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SAI1LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_DFSDM1LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_DFSDM2LPEN))
S#endif /* STM32F413xx || STM32F423xx */
S                                        
S#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_UART9_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_UART9LPEN))
S#define __HAL_RCC_UART10_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_UART10LPEN))                                        
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_SDIO_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDIOLPEN))
S#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))
S#define __HAL_RCC_EXTIT_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_EXTITLPEN))
S#define __HAL_RCC_TIM10_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))    
S#define __HAL_RCC_SPI5_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_SAI1_CLK_SLEEP_DISABLE()    (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI1LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S#define __HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_DFSDM1LPEN))
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define __HAL_RCC_DFSDM2_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_DFSDM2LPEN))
S#endif /* STM32F413xx || STM32F423xx */                                        
S/**
S  * @}
S  */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------------------- PLL Configuration --------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F446xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
S/** @brief  Macro to configure the main PLL clock source, multiplication and division factors.
S  * @note   This function must be used only when the main PLL is disabled.
S  * @param  __RCC_PLLSource__ specifies the PLL entry clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
S  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
S  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
S  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 2 MHz to limit PLL jitter.
S  * @param  __PLLN__ specifies the multiplication factor for PLL VCO output clock
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
S  *         output frequency is between 100 and 432 MHz.
S  *   
S  * @param  __PLLP__ specifies the division factor for main system clock (SYSCLK)
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  *           
S  * @param  __PLLQ__ specifies the division factor for OTG FS, SDIO and RNG clocks
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  * @note   If the USB OTG FS is used in your application, you have to set the
S  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
S  *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
S  *         correctly.
S  *     
S  * @param  __PLLR__ PLL division factor for I2S, SAI, SYSTEM, SPDIFRX clocks.
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   This parameter is only available in STM32F446xx/STM32F469xx/STM32F479xx/
S            STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/STM32F413xx/STM32F423xx devices.
S  *      
S  */
S#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__,__PLLR__)  \
S                            (RCC->PLLCFGR = ((__RCC_PLLSource__) | (__PLLM__)                   | \
S                            ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos)                      | \
S                            ((((__PLLP__) >> 1U) -1U) << RCC_PLLCFGR_PLLP_Pos)          | \
S                            ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos)                      | \
S                            ((__PLLR__) << RCC_PLLCFGR_PLLR_Pos)))
X#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__,__PLLR__)                              (RCC->PLLCFGR = ((__RCC_PLLSource__) | (__PLLM__)                   |                             ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos)                      |                             ((((__PLLP__) >> 1U) -1U) << RCC_PLLCFGR_PLLP_Pos)          |                             ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos)                      |                             ((__PLLR__) << RCC_PLLCFGR_PLLR_Pos)))
N#else
N/** @brief  Macro to configure the main PLL clock source, multiplication and division factors.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __RCC_PLLSource__ specifies the PLL entry clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
N  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
N  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
N  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
N  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
N  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
N  *         of 2 MHz to limit PLL jitter.
N  * @param  __PLLN__ specifies the multiplication factor for PLL VCO output clock
N  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432
N  *         Except for STM32F411xE devices where Min_Data = 192.
N  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
N  *         output frequency is between 100 and 432 MHz, Except for STM32F411xE devices
N  *         where frequency is between 192 and 432 MHz.
N  * @param  __PLLP__ specifies the division factor for main system clock (SYSCLK)
N  *         This parameter must be a number in the range {2, 4, 6, or 8}.
N  *           
N  * @param  __PLLQ__ specifies the division factor for OTG FS, SDIO and RNG clocks
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
N  * @note   If the USB OTG FS is used in your application, you have to set the
N  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
N  *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
N  *         correctly.
N  *      
N  */
N#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__)     \
N                            (RCC->PLLCFGR = (0x20000000U | (__RCC_PLLSource__) | (__PLLM__)| \
N                            ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos)                | \
N                            ((((__PLLP__) >> 1U) -1U) << RCC_PLLCFGR_PLLP_Pos)    | \
N                            ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos)))
X#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSource__, __PLLM__, __PLLN__, __PLLP__, __PLLQ__)                                 (RCC->PLLCFGR = (0x20000000U | (__RCC_PLLSource__) | (__PLLM__)|                             ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos)                |                             ((((__PLLP__) >> 1U) -1U) << RCC_PLLCFGR_PLLP_Pos)    |                             ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos)))
N #endif /* STM32F410xx || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*----------------------------------------------------------------------------*/
N                             
N/*----------------------------PLLI2S Configuration ---------------------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 1L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
N
N/** @brief Macros to enable or disable the PLLI2S. 
N  * @note  The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.
N  */
N#define __HAL_RCC_PLLI2S_ENABLE() (*(__IO uint32_t *) RCC_CR_PLLI2SON_BB = ENABLE)
N#define __HAL_RCC_PLLI2S_DISABLE() (*(__IO uint32_t *) RCC_CR_PLLI2SON_BB = DISABLE)
N
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || 
N          STM32F412Rx || STM32F412Cx */
N#if defined(STM32F446xx)
X#if 0L
S/** @brief  Macro to configure the PLLI2S clock multiplication and division factors .
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   PLLI2S clock source is common with the main PLL (configured in 
S  *         HAL_RCC_ClockConfig() API).
S  * @param  __PLLI2SM__ specifies the division factor for PLLI2S VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLI2SM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 1 MHz to limit PLLI2S jitter.
S  *
S  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLI2SP__ specifies division factor for SPDIFRX Clock.
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  * @note   the PLLI2SP parameter is only available with STM32F446xx Devices
S  *                 
S  * @param  __PLLI2SR__ specifies the division factor for I2S clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
S  *         on the I2S clock frequency.
S  *   
S  * @param  __PLLI2SQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  */
S#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SP__, __PLLI2SQ__, __PLLI2SR__)    \
S                               (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                   |\
S                               ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |\
S                               ((((__PLLI2SP__) >> 1U) -1U) << RCC_PLLI2SCFGR_PLLI2SP_Pos) |\
S                               ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos)             |\
S                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
X#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SP__, __PLLI2SQ__, __PLLI2SR__)                                   (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                   |                               ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |                               ((((__PLLI2SP__) >> 1U) -1U) << RCC_PLLI2SCFGR_PLLI2SP_Pos) |                               ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos)             |                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
S#elif defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
S      defined(STM32F413xx) || defined(STM32F423xx)
X#elif 0L || 0L || 0L || 0L ||      0L || 0L
S/** @brief  Macro to configure the PLLI2S clock multiplication and division factors .
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   PLLI2S clock source is common with the main PLL (configured in 
S  *         HAL_RCC_ClockConfig() API).
S  * @param  __PLLI2SM__ specifies the division factor for PLLI2S VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLI2SM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 1 MHz to limit PLLI2S jitter.
S  *
S  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLI2SR__ specifies the division factor for I2S clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
S  *         on the I2S clock frequency.
S  *
S  * @param  __PLLI2SQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  */
S#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SQ__, __PLLI2SR__)    \
S                               (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                   |\
S                               ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |\
S                               ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos)             |\
S                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
X#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SQ__, __PLLI2SR__)                                   (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                   |                               ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |                               ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos)             |                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
N#else
N/** @brief  Macro to configure the PLLI2S clock multiplication and division factors .
N  * @note   This macro must be used only when the PLLI2S is disabled.
N  * @note   PLLI2S clock source is common with the main PLL (configured in 
N  *         HAL_RCC_ClockConfig() API).
N  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock
N  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
N  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
N  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
N  *
N  * @param  __PLLI2SR__ specifies the division factor for I2S clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
N  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
N  *         on the I2S clock frequency.
N  *
N  */
N#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SN__, __PLLI2SR__)                                                    \
N                               (RCC->PLLI2SCFGR = (((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)  |\
N                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
X#define __HAL_RCC_PLLI2S_CONFIG(__PLLI2SN__, __PLLI2SR__)                                                                                   (RCC->PLLI2SCFGR = (((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)  |                               ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
N#endif /* STM32F446xx */
N
N#if defined(STM32F411xE)
X#if 0L
S/** @brief  Macro to configure the PLLI2S clock multiplication and division factors .
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   PLLI2S clock source is common with the main PLL (configured in 
S  *         HAL_RCC_ClockConfig() API).
S  * @param  __PLLI2SM__ specifies the division factor for PLLI2S VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   The PLLI2SM parameter is only used with STM32F411xE/STM32F410xx Devices
S  * @note   You have to set the PLLI2SM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 2 MHz to limit PLLI2S jitter.    
S  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock
S  *         This parameter must be a number between Min_Data = 192 and Max_Data = 432.
S  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 192 and Max_Data = 432 MHz.
S  * @param  __PLLI2SR__ specifies the division factor for I2S clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
S  *         on the I2S clock frequency.
S  */
S#define __HAL_RCC_PLLI2S_I2SCLK_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SR__) (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                                       |\
S                                                                                                  ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |\
S                                                                                                  ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
X#define __HAL_RCC_PLLI2S_I2SCLK_CONFIG(__PLLI2SM__, __PLLI2SN__, __PLLI2SR__) (RCC->PLLI2SCFGR = ((__PLLI2SM__)                                                       |                                                                                                  ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos)             |                                                                                                  ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos)))
N#endif /* STM32F411xE */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** @brief  Macro used by the SAI HAL driver to configure the PLLI2S clock multiplication and division factors.
S  * @note   This macro must be used only when the PLLI2S is disabled.
S  * @note   PLLI2S clock source is common with the main PLL (configured in 
S  *         HAL_RCC_ClockConfig() API)             
S  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock.
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  * @param  __PLLI2SQ__ specifies the division factor for SAI1 clock.
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15. 
S  * @note   the PLLI2SQ parameter is only available with STM32F427xx/437xx/429xx/439xx/469xx/479xx 
S  *         Devices and can be configured using the __HAL_RCC_PLLI2S_PLLSAICLK_CONFIG() macro
S  * @param  __PLLI2SR__ specifies the division factor for I2S clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
S  *         on the I2S clock frequency.
S  */
S#define __HAL_RCC_PLLI2S_SAICLK_CONFIG(__PLLI2SN__, __PLLI2SQ__, __PLLI2SR__) (RCC->PLLI2SCFGR = ((__PLLI2SN__) << 6U)  |\
S                                                                                                 ((__PLLI2SQ__) << 24U) |\
S                                                                                                 ((__PLLI2SR__) << 28U))
X#define __HAL_RCC_PLLI2S_SAICLK_CONFIG(__PLLI2SN__, __PLLI2SQ__, __PLLI2SR__) (RCC->PLLI2SCFGR = ((__PLLI2SN__) << 6U)  |                                                                                                 ((__PLLI2SQ__) << 24U) |                                                                                                 ((__PLLI2SR__) << 28U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */   
N/*----------------------------------------------------------------------------*/
N
N/*------------------------------ PLLSAI Configuration ------------------------*/
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L
S/** @brief Macros to Enable or Disable the PLLISAI. 
S  * @note  The PLLSAI is only available with STM32F429x/439x Devices.
S  * @note  The PLLSAI is disabled by hardware when entering STOP and STANDBY modes. 
S  */
S#define __HAL_RCC_PLLSAI_ENABLE() (*(__IO uint32_t *) RCC_CR_PLLSAION_BB = ENABLE)
S#define __HAL_RCC_PLLSAI_DISABLE() (*(__IO uint32_t *) RCC_CR_PLLSAION_BB = DISABLE)
S
S#if defined(STM32F446xx)
S/** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
S  *
S  * @param  __PLLSAIM__ specifies the division factor for PLLSAI VCO input clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
S  * @note   You have to set the PLLSAIM parameter correctly to ensure that the VCO input
S  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
S  *         of 1 MHz to limit PLLI2S jitter.
S  * @note   The PLLSAIM parameter is only used with STM32F446xx Devices
S  *             
S  * @param  __PLLSAIN__ specifies the multiplication factor for PLLSAI VCO output clock.
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLSAIP__ specifies division factor for OTG FS, SDIO and RNG clocks.
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  * @note   the PLLSAIP parameter is only available with STM32F446xx Devices
S  *                 
S  * @param  __PLLSAIQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  *           
S  * @param  __PLLSAIR__ specifies the division factor for LTDC clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   the PLLI2SR parameter is only available with STM32F427/437/429/439xx Devices  
S  */
S#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIM__, __PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__)     \
S                               (RCC->PLLSAICFGR = ((__PLLSAIM__)                                   | \
S                               ((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)             | \
S                               ((((__PLLSAIP__) >> 1U) -1U) << RCC_PLLSAICFGR_PLLSAIP_Pos) | \
S                               ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos))) 
X#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIM__, __PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__)                                    (RCC->PLLSAICFGR = ((__PLLSAIM__)                                   |                                ((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)             |                                ((((__PLLSAIP__) >> 1U) -1U) << RCC_PLLSAICFGR_PLLSAIP_Pos) |                                ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos))) 
S#endif /* STM32F446xx */
S                                 
S#if defined(STM32F469xx) || defined(STM32F479xx)
S/** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
S  *             
S  * @param  __PLLSAIN__ specifies the multiplication factor for PLLSAI VCO output clock.
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLSAIP__ specifies division factor for SDIO and CLK48 clocks.
S  *         This parameter must be a number in the range {2, 4, 6, or 8}.
S  *                 
S  * @param  __PLLSAIQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  *           
S  * @param  __PLLSAIR__ specifies the division factor for LTDC clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.  
S  */
S#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__) \
S                               (RCC->PLLSAICFGR = (((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)             |\
S                                                   ((((__PLLSAIP__) >> 1U) -1U) << RCC_PLLSAICFGR_PLLSAIP_Pos) |\
S                                                   ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos)             |\
S                                                   ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos)))
X#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIP__, __PLLSAIQ__, __PLLSAIR__)                                (RCC->PLLSAICFGR = (((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)             |                                                   ((((__PLLSAIP__) >> 1U) -1U) << RCC_PLLSAICFGR_PLLSAIP_Pos) |                                                   ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos)             |                                                   ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos)))
S#endif /* STM32F469xx || STM32F479xx */                                 
S
S#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
S/** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
S  *             
S  * @param  __PLLSAIN__ specifies the multiplication factor for PLLSAI VCO output clock.
S  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
S  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
S  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
S  *
S  * @param  __PLLSAIQ__ specifies the division factor for SAI clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
S  *           
S  * @param  __PLLSAIR__ specifies the division factor for LTDC clock
S  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
S  * @note   the PLLI2SR parameter is only available with STM32F427/437/429/439xx Devices  
S  */
S#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIQ__, __PLLSAIR__)                                        \
S                               (RCC->PLLSAICFGR = (((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)  | \
S                               ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos)                      | \
S                               ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos)))
X#define __HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__, __PLLSAIQ__, __PLLSAIR__)                                                                       (RCC->PLLSAICFGR = (((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos)  |                                ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos)                      |                                ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos)))
S#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------- PLLSAI/PLLI2S Dividers Configuration -------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S/** @brief  Macro to configure the SAI clock Divider coming from PLLI2S.
S  * @note   This function must be called before enabling the PLLI2S.
S  * @param  __PLLI2SDivR__ specifies the PLLI2S division factor for SAI1 clock.
S  *          This parameter must be a number between 1 and 32.
S  *          SAI1 clock frequency = f(PLLI2SR) / __PLLI2SDivR__ 
S  */
S#define __HAL_RCC_PLLI2S_PLLSAICLKDIVR_CONFIG(__PLLI2SDivR__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLI2SDIVR, (__PLLI2SDivR__)-1U))
S
S/** @brief  Macro to configure the SAI clock Divider coming from PLL.
S  * @param  __PLLDivR__ specifies the PLL division factor for SAI1 clock.
S  *          This parameter must be a number between 1 and 32.
S  *          SAI1 clock frequency = f(PLLR) / __PLLDivR__ 
S  */
S#define __HAL_RCC_PLL_PLLSAICLKDIVR_CONFIG(__PLLDivR__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLDIVR, ((__PLLDivR__)-1U)<<8U))                                 
N#endif /* STM32F413xx || STM32F423xx */  
N                                 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)  || defined(STM32F446xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L  || 0L ||    0L || 0L
S/** @brief  Macro to configure the SAI clock Divider coming from PLLI2S.
S  * @note   This function must be called before enabling the PLLI2S.
S  * @param  __PLLI2SDivQ__ specifies the PLLI2S division factor for SAI1 clock.
S  *          This parameter must be a number between 1 and 32.
S  *          SAI1 clock frequency = f(PLLI2SQ) / __PLLI2SDivQ__ 
S  */
S#define __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(__PLLI2SDivQ__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLI2SDIVQ, (__PLLI2SDivQ__)-1U))
S
S/** @brief  Macro to configure the SAI clock Divider coming from PLLSAI.
S  * @note   This function must be called before enabling the PLLSAI.
S  * @param  __PLLSAIDivQ__ specifies the PLLSAI division factor for SAI1 clock .
S  *         This parameter must be a number between Min_Data = 1 and Max_Data = 32.
S  *         SAI1 clock frequency = f(PLLSAIQ) / __PLLSAIDivQ__  
S  */
S#define __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(__PLLSAIDivQ__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLSAIDIVQ, ((__PLLSAIDivQ__)-1U)<<8U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S/** @brief  Macro to configure the LTDC clock Divider coming from PLLSAI.
S  * 
S  * @note   The LTDC peripheral is only available with STM32F427/437/429/439/469/479xx Devices.
S  * @note   This function must be called before enabling the PLLSAI. 
S  * @param  __PLLSAIDivR__ specifies the PLLSAI division factor for LTDC clock .
S  *          This parameter must be a number between Min_Data = 2 and Max_Data = 16.
S  *          LTDC clock frequency = f(PLLSAIR) / __PLLSAIDivR__ 
S  */
S#define __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(__PLLSAIDivR__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_PLLSAIDIVR, (__PLLSAIDivR__)))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------------- Peripheral Clock selection -----------------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F469xx) ||\
N    defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L
N/** @brief  Macro to configure the I2S clock source (I2SCLK).
N  * @note   This function must be called before enabling the I2S APB clock.
N  * @param  __SOURCE__ specifies the I2S clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_I2SCLKSOURCE_PLLI2S: PLLI2S clock used as I2S clock source.
N  *            @arg RCC_I2SCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin
N  *                                       used as I2S clock source.
N  */
N#define __HAL_RCC_I2S_CONFIG(__SOURCE__) (*(__IO uint32_t *) RCC_CFGR_I2SSRC_BB = (__SOURCE__))
N
N
N/** @brief  Macro to get the I2S clock source (I2SCLK).
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_I2SCLKSOURCE_PLLI2S: PLLI2S clock used as I2S clock source.
N  *            @arg @ref RCC_I2SCLKSOURCE_EXT External clock mapped on the I2S_CKIN pin
N  *                                        used as I2S clock source
N  */
N#define __HAL_RCC_GET_I2S_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_I2SSRC)))
N#endif /* STM32F40xxx || STM32F41xxx || STM32F42xxx || STM32F43xxx || STM32F469xx || STM32F479xx */
N                                 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S                                 
S/** @brief  Macro to configure SAI1BlockA clock source selection.
S  * @note   The SAI peripheral is only available with STM32F427/437/429/439/469/479xx Devices.      
S  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI Block A clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAIACLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
S  *                                           as SAI1 Block A clock. 
S  *            @arg RCC_SAIACLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
S  *                                           as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_Ext: External clock mapped on the I2S_CKIN pin
S  *                                        used as SAI1 Block A clock.
S  */
S#define __HAL_RCC_SAI_BLOCKACLKSOURCE_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1ASRC, (__SOURCE__)))
S
S/** @brief  Macro to configure SAI1BlockB clock source selection.
S  * @note   The SAI peripheral is only available with STM32F427/437/429/439/469/479xx Devices.
S  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI Block B clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAIBCLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
S  *                                           as SAI1 Block B clock. 
S  *            @arg RCC_SAIBCLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
S  *                                           as SAI1 Block B clock. 
S  *            @arg RCC_SAIBCLKSOURCE_Ext: External clock mapped on the I2S_CKIN pin
S  *                                        used as SAI1 Block B clock.
S  */
S#define __HAL_RCC_SAI_BLOCKBCLKSOURCE_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1BSRC, (__SOURCE__)))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F446xx)
X#if 0L
S/** @brief  Macro to configure SAI1 clock source selection.
S  * @note   This configuration is only available with STM32F446xx Devices.
S  * @note   This function must be called before enabling PLL, PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAI1CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used as SAI1 clock. 
S  *            @arg RCC_SAI1CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used as SAI1 clock.
S  *            @arg RCC_SAI1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SAI1 clock.  
S  *            @arg RCC_SAI1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as SAI1 clock.
S  */
S#define __HAL_RCC_SAI1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get SAI1 clock source selection.
S  * @note   This configuration is only available with STM32F446xx Devices.      
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SAI1CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used as SAI1 clock. 
S  *            @arg RCC_SAI1CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used as SAI1 clock.
S  *            @arg RCC_SAI1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SAI1 clock.  
S  *            @arg RCC_SAI1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as SAI1 clock.
S  */
S#define __HAL_RCC_GET_SAI1_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SAI1SRC))
S
S/** @brief  Macro to configure SAI2 clock source selection.
S  * @note   This configuration is only available with STM32F446xx Devices.      
S  * @note   This function must be called before enabling PLL, PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI2 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAI2CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used as SAI2 clock. 
S  *            @arg RCC_SAI2CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used as SAI2 clock.
S  *            @arg RCC_SAI2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SAI2 clock.  
S  *            @arg RCC_SAI2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock used as SAI2 clock.
S  */
S#define __HAL_RCC_SAI2_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI2SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get SAI2 clock source selection.
S  * @note   This configuration is only available with STM32F446xx Devices.      
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SAI2CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used as SAI2 clock. 
S  *            @arg RCC_SAI2CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used as SAI2 clock.
S  *            @arg RCC_SAI2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SAI2 clock.  
S  *            @arg RCC_SAI2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock used as SAI2 clock.
S  */
S#define __HAL_RCC_GET_SAI2_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SAI2SRC))
S
S/** @brief  Macro to configure I2S APB1 clock source selection.
S  * @note   This function must be called before enabling PLL, PLLI2S and the I2S clock.
S  * @param  __SOURCE__ specifies the I2S APB1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
S  *            @arg RCC_I2SAPB1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S APB1 clock.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as I2S APB1 clock.  
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_I2S_APB1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2S1SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S APB1 clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
S  *            @arg RCC_I2SAPB1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S APB1 clock.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as I2S APB1 clock.  
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_I2S_APB1_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2S1SRC))
S
S/** @brief  Macro to configure I2S APB2 clock source selection.
S  * @note   This function must be called before enabling PLL, PLLI2S and the I2S clock.
S  * @param  __SOURCE__ specifies the SAI Block A clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
S  *            @arg RCC_I2SAPB2CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S APB2 clock.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as I2S APB2 clock.  
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_I2S_APB2_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2S2SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S APB2 clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock. 
S  *            @arg RCC_I2SAPB2CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S APB2 clock.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as I2S APB2 clock.  
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_I2S_APB2_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2S2SRC))
S
S/** @brief  Macro to configure the CEC clock.
S  * @param  __SOURCE__ specifies the CEC clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_CECCLKSOURCE_HSI: HSI selected as CEC clock
S  *            @arg RCC_CECCLKSOURCE_LSE: LSE selected as CEC clock
S  */
S#define __HAL_RCC_CEC_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the CEC clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_CECCLKSOURCE_HSI488: HSI selected as CEC clock
S  *            @arg RCC_CECCLKSOURCE_LSE: LSE selected as CEC clock
S  */
S#define __HAL_RCC_GET_CEC_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL))
S
S/** @brief  Macro to configure the FMPI2C1 clock.
S  * @param  __SOURCE__ specifies the FMPI2C1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_FMPI2C1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the FMPI2C1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_GET_FMPI2C1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL))
S
S/** @brief  Macro to configure the CLK48 clock.
S  * @param  __SOURCE__ specifies the CLK48 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLSAIP: PLLSAI VCO Output divided by PLLSAIP used as CLK48 clock. 
S  */
S#define __HAL_RCC_CLK48_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the CLK48 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLSAIP: PLLSAI VCO Output divided by PLLSAIP used as CLK48 clock. 
S  */
S#define __HAL_RCC_GET_CLK48_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL))
S
S/** @brief  Macro to configure the SDIO clock.
S  * @param  __SOURCE__ specifies the SDIO clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_SDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the SDIO clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_GET_SDIO_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL))
S
S/** @brief  Macro to configure the SPDIFRX clock.
S  * @param  __SOURCE__ specifies the SPDIFRX clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SPDIFRXCLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SPDIFRX clock.  
S  *            @arg RCC_SPDIFRXCLKSOURCE_PLLI2SP: PLLI2S VCO Output divided by PLLI2SP used as SPDIFRX clock. 
S  */
S#define __HAL_RCC_SPDIFRX_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SPDIFRXSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the SPDIFRX clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SPDIFRXCLKSOURCE_PLLR: PLL VCO Output divided by PLLR used as SPDIFRX clock.  
S  *            @arg RCC_SPDIFRXCLKSOURCE_PLLI2SP: PLLI2S VCO Output divided by PLLI2SP used as SPDIFRX clock. 
S  */
S#define __HAL_RCC_GET_SPDIFRX_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SPDIFRXSEL))
N#endif /* STM32F446xx */
N      
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S      
S/** @brief  Macro to configure the CLK48 clock.
S  * @param  __SOURCE__ specifies the CLK48 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLSAIP: PLLSAI VCO Output divided by PLLSAIP used as CLK48 clock. 
S  */
S#define __HAL_RCC_CLK48_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CK48MSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the CLK48 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLSAIP: PLLSAI VCO Output divided by PLLSAIP used as CLK48 clock. 
S  */
S#define __HAL_RCC_GET_CLK48_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CK48MSEL))
S
S/** @brief  Macro to configure the SDIO clock.
S  * @param  __SOURCE__ specifies the SDIO clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_SDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SDIOSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the SDIO clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_GET_SDIO_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SDIOSEL))  
S      
S/** @brief  Macro to configure the DSI clock.
S  * @param  __SOURCE__ specifies the DSI clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DSICLKSOURCE_PLLR: PLLR output used as DSI clock. 
S  *            @arg RCC_DSICLKSOURCE_DSIPHY: DSI-PHY output used as DSI clock. 
S  */
S#define __HAL_RCC_DSI_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_DSISEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the DSI clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DSICLKSOURCE_PLLR: PLLR output used as DSI clock. 
S  *            @arg RCC_DSICLKSOURCE_DSIPHY: DSI-PHY output used as DSI clock. 
S  */
S#define __HAL_RCC_GET_DSI_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_DSISEL))       
S      
N#endif /* STM32F469xx || STM32F479xx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S /** @brief  Macro to configure the DFSDM1 clock.
S  * @param  __DFSDM1_CLKSOURCE__ specifies the DFSDM1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DFSDM1CLKSOURCE_PCLK2: PCLK2 clock used as kernel clock. 
S  *            @arg RCC_DFSDM1CLKSOURCE_SYSCLK: System clock used as kernal clock.
S  * @retval None
S  */
S#define __HAL_RCC_DFSDM1_CONFIG(__DFSDM1_CLKSOURCE__)  MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1SEL, (__DFSDM1_CLKSOURCE__))
S
S/** @brief  Macro to get the DFSDM1 clock source.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DFSDM1CLKSOURCE_PCLK2: PCLK2 clock used as kernel clock. 
S  *            @arg RCC_DFSDM1CLKSOURCE_SYSCLK: System clock used as kernal clock.
S  */
S#define __HAL_RCC_GET_DFSDM1_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1SEL)))
S
S/** @brief  Macro to configure DFSDM1 Audio clock source selection.
S  * @note   This configuration is only available with STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/
S            STM32F413xx/STM32F423xx Devices.
S  * @param  __SOURCE__ specifies the DFSDM1 Audio clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_I2S1: CK_I2S_PCLK1 selected as audio clock
S  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_I2S2: CK_I2S_PCLK2 selected as audio clock
S  */
S#define __HAL_RCC_DFSDM1AUDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1ASEL, (__SOURCE__)))
S
S/** @brief  Macro to Get DFSDM1 Audio clock source selection.
S  * @note   This configuration is only available with STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/
S            STM32F413xx/STM32F423xx Devices.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_I2S1: CK_I2S_PCLK1 selected as audio clock
S  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_I2S2: CK_I2S_PCLK2 selected as audio clock
S  */
S#define __HAL_RCC_GET_DFSDM1AUDIO_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1ASEL))
S
S#if defined(STM32F413xx) || defined(STM32F423xx)
S /** @brief  Macro to configure the DFSDM2 clock.
S  * @param  __DFSDM2_CLKSOURCE__ specifies the DFSDM1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DFSDM2CLKSOURCE_PCLK2: PCLK2 clock used as kernel clock. 
S  *            @arg RCC_DFSDM2CLKSOURCE_SYSCLK: System clock used as kernal clock.
S  * @retval None
S  */
S#define __HAL_RCC_DFSDM2_CONFIG(__DFSDM2_CLKSOURCE__)  MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1SEL, (__DFSDM2_CLKSOURCE__))
S
S/** @brief  Macro to get the DFSDM2 clock source.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DFSDM2CLKSOURCE_PCLK2: PCLK2 clock used as kernel clock. 
S  *            @arg RCC_DFSDM2CLKSOURCE_SYSCLK: System clock used as kernal clock.
S  */
S#define __HAL_RCC_GET_DFSDM2_SOURCE() ((uint32_t)(READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM1SEL)))
S
S/** @brief  Macro to configure DFSDM1 Audio clock source selection.
S  * @note   This configuration is only available with STM32F413xx/STM32F423xx Devices.
S  * @param  __SOURCE__ specifies the DFSDM2 Audio clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_DFSDM2AUDIOCLKSOURCE_I2S1: CK_I2S_PCLK1 selected as audio clock
S  *            @arg RCC_DFSDM2AUDIOCLKSOURCE_I2S2: CK_I2S_PCLK2 selected as audio clock
S  */
S#define __HAL_RCC_DFSDM2AUDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM2ASEL, (__SOURCE__)))
S
S/** @brief  Macro to Get DFSDM2 Audio clock source selection.
S  * @note   This configuration is only available with STM32F413xx/STM32F423xx Devices.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_DFSDM2AUDIOCLKSOURCE_I2S1: CK_I2S_PCLK1 selected as audio clock
S  *            @arg RCC_DFSDM2AUDIOCLKSOURCE_I2S2: CK_I2S_PCLK2 selected as audio clock
S  */
S#define __HAL_RCC_GET_DFSDM2AUDIO_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_CKDFSDM2ASEL))
S      
S/** @brief  Macro to configure SAI1BlockA clock source selection.
S  * @note   The SAI peripheral is only available with STM32F413xx/STM32F423xx Devices.      
S  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI Block A clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAIACLKSOURCE_PLLI2SR: PLLI2S_R clock divided (R2) used as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_EXT: External clock mapped on the I2S_CKIN pinused as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_PLLR: PLL_R clock divided (R1) used as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_SAI_BLOCKACLKSOURCE_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1ASRC, (__SOURCE__)))
S      
S/** @brief  Macro to Get SAI1 BlockA clock source selection.
S  * @note   This configuration is only available with STM32F413xx/STM32F423xx Devices.      
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SAIACLKSOURCE_PLLI2SR: PLLI2S_R clock divided (R2) used as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_EXT: External clock mapped on the I2S_CKIN pinused as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_PLLR: PLL_R clock divided (R1) used as SAI1 Block A clock.
S  *            @arg RCC_SAIACLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_SAI_BLOCKA_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SAI1ASRC))
S
S/** @brief  Macro to configure SAI1 BlockB clock source selection.
S  * @note   The SAI peripheral is only available with STM32F413xx/STM32F423xx Devices.
S  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
S  *         the SAI clock.
S  * @param  __SOURCE__ specifies the SAI Block B clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SAIBCLKSOURCE_PLLI2SR: PLLI2S_R clock divided (R2) used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_PLLR: PLL_R clock divided (R1) used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_SAI_BLOCKBCLKSOURCE_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_SAI1BSRC, (__SOURCE__)))
S      
S/** @brief  Macro to Get SAI1 BlockB clock source selection.
S  * @note   This configuration is only available with STM32F413xx/STM32F423xx Devices.      
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SAIBCLKSOURCE_PLLI2SR: PLLI2S_R clock divided (R2) used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_PLLR: PLL_R clock divided (R1) used as SAI1 Block A clock.
S  *            @arg RCC_SAIBCLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_SAI_BLOCKB_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_SAI1BSRC))
S
S/** @brief  Macro to configure the LPTIM1 clock.
S  * @param  __SOURCE__ specifies the LPTIM1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI clock selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
S  */
S#define __HAL_RCC_LPTIM1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the LPTIM1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI clock selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
S  */
S#define __HAL_RCC_GET_LPTIM1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL))      
S#endif /* STM32F413xx || STM32F423xx */
S      
S/** @brief  Macro to configure I2S APB1 clock source selection.
S  * @param  __SOURCE__ specifies the I2S APB1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR.
S  *            @arg RCC_I2SAPB1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_I2S_APB1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2S1SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S APB1 clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR.
S  *            @arg RCC_I2SAPB1CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLR: PLL VCO Output divided by PLLR.
S  *            @arg RCC_I2SAPB1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_I2S_APB1_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2S1SRC))
S
S/** @brief  Macro to configure I2S APB2 clock source selection.
S  * @param  __SOURCE__ specifies the I2S APB2 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR.
S  *            @arg RCC_I2SAPB2CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_I2S_APB2_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2S2SRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S APB2 clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR.
S  *            @arg RCC_I2SAPB2CLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLR: PLL VCO Output divided by PLLR.
S  *            @arg RCC_I2SAPB2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  */
S#define __HAL_RCC_GET_I2S_APB2_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2S2SRC))
S
S/** @brief  Macro to configure the PLL I2S clock source (PLLI2SCLK).
S  * @note   This macro must be called before enabling the I2S APB clock.
S  * @param  __SOURCE__ specifies the I2S clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_PLLI2SCLKSOURCE_PLLSRC: HSI or HSE depending from PLL source Clock.
S  *            @arg RCC_PLLI2SCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin
S  *                                       used as I2S clock source.
S  */
S#define __HAL_RCC_PLL_I2S_CONFIG(__SOURCE__) (*(__IO uint32_t *) RCC_PLLI2SCFGR_PLLI2SSRC_BB = (__SOURCE__))
S      
S/** @brief  Macro to configure the FMPI2C1 clock.
S  * @param  __SOURCE__ specifies the FMPI2C1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_FMPI2C1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the FMPI2C1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_GET_FMPI2C1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL))
S
S/** @brief  Macro to configure the CLK48 clock.
S  * @param  __SOURCE__ specifies the CLK48 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLI2SQ: PLLI2S VCO Output divided by PLLI2SQ used as CLK48 clock.
S  */
S#define __HAL_RCC_CLK48_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the CLK48 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_CLK48CLKSOURCE_PLLQ: PLL VCO Output divided by PLLQ used as CLK48 clock. 
S  *            @arg RCC_CLK48CLKSOURCE_PLLI2SQ: PLLI2S VCO Output divided by PLLI2SQ used as CLK48 clock
S  */
S#define __HAL_RCC_GET_CLK48_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL))
S
S/** @brief  Macro to configure the SDIO clock.
S  * @param  __SOURCE__ specifies the SDIO clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_SDIO_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the SDIO clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_SDIOCLKSOURCE_CLK48: CLK48 output used as SDIO clock. 
S  *            @arg RCC_SDIOCLKSOURCE_SYSCLK: System clock output used as SDIO clock. 
S  */
S#define __HAL_RCC_GET_SDIO_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDIOSEL))
S
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** @brief  Macro to configure I2S clock source selection.
S  * @param  __SOURCE__ specifies the I2S clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_I2SAPBCLKSOURCE_PLLR: PLL VCO output clock divided by PLLR.
S  *            @arg RCC_I2SAPBCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPBCLKSOURCE_PLLSRC: HSI/HSE depends on PLLSRC.
S  */
S#define __HAL_RCC_I2S_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR, RCC_DCKCFGR_I2SSRC, (__SOURCE__)))
S
S/** @brief  Macro to Get I2S clock source selection.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_I2SAPBCLKSOURCE_PLLR: PLL VCO output clock divided by PLLR.
S  *            @arg RCC_I2SAPBCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin.
S  *            @arg RCC_I2SAPBCLKSOURCE_PLLSRC: HSI/HSE depends on PLLSRC.
S  */
S#define __HAL_RCC_GET_I2S_SOURCE() (READ_BIT(RCC->DCKCFGR, RCC_DCKCFGR_I2SSRC))
S
S/** @brief  Macro to configure the FMPI2C1 clock.
S  * @param  __SOURCE__ specifies the FMPI2C1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_FMPI2C1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the FMPI2C1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_FMPI2C1CLKSOURCE_PCLK1: PCLK1 selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_SYSCLK: SYS clock selected as FMPI2C1 clock
S  *            @arg RCC_FMPI2C1CLKSOURCE_HSI: HSI selected as FMPI2C1 clock
S  */
S#define __HAL_RCC_GET_FMPI2C1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_FMPI2C1SEL))
S
S/** @brief  Macro to configure the LPTIM1 clock.
S  * @param  __SOURCE__ specifies the LPTIM1 clock source.
S  *         This parameter can be one of the following values:
S  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK1 selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI clock selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
S  */
S#define __HAL_RCC_LPTIM1_CONFIG(__SOURCE__) (MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL, (uint32_t)(__SOURCE__)))
S
S/** @brief  Macro to Get the LPTIM1 clock.
S  * @retval The clock source can be one of the following values:
S  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK1 selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI clock selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
S  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
S  */
S#define __HAL_RCC_GET_LPTIM1_SOURCE() (READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N      
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
N/** @brief  Macro to configure the Timers clocks prescalers 
N  * @note   This feature is only available with STM32F429x/439x Devices.  
N  * @param  __PRESC__  specifies the Timers clocks prescalers selection
N  *         This parameter can be one of the following values:
N  *            @arg RCC_TIMPRES_DESACTIVATED: The Timers kernels clocks prescaler is 
N  *                 equal to HPRE if PPREx is corresponding to division by 1 or 2, 
N  *                 else it is equal to [(HPRE * PPREx) / 2] if PPREx is corresponding to 
N  *                 division by 4 or more.       
N  *            @arg RCC_TIMPRES_ACTIVATED: The Timers kernels clocks prescaler is 
N  *                 equal to HPRE if PPREx is corresponding to division by 1, 2 or 4, 
N  *                 else it is equal to [(HPRE * PPREx) / 4] if PPREx is corresponding 
N  *                 to division by 8 or more.
N  */     
N#define __HAL_RCC_TIMCLKPRESCALER(__PRESC__) (*(__IO uint32_t *) RCC_DCKCFGR_TIMPRE_BB = (__PRESC__))
N
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx) || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE ||\
N          STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx  || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx ||\
N          STM32F423xx */
X#endif  
N
N/*----------------------------------------------------------------------------*/
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L
S/** @brief Enable PLLSAI_RDY interrupt.
S  */
S#define __HAL_RCC_PLLSAI_ENABLE_IT() (RCC->CIR |= (RCC_CIR_PLLSAIRDYIE))
S
S/** @brief Disable PLLSAI_RDY interrupt.
S  */
S#define __HAL_RCC_PLLSAI_DISABLE_IT() (RCC->CIR &= ~(RCC_CIR_PLLSAIRDYIE))
S
S/** @brief Clear the PLLSAI RDY interrupt pending bits.
S  */
S#define __HAL_RCC_PLLSAI_CLEAR_IT() (RCC->CIR |= (RCC_CIR_PLLSAIRDYF))
S
S/** @brief Check the PLLSAI RDY interrupt has occurred or not.
S  * @retval The new state (TRUE or FALSE).
S  */
S#define __HAL_RCC_PLLSAI_GET_IT() ((RCC->CIR & (RCC_CIR_PLLSAIRDYIE)) == (RCC_CIR_PLLSAIRDYIE))
S
S/** @brief  Check PLLSAI RDY flag is set or not.
S  * @retval The new state (TRUE or FALSE).
S  */
S#define __HAL_RCC_PLLSAI_GET_FLAG() ((RCC->CR & (RCC_CR_PLLSAIRDY)) == (RCC_CR_PLLSAIRDY))
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** @brief  Macros to enable or disable the RCC MCO1 feature.
S  */
S#define __HAL_RCC_MCO1_ENABLE() (*(__IO uint32_t *) RCC_CFGR_MCO1EN_BB = ENABLE)
S#define __HAL_RCC_MCO1_DISABLE() (*(__IO uint32_t *) RCC_CFGR_MCO1EN_BB = DISABLE)
S
S/** @brief  Macros to enable or disable the RCC MCO2 feature.
S  */
S#define __HAL_RCC_MCO2_ENABLE() (*(__IO uint32_t *) RCC_CFGR_MCO2EN_BB = ENABLE)
S#define __HAL_RCC_MCO2_DISABLE() (*(__IO uint32_t *) RCC_CFGR_MCO2EN_BB = DISABLE)
S
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup RCCEx_Exported_Functions
N  *  @{
N  */
N
N/** @addtogroup RCCEx_Exported_Functions_Group1
N  *  @{
N  */
NHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
Nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
N
Nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk);
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
Svoid HAL_RCCEx_SelectLSEMode(uint8_t Mode);
N#endif /* STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N#if defined(RCC_PLLI2S_SUPPORT)
X#if 1L
NHAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit);
NHAL_StatusTypeDef HAL_RCCEx_DisablePLLI2S(void);
N#endif /* RCC_PLLI2S_SUPPORT */
N#if defined(RCC_PLLSAI_SUPPORT)
X#if 0L
SHAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI(RCC_PLLSAIInitTypeDef  *PLLSAIInit);
SHAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI(void);
N#endif /* RCC_PLLSAI_SUPPORT */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RCCEx_Private_Constants RCCEx Private Constants
N  * @{
N  */
N
N/** @defgroup RCCEx_BitAddress_AliasRegion RCC BitAddress AliasRegion
N  * @brief RCC registers bit address in the alias region
N  * @{
N  */
N/* --- CR Register ---*/  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L
S/* Alias word address of PLLSAION bit */
S#define RCC_PLLSAION_BIT_NUMBER       0x1CU
S#define RCC_CR_PLLSAION_BB            (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_PLLSAION_BIT_NUMBER * 4U))
S
S#define PLLSAI_TIMEOUT_VALUE          2U  /* Timeout value fixed to 2 ms  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 1L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
N/* Alias word address of PLLI2SON bit */
N#define RCC_PLLI2SON_BIT_NUMBER    0x1AU
N#define RCC_CR_PLLI2SON_BB         (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_PLLI2SON_BIT_NUMBER * 4U))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx ||
N          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N/* --- DCKCFGR Register ---*/
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F401xC) ||\
N    defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    1L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
N/* Alias word address of TIMPRE bit */
N#define RCC_DCKCFGR_OFFSET            (RCC_OFFSET + 0x8CU)
N#define RCC_TIMPRE_BIT_NUMBER          0x18U
N#define RCC_DCKCFGR_TIMPRE_BB         (PERIPH_BB_BASE + (RCC_DCKCFGR_OFFSET * 32U) + (RCC_TIMPRE_BIT_NUMBER * 4U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F410xx || STM32F401xC ||\
N          STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N/* --- CFGR Register ---*/
N#define RCC_CFGR_OFFSET            (RCC_OFFSET + 0x08U)
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 1L || 0L || 0L ||     0L || 0L
N/* Alias word address of I2SSRC bit */
N#define RCC_I2SSRC_BIT_NUMBER      0x17U
N#define RCC_CFGR_I2SSRC_BB         (PERIPH_BB_BASE + (RCC_CFGR_OFFSET * 32U) + (RCC_I2SSRC_BIT_NUMBER * 4U))
N      
N#define PLLI2S_TIMEOUT_VALUE       2U  /* Timeout value fixed to 2 ms  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx */
N      
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S/* --- PLLI2SCFGR Register ---*/
S#define RCC_PLLI2SCFGR_OFFSET         (RCC_OFFSET + 0x84U)
S/* Alias word address of PLLI2SSRC bit */
S#define RCC_PLLI2SSRC_BIT_NUMBER      0x16U
S#define RCC_PLLI2SCFGR_PLLI2SSRC_BB         (PERIPH_BB_BASE + (RCC_PLLI2SCFGR_OFFSET * 32U) + (RCC_PLLI2SSRC_BIT_NUMBER * 4U))
S      
S#define PLLI2S_TIMEOUT_VALUE          2U  /* Timeout value fixed to 2 ms */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx | STM32F423xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/* Alias word address of MCO1EN bit */
S#define RCC_MCO1EN_BIT_NUMBER      0x8U
S#define RCC_CFGR_MCO1EN_BB         (PERIPH_BB_BASE + (RCC_CFGR_OFFSET * 32U) + (RCC_MCO1EN_BIT_NUMBER * 4U))
S
S/* Alias word address of MCO2EN bit */
S#define RCC_MCO2EN_BIT_NUMBER      0x9U
S#define RCC_CFGR_MCO2EN_BB         (PERIPH_BB_BASE + (RCC_CFGR_OFFSET * 32U) + (RCC_MCO2EN_BIT_NUMBER * 4U))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#define PLL_TIMEOUT_VALUE          2U  /* 2 ms */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RCCEx_Private_Macros RCCEx Private Macros
N  * @{
N  */
N/** @defgroup RCCEx_IS_RCC_Definitions RCC Private macros to check input parameters
N  * @{
N  */
N#if defined(STM32F411xE)
X#if 0L
S#define IS_RCC_PLLN_VALUE(VALUE) ((192U <= (VALUE)) && ((VALUE) <= 432U))
S#define IS_RCC_PLLI2SN_VALUE(VALUE) ((192U <= (VALUE)) && ((VALUE) <= 432U))      
S#else /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx ||
S         STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE || STM32F410Tx || STM32F410Cx || 
S         STM32F410Rx || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Cx || STM32F412Rx || 
N         STM32F412Vx || STM32F412Zx || STM32F413xx || STM32F423xx */
N#define IS_RCC_PLLN_VALUE(VALUE) ((50U <= (VALUE)) && ((VALUE) <= 432U))
N#define IS_RCC_PLLI2SN_VALUE(VALUE) ((50U <= (VALUE)) && ((VALUE) <= 432U))
N#endif  /* STM32F411xE */    
N      
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx)
X#if 0L || 0L || 0L|| 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x0000007FU))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx) 
X#if 0L || 0L || 0L|| 0L 
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x00000007U))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) 
X#if 0L || 1L || 0L 
N#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x0000000FU))
N#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x0000001FU))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F446xx)
X#if 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x00000FFFU))
N#endif /* STM32F446xx */
N
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x000001FFU))
N#endif /* STM32F469xx || STM32F479xx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)
X#if 0L || 0L || 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x000003FFU))
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N      
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((1U <= (SELECTION)) && ((SELECTION) <= 0x00007FFFU))
N#endif /* STM32F413xx || STM32F423xx */
N      
N#define IS_RCC_PLLI2SR_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 7U))
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L || 0L
S#define IS_RCC_PLLI2SQ_VALUE(VALUE)     ((2U <= (VALUE)) && ((VALUE) <= 15U))
S
S#define IS_RCC_PLLSAIN_VALUE(VALUE)     ((50U <= (VALUE)) && ((VALUE) <= 432U))
S
S#define IS_RCC_PLLSAIQ_VALUE(VALUE)     ((2U <= (VALUE)) && ((VALUE) <= 15U))
S
S#define IS_RCC_PLLSAIR_VALUE(VALUE)     ((2U <= (VALUE)) && ((VALUE) <= 7U))
S
S#define IS_RCC_PLLSAI_DIVQ_VALUE(VALUE) ((1U <= (VALUE)) && ((VALUE) <= 32U))
S
S#define IS_RCC_PLLI2S_DIVQ_VALUE(VALUE) ((1U <= (VALUE)) && ((VALUE) <= 32U))
S
S#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDIVR_2)  ||\
S                                         ((VALUE) == RCC_PLLSAIDIVR_4)  ||\
S                                         ((VALUE) == RCC_PLLSAIDIVR_8)  ||\
S                                         ((VALUE) == RCC_PLLSAIDIVR_16))
X#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDIVR_2)  ||                                         ((VALUE) == RCC_PLLSAIDIVR_4)  ||                                         ((VALUE) == RCC_PLLSAIDIVR_8)  ||                                         ((VALUE) == RCC_PLLSAIDIVR_16))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
S#define IS_RCC_PLLI2SM_VALUE(VALUE)   ((2U <= (VALUE)) && ((VALUE) <= 63U))
S 
S#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||\
S                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
X#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
N#endif /* STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx  */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_RCC_PLLR_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 7U))
S
S#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||\
S                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
X#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
S
S#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
X#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
S
S#define IS_RCC_LPTIM1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI) ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI) ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
X#define IS_RCC_LPTIM1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI) ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI) ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
S
S#define IS_RCC_I2SAPBCLKSOURCE(SOURCE)      (((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLR)    ||\
S                                             ((SOURCE) == RCC_I2SAPBCLKSOURCE_EXT)    ||\
S                                             ((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLSRC))
X#define IS_RCC_I2SAPBCLKSOURCE(SOURCE)      (((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLR)    ||                                             ((SOURCE) == RCC_I2SAPBCLKSOURCE_EXT)    ||                                             ((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLSRC))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F446xx)
X#if 0L
S#define IS_RCC_PLLR_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 7U))
S  
S#define IS_RCC_PLLI2SP_VALUE(VALUE)       (((VALUE) == RCC_PLLI2SP_DIV2) ||\
S                                           ((VALUE) == RCC_PLLI2SP_DIV4) ||\
S                                           ((VALUE) == RCC_PLLI2SP_DIV6) ||\
S                                           ((VALUE) == RCC_PLLI2SP_DIV8))
X#define IS_RCC_PLLI2SP_VALUE(VALUE)       (((VALUE) == RCC_PLLI2SP_DIV2) ||                                           ((VALUE) == RCC_PLLI2SP_DIV4) ||                                           ((VALUE) == RCC_PLLI2SP_DIV6) ||                                           ((VALUE) == RCC_PLLI2SP_DIV8))
S
S#define IS_RCC_PLLSAIM_VALUE(VALUE)       ((VALUE) <= 63U)
S  
S#define IS_RCC_PLLSAIP_VALUE(VALUE)       (((VALUE) == RCC_PLLSAIP_DIV2) ||\
S                                           ((VALUE) == RCC_PLLSAIP_DIV4) ||\
S                                           ((VALUE) == RCC_PLLSAIP_DIV6) ||\
S                                           ((VALUE) == RCC_PLLSAIP_DIV8))
X#define IS_RCC_PLLSAIP_VALUE(VALUE)       (((VALUE) == RCC_PLLSAIP_DIV2) ||                                           ((VALUE) == RCC_PLLSAIP_DIV4) ||                                           ((VALUE) == RCC_PLLSAIP_DIV6) ||                                           ((VALUE) == RCC_PLLSAIP_DIV8))
S
S#define IS_RCC_SAI1CLKSOURCE(SOURCE)      (((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) ||\
S                                           ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_SAI1CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_SAI1CLKSOURCE_EXT))
X#define IS_RCC_SAI1CLKSOURCE(SOURCE)      (((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) ||                                           ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_SAI1CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_SAI1CLKSOURCE_EXT))
S
S#define IS_RCC_SAI2CLKSOURCE(SOURCE)      (((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) ||\
S                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLSRC))
X#define IS_RCC_SAI2CLKSOURCE(SOURCE)      (((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) ||                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_SAI2CLKSOURCE_PLLSRC))
S 
S#define IS_RCC_I2SAPB1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_EXT)    ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLSRC))
X#define IS_RCC_I2SAPB1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_EXT)    ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLSRC))
S                                              
S #define IS_RCC_I2SAPB2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_EXT)    ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLSRC))
X #define IS_RCC_I2SAPB2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_EXT)    ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLSRC))
S
S#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
X#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
S
S#define IS_RCC_CECCLKSOURCE(SOURCE)       (((SOURCE) == RCC_CECCLKSOURCE_HSI)   ||\
S                                           ((SOURCE) == RCC_CECCLKSOURCE_LSE))
X#define IS_RCC_CECCLKSOURCE(SOURCE)       (((SOURCE) == RCC_CECCLKSOURCE_HSI)   ||                                           ((SOURCE) == RCC_CECCLKSOURCE_LSE))
S
S#define IS_RCC_CLK48CLKSOURCE(SOURCE)      (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||\
S                                            ((SOURCE) == RCC_CLK48CLKSOURCE_PLLSAIP))
X#define IS_RCC_CLK48CLKSOURCE(SOURCE)      (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||                                            ((SOURCE) == RCC_CLK48CLKSOURCE_PLLSAIP))
S
S#define IS_RCC_SDIOCLKSOURCE(SOURCE)      (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||\
S                                           ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
X#define IS_RCC_SDIOCLKSOURCE(SOURCE)      (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||                                           ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
S
S#define IS_RCC_SPDIFRXCLKSOURCE(SOURCE)   (((SOURCE) == RCC_SPDIFRXCLKSOURCE_PLLR) ||\
S                                           ((SOURCE) == RCC_SPDIFRXCLKSOURCE_PLLI2SP))  
X#define IS_RCC_SPDIFRXCLKSOURCE(SOURCE)   (((SOURCE) == RCC_SPDIFRXCLKSOURCE_PLLR) ||                                           ((SOURCE) == RCC_SPDIFRXCLKSOURCE_PLLI2SP))  
N#endif /* STM32F446xx */
N
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S#define IS_RCC_PLLR_VALUE(VALUE)            ((2U <= (VALUE)) && ((VALUE) <= 7U))
S
S#define IS_RCC_PLLSAIP_VALUE(VALUE)         (((VALUE) == RCC_PLLSAIP_DIV2) ||\
S                                             ((VALUE) == RCC_PLLSAIP_DIV4) ||\
S                                             ((VALUE) == RCC_PLLSAIP_DIV6) ||\
S                                             ((VALUE) == RCC_PLLSAIP_DIV8))
X#define IS_RCC_PLLSAIP_VALUE(VALUE)         (((VALUE) == RCC_PLLSAIP_DIV2) ||                                             ((VALUE) == RCC_PLLSAIP_DIV4) ||                                             ((VALUE) == RCC_PLLSAIP_DIV6) ||                                             ((VALUE) == RCC_PLLSAIP_DIV8))
S 
S#define IS_RCC_CLK48CLKSOURCE(SOURCE)        (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||\
S                                              ((SOURCE) == RCC_CLK48CLKSOURCE_PLLSAIP))
X#define IS_RCC_CLK48CLKSOURCE(SOURCE)        (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||                                              ((SOURCE) == RCC_CLK48CLKSOURCE_PLLSAIP))
S
S#define IS_RCC_SDIOCLKSOURCE(SOURCE)        (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||\
S                                             ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
X#define IS_RCC_SDIOCLKSOURCE(SOURCE)        (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||                                             ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
S
S#define IS_RCC_DSIBYTELANECLKSOURCE(SOURCE) (((SOURCE) == RCC_DSICLKSOURCE_PLLR)  ||\
S                                             ((SOURCE) == RCC_DSICLKSOURCE_DSIPHY))
X#define IS_RCC_DSIBYTELANECLKSOURCE(SOURCE) (((SOURCE) == RCC_DSICLKSOURCE_PLLR)  ||                                             ((SOURCE) == RCC_DSICLKSOURCE_DSIPHY))
S
S#define IS_RCC_LSE_MODE(MODE)               (((MODE) == RCC_LSE_LOWPOWER_MODE) ||\
S                                             ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
X#define IS_RCC_LSE_MODE(MODE)               (((MODE) == RCC_LSE_LOWPOWER_MODE) ||                                             ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
N#endif /* STM32F469xx || STM32F479xx */
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
N    defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define IS_RCC_PLLI2SQ_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 15U))
S    
S#define IS_RCC_PLLR_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 7U))
S
S#define IS_RCC_PLLI2SCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_PLLI2SCLKSOURCE_PLLSRC) || \
S                                            ((__SOURCE__) == RCC_PLLI2SCLKSOURCE_EXT))
X#define IS_RCC_PLLI2SCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_PLLI2SCLKSOURCE_PLLSRC) ||                                             ((__SOURCE__) == RCC_PLLI2SCLKSOURCE_EXT))
S 
S#define IS_RCC_I2SAPB1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_EXT)    ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLSRC))
X#define IS_RCC_I2SAPB1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_EXT)    ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_I2SAPB1CLKSOURCE_PLLSRC))
S                                              
S #define IS_RCC_I2SAPB2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLI2S) ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_EXT)    ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLR)   ||\
S                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLSRC))
X #define IS_RCC_I2SAPB2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLI2S) ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_EXT)    ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLR)   ||                                           ((SOURCE) == RCC_I2SAPB2CLKSOURCE_PLLSRC))
S
S#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||\
S                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
X#define IS_RCC_FMPI2C1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_FMPI2C1CLKSOURCE_PCLK1)    ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_SYSCLK) ||                                           ((SOURCE) == RCC_FMPI2C1CLKSOURCE_HSI))
S
S#define IS_RCC_CLK48CLKSOURCE(SOURCE)      (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||\
S                                            ((SOURCE) == RCC_CLK48CLKSOURCE_PLLI2SQ))
X#define IS_RCC_CLK48CLKSOURCE(SOURCE)      (((SOURCE) == RCC_CLK48CLKSOURCE_PLLQ) ||                                            ((SOURCE) == RCC_CLK48CLKSOURCE_PLLI2SQ))
S
S#define IS_RCC_SDIOCLKSOURCE(SOURCE)      (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||\
S                                           ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
X#define IS_RCC_SDIOCLKSOURCE(SOURCE)      (((SOURCE) == RCC_SDIOCLKSOURCE_CLK48) ||                                           ((SOURCE) == RCC_SDIOCLKSOURCE_SYSCLK))
S
S#define IS_RCC_DFSDM1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM1CLKSOURCE_PCLK2) || \
S                                            ((__SOURCE__) == RCC_DFSDM1CLKSOURCE_SYSCLK))
X#define IS_RCC_DFSDM1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM1CLKSOURCE_PCLK2) ||                                             ((__SOURCE__) == RCC_DFSDM1CLKSOURCE_SYSCLK))
S
S#define IS_RCC_DFSDM1AUDIOCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM1AUDIOCLKSOURCE_I2S1) || \
S                                                 ((__SOURCE__) == RCC_DFSDM1AUDIOCLKSOURCE_I2S2))
X#define IS_RCC_DFSDM1AUDIOCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM1AUDIOCLKSOURCE_I2S1) ||                                                  ((__SOURCE__) == RCC_DFSDM1AUDIOCLKSOURCE_I2S2))
S
S#if defined(STM32F413xx) || defined(STM32F423xx)
S#define IS_RCC_DFSDM2CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM2CLKSOURCE_PCLK2) || \
S                                            ((__SOURCE__) == RCC_DFSDM2CLKSOURCE_SYSCLK))
X#define IS_RCC_DFSDM2CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM2CLKSOURCE_PCLK2) ||                                             ((__SOURCE__) == RCC_DFSDM2CLKSOURCE_SYSCLK))
S
S#define IS_RCC_DFSDM2AUDIOCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM2AUDIOCLKSOURCE_I2S1) || \
S                                                 ((__SOURCE__) == RCC_DFSDM2AUDIOCLKSOURCE_I2S2))
X#define IS_RCC_DFSDM2AUDIOCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_DFSDM2AUDIOCLKSOURCE_I2S1) ||                                                  ((__SOURCE__) == RCC_DFSDM2AUDIOCLKSOURCE_I2S2))
S
S#define IS_RCC_LPTIM1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI)  ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI)  ||\
S                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
X#define IS_RCC_LPTIM1CLKSOURCE(SOURCE)   (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI)  ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI)  ||                                          ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
S
S#define IS_RCC_SAIACLKSOURCE(SOURCE)     (((SOURCE) == RCC_SAIACLKSOURCE_PLLI2SR) ||\
S                                          ((SOURCE) == RCC_SAIACLKSOURCE_EXT)     ||\
S                                          ((SOURCE) == RCC_SAIACLKSOURCE_PLLR)    ||\
S                                          ((SOURCE) == RCC_SAIACLKSOURCE_PLLSRC))
X#define IS_RCC_SAIACLKSOURCE(SOURCE)     (((SOURCE) == RCC_SAIACLKSOURCE_PLLI2SR) ||                                          ((SOURCE) == RCC_SAIACLKSOURCE_EXT)     ||                                          ((SOURCE) == RCC_SAIACLKSOURCE_PLLR)    ||                                          ((SOURCE) == RCC_SAIACLKSOURCE_PLLSRC))
S
S#define IS_RCC_SAIBCLKSOURCE(SOURCE)     (((SOURCE) == RCC_SAIBCLKSOURCE_PLLI2SR) ||\
S                                          ((SOURCE) == RCC_SAIBCLKSOURCE_EXT)     ||\
S                                          ((SOURCE) == RCC_SAIBCLKSOURCE_PLLR)    ||\
S                                          ((SOURCE) == RCC_SAIBCLKSOURCE_PLLSRC))
X#define IS_RCC_SAIBCLKSOURCE(SOURCE)     (((SOURCE) == RCC_SAIBCLKSOURCE_PLLI2SR) ||                                          ((SOURCE) == RCC_SAIBCLKSOURCE_EXT)     ||                                          ((SOURCE) == RCC_SAIBCLKSOURCE_PLLR)    ||                                          ((SOURCE) == RCC_SAIBCLKSOURCE_PLLSRC))
S
S#define IS_RCC_PLL_DIVR_VALUE(VALUE) ((1U <= (VALUE)) && ((VALUE) <= 32U))
S
S#define IS_RCC_PLLI2S_DIVR_VALUE(VALUE) ((1U <= (VALUE)) && ((VALUE) <= 32U))
S
S#endif /* STM32F413xx || STM32F423xx */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
N    defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 1L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L
N      
N#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_PLLI2SCLK)|| \
N                                   ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
X#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_PLLI2SCLK)||                                    ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
N
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
N          STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || \
N          STM32F412Rx */
X#endif  
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)      
X#if 0L || 0L || 0L      
S#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_I2SCLK)|| \
S                                   ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
X#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_I2SCLK)||                                    ((SOURCE) == RCC_MCO2SOURCE_HSE)    || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_RCC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 34 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rcc.h" 2
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RCC_Exported_Types RCC Exported Types
N  * @{
N  */
N
N/**
N  * @brief  RCC Internal/External Oscillator (HSE, HSI, LSE and LSI) configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t OscillatorType;       /*!< The oscillators to be configured.
N                                      This parameter can be a value of @ref RCC_Oscillator_Type                   */
N
N  uint32_t HSEState;             /*!< The new state of the HSE.
N                                      This parameter can be a value of @ref RCC_HSE_Config                        */
N
N  uint32_t LSEState;             /*!< The new state of the LSE.
N                                      This parameter can be a value of @ref RCC_LSE_Config                        */
N
N  uint32_t HSIState;             /*!< The new state of the HSI.
N                                      This parameter can be a value of @ref RCC_HSI_Config                        */
N
N  uint32_t HSICalibrationValue;  /*!< The HSI calibration trimming value (default is RCC_HSICALIBRATION_DEFAULT).
N                                       This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x1F */
N
N  uint32_t LSIState;             /*!< The new state of the LSI.
N                                      This parameter can be a value of @ref RCC_LSI_Config                        */
N
N  RCC_PLLInitTypeDef PLL;        /*!< PLL structure parameters                                                    */
N}RCC_OscInitTypeDef;
N
N/**
N  * @brief  RCC System, AHB and APB busses clock configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t ClockType;             /*!< The clock to be configured.
N                                       This parameter can be a value of @ref RCC_System_Clock_Type      */
N
N  uint32_t SYSCLKSource;          /*!< The clock source (SYSCLKS) used as system clock.
N                                       This parameter can be a value of @ref RCC_System_Clock_Source    */
N
N  uint32_t AHBCLKDivider;         /*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
N                                       This parameter can be a value of @ref RCC_AHB_Clock_Source       */
N
N  uint32_t APB1CLKDivider;        /*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source */
N
N  uint32_t APB2CLKDivider;        /*!< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source */
N
N}RCC_ClkInitTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCC_Exported_Constants RCC Exported Constants
N  * @{
N  */
N
N/** @defgroup RCC_Oscillator_Type Oscillator Type
N  * @{
N  */
N#define RCC_OSCILLATORTYPE_NONE            0x00000000U
N#define RCC_OSCILLATORTYPE_HSE             0x00000001U
N#define RCC_OSCILLATORTYPE_HSI             0x00000002U
N#define RCC_OSCILLATORTYPE_LSE             0x00000004U
N#define RCC_OSCILLATORTYPE_LSI             0x00000008U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSE_Config HSE Config
N  * @{
N  */
N#define RCC_HSE_OFF                      0x00000000U
N#define RCC_HSE_ON                       RCC_CR_HSEON
N#define RCC_HSE_BYPASS                   ((uint32_t)(RCC_CR_HSEBYP | RCC_CR_HSEON))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Config LSE Config
N  * @{
N  */
N#define RCC_LSE_OFF                    0x00000000U
N#define RCC_LSE_ON                     RCC_BDCR_LSEON
N#define RCC_LSE_BYPASS                 ((uint32_t)(RCC_BDCR_LSEBYP | RCC_BDCR_LSEON))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSI_Config HSI Config
N  * @{
N  */
N#define RCC_HSI_OFF                      ((uint8_t)0x00)
N#define RCC_HSI_ON                       ((uint8_t)0x01)
N
N#define RCC_HSICALIBRATION_DEFAULT       0x10U         /* Default HSI calibration trimming value */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSI_Config LSI Config
N  * @{
N  */
N#define RCC_LSI_OFF                      ((uint8_t)0x00)
N#define RCC_LSI_ON                       ((uint8_t)0x01)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Config PLL Config
N  * @{
N  */
N#define RCC_PLL_NONE                      ((uint8_t)0x00)
N#define RCC_PLL_OFF                       ((uint8_t)0x01)
N#define RCC_PLL_ON                        ((uint8_t)0x02)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLLP_Clock_Divider PLLP Clock Divider
N  * @{
N  */
N#define RCC_PLLP_DIV2                  0x00000002U
N#define RCC_PLLP_DIV4                  0x00000004U
N#define RCC_PLLP_DIV6                  0x00000006U
N#define RCC_PLLP_DIV8                  0x00000008U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Clock_Source PLL Clock Source
N  * @{
N  */
N#define RCC_PLLSOURCE_HSI                RCC_PLLCFGR_PLLSRC_HSI
N#define RCC_PLLSOURCE_HSE                RCC_PLLCFGR_PLLSRC_HSE
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Type System Clock Type
N  * @{
N  */
N#define RCC_CLOCKTYPE_SYSCLK             0x00000001U
N#define RCC_CLOCKTYPE_HCLK               0x00000002U
N#define RCC_CLOCKTYPE_PCLK1              0x00000004U
N#define RCC_CLOCKTYPE_PCLK2              0x00000008U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Source System Clock Source
N  * @note     The RCC_SYSCLKSOURCE_PLLRCLK parameter is available only for
N  *           STM32F446xx devices.
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_HSI             RCC_CFGR_SW_HSI
N#define RCC_SYSCLKSOURCE_HSE             RCC_CFGR_SW_HSE
N#define RCC_SYSCLKSOURCE_PLLCLK          RCC_CFGR_SW_PLL
N#define RCC_SYSCLKSOURCE_PLLRCLK         ((uint32_t)(RCC_CFGR_SW_0 | RCC_CFGR_SW_1))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Source_Status System Clock Source Status
N  * @note     The RCC_SYSCLKSOURCE_STATUS_PLLRCLK parameter is available only for
N  *           STM32F446xx devices.
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_STATUS_HSI     RCC_CFGR_SWS_HSI   /*!< HSI used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_HSE     RCC_CFGR_SWS_HSE   /*!< HSE used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_PLLCLK  RCC_CFGR_SWS_PLL   /*!< PLL used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_PLLRCLK ((uint32_t)(RCC_CFGR_SWS_0 | RCC_CFGR_SWS_1))   /*!< PLLR used as system clock */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Clock_Source AHB Clock Source
N  * @{
N  */
N#define RCC_SYSCLK_DIV1                  RCC_CFGR_HPRE_DIV1
N#define RCC_SYSCLK_DIV2                  RCC_CFGR_HPRE_DIV2
N#define RCC_SYSCLK_DIV4                  RCC_CFGR_HPRE_DIV4
N#define RCC_SYSCLK_DIV8                  RCC_CFGR_HPRE_DIV8
N#define RCC_SYSCLK_DIV16                 RCC_CFGR_HPRE_DIV16
N#define RCC_SYSCLK_DIV64                 RCC_CFGR_HPRE_DIV64
N#define RCC_SYSCLK_DIV128                RCC_CFGR_HPRE_DIV128
N#define RCC_SYSCLK_DIV256                RCC_CFGR_HPRE_DIV256
N#define RCC_SYSCLK_DIV512                RCC_CFGR_HPRE_DIV512
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_APB2_Clock_Source APB1/APB2 Clock Source
N  * @{
N  */
N#define RCC_HCLK_DIV1                    RCC_CFGR_PPRE1_DIV1
N#define RCC_HCLK_DIV2                    RCC_CFGR_PPRE1_DIV2
N#define RCC_HCLK_DIV4                    RCC_CFGR_PPRE1_DIV4
N#define RCC_HCLK_DIV8                    RCC_CFGR_PPRE1_DIV8
N#define RCC_HCLK_DIV16                   RCC_CFGR_PPRE1_DIV16
N/**
N  * @}
N  */
N
N/** @defgroup RCC_RTC_Clock_Source RTC Clock Source
N  * @{
N  */
N#define RCC_RTCCLKSOURCE_NO_CLK          0x00000000U
N#define RCC_RTCCLKSOURCE_LSE             0x00000100U
N#define RCC_RTCCLKSOURCE_LSI             0x00000200U
N#define RCC_RTCCLKSOURCE_HSE_DIVX        0x00000300U
N#define RCC_RTCCLKSOURCE_HSE_DIV2        0x00020300U
N#define RCC_RTCCLKSOURCE_HSE_DIV3        0x00030300U
N#define RCC_RTCCLKSOURCE_HSE_DIV4        0x00040300U
N#define RCC_RTCCLKSOURCE_HSE_DIV5        0x00050300U
N#define RCC_RTCCLKSOURCE_HSE_DIV6        0x00060300U
N#define RCC_RTCCLKSOURCE_HSE_DIV7        0x00070300U
N#define RCC_RTCCLKSOURCE_HSE_DIV8        0x00080300U
N#define RCC_RTCCLKSOURCE_HSE_DIV9        0x00090300U
N#define RCC_RTCCLKSOURCE_HSE_DIV10       0x000A0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV11       0x000B0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV12       0x000C0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV13       0x000D0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV14       0x000E0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV15       0x000F0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV16       0x00100300U
N#define RCC_RTCCLKSOURCE_HSE_DIV17       0x00110300U
N#define RCC_RTCCLKSOURCE_HSE_DIV18       0x00120300U
N#define RCC_RTCCLKSOURCE_HSE_DIV19       0x00130300U
N#define RCC_RTCCLKSOURCE_HSE_DIV20       0x00140300U
N#define RCC_RTCCLKSOURCE_HSE_DIV21       0x00150300U
N#define RCC_RTCCLKSOURCE_HSE_DIV22       0x00160300U
N#define RCC_RTCCLKSOURCE_HSE_DIV23       0x00170300U
N#define RCC_RTCCLKSOURCE_HSE_DIV24       0x00180300U
N#define RCC_RTCCLKSOURCE_HSE_DIV25       0x00190300U
N#define RCC_RTCCLKSOURCE_HSE_DIV26       0x001A0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV27       0x001B0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV28       0x001C0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV29       0x001D0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV30       0x001E0300U
N#define RCC_RTCCLKSOURCE_HSE_DIV31       0x001F0300U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO_Index MCO Index
N  * @{
N  */
N#define RCC_MCO1                         0x00000000U
N#define RCC_MCO2                         0x00000001U
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO1_Clock_Source MCO1 Clock Source
N  * @{
N  */
N#define RCC_MCO1SOURCE_HSI               0x00000000U
N#define RCC_MCO1SOURCE_LSE               RCC_CFGR_MCO1_0
N#define RCC_MCO1SOURCE_HSE               RCC_CFGR_MCO1_1
N#define RCC_MCO1SOURCE_PLLCLK            RCC_CFGR_MCO1
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCOx_Clock_Prescaler MCOx Clock Prescaler
N  * @{
N  */
N#define RCC_MCODIV_1                    0x00000000U
N#define RCC_MCODIV_2                    RCC_CFGR_MCO1PRE_2
N#define RCC_MCODIV_3                    ((uint32_t)RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_2)
N#define RCC_MCODIV_4                    ((uint32_t)RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_2)
N#define RCC_MCODIV_5                    RCC_CFGR_MCO1PRE
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Interrupt Interrupts
N  * @{
N  */
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
N#define RCC_IT_PLLI2SRDY                 ((uint8_t)0x20)
N#define RCC_IT_CSS                       ((uint8_t)0x80)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Flag Flags
N  *        Elements values convention: 0XXYYYYYb
N  *           - YYYYY  : Flag position in the register
N  *           - 0XX  : Register index
N  *                 - 01: CR register
N  *                 - 10: BDCR register
N  *                 - 11: CSR register
N  * @{
N  */
N/* Flags in the CR register */
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
N#define RCC_FLAG_PLLI2SRDY               ((uint8_t)0x3B)
N
N/* Flags in the BDCR register */
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
N
N/* Flags in the CSR register */
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
N#define RCC_FLAG_BORRST                  ((uint8_t)0x79)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RCC_Exported_Macros RCC Exported Macros
N  * @{
N  */
N
N/** @defgroup RCC_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_GPIOA_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_GPIOA_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_GPIOB_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_GPIOB_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_GPIOC_CLK_ENABLE()  do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_GPIOC_CLK_ENABLE()  do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_GPIOH_CLK_ENABLE()  do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);\
N                                        UNUSED(tmpreg); \
N                                         } while(0U)
X#define __HAL_RCC_GPIOH_CLK_ENABLE()  do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN);                                        UNUSED(tmpreg);                                          } while(0U)
N#define __HAL_RCC_DMA1_CLK_ENABLE()  do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);\
N                                        UNUSED(tmpreg); \
N                                         } while(0U)
X#define __HAL_RCC_DMA1_CLK_ENABLE()  do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN);                                        UNUSED(tmpreg);                                          } while(0U)
N#define __HAL_RCC_DMA2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_DMA2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);                                                                                  tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN);                                        UNUSED(tmpreg);                                           } while(0U)
N
N#define __HAL_RCC_GPIOA_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOAEN))
N#define __HAL_RCC_GPIOB_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOBEN))
N#define __HAL_RCC_GPIOC_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOCEN))
N#define __HAL_RCC_GPIOH_CLK_DISABLE()        (RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOHEN))
N#define __HAL_RCC_DMA1_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA1EN))
N#define __HAL_RCC_DMA2_CLK_DISABLE()         (RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA2EN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_GPIOA_IS_CLK_ENABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOAEN)) != RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_ENABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOBEN)) != RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_ENABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOCEN)) != RESET)
N#define __HAL_RCC_GPIOH_IS_CLK_ENABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOHEN)) != RESET)
N#define __HAL_RCC_DMA1_IS_CLK_ENABLED()         ((RCC->AHB1ENR &(RCC_AHB1ENR_DMA1EN)) != RESET)
N#define __HAL_RCC_DMA2_IS_CLK_ENABLED()         ((RCC->AHB1ENR &(RCC_AHB1ENR_DMA2EN)) != RESET)
N
N#define __HAL_RCC_GPIOA_IS_CLK_DISABLED()       ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOAEN)) == RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_DISABLED()       ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOBEN)) == RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_DISABLED()       ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOCEN)) == RESET)
N#define __HAL_RCC_GPIOH_IS_CLK_DISABLED()       ((RCC->AHB1ENR &(RCC_AHB1ENR_GPIOHEN)) == RESET)
N#define __HAL_RCC_DMA1_IS_CLK_DISABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_DMA1EN)) == RESET)
N#define __HAL_RCC_DMA2_IS_CLK_DISABLED()        ((RCC->AHB1ENR &(RCC_AHB1ENR_DMA2EN)) == RESET)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM5_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_TIM5_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_WWDG_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_WWDG_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_SPI2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_SPI2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_USART2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_USART2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_I2C1_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_I2C1_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_I2C2_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_I2C2_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_PWR_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_PWR_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);                                        UNUSED(tmpreg);                                           } while(0U)
N
N#define __HAL_RCC_TIM5_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM5EN))
N#define __HAL_RCC_WWDG_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_WWDGEN))
N#define __HAL_RCC_SPI2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI2EN))
N#define __HAL_RCC_USART2_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART2EN))
N#define __HAL_RCC_I2C1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C1EN))
N#define __HAL_RCC_I2C2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C2EN))
N#define __HAL_RCC_PWR_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_PWREN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM5_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM5EN)) != RESET)
N#define __HAL_RCC_WWDG_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN)) != RESET)
N#define __HAL_RCC_SPI2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) != RESET)
N#define __HAL_RCC_USART2_IS_CLK_ENABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) != RESET)
N#define __HAL_RCC_I2C1_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN)) != RESET)
N#define __HAL_RCC_I2C2_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) != RESET)
N#define __HAL_RCC_PWR_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_PWREN)) != RESET)
N
N#define __HAL_RCC_TIM5_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM5EN)) == RESET)
N#define __HAL_RCC_WWDG_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN)) == RESET)
N#define __HAL_RCC_SPI2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) == RESET)
N#define __HAL_RCC_USART2_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) == RESET)
N#define __HAL_RCC_I2C1_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN)) == RESET)
N#define __HAL_RCC_I2C2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) == RESET)
N#define __HAL_RCC_PWR_IS_CLK_DISABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_PWREN)) == RESET)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
N  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM1_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_TIM1_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_USART1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_USART1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_USART6_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_USART6_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_ADC1_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_ADC1_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_SPI1_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_SPI1_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_SYSCFG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_SYSCFG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_TIM9_CLK_ENABLE()     do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_TIM9_CLK_ENABLE()     do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN);                                        UNUSED(tmpreg);                                           } while(0U)
N#define __HAL_RCC_TIM11_CLK_ENABLE()    do { \
N                                        __IO uint32_t tmpreg = 0x00U; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);\
N                                        UNUSED(tmpreg); \
N                                          } while(0U)
X#define __HAL_RCC_TIM11_CLK_ENABLE()    do {                                         __IO uint32_t tmpreg = 0x00U;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN);                                        UNUSED(tmpreg);                                           } while(0U)
N
N#define __HAL_RCC_TIM1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM1EN))
N#define __HAL_RCC_USART1_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_USART1EN))
N#define __HAL_RCC_USART6_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_USART6EN))
N#define __HAL_RCC_ADC1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC1EN))
N#define __HAL_RCC_SPI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI1EN))
N#define __HAL_RCC_SYSCFG_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_SYSCFGEN))
N#define __HAL_RCC_TIM9_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM9EN))
N#define __HAL_RCC_TIM11_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM11EN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN)) != RESET)
N#define __HAL_RCC_USART1_IS_CLK_ENABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) != RESET)
N#define __HAL_RCC_USART6_IS_CLK_ENABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) != RESET)
N#define __HAL_RCC_ADC1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN)) != RESET)
N#define __HAL_RCC_SPI1_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN)) != RESET)
N#define __HAL_RCC_SYSCFG_IS_CLK_ENABLED() ((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) != RESET)
N#define __HAL_RCC_TIM9_IS_CLK_ENABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM9EN)) != RESET)
N#define __HAL_RCC_TIM11_IS_CLK_ENABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM11EN)) != RESET)
N
N#define __HAL_RCC_TIM1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN)) == RESET)
N#define __HAL_RCC_USART1_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) == RESET)
N#define __HAL_RCC_USART6_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) == RESET)
N#define __HAL_RCC_ADC1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN)) == RESET)
N#define __HAL_RCC_SPI1_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN)) == RESET)
N#define __HAL_RCC_SYSCFG_IS_CLK_DISABLED() ((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) == RESET)
N#define __HAL_RCC_TIM9_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_TIM9EN)) == RESET)
N#define __HAL_RCC_TIM11_IS_CLK_DISABLED()  ((RCC->APB2ENR & (RCC_APB2ENR_TIM11EN)) == RESET)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB1_Force_Release_Reset AHB1 Force Release Reset
N  * @brief  Force or release AHB1 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_AHB1_FORCE_RESET()    (RCC->AHB1RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_GPIOA_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOARST))
N#define __HAL_RCC_GPIOB_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOBRST))
N#define __HAL_RCC_GPIOC_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOCRST))
N#define __HAL_RCC_GPIOH_FORCE_RESET()   (RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOHRST))
N#define __HAL_RCC_DMA1_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA1RST))
N#define __HAL_RCC_DMA2_FORCE_RESET()    (RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA2RST))
N
N#define __HAL_RCC_AHB1_RELEASE_RESET()  (RCC->AHB1RSTR = 0x00U)
N#define __HAL_RCC_GPIOA_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOARST))
N#define __HAL_RCC_GPIOB_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOBRST))
N#define __HAL_RCC_GPIOC_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOCRST))
N#define __HAL_RCC_GPIOH_RELEASE_RESET() (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOHRST))
N#define __HAL_RCC_DMA1_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA1RST))
N#define __HAL_RCC_DMA2_RELEASE_RESET()  (RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA2RST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Force_Release_Reset APB1 Force Release Reset
N  * @brief  Force or release APB1 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_APB1_FORCE_RESET()     (RCC->APB1RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_TIM5_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM5RST))
N#define __HAL_RCC_WWDG_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_WWDGRST))
N#define __HAL_RCC_SPI2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI2RST))
N#define __HAL_RCC_USART2_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART2RST))
N#define __HAL_RCC_I2C1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C1RST))
N#define __HAL_RCC_I2C2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C2RST))
N#define __HAL_RCC_PWR_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_PWRRST))
N
N#define __HAL_RCC_APB1_RELEASE_RESET()   (RCC->APB1RSTR = 0x00U)
N#define __HAL_RCC_TIM5_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM5RST))
N#define __HAL_RCC_WWDG_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_WWDGRST))
N#define __HAL_RCC_SPI2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI2RST))
N#define __HAL_RCC_USART2_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART2RST))
N#define __HAL_RCC_I2C1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C1RST))
N#define __HAL_RCC_I2C2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C2RST))
N#define __HAL_RCC_PWR_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_PWRRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Force_Release_Reset APB2 Force Release Reset
N  * @brief  Force or release APB2 peripheral reset.
N  * @{
N  */
N#define __HAL_RCC_APB2_FORCE_RESET()     (RCC->APB2RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_TIM1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM1RST))
N#define __HAL_RCC_USART1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_USART1RST))
N#define __HAL_RCC_USART6_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_USART6RST))
N#define __HAL_RCC_ADC_FORCE_RESET()      (RCC->APB2RSTR |= (RCC_APB2RSTR_ADCRST))
N#define __HAL_RCC_SPI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI1RST))
N#define __HAL_RCC_SYSCFG_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SYSCFGRST))
N#define __HAL_RCC_TIM9_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM9RST))
N#define __HAL_RCC_TIM11_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM11RST))
N
N#define __HAL_RCC_APB2_RELEASE_RESET()   (RCC->APB2RSTR = 0x00U)
N#define __HAL_RCC_TIM1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM1RST))
N#define __HAL_RCC_USART1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART1RST))
N#define __HAL_RCC_USART6_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART6RST))
N#define __HAL_RCC_ADC_RELEASE_RESET()    (RCC->APB2RSTR &= ~(RCC_APB2RSTR_ADCRST))
N#define __HAL_RCC_SPI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI1RST))
N#define __HAL_RCC_SYSCFG_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SYSCFGRST))
N#define __HAL_RCC_TIM9_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM9RST))
N#define __HAL_RCC_TIM11_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM11RST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB1_LowPower_Enable_Disable AHB1 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOALPEN))
N#define __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOBLPEN))
N#define __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOCLPEN))
N#define __HAL_RCC_GPIOH_CLK_SLEEP_ENABLE()    (RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOHLPEN))
N#define __HAL_RCC_DMA1_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA1LPEN))
N#define __HAL_RCC_DMA2_CLK_SLEEP_ENABLE()     (RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA2LPEN))
N
N#define __HAL_RCC_GPIOA_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOALPEN))
N#define __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOBLPEN))
N#define __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOCLPEN))
N#define __HAL_RCC_GPIOH_CLK_SLEEP_DISABLE()   (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOHLPEN))
N#define __HAL_RCC_DMA1_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA1LPEN))
N#define __HAL_RCC_DMA2_CLK_SLEEP_DISABLE()    (RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA2LPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_LowPower_Enable_Disable APB1 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_TIM5_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_TIM5LPEN))
N#define __HAL_RCC_WWDG_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_WWDGLPEN))
N#define __HAL_RCC_SPI2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_SPI2LPEN))
N#define __HAL_RCC_USART2_CLK_SLEEP_ENABLE()  (RCC->APB1LPENR |= (RCC_APB1LPENR_USART2LPEN))
N#define __HAL_RCC_I2C1_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C1LPEN))
N#define __HAL_RCC_I2C2_CLK_SLEEP_ENABLE()    (RCC->APB1LPENR |= (RCC_APB1LPENR_I2C2LPEN))
N#define __HAL_RCC_PWR_CLK_SLEEP_ENABLE()     (RCC->APB1LPENR |= (RCC_APB1LPENR_PWRLPEN))
N
N#define __HAL_RCC_TIM5_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM5LPEN))
N#define __HAL_RCC_WWDG_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_WWDGLPEN))
N#define __HAL_RCC_SPI2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI2LPEN))
N#define __HAL_RCC_USART2_CLK_SLEEP_DISABLE() (RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART2LPEN))
N#define __HAL_RCC_I2C1_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C1LPEN))
N#define __HAL_RCC_I2C2_CLK_SLEEP_DISABLE()   (RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C2LPEN))
N#define __HAL_RCC_PWR_CLK_SLEEP_DISABLE()    (RCC->APB1LPENR &= ~(RCC_APB1LPENR_PWRLPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_LowPower_Enable_Disable APB2 Peripheral Low Power Enable Disable
N  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
N  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
N  *         power consumption.
N  * @note   After wake-up from SLEEP mode, the peripheral clock is enabled again.
N  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
N  * @{
N  */
N#define __HAL_RCC_TIM1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM1LPEN))
N#define __HAL_RCC_USART1_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_USART1LPEN))
N#define __HAL_RCC_USART6_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_USART6LPEN))
N#define __HAL_RCC_ADC1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_ADC1LPEN))
N#define __HAL_RCC_SPI1_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_SPI1LPEN))
N#define __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE()  (RCC->APB2LPENR |= (RCC_APB2LPENR_SYSCFGLPEN))
N#define __HAL_RCC_TIM9_CLK_SLEEP_ENABLE()    (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM9LPEN))
N#define __HAL_RCC_TIM11_CLK_SLEEP_ENABLE()   (RCC->APB2LPENR |= (RCC_APB2LPENR_TIM11LPEN))
N
N#define __HAL_RCC_TIM1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM1LPEN))
N#define __HAL_RCC_USART1_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_USART1LPEN))
N#define __HAL_RCC_USART6_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_USART6LPEN))
N#define __HAL_RCC_ADC1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC1LPEN))
N#define __HAL_RCC_SPI1_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI1LPEN))
N#define __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE() (RCC->APB2LPENR &= ~(RCC_APB2LPENR_SYSCFGLPEN))
N#define __HAL_RCC_TIM9_CLK_SLEEP_DISABLE()   (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM9LPEN))
N#define __HAL_RCC_TIM11_CLK_SLEEP_DISABLE()  (RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM11LPEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSI_Configuration HSI Configuration
N  * @{
N  */
N
N/** @brief  Macros to enable or disable the Internal High Speed oscillator (HSI).
N  * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
N  *         It is used (enabled by hardware) as system clock source after startup
N  *         from Reset, wake-up from STOP and STANDBY mode, or in case of failure
N  *         of the HSE used directly or indirectly as system clock (if the Clock
N  *         Security System CSS is enabled).
N  * @note   HSI can not be stopped if it is used as system clock source. In this case,
N  *         you have to select another source of the system clock then stop the HSI.
N  * @note   After enabling the HSI, the application software should wait on HSIRDY
N  *         flag to be set indicating that HSI clock is stable and can be used as
N  *         system clock source.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
N  *         clock cycles.
N  */
N#define __HAL_RCC_HSI_ENABLE() (*(__IO uint32_t *) RCC_CR_HSION_BB = ENABLE)
N#define __HAL_RCC_HSI_DISABLE() (*(__IO uint32_t *) RCC_CR_HSION_BB = DISABLE)
N
N/** @brief  Macro to adjust the Internal High Speed oscillator (HSI) calibration value.
N  * @note   The calibration is used to compensate for the variations in voltage
N  *         and temperature that influence the frequency of the internal HSI RC.
N  * @param  __HSICalibrationValue__ specifies the calibration trimming value.
N  *         (default is RCC_HSICALIBRATION_DEFAULT).
N  *         This parameter must be a number between 0 and 0x1F.
N  */
N#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(__HSICalibrationValue__) (MODIFY_REG(RCC->CR,\
N        RCC_CR_HSITRIM, (uint32_t)(__HSICalibrationValue__) << RCC_CR_HSITRIM_Pos))
X#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(__HSICalibrationValue__) (MODIFY_REG(RCC->CR,        RCC_CR_HSITRIM, (uint32_t)(__HSICalibrationValue__) << RCC_CR_HSITRIM_Pos))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSI_Configuration LSI Configuration
N  * @{
N  */
N
N/** @brief  Macros to enable or disable the Internal Low Speed oscillator (LSI).
N  * @note   After enabling the LSI, the application software should wait on
N  *         LSIRDY flag to be set indicating that LSI clock is stable and can
N  *         be used to clock the IWDG and/or the RTC.
N  * @note   LSI can not be disabled if the IWDG is running.
N  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
N  *         clock cycles.
N  */
N#define __HAL_RCC_LSI_ENABLE() (*(__IO uint32_t *) RCC_CSR_LSION_BB = ENABLE)
N#define __HAL_RCC_LSI_DISABLE() (*(__IO uint32_t *) RCC_CSR_LSION_BB = DISABLE)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSE_Configuration HSE Configuration
N  * @{
N  */
N
N/**
N  * @brief  Macro to configure the External High Speed oscillator (HSE).
N  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not supported by this macro.
N  *         User should request a transition to HSE Off first and then HSE On or HSE Bypass.
N  * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
N  *         software should wait on HSERDY flag to be set indicating that HSE clock
N  *         is stable and can be used to clock the PLL and/or system clock.
N  * @note   HSE state can not be changed if it is used directly or through the
N  *         PLL as system clock. In this case, you have to select another source
N  *         of the system clock then change the HSE state (ex. disable it).
N  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
N  * @note   This function reset the CSSON bit, so if the clock security system(CSS)
N  *         was previously enabled you have to enable it again after calling this
N  *         function.
N  * @param  __STATE__ specifies the new state of the HSE.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
N  *                              6 HSE oscillator clock cycles.
N  *            @arg RCC_HSE_ON: turn ON the HSE oscillator.
N  *            @arg RCC_HSE_BYPASS: HSE oscillator bypassed with external clock.
N  */
N#define __HAL_RCC_HSE_CONFIG(__STATE__)                         \
N                    do {                                        \
N                      if ((__STATE__) == RCC_HSE_ON)            \
N                      {                                         \
N                        SET_BIT(RCC->CR, RCC_CR_HSEON);         \
N                      }                                         \
N                      else if ((__STATE__) == RCC_HSE_BYPASS)   \
N                      {                                         \
N                        SET_BIT(RCC->CR, RCC_CR_HSEBYP);        \
N                        SET_BIT(RCC->CR, RCC_CR_HSEON);         \
N                      }                                         \
N                      else                                      \
N                      {                                         \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEON);       \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);      \
N                      }                                         \
N                    } while(0U)
X#define __HAL_RCC_HSE_CONFIG(__STATE__)                                             do {                                                              if ((__STATE__) == RCC_HSE_ON)                                  {                                                                 SET_BIT(RCC->CR, RCC_CR_HSEON);                               }                                                               else if ((__STATE__) == RCC_HSE_BYPASS)                         {                                                                 SET_BIT(RCC->CR, RCC_CR_HSEBYP);                                SET_BIT(RCC->CR, RCC_CR_HSEON);                               }                                                               else                                                            {                                                                 CLEAR_BIT(RCC->CR, RCC_CR_HSEON);                               CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);                            }                                                             } while(0U)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Configuration LSE Configuration
N  * @{
N  */
N
N/**
N  * @brief  Macro to configure the External Low Speed oscillator (LSE).
N  * @note   Transition LSE Bypass to LSE On and LSE On to LSE Bypass are not supported by this macro.
N  *         User should request a transition to LSE Off first and then LSE On or LSE Bypass.
N  * @note   As the LSE is in the Backup domain and write access is denied to
N  *         this domain after reset, you have to enable write access using
N  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
N  *         (to be done once after reset).
N  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_BYPASS), the application
N  *         software should wait on LSERDY flag to be set indicating that LSE clock
N  *         is stable and can be used to clock the RTC.
N  * @param  __STATE__ specifies the new state of the LSE.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
N  *                              6 LSE oscillator clock cycles.
N  *            @arg RCC_LSE_ON: turn ON the LSE oscillator.
N  *            @arg RCC_LSE_BYPASS: LSE oscillator bypassed with external clock.
N  */
N#define __HAL_RCC_LSE_CONFIG(__STATE__) \
N                    do {                                       \
N                      if((__STATE__) == RCC_LSE_ON)            \
N                      {                                        \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);    \
N                      }                                        \
N                      else if((__STATE__) == RCC_LSE_BYPASS)   \
N                      {                                        \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);   \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);    \
N                      }                                        \
N                      else                                     \
N                      {                                        \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);  \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); \
N                      }                                        \
N                    } while(0U)
X#define __HAL_RCC_LSE_CONFIG(__STATE__)                     do {                                                             if((__STATE__) == RCC_LSE_ON)                                  {                                                                SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          }                                                              else if((__STATE__) == RCC_LSE_BYPASS)                         {                                                                SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                           SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          }                                                              else                                                           {                                                                CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);                          CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                       }                                                            } while(0U)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Internal_RTC_Clock_Configuration RTC Clock Configuration
N  * @{
N  */
N
N/** @brief  Macros to enable or disable the RTC clock.
N  * @note   These macros must be used only after the RTC clock source was selected.
N  */
N#define __HAL_RCC_RTC_ENABLE() (*(__IO uint32_t *) RCC_BDCR_RTCEN_BB = ENABLE)
N#define __HAL_RCC_RTC_DISABLE() (*(__IO uint32_t *) RCC_BDCR_RTCEN_BB = DISABLE)
N
N/** @brief  Macros to configure the RTC clock (RTCCLK).
N  * @note   As the RTC clock configuration bits are in the Backup domain and write
N  *         access is denied to this domain after reset, you have to enable write
N  *         access using the Power Backup Access macro before to configure
N  *         the RTC clock source (to be done once after reset).
N  * @note   Once the RTC clock is configured it can't be changed unless the
N  *         Backup domain is reset using __HAL_RCC_BackupReset_RELEASE() macro, or by
N  *         a Power On Reset (POR).
N  * @param  __RTCCLKSource__ specifies the RTC clock source.
N  *         This parameter can be one of the following values:
N               @arg @ref RCC_RTCCLKSOURCE_NO_CLK: No clock selected as RTC clock.
N  *            @arg @ref RCC_RTCCLKSOURCE_LSE: LSE selected as RTC clock.
N  *            @arg @ref RCC_RTCCLKSOURCE_LSI: LSI selected as RTC clock.
N  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX: HSE clock divided by x selected
N  *                                                 as RTC clock, where x:[2,31]
N  * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
N  *         work in STOP and STANDBY modes, and can be used as wake-up source.
N  *         However, when the HSE clock is used as RTC clock source, the RTC
N  *         cannot be used in STOP and STANDBY modes.
N  * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
N  *         RTC clock source).
N  */
N#define __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__) (((__RTCCLKSource__) & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) ?    \
N                                                 MODIFY_REG(RCC->CFGR, RCC_CFGR_RTCPRE, ((__RTCCLKSource__) & 0xFFFFCFFU)) : CLEAR_BIT(RCC->CFGR, RCC_CFGR_RTCPRE)
X#define __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__) (((__RTCCLKSource__) & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) ?                                                     MODIFY_REG(RCC->CFGR, RCC_CFGR_RTCPRE, ((__RTCCLKSource__) & 0xFFFFCFFU)) : CLEAR_BIT(RCC->CFGR, RCC_CFGR_RTCPRE)
N
N#define __HAL_RCC_RTC_CONFIG(__RTCCLKSource__) do { __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__);    \
N                                                    RCC->BDCR |= ((__RTCCLKSource__) & 0x00000FFFU);  \
N                                                   } while(0U)
X#define __HAL_RCC_RTC_CONFIG(__RTCCLKSource__) do { __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__);                                                        RCC->BDCR |= ((__RTCCLKSource__) & 0x00000FFFU);                                                     } while(0U)
N
N/** @brief Macro to get the RTC clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_RTCCLKSOURCE_NO_CLK No clock selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_LSE LSE selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_LSI LSI selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX HSE divided by X selected as RTC clock (X can be retrieved thanks to @ref __HAL_RCC_GET_RTC_HSE_PRESCALER()
N  */
N#define __HAL_RCC_GET_RTC_SOURCE() (READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL))
N
N/**
N  * @brief   Get the RTC and HSE clock divider (RTCPRE).
N  * @retval Returned value can be one of the following values:
N  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX: HSE clock divided by x selected
N  *                                                 as RTC clock, where x:[2,31]
N  */
N#define  __HAL_RCC_GET_RTC_HSE_PRESCALER() (READ_BIT(RCC->CFGR, RCC_CFGR_RTCPRE) | RCC_BDCR_RTCSEL)
N
N/** @brief  Macros to force or release the Backup domain reset.
N  * @note   This function resets the RTC peripheral (including the backup registers)
N  *         and the RTC clock source selection in RCC_CSR register.
N  * @note   The BKPSRAM is not affected by this reset.
N  */
N#define __HAL_RCC_BACKUPRESET_FORCE() (*(__IO uint32_t *) RCC_BDCR_BDRST_BB = ENABLE)
N#define __HAL_RCC_BACKUPRESET_RELEASE() (*(__IO uint32_t *) RCC_BDCR_BDRST_BB = DISABLE)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Configuration PLL Configuration
N  * @{
N  */
N
N/** @brief  Macros to enable or disable the main PLL.
N  * @note   After enabling the main PLL, the application software should wait on
N  *         PLLRDY flag to be set indicating that PLL clock is stable and can
N  *         be used as system clock source.
N  * @note   The main PLL can not be disabled if it is used as system clock source
N  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
N  */
N#define __HAL_RCC_PLL_ENABLE() (*(__IO uint32_t *) RCC_CR_PLLON_BB = ENABLE)
N#define __HAL_RCC_PLL_DISABLE() (*(__IO uint32_t *) RCC_CR_PLLON_BB = DISABLE)
N
N/** @brief  Macro to configure the PLL clock source.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __PLLSOURCE__ specifies the PLL entry clock source.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
N  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
N  *
N  */
N#define __HAL_RCC_PLL_PLLSOURCE_CONFIG(__PLLSOURCE__) MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, (__PLLSOURCE__))
N
N/** @brief  Macro to configure the PLL multiplication factor.
N  * @note   This function must be used only when the main PLL is disabled.
N  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
N  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
N  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
N  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
N  *         of 2 MHz to limit PLL jitter.
N  *
N  */
N#define __HAL_RCC_PLL_PLLM_CONFIG(__PLLM__) MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLM, (__PLLM__))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Get_Clock_source Get Clock source
N  * @{
N  */
N/**
N  * @brief Macro to configure the system clock source.
N  * @param __RCC_SYSCLKSOURCE__ specifies the system clock source.
N  * This parameter can be one of the following values:
N  *              - RCC_SYSCLKSOURCE_HSI: HSI oscillator is used as system clock source.
N  *              - RCC_SYSCLKSOURCE_HSE: HSE oscillator is used as system clock source.
N  *              - RCC_SYSCLKSOURCE_PLLCLK: PLL output is used as system clock source.
N  *              - RCC_SYSCLKSOURCE_PLLRCLK: PLLR output is used as system clock source. This
N  *                parameter is available only for STM32F446xx devices.
N  */
N#define __HAL_RCC_SYSCLK_CONFIG(__RCC_SYSCLKSOURCE__) MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, (__RCC_SYSCLKSOURCE__))
N
N/** @brief  Macro to get the clock source used as system clock.
N  * @retval The clock source used as system clock. The returned value can be one
N  *         of the following:
N  *              - RCC_SYSCLKSOURCE_STATUS_HSI: HSI used as system clock.
N  *              - RCC_SYSCLKSOURCE_STATUS_HSE: HSE used as system clock.
N  *              - RCC_SYSCLKSOURCE_STATUS_PLLCLK: PLL used as system clock.
N  *              - RCC_SYSCLKSOURCE_STATUS_PLLRCLK: PLLR used as system clock. This parameter
N  *                is available only for STM32F446xx devices.
N  */
N#define __HAL_RCC_GET_SYSCLK_SOURCE() (RCC->CFGR & RCC_CFGR_SWS)
N
N/** @brief  Macro to get the oscillator used as PLL clock source.
N  * @retval The oscillator used as PLL clock source. The returned value can be one
N  *         of the following:
N  *              - RCC_PLLSOURCE_HSI: HSI oscillator is used as PLL clock source.
N  *              - RCC_PLLSOURCE_HSE: HSE oscillator is used as PLL clock source.
N  */
N#define __HAL_RCC_GET_PLL_OSCSOURCE() ((uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC))
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_MCOx_Clock_Config RCC Extended MCOx Clock Config
N  * @{
N  */
N
N/** @brief  Macro to configure the MCO1 clock.
N  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
N  *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source
N  * @param  __MCODIV__ specifies the MCO clock prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
N  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
N  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
N  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
N  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
N  */
N#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__) \
N                 MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))
X#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__)                  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))
N
N/** @brief  Macro to configure the MCO2 clock.
N  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
N  *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source, available for all STM32F4 devices except STM32F410xx
N  *            @arg RCC_MCO2SOURCE_I2SCLK: I2SCLK clock selected as MCO2 source, available only for STM32F410Rx devices
N  *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
N  *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source
N  * @param  __MCODIV__ specifies the MCO clock prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
N  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
N  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
N  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
N  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
N  * @note  For STM32F410Rx devices, to output I2SCLK clock on MCO2, you should have
N  *        at least one of the SPI clocks enabled (SPI1, SPI2 or SPI5).
N  */
N#define __HAL_RCC_MCO2_CONFIG(__MCOCLKSOURCE__, __MCODIV__) \
N    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), ((__MCOCLKSOURCE__) | ((__MCODIV__) << 3U)));
X#define __HAL_RCC_MCO2_CONFIG(__MCOCLKSOURCE__, __MCODIV__)     MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), ((__MCOCLKSOURCE__) | ((__MCODIV__) << 3U)));
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Flags_Interrupts_Management Flags Interrupts Management
N  * @brief macros to manage the specified RCC Flags and interrupts.
N  * @{
N  */
N
N/** @brief  Enable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to enable
N  *         the selected interrupts).
N  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be enabled.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  */
N#define __HAL_RCC_ENABLE_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS |= (__INTERRUPT__))
N
N/** @brief Disable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to disable
N  *        the selected interrupts).
N  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be disabled.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  */
N#define __HAL_RCC_DISABLE_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS &= (uint8_t)(~(__INTERRUPT__)))
N
N/** @brief  Clear the RCC's interrupt pending bits (Perform Byte access to RCC_CIR[23:16]
N  *         bits to clear the selected interrupt pending bits.
N  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
N  *         This parameter can be any combination of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  *            @arg RCC_IT_CSS: Clock Security System interrupt
N  */
N#define __HAL_RCC_CLEAR_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE2_ADDRESS = (__INTERRUPT__))
N
N/** @brief  Check the RCC's interrupt has occurred or not.
N  * @param  __INTERRUPT__ specifies the RCC interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
N  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
N  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
N  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
N  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
N  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
N  *            @arg RCC_IT_CSS: Clock Security System interrupt
N  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_RCC_GET_IT(__INTERRUPT__) ((RCC->CIR & (__INTERRUPT__)) == (__INTERRUPT__))
N
N/** @brief Set RMVF bit to clear the reset flags: RCC_FLAG_PINRST, RCC_FLAG_PORRST,
N  *        RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST and RCC_FLAG_LPWRRST.
N  */
N#define __HAL_RCC_CLEAR_RESET_FLAGS() (RCC->CSR |= RCC_CSR_RMVF)
N
N/** @brief  Check RCC flag is set or not.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready.
N  *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready.
N  *            @arg RCC_FLAG_PLLRDY: Main PLL clock ready.
N  *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready.
N  *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready.
N  *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready.
N  *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset.
N  *            @arg RCC_FLAG_PINRST: Pin reset.
N  *            @arg RCC_FLAG_PORRST: POR/PDR reset.
N  *            @arg RCC_FLAG_SFTRST: Software reset.
N  *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset.
N  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset.
N  *            @arg RCC_FLAG_LPWRRST: Low Power reset.
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define RCC_FLAG_MASK  ((uint8_t)0x1FU)
N#define __HAL_RCC_GET_FLAG(__FLAG__) (((((((__FLAG__) >> 5U) == 1U)? RCC->CR :((((__FLAG__) >> 5U) == 2U) ? RCC->BDCR :((((__FLAG__) >> 5U) == 3U)? RCC->CSR :RCC->CIR))) & (1U << ((__FLAG__) & RCC_FLAG_MASK)))!= 0U)? 1U : 0U)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N /** @addtogroup RCC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup RCC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions  ******************************/
NHAL_StatusTypeDef HAL_RCC_DeInit(void);
NHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
NHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency);
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions  ************************************************/
Nvoid     HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv);
Nvoid     HAL_RCC_EnableCSS(void);
Nvoid     HAL_RCC_DisableCSS(void);
Nuint32_t HAL_RCC_GetSysClockFreq(void);
Nuint32_t HAL_RCC_GetHCLKFreq(void);
Nuint32_t HAL_RCC_GetPCLK1Freq(void);
Nuint32_t HAL_RCC_GetPCLK2Freq(void);
Nvoid     HAL_RCC_GetOscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
Nvoid     HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t *pFLatency);
N
N/* CSS NMI IRQ handler */
Nvoid HAL_RCC_NMI_IRQHandler(void);
N
N/* User Callbacks in non blocking mode (IT mode) */
Nvoid HAL_RCC_CSSCallback(void);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RCC_Private_Constants RCC Private Constants
N  * @{
N  */
N
N/** @defgroup RCC_BitAddress_AliasRegion RCC BitAddress AliasRegion
N  * @brief RCC registers bit address in the alias region
N  * @{
N  */
N#define RCC_OFFSET                 (RCC_BASE - PERIPH_BASE)
N/* --- CR Register --- */
N/* Alias word address of HSION bit */
N#define RCC_CR_OFFSET              (RCC_OFFSET + 0x00U)
N#define RCC_HSION_BIT_NUMBER       0x00U
N#define RCC_CR_HSION_BB            (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_HSION_BIT_NUMBER * 4U))
N/* Alias word address of CSSON bit */
N#define RCC_CSSON_BIT_NUMBER       0x13U
N#define RCC_CR_CSSON_BB            (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_CSSON_BIT_NUMBER * 4U))
N/* Alias word address of PLLON bit */
N#define RCC_PLLON_BIT_NUMBER       0x18U
N#define RCC_CR_PLLON_BB            (PERIPH_BB_BASE + (RCC_CR_OFFSET * 32U) + (RCC_PLLON_BIT_NUMBER * 4U))
N
N/* --- BDCR Register --- */
N/* Alias word address of RTCEN bit */
N#define RCC_BDCR_OFFSET            (RCC_OFFSET + 0x70U)
N#define RCC_RTCEN_BIT_NUMBER       0x0FU
N#define RCC_BDCR_RTCEN_BB          (PERIPH_BB_BASE + (RCC_BDCR_OFFSET * 32U) + (RCC_RTCEN_BIT_NUMBER * 4U))
N/* Alias word address of BDRST bit */
N#define RCC_BDRST_BIT_NUMBER       0x10U
N#define RCC_BDCR_BDRST_BB          (PERIPH_BB_BASE + (RCC_BDCR_OFFSET * 32U) + (RCC_BDRST_BIT_NUMBER * 4U))
N
N/* --- CSR Register --- */
N/* Alias word address of LSION bit */
N#define RCC_CSR_OFFSET             (RCC_OFFSET + 0x74U)
N#define RCC_LSION_BIT_NUMBER        0x00U
N#define RCC_CSR_LSION_BB           (PERIPH_BB_BASE + (RCC_CSR_OFFSET * 32U) + (RCC_LSION_BIT_NUMBER * 4U))
N
N/* CR register byte 3 (Bits[23:16]) base address */
N#define RCC_CR_BYTE2_ADDRESS       0x40023802U
N
N/* CIR register byte 2 (Bits[15:8]) base address */
N#define RCC_CIR_BYTE1_ADDRESS      ((uint32_t)(RCC_BASE + 0x0CU + 0x01U))
N
N/* CIR register byte 3 (Bits[23:16]) base address */
N#define RCC_CIR_BYTE2_ADDRESS      ((uint32_t)(RCC_BASE + 0x0CU + 0x02U))
N
N/* BDCR register base address */
N#define RCC_BDCR_BYTE0_ADDRESS     (PERIPH_BASE + RCC_BDCR_OFFSET)
N
N#define RCC_DBP_TIMEOUT_VALUE      2U
N#define RCC_LSE_TIMEOUT_VALUE      LSE_STARTUP_TIMEOUT
N
N#define HSE_TIMEOUT_VALUE          HSE_STARTUP_TIMEOUT
N#define HSI_TIMEOUT_VALUE          2U  /* 2 ms */
N#define LSI_TIMEOUT_VALUE          2U  /* 2 ms */
N#define CLOCKSWITCH_TIMEOUT_VALUE  5000U /* 5 s */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RCC_Private_Macros RCC Private Macros
N  * @{
N  */
N
N/** @defgroup RCC_IS_RCC_Definitions RCC Private macros to check input parameters
N  * @{
N  */
N#define IS_RCC_OSCILLATORTYPE(OSCILLATOR) ((OSCILLATOR) <= 15U)
N
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_BYPASS))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_BYPASS))
N
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_BYPASS))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_BYPASS))
N
N#define IS_RCC_HSI(HSI) (((HSI) == RCC_HSI_OFF) || ((HSI) == RCC_HSI_ON))
N
N#define IS_RCC_LSI(LSI) (((LSI) == RCC_LSI_OFF) || ((LSI) == RCC_LSI_ON))
N
N#define IS_RCC_PLL(PLL) (((PLL) == RCC_PLL_NONE) ||((PLL) == RCC_PLL_OFF) || ((PLL) == RCC_PLL_ON))
N
N#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI) || \
N                                  ((SOURCE) == RCC_PLLSOURCE_HSE))
X#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI) ||                                   ((SOURCE) == RCC_PLLSOURCE_HSE))
N
N#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_HSI) || \
N                                     ((SOURCE) == RCC_SYSCLKSOURCE_HSE) || \
N                                     ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK) || \
N                                     ((SOURCE) == RCC_SYSCLKSOURCE_PLLRCLK))
X#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_HSI) ||                                      ((SOURCE) == RCC_SYSCLKSOURCE_HSE) ||                                      ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK) ||                                      ((SOURCE) == RCC_SYSCLKSOURCE_PLLRCLK))
N
N#define IS_RCC_RTCCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_RTCCLKSOURCE_LSE) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_LSI) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV2) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV3) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV4) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV5) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV6) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV7) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV8) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV9) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV10) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV11) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV12) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV13) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV14) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV15) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV16) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV17) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV18) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV19) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV20) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV21) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV22) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV23) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV24) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV25) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV26) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV27) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV28) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV29) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV30) || \
N                                         ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV31))
X#define IS_RCC_RTCCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_RTCCLKSOURCE_LSE) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_LSI) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV2) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV3) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV4) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV5) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV6) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV7) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV8) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV9) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV10) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV11) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV12) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV13) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV14) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV15) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV16) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV17) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV18) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV19) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV20) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV21) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV22) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV23) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV24) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV25) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV26) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV27) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV28) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV29) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV30) ||                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV31))
N
N#define IS_RCC_PLLM_VALUE(VALUE) ((VALUE) <= 63U)
N
N#define IS_RCC_PLLP_VALUE(VALUE) (((VALUE) == 2U) || ((VALUE) == 4U) || ((VALUE) == 6U) || ((VALUE) == 8U))
N
N#define IS_RCC_PLLQ_VALUE(VALUE) ((2U <= (VALUE)) && ((VALUE) <= 15U))
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_DIV1)   || ((HCLK) == RCC_SYSCLK_DIV2)   || \
N                           ((HCLK) == RCC_SYSCLK_DIV4)   || ((HCLK) == RCC_SYSCLK_DIV8)   || \
N                           ((HCLK) == RCC_SYSCLK_DIV16)  || ((HCLK) == RCC_SYSCLK_DIV64)  || \
N                           ((HCLK) == RCC_SYSCLK_DIV128) || ((HCLK) == RCC_SYSCLK_DIV256) || \
N                           ((HCLK) == RCC_SYSCLK_DIV512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_DIV1)   || ((HCLK) == RCC_SYSCLK_DIV2)   ||                            ((HCLK) == RCC_SYSCLK_DIV4)   || ((HCLK) == RCC_SYSCLK_DIV8)   ||                            ((HCLK) == RCC_SYSCLK_DIV16)  || ((HCLK) == RCC_SYSCLK_DIV64)  ||                            ((HCLK) == RCC_SYSCLK_DIV128) || ((HCLK) == RCC_SYSCLK_DIV256) ||                            ((HCLK) == RCC_SYSCLK_DIV512))
N
N#define IS_RCC_CLOCKTYPE(CLK) ((1U <= (CLK)) && ((CLK) <= 15U))
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_DIV1) || ((PCLK) == RCC_HCLK_DIV2) || \
N                           ((PCLK) == RCC_HCLK_DIV4) || ((PCLK) == RCC_HCLK_DIV8) || \
N                           ((PCLK) == RCC_HCLK_DIV16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_DIV1) || ((PCLK) == RCC_HCLK_DIV2) ||                            ((PCLK) == RCC_HCLK_DIV4) || ((PCLK) == RCC_HCLK_DIV8) ||                            ((PCLK) == RCC_HCLK_DIV16))
N
N#define IS_RCC_MCO(MCOx) (((MCOx) == RCC_MCO1) || ((MCOx) == RCC_MCO2))
N
N#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1SOURCE_HSI) || ((SOURCE) == RCC_MCO1SOURCE_LSE) || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_HSE) || ((SOURCE) == RCC_MCO1SOURCE_PLLCLK))
X#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1SOURCE_HSI) || ((SOURCE) == RCC_MCO1SOURCE_LSE) ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSE) || ((SOURCE) == RCC_MCO1SOURCE_PLLCLK))
N
N#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1)  || ((DIV) == RCC_MCODIV_2) || \
N                             ((DIV) == RCC_MCODIV_3) || ((DIV) == RCC_MCODIV_4) || \
N                             ((DIV) == RCC_MCODIV_5))
X#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1)  || ((DIV) == RCC_MCODIV_2) ||                              ((DIV) == RCC_MCODIV_3) || ((DIV) == RCC_MCODIV_4) ||                              ((DIV) == RCC_MCODIV_5))
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1FU)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_RCC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 199 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_RCC_MODULE_ENABLED */
N
N#ifdef HAL_GPIO_MODULE_ENABLED
N#include "stm32f4xx_hal_gpio.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_gpio.h
N  * @author  MCD Application Team
N  * @brief   Header file of GPIO HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_GPIO_H
N#define __STM32F4xx_HAL_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup GPIO
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Types GPIO Exported Types
N  * @{
N  */
N
N/** 
N  * @brief GPIO Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t Pin;       /*!< Specifies the GPIO pins to be configured.
N                           This parameter can be any value of @ref GPIO_pins_define */
N
N  uint32_t Mode;      /*!< Specifies the operating mode for the selected pins.
N                           This parameter can be a value of @ref GPIO_mode_define */
N
N  uint32_t Pull;      /*!< Specifies the Pull-up or Pull-Down activation for the selected pins.
N                           This parameter can be a value of @ref GPIO_pull_define */
N
N  uint32_t Speed;     /*!< Specifies the speed for the selected pins.
N                           This parameter can be a value of @ref GPIO_speed_define */
N
N  uint32_t Alternate;  /*!< Peripheral to be connected to the selected pins. 
N                            This parameter can be a value of @ref GPIO_Alternate_function_selection */
N}GPIO_InitTypeDef;
N
N/** 
N  * @brief  GPIO Bit SET and Bit RESET enumeration 
N  */
Ntypedef enum
N{
N  GPIO_PIN_RESET = 0,
N  GPIO_PIN_SET
N}GPIO_PinState;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup GPIO_Exported_Constants GPIO Exported Constants
N  * @{
N  */ 
N
N/** @defgroup GPIO_pins_define GPIO pins define
N  * @{
N  */
N#define GPIO_PIN_0                 ((uint16_t)0x0001)  /* Pin 0 selected    */
N#define GPIO_PIN_1                 ((uint16_t)0x0002)  /* Pin 1 selected    */
N#define GPIO_PIN_2                 ((uint16_t)0x0004)  /* Pin 2 selected    */
N#define GPIO_PIN_3                 ((uint16_t)0x0008)  /* Pin 3 selected    */
N#define GPIO_PIN_4                 ((uint16_t)0x0010)  /* Pin 4 selected    */
N#define GPIO_PIN_5                 ((uint16_t)0x0020)  /* Pin 5 selected    */
N#define GPIO_PIN_6                 ((uint16_t)0x0040)  /* Pin 6 selected    */
N#define GPIO_PIN_7                 ((uint16_t)0x0080)  /* Pin 7 selected    */
N#define GPIO_PIN_8                 ((uint16_t)0x0100)  /* Pin 8 selected    */
N#define GPIO_PIN_9                 ((uint16_t)0x0200)  /* Pin 9 selected    */
N#define GPIO_PIN_10                ((uint16_t)0x0400)  /* Pin 10 selected   */
N#define GPIO_PIN_11                ((uint16_t)0x0800)  /* Pin 11 selected   */
N#define GPIO_PIN_12                ((uint16_t)0x1000)  /* Pin 12 selected   */
N#define GPIO_PIN_13                ((uint16_t)0x2000)  /* Pin 13 selected   */
N#define GPIO_PIN_14                ((uint16_t)0x4000)  /* Pin 14 selected   */
N#define GPIO_PIN_15                ((uint16_t)0x8000)  /* Pin 15 selected   */
N#define GPIO_PIN_All               ((uint16_t)0xFFFF)  /* All pins selected */
N
N#define GPIO_PIN_MASK              0x0000FFFFU /* PIN mask for assert test */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_mode_define GPIO mode define
N  * @brief GPIO Configuration Mode 
N  *        Elements values convention: 0xX0yz00YZ
N  *           - X  : GPIO mode or EXTI Mode
N  *           - y  : External IT or Event trigger detection 
N  *           - z  : IO configuration on External IT or Event
N  *           - Y  : Output type (Push Pull or Open Drain)
N  *           - Z  : IO Direction mode (Input, Output, Alternate or Analog)
N  * @{
N  */ 
N#define  GPIO_MODE_INPUT                        0x00000000U   /*!< Input Floating Mode                   */
N#define  GPIO_MODE_OUTPUT_PP                    0x00000001U   /*!< Output Push Pull Mode                 */
N#define  GPIO_MODE_OUTPUT_OD                    0x00000011U   /*!< Output Open Drain Mode                */
N#define  GPIO_MODE_AF_PP                        0x00000002U   /*!< Alternate Function Push Pull Mode     */
N#define  GPIO_MODE_AF_OD                        0x00000012U   /*!< Alternate Function Open Drain Mode    */
N
N#define  GPIO_MODE_ANALOG                       0x00000003U   /*!< Analog Mode  */
N    
N#define  GPIO_MODE_IT_RISING                    0x10110000U   /*!< External Interrupt Mode with Rising edge trigger detection          */
N#define  GPIO_MODE_IT_FALLING                   0x10210000U   /*!< External Interrupt Mode with Falling edge trigger detection         */
N#define  GPIO_MODE_IT_RISING_FALLING            0x10310000U   /*!< External Interrupt Mode with Rising/Falling edge trigger detection  */
N 
N#define  GPIO_MODE_EVT_RISING                   0x10120000U   /*!< External Event Mode with Rising edge trigger detection               */
N#define  GPIO_MODE_EVT_FALLING                  0x10220000U   /*!< External Event Mode with Falling edge trigger detection              */
N#define  GPIO_MODE_EVT_RISING_FALLING           0x10320000U   /*!< External Event Mode with Rising/Falling edge trigger detection       */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_speed_define  GPIO speed define
N  * @brief GPIO Output Maximum frequency
N  * @{
N  */
N#define  GPIO_SPEED_FREQ_LOW         0x00000000U  /*!< IO works at 2 MHz, please refer to the product datasheet */
N#define  GPIO_SPEED_FREQ_MEDIUM      0x00000001U  /*!< range 12,5 MHz to 50 MHz, please refer to the product datasheet */
N#define  GPIO_SPEED_FREQ_HIGH        0x00000002U  /*!< range 25 MHz to 100 MHz, please refer to the product datasheet  */
N#define  GPIO_SPEED_FREQ_VERY_HIGH   0x00000003U  /*!< range 50 MHz to 200 MHz, please refer to the product datasheet  */
N/**
N  * @}
N  */
N
N /** @defgroup GPIO_pull_define GPIO pull define
N   * @brief GPIO Pull-Up or Pull-Down Activation
N   * @{
N   */  
N#define  GPIO_NOPULL        0x00000000U   /*!< No Pull-up or Pull-down activation  */
N#define  GPIO_PULLUP        0x00000001U   /*!< Pull-up activation                  */
N#define  GPIO_PULLDOWN      0x00000002U   /*!< Pull-down activation                */
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Macros GPIO Exported Macros
N  * @{
N  */
N
N/**
N  * @brief  Checks whether the specified EXTI line flag is set or not.
N  * @param  __EXTI_LINE__ specifies the EXTI line flag to check.
N  *         This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval The new state of __EXTI_LINE__ (SET or RESET).
N  */
N#define __HAL_GPIO_EXTI_GET_FLAG(__EXTI_LINE__) (EXTI->PR & (__EXTI_LINE__))
N
N/**
N  * @brief  Clears the EXTI's line pending flags.
N  * @param  __EXTI_LINE__ specifies the EXTI lines flags to clear.
N  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_CLEAR_FLAG(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
N
N/**
N  * @brief  Checks whether the specified EXTI line is asserted or not.
N  * @param  __EXTI_LINE__ specifies the EXTI line to check.
N  *          This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval The new state of __EXTI_LINE__ (SET or RESET).
N  */
N#define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI->PR & (__EXTI_LINE__))
N
N/**
N  * @brief  Clears the EXTI's line pending bits.
N  * @param  __EXTI_LINE__ specifies the EXTI lines to clear.
N  *          This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
N
N/**
N  * @brief  Generates a Software interrupt on selected EXTI line.
N  * @param  __EXTI_LINE__ specifies the EXTI line to check.
N  *          This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_GENERATE_SWIT(__EXTI_LINE__) (EXTI->SWIER |= (__EXTI_LINE__))
N/**
N  * @}
N  */
N
N/* Include GPIO HAL Extension module */
N#include "stm32f4xx_hal_gpio_ex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_gpio_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_gpio_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of GPIO HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_GPIO_EX_H
N#define __STM32F4xx_HAL_GPIO_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup GPIOEx GPIOEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Constants GPIO Exported Constants
N  * @{
N  */
N  
N/** @defgroup GPIO_Alternate_function_selection GPIO Alternate Function Selection
N  * @{
N  */
N
N/*------------------------------------------ STM32F429xx/STM32F439xx ---------*/
N#if defined(STM32F429xx) || defined(STM32F439xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping        */
S#define GPIO_AF5_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping        */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping       */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
S#define GPIO_AF8_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping    */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping   */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping   */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping   */
S#define GPIO_AF9_LTDC          ((uint8_t)0x09)  /* LCD-TFT Alternate Function mapping */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FMC           ((uint8_t)0x0C)  /* FMC Alternate Function mapping                      */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S
S/** 
S  * @brief   AF 14 selection  
S  */
S#define GPIO_AF14_LTDC          ((uint8_t)0x0E)  /* LCD-TFT Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F429xx || STM32F439xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F427xx/STM32F437xx------------------*/
N#if defined(STM32F427xx) || defined(STM32F437xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping        */
S#define GPIO_AF5_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping        */
S/** @brief  GPIO_Legacy 
S  */
S#define GPIO_AF5_I2S3ext       GPIO_AF5_SPI3   /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping       */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
S#define GPIO_AF8_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FMC           ((uint8_t)0x0C)  /* FMC Alternate Function mapping                      */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F427xx || STM32F437xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F407xx/STM32F417xx------------------*/
N#if defined(STM32F407xx) || defined(STM32F417xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FSMC          ((uint8_t)0x0C)  /* FSMC Alternate Function mapping                     */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F407xx || STM32F417xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F405xx/STM32F415xx------------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FSMC          ((uint8_t)0x0C)  /* FSMC Alternate Function mapping                     */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F405xx || STM32F415xx */
N
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------------- STM32F401xx------------------------*/
N#if defined(STM32F401xC) || defined(STM32F401xE) 
X#if 0L || 1L 
N/** 
N  * @brief   AF 0 selection  
N  */ 
N#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
N#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
N#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
N#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
N#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
N
N/** 
N  * @brief   AF 1 selection  
N  */ 
N#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
N#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
N
N/** 
N  * @brief   AF 2 selection  
N  */ 
N#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
N#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
N#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
N
N/** 
N  * @brief   AF 3 selection  
N  */ 
N#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
N#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
N#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
N
N/** 
N  * @brief   AF 4 selection  
N  */ 
N#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
N#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
N#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
N
N/** 
N  * @brief   AF 5 selection  
N  */ 
N#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
N#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
N#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3 Alternate Function mapping        */
N#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
N#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
N
N/** 
N  * @brief   AF 6 selection  
N  */ 
N#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
N#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
N
N/** 
N  * @brief   AF 7 selection  
N  */ 
N#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
N#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
N#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
N
N/** 
N  * @brief   AF 8 selection  
N  */ 
N#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
N
N/** 
N  * @brief   AF 9 selection 
N  */ 
N#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping  */
N#define GPIO_AF9_I2C3          ((uint8_t)0x09)  /* I2C3 Alternate Function mapping  */
N
N
N/** 
N  * @brief   AF 10 selection  
N  */ 
N#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
N
N/** 
N  * @brief   AF 12 selection  
N  */ 
N#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping  */
N
N/** 
N  * @brief   AF 15 selection  
N  */ 
N#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F401xC || STM32F401xE */
N/*----------------------------------------------------------------------------*/
N
N/*--------------- STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx-------------*/
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)   
X#if 0L || 0L || 0L || 0L   
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping    */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping    */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping    */
S#define GPIO_AF4_FMPI2C1       ((uint8_t)0x04)  /* FMPI2C1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4/I2S4 Alternate Function mapping   */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* I2S2 Alternate Function mapping       */
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_SPI4          ((uint8_t)0x06)  /* SPI4/I2S4 Alternate Function mapping  */
S#define GPIO_AF6_SPI5          ((uint8_t)0x06)  /* SPI5/I2S5 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_DFSDM1        ((uint8_t)0x06)  /* DFSDM1 Alternate Function mapping     */
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_USART3        ((uint8_t)0x08)  /* USART3 Alternate Function mapping */
S#define GPIO_AF8_DFSDM1        ((uint8_t)0x08)  /* DFSDM1 Alternate Function mapping */
S#define GPIO_AF8_CAN1          ((uint8_t)0x08)  /* CAN1 Alternate Function mapping   */
S
S/** 
S  * @brief   AF 9 selection 
S  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping   */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping   */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping   */
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping    */
S#define GPIO_AF9_I2C3          ((uint8_t)0x09)  /* I2C3 Alternate Function mapping    */
S#define GPIO_AF9_FMPI2C1       ((uint8_t)0x09)  /* FMPI2C1 Alternate Function mapping */
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */  
S#define GPIO_AF9_QSPI          ((uint8_t)0x09)  /* QSPI Alternate Function mapping    */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_DFSDM1        ((uint8_t)0x0A)  /* DFSDM1 Alternate Function mapping */
S#define GPIO_AF10_QSPI          ((uint8_t)0x0A)  /* QSPI Alternate Function mapping   */
S#define GPIO_AF10_FMC           ((uint8_t)0x0A)  /* FMC Alternate Function mapping    */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping  */
S#define GPIO_AF12_FSMC          ((uint8_t)0x0C)  /* FMC Alternate Function mapping   */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N/*----------------------------------------------------------------------------*/
N
N/*--------------- STM32F413xx/STM32F423xx-------------------------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)   
X#if 0L || 0L   
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S#define GPIO_AF1_LPTIM1        ((uint8_t)0x01)  /* LPTIM1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S#define GPIO_AF3_DFSDM2        ((uint8_t)0x03)  /* DFSDM2 Alternate Function mapping */   
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping    */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping    */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping    */
S#define GPIO_AF4_FMPI2C1       ((uint8_t)0x04)  /* FMPI2C1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4/I2S4 Alternate Function mapping   */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* I2S2 Alternate Function mapping       */
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_SPI4          ((uint8_t)0x06)  /* SPI4/I2S4 Alternate Function mapping  */
S#define GPIO_AF6_SPI5          ((uint8_t)0x06)  /* SPI5/I2S5 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_DFSDM1        ((uint8_t)0x06)  /* DFSDM1 Alternate Function mapping     */
S#define GPIO_AF6_DFSDM2        ((uint8_t)0x06)  /* DFSDM2 Alternate Function mapping     */   
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF7_SAI1          ((uint8_t)0x07)  /* SAI1 Alternate Function mapping       */
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S#define GPIO_AF7_DFSDM2        ((uint8_t)0x07)  /* DFSDM2 Alternate Function mapping     */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_USART3        ((uint8_t)0x08)  /* USART3 Alternate Function mapping */
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_UART7         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S#define GPIO_AF8_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S#define GPIO_AF8_DFSDM1        ((uint8_t)0x08)  /* DFSDM1 Alternate Function mapping */
S#define GPIO_AF8_CAN1          ((uint8_t)0x08)  /* CAN1 Alternate Function mapping   */
S
S/** 
S  * @brief   AF 9 selection 
S  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping   */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping   */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping   */
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping    */
S#define GPIO_AF9_I2C3          ((uint8_t)0x09)  /* I2C3 Alternate Function mapping    */
S#define GPIO_AF9_FMPI2C1       ((uint8_t)0x09)  /* FMPI2C1 Alternate Function mapping */
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_QSPI          ((uint8_t)0x09)  /* QSPI Alternate Function mapping    */
S
S/** 
S  * @brief   AF 10 selection  
S  */
S#define GPIO_AF10_SAI1          ((uint8_t)0x0A)  /* SAI1 Alternate Function mapping   */
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_DFSDM1        ((uint8_t)0x0A)  /* DFSDM1 Alternate Function mapping */
S#define GPIO_AF10_DFSDM2        ((uint8_t)0x0A)  /* DFSDM2 Alternate Function mapping */
S#define GPIO_AF10_QSPI          ((uint8_t)0x0A)  /* QSPI Alternate Function mapping   */
S#define GPIO_AF10_FSMC          ((uint8_t)0x0A)  /* FSMC Alternate Function mapping   */
S
S/** 
S  * @brief   AF 11 selection  
S  */
S#define GPIO_AF11_UART4         ((uint8_t)0x0B)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF11_UART5         ((uint8_t)0x0B)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF11_UART9         ((uint8_t)0x0B)  /* UART9 Alternate Function mapping  */
S#define GPIO_AF11_UART10        ((uint8_t)0x0B)  /* UART10 Alternate Function mapping */
S#define GPIO_AF11_CAN3          ((uint8_t)0x0B)  /* CAN3 Alternate Function mapping   */
S   
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping  */
S#define GPIO_AF12_FSMC          ((uint8_t)0x0C)  /* FMC Alternate Function mapping   */
S
S/** 
S  * @brief   AF 14 selection  
S  */ 
S#define GPIO_AF14_RNG           ((uint8_t)0x0E)  /* RNG Alternate Function mapping  */
S   
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F413xx || STM32F423xx */
N
N/*---------------------------------------- STM32F411xx------------------------*/
N#if defined(STM32F411xE) 
X#if 0L 
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* I2S2 Alternate Function mapping       */
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_SPI4          ((uint8_t)0x06)  /* SPI4/I2S4 Alternate Function mapping  */
S#define GPIO_AF6_SPI5          ((uint8_t)0x06)  /* SPI5/I2S5 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping  */
S#define GPIO_AF9_I2C3          ((uint8_t)0x09)  /* I2C3 Alternate Function mapping  */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping  */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F411xE */
N
N/*---------------------------------------- STM32F410xx------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_LPTIM1        ((uint8_t)0x01)  /* LPTIM1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_FMPI2C1       ((uint8_t)0x04)  /* FMPI2C1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#if defined(STM32F410Cx) || defined(STM32F410Rx)  
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#endif /* STM32F410Cx || STM32F410Rx */   
S
S/** 
S  * @brief   AF 6 selection  
S  */
S#define GPIO_AF6_SPI1          ((uint8_t)0x06)  /* SPI1 Alternate Function mapping  */
S#if defined(STM32F410Cx) || defined(STM32F410Rx)   
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* I2S2 Alternate Function mapping       */
S#endif /* STM32F410Cx || STM32F410Rx */   
S#define GPIO_AF6_SPI5          ((uint8_t)0x06)  /* SPI5/I2S5 Alternate Function mapping  */
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_I2C2          ((uint8_t)0x09)  /* I2C2 Alternate Function mapping  */
S#define GPIO_AF9_FMPI2C1       ((uint8_t)0x09)  /* FMPI2C1 Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/*---------------------------------------- STM32F446xx -----------------------*/
N#if defined(STM32F446xx)
X#if 0L
S/**
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S#define GPIO_AF3_CEC           ((uint8_t)0x03)  /* CEC Alternate Function mapping   */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S#define GPIO_AF4_FMPI2C1       ((uint8_t)0x04)  /* FMPI2C1 Alternate Function mapping */
S#define GPIO_AF4_CEC           ((uint8_t)0x04)  /* CEC Alternate Function mapping  */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping   */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI2          ((uint8_t)0x06)  /* SPI2/I2S2 Alternate Function mapping  */
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_SPI4          ((uint8_t)0x06)  /* SPI4 Alternate Function mapping       */
S#define GPIO_AF6_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping       */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_UART5         ((uint8_t)0x07)  /* UART5 Alternate Function mapping      */
S#define GPIO_AF7_SPI2          ((uint8_t)0x07)  /* SPI2/I2S2 Alternate Function mapping  */
S#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF7_SPDIFRX       ((uint8_t)0x07)  /* SPDIFRX Alternate Function mapping      */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_SPDIFRX       ((uint8_t)0x08)  /* SPDIFRX Alternate Function mapping  */
S#define GPIO_AF8_SAI2          ((uint8_t)0x08)  /* SAI2 Alternate Function mapping   */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
S#define GPIO_AF9_QSPI          ((uint8_t)0x09)  /* QSPI Alternate Function mapping  */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S#define GPIO_AF10_SAI2          ((uint8_t)0x0A)  /* SAI2 Alternate Function mapping   */
S#define GPIO_AF10_QSPI          ((uint8_t)0x0A)  /* QSPI Alternate Function mapping  */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FMC           ((uint8_t)0x0C)  /* FMC Alternate Function mapping                      */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
S
N#endif /* STM32F446xx */
N/*----------------------------------------------------------------------------*/
N
N/*-------------------------------- STM32F469xx/STM32F479xx--------------------*/
N#if defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L
S/** 
S  * @brief   AF 0 selection  
S  */ 
S#define GPIO_AF0_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping                       */
S#define GPIO_AF0_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping            */
S#define GPIO_AF0_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
S#define GPIO_AF0_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping             */
S#define GPIO_AF0_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping                          */
S
S/** 
S  * @brief   AF 1 selection  
S  */ 
S#define GPIO_AF1_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
S#define GPIO_AF1_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
S
S/** 
S  * @brief   AF 2 selection  
S  */ 
S#define GPIO_AF2_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
S#define GPIO_AF2_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
S#define GPIO_AF2_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
S
S/** 
S  * @brief   AF 3 selection  
S  */ 
S#define GPIO_AF3_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping  */
S#define GPIO_AF3_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping  */
S#define GPIO_AF3_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
S#define GPIO_AF3_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
S
S/** 
S  * @brief   AF 4 selection  
S  */ 
S#define GPIO_AF4_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
S#define GPIO_AF4_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
S#define GPIO_AF4_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
S
S/** 
S  * @brief   AF 5 selection  
S  */ 
S#define GPIO_AF5_SPI1          ((uint8_t)0x05)  /* SPI1 Alternate Function mapping        */
S#define GPIO_AF5_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping   */
S#define GPIO_AF5_SPI3          ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping   */
S#define GPIO_AF5_SPI4          ((uint8_t)0x05)  /* SPI4 Alternate Function mapping        */
S#define GPIO_AF5_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping        */
S#define GPIO_AF5_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping        */
S#define GPIO_AF5_I2S3ext       ((uint8_t)0x05)  /* I2S3ext_SD Alternate Function mapping  */
S
S/** 
S  * @brief   AF 6 selection  
S  */ 
S#define GPIO_AF6_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping  */
S#define GPIO_AF6_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping */
S#define GPIO_AF6_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping       */
S
S/** 
S  * @brief   AF 7 selection  
S  */ 
S#define GPIO_AF7_USART1        ((uint8_t)0x07)  /* USART1 Alternate Function mapping     */
S#define GPIO_AF7_USART2        ((uint8_t)0x07)  /* USART2 Alternate Function mapping     */
S#define GPIO_AF7_USART3        ((uint8_t)0x07)  /* USART3 Alternate Function mapping     */
S#define GPIO_AF7_I2S3ext       ((uint8_t)0x07)  /* I2S3ext_SD Alternate Function mapping */
S
S/** 
S  * @brief   AF 8 selection  
S  */ 
S#define GPIO_AF8_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF8_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF8_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
S#define GPIO_AF8_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
S#define GPIO_AF8_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
S
S/** 
S  * @brief   AF 9 selection 
S  */ 
S#define GPIO_AF9_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping    */
S#define GPIO_AF9_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping    */
S#define GPIO_AF9_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping   */
S#define GPIO_AF9_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping   */
S#define GPIO_AF9_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping   */
S#define GPIO_AF9_LTDC          ((uint8_t)0x09)  /* LCD-TFT Alternate Function mapping */
S#define GPIO_AF9_QSPI          ((uint8_t)0x09)  /* QSPI Alternate Function mapping    */
S
S/** 
S  * @brief   AF 10 selection  
S  */ 
S#define GPIO_AF10_OTG_FS        ((uint8_t)0x0A)  /* OTG_FS Alternate Function mapping */
S#define GPIO_AF10_OTG_HS        ((uint8_t)0x0A)  /* OTG_HS Alternate Function mapping */
S#define GPIO_AF10_QSPI          ((uint8_t)0x0A)  /* QSPI Alternate Function mapping   */
S
S/** 
S  * @brief   AF 11 selection  
S  */ 
S#define GPIO_AF11_ETH           ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
S
S/** 
S  * @brief   AF 12 selection  
S  */ 
S#define GPIO_AF12_FMC           ((uint8_t)0x0C)  /* FMC Alternate Function mapping                      */
S#define GPIO_AF12_OTG_HS_FS     ((uint8_t)0x0C)  /* OTG HS configured in FS, Alternate Function mapping */
S#define GPIO_AF12_SDIO          ((uint8_t)0x0C)  /* SDIO Alternate Function mapping                     */
S
S/** 
S  * @brief   AF 13 selection  
S  */ 
S#define GPIO_AF13_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
S#define GPIO_AF13_DSI           ((uint8_t)0x0D)  /* DSI Alternate Function mapping  */
S
S/** 
S  * @brief   AF 14 selection  
S  */
S#define GPIO_AF14_LTDC          ((uint8_t)0x0E)  /* LCD-TFT Alternate Function mapping */
S
S/** 
S  * @brief   AF 15 selection  
S  */ 
S#define GPIO_AF15_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
S
N#endif /* STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Macros GPIO Exported Macros
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Functions GPIO Exported Functions
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Constants GPIO Private Constants
N  * @{
N  */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Macros GPIO Private Macros
N  * @{
N  */
N/** @defgroup GPIOEx_Get_Port_Index GPIO Get Port Index
N  * @{
N  */
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
X#if 0L || 0L || 0L || 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U :\
S                                               ((__GPIOx__) == (GPIOE))? 4U :\
S                                               ((__GPIOx__) == (GPIOF))? 5U :\
S                                               ((__GPIOx__) == (GPIOG))? 6U :\
S                                               ((__GPIOx__) == (GPIOH))? 7U : 8U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U :                                               ((__GPIOx__) == (GPIOF))? 5U :                                               ((__GPIOx__) == (GPIOG))? 6U :                                               ((__GPIOx__) == (GPIOH))? 7U : 8U)
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U :\
S                                               ((__GPIOx__) == (GPIOE))? 4U :\
S                                               ((__GPIOx__) == (GPIOF))? 5U :\
S                                               ((__GPIOx__) == (GPIOG))? 6U :\
S                                               ((__GPIOx__) == (GPIOH))? 7U :\
S                                               ((__GPIOx__) == (GPIOI))? 8U :\
S                                               ((__GPIOx__) == (GPIOJ))? 9U : 10U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U :                                               ((__GPIOx__) == (GPIOF))? 5U :                                               ((__GPIOx__) == (GPIOG))? 6U :                                               ((__GPIOx__) == (GPIOH))? 7U :                                               ((__GPIOx__) == (GPIOI))? 8U :                                               ((__GPIOx__) == (GPIOJ))? 9U : 10U)
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) 
X#if 0L || 0L || 0L 
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U : 7U)
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) 
X#if 0L || 1L || 0L 
N#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
N                                               ((__GPIOx__) == (GPIOB))? 1U :\
N                                               ((__GPIOx__) == (GPIOC))? 2U :\
N                                               ((__GPIOx__) == (GPIOD))? 3U :\
N                                               ((__GPIOx__) == (GPIOE))? 4U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U : 7U)
N#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
N
N#if defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F413xx) || defined(STM32F423xx) 
X#if 0L || 0L || 0L || 0L 
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U :\
S                                               ((__GPIOx__) == (GPIOE))? 4U :\
S                                               ((__GPIOx__) == (GPIOF))? 5U :\
S                                               ((__GPIOx__) == (GPIOG))? 6U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U :                                               ((__GPIOx__) == (GPIOF))? 5U :                                               ((__GPIOx__) == (GPIOG))? 6U : 7U)
N#endif /* STM32F446xx || STM32F412Zx  || STM32F413xx || STM32F423xx */
N#if defined(STM32F412Vx)
X#if 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U :\
S                                               ((__GPIOx__) == (GPIOE))? 4U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U :                                               ((__GPIOx__) == (GPIOE))? 4U : 7U)
N#endif /* STM32F412Vx */
N#if defined(STM32F412Rx)
X#if 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U :\
S                                               ((__GPIOx__) == (GPIOD))? 3U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U :                                               ((__GPIOx__) == (GPIOD))? 3U : 7U)
N#endif /* STM32F412Rx */
N#if defined(STM32F412Cx)
X#if 0L
S#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :\
S                                               ((__GPIOx__) == (GPIOB))? 1U :\
S                                               ((__GPIOx__) == (GPIOC))? 2U : 7U)
X#define GPIO_GET_INDEX(__GPIOx__)    (uint8_t)(((__GPIOx__) == (GPIOA))? 0U :                                               ((__GPIOx__) == (GPIOB))? 1U :                                               ((__GPIOx__) == (GPIOC))? 2U : 7U)
N#endif /* STM32F412Cx */
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIOEx_IS_Alternat_function_selection GPIO Check Alternate Function
N  * @{
N  */  
N/*------------------------- STM32F429xx/STM32F439xx---------------------------*/
N#if defined(STM32F429xx) || defined(STM32F439xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
S                          ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1)      || \
S                          ((AF) == GPIO_AF14_LTDC))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1)      ||                           ((AF) == GPIO_AF14_LTDC))
S
N#endif /* STM32F429xx || STM32F439xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F427xx/STM32F437xx------------------*/
N#if defined(STM32F427xx) || defined(STM32F437xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
S                          ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1))
S
N#endif /* STM32F427xx || STM32F437xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F407xx/STM32F417xx------------------*/
N#if defined(STM32F407xx) || defined(STM32F417xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF12_FSMC)      || ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF12_FSMC)      || ((AF) == GPIO_AF15_EVENTOUT))
S
N#endif /* STM32F407xx || STM32F417xx */
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F405xx/STM32F415xx------------------*/
N#if defined(STM32F405xx) || defined(STM32F415xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDIO)      || \
S                          ((AF) == GPIO_AF12_FSMC)      || ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDIO)      ||                           ((AF) == GPIO_AF12_FSMC)      || ((AF) == GPIO_AF15_EVENTOUT))
S
N#endif /* STM32F405xx || STM32F415xx */
N
N/*----------------------------------------------------------------------------*/
N
N/*---------------------------------------- STM32F401xx------------------------*/
N#if defined(STM32F401xC) || defined(STM32F401xE) 
X#if 0L || 1L 
N#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF12_SDIO)      || \
N                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
N                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
N                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
N                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
N                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF4_I2C1)       || \
N                          ((AF) == GPIO_AF4_I2C2)       || ((AF) == GPIO_AF4_I2C3)       || \
N                          ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       || \
N                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF5_SPI4)       || \
N                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
N                          ((AF) == GPIO_AF8_USART6)     || ((AF) == GPIO_AF10_OTG_FS)    || \
N                          ((AF) == GPIO_AF9_I2C2)       || ((AF) == GPIO_AF9_I2C3)       || \
N                          ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF12_SDIO)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF4_I2C1)       ||                           ((AF) == GPIO_AF4_I2C2)       || ((AF) == GPIO_AF4_I2C3)       ||                           ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF8_USART6)     || ((AF) == GPIO_AF10_OTG_FS)    ||                           ((AF) == GPIO_AF9_I2C2)       || ((AF) == GPIO_AF9_I2C3)       ||                           ((AF) == GPIO_AF15_EVENTOUT))
N
N#endif /* STM32F401xC || STM32F401xE */
N/*----------------------------------------------------------------------------*/
N/*---------------------------------------- STM32F410xx------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) 
X#if 0L || 0L || 0L 
S#define IS_GPIO_AF(AF)   (((AF) < 10U) || ((AF) == 15U))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/*---------------------------------------- STM32F411xx------------------------*/
N#if defined(STM32F411xE) 
X#if 0L 
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF4_I2C1)       || \
S                          ((AF) == GPIO_AF4_I2C2)       || ((AF) == GPIO_AF4_I2C3)       || \
S                          ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       || \
S                          ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF6_SPI4)       || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF6_SPI5)       || ((AF) == GPIO_AF7_SPI3)       || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF8_USART6)     || ((AF) == GPIO_AF10_OTG_FS)    || \
S                          ((AF) == GPIO_AF9_I2C2)       || ((AF) == GPIO_AF9_I2C3)       || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF15_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF4_I2C1)       ||                           ((AF) == GPIO_AF4_I2C2)       || ((AF) == GPIO_AF4_I2C3)       ||                           ((AF) == GPIO_AF5_SPI1)       || ((AF) == GPIO_AF5_SPI2)       ||                           ((AF) == GPIO_AF5_SPI3)       || ((AF) == GPIO_AF6_SPI4)       ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF6_SPI5)       || ((AF) == GPIO_AF7_SPI3)       ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF8_USART6)     || ((AF) == GPIO_AF10_OTG_FS)    ||                           ((AF) == GPIO_AF9_I2C2)       || ((AF) == GPIO_AF9_I2C3)       ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF15_EVENTOUT))
S
N#endif /* STM32F411xE */
N/*----------------------------------------------------------------------------*/
N
N/*----------------------------------------------- STM32F446xx ----------------*/
N#if defined(STM32F446xx) 
X#if 0L 
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1)      || \
S                          ((AF) == GPIO_AF3_CEC)        ||  ((AF) == GPIO_AF4_CEC)       || \
S                          ((AF) == GPIO_AF5_SPI3)       ||  ((AF) == GPIO_AF6_SPI2)      || \
S                          ((AF) == GPIO_AF6_SPI4)       ||  ((AF) == GPIO_AF7_UART5)     || \
S                          ((AF) == GPIO_AF7_SPI2)       ||  ((AF) == GPIO_AF7_SPI3)      || \
S                          ((AF) == GPIO_AF7_SPDIFRX)    ||  ((AF) == GPIO_AF8_SPDIFRX)   || \
S                          ((AF) == GPIO_AF8_SAI2)       ||  ((AF) == GPIO_AF9_QSPI)      || \
S                          ((AF) == GPIO_AF10_SAI2)      ||  ((AF) == GPIO_AF10_QSPI))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF12_FMC)       ||  ((AF) == GPIO_AF6_SAI1)      ||                           ((AF) == GPIO_AF3_CEC)        ||  ((AF) == GPIO_AF4_CEC)       ||                           ((AF) == GPIO_AF5_SPI3)       ||  ((AF) == GPIO_AF6_SPI2)      ||                           ((AF) == GPIO_AF6_SPI4)       ||  ((AF) == GPIO_AF7_UART5)     ||                           ((AF) == GPIO_AF7_SPI2)       ||  ((AF) == GPIO_AF7_SPI3)      ||                           ((AF) == GPIO_AF7_SPDIFRX)    ||  ((AF) == GPIO_AF8_SPDIFRX)   ||                           ((AF) == GPIO_AF8_SAI2)       ||  ((AF) == GPIO_AF9_QSPI)      ||                           ((AF) == GPIO_AF10_SAI2)      ||  ((AF) == GPIO_AF10_QSPI))
S
N#endif /* STM32F446xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------------------------------- STM32F469xx/STM32F479xx --------*/
N#if defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L 
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      || \
S                          ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     || \
S                          ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      || \
S                          ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       || \
S                          ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       || \
S                          ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       || \
S                          ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       || \
S                          ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       || \
S                          ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      || \
S                          ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      || \
S                          ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     || \
S                          ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      || \
S                          ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     || \
S                          ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       || \
S                          ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    || \
S                          ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      || \
S                          ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       || \
S                          ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       || \
S                          ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      || \
S                          ((AF) == GPIO_AF12_FMC)       || ((AF) == GPIO_AF6_SAI1)       || \
S                          ((AF) == GPIO_AF14_LTDC)      || ((AF) == GPIO_AF13_DSI)      || \
S                          ((AF) == GPIO_AF9_QSPI)       || ((AF) == GPIO_AF10_QSPI))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF0_RTC_50Hz)   || ((AF) == GPIO_AF9_TIM14)      ||                           ((AF) == GPIO_AF0_MCO)        || ((AF) == GPIO_AF0_TAMPER)     ||                           ((AF) == GPIO_AF0_SWJ)        || ((AF) == GPIO_AF0_TRACE)      ||                           ((AF) == GPIO_AF1_TIM1)       || ((AF) == GPIO_AF1_TIM2)       ||                           ((AF) == GPIO_AF2_TIM3)       || ((AF) == GPIO_AF2_TIM4)       ||                           ((AF) == GPIO_AF2_TIM5)       || ((AF) == GPIO_AF3_TIM8)       ||                           ((AF) == GPIO_AF4_I2C1)       || ((AF) == GPIO_AF4_I2C2)       ||                           ((AF) == GPIO_AF4_I2C3)       || ((AF) == GPIO_AF5_SPI1)       ||                           ((AF) == GPIO_AF5_SPI2)       || ((AF) == GPIO_AF9_TIM13)      ||                           ((AF) == GPIO_AF6_SPI3)       || ((AF) == GPIO_AF9_TIM12)      ||                           ((AF) == GPIO_AF7_USART1)     || ((AF) == GPIO_AF7_USART2)     ||                           ((AF) == GPIO_AF7_USART3)     || ((AF) == GPIO_AF8_UART4)      ||                           ((AF) == GPIO_AF8_UART5)      || ((AF) == GPIO_AF8_USART6)     ||                           ((AF) == GPIO_AF9_CAN1)       || ((AF) == GPIO_AF9_CAN2)       ||                           ((AF) == GPIO_AF10_OTG_FS)    || ((AF) == GPIO_AF10_OTG_HS)    ||                           ((AF) == GPIO_AF11_ETH)       || ((AF) == GPIO_AF12_OTG_HS_FS) ||                           ((AF) == GPIO_AF12_SDIO)      || ((AF) == GPIO_AF13_DCMI)      ||                           ((AF) == GPIO_AF15_EVENTOUT)  || ((AF) == GPIO_AF5_SPI4)       ||                           ((AF) == GPIO_AF5_SPI5)       || ((AF) == GPIO_AF5_SPI6)       ||                           ((AF) == GPIO_AF8_UART7)      || ((AF) == GPIO_AF8_UART8)      ||                           ((AF) == GPIO_AF12_FMC)       || ((AF) == GPIO_AF6_SAI1)       ||                           ((AF) == GPIO_AF14_LTDC)      || ((AF) == GPIO_AF13_DSI)      ||                           ((AF) == GPIO_AF9_QSPI)       || ((AF) == GPIO_AF10_QSPI))
S
N#endif /* STM32F469xx || STM32F479xx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx-----------*/
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L  
S#define IS_GPIO_AF(AF)   (((AF) < 16U) && ((AF) != 11U) && ((AF) != 14U) && ((AF) != 13U))
N#endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*----------------------------------------------------------------------------*/
N
N/*------------------STM32F413xx/STM32F423xx-----------------------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)  
X#if 0L || 0L  
S#define IS_GPIO_AF(AF)   (((AF) < 16U) && ((AF) != 13U))
N#endif /* STM32F413xx || STM32F423xx */
N/*----------------------------------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup GPIOEx_Private_Functions GPIO Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_GPIO_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 215 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_gpio.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup GPIO_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup GPIO_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
Nvoid  HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init);
Nvoid  HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin);
N/**
N  * @}
N  */
N
N/** @addtogroup GPIO_Exported_Functions_Group2
N  * @{
N  */
N/* IO operation functions *****************************************************/
NGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
Nvoid HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
NHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin);
Nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup GPIO_Private_Constants GPIO Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup GPIO_Private_Macros GPIO Private Macros
N  * @{
N  */
N#define IS_GPIO_PIN_ACTION(ACTION) (((ACTION) == GPIO_PIN_RESET) || ((ACTION) == GPIO_PIN_SET))
N#define IS_GPIO_PIN(PIN)           ((((PIN) & GPIO_PIN_MASK ) != 0x00U) && (((PIN) & ~GPIO_PIN_MASK) == 0x00U))
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_MODE_INPUT)              ||\
N                            ((MODE) == GPIO_MODE_OUTPUT_PP)          ||\
N                            ((MODE) == GPIO_MODE_OUTPUT_OD)          ||\
N                            ((MODE) == GPIO_MODE_AF_PP)              ||\
N                            ((MODE) == GPIO_MODE_AF_OD)              ||\
N                            ((MODE) == GPIO_MODE_IT_RISING)          ||\
N                            ((MODE) == GPIO_MODE_IT_FALLING)         ||\
N                            ((MODE) == GPIO_MODE_IT_RISING_FALLING)  ||\
N                            ((MODE) == GPIO_MODE_EVT_RISING)         ||\
N                            ((MODE) == GPIO_MODE_EVT_FALLING)        ||\
N                            ((MODE) == GPIO_MODE_EVT_RISING_FALLING) ||\
N                            ((MODE) == GPIO_MODE_ANALOG))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_MODE_INPUT)              ||                            ((MODE) == GPIO_MODE_OUTPUT_PP)          ||                            ((MODE) == GPIO_MODE_OUTPUT_OD)          ||                            ((MODE) == GPIO_MODE_AF_PP)              ||                            ((MODE) == GPIO_MODE_AF_OD)              ||                            ((MODE) == GPIO_MODE_IT_RISING)          ||                            ((MODE) == GPIO_MODE_IT_FALLING)         ||                            ((MODE) == GPIO_MODE_IT_RISING_FALLING)  ||                            ((MODE) == GPIO_MODE_EVT_RISING)         ||                            ((MODE) == GPIO_MODE_EVT_FALLING)        ||                            ((MODE) == GPIO_MODE_EVT_RISING_FALLING) ||                            ((MODE) == GPIO_MODE_ANALOG))
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_SPEED_FREQ_LOW)  || ((SPEED) == GPIO_SPEED_FREQ_MEDIUM) || \
N                              ((SPEED) == GPIO_SPEED_FREQ_HIGH) || ((SPEED) == GPIO_SPEED_FREQ_VERY_HIGH))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_SPEED_FREQ_LOW)  || ((SPEED) == GPIO_SPEED_FREQ_MEDIUM) ||                               ((SPEED) == GPIO_SPEED_FREQ_HIGH) || ((SPEED) == GPIO_SPEED_FREQ_VERY_HIGH))
N#define IS_GPIO_PULL(PULL) (((PULL) == GPIO_NOPULL) || ((PULL) == GPIO_PULLUP) || \
N                            ((PULL) == GPIO_PULLDOWN))
X#define IS_GPIO_PULL(PULL) (((PULL) == GPIO_NOPULL) || ((PULL) == GPIO_PULLUP) ||                             ((PULL) == GPIO_PULLDOWN))
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup GPIO_Private_Functions GPIO Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_GPIO_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 203 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_GPIO_MODULE_ENABLED */
N
N#ifdef HAL_DMA_MODULE_ENABLED
N#include "stm32f4xx_hal_dma.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_dma.h
N  * @author  MCD Application Team
N  * @brief   Header file of DMA HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_DMA_H
N#define __STM32F4xx_HAL_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Types DMA Exported Types
N  * @brief    DMA Exported Types 
N  * @{
N  */
N   
N/** 
N  * @brief  DMA Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Channel;              /*!< Specifies the channel used for the specified stream. 
N                                      This parameter can be a value of @ref DMA_Channel_selection                    */
N
N  uint32_t Direction;            /*!< Specifies if the data will be transferred from memory to peripheral, 
N                                      from memory to memory or from peripheral to memory.
N                                      This parameter can be a value of @ref DMA_Data_transfer_direction              */
N
N  uint32_t PeriphInc;            /*!< Specifies whether the Peripheral address register should be incremented or not.
N                                      This parameter can be a value of @ref DMA_Peripheral_incremented_mode          */
N
N  uint32_t MemInc;               /*!< Specifies whether the memory address register should be incremented or not.
N                                      This parameter can be a value of @ref DMA_Memory_incremented_mode              */
N
N  uint32_t PeriphDataAlignment;  /*!< Specifies the Peripheral data width.
N                                      This parameter can be a value of @ref DMA_Peripheral_data_size                 */
N
N  uint32_t MemDataAlignment;     /*!< Specifies the Memory data width.
N                                      This parameter can be a value of @ref DMA_Memory_data_size                     */
N
N  uint32_t Mode;                 /*!< Specifies the operation mode of the DMAy Streamx.
N                                      This parameter can be a value of @ref DMA_mode
N                                      @note The circular buffer mode cannot be used if the memory-to-memory
N                                            data transfer is configured on the selected Stream                        */
N
N  uint32_t Priority;             /*!< Specifies the software priority for the DMAy Streamx.
N                                      This parameter can be a value of @ref DMA_Priority_level                       */
N
N  uint32_t FIFOMode;             /*!< Specifies if the FIFO mode or Direct mode will be used for the specified stream.
N                                      This parameter can be a value of @ref DMA_FIFO_direct_mode
N                                      @note The Direct mode (FIFO mode disabled) cannot be used if the 
N                                            memory-to-memory data transfer is configured on the selected stream       */
N
N  uint32_t FIFOThreshold;        /*!< Specifies the FIFO threshold level.
N                                      This parameter can be a value of @ref DMA_FIFO_threshold_level                  */
N
N  uint32_t MemBurst;             /*!< Specifies the Burst transfer configuration for the memory transfers. 
N                                      It specifies the amount of data to be transferred in a single non interruptible
N                                      transaction.
N                                      This parameter can be a value of @ref DMA_Memory_burst 
N                                      @note The burst mode is possible only if the address Increment mode is enabled. */
N
N  uint32_t PeriphBurst;          /*!< Specifies the Burst transfer configuration for the peripheral transfers. 
N                                      It specifies the amount of data to be transferred in a single non interruptible 
N                                      transaction. 
N                                      This parameter can be a value of @ref DMA_Peripheral_burst
N                                      @note The burst mode is possible only if the address Increment mode is enabled. */
N}DMA_InitTypeDef;
N
N
N/** 
N  * @brief  HAL DMA State structures definition
N  */
Ntypedef enum
N{
N  HAL_DMA_STATE_RESET             = 0x00U,  /*!< DMA not yet initialized or disabled */
N  HAL_DMA_STATE_READY             = 0x01U,  /*!< DMA initialized and ready for use   */
N  HAL_DMA_STATE_BUSY              = 0x02U,  /*!< DMA process is ongoing              */
N  HAL_DMA_STATE_TIMEOUT           = 0x03U,  /*!< DMA timeout state                   */
N  HAL_DMA_STATE_ERROR             = 0x04U,  /*!< DMA error state                     */
N  HAL_DMA_STATE_ABORT             = 0x05U,  /*!< DMA Abort state                     */
N}HAL_DMA_StateTypeDef;
N
N/** 
N  * @brief  HAL DMA Error Code structure definition
N  */
Ntypedef enum
N{
N  HAL_DMA_FULL_TRANSFER           = 0x00U,  /*!< Full transfer     */
N  HAL_DMA_HALF_TRANSFER           = 0x01U   /*!< Half Transfer     */
N}HAL_DMA_LevelCompleteTypeDef;
N
N/** 
N  * @brief  HAL DMA Error Code structure definition
N  */
Ntypedef enum
N{
N  HAL_DMA_XFER_CPLT_CB_ID         = 0x00U,  /*!< Full transfer     */
N  HAL_DMA_XFER_HALFCPLT_CB_ID     = 0x01U,  /*!< Half Transfer     */
N  HAL_DMA_XFER_M1CPLT_CB_ID       = 0x02U,  /*!< M1 Full Transfer  */
N  HAL_DMA_XFER_M1HALFCPLT_CB_ID   = 0x03U,  /*!< M1 Half Transfer  */
N  HAL_DMA_XFER_ERROR_CB_ID        = 0x04U,  /*!< Error             */
N  HAL_DMA_XFER_ABORT_CB_ID        = 0x05U,  /*!< Abort             */
N  HAL_DMA_XFER_ALL_CB_ID          = 0x06U   /*!< All               */
N}HAL_DMA_CallbackIDTypeDef;
N
N/** 
N  * @brief  DMA handle Structure definition
N  */
Ntypedef struct __DMA_HandleTypeDef
N{
N  DMA_Stream_TypeDef         *Instance;                                                        /*!< Register base address                  */
N
N  DMA_InitTypeDef            Init;                                                             /*!< DMA communication parameters           */ 
N
N  HAL_LockTypeDef            Lock;                                                             /*!< DMA locking object                     */  
N
N  __IO HAL_DMA_StateTypeDef  State;                                                            /*!< DMA transfer state                     */
X  volatile HAL_DMA_StateTypeDef  State;                                                             
N
N  void                       *Parent;                                                          /*!< Parent object state                    */ 
N
N  void                       (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma);         /*!< DMA transfer complete callback         */
N
N  void                       (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);     /*!< DMA Half transfer complete callback    */
N
N  void                       (* XferM1CpltCallback)( struct __DMA_HandleTypeDef * hdma);       /*!< DMA transfer complete Memory1 callback */
N  
N  void                       (* XferM1HalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);   /*!< DMA transfer Half complete Memory1 callback */
N  
N  void                       (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma);        /*!< DMA transfer error callback            */
N  
N  void                       (* XferAbortCallback)( struct __DMA_HandleTypeDef * hdma);        /*!< DMA transfer Abort callback            */  
N
N  __IO uint32_t              ErrorCode;                                                        /*!< DMA Error code                          */
X  volatile uint32_t              ErrorCode;                                                         
N  
N  uint32_t                   StreamBaseAddress;                                                /*!< DMA Stream Base Address                */
N
N  uint32_t                   StreamIndex;                                                      /*!< DMA Stream Index                       */
N 
N}DMA_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants DMA Exported Constants
N  * @brief    DMA Exported constants 
N  * @{
N  */
N
N/** @defgroup DMA_Error_Code DMA Error Code
N  * @brief    DMA Error Code 
N  * @{
N  */ 
N#define HAL_DMA_ERROR_NONE            0x00000000U    /*!< No error                               */
N#define HAL_DMA_ERROR_TE              0x00000001U    /*!< Transfer error                         */
N#define HAL_DMA_ERROR_FE              0x00000002U    /*!< FIFO error                             */
N#define HAL_DMA_ERROR_DME             0x00000004U    /*!< Direct Mode error                      */
N#define HAL_DMA_ERROR_TIMEOUT         0x00000020U    /*!< Timeout error                          */
N#define HAL_DMA_ERROR_PARAM           0x00000040U    /*!< Parameter error                        */
N#define HAL_DMA_ERROR_NO_XFER         0x00000080U    /*!< Abort requested with no Xfer ongoing   */
N#define HAL_DMA_ERROR_NOT_SUPPORTED   0x00000100U    /*!< Not supported mode                     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Channel_selection DMA Channel selection
N  * @brief    DMA channel selection 
N  * @{
N  */ 
N#define DMA_CHANNEL_0                 0x00000000U    /*!< DMA Channel 0 */
N#define DMA_CHANNEL_1                 0x02000000U    /*!< DMA Channel 1 */
N#define DMA_CHANNEL_2                 0x04000000U    /*!< DMA Channel 2 */
N#define DMA_CHANNEL_3                 0x06000000U    /*!< DMA Channel 3 */
N#define DMA_CHANNEL_4                 0x08000000U    /*!< DMA Channel 4 */
N#define DMA_CHANNEL_5                 0x0A000000U    /*!< DMA Channel 5 */
N#define DMA_CHANNEL_6                 0x0C000000U    /*!< DMA Channel 6 */
N#define DMA_CHANNEL_7                 0x0E000000U    /*!< DMA Channel 7 */
N#if defined (DMA_SxCR_CHSEL_3)
X#if 0L
S#define DMA_CHANNEL_8                 0x10000000U    /*!< DMA Channel 8 */
S#define DMA_CHANNEL_9                 0x12000000U    /*!< DMA Channel 9 */
S#define DMA_CHANNEL_10                0x14000000U    /*!< DMA Channel 10 */
S#define DMA_CHANNEL_11                0x16000000U    /*!< DMA Channel 11 */
S#define DMA_CHANNEL_12                0x18000000U    /*!< DMA Channel 12 */
S#define DMA_CHANNEL_13                0x1A000000U    /*!< DMA Channel 13 */
S#define DMA_CHANNEL_14                0x1C000000U    /*!< DMA Channel 14 */
S#define DMA_CHANNEL_15                0x1E000000U    /*!< DMA Channel 15 */
N#endif /* DMA_SxCR_CHSEL_3 */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Data_transfer_direction DMA Data transfer direction
N  * @brief    DMA data transfer direction 
N  * @{
N  */ 
N#define DMA_PERIPH_TO_MEMORY          0x00000000U                 /*!< Peripheral to memory direction */
N#define DMA_MEMORY_TO_PERIPH          ((uint32_t)DMA_SxCR_DIR_0)  /*!< Memory to peripheral direction */
N#define DMA_MEMORY_TO_MEMORY          ((uint32_t)DMA_SxCR_DIR_1)  /*!< Memory to memory direction     */
N/**
N  * @}
N  */
N        
N/** @defgroup DMA_Peripheral_incremented_mode DMA Peripheral incremented mode
N  * @brief    DMA peripheral incremented mode 
N  * @{
N  */ 
N#define DMA_PINC_ENABLE               ((uint32_t)DMA_SxCR_PINC)   /*!< Peripheral increment mode enable  */
N#define DMA_PINC_DISABLE              0x00000000U                 /*!< Peripheral increment mode disable */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_incremented_mode DMA Memory incremented mode
N  * @brief    DMA memory incremented mode 
N  * @{
N  */ 
N#define DMA_MINC_ENABLE               ((uint32_t)DMA_SxCR_MINC)   /*!< Memory increment mode enable  */
N#define DMA_MINC_DISABLE              0x00000000U                 /*!< Memory increment mode disable */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Peripheral_data_size DMA Peripheral data size
N  * @brief    DMA peripheral data size 
N  * @{
N  */ 
N#define DMA_PDATAALIGN_BYTE           0x00000000U                  /*!< Peripheral data alignment: Byte     */
N#define DMA_PDATAALIGN_HALFWORD       ((uint32_t)DMA_SxCR_PSIZE_0) /*!< Peripheral data alignment: HalfWord */
N#define DMA_PDATAALIGN_WORD           ((uint32_t)DMA_SxCR_PSIZE_1) /*!< Peripheral data alignment: Word     */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_data_size DMA Memory data size
N  * @brief    DMA memory data size 
N  * @{ 
N  */
N#define DMA_MDATAALIGN_BYTE           0x00000000U                  /*!< Memory data alignment: Byte     */
N#define DMA_MDATAALIGN_HALFWORD       ((uint32_t)DMA_SxCR_MSIZE_0) /*!< Memory data alignment: HalfWord */
N#define DMA_MDATAALIGN_WORD           ((uint32_t)DMA_SxCR_MSIZE_1) /*!< Memory data alignment: Word     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_mode DMA mode
N  * @brief    DMA mode 
N  * @{
N  */ 
N#define DMA_NORMAL                    0x00000000U                  /*!< Normal mode                  */
N#define DMA_CIRCULAR                  ((uint32_t)DMA_SxCR_CIRC)    /*!< Circular mode                */
N#define DMA_PFCTRL                    ((uint32_t)DMA_SxCR_PFCTRL)  /*!< Peripheral flow control mode */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Priority_level DMA Priority level
N  * @brief    DMA priority levels 
N  * @{
N  */
N#define DMA_PRIORITY_LOW              0x00000000U                 /*!< Priority level: Low       */
N#define DMA_PRIORITY_MEDIUM           ((uint32_t)DMA_SxCR_PL_0)   /*!< Priority level: Medium    */
N#define DMA_PRIORITY_HIGH             ((uint32_t)DMA_SxCR_PL_1)   /*!< Priority level: High      */
N#define DMA_PRIORITY_VERY_HIGH        ((uint32_t)DMA_SxCR_PL)     /*!< Priority level: Very High */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_FIFO_direct_mode DMA FIFO direct mode
N  * @brief    DMA FIFO direct mode
N  * @{
N  */
N#define DMA_FIFOMODE_DISABLE          0x00000000U                 /*!< FIFO mode disable */
N#define DMA_FIFOMODE_ENABLE           ((uint32_t)DMA_SxFCR_DMDIS) /*!< FIFO mode enable  */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_FIFO_threshold_level DMA FIFO threshold level
N  * @brief    DMA FIFO level 
N  * @{
N  */
N#define DMA_FIFO_THRESHOLD_1QUARTERFULL       0x00000000U                  /*!< FIFO threshold 1 quart full configuration  */
N#define DMA_FIFO_THRESHOLD_HALFFULL           ((uint32_t)DMA_SxFCR_FTH_0)  /*!< FIFO threshold half full configuration     */
N#define DMA_FIFO_THRESHOLD_3QUARTERSFULL      ((uint32_t)DMA_SxFCR_FTH_1)  /*!< FIFO threshold 3 quarts full configuration */
N#define DMA_FIFO_THRESHOLD_FULL               ((uint32_t)DMA_SxFCR_FTH)    /*!< FIFO threshold full configuration          */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_burst DMA Memory burst
N  * @brief    DMA memory burst 
N  * @{
N  */ 
N#define DMA_MBURST_SINGLE             0x00000000U
N#define DMA_MBURST_INC4               ((uint32_t)DMA_SxCR_MBURST_0)  
N#define DMA_MBURST_INC8               ((uint32_t)DMA_SxCR_MBURST_1)  
N#define DMA_MBURST_INC16              ((uint32_t)DMA_SxCR_MBURST)  
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Peripheral_burst DMA Peripheral burst
N  * @brief    DMA peripheral burst 
N  * @{
N  */ 
N#define DMA_PBURST_SINGLE             0x00000000U
N#define DMA_PBURST_INC4               ((uint32_t)DMA_SxCR_PBURST_0)
N#define DMA_PBURST_INC8               ((uint32_t)DMA_SxCR_PBURST_1)
N#define DMA_PBURST_INC16              ((uint32_t)DMA_SxCR_PBURST)
N/**
N  * @}
N  */
N
N/** @defgroup DMA_interrupt_enable_definitions DMA interrupt enable definitions
N  * @brief    DMA interrupts definition 
N  * @{
N  */
N#define DMA_IT_TC                     ((uint32_t)DMA_SxCR_TCIE)
N#define DMA_IT_HT                     ((uint32_t)DMA_SxCR_HTIE)
N#define DMA_IT_TE                     ((uint32_t)DMA_SxCR_TEIE)
N#define DMA_IT_DME                    ((uint32_t)DMA_SxCR_DMEIE)
N#define DMA_IT_FE                     0x00000080U
N/**
N  * @}
N  */
N
N/** @defgroup DMA_flag_definitions DMA flag definitions
N  * @brief    DMA flag definitions 
N  * @{
N  */ 
N#define DMA_FLAG_FEIF0_4              0x00000001U
N#define DMA_FLAG_DMEIF0_4             0x00000004U
N#define DMA_FLAG_TEIF0_4              0x00000008U
N#define DMA_FLAG_HTIF0_4              0x00000010U
N#define DMA_FLAG_TCIF0_4              0x00000020U
N#define DMA_FLAG_FEIF1_5              0x00000040U
N#define DMA_FLAG_DMEIF1_5             0x00000100U
N#define DMA_FLAG_TEIF1_5              0x00000200U
N#define DMA_FLAG_HTIF1_5              0x00000400U
N#define DMA_FLAG_TCIF1_5              0x00000800U
N#define DMA_FLAG_FEIF2_6              0x00010000U
N#define DMA_FLAG_DMEIF2_6             0x00040000U
N#define DMA_FLAG_TEIF2_6              0x00080000U
N#define DMA_FLAG_HTIF2_6              0x00100000U
N#define DMA_FLAG_TCIF2_6              0x00200000U
N#define DMA_FLAG_FEIF3_7              0x00400000U
N#define DMA_FLAG_DMEIF3_7             0x01000000U
N#define DMA_FLAG_TEIF3_7              0x02000000U
N#define DMA_FLAG_HTIF3_7              0x04000000U
N#define DMA_FLAG_TCIF3_7              0x08000000U
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N 
N/* Exported macro ------------------------------------------------------------*/
N
N/** @brief Reset DMA handle state
N  * @param  __HANDLE__ specifies the DMA handle.
N  * @retval None
N  */
N#define __HAL_DMA_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DMA_STATE_RESET)
N
N/**
N  * @brief  Return the current DMA Stream FIFO filled level.
N  * @param  __HANDLE__ DMA handle
N  * @retval The FIFO filling state.
N  *           - DMA_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
N  *                                              and not empty.
N  *           - DMA_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
N  *           - DMA_FIFOStatus_HalfFull: if more than 1 half-full.
N  *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
N  *           - DMA_FIFOStatus_Empty: when FIFO is empty
N  *           - DMA_FIFOStatus_Full: when FIFO is full
N  */
N#define __HAL_DMA_GET_FS(__HANDLE__)      (((__HANDLE__)->Instance->FCR & (DMA_SxFCR_FS)))
N
N/**
N  * @brief  Enable the specified DMA Stream.
N  * @param  __HANDLE__ DMA handle
N  * @retval None
N  */
N#define __HAL_DMA_ENABLE(__HANDLE__)      ((__HANDLE__)->Instance->CR |=  DMA_SxCR_EN)
N
N/**
N  * @brief  Disable the specified DMA Stream.
N  * @param  __HANDLE__ DMA handle
N  * @retval None
N  */
N#define __HAL_DMA_DISABLE(__HANDLE__)     ((__HANDLE__)->Instance->CR &=  ~DMA_SxCR_EN)
N
N/* Interrupt & Flag management */
N
N/**
N  * @brief  Return the current DMA Stream transfer complete flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified transfer complete flag index.
N  */
N#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) \
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TCIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TCIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TCIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TCIF2_6 :\
N   DMA_FLAG_TCIF3_7)
X#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TCIF2_6 :   DMA_FLAG_TCIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream half transfer complete flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified half transfer complete flag index.
N  */      
N#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_HTIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_HTIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_HTIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_HTIF2_6 :\
N   DMA_FLAG_HTIF3_7)
X#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_HTIF2_6 :   DMA_FLAG_HTIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream transfer error flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified transfer error flag index.
N  */
N#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TEIF2_6 :\
N   DMA_FLAG_TEIF3_7)
X#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TEIF2_6 :   DMA_FLAG_TEIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream FIFO error flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified FIFO error flag index.
N  */
N#define __HAL_DMA_GET_FE_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_FEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_FEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_FEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_FEIF2_6 :\
N   DMA_FLAG_FEIF3_7)
X#define __HAL_DMA_GET_FE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_FEIF2_6 :   DMA_FLAG_FEIF3_7)
N
N/**
N  * @brief  Return the current DMA Stream direct mode error flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified direct mode error flag index.
N  */
N#define __HAL_DMA_GET_DME_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_DMEIF0_4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_DMEIF1_5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_DMEIF2_6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_DMEIF2_6 :\
N   DMA_FLAG_DMEIF3_7)
X#define __HAL_DMA_GET_DME_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_DMEIF2_6 :   DMA_FLAG_DMEIF3_7)
N
N/**
N  * @brief  Get the DMA Stream pending flags.
N  * @param  __HANDLE__ DMA handle
N  * @param  __FLAG__ Get the specified flag.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_FLAG_TCIFx: Transfer complete flag.
N  *            @arg DMA_FLAG_HTIFx: Half transfer complete flag.
N  *            @arg DMA_FLAG_TEIFx: Transfer error flag.
N  *            @arg DMA_FLAG_DMEIFx: Direct mode error flag.
N  *            @arg DMA_FLAG_FEIFx: FIFO error flag.
N  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Stream flag.   
N  * @retval The state of FLAG (SET or RESET).
N  */
N#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)\
N(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HISR & (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LISR & (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HISR & (__FLAG__)) : (DMA1->LISR & (__FLAG__)))
X#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HISR & (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LISR & (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HISR & (__FLAG__)) : (DMA1->LISR & (__FLAG__)))
N
N/**
N  * @brief  Clear the DMA Stream pending flags.
N  * @param  __HANDLE__ DMA handle
N  * @param  __FLAG__ specifies the flag to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_FLAG_TCIFx: Transfer complete flag.
N  *            @arg DMA_FLAG_HTIFx: Half transfer complete flag.
N  *            @arg DMA_FLAG_TEIFx: Transfer error flag.
N  *            @arg DMA_FLAG_DMEIFx: Direct mode error flag.
N  *            @arg DMA_FLAG_FEIFx: FIFO error flag.
N  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Stream flag.   
N  * @retval None
N  */
N#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) \
N(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HIFCR = (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LIFCR = (__FLAG__)) :\
N ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HIFCR = (__FLAG__)) : (DMA1->LIFCR = (__FLAG__)))
X#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) (((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HIFCR = (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LIFCR = (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HIFCR = (__FLAG__)) : (DMA1->LIFCR = (__FLAG__)))
N
N/**
N  * @brief  Enable the specified DMA Stream interrupts.
N  * @param  __HANDLE__ DMA handle
N  * @param  __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled. 
N  *        This parameter can be any combination of the following values:
N  *           @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *           @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *           @arg DMA_IT_TE: Transfer error interrupt mask.
N  *           @arg DMA_IT_FE: FIFO error interrupt mask.
N  *           @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval None
N  */
N#define __HAL_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((__INTERRUPT__) != DMA_IT_FE)? \
N((__HANDLE__)->Instance->CR |= (__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR |= (__INTERRUPT__)))
X#define __HAL_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR |= (__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR |= (__INTERRUPT__)))
N
N/**
N  * @brief  Disable the specified DMA Stream interrupts.
N  * @param  __HANDLE__ DMA handle
N  * @param  __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled. 
N  *         This parameter can be any combination of the following values:
N  *            @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *            @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *            @arg DMA_IT_TE: Transfer error interrupt mask.
N  *            @arg DMA_IT_FE: FIFO error interrupt mask.
N  *            @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval None
N  */
N#define __HAL_DMA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? \
N((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR &= ~(__INTERRUPT__)))
X#define __HAL_DMA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR &= ~(__INTERRUPT__)))
N
N/**
N  * @brief  Check whether the specified DMA Stream interrupt is enabled or disabled.
N  * @param  __HANDLE__ DMA handle
N  * @param  __INTERRUPT__ specifies the DMA interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg DMA_IT_TC: Transfer complete interrupt mask.
N  *            @arg DMA_IT_HT: Half transfer complete interrupt mask.
N  *            @arg DMA_IT_TE: Transfer error interrupt mask.
N  *            @arg DMA_IT_FE: FIFO error interrupt mask.
N  *            @arg DMA_IT_DME: Direct mode error interrupt.
N  * @retval The state of DMA_IT.
N  */
N#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)? \
N                                                        ((__HANDLE__)->Instance->CR & (__INTERRUPT__)) : \
N                                                        ((__HANDLE__)->Instance->FCR & (__INTERRUPT__)))
X#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__INTERRUPT__) != DMA_IT_FE)?                                                         ((__HANDLE__)->Instance->CR & (__INTERRUPT__)) :                                                         ((__HANDLE__)->Instance->FCR & (__INTERRUPT__)))
N
N/**
N  * @brief  Writes the number of data units to be transferred on the DMA Stream.
N  * @param  __HANDLE__ DMA handle
N  * @param  __COUNTER__ Number of data units to be transferred (from 0 to 65535) 
N  *          Number of data items depends only on the Peripheral data format.
N  *            
N  * @note   If Peripheral data format is Bytes: number of data units is equal 
N  *         to total number of bytes to be transferred.
N  *           
N  * @note   If Peripheral data format is Half-Word: number of data units is  
N  *         equal to total number of bytes to be transferred / 2.
N  *           
N  * @note   If Peripheral data format is Word: number of data units is equal 
N  *         to total  number of bytes to be transferred / 4.
N  *      
N  * @retval The number of remaining data units in the current DMAy Streamx transfer.
N  */
N#define __HAL_DMA_SET_COUNTER(__HANDLE__, __COUNTER__) ((__HANDLE__)->Instance->NDTR = (uint16_t)(__COUNTER__))
N
N/**
N  * @brief  Returns the number of remaining data units in the current DMAy Streamx transfer.
N  * @param  __HANDLE__ DMA handle
N  *   
N  * @retval The number of remaining data units in the current DMA Stream transfer.
N  */
N#define __HAL_DMA_GET_COUNTER(__HANDLE__) ((__HANDLE__)->Instance->NDTR)
N
N
N/* Include DMA HAL Extension module */
N#include "stm32f4xx_hal_dma_ex.h"   
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_dma_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_dma_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of DMA HAL extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_DMA_EX_H
N#define __STM32F4xx_HAL_DMA_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DMAEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup DMAEx_Exported_Types DMAEx Exported Types
N  * @brief DMAEx Exported types
N  * @{
N  */
N   
N/** 
N  * @brief  HAL DMA Memory definition  
N  */ 
Ntypedef enum
N{
N  MEMORY0      = 0x00U,    /*!< Memory 0     */
N  MEMORY1      = 0x01U     /*!< Memory 1     */
N}HAL_DMA_MemoryTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup DMAEx_Exported_Functions DMAEx Exported Functions
N  * @brief   DMAEx Exported functions
N  * @{
N  */
N
N/** @defgroup DMAEx_Exported_Functions_Group1 Extended features functions
N  * @brief   Extended features functions
N  * @{
N  */
N
N/* IO operation functions *******************************************************/
NHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory);
N
N/**
N  * @}
N  */
N/**
N  * @}
N  */
N         
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup DMAEx_Private_Functions DMAEx Private Functions
N  * @brief DMAEx Private functions
N  * @{
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_HAL_DMA_EX_H*/
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 641 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_dma.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Functions DMA Exported Functions
N  * @brief    DMA Exported functions 
N  * @{
N  */
N
N/** @defgroup DMA_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @brief   Initialization and de-initialization functions 
N  * @{
N  */
NHAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma); 
NHAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Exported_Functions_Group2 I/O operation functions
N  * @brief   I/O operation functions  
N  * @{
N  */
NHAL_StatusTypeDef HAL_DMA_Start (DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout);
Nvoid              HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_CleanCallbacks(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma));
NHAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID);
N
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Exported_Functions_Group3 Peripheral State functions
N  * @brief    Peripheral State functions 
N  * @{
N  */
NHAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma);
Nuint32_t             HAL_DMA_GetError(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */ 
N/**
N  * @}
N  */ 
N/* Private Constants -------------------------------------------------------------*/
N/** @defgroup DMA_Private_Constants DMA Private Constants
N  * @brief    DMA private defines and constants 
N  * @{
N  */
N/**
N  * @}
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup DMA_Private_Macros DMA Private Macros
N  * @brief    DMA private macros 
N  * @{
N  */
N#if defined (DMA_SxCR_CHSEL_3)
X#if 0L
S#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) || \
S                                 ((CHANNEL) == DMA_CHANNEL_1) || \
S                                 ((CHANNEL) == DMA_CHANNEL_2) || \
S                                 ((CHANNEL) == DMA_CHANNEL_3) || \
S                                 ((CHANNEL) == DMA_CHANNEL_4) || \
S                                 ((CHANNEL) == DMA_CHANNEL_5) || \
S                                 ((CHANNEL) == DMA_CHANNEL_6) || \
S                                 ((CHANNEL) == DMA_CHANNEL_7) || \
S                                 ((CHANNEL) == DMA_CHANNEL_8) || \
S                                 ((CHANNEL) == DMA_CHANNEL_9) || \
S                                 ((CHANNEL) == DMA_CHANNEL_10)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_11)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_12)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_13)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_14)|| \
S                                 ((CHANNEL) == DMA_CHANNEL_15))
X#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) ||                                  ((CHANNEL) == DMA_CHANNEL_1) ||                                  ((CHANNEL) == DMA_CHANNEL_2) ||                                  ((CHANNEL) == DMA_CHANNEL_3) ||                                  ((CHANNEL) == DMA_CHANNEL_4) ||                                  ((CHANNEL) == DMA_CHANNEL_5) ||                                  ((CHANNEL) == DMA_CHANNEL_6) ||                                  ((CHANNEL) == DMA_CHANNEL_7) ||                                  ((CHANNEL) == DMA_CHANNEL_8) ||                                  ((CHANNEL) == DMA_CHANNEL_9) ||                                  ((CHANNEL) == DMA_CHANNEL_10)||                                  ((CHANNEL) == DMA_CHANNEL_11)||                                  ((CHANNEL) == DMA_CHANNEL_12)||                                  ((CHANNEL) == DMA_CHANNEL_13)||                                  ((CHANNEL) == DMA_CHANNEL_14)||                                  ((CHANNEL) == DMA_CHANNEL_15))
N#else
N#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) || \
N                                 ((CHANNEL) == DMA_CHANNEL_1) || \
N                                 ((CHANNEL) == DMA_CHANNEL_2) || \
N                                 ((CHANNEL) == DMA_CHANNEL_3) || \
N                                 ((CHANNEL) == DMA_CHANNEL_4) || \
N                                 ((CHANNEL) == DMA_CHANNEL_5) || \
N                                 ((CHANNEL) == DMA_CHANNEL_6) || \
N                                 ((CHANNEL) == DMA_CHANNEL_7))
X#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_CHANNEL_0) ||                                  ((CHANNEL) == DMA_CHANNEL_1) ||                                  ((CHANNEL) == DMA_CHANNEL_2) ||                                  ((CHANNEL) == DMA_CHANNEL_3) ||                                  ((CHANNEL) == DMA_CHANNEL_4) ||                                  ((CHANNEL) == DMA_CHANNEL_5) ||                                  ((CHANNEL) == DMA_CHANNEL_6) ||                                  ((CHANNEL) == DMA_CHANNEL_7))
N#endif /* DMA_SxCR_CHSEL_3 */
N
N#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) || \
N                                     ((DIRECTION) == DMA_MEMORY_TO_PERIPH)  || \
N                                     ((DIRECTION) == DMA_MEMORY_TO_MEMORY)) 
X#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) ||                                      ((DIRECTION) == DMA_MEMORY_TO_PERIPH)  ||                                      ((DIRECTION) == DMA_MEMORY_TO_MEMORY)) 
N
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x01U) && ((SIZE) < 0x10000U))
N
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) || \
N                                            ((STATE) == DMA_PINC_DISABLE))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) ||                                             ((STATE) == DMA_PINC_DISABLE))
N
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE)  || \
N                                        ((STATE) == DMA_MINC_DISABLE))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE)  ||                                         ((STATE) == DMA_MINC_DISABLE))
N
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE)     || \
N                                           ((SIZE) == DMA_PDATAALIGN_HALFWORD) || \
N                                           ((SIZE) == DMA_PDATAALIGN_WORD))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE)     ||                                            ((SIZE) == DMA_PDATAALIGN_HALFWORD) ||                                            ((SIZE) == DMA_PDATAALIGN_WORD))
N
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE)     || \
N                                       ((SIZE) == DMA_MDATAALIGN_HALFWORD) || \
N                                       ((SIZE) == DMA_MDATAALIGN_WORD ))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE)     ||                                        ((SIZE) == DMA_MDATAALIGN_HALFWORD) ||                                        ((SIZE) == DMA_MDATAALIGN_WORD ))
N
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL )  || \
N                           ((MODE) == DMA_CIRCULAR) || \
N                           ((MODE) == DMA_PFCTRL)) 
X#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL )  ||                            ((MODE) == DMA_CIRCULAR) ||                            ((MODE) == DMA_PFCTRL)) 
N
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW )   || \
N                                   ((PRIORITY) == DMA_PRIORITY_MEDIUM) || \
N                                   ((PRIORITY) == DMA_PRIORITY_HIGH)   || \
N                                   ((PRIORITY) == DMA_PRIORITY_VERY_HIGH)) 
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW )   ||                                    ((PRIORITY) == DMA_PRIORITY_MEDIUM) ||                                    ((PRIORITY) == DMA_PRIORITY_HIGH)   ||                                    ((PRIORITY) == DMA_PRIORITY_VERY_HIGH)) 
N
N#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMODE_DISABLE ) || \
N                                       ((STATE) == DMA_FIFOMODE_ENABLE))
X#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMODE_DISABLE ) ||                                        ((STATE) == DMA_FIFOMODE_ENABLE))
N
N#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFO_THRESHOLD_1QUARTERFULL ) || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_HALFFULL)      || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_3QUARTERSFULL) || \
N                                          ((THRESHOLD) == DMA_FIFO_THRESHOLD_FULL))
X#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFO_THRESHOLD_1QUARTERFULL ) ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_HALFFULL)      ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_3QUARTERSFULL) ||                                           ((THRESHOLD) == DMA_FIFO_THRESHOLD_FULL))
N
N#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MBURST_SINGLE) || \
N                                    ((BURST) == DMA_MBURST_INC4)   || \
N                                    ((BURST) == DMA_MBURST_INC8)   || \
N                                    ((BURST) == DMA_MBURST_INC16))
X#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MBURST_SINGLE) ||                                     ((BURST) == DMA_MBURST_INC4)   ||                                     ((BURST) == DMA_MBURST_INC8)   ||                                     ((BURST) == DMA_MBURST_INC16))
N
N#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PBURST_SINGLE) || \
N                                        ((BURST) == DMA_PBURST_INC4)   || \
N                                        ((BURST) == DMA_PBURST_INC8)   || \
N                                        ((BURST) == DMA_PBURST_INC16))
X#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PBURST_SINGLE) ||                                         ((BURST) == DMA_PBURST_INC4)   ||                                         ((BURST) == DMA_PBURST_INC8)   ||                                         ((BURST) == DMA_PBURST_INC16))
N/**
N  * @}
N  */ 
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup DMA_Private_Functions DMA Private Functions
N  * @brief    DMA private  functions 
N  * @{
N  */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_DMA_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 207 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_DMA_MODULE_ENABLED */
N
N#ifdef HAL_DFSDM_MODULE_ENABLED
S#include "stm32f4xx_hal_dfsdm.h"
N#endif /* HAL_DFSDM_MODULE_ENABLED */
N
N#ifdef HAL_CORTEX_MODULE_ENABLED
N#include "stm32f4xx_hal_cortex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_cortex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_cortex.h
N  * @author  MCD Application Team
N  * @brief   Header file of CORTEX HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_CORTEX_H
N#define __STM32F4xx_HAL_CORTEX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup CORTEX
N  * @{
N  */ 
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup CORTEX_Exported_Types Cortex Exported Types
N  * @{
N  */
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
N/** @defgroup CORTEX_MPU_Region_Initialization_Structure_definition MPU Region Initialization Structure Definition
N  * @brief  MPU Region initialization structure 
N  * @{
N  */
Ntypedef struct
N{
N  uint8_t                Enable;                /*!< Specifies the status of the region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Enable                 */
N  uint8_t                Number;                /*!< Specifies the number of the region to protect. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Number                 */
N  uint32_t               BaseAddress;           /*!< Specifies the base address of the region to protect.                           */
N  uint8_t                Size;                  /*!< Specifies the size of the region to protect. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Size                   */
N  uint8_t                SubRegionDisable;      /*!< Specifies the number of the subregion protection to disable. 
N                                                     This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF    */         
N  uint8_t                TypeExtField;          /*!< Specifies the TEX field level.
N                                                     This parameter can be a value of @ref CORTEX_MPU_TEX_Levels                    */                 
N  uint8_t                AccessPermission;      /*!< Specifies the region access permission type. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Permission_Attributes  */
N  uint8_t                DisableExec;           /*!< Specifies the instruction access status. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Instruction_Access            */
N  uint8_t                IsShareable;           /*!< Specifies the shareability status of the protected region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Shareable              */
N  uint8_t                IsCacheable;           /*!< Specifies the cacheable status of the region protected. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Cacheable              */
N  uint8_t                IsBufferable;          /*!< Specifies the bufferable status of the protected region. 
N                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Bufferable             */
N}MPU_Region_InitTypeDef;
N/**
N  * @}
N  */
N#endif /* __MPU_PRESENT */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CORTEX_Exported_Constants CORTEX Exported Constants
N  * @{
N  */
N
N/** @defgroup CORTEX_Preemption_Priority_Group CORTEX Preemption Priority Group
N  * @{
N  */
N#define NVIC_PRIORITYGROUP_0         0x00000007U /*!< 0 bits for pre-emption priority
N                                                      4 bits for subpriority */
N#define NVIC_PRIORITYGROUP_1         0x00000006U /*!< 1 bits for pre-emption priority
N                                                      3 bits for subpriority */
N#define NVIC_PRIORITYGROUP_2         0x00000005U /*!< 2 bits for pre-emption priority
N                                                      2 bits for subpriority */
N#define NVIC_PRIORITYGROUP_3         0x00000004U /*!< 3 bits for pre-emption priority
N                                                      1 bits for subpriority */
N#define NVIC_PRIORITYGROUP_4         0x00000003U /*!< 4 bits for pre-emption priority
N                                                      0 bits for subpriority */
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_SysTick_clock_source CORTEX _SysTick clock source 
N  * @{
N  */
N#define SYSTICK_CLKSOURCE_HCLK_DIV8    0x00000000U
N#define SYSTICK_CLKSOURCE_HCLK         0x00000004U
N
N/**
N  * @}
N  */
N
N#if (__MPU_PRESENT == 1)
X#if (1U == 1)
N/** @defgroup CORTEX_MPU_HFNMI_PRIVDEF_Control MPU HFNMI and PRIVILEGED Access control
N  * @{
N  */
N#define  MPU_HFNMI_PRIVDEF_NONE           0x00000000U
N#define  MPU_HARDFAULT_NMI                MPU_CTRL_HFNMIENA_Msk
N#define  MPU_PRIVILEGED_DEFAULT           MPU_CTRL_PRIVDEFENA_Msk
N#define  MPU_HFNMI_PRIVDEF               (MPU_CTRL_HFNMIENA_Msk | MPU_CTRL_PRIVDEFENA_Msk)
N
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Enable CORTEX MPU Region Enable
N  * @{
N  */
N#define  MPU_REGION_ENABLE     ((uint8_t)0x01)
N#define  MPU_REGION_DISABLE    ((uint8_t)0x00)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Instruction_Access CORTEX MPU Instruction Access
N  * @{
N  */
N#define  MPU_INSTRUCTION_ACCESS_ENABLE      ((uint8_t)0x00)
N#define  MPU_INSTRUCTION_ACCESS_DISABLE     ((uint8_t)0x01)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Shareable CORTEX MPU Instruction Access Shareable
N  * @{
N  */
N#define  MPU_ACCESS_SHAREABLE        ((uint8_t)0x01)
N#define  MPU_ACCESS_NOT_SHAREABLE    ((uint8_t)0x00)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Cacheable CORTEX MPU Instruction Access Cacheable
N  * @{
N  */
N#define  MPU_ACCESS_CACHEABLE         ((uint8_t)0x01)
N#define  MPU_ACCESS_NOT_CACHEABLE     ((uint8_t)0x00)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Access_Bufferable CORTEX MPU Instruction Access Bufferable
N  * @{
N  */
N#define  MPU_ACCESS_BUFFERABLE         ((uint8_t)0x01)
N#define  MPU_ACCESS_NOT_BUFFERABLE     ((uint8_t)0x00)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_TEX_Levels MPU TEX Levels
N  * @{
N  */
N#define  MPU_TEX_LEVEL0    ((uint8_t)0x00)
N#define  MPU_TEX_LEVEL1    ((uint8_t)0x01)
N#define  MPU_TEX_LEVEL2    ((uint8_t)0x02)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Size CORTEX MPU Region Size
N  * @{
N  */
N#define   MPU_REGION_SIZE_32B      ((uint8_t)0x04)
N#define   MPU_REGION_SIZE_64B      ((uint8_t)0x05)
N#define   MPU_REGION_SIZE_128B     ((uint8_t)0x06)
N#define   MPU_REGION_SIZE_256B     ((uint8_t)0x07)
N#define   MPU_REGION_SIZE_512B     ((uint8_t)0x08)
N#define   MPU_REGION_SIZE_1KB      ((uint8_t)0x09)
N#define   MPU_REGION_SIZE_2KB      ((uint8_t)0x0A)
N#define   MPU_REGION_SIZE_4KB      ((uint8_t)0x0B)
N#define   MPU_REGION_SIZE_8KB      ((uint8_t)0x0C)
N#define   MPU_REGION_SIZE_16KB     ((uint8_t)0x0D)
N#define   MPU_REGION_SIZE_32KB     ((uint8_t)0x0E)
N#define   MPU_REGION_SIZE_64KB     ((uint8_t)0x0F)
N#define   MPU_REGION_SIZE_128KB    ((uint8_t)0x10)
N#define   MPU_REGION_SIZE_256KB    ((uint8_t)0x11)
N#define   MPU_REGION_SIZE_512KB    ((uint8_t)0x12)
N#define   MPU_REGION_SIZE_1MB      ((uint8_t)0x13)
N#define   MPU_REGION_SIZE_2MB      ((uint8_t)0x14)
N#define   MPU_REGION_SIZE_4MB      ((uint8_t)0x15)
N#define   MPU_REGION_SIZE_8MB      ((uint8_t)0x16)
N#define   MPU_REGION_SIZE_16MB     ((uint8_t)0x17)
N#define   MPU_REGION_SIZE_32MB     ((uint8_t)0x18)
N#define   MPU_REGION_SIZE_64MB     ((uint8_t)0x19)
N#define   MPU_REGION_SIZE_128MB    ((uint8_t)0x1A)
N#define   MPU_REGION_SIZE_256MB    ((uint8_t)0x1B)
N#define   MPU_REGION_SIZE_512MB    ((uint8_t)0x1C)
N#define   MPU_REGION_SIZE_1GB      ((uint8_t)0x1D)
N#define   MPU_REGION_SIZE_2GB      ((uint8_t)0x1E)
N#define   MPU_REGION_SIZE_4GB      ((uint8_t)0x1F)
N/**
N  * @}
N  */
N   
N/** @defgroup CORTEX_MPU_Region_Permission_Attributes CORTEX MPU Region Permission Attributes 
N  * @{
N  */
N#define  MPU_REGION_NO_ACCESS      ((uint8_t)0x00)
N#define  MPU_REGION_PRIV_RW        ((uint8_t)0x01)
N#define  MPU_REGION_PRIV_RW_URO    ((uint8_t)0x02)
N#define  MPU_REGION_FULL_ACCESS    ((uint8_t)0x03)
N#define  MPU_REGION_PRIV_RO        ((uint8_t)0x05)
N#define  MPU_REGION_PRIV_RO_URO    ((uint8_t)0x06)
N/**
N  * @}
N  */
N
N/** @defgroup CORTEX_MPU_Region_Number CORTEX MPU Region Number
N  * @{
N  */
N#define  MPU_REGION_NUMBER0    ((uint8_t)0x00)
N#define  MPU_REGION_NUMBER1    ((uint8_t)0x01)
N#define  MPU_REGION_NUMBER2    ((uint8_t)0x02)
N#define  MPU_REGION_NUMBER3    ((uint8_t)0x03)
N#define  MPU_REGION_NUMBER4    ((uint8_t)0x04)
N#define  MPU_REGION_NUMBER5    ((uint8_t)0x05)
N#define  MPU_REGION_NUMBER6    ((uint8_t)0x06)
N#define  MPU_REGION_NUMBER7    ((uint8_t)0x07)
N/**
N  * @}
N  */
N#endif /* __MPU_PRESENT */
N
N/**
N  * @}
N  */
N
N
N/* Exported Macros -----------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup CORTEX_Exported_Functions
N  * @{
N  */
N  
N/** @addtogroup CORTEX_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
Nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup);
Nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
Nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_SystemReset(void);
Nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb);
N/**
N  * @}
N  */
N
N/** @addtogroup CORTEX_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions ***********************************************/
Nuint32_t HAL_NVIC_GetPriorityGrouping(void);
Nvoid HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority);
Nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn);
Nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn);
Nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource);
Nvoid HAL_SYSTICK_IRQHandler(void);
Nvoid HAL_SYSTICK_Callback(void);
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
Nvoid HAL_MPU_Enable(uint32_t MPU_Control);
Nvoid HAL_MPU_Disable(void);
Nvoid HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init);
N#endif /* __MPU_PRESENT */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup CORTEX_Private_Macros CORTEX Private Macros
N  * @{
N  */
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PRIORITYGROUP_0) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_1) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_2) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_3) || \
N                                       ((GROUP) == NVIC_PRIORITYGROUP_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PRIORITYGROUP_0) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_1) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_2) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_3) ||                                        ((GROUP) == NVIC_PRIORITYGROUP_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10U)
N
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)         ((PRIORITY) < 0x10U)
N
N#define IS_NVIC_DEVICE_IRQ(IRQ)                ((IRQ) >= (IRQn_Type)0x00U)
N
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) || \
N                                       ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) ||                                        ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))
N
N#if (__MPU_PRESENT == 1U)
X#if (1U == 1U)
N#define IS_MPU_REGION_ENABLE(STATE) (((STATE) == MPU_REGION_ENABLE) || \
N                                     ((STATE) == MPU_REGION_DISABLE))
X#define IS_MPU_REGION_ENABLE(STATE) (((STATE) == MPU_REGION_ENABLE) ||                                      ((STATE) == MPU_REGION_DISABLE))
N
N#define IS_MPU_INSTRUCTION_ACCESS(STATE) (((STATE) == MPU_INSTRUCTION_ACCESS_ENABLE) || \
N                                          ((STATE) == MPU_INSTRUCTION_ACCESS_DISABLE))
X#define IS_MPU_INSTRUCTION_ACCESS(STATE) (((STATE) == MPU_INSTRUCTION_ACCESS_ENABLE) ||                                           ((STATE) == MPU_INSTRUCTION_ACCESS_DISABLE))
N
N#define IS_MPU_ACCESS_SHAREABLE(STATE)   (((STATE) == MPU_ACCESS_SHAREABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_SHAREABLE))
X#define IS_MPU_ACCESS_SHAREABLE(STATE)   (((STATE) == MPU_ACCESS_SHAREABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_SHAREABLE))
N
N#define IS_MPU_ACCESS_CACHEABLE(STATE)   (((STATE) == MPU_ACCESS_CACHEABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_CACHEABLE))
X#define IS_MPU_ACCESS_CACHEABLE(STATE)   (((STATE) == MPU_ACCESS_CACHEABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_CACHEABLE))
N
N#define IS_MPU_ACCESS_BUFFERABLE(STATE)   (((STATE) == MPU_ACCESS_BUFFERABLE) || \
N                                          ((STATE) == MPU_ACCESS_NOT_BUFFERABLE))
X#define IS_MPU_ACCESS_BUFFERABLE(STATE)   (((STATE) == MPU_ACCESS_BUFFERABLE) ||                                           ((STATE) == MPU_ACCESS_NOT_BUFFERABLE))
N
N#define IS_MPU_TEX_LEVEL(TYPE) (((TYPE) == MPU_TEX_LEVEL0)  || \
N                                ((TYPE) == MPU_TEX_LEVEL1)  || \
N                                ((TYPE) == MPU_TEX_LEVEL2))
X#define IS_MPU_TEX_LEVEL(TYPE) (((TYPE) == MPU_TEX_LEVEL0)  ||                                 ((TYPE) == MPU_TEX_LEVEL1)  ||                                 ((TYPE) == MPU_TEX_LEVEL2))
N
N#define IS_MPU_REGION_PERMISSION_ATTRIBUTE(TYPE) (((TYPE) == MPU_REGION_NO_ACCESS)   || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RW)     || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RW_URO) || \
N                                                  ((TYPE) == MPU_REGION_FULL_ACCESS) || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RO)     || \
N                                                  ((TYPE) == MPU_REGION_PRIV_RO_URO))
X#define IS_MPU_REGION_PERMISSION_ATTRIBUTE(TYPE) (((TYPE) == MPU_REGION_NO_ACCESS)   ||                                                   ((TYPE) == MPU_REGION_PRIV_RW)     ||                                                   ((TYPE) == MPU_REGION_PRIV_RW_URO) ||                                                   ((TYPE) == MPU_REGION_FULL_ACCESS) ||                                                   ((TYPE) == MPU_REGION_PRIV_RO)     ||                                                   ((TYPE) == MPU_REGION_PRIV_RO_URO))
N
N#define IS_MPU_REGION_NUMBER(NUMBER)    (((NUMBER) == MPU_REGION_NUMBER0) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER1) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER2) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER3) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER4) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER5) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER6) || \
N                                         ((NUMBER) == MPU_REGION_NUMBER7))
X#define IS_MPU_REGION_NUMBER(NUMBER)    (((NUMBER) == MPU_REGION_NUMBER0) ||                                          ((NUMBER) == MPU_REGION_NUMBER1) ||                                          ((NUMBER) == MPU_REGION_NUMBER2) ||                                          ((NUMBER) == MPU_REGION_NUMBER3) ||                                          ((NUMBER) == MPU_REGION_NUMBER4) ||                                          ((NUMBER) == MPU_REGION_NUMBER5) ||                                          ((NUMBER) == MPU_REGION_NUMBER6) ||                                          ((NUMBER) == MPU_REGION_NUMBER7))
N
N#define IS_MPU_REGION_SIZE(SIZE)    (((SIZE) == MPU_REGION_SIZE_32B)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_64B)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_128B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_256B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_512B)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_1KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_8KB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_16KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_32KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_64KB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_128KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_256KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_512KB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_1MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_8MB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_16MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_32MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_64MB)  || \
N                                     ((SIZE) == MPU_REGION_SIZE_128MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_256MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_512MB) || \
N                                     ((SIZE) == MPU_REGION_SIZE_1GB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_2GB)   || \
N                                     ((SIZE) == MPU_REGION_SIZE_4GB))
X#define IS_MPU_REGION_SIZE(SIZE)    (((SIZE) == MPU_REGION_SIZE_32B)   ||                                      ((SIZE) == MPU_REGION_SIZE_64B)   ||                                      ((SIZE) == MPU_REGION_SIZE_128B)  ||                                      ((SIZE) == MPU_REGION_SIZE_256B)  ||                                      ((SIZE) == MPU_REGION_SIZE_512B)  ||                                      ((SIZE) == MPU_REGION_SIZE_1KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_8KB)   ||                                      ((SIZE) == MPU_REGION_SIZE_16KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_32KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_64KB)  ||                                      ((SIZE) == MPU_REGION_SIZE_128KB) ||                                      ((SIZE) == MPU_REGION_SIZE_256KB) ||                                      ((SIZE) == MPU_REGION_SIZE_512KB) ||                                      ((SIZE) == MPU_REGION_SIZE_1MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_8MB)   ||                                      ((SIZE) == MPU_REGION_SIZE_16MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_32MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_64MB)  ||                                      ((SIZE) == MPU_REGION_SIZE_128MB) ||                                      ((SIZE) == MPU_REGION_SIZE_256MB) ||                                      ((SIZE) == MPU_REGION_SIZE_512MB) ||                                      ((SIZE) == MPU_REGION_SIZE_1GB)   ||                                      ((SIZE) == MPU_REGION_SIZE_2GB)   ||                                      ((SIZE) == MPU_REGION_SIZE_4GB))
N
N#define IS_MPU_SUB_REGION_DISABLE(SUBREGION)  ((SUBREGION) < (uint16_t)0x00FF)
N#endif /* __MPU_PRESENT */
N
N/**                                                                          
N  * @}                                                                  
N  */
N
N/* Private functions ---------------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_CORTEX_H */
N 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 215 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_CORTEX_MODULE_ENABLED */
N
N#ifdef HAL_ADC_MODULE_ENABLED
N#include "stm32f4xx_hal_adc.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_adc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_adc.h
N  * @author  MCD Application Team
N  * @brief   Header file containing functions prototypes of ADC HAL library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_ADC_H
N#define __STM32F4xx_ADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup ADC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup ADC_Exported_Types ADC Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  Structure definition of ADC and regular group initialization 
N  * @note   Parameters of this structure are shared within 2 scopes:
N  *          - Scope entire ADC (affects regular and injected groups): ClockPrescaler, Resolution, ScanConvMode, DataAlign, ScanConvMode, EOCSelection, LowPowerAutoWait, LowPowerAutoPowerOff, ChannelsBank.
N  *          - Scope regular group: ContinuousConvMode, NbrOfConversion, DiscontinuousConvMode, NbrOfDiscConversion, ExternalTrigConvEdge, ExternalTrigConv.
N  * @note   The setting of these parameters with function HAL_ADC_Init() is conditioned to ADC state.
N  *         ADC state can be either:
N  *          - For all parameters: ADC disabled
N  *          - For all parameters except 'Resolution', 'ScanConvMode', 'DiscontinuousConvMode', 'NbrOfDiscConversion' : ADC enabled without conversion on going on regular group.
N  *          - For parameters 'ExternalTrigConv' and 'ExternalTrigConvEdge': ADC enabled, even with conversion on going.
N  *         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed
N  *         without error reporting (as it can be the expected behaviour in case of intended action to update another parameter (which fulfills the ADC state condition) on the fly).
N  */
Ntypedef struct
N{
N  uint32_t ClockPrescaler;               /*!< Select ADC clock prescaler. The clock is common for 
N                                              all the ADCs.
N                                              This parameter can be a value of @ref ADC_ClockPrescaler */
N  uint32_t Resolution;                   /*!< Configures the ADC resolution.
N                                              This parameter can be a value of @ref ADC_Resolution */
N  uint32_t DataAlign;                    /*!< Specifies ADC data alignment to right (MSB on register bit 11 and LSB on register bit 0) (default setting)
N                                              or to left (if regular group: MSB on register bit 15 and LSB on register bit 4, if injected group (MSB kept as signed value due to potential negative value after offset application): MSB on register bit 14 and LSB on register bit 3).
N                                              This parameter can be a value of @ref ADC_Data_align */
N  uint32_t ScanConvMode;                 /*!< Configures the sequencer of regular and injected groups.
N                                              This parameter can be associated to parameter 'DiscontinuousConvMode' to have main sequence subdivided in successive parts.
N                                              If disabled: Conversion is performed in single mode (one channel converted, the one defined in rank 1).
N                                                           Parameters 'NbrOfConversion' and 'InjectedNbrOfConversion' are discarded (equivalent to set to 1).
N                                              If enabled:  Conversions are performed in sequence mode (multiple ranks defined by 'NbrOfConversion'/'InjectedNbrOfConversion' and each channel rank).
N                                                           Scan direction is upward: from rank1 to rank 'n'.
N                                              This parameter can be set to ENABLE or DISABLE */
N  uint32_t EOCSelection;                 /*!< Specifies what EOC (End Of Conversion) flag is used for conversion by polling and interruption: end of conversion of each rank or complete sequence.
N                                              This parameter can be a value of @ref ADC_EOCSelection.
N                                              Note: For injected group, end of conversion (flag&IT) is raised only at the end of the sequence.
N                                                    Therefore, if end of conversion is set to end of each conversion, injected group should not be used with interruption (HAL_ADCEx_InjectedStart_IT)
N                                                    or polling (HAL_ADCEx_InjectedStart and HAL_ADCEx_InjectedPollForConversion). By the way, polling is still possible since driver will use an estimated timing for end of injected conversion.
N                                              Note: If overrun feature is intended to be used, use ADC in mode 'interruption' (function HAL_ADC_Start_IT() ) with parameter EOCSelection set to end of each conversion or in mode 'transfer by DMA' (function HAL_ADC_Start_DMA()).
N                                                    If overrun feature is intended to be bypassed, use ADC in mode 'polling' or 'interruption' with parameter EOCSelection must be set to end of sequence */
N  FunctionalState ContinuousConvMode;    /*!< Specifies whether the conversion is performed in single mode (one conversion) or continuous mode for regular group,
N                                              after the selected trigger occurred (software start or external trigger).
N                                              This parameter can be set to ENABLE or DISABLE. */
N  uint32_t NbrOfConversion;              /*!< Specifies the number of ranks that will be converted within the regular group sequencer.
N                                              To use regular group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled.
N                                              This parameter must be a number between Min_Data = 1 and Max_Data = 16. */
N  FunctionalState DiscontinuousConvMode; /*!< Specifies whether the conversions sequence of regular group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts).
N                                              Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.
N                                              Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded.
N                                              This parameter can be set to ENABLE or DISABLE. */
N  uint32_t NbrOfDiscConversion;          /*!< Specifies the number of discontinuous conversions in which the  main sequence of regular group (parameter NbrOfConversion) will be subdivided.
N                                              If parameter 'DiscontinuousConvMode' is disabled, this parameter is discarded.
N                                              This parameter must be a number between Min_Data = 1 and Max_Data = 8. */
N  uint32_t ExternalTrigConv;             /*!< Selects the external event used to trigger the conversion start of regular group.
N                                              If set to ADC_SOFTWARE_START, external triggers are disabled.
N                                              If set to external trigger source, triggering is on event rising edge by default.
N                                              This parameter can be a value of @ref ADC_External_trigger_Source_Regular */
N  uint32_t ExternalTrigConvEdge;         /*!< Selects the external trigger edge of regular group.
N                                              If trigger is set to ADC_SOFTWARE_START, this parameter is discarded.
N                                              This parameter can be a value of @ref ADC_External_trigger_edge_Regular */
N  FunctionalState DMAContinuousRequests; /*!< Specifies whether the DMA requests are performed in one shot mode (DMA transfer stop when number of conversions is reached)
N											  or in Continuous mode (DMA transfer unlimited, whatever number of conversions).
N											  Note: In continuous mode, DMA must be configured in circular mode. Otherwise an overrun will be triggered when DMA buffer maximum pointer is reached.
N											  Note: This parameter must be modified when no conversion is on going on both regular and injected groups (ADC disabled, or ADC enabled without continuous mode or external trigger that could launch a conversion).
N											  This parameter can be set to ENABLE or DISABLE. */
N}ADC_InitTypeDef;
N
N
N
N/** 
N  * @brief  Structure definition of ADC channel for regular group   
N  * @note   The setting of these parameters with function HAL_ADC_ConfigChannel() is conditioned to ADC state.
N  *         ADC can be either disabled or enabled without conversion on going on regular group.
N  */ 
Ntypedef struct 
N{
N  uint32_t Channel;                /*!< Specifies the channel to configure into ADC regular group.
N                                        This parameter can be a value of @ref ADC_channels */
N  uint32_t Rank;                   /*!< Specifies the rank in the regular group sequencer.
N                                        This parameter must be a number between Min_Data = 1 and Max_Data = 16 */
N  uint32_t SamplingTime;           /*!< Sampling time value to be set for the selected channel.
N                                        Unit: ADC clock cycles
N                                        Conversion time is the addition of sampling time and processing time (12 ADC clock cycles at ADC resolution 12 bits, 11 cycles at 10 bits, 9 cycles at 8 bits, 7 cycles at 6 bits).
N                                        This parameter can be a value of @ref ADC_sampling_times
N                                        Caution: This parameter updates the parameter property of the channel, that can be used into regular and/or injected groups.
N                                                 If this same channel has been previously configured in the other group (regular/injected), it will be updated to last setting.
N                                        Note: In case of usage of internal measurement channels (VrefInt/Vbat/TempSensor),
N                                              sampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)
N                                              Refer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 4us min). */
N  uint32_t Offset;                 /*!< Reserved for future use, can be set to 0 */
N}ADC_ChannelConfTypeDef;
N
N/** 
N  * @brief ADC Configuration multi-mode structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t WatchdogMode;      /*!< Configures the ADC analog watchdog mode.
N                                   This parameter can be a value of @ref ADC_analog_watchdog_selection */
N  uint32_t HighThreshold;     /*!< Configures the ADC analog watchdog High threshold value.
N                                   This parameter must be a 12-bit value. */     
N  uint32_t LowThreshold;      /*!< Configures the ADC analog watchdog High threshold value.
N                                   This parameter must be a 12-bit value. */
N  uint32_t Channel;           /*!< Configures ADC channel for the analog watchdog. 
N                                   This parameter has an effect only if watchdog mode is configured on single channel 
N                                   This parameter can be a value of @ref ADC_channels */      
N  FunctionalState ITMode;     /*!< Specifies whether the analog watchdog is configured
N                                   is interrupt mode or in polling mode.
N                                   This parameter can be set to ENABLE or DISABLE */
N  uint32_t WatchdogNumber;    /*!< Reserved for future use, can be set to 0 */
N}ADC_AnalogWDGConfTypeDef;
N
N/** 
N  * @brief  HAL ADC state machine: ADC states definition (bitfields)
N  */ 
N/* States of ADC global scope */
N#define HAL_ADC_STATE_RESET             0x00000000U    /*!< ADC not yet initialized or disabled */
N#define HAL_ADC_STATE_READY             0x00000001U    /*!< ADC peripheral ready for use */
N#define HAL_ADC_STATE_BUSY_INTERNAL     0x00000002U    /*!< ADC is busy to internal process (initialization, calibration) */
N#define HAL_ADC_STATE_TIMEOUT           0x00000004U    /*!< TimeOut occurrence */
N
N/* States of ADC errors */
N#define HAL_ADC_STATE_ERROR_INTERNAL    0x00000010U    /*!< Internal error occurrence */
N#define HAL_ADC_STATE_ERROR_CONFIG      0x00000020U    /*!< Configuration error occurrence */
N#define HAL_ADC_STATE_ERROR_DMA         0x00000040U    /*!< DMA error occurrence */
N
N/* States of ADC group regular */
N#define HAL_ADC_STATE_REG_BUSY          0x00000100U    /*!< A conversion on group regular is ongoing or can occur (either by continuous mode,
N                                                            external trigger, low power auto power-on (if feature available), multimode ADC master control (if feature available)) */
N#define HAL_ADC_STATE_REG_EOC           0x00000200U    /*!< Conversion data available on group regular */
N#define HAL_ADC_STATE_REG_OVR           0x00000400U    /*!< Overrun occurrence */
N
N/* States of ADC group injected */
N#define HAL_ADC_STATE_INJ_BUSY          0x00001000U    /*!< A conversion on group injected is ongoing or can occur (either by auto-injection mode,
N                                                            external trigger, low power auto power-on (if feature available), multimode ADC master control (if feature available)) */
N#define HAL_ADC_STATE_INJ_EOC           0x00002000U    /*!< Conversion data available on group injected */
N
N/* States of ADC analog watchdogs */
N#define HAL_ADC_STATE_AWD1              0x00010000U    /*!< Out-of-window occurrence of analog watchdog 1 */
N#define HAL_ADC_STATE_AWD2              0x00020000U    /*!< Not available on STM32F4 device: Out-of-window occurrence of analog watchdog 2 */
N#define HAL_ADC_STATE_AWD3              0x00040000U    /*!< Not available on STM32F4 device: Out-of-window occurrence of analog watchdog 3 */
N
N/* States of ADC multi-mode */
N#define HAL_ADC_STATE_MULTIMODE_SLAVE   0x00100000U    /*!< Not available on STM32F4 device: ADC in multimode slave state, controlled by another ADC master ( */
N
N
N/** 
N  * @brief  ADC handle Structure definition
N  */ 
N#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
Stypedef struct __ADC_HandleTypeDef
N#else
Ntypedef struct
N#endif
N{
N  ADC_TypeDef                   *Instance;                   /*!< Register base address */
N
N  ADC_InitTypeDef               Init;                        /*!< ADC required parameters */
N
N  __IO uint32_t                 NbrOfCurrentConversionRank;  /*!< ADC number of current conversion rank */
X  volatile uint32_t                 NbrOfCurrentConversionRank;   
N
N  DMA_HandleTypeDef             *DMA_Handle;                 /*!< Pointer DMA Handler */
N
N  HAL_LockTypeDef               Lock;                        /*!< ADC locking object */
N
N  __IO uint32_t                 State;                       /*!< ADC communication state */
X  volatile uint32_t                 State;                        
N
N  __IO uint32_t                 ErrorCode;                   /*!< ADC Error code */
X  volatile uint32_t                 ErrorCode;                    
N#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
S  void (* ConvCpltCallback)(struct __ADC_HandleTypeDef *hadc);              /*!< ADC conversion complete callback */
S  void (* ConvHalfCpltCallback)(struct __ADC_HandleTypeDef *hadc);          /*!< ADC conversion DMA half-transfer callback */
S  void (* LevelOutOfWindowCallback)(struct __ADC_HandleTypeDef *hadc);      /*!< ADC analog watchdog 1 callback */
S  void (* ErrorCallback)(struct __ADC_HandleTypeDef *hadc);                 /*!< ADC error callback */
S  void (* InjectedConvCpltCallback)(struct __ADC_HandleTypeDef *hadc);      /*!< ADC group injected conversion complete callback */
S  void (* MspInitCallback)(struct __ADC_HandleTypeDef *hadc);               /*!< ADC Msp Init callback */
S  void (* MspDeInitCallback)(struct __ADC_HandleTypeDef *hadc);             /*!< ADC Msp DeInit callback */
N#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
N}ADC_HandleTypeDef;
N
N#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
S/**
S  * @brief  HAL ADC Callback ID enumeration definition
S  */
Stypedef enum
S{
S  HAL_ADC_CONVERSION_COMPLETE_CB_ID     = 0x00U,  /*!< ADC conversion complete callback ID */
S  HAL_ADC_CONVERSION_HALF_CB_ID         = 0x01U,  /*!< ADC conversion DMA half-transfer callback ID */
S  HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID   = 0x02U,  /*!< ADC analog watchdog 1 callback ID */
S  HAL_ADC_ERROR_CB_ID                   = 0x03U,  /*!< ADC error callback ID */
S  HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID = 0x04U,  /*!< ADC group injected conversion complete callback ID */
S  HAL_ADC_MSPINIT_CB_ID                 = 0x05U,  /*!< ADC Msp Init callback ID          */
S  HAL_ADC_MSPDEINIT_CB_ID               = 0x06U   /*!< ADC Msp DeInit callback ID        */
S} HAL_ADC_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL ADC Callback pointer definition
S  */
Stypedef  void (*pADC_CallbackTypeDef)(ADC_HandleTypeDef *hadc); /*!< pointer to a ADC callback function */
S
N#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup ADC_Exported_Constants ADC Exported Constants
N  * @{
N  */
N
N/** @defgroup ADC_Error_Code ADC Error Code
N  * @{
N  */
N#define HAL_ADC_ERROR_NONE        0x00U   /*!< No error                                              */
N#define HAL_ADC_ERROR_INTERNAL    0x01U   /*!< ADC IP internal error: if problem of clocking, 
N                                               enable/disable, erroneous state                       */
N#define HAL_ADC_ERROR_OVR         0x02U   /*!< Overrun error                                         */
N#define HAL_ADC_ERROR_DMA         0x04U   /*!< DMA transfer error                                    */
N#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
S#define HAL_ADC_ERROR_INVALID_CALLBACK  (0x10U)   /*!< Invalid Callback error */
N#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N
N/** @defgroup ADC_ClockPrescaler  ADC Clock Prescaler
N  * @{
N  */ 
N#define ADC_CLOCK_SYNC_PCLK_DIV2    0x00000000U
N#define ADC_CLOCK_SYNC_PCLK_DIV4    ((uint32_t)ADC_CCR_ADCPRE_0)
N#define ADC_CLOCK_SYNC_PCLK_DIV6    ((uint32_t)ADC_CCR_ADCPRE_1)
N#define ADC_CLOCK_SYNC_PCLK_DIV8    ((uint32_t)ADC_CCR_ADCPRE)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_delay_between_2_sampling_phases ADC Delay Between 2 Sampling Phases
N  * @{
N  */ 
N#define ADC_TWOSAMPLINGDELAY_5CYCLES    0x00000000U
N#define ADC_TWOSAMPLINGDELAY_6CYCLES    ((uint32_t)ADC_CCR_DELAY_0)
N#define ADC_TWOSAMPLINGDELAY_7CYCLES    ((uint32_t)ADC_CCR_DELAY_1)
N#define ADC_TWOSAMPLINGDELAY_8CYCLES    ((uint32_t)(ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_9CYCLES    ((uint32_t)ADC_CCR_DELAY_2)
N#define ADC_TWOSAMPLINGDELAY_10CYCLES   ((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_11CYCLES   ((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1))
N#define ADC_TWOSAMPLINGDELAY_12CYCLES   ((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_13CYCLES   ((uint32_t)ADC_CCR_DELAY_3)
N#define ADC_TWOSAMPLINGDELAY_14CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_15CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_1))
N#define ADC_TWOSAMPLINGDELAY_16CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_17CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2))
N#define ADC_TWOSAMPLINGDELAY_18CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2 | ADC_CCR_DELAY_0))
N#define ADC_TWOSAMPLINGDELAY_19CYCLES   ((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1))
N#define ADC_TWOSAMPLINGDELAY_20CYCLES   ((uint32_t)ADC_CCR_DELAY)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Resolution ADC Resolution
N  * @{
N  */ 
N#define ADC_RESOLUTION_12B  0x00000000U
N#define ADC_RESOLUTION_10B  ((uint32_t)ADC_CR1_RES_0)
N#define ADC_RESOLUTION_8B   ((uint32_t)ADC_CR1_RES_1)
N#define ADC_RESOLUTION_6B   ((uint32_t)ADC_CR1_RES)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_External_trigger_edge_Regular ADC External Trigger Edge Regular
N  * @{
N  */ 
N#define ADC_EXTERNALTRIGCONVEDGE_NONE           0x00000000U
N#define ADC_EXTERNALTRIGCONVEDGE_RISING         ((uint32_t)ADC_CR2_EXTEN_0)
N#define ADC_EXTERNALTRIGCONVEDGE_FALLING        ((uint32_t)ADC_CR2_EXTEN_1)
N#define ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING  ((uint32_t)ADC_CR2_EXTEN)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_External_trigger_Source_Regular ADC External Trigger Source Regular
N  * @{
N  */
N/* Note: Parameter ADC_SOFTWARE_START is a software parameter used for        */
N/*       compatibility with other STM32 devices.                              */
N#define ADC_EXTERNALTRIGCONV_T1_CC1    0x00000000U
N#define ADC_EXTERNALTRIGCONV_T1_CC2    ((uint32_t)ADC_CR2_EXTSEL_0)
N#define ADC_EXTERNALTRIGCONV_T1_CC3    ((uint32_t)ADC_CR2_EXTSEL_1)
N#define ADC_EXTERNALTRIGCONV_T2_CC2    ((uint32_t)(ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T2_CC3    ((uint32_t)ADC_CR2_EXTSEL_2)
N#define ADC_EXTERNALTRIGCONV_T2_CC4    ((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T2_TRGO   ((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_1))
N#define ADC_EXTERNALTRIGCONV_T3_CC1    ((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T3_TRGO   ((uint32_t)ADC_CR2_EXTSEL_3)
N#define ADC_EXTERNALTRIGCONV_T4_CC4    ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T5_CC1    ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_1))
N#define ADC_EXTERNALTRIGCONV_T5_CC2    ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T5_CC3    ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_2))
N#define ADC_EXTERNALTRIGCONV_T8_CC1    ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_0))
N#define ADC_EXTERNALTRIGCONV_T8_TRGO   ((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_1))
N#define ADC_EXTERNALTRIGCONV_Ext_IT11  ((uint32_t)ADC_CR2_EXTSEL)
N#define ADC_SOFTWARE_START             ((uint32_t)ADC_CR2_EXTSEL + 1U)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Data_align ADC Data Align
N  * @{
N  */ 
N#define ADC_DATAALIGN_RIGHT      0x00000000U
N#define ADC_DATAALIGN_LEFT       ((uint32_t)ADC_CR2_ALIGN)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_channels  ADC Common Channels
N  * @{
N  */ 
N#define ADC_CHANNEL_0           0x00000000U
N#define ADC_CHANNEL_1           ((uint32_t)ADC_CR1_AWDCH_0)
N#define ADC_CHANNEL_2           ((uint32_t)ADC_CR1_AWDCH_1)
N#define ADC_CHANNEL_3           ((uint32_t)(ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_4           ((uint32_t)ADC_CR1_AWDCH_2)
N#define ADC_CHANNEL_5           ((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_6           ((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1))
N#define ADC_CHANNEL_7           ((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_8           ((uint32_t)ADC_CR1_AWDCH_3)
N#define ADC_CHANNEL_9           ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_10          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_1))
N#define ADC_CHANNEL_11          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_12          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2))
N#define ADC_CHANNEL_13          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_14          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1))
N#define ADC_CHANNEL_15          ((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_16          ((uint32_t)ADC_CR1_AWDCH_4)
N#define ADC_CHANNEL_17          ((uint32_t)(ADC_CR1_AWDCH_4 | ADC_CR1_AWDCH_0))
N#define ADC_CHANNEL_18          ((uint32_t)(ADC_CR1_AWDCH_4 | ADC_CR1_AWDCH_1))
N
N#define ADC_CHANNEL_VREFINT     ((uint32_t)ADC_CHANNEL_17)
N#define ADC_CHANNEL_VBAT        ((uint32_t)ADC_CHANNEL_18)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_sampling_times  ADC Sampling Times
N  * @{
N  */ 
N#define ADC_SAMPLETIME_3CYCLES    0x00000000U
N#define ADC_SAMPLETIME_15CYCLES   ((uint32_t)ADC_SMPR1_SMP10_0)
N#define ADC_SAMPLETIME_28CYCLES   ((uint32_t)ADC_SMPR1_SMP10_1)
N#define ADC_SAMPLETIME_56CYCLES   ((uint32_t)(ADC_SMPR1_SMP10_1 | ADC_SMPR1_SMP10_0))
N#define ADC_SAMPLETIME_84CYCLES   ((uint32_t)ADC_SMPR1_SMP10_2)
N#define ADC_SAMPLETIME_112CYCLES  ((uint32_t)(ADC_SMPR1_SMP10_2 | ADC_SMPR1_SMP10_0))
N#define ADC_SAMPLETIME_144CYCLES  ((uint32_t)(ADC_SMPR1_SMP10_2 | ADC_SMPR1_SMP10_1))
N#define ADC_SAMPLETIME_480CYCLES  ((uint32_t)ADC_SMPR1_SMP10)
N/**
N  * @}
N  */ 
N
N  /** @defgroup ADC_EOCSelection ADC EOC Selection
N  * @{
N  */ 
N#define ADC_EOC_SEQ_CONV              0x00000000U
N#define ADC_EOC_SINGLE_CONV           0x00000001U
N#define ADC_EOC_SINGLE_SEQ_CONV       0x00000002U  /*!< reserved for future use */
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Event_type ADC Event Type
N  * @{
N  */ 
N#define ADC_AWD_EVENT             ((uint32_t)ADC_FLAG_AWD)
N#define ADC_OVR_EVENT             ((uint32_t)ADC_FLAG_OVR)
N/**
N  * @}
N  */
N
N/** @defgroup ADC_analog_watchdog_selection ADC Analog Watchdog Selection
N  * @{
N  */ 
N#define ADC_ANALOGWATCHDOG_SINGLE_REG         ((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_AWDEN))
N#define ADC_ANALOGWATCHDOG_SINGLE_INJEC       ((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN))
N#define ADC_ANALOGWATCHDOG_SINGLE_REGINJEC    ((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_AWDEN | ADC_CR1_JAWDEN))
N#define ADC_ANALOGWATCHDOG_ALL_REG            ((uint32_t)ADC_CR1_AWDEN)
N#define ADC_ANALOGWATCHDOG_ALL_INJEC          ((uint32_t)ADC_CR1_JAWDEN)
N#define ADC_ANALOGWATCHDOG_ALL_REGINJEC       ((uint32_t)(ADC_CR1_AWDEN | ADC_CR1_JAWDEN))
N#define ADC_ANALOGWATCHDOG_NONE               0x00000000U
N/**
N  * @}
N  */ 
N    
N/** @defgroup ADC_interrupts_definition ADC Interrupts Definition
N  * @{
N  */ 
N#define ADC_IT_EOC      ((uint32_t)ADC_CR1_EOCIE)
N#define ADC_IT_AWD      ((uint32_t)ADC_CR1_AWDIE)
N#define ADC_IT_JEOC     ((uint32_t)ADC_CR1_JEOCIE)
N#define ADC_IT_OVR      ((uint32_t)ADC_CR1_OVRIE)
N/**
N  * @}
N  */ 
N    
N/** @defgroup ADC_flags_definition ADC Flags Definition
N  * @{
N  */ 
N#define ADC_FLAG_AWD    ((uint32_t)ADC_SR_AWD)
N#define ADC_FLAG_EOC    ((uint32_t)ADC_SR_EOC)
N#define ADC_FLAG_JEOC   ((uint32_t)ADC_SR_JEOC)
N#define ADC_FLAG_JSTRT  ((uint32_t)ADC_SR_JSTRT)
N#define ADC_FLAG_STRT   ((uint32_t)ADC_SR_STRT)
N#define ADC_FLAG_OVR    ((uint32_t)ADC_SR_OVR)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_channels_type ADC Channels Type
N  * @{
N  */ 
N#define ADC_ALL_CHANNELS      0x00000001U
N#define ADC_REGULAR_CHANNELS  0x00000002U /*!< reserved for future use */
N#define ADC_INJECTED_CHANNELS 0x00000003U /*!< reserved for future use */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup ADC_Exported_Macros ADC Exported Macros
N  * @{
N  */
N
N/** @brief Reset ADC handle state
N  * @param  __HANDLE__ ADC handle
N  * @retval None
N  */
N#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
S#define __HAL_ADC_RESET_HANDLE_STATE(__HANDLE__)                               \
S  do{                                                                          \
S     (__HANDLE__)->State = HAL_ADC_STATE_RESET;                               \
S     (__HANDLE__)->MspInitCallback = NULL;                                     \
S     (__HANDLE__)->MspDeInitCallback = NULL;                                   \
S    } while(0)
X#define __HAL_ADC_RESET_HANDLE_STATE(__HANDLE__)                                 do{                                                                               (__HANDLE__)->State = HAL_ADC_STATE_RESET;                                    (__HANDLE__)->MspInitCallback = NULL;                                          (__HANDLE__)->MspDeInitCallback = NULL;                                       } while(0)
N#else
N#define __HAL_ADC_RESET_HANDLE_STATE(__HANDLE__)                               \
N  ((__HANDLE__)->State = HAL_ADC_STATE_RESET)
X#define __HAL_ADC_RESET_HANDLE_STATE(__HANDLE__)                                 ((__HANDLE__)->State = HAL_ADC_STATE_RESET)
N#endif
N
N/**
N  * @brief  Enable the ADC peripheral.
N  * @param  __HANDLE__ ADC handle
N  * @retval None
N  */
N#define __HAL_ADC_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR2 |=  ADC_CR2_ADON)
N
N/**
N  * @brief  Disable the ADC peripheral.
N  * @param  __HANDLE__ ADC handle
N  * @retval None
N  */
N#define __HAL_ADC_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR2 &=  ~ADC_CR2_ADON)
N
N/**
N  * @brief  Enable the ADC end of conversion interrupt.
N  * @param  __HANDLE__ specifies the ADC Handle.
N  * @param  __INTERRUPT__ ADC Interrupt.
N  * @retval None
N  */
N#define __HAL_ADC_ENABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CR1) |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the ADC end of conversion interrupt.
N  * @param  __HANDLE__ specifies the ADC Handle.
N  * @param  __INTERRUPT__ ADC interrupt.
N  * @retval None
N  */
N#define __HAL_ADC_DISABLE_IT(__HANDLE__, __INTERRUPT__) (((__HANDLE__)->Instance->CR1) &= ~(__INTERRUPT__))
N
N/** @brief  Check if the specified ADC interrupt source is enabled or disabled.
N  * @param  __HANDLE__ specifies the ADC Handle.
N  * @param  __INTERRUPT__ specifies the ADC interrupt source to check.
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_ADC_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__HANDLE__)->Instance->CR1 & (__INTERRUPT__)) == (__INTERRUPT__))
N
N/**
N  * @brief  Clear the ADC's pending flags.
N  * @param  __HANDLE__ specifies the ADC Handle.
N  * @param  __FLAG__ ADC flag.
N  * @retval None
N  */
N#define __HAL_ADC_CLEAR_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->SR) = ~(__FLAG__))
N
N/**
N  * @brief  Get the selected ADC's flag status.
N  * @param  __HANDLE__ specifies the ADC Handle.
N  * @param  __FLAG__ ADC flag.
N  * @retval None
N  */
N#define __HAL_ADC_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/**
N  * @}
N  */
N
N/* Include ADC HAL Extension module */
N#include "stm32f4xx_hal_adc_ex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_adc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_adc_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of ADC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_ADC_EX_H
N#define __STM32F4xx_ADC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup ADCEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup ADCEx_Exported_Types ADC Exported Types
N  * @{
N  */
N   
N/** 
N  * @brief  ADC Configuration injected Channel structure definition
N  * @note   Parameters of this structure are shared within 2 scopes:
N  *          - Scope channel: InjectedChannel, InjectedRank, InjectedSamplingTime, InjectedOffset
N  *          - Scope injected group (affects all channels of injected group): InjectedNbrOfConversion, InjectedDiscontinuousConvMode,
N  *            AutoInjectedConv, ExternalTrigInjecConvEdge, ExternalTrigInjecConv.
N  * @note   The setting of these parameters with function HAL_ADCEx_InjectedConfigChannel() is conditioned to ADC state.
N  *         ADC state can be either:
N  *          - For all parameters: ADC disabled
N  *          - For all except parameters 'InjectedDiscontinuousConvMode' and 'AutoInjectedConv': ADC enabled without conversion on going on injected group.
N  *          - For parameters 'ExternalTrigInjecConv' and 'ExternalTrigInjecConvEdge': ADC enabled, even with conversion on going on injected group.
N  */
Ntypedef struct 
N{
N  uint32_t InjectedChannel;                      /*!< Selection of ADC channel to configure
N                                                      This parameter can be a value of @ref ADC_channels
N                                                      Note: Depending on devices, some channels may not be available on package pins. Refer to device datasheet for channels availability. */
N  uint32_t InjectedRank;                         /*!< Rank in the injected group sequencer
N                                                      This parameter must be a value of @ref ADCEx_injected_rank
N                                                      Note: In case of need to disable a channel or change order of conversion sequencer, rank containing a previous channel setting can be overwritten by the new channel setting (or parameter number of conversions can be adjusted) */
N  uint32_t InjectedSamplingTime;                 /*!< Sampling time value to be set for the selected channel.
N                                                      Unit: ADC clock cycles
N                                                      Conversion time is the addition of sampling time and processing time (12 ADC clock cycles at ADC resolution 12 bits, 11 cycles at 10 bits, 9 cycles at 8 bits, 7 cycles at 6 bits).
N                                                      This parameter can be a value of @ref ADC_sampling_times
N                                                      Caution: This parameter updates the parameter property of the channel, that can be used into regular and/or injected groups.
N                                                               If this same channel has been previously configured in the other group (regular/injected), it will be updated to last setting.
N                                                      Note: In case of usage of internal measurement channels (VrefInt/Vbat/TempSensor),
N                                                            sampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)
N                                                            Refer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 4us min). */
N  uint32_t InjectedOffset;                       /*!< Defines the offset to be subtracted from the raw converted data (for channels set on injected group only).
N                                                      Offset value must be a positive number.
N                                                      Depending of ADC resolution selected (12, 10, 8 or 6 bits),
N                                                      this parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F respectively. */
N  uint32_t InjectedNbrOfConversion;              /*!< Specifies the number of ranks that will be converted within the injected group sequencer.
N                                                      To use the injected group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled.
N                                                      This parameter must be a number between Min_Data = 1 and Max_Data = 4.
N                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
N                                                               configure a channel on injected group can impact the configuration of other channels previously set. */
N  FunctionalState InjectedDiscontinuousConvMode; /*!< Specifies whether the conversions sequence of injected group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts).
N                                                      Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.
N                                                      Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded.
N                                                      This parameter can be set to ENABLE or DISABLE.
N                                                      Note: For injected group, number of discontinuous ranks increment is fixed to one-by-one.
N                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
N                                                               configure a channel on injected group can impact the configuration of other channels previously set. */
N  FunctionalState AutoInjectedConv;              /*!< Enables or disables the selected ADC automatic injected group conversion after regular one
N                                                      This parameter can be set to ENABLE or DISABLE.      
N                                                      Note: To use Automatic injected conversion, discontinuous mode must be disabled ('DiscontinuousConvMode' and 'InjectedDiscontinuousConvMode' set to DISABLE)
N                                                      Note: To use Automatic injected conversion, injected group external triggers must be disabled ('ExternalTrigInjecConv' set to ADC_SOFTWARE_START)
N                                                      Note: In case of DMA used with regular group: if DMA configured in normal mode (single shot) JAUTO will be stopped upon DMA transfer complete.
N                                                            To maintain JAUTO always enabled, DMA must be configured in circular mode.
N                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to
N                                                               configure a channel on injected group can impact the configuration of other channels previously set. */
N  uint32_t ExternalTrigInjecConv;                /*!< Selects the external event used to trigger the conversion start of injected group.
N                                                      If set to ADC_INJECTED_SOFTWARE_START, external triggers are disabled.
N                                                      If set to external trigger source, triggering is on event rising edge.
N                                                      This parameter can be a value of @ref ADCEx_External_trigger_Source_Injected
N                                                      Note: This parameter must be modified when ADC is disabled (before ADC start conversion or after ADC stop conversion).
N                                                            If ADC is enabled, this parameter setting is bypassed without error reporting (as it can be the expected behaviour in case of another parameter update on the fly)
N                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to
N                                                               configure a channel on injected group can impact the configuration of other channels previously set. */
N  uint32_t ExternalTrigInjecConvEdge;            /*!< Selects the external trigger edge of injected group.
N                                                      This parameter can be a value of @ref ADCEx_External_trigger_edge_Injected.
N                                                      If trigger is set to ADC_INJECTED_SOFTWARE_START, this parameter is discarded.
N                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
N                                                               configure a channel on injected group can impact the configuration of other channels previously set. */
N}ADC_InjectionConfTypeDef; 
N
N/** 
N  * @brief ADC Configuration multi-mode structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t Mode;              /*!< Configures the ADC to operate in independent or multi mode. 
N                                   This parameter can be a value of @ref ADCEx_Common_mode */
N  uint32_t DMAAccessMode;     /*!< Configures the Direct memory access mode for multi ADC mode.
N                                   This parameter can be a value of @ref ADCEx_Direct_memory_access_mode_for_multi_mode */
N  uint32_t TwoSamplingDelay;  /*!< Configures the Delay between 2 sampling phases.
N                                   This parameter can be a value of @ref ADC_delay_between_2_sampling_phases */
N}ADC_MultiModeTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup ADCEx_Exported_Constants ADC Exported Constants
N  * @{
N  */
N
N/** @defgroup ADCEx_Common_mode ADC Common Mode
N  * @{
N  */ 
N#define ADC_MODE_INDEPENDENT                  0x00000000U
N#define ADC_DUALMODE_REGSIMULT_INJECSIMULT    ((uint32_t)ADC_CCR_MULTI_0)
N#define ADC_DUALMODE_REGSIMULT_ALTERTRIG      ((uint32_t)ADC_CCR_MULTI_1)
N#define ADC_DUALMODE_INJECSIMULT              ((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_0))
N#define ADC_DUALMODE_REGSIMULT                ((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1))
N#define ADC_DUALMODE_INTERL                   ((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1 | ADC_CCR_MULTI_0))
N#define ADC_DUALMODE_ALTERTRIG                ((uint32_t)(ADC_CCR_MULTI_3 | ADC_CCR_MULTI_0))
N#define ADC_TRIPLEMODE_REGSIMULT_INJECSIMULT  ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_0))
N#define ADC_TRIPLEMODE_REGSIMULT_AlterTrig    ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_1))
N#define ADC_TRIPLEMODE_INJECSIMULT            ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_0))
N#define ADC_TRIPLEMODE_REGSIMULT              ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1))
N#define ADC_TRIPLEMODE_INTERL                 ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1 | ADC_CCR_MULTI_0))
N#define ADC_TRIPLEMODE_ALTERTRIG              ((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_3 | ADC_CCR_MULTI_0))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_Direct_memory_access_mode_for_multi_mode ADC Direct Memory Access Mode For Multi Mode
N  * @{
N  */ 
N#define ADC_DMAACCESSMODE_DISABLED  0x00000000U                /*!< DMA mode disabled */
N#define ADC_DMAACCESSMODE_1         ((uint32_t)ADC_CCR_DMA_0)  /*!< DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)*/
N#define ADC_DMAACCESSMODE_2         ((uint32_t)ADC_CCR_DMA_1)  /*!< DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)*/
N#define ADC_DMAACCESSMODE_3         ((uint32_t)ADC_CCR_DMA)    /*!< DMA mode 3 enabled (2 / 3 bytes by pairs - 2&1 then 1&3 then 3&2) */
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_External_trigger_edge_Injected ADC External Trigger Edge Injected
N  * @{
N  */ 
N#define ADC_EXTERNALTRIGINJECCONVEDGE_NONE           0x00000000U
N#define ADC_EXTERNALTRIGINJECCONVEDGE_RISING         ((uint32_t)ADC_CR2_JEXTEN_0)
N#define ADC_EXTERNALTRIGINJECCONVEDGE_FALLING        ((uint32_t)ADC_CR2_JEXTEN_1)
N#define ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING  ((uint32_t)ADC_CR2_JEXTEN)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_External_trigger_Source_Injected ADC External Trigger Source Injected
N  * @{
N  */ 
N#define ADC_EXTERNALTRIGINJECCONV_T1_CC4           0x00000000U
N#define ADC_EXTERNALTRIGINJECCONV_T1_TRGO          ((uint32_t)ADC_CR2_JEXTSEL_0)
N#define ADC_EXTERNALTRIGINJECCONV_T2_CC1           ((uint32_t)ADC_CR2_JEXTSEL_1)
N#define ADC_EXTERNALTRIGINJECCONV_T2_TRGO          ((uint32_t)(ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T3_CC2           ((uint32_t)ADC_CR2_JEXTSEL_2)
N#define ADC_EXTERNALTRIGINJECCONV_T3_CC4           ((uint32_t)(ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T4_CC1           ((uint32_t)(ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_1))
N#define ADC_EXTERNALTRIGINJECCONV_T4_CC2           ((uint32_t)(ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T4_CC3           ((uint32_t)ADC_CR2_JEXTSEL_3)
N#define ADC_EXTERNALTRIGINJECCONV_T4_TRGO          ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T5_CC4           ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_1))
N#define ADC_EXTERNALTRIGINJECCONV_T5_TRGO          ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T8_CC2           ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2))
N#define ADC_EXTERNALTRIGINJECCONV_T8_CC3           ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_0))
N#define ADC_EXTERNALTRIGINJECCONV_T8_CC4           ((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_1))
N#define ADC_EXTERNALTRIGINJECCONV_EXT_IT15         ((uint32_t)ADC_CR2_JEXTSEL)
N#define ADC_INJECTED_SOFTWARE_START                ((uint32_t)ADC_CR2_JEXTSEL + 1U)
N/**
N  * @}
N  */ 
N
N/** @defgroup ADCEx_injected_rank ADC Injected Rank
N  * @{
N  */ 
N#define ADC_INJECTED_RANK_1    0x00000001U
N#define ADC_INJECTED_RANK_2    0x00000002U
N#define ADC_INJECTED_RANK_3    0x00000003U
N#define ADC_INJECTED_RANK_4    0x00000004U
N/**
N  * @}
N  */
N
N/** @defgroup ADCEx_channels  ADC Specific Channels
N  * @{
N  */
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || \
N    defined(STM32F410Rx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || \
N    defined(STM32F412Cx)
X#if 0L || 0L || 0L || 0L ||     0L || 1L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L
N#define ADC_CHANNEL_TEMPSENSOR  ((uint32_t)ADC_CHANNEL_16)
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F410xx || STM32F412Zx ||
N          STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N#if defined(STM32F411xE) || defined(STM32F413xx) || defined(STM32F423xx) || defined(STM32F427xx) || defined(STM32F437xx) ||\
N    defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L || 0L 
S#define ADC_CHANNEL_DIFFERENCIATION_TEMPSENSOR_VBAT 0x10000000U /* Dummy bit for driver internal usage, not used in ADC channel setting registers CR1 or SQRx */
S#define ADC_CHANNEL_TEMPSENSOR  ((uint32_t)ADC_CHANNEL_18 | ADC_CHANNEL_DIFFERENCIATION_TEMPSENSOR_VBAT)
N#endif /* STM32F411xE || STM32F413xx || STM32F423xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */ 
N
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup ADC_Exported_Macros ADC Exported Macros
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx)
X#if 0L || 0L || 0L|| 0L
S/**
S  * @brief Disable internal path of ADC channel Vbat
S  * @note  Use case of this macro:
S  *        On devices STM32F42x and STM32F43x, ADC internal channels
S  *        Vbat and VrefInt share the same internal path, only
S  *        one of them can be enabled.This macro is to be used when ADC 
S  *        channels Vbat and VrefInt are selected, and must be called 
S  *        before starting conversion of ADC channel VrefInt in order 
S  *        to disable ADC channel Vbat.
S  * @retval None
S  */
S#define __HAL_ADC_PATH_INTERNAL_VBAT_DISABLE() (ADC->CCR &= ~(ADC_CCR_VBATE))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */
N/**
N  * @}
N  */ 
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup ADCEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup ADCEx_Exported_Functions_Group1
N  * @{
N  */
N
N/* I/O operation functions ******************************************************/
NHAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc);
Nuint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank);
NHAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length);
NHAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc);
Nuint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef* hadc);
Nvoid HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc);
N
N/* Peripheral Control functions *************************************************/
NHAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc,ADC_InjectionConfTypeDef* sConfigInjected);
NHAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup ADCEx_Private_Constants ADC Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup ADCEx_Private_Macros ADC Private Macros
N  * @{
N  */
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || \
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||     0L || 1L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
N#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_CHANNEL_18)
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE ||
N          STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||     0L || 0L || 0L
S#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) <= ADC_CHANNEL_18)  || \
S                                 ((CHANNEL) == ADC_CHANNEL_TEMPSENSOR))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) <= ADC_CHANNEL_18)  ||                                  ((CHANNEL) == ADC_CHANNEL_TEMPSENSOR))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#define IS_ADC_MODE(MODE) (((MODE) == ADC_MODE_INDEPENDENT)                 || \
N                           ((MODE) == ADC_DUALMODE_REGSIMULT_INJECSIMULT)   || \
N                           ((MODE) == ADC_DUALMODE_REGSIMULT_ALTERTRIG)     || \
N                           ((MODE) == ADC_DUALMODE_INJECSIMULT)             || \
N                           ((MODE) == ADC_DUALMODE_REGSIMULT)               || \
N                           ((MODE) == ADC_DUALMODE_INTERL)                  || \
N                           ((MODE) == ADC_DUALMODE_ALTERTRIG)               || \
N                           ((MODE) == ADC_TRIPLEMODE_REGSIMULT_INJECSIMULT) || \
N                           ((MODE) == ADC_TRIPLEMODE_REGSIMULT_AlterTrig)   || \
N                           ((MODE) == ADC_TRIPLEMODE_INJECSIMULT)           || \
N                           ((MODE) == ADC_TRIPLEMODE_REGSIMULT)             || \
N                           ((MODE) == ADC_TRIPLEMODE_INTERL)                || \
N                           ((MODE) == ADC_TRIPLEMODE_ALTERTRIG))
X#define IS_ADC_MODE(MODE) (((MODE) == ADC_MODE_INDEPENDENT)                 ||                            ((MODE) == ADC_DUALMODE_REGSIMULT_INJECSIMULT)   ||                            ((MODE) == ADC_DUALMODE_REGSIMULT_ALTERTRIG)     ||                            ((MODE) == ADC_DUALMODE_INJECSIMULT)             ||                            ((MODE) == ADC_DUALMODE_REGSIMULT)               ||                            ((MODE) == ADC_DUALMODE_INTERL)                  ||                            ((MODE) == ADC_DUALMODE_ALTERTRIG)               ||                            ((MODE) == ADC_TRIPLEMODE_REGSIMULT_INJECSIMULT) ||                            ((MODE) == ADC_TRIPLEMODE_REGSIMULT_AlterTrig)   ||                            ((MODE) == ADC_TRIPLEMODE_INJECSIMULT)           ||                            ((MODE) == ADC_TRIPLEMODE_REGSIMULT)             ||                            ((MODE) == ADC_TRIPLEMODE_INTERL)                ||                            ((MODE) == ADC_TRIPLEMODE_ALTERTRIG))
N#define IS_ADC_DMA_ACCESS_MODE(MODE) (((MODE) == ADC_DMAACCESSMODE_DISABLED) || \
N                                      ((MODE) == ADC_DMAACCESSMODE_1)        || \
N                                      ((MODE) == ADC_DMAACCESSMODE_2)        || \
N                                      ((MODE) == ADC_DMAACCESSMODE_3))
X#define IS_ADC_DMA_ACCESS_MODE(MODE) (((MODE) == ADC_DMAACCESSMODE_DISABLED) ||                                       ((MODE) == ADC_DMAACCESSMODE_1)        ||                                       ((MODE) == ADC_DMAACCESSMODE_2)        ||                                       ((MODE) == ADC_DMAACCESSMODE_3))
N#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_EXTERNALTRIGINJECCONVEDGE_NONE)    || \
N                                          ((EDGE) == ADC_EXTERNALTRIGINJECCONVEDGE_RISING)  || \
N                                          ((EDGE) == ADC_EXTERNALTRIGINJECCONVEDGE_FALLING) || \
N                                          ((EDGE) == ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING))
X#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_EXTERNALTRIGINJECCONVEDGE_NONE)    ||                                           ((EDGE) == ADC_EXTERNALTRIGINJECCONVEDGE_RISING)  ||                                           ((EDGE) == ADC_EXTERNALTRIGINJECCONVEDGE_FALLING) ||                                           ((EDGE) == ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING))
N#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T1_CC4)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T1_TRGO) || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T2_CC1)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T2_TRGO) || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T3_CC2)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T3_CC4)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T4_CC1)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T4_CC2)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T4_CC3)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T4_TRGO) || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T5_CC4)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T5_TRGO) || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T8_CC2)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T8_CC3)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T8_CC4)  || \
N                                        ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_EXT_IT15)|| \
N                                        ((INJTRIG) == ADC_INJECTED_SOFTWARE_START))
X#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T1_CC4)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T1_TRGO) ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T2_CC1)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T2_TRGO) ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T3_CC2)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T3_CC4)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T4_CC1)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T4_CC2)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T4_CC3)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T4_TRGO) ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T5_CC4)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T5_TRGO) ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T8_CC2)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T8_CC3)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_T8_CC4)  ||                                         ((INJTRIG) == ADC_EXTERNALTRIGINJECCONV_EXT_IT15)||                                         ((INJTRIG) == ADC_INJECTED_SOFTWARE_START))
N#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 1U) && ((LENGTH) <= 4U))
N#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 1U) && ((RANK) <= 4U))
N
N/**
N  * @brief  Set the selected injected Channel rank.
N  * @param  _CHANNELNB_ Channel number.
N  * @param  _RANKNB_ Rank number. 
N  * @param  _JSQR_JL_ Sequence length.
N  * @retval None
N  */
N#define   ADC_JSQR(_CHANNELNB_, _RANKNB_, _JSQR_JL_)  (((uint32_t)((uint16_t)(_CHANNELNB_))) << (5U * (uint8_t)(((_RANKNB_) + 3U) - (_JSQR_JL_))))
N
N/**
N  * @brief Defines if the selected ADC is within ADC common register ADC123 or ADC1
N  * if available (ADC2, ADC3 availability depends on STM32 product)
N  * @param __HANDLE__ ADC handle
N  * @retval Common control register ADC123 or ADC1
N  */
N#if defined(STM32F405xx) || defined(STM32F407xx) || defined(STM32F415xx) || defined(STM32F417xx) || defined(STM32F427xx) || defined(STM32F429xx) || defined(STM32F437xx) || defined(STM32F439xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L
S#define ADC_COMMON_REGISTER(__HANDLE__)                ADC123_COMMON
N#else
N#define ADC_COMMON_REGISTER(__HANDLE__)                ADC1_COMMON
N#endif /* STM32F405xx || STM32F407xx || STM32F415xx || STM32F417xx || STM32F427xx || STM32F429xx || STM32F437xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup ADCEx_Private_Functions ADC Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_ADC_EX_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 553 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_adc.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup ADC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup ADC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions ***********************************/
NHAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef *hadc);
Nvoid HAL_ADC_MspInit(ADC_HandleTypeDef* hadc);
Nvoid HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc);
N
N#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
S/* Callbacks Register/UnRegister functions  ***********************************/
SHAL_StatusTypeDef HAL_ADC_RegisterCallback(ADC_HandleTypeDef *hadc, HAL_ADC_CallbackIDTypeDef CallbackID, pADC_CallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_ADC_UnRegisterCallback(ADC_HandleTypeDef *hadc, HAL_ADC_CallbackIDTypeDef CallbackID);
N#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @addtogroup ADC_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions ******************************************************/
NHAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout);
N
NHAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout);
N
NHAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc);
NHAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc);
N
Nvoid HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc);
N
NHAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length);
NHAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc);
N
Nuint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc);
N
Nvoid HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc);
Nvoid HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc);
Nvoid HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc);
Nvoid HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc);
N/**
N  * @}
N  */
N
N/** @addtogroup ADC_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral Control functions *************************************************/
NHAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig);
NHAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig);
N/**
N  * @}
N  */
N
N/** @addtogroup ADC_Exported_Functions_Group4
N  * @{
N  */
N/* Peripheral State functions ***************************************************/
Nuint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc);
Nuint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup ADC_Private_Constants ADC Private Constants
N  * @{
N  */
N/* Delay for ADC stabilization time.                                        */
N/* Maximum delay is 1us (refer to device datasheet, parameter tSTAB).       */
N/* Unit: us                                                                 */
N#define ADC_STAB_DELAY_US               3U
N/* Delay for temperature sensor stabilization time.                         */
N/* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */
N/* Unit: us                                                                 */
N#define ADC_TEMPSENSOR_DELAY_US         10U
N/**
N  * @}
N  */
N
N/* Private macro ------------------------------------------------------------*/
N
N/** @defgroup ADC_Private_Macros ADC Private Macros
N  * @{
N  */
N/* Macro reserved for internal HAL driver usage, not intended to be used in
N   code of final user */
N
N/**
N  * @brief Verification of ADC state: enabled or disabled
N  * @param __HANDLE__ ADC handle
N  * @retval SET (ADC enabled) or RESET (ADC disabled)
N  */
N#define ADC_IS_ENABLE(__HANDLE__)                                              \
N  ((( ((__HANDLE__)->Instance->SR & ADC_SR_ADONS) == ADC_SR_ADONS )            \
N  ) ? SET : RESET)
X#define ADC_IS_ENABLE(__HANDLE__)                                                ((( ((__HANDLE__)->Instance->SR & ADC_SR_ADONS) == ADC_SR_ADONS )              ) ? SET : RESET)
N
N/**
N  * @brief Test if conversion trigger of regular group is software start
N  *        or external trigger.
N  * @param __HANDLE__ ADC handle
N  * @retval SET (software start) or RESET (external trigger)
N  */
N#define ADC_IS_SOFTWARE_START_REGULAR(__HANDLE__)                              \
N  (((__HANDLE__)->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
X#define ADC_IS_SOFTWARE_START_REGULAR(__HANDLE__)                                (((__HANDLE__)->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
N
N/**
N  * @brief Test if conversion trigger of injected group is software start
N  *        or external trigger.
N  * @param __HANDLE__ ADC handle
N  * @retval SET (software start) or RESET (external trigger)
N  */
N#define ADC_IS_SOFTWARE_START_INJECTED(__HANDLE__)                             \
N  (((__HANDLE__)->Instance->CR2 & ADC_CR2_JEXTEN) == RESET)
X#define ADC_IS_SOFTWARE_START_INJECTED(__HANDLE__)                               (((__HANDLE__)->Instance->CR2 & ADC_CR2_JEXTEN) == RESET)
N
N/**
N  * @brief Simultaneously clears and sets specific bits of the handle State
N  * @note: ADC_STATE_CLR_SET() macro is merely aliased to generic macro MODIFY_REG(),
N  *        the first parameter is the ADC handle State, the second parameter is the
N  *        bit field to clear, the third and last parameter is the bit field to set.
N  * @retval None
N  */
N#define ADC_STATE_CLR_SET MODIFY_REG
N
N/**
N  * @brief Clear ADC error code (set it to error code: "no error")
N  * @param __HANDLE__ ADC handle
N  * @retval None
N  */
N#define ADC_CLEAR_ERRORCODE(__HANDLE__)                                        \
N  ((__HANDLE__)->ErrorCode = HAL_ADC_ERROR_NONE)
X#define ADC_CLEAR_ERRORCODE(__HANDLE__)                                          ((__HANDLE__)->ErrorCode = HAL_ADC_ERROR_NONE)
N
N    
N#define IS_ADC_CLOCKPRESCALER(ADC_CLOCK)     (((ADC_CLOCK) == ADC_CLOCK_SYNC_PCLK_DIV2) || \
N                                              ((ADC_CLOCK) == ADC_CLOCK_SYNC_PCLK_DIV4) || \
N                                              ((ADC_CLOCK) == ADC_CLOCK_SYNC_PCLK_DIV6) || \
N                                              ((ADC_CLOCK) == ADC_CLOCK_SYNC_PCLK_DIV8))
X#define IS_ADC_CLOCKPRESCALER(ADC_CLOCK)     (((ADC_CLOCK) == ADC_CLOCK_SYNC_PCLK_DIV2) ||                                               ((ADC_CLOCK) == ADC_CLOCK_SYNC_PCLK_DIV4) ||                                               ((ADC_CLOCK) == ADC_CLOCK_SYNC_PCLK_DIV6) ||                                               ((ADC_CLOCK) == ADC_CLOCK_SYNC_PCLK_DIV8))
N#define IS_ADC_SAMPLING_DELAY(DELAY) (((DELAY) == ADC_TWOSAMPLINGDELAY_5CYCLES)  || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_6CYCLES)  || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_7CYCLES)  || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_8CYCLES)  || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_9CYCLES)  || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_10CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_11CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_12CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_13CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_14CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_15CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_16CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_17CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_18CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_19CYCLES) || \
N                                      ((DELAY) == ADC_TWOSAMPLINGDELAY_20CYCLES))
X#define IS_ADC_SAMPLING_DELAY(DELAY) (((DELAY) == ADC_TWOSAMPLINGDELAY_5CYCLES)  ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_6CYCLES)  ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_7CYCLES)  ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_8CYCLES)  ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_9CYCLES)  ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_10CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_11CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_12CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_13CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_14CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_15CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_16CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_17CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_18CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_19CYCLES) ||                                       ((DELAY) == ADC_TWOSAMPLINGDELAY_20CYCLES))
N#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_RESOLUTION_12B) || \
N                                       ((RESOLUTION) == ADC_RESOLUTION_10B) || \
N                                       ((RESOLUTION) == ADC_RESOLUTION_8B)  || \
N                                       ((RESOLUTION) == ADC_RESOLUTION_6B))
X#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_RESOLUTION_12B) ||                                        ((RESOLUTION) == ADC_RESOLUTION_10B) ||                                        ((RESOLUTION) == ADC_RESOLUTION_8B)  ||                                        ((RESOLUTION) == ADC_RESOLUTION_6B))
N#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_EXTERNALTRIGCONVEDGE_NONE)    || \
N                                    ((EDGE) == ADC_EXTERNALTRIGCONVEDGE_RISING)  || \
N                                    ((EDGE) == ADC_EXTERNALTRIGCONVEDGE_FALLING) || \
N                                    ((EDGE) == ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING))
X#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_EXTERNALTRIGCONVEDGE_NONE)    ||                                     ((EDGE) == ADC_EXTERNALTRIGCONVEDGE_RISING)  ||                                     ((EDGE) == ADC_EXTERNALTRIGCONVEDGE_FALLING) ||                                     ((EDGE) == ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING))
N#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_EXTERNALTRIGCONV_T1_CC1)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T1_CC2)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T1_CC3)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T2_CC2)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T2_CC3)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T2_CC4)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T2_TRGO) || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T3_CC1)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T3_TRGO) || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T4_CC4)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T5_CC1)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T5_CC2)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T5_CC3)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T8_CC1)  || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_T8_TRGO) || \
N                                  ((REGTRIG) == ADC_EXTERNALTRIGCONV_Ext_IT11)|| \
N                                  ((REGTRIG) == ADC_SOFTWARE_START))
X#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_EXTERNALTRIGCONV_T1_CC1)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T1_CC2)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T1_CC3)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T2_CC2)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T2_CC3)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T2_CC4)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T2_TRGO) ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T3_CC1)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T3_TRGO) ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T4_CC4)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T5_CC1)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T5_CC2)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T5_CC3)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T8_CC1)  ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_T8_TRGO) ||                                   ((REGTRIG) == ADC_EXTERNALTRIGCONV_Ext_IT11)||                                   ((REGTRIG) == ADC_SOFTWARE_START))
N#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DATAALIGN_RIGHT) || \
N                                  ((ALIGN) == ADC_DATAALIGN_LEFT))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DATAALIGN_RIGHT) ||                                   ((ALIGN) == ADC_DATAALIGN_LEFT))
N#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SAMPLETIME_3CYCLES)   || \
N                                  ((TIME) == ADC_SAMPLETIME_15CYCLES)  || \
N                                  ((TIME) == ADC_SAMPLETIME_28CYCLES)  || \
N                                  ((TIME) == ADC_SAMPLETIME_56CYCLES)  || \
N                                  ((TIME) == ADC_SAMPLETIME_84CYCLES)  || \
N                                  ((TIME) == ADC_SAMPLETIME_112CYCLES) || \
N                                  ((TIME) == ADC_SAMPLETIME_144CYCLES) || \
N                                  ((TIME) == ADC_SAMPLETIME_480CYCLES))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SAMPLETIME_3CYCLES)   ||                                   ((TIME) == ADC_SAMPLETIME_15CYCLES)  ||                                   ((TIME) == ADC_SAMPLETIME_28CYCLES)  ||                                   ((TIME) == ADC_SAMPLETIME_56CYCLES)  ||                                   ((TIME) == ADC_SAMPLETIME_84CYCLES)  ||                                   ((TIME) == ADC_SAMPLETIME_112CYCLES) ||                                   ((TIME) == ADC_SAMPLETIME_144CYCLES) ||                                   ((TIME) == ADC_SAMPLETIME_480CYCLES))
N#define IS_ADC_EOCSelection(EOCSelection) (((EOCSelection) == ADC_EOC_SINGLE_CONV)   || \
N                                           ((EOCSelection) == ADC_EOC_SEQ_CONV)  || \
N                                           ((EOCSelection) == ADC_EOC_SINGLE_SEQ_CONV))
X#define IS_ADC_EOCSelection(EOCSelection) (((EOCSelection) == ADC_EOC_SINGLE_CONV)   ||                                            ((EOCSelection) == ADC_EOC_SEQ_CONV)  ||                                            ((EOCSelection) == ADC_EOC_SINGLE_SEQ_CONV))
N#define IS_ADC_EVENT_TYPE(EVENT) (((EVENT) == ADC_AWD_EVENT) || \
N                                  ((EVENT) == ADC_OVR_EVENT))
X#define IS_ADC_EVENT_TYPE(EVENT) (((EVENT) == ADC_AWD_EVENT) ||                                   ((EVENT) == ADC_OVR_EVENT))
N#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_ANALOGWATCHDOG_SINGLE_REG)        || \
N                                          ((WATCHDOG) == ADC_ANALOGWATCHDOG_SINGLE_INJEC)      || \
N                                          ((WATCHDOG) == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)   || \
N                                          ((WATCHDOG) == ADC_ANALOGWATCHDOG_ALL_REG)           || \
N                                          ((WATCHDOG) == ADC_ANALOGWATCHDOG_ALL_INJEC)         || \
N                                          ((WATCHDOG) == ADC_ANALOGWATCHDOG_ALL_REGINJEC)      || \
N                                          ((WATCHDOG) == ADC_ANALOGWATCHDOG_NONE))
X#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_ANALOGWATCHDOG_SINGLE_REG)        ||                                           ((WATCHDOG) == ADC_ANALOGWATCHDOG_SINGLE_INJEC)      ||                                           ((WATCHDOG) == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)   ||                                           ((WATCHDOG) == ADC_ANALOGWATCHDOG_ALL_REG)           ||                                           ((WATCHDOG) == ADC_ANALOGWATCHDOG_ALL_INJEC)         ||                                           ((WATCHDOG) == ADC_ANALOGWATCHDOG_ALL_REGINJEC)      ||                                           ((WATCHDOG) == ADC_ANALOGWATCHDOG_NONE))
N#define IS_ADC_CHANNELS_TYPE(CHANNEL_TYPE) (((CHANNEL_TYPE) == ADC_ALL_CHANNELS) || \
N                                            ((CHANNEL_TYPE) == ADC_REGULAR_CHANNELS) || \
N                                            ((CHANNEL_TYPE) == ADC_INJECTED_CHANNELS))
X#define IS_ADC_CHANNELS_TYPE(CHANNEL_TYPE) (((CHANNEL_TYPE) == ADC_ALL_CHANNELS) ||                                             ((CHANNEL_TYPE) == ADC_REGULAR_CHANNELS) ||                                             ((CHANNEL_TYPE) == ADC_INJECTED_CHANNELS))
N#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFFU)
N
N#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 1U) && ((LENGTH) <= 16U))
N#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 1U) && ((RANK) <= (16U)))
N#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 1U) && ((NUMBER) <= 8U))
N#define IS_ADC_RANGE(RESOLUTION, ADC_VALUE)                                     \
N   ((((RESOLUTION) == ADC_RESOLUTION_12B) && ((ADC_VALUE) <= 0x0FFFU)) || \
N    (((RESOLUTION) == ADC_RESOLUTION_10B) && ((ADC_VALUE) <= 0x03FFU)) || \
N    (((RESOLUTION) == ADC_RESOLUTION_8B)  && ((ADC_VALUE) <= 0x00FFU)) || \
N    (((RESOLUTION) == ADC_RESOLUTION_6B)  && ((ADC_VALUE) <= 0x003FU)))
X#define IS_ADC_RANGE(RESOLUTION, ADC_VALUE)                                        ((((RESOLUTION) == ADC_RESOLUTION_12B) && ((ADC_VALUE) <= 0x0FFFU)) ||     (((RESOLUTION) == ADC_RESOLUTION_10B) && ((ADC_VALUE) <= 0x03FFU)) ||     (((RESOLUTION) == ADC_RESOLUTION_8B)  && ((ADC_VALUE) <= 0x00FFU)) ||     (((RESOLUTION) == ADC_RESOLUTION_6B)  && ((ADC_VALUE) <= 0x003FU)))
N
N/**
N  * @brief  Set ADC Regular channel sequence length.
N  * @param  _NbrOfConversion_ Regular channel sequence length. 
N  * @retval None
N  */
N#define ADC_SQR1(_NbrOfConversion_) (((_NbrOfConversion_) - (uint8_t)1U) << 20U)
N
N/**
N  * @brief  Set the ADC's sample time for channel numbers between 10 and 18.
N  * @param  _SAMPLETIME_ Sample time parameter.
N  * @param  _CHANNELNB_ Channel number.  
N  * @retval None
N  */
N#define ADC_SMPR1(_SAMPLETIME_, _CHANNELNB_) ((_SAMPLETIME_) << (3U * (((uint32_t)((uint16_t)(_CHANNELNB_))) - 10U)))
N
N/**
N  * @brief  Set the ADC's sample time for channel numbers between 0 and 9.
N  * @param  _SAMPLETIME_ Sample time parameter.
N  * @param  _CHANNELNB_ Channel number.  
N  * @retval None
N  */
N#define ADC_SMPR2(_SAMPLETIME_, _CHANNELNB_) ((_SAMPLETIME_) << (3U * ((uint32_t)((uint16_t)(_CHANNELNB_)))))
N
N/**
N  * @brief  Set the selected regular channel rank for rank between 1 and 6.
N  * @param  _CHANNELNB_ Channel number.
N  * @param  _RANKNB_ Rank number.    
N  * @retval None
N  */
N#define ADC_SQR3_RK(_CHANNELNB_, _RANKNB_) (((uint32_t)((uint16_t)(_CHANNELNB_))) << (5U * ((_RANKNB_) - 1U)))
N
N/**
N  * @brief  Set the selected regular channel rank for rank between 7 and 12.
N  * @param  _CHANNELNB_ Channel number.
N  * @param  _RANKNB_ Rank number.    
N  * @retval None
N  */
N#define ADC_SQR2_RK(_CHANNELNB_, _RANKNB_) (((uint32_t)((uint16_t)(_CHANNELNB_))) << (5U * ((_RANKNB_) - 7U)))
N
N/**
N  * @brief  Set the selected regular channel rank for rank between 13 and 16.
N  * @param  _CHANNELNB_ Channel number.
N  * @param  _RANKNB_ Rank number.    
N  * @retval None
N  */
N#define ADC_SQR1_RK(_CHANNELNB_, _RANKNB_) (((uint32_t)((uint16_t)(_CHANNELNB_))) << (5U * ((_RANKNB_) - 13U)))
N
N/**
N  * @brief  Enable ADC continuous conversion mode.
N  * @param  _CONTINUOUS_MODE_ Continuous mode.
N  * @retval None
N  */
N#define ADC_CR2_CONTINUOUS(_CONTINUOUS_MODE_) ((_CONTINUOUS_MODE_) << 1U)
N
N/**
N  * @brief  Configures the number of discontinuous conversions for the regular group channels.
N  * @param  _NBR_DISCONTINUOUSCONV_ Number of discontinuous conversions.
N  * @retval None
N  */
N#define ADC_CR1_DISCONTINUOUS(_NBR_DISCONTINUOUSCONV_) (((_NBR_DISCONTINUOUSCONV_) - 1U) << ADC_CR1_DISCNUM_Pos)
N
N/**
N  * @brief  Enable ADC scan mode.
N  * @param  _SCANCONV_MODE_ Scan conversion mode.
N  * @retval None
N  */
N#define ADC_CR1_SCANCONV(_SCANCONV_MODE_) ((_SCANCONV_MODE_) << 8U)
N
N/**
N  * @brief  Enable the ADC end of conversion selection.
N  * @param  _EOCSelection_MODE_ End of conversion selection mode.
N  * @retval None
N  */
N#define ADC_CR2_EOCSelection(_EOCSelection_MODE_) ((_EOCSelection_MODE_) << 10U)
N
N/**
N  * @brief  Enable the ADC DMA continuous request.
N  * @param  _DMAContReq_MODE_ DMA continuous request mode.
N  * @retval None
N  */
N#define ADC_CR2_DMAContReq(_DMAContReq_MODE_) ((_DMAContReq_MODE_) << 9U)
N
N/**
N  * @brief Return resolution bits in CR1 register.
N  * @param __HANDLE__ ADC handle
N  * @retval None
N  */
N#define ADC_GET_RESOLUTION(__HANDLE__) (((__HANDLE__)->Instance->CR1) & ADC_CR1_RES)
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup ADC_Private_Functions ADC Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_ADC_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 219 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_ADC_MODULE_ENABLED */
N
N#ifdef HAL_CAN_MODULE_ENABLED
S#include "stm32f4xx_hal_can.h"
N#endif /* HAL_CAN_MODULE_ENABLED */
N
N#ifdef HAL_CAN_LEGACY_MODULE_ENABLED
S#include "Legacy/stm32f4xx_hal_can_legacy.h"
N#endif /* HAL_CAN_LEGACY_MODULE_ENABLED */
N
N#ifdef HAL_COMP_MODULE_ENABLED
S#include "stm32f4xx_hal_comp.h"
N#endif /* HAL_COMP_MODULE_ENABLED */
N
N#ifdef HAL_CRC_MODULE_ENABLED
N#include "stm32f4xx_hal_crc.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_crc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_crc.h
N  * @author  MCD Application Team
N  * @brief   Header file of CRC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32F4xx_HAL_CRC_H
N#define STM32F4xx_HAL_CRC_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup CRC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup CRC_Exported_Types CRC Exported Types
N  * @{
N  */
N
N/**
N  * @brief  CRC HAL State Structure definition
N  */
Ntypedef enum
N{
N  HAL_CRC_STATE_RESET     = 0x00U,  /*!< CRC not yet initialized or disabled */
N  HAL_CRC_STATE_READY     = 0x01U,  /*!< CRC initialized and ready for use   */
N  HAL_CRC_STATE_BUSY      = 0x02U,  /*!< CRC internal process is ongoing     */
N  HAL_CRC_STATE_TIMEOUT   = 0x03U,  /*!< CRC timeout state                   */
N  HAL_CRC_STATE_ERROR     = 0x04U   /*!< CRC error state                     */
N} HAL_CRC_StateTypeDef;
N
N
N/**
N  * @brief  CRC Handle Structure definition
N  */
Ntypedef struct
N{
N  CRC_TypeDef                 *Instance;   /*!< Register base address        */
N
N  HAL_LockTypeDef             Lock;        /*!< CRC Locking object           */
N
N  __IO HAL_CRC_StateTypeDef   State;       /*!< CRC communication state      */
X  volatile HAL_CRC_StateTypeDef   State;        
N
N} CRC_HandleTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup CRC_Exported_Constants CRC Exported Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup CRC_Exported_Macros CRC Exported Macros
N  * @{
N  */
N
N/** @brief Reset CRC handle state.
N  * @param  __HANDLE__ CRC handle.
N  * @retval None
N  */
N#define __HAL_CRC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_CRC_STATE_RESET)
N
N/**
N  * @brief  Reset CRC Data Register.
N  * @param  __HANDLE__ CRC handle
N  * @retval None
N  */
N#define __HAL_CRC_DR_RESET(__HANDLE__) ((__HANDLE__)->Instance->CR |= CRC_CR_RESET)
N
N/**
N  * @brief Store data in the Independent Data (ID) register.
N  * @param __HANDLE__ CRC handle
N  * @param __VALUE__  Value to be stored in the ID register
N  * @note  Refer to the Reference Manual to get the authorized __VALUE__ length in bits
N  * @retval None
N  */
N#define __HAL_CRC_SET_IDR(__HANDLE__, __VALUE__) (WRITE_REG((__HANDLE__)->Instance->IDR, (__VALUE__)))
N
N/**
N  * @brief Return the data stored in the Independent Data (ID) register.
N  * @param __HANDLE__ CRC handle
N  * @note  Refer to the Reference Manual to get the authorized __VALUE__ length in bits
N  * @retval Value of the ID register
N  */
N#define __HAL_CRC_GET_IDR(__HANDLE__) (((__HANDLE__)->Instance->IDR) & CRC_IDR_IDR)
N/**
N  * @}
N  */
N
N
N/* Private macros --------------------------------------------------------*/
N/** @defgroup  CRC_Private_Macros CRC Private Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup CRC_Exported_Functions CRC Exported Functions
N  * @{
N  */
N
N/* Initialization and de-initialization functions  ****************************/
N/** @defgroup CRC_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
NHAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc);
NHAL_StatusTypeDef HAL_CRC_DeInit(CRC_HandleTypeDef *hcrc);
Nvoid HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc);
Nvoid HAL_CRC_MspDeInit(CRC_HandleTypeDef *hcrc);
N/**
N  * @}
N  */
N
N/* Peripheral Control functions ***********************************************/
N/** @defgroup CRC_Exported_Functions_Group2 Peripheral Control functions
N  * @{
N  */
Nuint32_t HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength);
Nuint32_t HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength);
N/**
N  * @}
N  */
N
N/* Peripheral State and Error functions ***************************************/
N/** @defgroup CRC_Exported_Functions_Group3 Peripheral State functions
N  * @{
N  */
NHAL_CRC_StateTypeDef HAL_CRC_GetState(CRC_HandleTypeDef *hcrc);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32F4xx_HAL_CRC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 235 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_CRC_MODULE_ENABLED */
N
N#ifdef HAL_CRYP_MODULE_ENABLED
S#include "stm32f4xx_hal_cryp.h"
N#endif /* HAL_CRYP_MODULE_ENABLED */
N
N#ifdef HAL_DAC_MODULE_ENABLED
S#include "stm32f4xx_hal_dac.h"
N#endif /* HAL_DAC_MODULE_ENABLED */
N
N#ifdef HAL_FIREWALL_MODULE_ENABLED
S#include "stm32f4xx_hal_firewall.h"
N#endif /* HAL_FIREWALL_MODULE_ENABLED */
N
N#ifdef HAL_FLASH_MODULE_ENABLED
N#include "stm32f4xx_hal_flash.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_flash.h
N  * @author  MCD Application Team
N  * @brief   Header file of FLASH HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_FLASH_H
N#define __STM32F4xx_HAL_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FLASH
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Types FLASH Exported Types
N  * @{
N  */
N 
N/**
N  * @brief  FLASH Procedure structure definition
N  */
Ntypedef enum 
N{
N  FLASH_PROC_NONE = 0U, 
N  FLASH_PROC_SECTERASE,
N  FLASH_PROC_MASSERASE,
N  FLASH_PROC_PROGRAM
N} FLASH_ProcedureTypeDef;
N
N/** 
N  * @brief  FLASH handle Structure definition  
N  */
Ntypedef struct
N{
N  __IO FLASH_ProcedureTypeDef ProcedureOnGoing;   /*Internal variable to indicate which procedure is ongoing or not in IT context*/
X  volatile FLASH_ProcedureTypeDef ProcedureOnGoing;    
N  
N  __IO uint32_t               NbSectorsToErase;   /*Internal variable to save the remaining sectors to erase in IT context*/
X  volatile uint32_t               NbSectorsToErase;    
N  
N  __IO uint8_t                VoltageForErase;    /*Internal variable to provide voltage range selected by user in IT context*/
X  volatile uint8_t                VoltageForErase;     
N  
N  __IO uint32_t               Sector;             /*Internal variable to define the current sector which is erasing*/
X  volatile uint32_t               Sector;              
N  
N  __IO uint32_t               Bank;               /*Internal variable to save current bank selected during mass erase*/
X  volatile uint32_t               Bank;                
N  
N  __IO uint32_t               Address;            /*Internal variable to save address selected for program*/
X  volatile uint32_t               Address;             
N  
N  HAL_LockTypeDef             Lock;               /* FLASH locking object                */
N
N  __IO uint32_t               ErrorCode;          /* FLASH error code                    */
X  volatile uint32_t               ErrorCode;           
N
N}FLASH_ProcessTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Constants FLASH Exported Constants
N  * @{
N  */  
N/** @defgroup FLASH_Error_Code FLASH Error Code
N  * @brief    FLASH Error Code 
N  * @{
N  */ 
N#define HAL_FLASH_ERROR_NONE         0x00000000U    /*!< No error                      */
N#define HAL_FLASH_ERROR_RD           0x00000001U    /*!< Read Protection error         */
N#define HAL_FLASH_ERROR_PGS          0x00000002U    /*!< Programming Sequence error    */
N#define HAL_FLASH_ERROR_PGP          0x00000004U    /*!< Programming Parallelism error */
N#define HAL_FLASH_ERROR_PGA          0x00000008U    /*!< Programming Alignment error   */
N#define HAL_FLASH_ERROR_WRP          0x00000010U    /*!< Write protection error        */
N#define HAL_FLASH_ERROR_OPERATION    0x00000020U    /*!< Operation Error               */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Type_Program FLASH Type Program
N  * @{
N  */ 
N#define FLASH_TYPEPROGRAM_BYTE        0x00000000U  /*!< Program byte (8-bit) at a specified address           */
N#define FLASH_TYPEPROGRAM_HALFWORD    0x00000001U  /*!< Program a half-word (16-bit) at a specified address   */
N#define FLASH_TYPEPROGRAM_WORD        0x00000002U  /*!< Program a word (32-bit) at a specified address        */
N#define FLASH_TYPEPROGRAM_DOUBLEWORD  0x00000003U  /*!< Program a double word (64-bit) at a specified address */
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Flag_definition FLASH Flag definition
N  * @brief Flag definition
N  * @{
N  */ 
N#define FLASH_FLAG_EOP                 FLASH_SR_EOP            /*!< FLASH End of Operation flag               */
N#define FLASH_FLAG_OPERR               FLASH_SR_SOP            /*!< FLASH operation Error flag                */
N#define FLASH_FLAG_WRPERR              FLASH_SR_WRPERR         /*!< FLASH Write protected error flag          */
N#define FLASH_FLAG_PGAERR              FLASH_SR_PGAERR         /*!< FLASH Programming Alignment error flag    */
N#define FLASH_FLAG_PGPERR              FLASH_SR_PGPERR         /*!< FLASH Programming Parallelism error flag  */
N#define FLASH_FLAG_PGSERR              FLASH_SR_PGSERR         /*!< FLASH Programming Sequence error flag     */
N#if defined(FLASH_SR_RDERR)
X#if 1L
N#define FLASH_FLAG_RDERR               FLASH_SR_RDERR          /*!< Read Protection error flag (PCROP)        */
N#endif /* FLASH_SR_RDERR */
N#define FLASH_FLAG_BSY                 FLASH_SR_BSY            /*!< FLASH Busy flag                           */ 
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Interrupt_definition FLASH Interrupt definition
N  * @brief FLASH Interrupt definition
N  * @{
N  */ 
N#define FLASH_IT_EOP                   FLASH_CR_EOPIE          /*!< End of FLASH Operation Interrupt source */
N#define FLASH_IT_ERR                   0x02000000U             /*!< Error Interrupt source                  */
N/**
N  * @}
N  */  
N
N/** @defgroup FLASH_Program_Parallelism FLASH Program Parallelism
N  * @{
N  */
N#define FLASH_PSIZE_BYTE           0x00000000U
N#define FLASH_PSIZE_HALF_WORD      0x00000100U
N#define FLASH_PSIZE_WORD           0x00000200U
N#define FLASH_PSIZE_DOUBLE_WORD    0x00000300U
N#define CR_PSIZE_MASK              0xFFFFFCFFU
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Keys FLASH Keys
N  * @{
N  */ 
N#define RDP_KEY                  ((uint16_t)0x00A5)
N#define FLASH_KEY1               0x45670123U
N#define FLASH_KEY2               0xCDEF89ABU
N#define FLASH_OPT_KEY1           0x08192A3BU
N#define FLASH_OPT_KEY2           0x4C5D6E7FU
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Macros FLASH Exported Macros
N  * @{
N  */
N/**
N  * @brief  Set the FLASH Latency.
N  * @param  __LATENCY__ FLASH Latency
N  *         The value of this parameter depend on device used within the same series
N  * @retval none
N  */ 
N#define __HAL_FLASH_SET_LATENCY(__LATENCY__) (*(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)(__LATENCY__))
N
N/**
N  * @brief  Get the FLASH Latency.
N  * @retval FLASH Latency
N  *          The value of this parameter depend on device used within the same series
N  */ 
N#define __HAL_FLASH_GET_LATENCY()     (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY))
N
N/**
N  * @brief  Enable the FLASH prefetch buffer.
N  * @retval none
N  */ 
N#define __HAL_FLASH_PREFETCH_BUFFER_ENABLE()  (FLASH->ACR |= FLASH_ACR_PRFTEN)
N
N/**
N  * @brief  Disable the FLASH prefetch buffer.
N  * @retval none
N  */ 
N#define __HAL_FLASH_PREFETCH_BUFFER_DISABLE()   (FLASH->ACR &= (~FLASH_ACR_PRFTEN))
N
N/**
N  * @brief  Enable the FLASH instruction cache.
N  * @retval none
N  */ 
N#define __HAL_FLASH_INSTRUCTION_CACHE_ENABLE()  (FLASH->ACR |= FLASH_ACR_ICEN)
N
N/**
N  * @brief  Disable the FLASH instruction cache.
N  * @retval none
N  */ 
N#define __HAL_FLASH_INSTRUCTION_CACHE_DISABLE()   (FLASH->ACR &= (~FLASH_ACR_ICEN))
N
N/**
N  * @brief  Enable the FLASH data cache.
N  * @retval none
N  */ 
N#define __HAL_FLASH_DATA_CACHE_ENABLE()  (FLASH->ACR |= FLASH_ACR_DCEN)
N
N/**
N  * @brief  Disable the FLASH data cache.
N  * @retval none
N  */ 
N#define __HAL_FLASH_DATA_CACHE_DISABLE()   (FLASH->ACR &= (~FLASH_ACR_DCEN))
N
N/**
N  * @brief  Resets the FLASH instruction Cache.
N  * @note   This function must be used only when the Instruction Cache is disabled.  
N  * @retval None
N  */
N#define __HAL_FLASH_INSTRUCTION_CACHE_RESET() do {FLASH->ACR |= FLASH_ACR_ICRST;  \
N                                                  FLASH->ACR &= ~FLASH_ACR_ICRST; \
N                                                 }while(0U)
X#define __HAL_FLASH_INSTRUCTION_CACHE_RESET() do {FLASH->ACR |= FLASH_ACR_ICRST;                                                    FLASH->ACR &= ~FLASH_ACR_ICRST;                                                  }while(0U)
N
N/**
N  * @brief  Resets the FLASH data Cache.
N  * @note   This function must be used only when the data Cache is disabled.  
N  * @retval None
N  */
N#define __HAL_FLASH_DATA_CACHE_RESET() do {FLASH->ACR |= FLASH_ACR_DCRST;  \
N                                           FLASH->ACR &= ~FLASH_ACR_DCRST; \
N                                          }while(0U)
X#define __HAL_FLASH_DATA_CACHE_RESET() do {FLASH->ACR |= FLASH_ACR_DCRST;                                             FLASH->ACR &= ~FLASH_ACR_DCRST;                                           }while(0U)
N/**
N  * @brief  Enable the specified FLASH interrupt.
N  * @param  __INTERRUPT__  FLASH interrupt 
N  *         This parameter can be any combination of the following values:
N  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
N  *     @arg FLASH_IT_ERR: Error Interrupt    
N  * @retval none
N  */  
N#define __HAL_FLASH_ENABLE_IT(__INTERRUPT__)  (FLASH->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified FLASH interrupt.
N  * @param  __INTERRUPT__  FLASH interrupt 
N  *         This parameter can be any combination of the following values:
N  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
N  *     @arg FLASH_IT_ERR: Error Interrupt    
N  * @retval none
N  */  
N#define __HAL_FLASH_DISABLE_IT(__INTERRUPT__)  (FLASH->CR &= ~(uint32_t)(__INTERRUPT__))
N
N/**
N  * @brief  Get the specified FLASH flag status. 
N  * @param  __FLAG__ specifies the FLASH flags to check.
N  *          This parameter can be any combination of the following values:
N  *            @arg FLASH_FLAG_EOP   : FLASH End of Operation flag 
N  *            @arg FLASH_FLAG_OPERR : FLASH operation Error flag 
N  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
N  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
N  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
N  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
N  *            @arg FLASH_FLAG_RDERR : FLASH Read Protection error flag (PCROP) (*)
N  *            @arg FLASH_FLAG_BSY   : FLASH Busy flag
N  *           (*) FLASH_FLAG_RDERR is not available for STM32F405xx/407xx/415xx/417xx devices                             
N  * @retval The new state of __FLAG__ (SET or RESET).
N  */
N#define __HAL_FLASH_GET_FLAG(__FLAG__)   ((FLASH->SR & (__FLAG__)))
N
N/**
N  * @brief  Clear the specified FLASH flags.
N  * @param  __FLAG__ specifies the FLASH flags to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg FLASH_FLAG_EOP   : FLASH End of Operation flag 
N  *            @arg FLASH_FLAG_OPERR : FLASH operation Error flag 
N  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
N  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
N  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
N  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
N  *            @arg FLASH_FLAG_RDERR : FLASH Read Protection error flag (PCROP) (*)
N  *           (*) FLASH_FLAG_RDERR is not available for STM32F405xx/407xx/415xx/417xx devices   
N  * @retval none
N  */
N#define __HAL_FLASH_CLEAR_FLAG(__FLAG__)   (FLASH->SR = (__FLAG__))
N/**
N  * @}
N  */
N
N/* Include FLASH HAL Extension module */
N#include "stm32f4xx_hal_flash_ex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_flash_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of FLASH HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_FLASH_EX_H
N#define __STM32F4xx_HAL_FLASH_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FLASHEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup FLASHEx_Exported_Types FLASH Exported Types
N  * @{
N  */
N
N/**
N  * @brief  FLASH Erase structure definition
N  */
Ntypedef struct
N{
N  uint32_t TypeErase;   /*!< Mass erase or sector Erase.
N                             This parameter can be a value of @ref FLASHEx_Type_Erase */
N
N  uint32_t Banks;       /*!< Select banks to erase when Mass erase is enabled.
N                             This parameter must be a value of @ref FLASHEx_Banks */
N
N  uint32_t Sector;      /*!< Initial FLASH sector to erase when Mass erase is disabled
N                             This parameter must be a value of @ref FLASHEx_Sectors */
N
N  uint32_t NbSectors;   /*!< Number of sectors to be erased.
N                             This parameter must be a value between 1 and (max number of sectors - value of Initial sector)*/
N
N  uint32_t VoltageRange;/*!< The device voltage range which defines the erase parallelism
N                             This parameter must be a value of @ref FLASHEx_Voltage_Range */
N
N} FLASH_EraseInitTypeDef;
N
N/**
N  * @brief  FLASH Option Bytes Program structure definition
N  */
Ntypedef struct
N{
N  uint32_t OptionType;   /*!< Option byte to be configured.
N                              This parameter can be a value of @ref FLASHEx_Option_Type */
N
N  uint32_t WRPState;     /*!< Write protection activation or deactivation.
N                              This parameter can be a value of @ref FLASHEx_WRP_State */
N
N  uint32_t WRPSector;         /*!< Specifies the sector(s) to be write protected.
N                              The value of this parameter depend on device used within the same series */
N
N  uint32_t Banks;        /*!< Select banks for WRP activation/deactivation of all sectors.
N                              This parameter must be a value of @ref FLASHEx_Banks */        
N
N  uint32_t RDPLevel;     /*!< Set the read protection level.
N                              This parameter can be a value of @ref FLASHEx_Option_Bytes_Read_Protection */
N
N  uint32_t BORLevel;     /*!< Set the BOR Level.
N                              This parameter can be a value of @ref FLASHEx_BOR_Reset_Level */
N
N  uint8_t  USERConfig;   /*!< Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY. */
N
N} FLASH_OBProgramInitTypeDef;
N
N/**
N  * @brief  FLASH Advanced Option Bytes Program structure definition
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
Ntypedef struct
N{
N  uint32_t OptionType;     /*!< Option byte to be configured for extension.
N                                This parameter can be a value of @ref FLASHEx_Advanced_Option_Type */
N
N  uint32_t PCROPState;     /*!< PCROP activation or deactivation.
N                                This parameter can be a value of @ref FLASHEx_PCROP_State */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 1L || 0L || 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L || 0L
N  uint16_t Sectors;        /*!< specifies the sector(s) set for PCROP.
N                                This parameter can be a value of @ref FLASHEx_Option_Bytes_PC_ReadWrite_Protection */
N#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx ||\
N          STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S  uint32_t Banks;          /*!< Select banks for PCROP activation/deactivation of all sectors.
S                                This parameter must be a value of @ref FLASHEx_Banks */
S
S  uint16_t SectorsBank1;   /*!< Specifies the sector(s) set for PCROP for Bank1.
S                                This parameter can be a value of @ref FLASHEx_Option_Bytes_PC_ReadWrite_Protection */
S
S  uint16_t SectorsBank2;   /*!< Specifies the sector(s) set for PCROP for Bank2.
S                                This parameter can be a value of @ref FLASHEx_Option_Bytes_PC_ReadWrite_Protection */
S
S  uint8_t BootConfig;      /*!< Specifies Option bytes for boot config.
S                                This parameter can be a value of @ref FLASHEx_Dual_Boot */
S
N#endif /*STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N}FLASH_AdvOBProgramInitTypeDef;
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx ||
N          STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup FLASHEx_Exported_Constants FLASH Exported Constants
N  * @{
N  */
N
N/** @defgroup FLASHEx_Type_Erase FLASH Type Erase
N  * @{
N  */ 
N#define FLASH_TYPEERASE_SECTORS         0x00000000U  /*!< Sectors erase only          */
N#define FLASH_TYPEERASE_MASSERASE       0x00000001U  /*!< Flash Mass erase activation */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Voltage_Range FLASH Voltage Range
N  * @{
N  */ 
N#define FLASH_VOLTAGE_RANGE_1        0x00000000U  /*!< Device operating range: 1.8V to 2.1V                */
N#define FLASH_VOLTAGE_RANGE_2        0x00000001U  /*!< Device operating range: 2.1V to 2.7V                */
N#define FLASH_VOLTAGE_RANGE_3        0x00000002U  /*!< Device operating range: 2.7V to 3.6V                */
N#define FLASH_VOLTAGE_RANGE_4        0x00000003U  /*!< Device operating range: 2.7V to 3.6V + External Vpp */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_WRP_State FLASH WRP State
N  * @{
N  */ 
N#define OB_WRPSTATE_DISABLE       0x00000000U  /*!< Disable the write protection of the desired bank 1 sectors */
N#define OB_WRPSTATE_ENABLE        0x00000001U  /*!< Enable the write protection of the desired bank 1 sectors  */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Option_Type FLASH Option Type
N  * @{
N  */ 
N#define OPTIONBYTE_WRP        0x00000001U  /*!< WRP option byte configuration  */
N#define OPTIONBYTE_RDP        0x00000002U  /*!< RDP option byte configuration  */
N#define OPTIONBYTE_USER       0x00000004U  /*!< USER option byte configuration */
N#define OPTIONBYTE_BOR        0x00000008U  /*!< BOR option byte configuration  */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Option_Bytes_Read_Protection FLASH Option Bytes Read Protection
N  * @{
N  */
N#define OB_RDP_LEVEL_0   ((uint8_t)0xAA)
N#define OB_RDP_LEVEL_1   ((uint8_t)0x55)
N#define OB_RDP_LEVEL_2   ((uint8_t)0xCC) /*!< Warning: When enabling read protection level 2 
N                                              it s no more possible to go back to level 1 or 0 */
N/**
N  * @}
N  */ 
N  
N/** @defgroup FLASHEx_Option_Bytes_IWatchdog FLASH Option Bytes IWatchdog
N  * @{
N  */ 
N#define OB_IWDG_SW                     ((uint8_t)0x20)  /*!< Software IWDG selected */
N#define OB_IWDG_HW                     ((uint8_t)0x00)  /*!< Hardware IWDG selected */
N/**
N  * @}
N  */ 
N  
N/** @defgroup FLASHEx_Option_Bytes_nRST_STOP FLASH Option Bytes nRST_STOP
N  * @{
N  */ 
N#define OB_STOP_NO_RST                 ((uint8_t)0x40) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST                    ((uint8_t)0x00) /*!< Reset generated when entering in STOP    */
N/**
N  * @}
N  */ 
N
N
N/** @defgroup FLASHEx_Option_Bytes_nRST_STDBY FLASH Option Bytes nRST_STDBY
N  * @{
N  */ 
N#define OB_STDBY_NO_RST                ((uint8_t)0x80) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST                   ((uint8_t)0x00) /*!< Reset generated when entering in STANDBY    */
N/**
N  * @}
N  */    
N
N/** @defgroup FLASHEx_BOR_Reset_Level FLASH BOR Reset Level
N  * @{
N  */  
N#define OB_BOR_LEVEL3          ((uint8_t)0x00)  /*!< Supply voltage ranges from 2.70 to 3.60 V */
N#define OB_BOR_LEVEL2          ((uint8_t)0x04)  /*!< Supply voltage ranges from 2.40 to 2.70 V */
N#define OB_BOR_LEVEL1          ((uint8_t)0x08)  /*!< Supply voltage ranges from 2.10 to 2.40 V */
N#define OB_BOR_OFF             ((uint8_t)0x0C)  /*!< Supply voltage ranges from 1.62 to 2.10 V */
N/**
N  * @}
N  */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
N/** @defgroup FLASHEx_PCROP_State FLASH PCROP State
N  * @{
N  */ 
N#define OB_PCROP_STATE_DISABLE       0x00000000U  /*!< Disable PCROP */
N#define OB_PCROP_STATE_ENABLE        0x00000001U  /*!< Enable PCROP  */
N/**
N  * @}
N  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N/** @defgroup FLASHEx_Advanced_Option_Type FLASH Advanced Option Type
N  * @{
N  */ 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define OPTIONBYTE_PCROP        0x00000001U  /*!< PCROP option byte configuration      */
S#define OPTIONBYTE_BOOTCONFIG   0x00000002U  /*!< BOOTConfig option byte configuration */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N#define OPTIONBYTE_PCROP        0x00000001U  /*!<PCROP option byte configuration */
N#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
N          STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Latency FLASH Latency
N  * @{
N  */
N/*------------------------- STM32F42xxx/STM32F43xxx/STM32F446xx/STM32F469xx/STM32F479xx ----------------------*/  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L || 0L
S#define FLASH_LATENCY_0                FLASH_ACR_LATENCY_0WS   /*!< FLASH Zero Latency cycle      */
S#define FLASH_LATENCY_1                FLASH_ACR_LATENCY_1WS   /*!< FLASH One Latency cycle       */
S#define FLASH_LATENCY_2                FLASH_ACR_LATENCY_2WS   /*!< FLASH Two Latency cycles      */
S#define FLASH_LATENCY_3                FLASH_ACR_LATENCY_3WS   /*!< FLASH Three Latency cycles    */
S#define FLASH_LATENCY_4                FLASH_ACR_LATENCY_4WS   /*!< FLASH Four Latency cycles     */
S#define FLASH_LATENCY_5                FLASH_ACR_LATENCY_5WS   /*!< FLASH Five Latency cycles     */
S#define FLASH_LATENCY_6                FLASH_ACR_LATENCY_6WS   /*!< FLASH Six Latency cycles      */
S#define FLASH_LATENCY_7                FLASH_ACR_LATENCY_7WS   /*!< FLASH Seven Latency cycles    */
S#define FLASH_LATENCY_8                FLASH_ACR_LATENCY_8WS   /*!< FLASH Eight Latency cycles    */
S#define FLASH_LATENCY_9                FLASH_ACR_LATENCY_9WS   /*!< FLASH Nine Latency cycles     */
S#define FLASH_LATENCY_10               FLASH_ACR_LATENCY_10WS  /*!< FLASH Ten Latency cycles      */
S#define FLASH_LATENCY_11               FLASH_ACR_LATENCY_11WS  /*!< FLASH Eleven Latency cycles   */
S#define FLASH_LATENCY_12               FLASH_ACR_LATENCY_12WS  /*!< FLASH Twelve Latency cycles   */
S#define FLASH_LATENCY_13               FLASH_ACR_LATENCY_13WS  /*!< FLASH Thirteen Latency cycles */
S#define FLASH_LATENCY_14               FLASH_ACR_LATENCY_14WS  /*!< FLASH Fourteen Latency cycles */
S#define FLASH_LATENCY_15               FLASH_ACR_LATENCY_15WS  /*!< FLASH Fifteen Latency cycles  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/*--------------------------------------------------------------------------------------------------------------*/
N
N/*-------------------------- STM32F40xxx/STM32F41xxx/STM32F401xx/STM32F411xx/STM32F423xx -----------------------*/ 
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L
N     
N#define FLASH_LATENCY_0                FLASH_ACR_LATENCY_0WS   /*!< FLASH Zero Latency cycle      */
N#define FLASH_LATENCY_1                FLASH_ACR_LATENCY_1WS   /*!< FLASH One Latency cycle       */
N#define FLASH_LATENCY_2                FLASH_ACR_LATENCY_2WS   /*!< FLASH Two Latency cycles      */
N#define FLASH_LATENCY_3                FLASH_ACR_LATENCY_3WS   /*!< FLASH Three Latency cycles    */
N#define FLASH_LATENCY_4                FLASH_ACR_LATENCY_4WS   /*!< FLASH Four Latency cycles     */
N#define FLASH_LATENCY_5                FLASH_ACR_LATENCY_5WS   /*!< FLASH Five Latency cycles     */
N#define FLASH_LATENCY_6                FLASH_ACR_LATENCY_6WS   /*!< FLASH Six Latency cycles      */
N#define FLASH_LATENCY_7                FLASH_ACR_LATENCY_7WS   /*!< FLASH Seven Latency cycles    */
N#endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
N          STM32F413xx || STM32F423xx */
N/*--------------------------------------------------------------------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N  
N
N/** @defgroup FLASHEx_Banks FLASH Banks
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
S#define FLASH_BANK_1     1U /*!< Bank 1   */
S#define FLASH_BANK_2     2U /*!< Bank 2   */
S#define FLASH_BANK_BOTH  ((uint32_t)FLASH_BANK_1 | FLASH_BANK_2) /*!< Bank1 and Bank2  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N#define FLASH_BANK_1     1U /*!< Bank 1   */
N#endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
N          STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */ 
N    
N/** @defgroup FLASHEx_MassErase_bit FLASH Mass Erase bit
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
S#define FLASH_MER_BIT     (FLASH_CR_MER1 | FLASH_CR_MER2) /*!< 2 MER bits here to clear */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N#define FLASH_MER_BIT     (FLASH_CR_MER) /*!< only 1 MER Bit */
N#endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
N          STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASHEx_Sectors FLASH Sectors
N  * @{
N  */
N/*-------------------------------------- STM32F42xxx/STM32F43xxx/STM32F469xx ------------------------------------*/   
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
S#define FLASH_SECTOR_0     0U  /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U  /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U  /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U  /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U  /*!< Sector Number 4   */
S#define FLASH_SECTOR_5     5U  /*!< Sector Number 5   */
S#define FLASH_SECTOR_6     6U  /*!< Sector Number 6   */
S#define FLASH_SECTOR_7     7U  /*!< Sector Number 7   */
S#define FLASH_SECTOR_8     8U  /*!< Sector Number 8   */
S#define FLASH_SECTOR_9     9U  /*!< Sector Number 9   */
S#define FLASH_SECTOR_10    10U /*!< Sector Number 10  */
S#define FLASH_SECTOR_11    11U /*!< Sector Number 11  */
S#define FLASH_SECTOR_12    12U /*!< Sector Number 12  */
S#define FLASH_SECTOR_13    13U /*!< Sector Number 13  */
S#define FLASH_SECTOR_14    14U /*!< Sector Number 14  */
S#define FLASH_SECTOR_15    15U /*!< Sector Number 15  */
S#define FLASH_SECTOR_16    16U /*!< Sector Number 16  */
S#define FLASH_SECTOR_17    17U /*!< Sector Number 17  */
S#define FLASH_SECTOR_18    18U /*!< Sector Number 18  */
S#define FLASH_SECTOR_19    19U /*!< Sector Number 19  */
S#define FLASH_SECTOR_20    20U /*!< Sector Number 20  */
S#define FLASH_SECTOR_21    21U /*!< Sector Number 21  */
S#define FLASH_SECTOR_22    22U /*!< Sector Number 22  */
S#define FLASH_SECTOR_23    23U /*!< Sector Number 23  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*-------------------------------------- STM32F413xx/STM32F423xx --------------------------------------*/   
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define FLASH_SECTOR_0     0U  /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U  /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U  /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U  /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U  /*!< Sector Number 4   */
S#define FLASH_SECTOR_5     5U  /*!< Sector Number 5   */
S#define FLASH_SECTOR_6     6U  /*!< Sector Number 6   */
S#define FLASH_SECTOR_7     7U  /*!< Sector Number 7   */
S#define FLASH_SECTOR_8     8U  /*!< Sector Number 8   */
S#define FLASH_SECTOR_9     9U  /*!< Sector Number 9   */
S#define FLASH_SECTOR_10    10U /*!< Sector Number 10  */
S#define FLASH_SECTOR_11    11U /*!< Sector Number 11  */
S#define FLASH_SECTOR_12    12U /*!< Sector Number 12  */
S#define FLASH_SECTOR_13    13U /*!< Sector Number 13  */
S#define FLASH_SECTOR_14    14U /*!< Sector Number 14  */
S#define FLASH_SECTOR_15    15U /*!< Sector Number 15  */
N#endif /* STM32F413xx || STM32F423xx */
N/*-----------------------------------------------------------------------------------------------------*/      
N
N/*--------------------------------------- STM32F40xxx/STM32F41xxx -------------------------------------*/ 
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L  
S#define FLASH_SECTOR_0     0U  /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U  /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U  /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U  /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U  /*!< Sector Number 4   */
S#define FLASH_SECTOR_5     5U  /*!< Sector Number 5   */
S#define FLASH_SECTOR_6     6U  /*!< Sector Number 6   */
S#define FLASH_SECTOR_7     7U  /*!< Sector Number 7   */
S#define FLASH_SECTOR_8     8U  /*!< Sector Number 8   */
S#define FLASH_SECTOR_9     9U  /*!< Sector Number 9   */
S#define FLASH_SECTOR_10    10U /*!< Sector Number 10  */
S#define FLASH_SECTOR_11    11U /*!< Sector Number 11  */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------------- STM32F401xC -------------------------------------------*/ 
N#if defined(STM32F401xC)
X#if 0L
S#define FLASH_SECTOR_0     0U /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U /*!< Sector Number 4   */
S#define FLASH_SECTOR_5     5U /*!< Sector Number 5   */
N#endif /* STM32F401xC */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------------- STM32F410xx -------------------------------------------*/ 
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define FLASH_SECTOR_0     0U /*!< Sector Number 0   */
S#define FLASH_SECTOR_1     1U /*!< Sector Number 1   */
S#define FLASH_SECTOR_2     2U /*!< Sector Number 2   */
S#define FLASH_SECTOR_3     3U /*!< Sector Number 3   */
S#define FLASH_SECTOR_4     4U /*!< Sector Number 4   */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F401xE/STM32F411xE/STM32F446xx ------------------------------*/
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx)
X#if 1L || 0L || 0L
N#define FLASH_SECTOR_0     0U /*!< Sector Number 0   */
N#define FLASH_SECTOR_1     1U /*!< Sector Number 1   */
N#define FLASH_SECTOR_2     2U /*!< Sector Number 2   */
N#define FLASH_SECTOR_3     3U /*!< Sector Number 3   */
N#define FLASH_SECTOR_4     4U /*!< Sector Number 4   */
N#define FLASH_SECTOR_5     5U /*!< Sector Number 5   */
N#define FLASH_SECTOR_6     6U /*!< Sector Number 6   */
N#define FLASH_SECTOR_7     7U /*!< Sector Number 7   */
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASHEx_Option_Bytes_Write_Protection FLASH Option Bytes Write Protection
N  * @{
N  */
N/*--------------------------- STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx -------------------------*/  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L ||    0L || 0L 
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_6       0x00000040U /*!< Write protection of Sector6     */
S#define OB_WRP_SECTOR_7       0x00000080U /*!< Write protection of Sector7     */
S#define OB_WRP_SECTOR_8       0x00000100U /*!< Write protection of Sector8     */
S#define OB_WRP_SECTOR_9       0x00000200U /*!< Write protection of Sector9     */
S#define OB_WRP_SECTOR_10      0x00000400U /*!< Write protection of Sector10    */
S#define OB_WRP_SECTOR_11      0x00000800U /*!< Write protection of Sector11    */
S#define OB_WRP_SECTOR_12      0x00000001U << 12U /*!< Write protection of Sector12    */
S#define OB_WRP_SECTOR_13      0x00000002U << 12U /*!< Write protection of Sector13    */
S#define OB_WRP_SECTOR_14      0x00000004U << 12U /*!< Write protection of Sector14    */
S#define OB_WRP_SECTOR_15      0x00000008U << 12U /*!< Write protection of Sector15    */
S#define OB_WRP_SECTOR_16      0x00000010U << 12U /*!< Write protection of Sector16    */
S#define OB_WRP_SECTOR_17      0x00000020U << 12U /*!< Write protection of Sector17    */
S#define OB_WRP_SECTOR_18      0x00000040U << 12U /*!< Write protection of Sector18    */
S#define OB_WRP_SECTOR_19      0x00000080U << 12U /*!< Write protection of Sector19    */
S#define OB_WRP_SECTOR_20      0x00000100U << 12U /*!< Write protection of Sector20    */
S#define OB_WRP_SECTOR_21      0x00000200U << 12U /*!< Write protection of Sector21    */
S#define OB_WRP_SECTOR_22      0x00000400U << 12U /*!< Write protection of Sector22    */
S#define OB_WRP_SECTOR_23      0x00000800U << 12U /*!< Write protection of Sector23    */
S#define OB_WRP_SECTOR_All     0x00000FFFU << 12U /*!< Write protection of all Sectors */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------- STM32F413xx/STM32F423xx -------------------------------------*/ 
N#if defined(STM32F413xx) || defined(STM32F423xx)  
X#if 0L || 0L  
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_6       0x00000040U /*!< Write protection of Sector6     */
S#define OB_WRP_SECTOR_7       0x00000080U /*!< Write protection of Sector7     */
S#define OB_WRP_SECTOR_8       0x00000100U /*!< Write protection of Sector8     */
S#define OB_WRP_SECTOR_9       0x00000200U /*!< Write protection of Sector9     */
S#define OB_WRP_SECTOR_10      0x00000400U /*!< Write protection of Sector10    */
S#define OB_WRP_SECTOR_11      0x00000800U /*!< Write protection of Sector11    */
S#define OB_WRP_SECTOR_12      0x00001000U /*!< Write protection of Sector12    */
S#define OB_WRP_SECTOR_13      0x00002000U /*!< Write protection of Sector13    */
S#define OB_WRP_SECTOR_14      0x00004000U /*!< Write protection of Sector14    */
S#define OB_WRP_SECTOR_15      0x00004000U /*!< Write protection of Sector15    */      
S#define OB_WRP_SECTOR_All     0x00007FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F413xx || STM32F423xx */
N/*-----------------------------------------------------------------------------------------------------*/    
N      
N/*--------------------------------------- STM32F40xxx/STM32F41xxx -------------------------------------*/ 
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L  
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_6       0x00000040U /*!< Write protection of Sector6     */
S#define OB_WRP_SECTOR_7       0x00000080U /*!< Write protection of Sector7     */
S#define OB_WRP_SECTOR_8       0x00000100U /*!< Write protection of Sector8     */
S#define OB_WRP_SECTOR_9       0x00000200U /*!< Write protection of Sector9     */
S#define OB_WRP_SECTOR_10      0x00000400U /*!< Write protection of Sector10    */
S#define OB_WRP_SECTOR_11      0x00000800U /*!< Write protection of Sector11    */
S#define OB_WRP_SECTOR_All     0x00000FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------------- STM32F401xC -------------------------------------------*/
N#if defined(STM32F401xC)
X#if 0L
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
S#define OB_WRP_SECTOR_All     0x00000FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F401xC */
N/*-----------------------------------------------------------------------------------------------------*/
N 
N/*--------------------------------------------- STM32F410xx -------------------------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
S#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
S#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
S#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
S#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
S#define OB_WRP_SECTOR_All     0x00000FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------- STM32F401xE/STM32F411xE/STM32F446xx ------------------------------*/
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx)
X#if 1L || 0L || 0L
N#define OB_WRP_SECTOR_0       0x00000001U /*!< Write protection of Sector0     */
N#define OB_WRP_SECTOR_1       0x00000002U /*!< Write protection of Sector1     */
N#define OB_WRP_SECTOR_2       0x00000004U /*!< Write protection of Sector2     */
N#define OB_WRP_SECTOR_3       0x00000008U /*!< Write protection of Sector3     */
N#define OB_WRP_SECTOR_4       0x00000010U /*!< Write protection of Sector4     */
N#define OB_WRP_SECTOR_5       0x00000020U /*!< Write protection of Sector5     */
N#define OB_WRP_SECTOR_6       0x00000040U /*!< Write protection of Sector6     */
N#define OB_WRP_SECTOR_7       0x00000080U /*!< Write protection of Sector7     */
N#define OB_WRP_SECTOR_All     0x00000FFFU /*!< Write protection of all Sectors */
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx */
N/*-----------------------------------------------------------------------------------------------------*/
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Option_Bytes_PC_ReadWrite_Protection FLASH Option Bytes PC ReadWrite Protection
N  * @{
N  */
N/*-------------------------------- STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx ---------------------------*/   
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L|| 0L ||    0L || 0L 
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_5        0x00000020U /*!< PC Read/Write protection of Sector5      */
S#define OB_PCROP_SECTOR_6        0x00000040U /*!< PC Read/Write protection of Sector6      */
S#define OB_PCROP_SECTOR_7        0x00000080U /*!< PC Read/Write protection of Sector7      */
S#define OB_PCROP_SECTOR_8        0x00000100U /*!< PC Read/Write protection of Sector8      */
S#define OB_PCROP_SECTOR_9        0x00000200U /*!< PC Read/Write protection of Sector9      */
S#define OB_PCROP_SECTOR_10       0x00000400U /*!< PC Read/Write protection of Sector10     */
S#define OB_PCROP_SECTOR_11       0x00000800U /*!< PC Read/Write protection of Sector11     */
S#define OB_PCROP_SECTOR_12       0x00000001U /*!< PC Read/Write protection of Sector12     */
S#define OB_PCROP_SECTOR_13       0x00000002U /*!< PC Read/Write protection of Sector13     */
S#define OB_PCROP_SECTOR_14       0x00000004U /*!< PC Read/Write protection of Sector14     */
S#define OB_PCROP_SECTOR_15       0x00000008U /*!< PC Read/Write protection of Sector15     */
S#define OB_PCROP_SECTOR_16       0x00000010U /*!< PC Read/Write protection of Sector16     */
S#define OB_PCROP_SECTOR_17       0x00000020U /*!< PC Read/Write protection of Sector17     */
S#define OB_PCROP_SECTOR_18       0x00000040U /*!< PC Read/Write protection of Sector18     */
S#define OB_PCROP_SECTOR_19       0x00000080U /*!< PC Read/Write protection of Sector19     */
S#define OB_PCROP_SECTOR_20       0x00000100U /*!< PC Read/Write protection of Sector20     */
S#define OB_PCROP_SECTOR_21       0x00000200U /*!< PC Read/Write protection of Sector21     */
S#define OB_PCROP_SECTOR_22       0x00000400U /*!< PC Read/Write protection of Sector22     */
S#define OB_PCROP_SECTOR_23       0x00000800U /*!< PC Read/Write protection of Sector23     */
S#define OB_PCROP_SECTOR_All      0x00000FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/*-----------------------------------------------------------------------------------------------------*/
N      
N/*------------------------------------- STM32F413xx/STM32F423xx ---------------------------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)  
X#if 0L || 0L  
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_5        0x00000020U /*!< PC Read/Write protection of Sector5      */
S#define OB_PCROP_SECTOR_6        0x00000040U /*!< PC Read/Write protection of Sector6      */
S#define OB_PCROP_SECTOR_7        0x00000080U /*!< PC Read/Write protection of Sector7      */
S#define OB_PCROP_SECTOR_8        0x00000100U /*!< PC Read/Write protection of Sector8      */
S#define OB_PCROP_SECTOR_9        0x00000200U /*!< PC Read/Write protection of Sector9      */
S#define OB_PCROP_SECTOR_10       0x00000400U /*!< PC Read/Write protection of Sector10     */
S#define OB_PCROP_SECTOR_11       0x00000800U /*!< PC Read/Write protection of Sector11     */
S#define OB_PCROP_SECTOR_12       0x00001000U /*!< PC Read/Write protection of Sector12     */
S#define OB_PCROP_SECTOR_13       0x00002000U /*!< PC Read/Write protection of Sector13     */
S#define OB_PCROP_SECTOR_14       0x00004000U /*!< PC Read/Write protection of Sector14     */
S#define OB_PCROP_SECTOR_15       0x00004000U /*!< PC Read/Write protection of Sector15     */      
S#define OB_PCROP_SECTOR_All      0x00007FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F413xx || STM32F423xx */
N/*-----------------------------------------------------------------------------------------------------*/      
N
N/*--------------------------------------------- STM32F401xC -------------------------------------------*/
N#if defined(STM32F401xC)
X#if 0L
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_5        0x00000020U /*!< PC Read/Write protection of Sector5      */
S#define OB_PCROP_SECTOR_All      0x00000FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F401xC */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*--------------------------------------------- STM32F410xx -------------------------------------------*/
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
S#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
S#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
S#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
S#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
S#define OB_PCROP_SECTOR_All      0x00000FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/*-------------- STM32F401xE/STM32F411xE/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx/STM32F446xx --*/
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 1L || 0L || 0L || 0L ||    0L || 0L || 0L  
N#define OB_PCROP_SECTOR_0        0x00000001U /*!< PC Read/Write protection of Sector0      */
N#define OB_PCROP_SECTOR_1        0x00000002U /*!< PC Read/Write protection of Sector1      */
N#define OB_PCROP_SECTOR_2        0x00000004U /*!< PC Read/Write protection of Sector2      */
N#define OB_PCROP_SECTOR_3        0x00000008U /*!< PC Read/Write protection of Sector3      */
N#define OB_PCROP_SECTOR_4        0x00000010U /*!< PC Read/Write protection of Sector4      */
N#define OB_PCROP_SECTOR_5        0x00000020U /*!< PC Read/Write protection of Sector5      */
N#define OB_PCROP_SECTOR_6        0x00000040U /*!< PC Read/Write protection of Sector6      */
N#define OB_PCROP_SECTOR_7        0x00000080U /*!< PC Read/Write protection of Sector7      */
N#define OB_PCROP_SECTOR_All      0x00000FFFU /*!< PC Read/Write protection of all Sectors  */
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N/*-----------------------------------------------------------------------------------------------------*/
N
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_Dual_Boot FLASH Dual Boot
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L|| 0L ||    0L || 0L 
S#define OB_DUAL_BOOT_ENABLE   ((uint8_t)0x10) /*!< Dual Bank Boot Enable                             */
S#define OB_DUAL_BOOT_DISABLE  ((uint8_t)0x00) /*!< Dual Bank Boot Disable, always boot on User Flash */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/** @defgroup  FLASHEx_Selection_Protection_Mode FLASH Selection Protection Mode
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
N#define OB_PCROP_DESELECTED     ((uint8_t)0x00) /*!< Disabled PcROP, nWPRi bits used for Write Protection on sector i */
N#define OB_PCROP_SELECTED       ((uint8_t)0x80) /*!< Enable PcROP, nWPRi bits used for PCRoP Protection on sector i   */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup FLASHEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup FLASHEx_Exported_Functions_Group1
N  * @{
N  */
N/* Extension Program operation functions  *************************************/
NHAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError);
NHAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit);
NHAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
Nvoid              HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
NHAL_StatusTypeDef HAL_FLASHEx_AdvOBProgram (FLASH_AdvOBProgramInitTypeDef *pAdvOBInit);
Nvoid              HAL_FLASHEx_AdvOBGetConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit);
NHAL_StatusTypeDef HAL_FLASHEx_OB_SelectPCROP(void);
NHAL_StatusTypeDef HAL_FLASHEx_OB_DeSelectPCROP(void);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
Suint16_t          HAL_FLASHEx_OB_GetBank2WRP(void);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup FLASHEx_Private_Constants FLASH Private Constants
N  * @{
N  */
N/*--------------------------------- STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx---------------------*/ 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L || 0L || 0L
S#define FLASH_SECTOR_TOTAL  24U
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N/*-------------------------------------- STM32F413xx/STM32F423xx ---------------------------------------*/
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define FLASH_SECTOR_TOTAL  16U
N#endif /* STM32F413xx || STM32F423xx */
N
N/*--------------------------------------- STM32F40xxx/STM32F41xxx -------------------------------------*/ 
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L  
S#define FLASH_SECTOR_TOTAL  12U
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N/*--------------------------------------------- STM32F401xC -------------------------------------------*/ 
N#if defined(STM32F401xC)
X#if 0L
S#define FLASH_SECTOR_TOTAL  6U
N#endif /* STM32F401xC */
N
N/*--------------------------------------------- STM32F410xx -------------------------------------------*/ 
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define FLASH_SECTOR_TOTAL  5U
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N/*--------------------------------- STM32F401xE/STM32F411xE/STM32F412xG/STM32F446xx -------------------*/
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx)
X#if 1L || 0L || 0L
N#define FLASH_SECTOR_TOTAL  8U
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx */
N
N/** 
N  * @brief OPTCR1 register byte 2 (Bits[23:16]) base address  
N  */ 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)  
X#if 0L || 0L || 0L|| 0L || 0L || 0L  
S#define OPTCR1_BYTE2_ADDRESS         0x40023C1AU
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup FLASHEx_Private_Macros FLASH Private Macros
N  * @{
N  */
N
N/** @defgroup FLASHEx_IS_FLASH_Definitions FLASH Private macros to check input parameters
N  * @{
N  */
N
N#define IS_FLASH_TYPEERASE(VALUE)(((VALUE) == FLASH_TYPEERASE_SECTORS) || \
N                                  ((VALUE) == FLASH_TYPEERASE_MASSERASE))  
X#define IS_FLASH_TYPEERASE(VALUE)(((VALUE) == FLASH_TYPEERASE_SECTORS) ||                                   ((VALUE) == FLASH_TYPEERASE_MASSERASE))  
N
N#define IS_VOLTAGERANGE(RANGE)(((RANGE) == FLASH_VOLTAGE_RANGE_1) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_2) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_3) || \
N                               ((RANGE) == FLASH_VOLTAGE_RANGE_4))  
X#define IS_VOLTAGERANGE(RANGE)(((RANGE) == FLASH_VOLTAGE_RANGE_1) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_2) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_3) ||                                ((RANGE) == FLASH_VOLTAGE_RANGE_4))  
N
N#define IS_WRPSTATE(VALUE)(((VALUE) == OB_WRPSTATE_DISABLE) || \
N                           ((VALUE) == OB_WRPSTATE_ENABLE))  
X#define IS_WRPSTATE(VALUE)(((VALUE) == OB_WRPSTATE_DISABLE) ||                            ((VALUE) == OB_WRPSTATE_ENABLE))  
N
N#define IS_OPTIONBYTE(VALUE)(((VALUE) <= (OPTIONBYTE_WRP|OPTIONBYTE_RDP|OPTIONBYTE_USER|OPTIONBYTE_BOR)))
N
N#define IS_OB_RDP_LEVEL(LEVEL) (((LEVEL) == OB_RDP_LEVEL_0) ||\
N                                ((LEVEL) == OB_RDP_LEVEL_1) ||\
N                                ((LEVEL) == OB_RDP_LEVEL_2))
X#define IS_OB_RDP_LEVEL(LEVEL) (((LEVEL) == OB_RDP_LEVEL_0) ||                                ((LEVEL) == OB_RDP_LEVEL_1) ||                                ((LEVEL) == OB_RDP_LEVEL_2))
N
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NO_RST) || ((SOURCE) == OB_STOP_RST))
N
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NO_RST) || ((SOURCE) == OB_STDBY_RST))
N
N#define IS_OB_BOR_LEVEL(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||\
N                                ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
X#define IS_OB_BOR_LEVEL(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||                                ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
N#define IS_PCROPSTATE(VALUE)(((VALUE) == OB_PCROP_STATE_DISABLE) || \
N                             ((VALUE) == OB_PCROP_STATE_ENABLE))  
X#define IS_PCROPSTATE(VALUE)(((VALUE) == OB_PCROP_STATE_DISABLE) ||                              ((VALUE) == OB_PCROP_STATE_ENABLE))  
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L
S#define IS_OBEX(VALUE)(((VALUE) == OPTIONBYTE_PCROP) || \
S                       ((VALUE) == OPTIONBYTE_BOOTCONFIG))  
X#define IS_OBEX(VALUE)(((VALUE) == OPTIONBYTE_PCROP) ||                        ((VALUE) == OPTIONBYTE_BOOTCONFIG))  
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N#define IS_OBEX(VALUE)(((VALUE) == OPTIONBYTE_PCROP))  
N#endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L || 0L
S#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  || \
S                                   ((LATENCY) == FLASH_LATENCY_1)  || \
S                                   ((LATENCY) == FLASH_LATENCY_2)  || \
S                                   ((LATENCY) == FLASH_LATENCY_3)  || \
S                                   ((LATENCY) == FLASH_LATENCY_4)  || \
S                                   ((LATENCY) == FLASH_LATENCY_5)  || \
S                                   ((LATENCY) == FLASH_LATENCY_6)  || \
S                                   ((LATENCY) == FLASH_LATENCY_7)  || \
S                                   ((LATENCY) == FLASH_LATENCY_8)  || \
S                                   ((LATENCY) == FLASH_LATENCY_9)  || \
S                                   ((LATENCY) == FLASH_LATENCY_10) || \
S                                   ((LATENCY) == FLASH_LATENCY_11) || \
S                                   ((LATENCY) == FLASH_LATENCY_12) || \
S                                   ((LATENCY) == FLASH_LATENCY_13) || \
S                                   ((LATENCY) == FLASH_LATENCY_14) || \
S                                   ((LATENCY) == FLASH_LATENCY_15))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  ||                                    ((LATENCY) == FLASH_LATENCY_1)  ||                                    ((LATENCY) == FLASH_LATENCY_2)  ||                                    ((LATENCY) == FLASH_LATENCY_3)  ||                                    ((LATENCY) == FLASH_LATENCY_4)  ||                                    ((LATENCY) == FLASH_LATENCY_5)  ||                                    ((LATENCY) == FLASH_LATENCY_6)  ||                                    ((LATENCY) == FLASH_LATENCY_7)  ||                                    ((LATENCY) == FLASH_LATENCY_8)  ||                                    ((LATENCY) == FLASH_LATENCY_9)  ||                                    ((LATENCY) == FLASH_LATENCY_10) ||                                    ((LATENCY) == FLASH_LATENCY_11) ||                                    ((LATENCY) == FLASH_LATENCY_12) ||                                    ((LATENCY) == FLASH_LATENCY_13) ||                                    ((LATENCY) == FLASH_LATENCY_14) ||                                    ((LATENCY) == FLASH_LATENCY_15))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  || \
N                                   ((LATENCY) == FLASH_LATENCY_1)  || \
N                                   ((LATENCY) == FLASH_LATENCY_2)  || \
N                                   ((LATENCY) == FLASH_LATENCY_3)  || \
N                                   ((LATENCY) == FLASH_LATENCY_4)  || \
N                                   ((LATENCY) == FLASH_LATENCY_5)  || \
N                                   ((LATENCY) == FLASH_LATENCY_6)  || \
N                                   ((LATENCY) == FLASH_LATENCY_7))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0)  ||                                    ((LATENCY) == FLASH_LATENCY_1)  ||                                    ((LATENCY) == FLASH_LATENCY_2)  ||                                    ((LATENCY) == FLASH_LATENCY_3)  ||                                    ((LATENCY) == FLASH_LATENCY_4)  ||                                    ((LATENCY) == FLASH_LATENCY_5)  ||                                    ((LATENCY) == FLASH_LATENCY_6)  ||                                    ((LATENCY) == FLASH_LATENCY_7))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F412Zx || STM32F412Vx ||\
N          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_FLASH_BANK(BANK) (((BANK) == FLASH_BANK_1)  || \
S                             ((BANK) == FLASH_BANK_2)  || \
S                             ((BANK) == FLASH_BANK_BOTH))
X#define IS_FLASH_BANK(BANK) (((BANK) == FLASH_BANK_1)  ||                              ((BANK) == FLASH_BANK_2)  ||                              ((BANK) == FLASH_BANK_BOTH))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
N    defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L
N#define IS_FLASH_BANK(BANK) (((BANK) == FLASH_BANK_1))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx ||\
N          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N 
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_FLASH_SECTOR(SECTOR) ( ((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_16)  || ((SECTOR) == FLASH_SECTOR_17)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_18)  || ((SECTOR) == FLASH_SECTOR_19)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_20)  || ((SECTOR) == FLASH_SECTOR_21)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_22)  || ((SECTOR) == FLASH_SECTOR_23))
X#define IS_FLASH_SECTOR(SECTOR) ( ((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                  ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                  ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                  ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||                                  ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||                                  ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||                                  ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||                                  ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15)  ||                                  ((SECTOR) == FLASH_SECTOR_16)  || ((SECTOR) == FLASH_SECTOR_17)  ||                                  ((SECTOR) == FLASH_SECTOR_18)  || ((SECTOR) == FLASH_SECTOR_19)  ||                                  ((SECTOR) == FLASH_SECTOR_20)  || ((SECTOR) == FLASH_SECTOR_21)  ||                                  ((SECTOR) == FLASH_SECTOR_22)  || ((SECTOR) == FLASH_SECTOR_23))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define IS_FLASH_SECTOR(SECTOR) ( ((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||\
S                                  ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||\
S                                  ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15))
X#define IS_FLASH_SECTOR(SECTOR) ( ((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                  ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                  ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                  ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||                                  ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||                                  ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11)  ||                                  ((SECTOR) == FLASH_SECTOR_12)  || ((SECTOR) == FLASH_SECTOR_13)  ||                                  ((SECTOR) == FLASH_SECTOR_14)  || ((SECTOR) == FLASH_SECTOR_15))
N#endif /* STM32F413xx || STM32F423xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L  
S#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7)   ||                                 ((SECTOR) == FLASH_SECTOR_8)   || ((SECTOR) == FLASH_SECTOR_9)   ||                                 ((SECTOR) == FLASH_SECTOR_10)  || ((SECTOR) == FLASH_SECTOR_11))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N#if defined(STM32F401xC)
X#if 0L
S#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5))
N#endif /* STM32F401xC */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
S                                 ((SECTOR) == FLASH_SECTOR_4))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx)
X#if 1L || 0L || 0L
N#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||\
N                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_SECTOR_0)   || ((SECTOR) == FLASH_SECTOR_1)   ||                                 ((SECTOR) == FLASH_SECTOR_2)   || ((SECTOR) == FLASH_SECTOR_3)   ||                                 ((SECTOR) == FLASH_SECTOR_4)   || ((SECTOR) == FLASH_SECTOR_5)   ||                                 ((SECTOR) == FLASH_SECTOR_6)   || ((SECTOR) == FLASH_SECTOR_7))
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx */
N
N#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= FLASH_BASE) && ((ADDRESS) <= FLASH_END)) || \
N                                   (((ADDRESS) >= FLASH_OTP_BASE) && ((ADDRESS) <= FLASH_OTP_END)))
X#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= FLASH_BASE) && ((ADDRESS) <= FLASH_END)) ||                                    (((ADDRESS) >= FLASH_OTP_BASE) && ((ADDRESS) <= FLASH_OTP_END)))
N
N#define IS_FLASH_NBSECTORS(NBSECTORS) (((NBSECTORS) != 0) && ((NBSECTORS) <= FLASH_SECTOR_TOTAL))
N  
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L || 0L || 0L 
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFF000000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F413xx) || defined(STM32F423xx) 
X#if 0L || 0L 
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFF8000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F413xx || STM32F423xx */
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
X#if 0L || 0L || 0L || 0L
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N
N#if defined(STM32F401xC)
X#if 0L
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F401xC */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 1L || 0L || 0L || 0L || 0L ||    0L || 0L  
N#define IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N   
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFF8000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))      
N#endif /* STM32F413xx || STM32F423xx */
N
N#if defined(STM32F401xC)
X#if 0L
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F401xC */
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
X#if 0L || 0L || 0L
S#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx */
N
N#if defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 1L || 0L || 0L || 0L || 0L ||    0L || 0L  
N#define IS_OB_PCROP(SECTOR)((((SECTOR) & 0xFFFFF000U) == 0x00000000U) && ((SECTOR) != 0x00000000U))
N#endif /* STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx) 
X#if 0L || 0L || 0L || 0L ||    0L || 0L 
S#define IS_OB_BOOT(BOOT) (((BOOT) == OB_DUAL_BOOT_ENABLE) || ((BOOT) == OB_DUAL_BOOT_DISABLE))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
N    defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
N    defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
N    defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    0L || 1L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L ||    0L || 0L || 0L
N#define IS_OB_PCROP_SELECT(PCROP) (((PCROP) == OB_PCROP_SELECTED) || ((PCROP) == OB_PCROP_DESELECTED))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE ||\
N          STM32F410xx || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx ||\
N          STM32F412Vx || STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup FLASHEx_Private_Functions FLASH Private Functions
N  * @{
N  */
Nvoid FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange);
Nvoid FLASH_FlushCaches(void);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_FLASH_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 298 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash.h" 2
N#include "stm32f4xx_hal_flash_ramfunc.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash_ramfunc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_flash_ramfunc.h
N  * @author  MCD Application Team
N  * @brief   Header file of FLASH RAMFUNC driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_FLASH_RAMFUNC_H
N#define __STM32F4xx_FLASH_RAMFUNC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
N    defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx)  
X#if 0L || 0L || 0L || 0L || 0L || 0L ||    0L || 0L || 0L  
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32f4xx_hal_def.h"
S
S/** @addtogroup STM32F4xx_HAL_Driver
S  * @{
S  */
S
S/** @addtogroup FLASH_RAMFUNC
S  * @{
S  */
S
S/* Exported types ------------------------------------------------------------*/
S/* Exported macro ------------------------------------------------------------*/
S/* Exported functions --------------------------------------------------------*/
S/** @addtogroup FLASH_RAMFUNC_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup FLASH_RAMFUNC_Exported_Functions_Group1
S  * @{
S  */   
S__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StopFlashInterfaceClk(void);
S__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StartFlashInterfaceClk(void);
S__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_EnableFlashSleepMode(void);
S__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_DisableFlashSleepMode(void);
S/**
S  * @}
S  */ 
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */ 
S
S/**
S  * @}
S  */
S
N#endif /* STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx */  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F4xx_FLASH_RAMFUNC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 299 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_flash.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup FLASH_Exported_Functions
N  * @{
N  */
N/** @addtogroup FLASH_Exported_Functions_Group1
N  * @{
N  */
N/* Program operation functions  ***********************************************/
NHAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
NHAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
N/* FLASH IRQ handler method */
Nvoid HAL_FLASH_IRQHandler(void);
N/* Callbacks in non blocking modes */ 
Nvoid HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue);
Nvoid HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue);
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions  **********************************************/
NHAL_StatusTypeDef HAL_FLASH_Unlock(void);
NHAL_StatusTypeDef HAL_FLASH_Lock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Unlock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Lock(void);
N/* Option bytes control */
NHAL_StatusTypeDef HAL_FLASH_OB_Launch(void);
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State functions  ************************************************/
Nuint32_t HAL_FLASH_GetError(void);
NHAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Variables FLASH Private Variables
N  * @{
N  */
N
N/**
N  * @}
N  */
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Constants FLASH Private Constants
N  * @{
N  */
N
N/** 
N  * @brief   ACR register byte 0 (Bits[7:0]) base address  
N  */ 
N#define ACR_BYTE0_ADDRESS           0x40023C00U 
N/** 
N  * @brief   OPTCR register byte 0 (Bits[7:0]) base address  
N  */ 
N#define OPTCR_BYTE0_ADDRESS         0x40023C14U
N/** 
N  * @brief   OPTCR register byte 1 (Bits[15:8]) base address  
N  */ 
N#define OPTCR_BYTE1_ADDRESS         0x40023C15U
N/** 
N  * @brief   OPTCR register byte 2 (Bits[23:16]) base address  
N  */ 
N#define OPTCR_BYTE2_ADDRESS         0x40023C16U
N/** 
N  * @brief   OPTCR register byte 3 (Bits[31:24]) base address  
N  */ 
N#define OPTCR_BYTE3_ADDRESS         0x40023C17U
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup FLASH_Private_Macros FLASH Private Macros
N  * @{
N  */
N
N/** @defgroup FLASH_IS_FLASH_Definitions FLASH Private macros to check input parameters
N  * @{
N  */
N#define IS_FLASH_TYPEPROGRAM(VALUE)(((VALUE) == FLASH_TYPEPROGRAM_BYTE) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_WORD) || \
N                                    ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))  
X#define IS_FLASH_TYPEPROGRAM(VALUE)(((VALUE) == FLASH_TYPEPROGRAM_BYTE) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_WORD) ||                                     ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup FLASH_Private_Functions FLASH Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_FLASH_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 251 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_FLASH_MODULE_ENABLED */
N
N#ifdef HAL_SRAM_MODULE_ENABLED
S#include "stm32f4xx_hal_sram.h"
N#endif /* HAL_SRAM_MODULE_ENABLED */
N
N#ifdef HAL_NOR_MODULE_ENABLED
S#include "stm32f4xx_hal_nor.h"
N#endif /* HAL_NOR_MODULE_ENABLED */
N
N#ifdef HAL_NAND_MODULE_ENABLED
S#include "stm32f4xx_hal_nand.h"
N#endif /* HAL_NAND_MODULE_ENABLED */
N
N#ifdef HAL_I2C_MODULE_ENABLED
N#include "stm32f4xx_hal_i2c.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_i2c.h
N  * @author  MCD Application Team
N  * @brief   Header file of I2C HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_I2C_H
N#define __STM32F4xx_HAL_I2C_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup I2C
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup I2C_Exported_Types I2C Exported Types
N  * @{
N  */
N
N/** @defgroup I2C_Configuration_Structure_definition I2C Configuration Structure definition
N  * @brief  I2C Configuration Structure definition
N  * @{
N  */
Ntypedef struct
N{
N  uint32_t ClockSpeed;       /*!< Specifies the clock frequency.
N                                  This parameter must be set to a value lower than 400kHz */
N
N  uint32_t DutyCycle;        /*!< Specifies the I2C fast mode duty cycle.
N                                  This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
N
N  uint32_t OwnAddress1;      /*!< Specifies the first device own address.
N                                  This parameter can be a 7-bit or 10-bit address. */
N
N  uint32_t AddressingMode;   /*!< Specifies if 7-bit or 10-bit addressing mode is selected.
N                                  This parameter can be a value of @ref I2C_addressing_mode */
N
N  uint32_t DualAddressMode;  /*!< Specifies if dual addressing mode is selected.
N                                  This parameter can be a value of @ref I2C_dual_addressing_mode */
N
N  uint32_t OwnAddress2;      /*!< Specifies the second device own address if dual addressing mode is selected
N                                  This parameter can be a 7-bit address. */
N
N  uint32_t GeneralCallMode;  /*!< Specifies if general call mode is selected.
N                                  This parameter can be a value of @ref I2C_general_call_addressing_mode */
N
N  uint32_t NoStretchMode;    /*!< Specifies if nostretch mode is selected.
N                                  This parameter can be a value of @ref I2C_nostretch_mode */
N
N} I2C_InitTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_state_structure_definition HAL state structure definition
N  * @brief  HAL State structure definition
N  * @note  HAL I2C State value coding follow below described bitmap :
N  *          b7-b6  Error information
N  *             00 : No Error
N  *             01 : Abort (Abort user request on going)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     Peripheral initilisation status
N  *             0  : Reset (Peripheral not initialized)
N  *             1  : Init done (Peripheral initialized and ready to use. HAL I2C Init function called)
N  *          b4     (not used)
N  *             x  : Should be set to 0
N  *          b3
N  *             0  : Ready or Busy (No Listen mode ongoing)
N  *             1  : Listen (Peripheral in Address Listen Mode)
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (Peripheral busy with some configuration or internal operations)
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  * @{
N  */
Ntypedef enum
N{
N  HAL_I2C_STATE_RESET             = 0x00U,   /*!< Peripheral is not yet Initialized         */
N  HAL_I2C_STATE_READY             = 0x20U,   /*!< Peripheral Initialized and ready for use  */
N  HAL_I2C_STATE_BUSY              = 0x24U,   /*!< An internal process is ongoing            */
N  HAL_I2C_STATE_BUSY_TX           = 0x21U,   /*!< Data Transmission process is ongoing      */
N  HAL_I2C_STATE_BUSY_RX           = 0x22U,   /*!< Data Reception process is ongoing         */
N  HAL_I2C_STATE_LISTEN            = 0x28U,   /*!< Address Listen Mode is ongoing            */
N  HAL_I2C_STATE_BUSY_TX_LISTEN    = 0x29U,   /*!< Address Listen Mode and Data Transmission
N                                                 process is ongoing                         */
N  HAL_I2C_STATE_BUSY_RX_LISTEN    = 0x2AU,   /*!< Address Listen Mode and Data Reception
N                                                 process is ongoing                         */
N  HAL_I2C_STATE_ABORT             = 0x60U,   /*!< Abort user request ongoing                */
N  HAL_I2C_STATE_TIMEOUT           = 0xA0U,   /*!< Timeout state                             */
N  HAL_I2C_STATE_ERROR             = 0xE0U    /*!< Error                                     */
N
N} HAL_I2C_StateTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_mode_structure_definition HAL mode structure definition
N  * @brief  HAL Mode structure definition
N  * @note  HAL I2C Mode value coding follow below described bitmap :\n
N  *          b7     (not used)\n
N  *             x  : Should be set to 0\n
N  *          b6\n
N  *             0  : None\n
N  *             1  : Memory (HAL I2C communication is in Memory Mode)\n
N  *          b5\n
N  *             0  : None\n
N  *             1  : Slave (HAL I2C communication is in Slave Mode)\n
N  *          b4\n
N  *             0  : None\n
N  *             1  : Master (HAL I2C communication is in Master Mode)\n
N  *          b3-b2-b1-b0  (not used)\n
N  *             xxxx : Should be set to 0000
N  * @{
N  */
Ntypedef enum
N{
N  HAL_I2C_MODE_NONE               = 0x00U,   /*!< No I2C communication on going             */
N  HAL_I2C_MODE_MASTER             = 0x10U,   /*!< I2C communication is in Master Mode       */
N  HAL_I2C_MODE_SLAVE              = 0x20U,   /*!< I2C communication is in Slave Mode        */
N  HAL_I2C_MODE_MEM                = 0x40U    /*!< I2C communication is in Memory Mode       */
N
N} HAL_I2C_ModeTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Error_Code_definition I2C Error Code definition
N  * @brief  I2C Error Code definition
N  * @{
N  */
N#define HAL_I2C_ERROR_NONE              0x00000000U    /*!< No error              */
N#define HAL_I2C_ERROR_BERR              0x00000001U    /*!< BERR error            */
N#define HAL_I2C_ERROR_ARLO              0x00000002U    /*!< ARLO error            */
N#define HAL_I2C_ERROR_AF                0x00000004U    /*!< AF error              */
N#define HAL_I2C_ERROR_OVR               0x00000008U    /*!< OVR error             */
N#define HAL_I2C_ERROR_DMA               0x00000010U    /*!< DMA transfer error    */
N#define HAL_I2C_ERROR_TIMEOUT           0x00000020U    /*!< Timeout Error         */
N#define HAL_I2C_ERROR_SIZE              0x00000040U    /*!< Size Management error */
N#define HAL_I2C_ERROR_DMA_PARAM         0x00000080U    /*!< DMA Parameter Error   */
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
S#define HAL_I2C_ERROR_INVALID_CALLBACK  0x00000100U    /*!< Invalid Callback error */
N#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_handle_Structure_definition I2C handle Structure definition
N  * @brief  I2C handle Structure definition
N  * @{
N  */
Ntypedef struct __I2C_HandleTypeDef
N{
N  I2C_TypeDef                *Instance;      /*!< I2C registers base address               */
N
N  I2C_InitTypeDef            Init;           /*!< I2C communication parameters             */
N
N  uint8_t                    *pBuffPtr;      /*!< Pointer to I2C transfer buffer           */
N
N  uint16_t                   XferSize;       /*!< I2C transfer size                        */
N
N  __IO uint16_t              XferCount;      /*!< I2C transfer counter                     */
X  volatile uint16_t              XferCount;       
N
N  __IO uint32_t              XferOptions;    /*!< I2C transfer options                     */
X  volatile uint32_t              XferOptions;     
N
N  __IO uint32_t              PreviousState;  /*!< I2C communication Previous state and mode
X  volatile uint32_t              PreviousState;  
N                                                  context for internal usage               */
N
N  DMA_HandleTypeDef          *hdmatx;        /*!< I2C Tx DMA handle parameters             */
N
N  DMA_HandleTypeDef          *hdmarx;        /*!< I2C Rx DMA handle parameters             */
N
N  HAL_LockTypeDef            Lock;           /*!< I2C locking object                       */
N
N  __IO HAL_I2C_StateTypeDef  State;          /*!< I2C communication state                  */
X  volatile HAL_I2C_StateTypeDef  State;           
N
N  __IO HAL_I2C_ModeTypeDef   Mode;           /*!< I2C communication mode                   */
X  volatile HAL_I2C_ModeTypeDef   Mode;            
N
N  __IO uint32_t              ErrorCode;      /*!< I2C Error code                           */
X  volatile uint32_t              ErrorCode;       
N
N  __IO uint32_t              Devaddress;     /*!< I2C Target device address                */
X  volatile uint32_t              Devaddress;      
N
N  __IO uint32_t              Memaddress;     /*!< I2C Target memory address                */
X  volatile uint32_t              Memaddress;      
N
N  __IO uint32_t              MemaddSize;     /*!< I2C Target memory address  size          */
X  volatile uint32_t              MemaddSize;      
N
N  __IO uint32_t              EventCount;     /*!< I2C Event counter                        */
X  volatile uint32_t              EventCount;      
N
N
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
S  void (* MasterTxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);           /*!< I2C Master Tx Transfer completed callback */
S  void (* MasterRxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);           /*!< I2C Master Rx Transfer completed callback */
S  void (* SlaveTxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);            /*!< I2C Slave Tx Transfer completed callback  */
S  void (* SlaveRxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);            /*!< I2C Slave Rx Transfer completed callback  */
S  void (* ListenCpltCallback)(struct __I2C_HandleTypeDef *hi2c);             /*!< I2C Listen Complete callback              */
S  void (* MemTxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);              /*!< I2C Memory Tx Transfer completed callback */
S  void (* MemRxCpltCallback)(struct __I2C_HandleTypeDef *hi2c);              /*!< I2C Memory Rx Transfer completed callback */
S  void (* ErrorCallback)(struct __I2C_HandleTypeDef *hi2c);                  /*!< I2C Error callback                        */
S  void (* AbortCpltCallback)(struct __I2C_HandleTypeDef *hi2c);              /*!< I2C Abort callback                        */
S
S  void (* AddrCallback)(struct __I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode);  /*!< I2C Slave Address Match callback */
S
S  void (* MspInitCallback)(struct __I2C_HandleTypeDef *hi2c);                /*!< I2C Msp Init callback                     */
S  void (* MspDeInitCallback)(struct __I2C_HandleTypeDef *hi2c);              /*!< I2C Msp DeInit callback                   */
S
N#endif  /* USE_HAL_I2C_REGISTER_CALLBACKS */
N} I2C_HandleTypeDef;
N
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
S/**
S  * @brief  HAL I2C Callback ID enumeration definition
S  */
Stypedef enum
S{
S  HAL_I2C_MASTER_TX_COMPLETE_CB_ID      = 0x00U,    /*!< I2C Master Tx Transfer completed callback ID  */
S  HAL_I2C_MASTER_RX_COMPLETE_CB_ID      = 0x01U,    /*!< I2C Master Rx Transfer completed callback ID  */
S  HAL_I2C_SLAVE_TX_COMPLETE_CB_ID       = 0x02U,    /*!< I2C Slave Tx Transfer completed callback ID   */
S  HAL_I2C_SLAVE_RX_COMPLETE_CB_ID       = 0x03U,    /*!< I2C Slave Rx Transfer completed callback ID   */
S  HAL_I2C_LISTEN_COMPLETE_CB_ID         = 0x04U,    /*!< I2C Listen Complete callback ID               */
S  HAL_I2C_MEM_TX_COMPLETE_CB_ID         = 0x05U,    /*!< I2C Memory Tx Transfer callback ID            */
S  HAL_I2C_MEM_RX_COMPLETE_CB_ID         = 0x06U,    /*!< I2C Memory Rx Transfer completed callback ID  */
S  HAL_I2C_ERROR_CB_ID                   = 0x07U,    /*!< I2C Error callback ID                         */
S  HAL_I2C_ABORT_CB_ID                   = 0x08U,    /*!< I2C Abort callback ID                         */
S
S  HAL_I2C_MSPINIT_CB_ID                 = 0x09U,    /*!< I2C Msp Init callback ID                      */
S  HAL_I2C_MSPDEINIT_CB_ID               = 0x0AU     /*!< I2C Msp DeInit callback ID                    */
S
S} HAL_I2C_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL I2C Callback pointer definition
S  */
Stypedef  void (*pI2C_CallbackTypeDef)(I2C_HandleTypeDef *hi2c); /*!< pointer to an I2C callback function */
Stypedef  void (*pI2C_AddrCallbackTypeDef)(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode); /*!< pointer to an I2C Address Match callback function */
S
N#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup I2C_Exported_Constants I2C Exported Constants
N  * @{
N  */
N
N/** @defgroup I2C_duty_cycle_in_fast_mode I2C duty cycle in fast mode
N  * @{
N  */
N#define I2C_DUTYCYCLE_2                 0x00000000U
N#define I2C_DUTYCYCLE_16_9              I2C_CCR_DUTY
N/**
N  * @}
N  */
N
N/** @defgroup I2C_addressing_mode I2C addressing mode
N  * @{
N  */
N#define I2C_ADDRESSINGMODE_7BIT         0x00004000U
N#define I2C_ADDRESSINGMODE_10BIT        (I2C_OAR1_ADDMODE | 0x00004000U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_dual_addressing_mode  I2C dual addressing mode
N  * @{
N  */
N#define I2C_DUALADDRESS_DISABLE        0x00000000U
N#define I2C_DUALADDRESS_ENABLE         I2C_OAR2_ENDUAL
N/**
N  * @}
N  */
N
N/** @defgroup I2C_general_call_addressing_mode I2C general call addressing mode
N  * @{
N  */
N#define I2C_GENERALCALL_DISABLE        0x00000000U
N#define I2C_GENERALCALL_ENABLE         I2C_CR1_ENGC
N/**
N  * @}
N  */
N
N/** @defgroup I2C_nostretch_mode I2C nostretch mode
N  * @{
N  */
N#define I2C_NOSTRETCH_DISABLE          0x00000000U
N#define I2C_NOSTRETCH_ENABLE           I2C_CR1_NOSTRETCH
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Memory_Address_Size I2C Memory Address Size
N  * @{
N  */
N#define I2C_MEMADD_SIZE_8BIT            0x00000001U
N#define I2C_MEMADD_SIZE_16BIT           0x00000010U
N/**
N  * @}
N  */
N
N/** @defgroup I2C_XferDirection_definition I2C XferDirection definition
N  * @{
N  */
N#define I2C_DIRECTION_RECEIVE           0x00000000U
N#define I2C_DIRECTION_TRANSMIT          0x00000001U
N/**
N  * @}
N  */
N
N/** @defgroup I2C_XferOptions_definition I2C XferOptions definition
N  * @{
N  */
N#define  I2C_FIRST_FRAME                0x00000001U
N#define  I2C_FIRST_AND_NEXT_FRAME       0x00000002U
N#define  I2C_NEXT_FRAME                 0x00000004U
N#define  I2C_FIRST_AND_LAST_FRAME       0x00000008U
N#define  I2C_LAST_FRAME_NO_STOP         0x00000010U
N#define  I2C_LAST_FRAME                 0x00000020U
N
N/* List of XferOptions in usage of :
N * 1- Restart condition in all use cases (direction change or not)
N */
N#define  I2C_OTHER_FRAME                (0x00AA0000U)
N#define  I2C_OTHER_AND_LAST_FRAME       (0xAA000000U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Interrupt_configuration_definition I2C Interrupt configuration definition
N  * @brief I2C Interrupt definition
N  *        Elements values convention: 0xXXXXXXXX
N  *           - XXXXXXXX  : Interrupt control mask
N  * @{
N  */
N#define I2C_IT_BUF                      I2C_CR2_ITBUFEN
N#define I2C_IT_EVT                      I2C_CR2_ITEVTEN
N#define I2C_IT_ERR                      I2C_CR2_ITERREN
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Flag_definition I2C Flag definition
N  * @{
N  */
N
N#define I2C_FLAG_OVR                    0x00010800U
N#define I2C_FLAG_AF                     0x00010400U
N#define I2C_FLAG_ARLO                   0x00010200U
N#define I2C_FLAG_BERR                   0x00010100U
N#define I2C_FLAG_TXE                    0x00010080U
N#define I2C_FLAG_RXNE                   0x00010040U
N#define I2C_FLAG_STOPF                  0x00010010U
N#define I2C_FLAG_ADD10                  0x00010008U
N#define I2C_FLAG_BTF                    0x00010004U
N#define I2C_FLAG_ADDR                   0x00010002U
N#define I2C_FLAG_SB                     0x00010001U
N#define I2C_FLAG_DUALF                  0x00100080U
N#define I2C_FLAG_GENCALL                0x00100010U
N#define I2C_FLAG_TRA                    0x00100004U
N#define I2C_FLAG_BUSY                   0x00100002U
N#define I2C_FLAG_MSL                    0x00100001U
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N
N/** @defgroup I2C_Exported_Macros I2C Exported Macros
N  * @{
N  */
N
N/** @brief Reset I2C handle state.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
S#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                do{                                                   \
S                                                                    (__HANDLE__)->State = HAL_I2C_STATE_RESET;       \
S                                                                    (__HANDLE__)->MspInitCallback = NULL;            \
S                                                                    (__HANDLE__)->MspDeInitCallback = NULL;          \
S                                                                  } while(0)
X#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                do{                                                                                                                       (__HANDLE__)->State = HAL_I2C_STATE_RESET;                                                                           (__HANDLE__)->MspInitCallback = NULL;                                                                                (__HANDLE__)->MspDeInitCallback = NULL;                                                                            } while(0)
N#else
N#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                ((__HANDLE__)->State = HAL_I2C_STATE_RESET)
N#endif
N
N/** @brief  Enable or disable the specified I2C interrupts.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the interrupt source to enable or disable.
N  *         This parameter can be one of the following values:
N  *            @arg I2C_IT_BUF: Buffer interrupt enable
N  *            @arg I2C_IT_EVT: Event interrupt enable
N  *            @arg I2C_IT_ERR: Error interrupt enable
N  * @retval None
N  */
N#define __HAL_I2C_ENABLE_IT(__HANDLE__, __INTERRUPT__)   SET_BIT((__HANDLE__)->Instance->CR2,(__INTERRUPT__))
N#define __HAL_I2C_DISABLE_IT(__HANDLE__, __INTERRUPT__)  CLEAR_BIT((__HANDLE__)->Instance->CR2, (__INTERRUPT__))
N
N/** @brief  Checks if the specified I2C interrupt source is enabled or disabled.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the I2C interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg I2C_IT_BUF: Buffer interrupt enable
N  *            @arg I2C_IT_EVT: Event interrupt enable
N  *            @arg I2C_IT_ERR: Error interrupt enable
N  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_I2C_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Checks whether the specified I2C flag is set or not.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg I2C_FLAG_OVR: Overrun/Underrun flag
N  *            @arg I2C_FLAG_AF: Acknowledge failure flag
N  *            @arg I2C_FLAG_ARLO: Arbitration lost flag
N  *            @arg I2C_FLAG_BERR: Bus error flag
N  *            @arg I2C_FLAG_TXE: Data register empty flag
N  *            @arg I2C_FLAG_RXNE: Data register not empty flag
N  *            @arg I2C_FLAG_STOPF: Stop detection flag
N  *            @arg I2C_FLAG_ADD10: 10-bit header sent flag
N  *            @arg I2C_FLAG_BTF: Byte transfer finished flag
N  *            @arg I2C_FLAG_ADDR: Address sent flag
N  *                                Address matched flag
N  *            @arg I2C_FLAG_SB: Start bit flag
N  *            @arg I2C_FLAG_DUALF: Dual flag
N  *            @arg I2C_FLAG_GENCALL: General call header flag
N  *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
N  *            @arg I2C_FLAG_BUSY: Bus busy flag
N  *            @arg I2C_FLAG_MSL: Master/Slave flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_I2C_GET_FLAG(__HANDLE__, __FLAG__) ((((uint8_t)((__FLAG__) >> 16U)) == 0x01U) ? \
N                                                  (((((__HANDLE__)->Instance->SR1) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET) : \
N                                                  (((((__HANDLE__)->Instance->SR2) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET))
X#define __HAL_I2C_GET_FLAG(__HANDLE__, __FLAG__) ((((uint8_t)((__FLAG__) >> 16U)) == 0x01U) ?                                                   (((((__HANDLE__)->Instance->SR1) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET) :                                                   (((((__HANDLE__)->Instance->SR2) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET))
N
N/** @brief  Clears the I2C pending flags which are cleared by writing 0 in a specific bit.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __FLAG__ specifies the flag to clear.
N  *         This parameter can be any combination of the following values:
N  *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
N  *            @arg I2C_FLAG_AF: Acknowledge failure flag
N  *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
N  *            @arg I2C_FLAG_BERR: Bus error flag
N  * @retval None
N  */
N#define __HAL_I2C_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->SR1 = ~((__FLAG__) & I2C_FLAG_MASK))
N
N/** @brief  Clears the I2C ADDR pending flag.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  *         This parameter can be I2C where x: 1, 2, or 3 to select the I2C peripheral.
N  * @retval None
N  */
N#define __HAL_I2C_CLEAR_ADDRFLAG(__HANDLE__)    \
N  do{                                           \
N    __IO uint32_t tmpreg = 0x00U;               \
N    tmpreg = (__HANDLE__)->Instance->SR1;       \
N    tmpreg = (__HANDLE__)->Instance->SR2;       \
N    UNUSED(tmpreg);                             \
N  } while(0)
X#define __HAL_I2C_CLEAR_ADDRFLAG(__HANDLE__)      do{                                               __IO uint32_t tmpreg = 0x00U;                   tmpreg = (__HANDLE__)->Instance->SR1;           tmpreg = (__HANDLE__)->Instance->SR2;           UNUSED(tmpreg);                               } while(0)
N
N/** @brief  Clears the I2C STOPF pending flag.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_CLEAR_STOPFLAG(__HANDLE__)           \
N  do{                                                  \
N    __IO uint32_t tmpreg = 0x00U;                      \
N    tmpreg = (__HANDLE__)->Instance->SR1;              \
N    SET_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE);  \
N    UNUSED(tmpreg);                                    \
N  } while(0)
X#define __HAL_I2C_CLEAR_STOPFLAG(__HANDLE__)             do{                                                      __IO uint32_t tmpreg = 0x00U;                          tmpreg = (__HANDLE__)->Instance->SR1;                  SET_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE);      UNUSED(tmpreg);                                      } while(0)
N
N/** @brief  Enable the specified I2C peripheral.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_ENABLE(__HANDLE__)                  SET_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE)
N
N/** @brief  Disable the specified I2C peripheral.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_DISABLE(__HANDLE__)                 CLEAR_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE)
N
N/**
N  * @}
N  */
N
N/* Include I2C HAL Extension module */
N#include "stm32f4xx_hal_i2c_ex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_i2c_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_i2c_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of I2C HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_I2C_EX_H
N#define __STM32F4xx_HAL_I2C_EX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if  defined(I2C_FLTR_ANOFF)&&defined(I2C_FLTR_DNF)
X#if  1L&&1L
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup I2CEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup I2CEx_Exported_Constants I2C Exported Constants
N  * @{
N  */
N
N/** @defgroup I2CEx_Analog_Filter I2C Analog Filter
N  * @{
N  */
N#define I2C_ANALOGFILTER_ENABLE        0x00000000U
N#define I2C_ANALOGFILTER_DISABLE       I2C_FLTR_ANOFF
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup I2CEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup I2CEx_Exported_Functions_Group1
N  * @{
N  */
N/* Peripheral Control functions  ************************************************/
NHAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter);
NHAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2CEx_Private_Constants I2C Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup I2CEx_Private_Macros I2C Private Macros
N  * @{
N  */
N#define IS_I2C_ANALOG_FILTER(FILTER) (((FILTER) == I2C_ANALOGFILTER_ENABLE) || \
N                                      ((FILTER) == I2C_ANALOGFILTER_DISABLE))
X#define IS_I2C_ANALOG_FILTER(FILTER) (((FILTER) == I2C_ANALOGFILTER_ENABLE) ||                                       ((FILTER) == I2C_ANALOGFILTER_DISABLE))
N#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000FU)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_I2C_EX_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 530 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_i2c.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup I2C_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N/* Initialization and de-initialization functions******************************/
NHAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c);
N
N/* Callbacks Register/UnRegister functions  ***********************************/
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
SHAL_StatusTypeDef HAL_I2C_RegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID, pI2C_CallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_I2C_UnRegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID);
S
SHAL_StatusTypeDef HAL_I2C_RegisterAddrCallback(I2C_HandleTypeDef *hi2c, pI2C_AddrCallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_I2C_UnRegisterAddrCallback(I2C_HandleTypeDef *hi2c);
N#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group2 Input and Output operation functions
N  * @{
N  */
N/* IO operation functions  ****************************************************/
N/******* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout);
N
N/******* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
N
NHAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress);
N
N/******* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
N
NHAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
N * @{
N */
N/******* I2C IRQHandler and Callbacks used in non blocking modes (Interrupt and DMA) */
Nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode);
Nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
N  * @{
N  */
N/* Peripheral State, Mode and Error functions  *********************************/
NHAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c);
NHAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c);
Nuint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Constants I2C Private Constants
N  * @{
N  */
N#define I2C_FLAG_MASK                    0x0000FFFFU
N#define I2C_MIN_PCLK_FREQ_STANDARD       2000000U     /*!< 2 MHz                     */
N#define I2C_MIN_PCLK_FREQ_FAST           4000000U     /*!< 4 MHz                     */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup I2C_Private_Macros I2C Private Macros
N  * @{
N  */
N
N#define I2C_MIN_PCLK_FREQ(__PCLK__, __SPEED__)             (((__SPEED__) <= 100000U) ? ((__PCLK__) < I2C_MIN_PCLK_FREQ_STANDARD) : ((__PCLK__) < I2C_MIN_PCLK_FREQ_FAST))
N#define I2C_CCR_CALCULATION(__PCLK__, __SPEED__, __COEFF__)     (((((__PCLK__) - 1U)/((__SPEED__) * (__COEFF__))) + 1U) & I2C_CCR_CCR)
N#define I2C_FREQRANGE(__PCLK__)                            ((__PCLK__)/1000000U)
N#define I2C_RISE_TIME(__FREQRANGE__, __SPEED__)            (((__SPEED__) <= 100000U) ? ((__FREQRANGE__) + 1U) : ((((__FREQRANGE__) * 300U) / 1000U) + 1U))
N#define I2C_SPEED_STANDARD(__PCLK__, __SPEED__)            ((I2C_CCR_CALCULATION((__PCLK__), (__SPEED__), 2U) < 4U)? 4U:I2C_CCR_CALCULATION((__PCLK__), (__SPEED__), 2U))
N#define I2C_SPEED_FAST(__PCLK__, __SPEED__, __DUTYCYCLE__) (((__DUTYCYCLE__) == I2C_DUTYCYCLE_2)? I2C_CCR_CALCULATION((__PCLK__), (__SPEED__), 3U) : (I2C_CCR_CALCULATION((__PCLK__), (__SPEED__), 25U) | I2C_DUTYCYCLE_16_9))
N#define I2C_SPEED(__PCLK__, __SPEED__, __DUTYCYCLE__)      (((__SPEED__) <= 100000U)? (I2C_SPEED_STANDARD((__PCLK__), (__SPEED__))) : \
N                                                                  ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__)) & I2C_CCR_CCR) == 0U)? 1U : \
N                                                                  ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__))) | I2C_CCR_FS))
X#define I2C_SPEED(__PCLK__, __SPEED__, __DUTYCYCLE__)      (((__SPEED__) <= 100000U)? (I2C_SPEED_STANDARD((__PCLK__), (__SPEED__))) :                                                                   ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__)) & I2C_CCR_CCR) == 0U)? 1U :                                                                   ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__))) | I2C_CCR_FS))
N
N#define I2C_7BIT_ADD_WRITE(__ADDRESS__)                    ((uint8_t)((__ADDRESS__) & (uint8_t)(~I2C_OAR1_ADD0)))
N#define I2C_7BIT_ADD_READ(__ADDRESS__)                     ((uint8_t)((__ADDRESS__) | I2C_OAR1_ADD0))
N
N#define I2C_10BIT_ADDRESS(__ADDRESS__)                     ((uint8_t)((uint16_t)((__ADDRESS__) & (uint16_t)0x00FF)))
N#define I2C_10BIT_HEADER_WRITE(__ADDRESS__)                ((uint8_t)((uint16_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)0x0300)) >> 7) | (uint16_t)0x00F0)))
N#define I2C_10BIT_HEADER_READ(__ADDRESS__)                 ((uint8_t)((uint16_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)0x0300)) >> 7) | (uint16_t)(0x00F1))))
N
N#define I2C_MEM_ADD_MSB(__ADDRESS__)                       ((uint8_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)0xFF00)) >> 8)))
N#define I2C_MEM_ADD_LSB(__ADDRESS__)                       ((uint8_t)((uint16_t)((__ADDRESS__) & (uint16_t)0x00FF)))
N
N/** @defgroup I2C_IS_RTC_Definitions I2C Private macros to check input parameters
N  * @{
N  */
N#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DUTYCYCLE_2) || \
N                                  ((CYCLE) == I2C_DUTYCYCLE_16_9))
X#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DUTYCYCLE_2) ||                                   ((CYCLE) == I2C_DUTYCYCLE_16_9))
N#define IS_I2C_ADDRESSING_MODE(ADDRESS) (((ADDRESS) == I2C_ADDRESSINGMODE_7BIT) || \
N                                         ((ADDRESS) == I2C_ADDRESSINGMODE_10BIT))
X#define IS_I2C_ADDRESSING_MODE(ADDRESS) (((ADDRESS) == I2C_ADDRESSINGMODE_7BIT) ||                                          ((ADDRESS) == I2C_ADDRESSINGMODE_10BIT))
N#define IS_I2C_DUAL_ADDRESS(ADDRESS) (((ADDRESS) == I2C_DUALADDRESS_DISABLE) || \
N                                      ((ADDRESS) == I2C_DUALADDRESS_ENABLE))
X#define IS_I2C_DUAL_ADDRESS(ADDRESS) (((ADDRESS) == I2C_DUALADDRESS_DISABLE) ||                                       ((ADDRESS) == I2C_DUALADDRESS_ENABLE))
N#define IS_I2C_GENERAL_CALL(CALL) (((CALL) == I2C_GENERALCALL_DISABLE) || \
N                                   ((CALL) == I2C_GENERALCALL_ENABLE))
X#define IS_I2C_GENERAL_CALL(CALL) (((CALL) == I2C_GENERALCALL_DISABLE) ||                                    ((CALL) == I2C_GENERALCALL_ENABLE))
N#define IS_I2C_NO_STRETCH(STRETCH) (((STRETCH) == I2C_NOSTRETCH_DISABLE) || \
N                                    ((STRETCH) == I2C_NOSTRETCH_ENABLE))
X#define IS_I2C_NO_STRETCH(STRETCH) (((STRETCH) == I2C_NOSTRETCH_DISABLE) ||                                     ((STRETCH) == I2C_NOSTRETCH_ENABLE))
N#define IS_I2C_MEMADD_SIZE(SIZE) (((SIZE) == I2C_MEMADD_SIZE_8BIT) || \
N                                  ((SIZE) == I2C_MEMADD_SIZE_16BIT))
X#define IS_I2C_MEMADD_SIZE(SIZE) (((SIZE) == I2C_MEMADD_SIZE_8BIT) ||                                   ((SIZE) == I2C_MEMADD_SIZE_16BIT))
N#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) > 0U) && ((SPEED) <= 400000U))
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1) (((ADDRESS1) & 0xFFFFFC00U) == 0U)
N#define IS_I2C_OWN_ADDRESS2(ADDRESS2) (((ADDRESS2) & 0xFFFFFF01U) == 0U)
N#define IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)      (((REQUEST) == I2C_FIRST_FRAME)              || \
N                                                       ((REQUEST) == I2C_FIRST_AND_NEXT_FRAME)     || \
N                                                       ((REQUEST) == I2C_NEXT_FRAME)               || \
N                                                       ((REQUEST) == I2C_FIRST_AND_LAST_FRAME)     || \
N                                                       ((REQUEST) == I2C_LAST_FRAME)               || \
N                                                       ((REQUEST) == I2C_LAST_FRAME_NO_STOP)       || \
N                                                       IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST))
X#define IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)      (((REQUEST) == I2C_FIRST_FRAME)              ||                                                        ((REQUEST) == I2C_FIRST_AND_NEXT_FRAME)     ||                                                        ((REQUEST) == I2C_NEXT_FRAME)               ||                                                        ((REQUEST) == I2C_FIRST_AND_LAST_FRAME)     ||                                                        ((REQUEST) == I2C_LAST_FRAME)               ||                                                        ((REQUEST) == I2C_LAST_FRAME_NO_STOP)       ||                                                        IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST))
N
N#define IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST) (((REQUEST) == I2C_OTHER_FRAME)     || \
N                                                        ((REQUEST) == I2C_OTHER_AND_LAST_FRAME))
X#define IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST) (((REQUEST) == I2C_OTHER_FRAME)     ||                                                         ((REQUEST) == I2C_OTHER_AND_LAST_FRAME))
N
N#define I2C_CHECK_FLAG(__ISR__, __FLAG__)         ((((__ISR__) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET)
N#define I2C_CHECK_IT_SOURCE(__CR1__, __IT__)      ((((__CR1__) & (__IT__)) == (__IT__)) ? SET : RESET)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Functions I2C Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F4xx_HAL_I2C_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 267 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_I2C_MODULE_ENABLED */
N
N#ifdef HAL_IWDG_MODULE_ENABLED
S#include "stm32f4xx_hal_iwdg.h"
N#endif /* HAL_IWDG_MODULE_ENABLED */
N
N#ifdef HAL_LCD_MODULE_ENABLED
S#include "stm32f4xx_hal_lcd.h"
N#endif /* HAL_LCD_MODULE_ENABLED */
N
N#ifdef HAL_LPTIM_MODULE_ENABLED
S#include "stm32f4xx_hal_lptim.h"
N#endif /* HAL_LPTIM_MODULE_ENABLED */
N
N#ifdef HAL_OPAMP_MODULE_ENABLED
S#include "stm32f4xx_hal_opamp.h"
N#endif /* HAL_OPAMP_MODULE_ENABLED */
N
N#ifdef HAL_PWR_MODULE_ENABLED
N#include "stm32f4xx_hal_pwr.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_pwr.h
N  * @author  MCD Application Team
N  * @brief   Header file of PWR HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_PWR_H
N#define __STM32F4xx_HAL_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PWR
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup PWR_Exported_Types PWR Exported Types
N  * @{
N  */
N   
N/**
N  * @brief  PWR PVD configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t PVDLevel;   /*!< PVDLevel: Specifies the PVD detection level.
N                            This parameter can be a value of @ref PWR_PVD_detection_level */
N
N  uint32_t Mode;      /*!< Mode: Specifies the operating mode for the selected pins.
N                           This parameter can be a value of @ref PWR_PVD_Mode */
N}PWR_PVDTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup PWR_Exported_Constants PWR Exported Constants
N  * @{
N  */
N  
N/** @defgroup PWR_WakeUp_Pins PWR WakeUp Pins
N  * @{
N  */
N#define PWR_WAKEUP_PIN1                 0x00000100U
N/**
N  * @}
N  */
N
N/** @defgroup PWR_PVD_detection_level PWR PVD detection level
N  * @{
N  */ 
N#define PWR_PVDLEVEL_0                  PWR_CR_PLS_LEV0
N#define PWR_PVDLEVEL_1                  PWR_CR_PLS_LEV1
N#define PWR_PVDLEVEL_2                  PWR_CR_PLS_LEV2
N#define PWR_PVDLEVEL_3                  PWR_CR_PLS_LEV3
N#define PWR_PVDLEVEL_4                  PWR_CR_PLS_LEV4
N#define PWR_PVDLEVEL_5                  PWR_CR_PLS_LEV5
N#define PWR_PVDLEVEL_6                  PWR_CR_PLS_LEV6
N#define PWR_PVDLEVEL_7                  PWR_CR_PLS_LEV7/* External input analog voltage 
N                                                          (Compare internally to VREFINT) */
N/**
N  * @}
N  */   
N 
N/** @defgroup PWR_PVD_Mode PWR PVD Mode
N  * @{
N  */
N#define PWR_PVD_MODE_NORMAL                 0x00000000U   /*!< basic mode is used */
N#define PWR_PVD_MODE_IT_RISING              0x00010001U   /*!< External Interrupt Mode with Rising edge trigger detection */
N#define PWR_PVD_MODE_IT_FALLING             0x00010002U   /*!< External Interrupt Mode with Falling edge trigger detection */
N#define PWR_PVD_MODE_IT_RISING_FALLING      0x00010003U   /*!< External Interrupt Mode with Rising/Falling edge trigger detection */
N#define PWR_PVD_MODE_EVENT_RISING           0x00020001U   /*!< Event Mode with Rising edge trigger detection */
N#define PWR_PVD_MODE_EVENT_FALLING          0x00020002U   /*!< Event Mode with Falling edge trigger detection */
N#define PWR_PVD_MODE_EVENT_RISING_FALLING   0x00020003U   /*!< Event Mode with Rising/Falling edge trigger detection */
N/**
N  * @}
N  */
N
N
N/** @defgroup PWR_Regulator_state_in_STOP_mode PWR Regulator state in SLEEP/STOP mode
N  * @{
N  */
N#define PWR_MAINREGULATOR_ON                        0x00000000U
N#define PWR_LOWPOWERREGULATOR_ON                    PWR_CR_LPDS
N/**
N  * @}
N  */
N    
N/** @defgroup PWR_SLEEP_mode_entry PWR SLEEP mode entry
N  * @{
N  */
N#define PWR_SLEEPENTRY_WFI              ((uint8_t)0x01)
N#define PWR_SLEEPENTRY_WFE              ((uint8_t)0x02)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_STOP_mode_entry PWR STOP mode entry
N  * @{
N  */
N#define PWR_STOPENTRY_WFI               ((uint8_t)0x01)
N#define PWR_STOPENTRY_WFE               ((uint8_t)0x02)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Flag PWR Flag
N  * @{
N  */
N#define PWR_FLAG_WU                     PWR_CSR_WUF
N#define PWR_FLAG_SB                     PWR_CSR_SBF
N#define PWR_FLAG_PVDO                   PWR_CSR_PVDO
N#define PWR_FLAG_BRR                    PWR_CSR_BRR
N#define PWR_FLAG_VOSRDY                 PWR_CSR_VOSRDY
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWR_Exported_Macro PWR Exported Macro
N  * @{
N  */
N
N/** @brief  Check PWR flag is set or not.
N  * @param  __FLAG__ specifies the flag to check.
N  *           This parameter can be one of the following values:
N  *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
N  *                  was received from the WKUP pin or from the RTC alarm (Alarm A 
N  *                  or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
N  *                  An additional wakeup event is detected if the WKUP pin is enabled 
N  *                  (by setting the EWUP bit) when the WKUP pin level is already high.  
N  *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
N  *                  resumed from StandBy mode.    
N  *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
N  *                  by the HAL_PWR_EnablePVD() function. The PVD is stopped by Standby mode 
N  *                  For this reason, this bit is equal to 0 after Standby or reset
N  *                  until the PVDE bit is set.
N  *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
N  *                  when the device wakes up from Standby mode or by a system reset 
N  *                  or power reset.  
N  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
N  *                 scaling output selection is ready.
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_PWR_GET_FLAG(__FLAG__) ((PWR->CSR & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the PWR's pending flags.
N  * @param  __FLAG__ specifies the flag to clear.
N  *          This parameter can be one of the following values:
N  *            @arg PWR_FLAG_WU: Wake Up flag
N  *            @arg PWR_FLAG_SB: StandBy flag
N  */
N#define __HAL_PWR_CLEAR_FLAG(__FLAG__) (PWR->CR |=  (__FLAG__) << 2U)
N
N/**
N  * @brief Enable the PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_IT()   (EXTI->IMR |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable the PVD EXTI Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_IT()  (EXTI->IMR &= ~(PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Enable event on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_EVENT()   (EXTI->EMR |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable event on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_EVENT()  (EXTI->EMR &= ~(PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Enable the PVD Extended Interrupt Rising Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE()   SET_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief Disable the PVD Extended Interrupt Rising Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE()  CLEAR_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief Enable the PVD Extended Interrupt Falling Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE()   SET_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)
N
N
N/**
N  * @brief Disable the PVD Extended Interrupt Falling Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE()  CLEAR_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)
N
N
N/**
N  * @brief  PVD EXTI line configuration: set rising & falling edge trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_FALLING_EDGE()   do{__HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();\
N                                                             __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();\
N                                                            }while(0U)
X#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_FALLING_EDGE()   do{__HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();                                                             __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();                                                            }while(0U)
N
N/**
N  * @brief Disable the PVD Extended Interrupt Rising & Falling Trigger.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE()  do{__HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();\
N                                                             __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();\
N                                                            }while(0U) 
X#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE()  do{__HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();                                                             __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();                                                            }while(0U) 
N
N/**
N  * @brief checks whether the specified PVD Exti interrupt flag is set or not.
N  * @retval EXTI PVD Line Status.
N  */
N#define __HAL_PWR_PVD_EXTI_GET_FLAG()  (EXTI->PR & (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Clear the PVD Exti flag.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_CLEAR_FLAG()  (EXTI->PR = (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief  Generates a Software interrupt on PVD EXTI line.
N  * @retval None
N  */
N#define __HAL_PWR_PVD_EXTI_GENERATE_SWIT() (EXTI->SWIER |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @}
N  */
N
N/* Include PWR HAL Extension module */
N#include "stm32f4xx_hal_pwr_ex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_pwr_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_pwr_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of PWR HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_PWR_EX_H
N#define __STM32F4xx_HAL_PWR_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PWREx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup PWREx_Exported_Constants PWREx Exported Constants
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L
S   
S/** @defgroup PWREx_Regulator_state_in_UnderDrive_mode PWREx Regulator state in UnderDrive mode
S  * @{
S  */
S#define PWR_MAINREGULATOR_UNDERDRIVE_ON                       PWR_CR_MRUDS
S#define PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON                   ((uint32_t)(PWR_CR_LPDS | PWR_CR_LPUDS))
S/**
S  * @}
S  */ 
S  
S/** @defgroup PWREx_Over_Under_Drive_Flag PWREx Over Under Drive Flag
S  * @{
S  */
S#define PWR_FLAG_ODRDY                  PWR_CSR_ODRDY
S#define PWR_FLAG_ODSWRDY                PWR_CSR_ODSWRDY
S#define PWR_FLAG_UDRDY                  PWR_CSR_UDSWRDY
S/**
S  * @}
S  */
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N/** @defgroup PWREx_Regulator_Voltage_Scale PWREx Regulator Voltage Scale
N  * @{
N  */
N#if defined(STM32F405xx) || defined(STM32F407xx) || defined(STM32F415xx) || defined(STM32F417xx)   
X#if 0L || 0L || 0L || 0L   
S#define PWR_REGULATOR_VOLTAGE_SCALE1         PWR_CR_VOS             /* Scale 1 mode(default value at reset): the maximum value of fHCLK = 168 MHz. */
S#define PWR_REGULATOR_VOLTAGE_SCALE2         0x00000000U            /* Scale 2 mode: the maximum value of fHCLK = 144 MHz. */
N#else
N#define PWR_REGULATOR_VOLTAGE_SCALE1         PWR_CR_VOS             /* Scale 1 mode(default value at reset): the maximum value of fHCLK is 168 MHz. It can be extended to
N                                                                       180 MHz by activating the over-drive mode. */
N#define PWR_REGULATOR_VOLTAGE_SCALE2         PWR_CR_VOS_1           /* Scale 2 mode: the maximum value of fHCLK is 144 MHz. It can be extended to
N                                                                       168 MHz by activating the over-drive mode. */
N#define PWR_REGULATOR_VOLTAGE_SCALE3         PWR_CR_VOS_0           /* Scale 3 mode: the maximum value of fHCLK is 120 MHz. */
N#endif /* STM32F405xx || STM32F407xx || STM32F415xx || STM32F417xx */ 
N/**
N  * @}
N  */
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L
S/** @defgroup PWREx_WakeUp_Pins PWREx WakeUp Pins
S  * @{
S  */
S#define PWR_WAKEUP_PIN2                 0x00000080U
S#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
S    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) 
X#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F412Zx) || defined(STM32F412Vx) ||     defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) 
S#define PWR_WAKEUP_PIN3                 0x00000040U
S#endif /* STM32F410xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Zx || STM32F412Vx || \
S          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
S/**
S  * @}
S  */   
S#endif /* STM32F410xx || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
N          STM32F413xx || STM32F423xx */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWREx_Exported_Constants PWREx Exported Constants
N  *  @{
N  */
N
N#if defined(STM32F405xx) || defined(STM32F407xx) || defined(STM32F415xx) || defined(STM32F417xx)
X#if 0L || 0L || 0L || 0L
S/** @brief  macros configure the main internal regulator output voltage.
S  * @param  __REGULATOR__ specifies the regulator output voltage to achieve
S  *         a tradeoff between performance and power consumption when the device does
S  *         not operate at the maximum frequency (refer to the datasheets for more details).
S  *          This parameter can be one of the following values:
S  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode
S  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode
S  * @retval None
S  */
S#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                     \
S                                                            __IO uint32_t tmpreg = 0x00U;                        \
S                                                            MODIFY_REG(PWR->CR, PWR_CR_VOS, (__REGULATOR__));   \
S                                                            /* Delay after an RCC peripheral clock enabling */  \
S                                                            tmpreg = READ_BIT(PWR->CR, PWR_CR_VOS);             \
S                                                            UNUSED(tmpreg);                                     \
S                                                          } while(0U)
X#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                                                                                 __IO uint32_t tmpreg = 0x00U;                                                                                    MODIFY_REG(PWR->CR, PWR_CR_VOS, (__REGULATOR__));                                                                                                                              tmpreg = READ_BIT(PWR->CR, PWR_CR_VOS);                                                                         UNUSED(tmpreg);                                                                                               } while(0U)
N#else
N/** @brief  macros configure the main internal regulator output voltage.
N  * @param  __REGULATOR__ specifies the regulator output voltage to achieve
N  *         a tradeoff between performance and power consumption when the device does
N  *         not operate at the maximum frequency (refer to the datasheets for more details).
N  *          This parameter can be one of the following values:
N  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode
N  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode
N  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output Scale 3 mode
N  * @retval None
N  */
N#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                     \
N                                                            __IO uint32_t tmpreg = 0x00U;                        \
N                                                            MODIFY_REG(PWR->CR, PWR_CR_VOS, (__REGULATOR__));   \
N                                                            /* Delay after an RCC peripheral clock enabling */  \
N                                                            tmpreg = READ_BIT(PWR->CR, PWR_CR_VOS);             \
N                                                            UNUSED(tmpreg);                                     \
N                                                          } while(0U)
X#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do {                                                                                                                 __IO uint32_t tmpreg = 0x00U;                                                                                    MODIFY_REG(PWR->CR, PWR_CR_VOS, (__REGULATOR__));                                                                                                                              tmpreg = READ_BIT(PWR->CR, PWR_CR_VOS);                                                                         UNUSED(tmpreg);                                                                                               } while(0U)
N#endif /* STM32F405xx || STM32F407xx || STM32F415xx || STM32F417xx */ 
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L
S/** @brief Macros to enable or disable the Over drive mode.
S  * @note  These macros can be used only for STM32F42xx/STM3243xx devices.
S  */
S#define __HAL_PWR_OVERDRIVE_ENABLE() (*(__IO uint32_t *) CR_ODEN_BB = ENABLE)
S#define __HAL_PWR_OVERDRIVE_DISABLE() (*(__IO uint32_t *) CR_ODEN_BB = DISABLE)
S
S/** @brief Macros to enable or disable the Over drive switching.
S  * @note  These macros can be used only for STM32F42xx/STM3243xx devices. 
S  */
S#define __HAL_PWR_OVERDRIVESWITCHING_ENABLE() (*(__IO uint32_t *) CR_ODSWEN_BB = ENABLE)
S#define __HAL_PWR_OVERDRIVESWITCHING_DISABLE() (*(__IO uint32_t *) CR_ODSWEN_BB = DISABLE)
S
S/** @brief Macros to enable or disable the Under drive mode.
S  * @note  This mode is enabled only with STOP low power mode.
S  *        In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
S  *        mode is only available when the main regulator or the low power regulator 
S  *        is in low voltage mode.      
S  * @note  If the Under-drive mode was enabled, it is automatically disabled after 
S  *        exiting Stop mode. 
S  *        When the voltage regulator operates in Under-drive mode, an additional  
S  *        startup delay is induced when waking up from Stop mode.
S  */
S#define __HAL_PWR_UNDERDRIVE_ENABLE() (PWR->CR |= (uint32_t)PWR_CR_UDEN)
S#define __HAL_PWR_UNDERDRIVE_DISABLE() (PWR->CR &= (uint32_t)(~PWR_CR_UDEN))
S
S/** @brief  Check PWR flag is set or not.
S  * @note   These macros can be used only for STM32F42xx/STM3243xx devices.
S  * @param  __FLAG__ specifies the flag to check.
S  *         This parameter can be one of the following values:
S  *            @arg PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode
S  *                                 is ready 
S  *            @arg PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode
S  *                                   switching is ready  
S  *            @arg PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode
S  *                                 is enabled in Stop mode
S  * @retval The new state of __FLAG__ (TRUE or FALSE).
S  */
S#define __HAL_PWR_GET_ODRUDR_FLAG(__FLAG__) ((PWR->CSR & (__FLAG__)) == (__FLAG__))
S
S/** @brief Clear the Under-Drive Ready flag.
S  * @note  These macros can be used only for STM32F42xx/STM3243xx devices.
S  */
S#define __HAL_PWR_CLEAR_ODRUDR_FLAG() (PWR->CSR |= PWR_FLAG_UDRDY)
S
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup PWREx_Exported_Functions PWREx Exported Functions
N  *  @{
N  */
N 
N/** @addtogroup PWREx_Exported_Functions_Group1
N  * @{
N  */
Nvoid HAL_PWREx_EnableFlashPowerDown(void);
Nvoid HAL_PWREx_DisableFlashPowerDown(void); 
NHAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void);
NHAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void); 
Nuint32_t HAL_PWREx_GetVoltageRange(void);
NHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling);
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F401xC) ||\
N    defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) ||\
N    defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L ||    1L || 0L || 0L || 0L ||    0L || 0L || 0L || 0L
Nvoid HAL_PWREx_EnableMainRegulatorLowVoltage(void);
Nvoid HAL_PWREx_DisableMainRegulatorLowVoltage(void);
Nvoid HAL_PWREx_EnableLowRegulatorLowVoltage(void);
Nvoid HAL_PWREx_DisableLowRegulatorLowVoltage(void);
N#endif /* STM32F410xx || STM32F401xC || STM32F401xE || STM32F411xE || STM32F412Zx || STM32F412Vx ||\
N          STM32F412Rx || STM32F412Cx || STM32F413xx || STM32F423xx */
X#endif  
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F446xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L || 0L ||    0L || 0L
SHAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void);
SHAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void);
SHAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup PWREx_Private_Constants PWREx Private Constants
N  * @{
N  */
N
N/** @defgroup PWREx_register_alias_address PWREx Register alias address
N  * @{
N  */
N/* ------------- PWR registers bit address in the alias region ---------------*/
N/* --- CR Register ---*/
N/* Alias word address of FPDS bit */
N#define FPDS_BIT_NUMBER          PWR_CR_FPDS_Pos
N#define CR_FPDS_BB               (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (FPDS_BIT_NUMBER * 4U))
N
N/* Alias word address of ODEN bit   */
N#define ODEN_BIT_NUMBER          PWR_CR_ODEN_Pos
N#define CR_ODEN_BB               (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (ODEN_BIT_NUMBER * 4U))
N
N/* Alias word address of ODSWEN bit */
N#define ODSWEN_BIT_NUMBER        PWR_CR_ODSWEN_Pos
N#define CR_ODSWEN_BB             (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (ODSWEN_BIT_NUMBER * 4U))
N    
N/* Alias word address of MRLVDS bit */
N#define MRLVDS_BIT_NUMBER        PWR_CR_MRLVDS_Pos
N#define CR_MRLVDS_BB             (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (MRLVDS_BIT_NUMBER * 4U))
N
N/* Alias word address of LPLVDS bit */
N#define LPLVDS_BIT_NUMBER        PWR_CR_LPLVDS_Pos
N#define CR_LPLVDS_BB             (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPLVDS_BIT_NUMBER * 4U))
N
N /**
N  * @}
N  */
N
N/** @defgroup PWREx_CSR_register_alias PWRx CSR Register alias address
N  * @{
N  */  
N/* --- CSR Register ---*/
N/* Alias word address of BRE bit */
N#define BRE_BIT_NUMBER   PWR_CSR_BRE_Pos
N#define CSR_BRE_BB      (uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (BRE_BIT_NUMBER * 4U))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup PWREx_Private_Macros PWREx Private Macros
N  * @{
N  */
N
N/** @defgroup PWREx_IS_PWR_Definitions PWREx Private macros to check input parameters
N  * @{
N  */
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
N    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L || 0L ||    0L || 0L || 0L
S#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_UNDERDRIVE_ON) || \
S                                                ((REGULATOR) == PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON))
X#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_UNDERDRIVE_ON) ||                                                 ((REGULATOR) == PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON))
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
N
N#if defined(STM32F405xx) || defined(STM32F407xx) || defined(STM32F415xx) || defined(STM32F417xx)
X#if 0L || 0L || 0L || 0L
S#define IS_PWR_VOLTAGE_SCALING_RANGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) || \
S                                               ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2))
X#define IS_PWR_VOLTAGE_SCALING_RANGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) ||                                                ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2))
N#else
N#define IS_PWR_VOLTAGE_SCALING_RANGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) || \
N                                               ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2) || \
N                                               ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE3))
X#define IS_PWR_VOLTAGE_SCALING_RANGE(VOLTAGE) (((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) ||                                                ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2) ||                                                ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE3))
N#endif /* STM32F405xx || STM32F407xx || STM32F415xx || STM32F417xx */ 
N
N#if defined(STM32F446xx)
X#if 0L
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || ((PIN) == PWR_WAKEUP_PIN2))
S#elif defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F412Zx) ||\
S      defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
S      defined(STM32F423xx)
X#elif 0L || 0L || 0L || 0L ||      0L || 0L || 0L || 0L ||      0L
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || ((PIN) == PWR_WAKEUP_PIN2) || \
S                                ((PIN) == PWR_WAKEUP_PIN3))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || ((PIN) == PWR_WAKEUP_PIN2) ||                                 ((PIN) == PWR_WAKEUP_PIN3))
N#else
N#define IS_PWR_WAKEUP_PIN(PIN) ((PIN) == PWR_WAKEUP_PIN1)
N#endif /* STM32F446xx */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F4xx_HAL_PWR_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 275 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_pwr.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup PWR_Exported_Functions PWR Exported Functions
N  * @{
N  */
N  
N/** @addtogroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
Nvoid HAL_PWR_DeInit(void);
Nvoid HAL_PWR_EnableBkUpAccess(void);
Nvoid HAL_PWR_DisableBkUpAccess(void);
N/**
N  * @}
N  */
N
N/** @addtogroup PWR_Exported_Functions_Group2 Peripheral Control functions 
N  * @{
N  */
N/* Peripheral Control functions  **********************************************/
N/* PVD configuration */
Nvoid HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD);
Nvoid HAL_PWR_EnablePVD(void);
Nvoid HAL_PWR_DisablePVD(void);
N
N/* WakeUp pins configuration */
Nvoid HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx);
Nvoid HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx);
N
N/* Low Power modes entry */
Nvoid HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
Nvoid HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry);
Nvoid HAL_PWR_EnterSTANDBYMode(void);
N
N/* Power PVD IRQ Handler */
Nvoid HAL_PWR_PVD_IRQHandler(void);
Nvoid HAL_PWR_PVDCallback(void);
N
N/* Cortex System Control functions  *******************************************/
Nvoid HAL_PWR_EnableSleepOnExit(void);
Nvoid HAL_PWR_DisableSleepOnExit(void);
Nvoid HAL_PWR_EnableSEVOnPend(void);
Nvoid HAL_PWR_DisableSEVOnPend(void);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup PWR_Private_Constants PWR Private Constants
N  * @{
N  */
N
N/** @defgroup PWR_PVD_EXTI_Line PWR PVD EXTI Line
N  * @{
N  */
N#define PWR_EXTI_LINE_PVD  ((uint32_t)EXTI_IMR_MR16)  /*!< External interrupt line 16 Connected to the PVD EXTI Line */
N/**
N  * @}
N  */
N
N/** @defgroup PWR_register_alias_address PWR Register alias address
N  * @{
N  */
N/* ------------- PWR registers bit address in the alias region ---------------*/
N#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
N#define PWR_CR_OFFSET            0x00U
N#define PWR_CSR_OFFSET           0x04U
N#define PWR_CR_OFFSET_BB         (PWR_OFFSET + PWR_CR_OFFSET)
N#define PWR_CSR_OFFSET_BB        (PWR_OFFSET + PWR_CSR_OFFSET)
N/**
N  * @}
N  */
N
N/** @defgroup PWR_CR_register_alias PWR CR Register alias address
N  * @{
N  */
N/* --- CR Register ---*/
N/* Alias word address of DBP bit */
N#define DBP_BIT_NUMBER   PWR_CR_DBP_Pos
N#define CR_DBP_BB        (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_NUMBER * 4U))
N
N/* Alias word address of PVDE bit */
N#define PVDE_BIT_NUMBER  PWR_CR_PVDE_Pos
N#define CR_PVDE_BB       (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_NUMBER * 4U))
N
N/* Alias word address of VOS bit */
N#define VOS_BIT_NUMBER  PWR_CR_VOS_Pos
N#define CR_VOS_BB      (uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (VOS_BIT_NUMBER * 4U))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_CSR_register_alias PWR CSR Register alias address
N  * @{
N  */
N/* --- CSR Register ---*/
N/* Alias word address of EWUP bit */
N#define EWUP_BIT_NUMBER  PWR_CSR_EWUP_Pos
N#define CSR_EWUP_BB      (PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (EWUP_BIT_NUMBER * 4U))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup PWR_Private_Macros PWR Private Macros
N  * @{
N  */
N
N/** @defgroup PWR_IS_PWR_Definitions PWR Private macros to check input parameters
N  * @{
N  */
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)||                                  ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)||                                  ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)||                                  ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))
N#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) || \
N                              ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) || \
N                              ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) || \
N                              ((MODE) == PWR_PVD_MODE_NORMAL))
X#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) ||                               ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) ||                               ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) ||                               ((MODE) == PWR_PVD_MODE_NORMAL))
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) || \
N                                     ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) ||                                      ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))
N#define IS_PWR_SLEEP_ENTRY(ENTRY) (((ENTRY) == PWR_SLEEPENTRY_WFI) || ((ENTRY) == PWR_SLEEPENTRY_WFE))
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPENTRY_WFI) || ((ENTRY) == PWR_STOPENTRY_WFE))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F4xx_HAL_PWR_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 287 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_PWR_MODULE_ENABLED */
N
N#ifdef HAL_QSPI_MODULE_ENABLED
S#include "stm32f4xx_hal_qspi.h"
N#endif /* HAL_QSPI_MODULE_ENABLED */
N
N#ifdef HAL_RNG_MODULE_ENABLED
S#include "stm32f4xx_hal_rng.h"
N#endif /* HAL_RNG_MODULE_ENABLED */
N
N#ifdef HAL_RTC_MODULE_ENABLED
N#include "stm32f4xx_hal_rtc.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rtc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_rtc.h
N  * @author  MCD Application Team
N  * @brief   Header file of RTC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_RTC_H
N#define __STM32F4xx_HAL_RTC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RTC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RTC_Exported_Types RTC Exported Types
N  * @{
N  */
N
N/**
N  * @brief  HAL State structures definition
N  */
Ntypedef enum
N{
N  HAL_RTC_STATE_RESET             = 0x00U,  /*!< RTC not yet initialized or disabled */
N  HAL_RTC_STATE_READY             = 0x01U,  /*!< RTC initialized and ready for use   */
N  HAL_RTC_STATE_BUSY              = 0x02U,  /*!< RTC process is ongoing              */
N  HAL_RTC_STATE_TIMEOUT           = 0x03U,  /*!< RTC timeout state                   */
N  HAL_RTC_STATE_ERROR             = 0x04U   /*!< RTC error state                     */
N}HAL_RTCStateTypeDef;
N
N/**
N  * @brief  RTC Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t HourFormat;      /*!< Specifies the RTC Hour Format.
N                                 This parameter can be a value of @ref RTC_Hour_Formats */
N
N  uint32_t AsynchPrediv;    /*!< Specifies the RTC Asynchronous Predivider value.
N                                 This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F */
N
N  uint32_t SynchPrediv;     /*!< Specifies the RTC Synchronous Predivider value.
N                                 This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFFU */
N
N  uint32_t OutPut;          /*!< Specifies which signal will be routed to the RTC output.
N                                 This parameter can be a value of @ref RTC_Output_selection_Definitions */
N
N  uint32_t OutPutPolarity;  /*!< Specifies the polarity of the output signal.
N                                 This parameter can be a value of @ref RTC_Output_Polarity_Definitions */
N
N  uint32_t OutPutType;      /*!< Specifies the RTC Output Pin mode.
N                                 This parameter can be a value of @ref RTC_Output_Type_ALARM_OUT */
N}RTC_InitTypeDef;
N
N/**
N  * @brief  RTC Time structure definition
N  */
Ntypedef struct
N{
N  uint8_t Hours;            /*!< Specifies the RTC Time Hour.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected  */
N
N  uint8_t Minutes;          /*!< Specifies the RTC Time Minutes.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */
N
N  uint8_t Seconds;          /*!< Specifies the RTC Time Seconds.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */
N
N  uint8_t TimeFormat;       /*!< Specifies the RTC AM/PM Time.
N                                 This parameter can be a value of @ref RTC_AM_PM_Definitions */
N
N  uint32_t SubSeconds;     /*!< Specifies the RTC_SSR RTC Sub Second register content.
N                                 This parameter corresponds to a time unit range between [0-1] Second
N                                 with [1 Sec / SecondFraction +1] granularity */
N
N  uint32_t SecondFraction;  /*!< Specifies the range or granularity of Sub Second register content
N                                 corresponding to Synchronous pre-scaler factor value (PREDIV_S)
N                                 This parameter corresponds to a time unit range between [0-1] Second
N                                 with [1 Sec / SecondFraction +1] granularity.
N                                 This field will be used only by HAL_RTC_GetTime function */
N
N  uint32_t DayLightSaving;  /*!< Specifies DayLight Save Operation.
N                                 This parameter can be a value of @ref RTC_DayLightSaving_Definitions */
N
N  uint32_t StoreOperation;  /*!< Specifies RTC_StoreOperation value to be written in the BCK bit
N                                 in CR register to store the operation.
N                                 This parameter can be a value of @ref RTC_StoreOperation_Definitions */
N}RTC_TimeTypeDef;
N
N/**
N  * @brief  RTC Date structure definition
N  */
Ntypedef struct
N{
N  uint8_t WeekDay;  /*!< Specifies the RTC Date WeekDay.
N                         This parameter can be a value of @ref RTC_WeekDay_Definitions */
N
N  uint8_t Month;    /*!< Specifies the RTC Date Month (in BCD format).
N                         This parameter can be a value of @ref RTC_Month_Date_Definitions */
N
N  uint8_t Date;     /*!< Specifies the RTC Date.
N                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */
N
N  uint8_t Year;     /*!< Specifies the RTC Date Year.
N                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */
N
N}RTC_DateTypeDef;
N
N/**
N  * @brief  RTC Alarm structure definition
N  */
Ntypedef struct
N{
N  RTC_TimeTypeDef AlarmTime;     /*!< Specifies the RTC Alarm Time members */
N
N  uint32_t AlarmMask;            /*!< Specifies the RTC Alarm Masks.
N                                      This parameter can be a value of @ref RTC_AlarmMask_Definitions */
N
N  uint32_t AlarmSubSecondMask;   /*!< Specifies the RTC Alarm SubSeconds Masks.
N                                      This parameter can be a value of @ref RTC_Alarm_Sub_Seconds_Masks_Definitions */
N
N  uint32_t AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
N                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
N
N  uint8_t AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
N                                      If the Alarm Date is selected, this parameter must be set to a value in the 1-31 range.
N                                      If the Alarm WeekDay is selected, this parameter can be a value of @ref RTC_WeekDay_Definitions */
N
N  uint32_t Alarm;                /*!< Specifies the alarm .
N                                      This parameter can be a value of @ref RTC_Alarms_Definitions */
N}RTC_AlarmTypeDef;
N
N/**
N  * @brief  RTC Handle Structure definition
N  */
N#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
Stypedef struct __RTC_HandleTypeDef
N#else
Ntypedef struct
N#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
N{
N  RTC_TypeDef                 *Instance;  /*!< Register base address    */
N
N  RTC_InitTypeDef             Init;       /*!< RTC required parameters  */
N
N  HAL_LockTypeDef             Lock;       /*!< RTC locking object       */
N
N  __IO HAL_RTCStateTypeDef    State;      /*!< Time communication state */
X  volatile HAL_RTCStateTypeDef    State;       
N
N#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
S  void  (* AlarmAEventCallback)      ( struct __RTC_HandleTypeDef * hrtc);  /*!< RTC Alarm A Event callback         */
S
S  void  (* AlarmBEventCallback)      ( struct __RTC_HandleTypeDef * hrtc);  /*!< RTC Alarm B Event callback         */
S
S  void  (* TimeStampEventCallback)   ( struct __RTC_HandleTypeDef * hrtc);  /*!< RTC TimeStamp Event callback       */
S
S  void  (* WakeUpTimerEventCallback) ( struct __RTC_HandleTypeDef * hrtc);  /*!< RTC WakeUpTimer Event callback     */
S
S  void  (* Tamper1EventCallback)     ( struct __RTC_HandleTypeDef * hrtc);  /*!< RTC Tamper 1 Event callback        */
S
S  void  (* Tamper2EventCallback)     ( struct __RTC_HandleTypeDef * hrtc);  /*!< RTC Tamper 2 Event callback        */
S
S  void  (* MspInitCallback)          ( struct __RTC_HandleTypeDef * hrtc);  /*!< RTC Msp Init callback              */
S
S  void  (* MspDeInitCallback)        ( struct __RTC_HandleTypeDef * hrtc);  /*!< RTC Msp DeInit callback            */
S
N#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
N
N}RTC_HandleTypeDef;
N
N#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
S/**
S  * @brief  HAL RTC Callback ID enumeration definition
S  */
Stypedef enum
S{
S  HAL_RTC_ALARM_A_EVENT_CB_ID           = 0x00u,    /*!< RTC Alarm A Event Callback ID       */
S  HAL_RTC_ALARM_B_EVENT_CB_ID           = 0x01u,    /*!< RTC Alarm B Event Callback ID       */
S  HAL_RTC_TIMESTAMP_EVENT_CB_ID         = 0x02u,    /*!< RTC TimeStamp Event Callback ID     */
S  HAL_RTC_WAKEUPTIMER_EVENT_CB_ID       = 0x03u,    /*!< RTC Wake-Up Timer Event Callback ID */
S  HAL_RTC_TAMPER1_EVENT_CB_ID           = 0x04u,    /*!< RTC Tamper 1 Callback ID            */
S  HAL_RTC_TAMPER2_EVENT_CB_ID           = 0x05u,    /*!< RTC Tamper 2 Callback ID            */
S  HAL_RTC_MSPINIT_CB_ID                 = 0x0Eu,    /*!< RTC Msp Init callback ID            */
S  HAL_RTC_MSPDEINIT_CB_ID               = 0x0Fu     /*!< RTC Msp DeInit callback ID          */
S}HAL_RTC_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL RTC Callback pointer definition
S  */
Stypedef  void (*pRTC_CallbackTypeDef)(RTC_HandleTypeDef * hrtc); /*!< pointer to an RTC callback function */
N#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RTC_Exported_Constants RTC Exported Constants
N  * @{
N  */
N
N/** @defgroup RTC_Hour_Formats RTC Hour Formats
N  * @{
N  */
N#define RTC_HOURFORMAT_24              0x00000000U
N#define RTC_HOURFORMAT_12              0x00000040U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Output_selection_Definitions RTC Output Selection Definitions
N  * @{
N  */
N#define RTC_OUTPUT_DISABLE             0x00000000U
N#define RTC_OUTPUT_ALARMA              0x00200000U
N#define RTC_OUTPUT_ALARMB              0x00400000U
N#define RTC_OUTPUT_WAKEUP              0x00600000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Output_Polarity_Definitions RTC Output Polarity Definitions
N  * @{
N  */
N#define RTC_OUTPUT_POLARITY_HIGH       0x00000000U
N#define RTC_OUTPUT_POLARITY_LOW        0x00100000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Output_Type_ALARM_OUT RTC Output Type ALARM OUT
N  * @{
N  */
N#define RTC_OUTPUT_TYPE_OPENDRAIN      0x00000000U
N#define RTC_OUTPUT_TYPE_PUSHPULL       0x00040000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_AM_PM_Definitions RTC AM PM Definitions
N  * @{
N  */
N#define RTC_HOURFORMAT12_AM            ((uint8_t)0x00)
N#define RTC_HOURFORMAT12_PM            ((uint8_t)0x40)
N/**
N  * @}
N  */
N
N/** @defgroup RTC_DayLightSaving_Definitions RTC DayLight Saving Definitions
N  * @{
N  */
N#define RTC_DAYLIGHTSAVING_SUB1H       0x00020000U
N#define RTC_DAYLIGHTSAVING_ADD1H       0x00010000U
N#define RTC_DAYLIGHTSAVING_NONE        0x00000000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_StoreOperation_Definitions RTC Store Operation Definitions
N  * @{
N  */
N#define RTC_STOREOPERATION_RESET        0x00000000U
N#define RTC_STOREOPERATION_SET          0x00040000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Input_parameter_format_definitions RTC Input Parameter Format Definitions
N  * @{
N  */
N#define RTC_FORMAT_BIN                      0x00000000U
N#define RTC_FORMAT_BCD                      0x00000001U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Month_Date_Definitions RTC Month Date Definitions
N  * @{
N  */
N/* Coded in BCD format */
N#define RTC_MONTH_JANUARY              ((uint8_t)0x01)
N#define RTC_MONTH_FEBRUARY             ((uint8_t)0x02)
N#define RTC_MONTH_MARCH                ((uint8_t)0x03)
N#define RTC_MONTH_APRIL                ((uint8_t)0x04)
N#define RTC_MONTH_MAY                  ((uint8_t)0x05)
N#define RTC_MONTH_JUNE                 ((uint8_t)0x06)
N#define RTC_MONTH_JULY                 ((uint8_t)0x07)
N#define RTC_MONTH_AUGUST               ((uint8_t)0x08)
N#define RTC_MONTH_SEPTEMBER            ((uint8_t)0x09)
N#define RTC_MONTH_OCTOBER              ((uint8_t)0x10)
N#define RTC_MONTH_NOVEMBER             ((uint8_t)0x11)
N#define RTC_MONTH_DECEMBER             ((uint8_t)0x12)
N/**
N  * @}
N  */
N
N/** @defgroup RTC_WeekDay_Definitions RTC WeekDay Definitions
N  * @{
N  */
N#define RTC_WEEKDAY_MONDAY             ((uint8_t)0x01)
N#define RTC_WEEKDAY_TUESDAY            ((uint8_t)0x02)
N#define RTC_WEEKDAY_WEDNESDAY          ((uint8_t)0x03)
N#define RTC_WEEKDAY_THURSDAY           ((uint8_t)0x04)
N#define RTC_WEEKDAY_FRIDAY             ((uint8_t)0x05)
N#define RTC_WEEKDAY_SATURDAY           ((uint8_t)0x06)
N#define RTC_WEEKDAY_SUNDAY             ((uint8_t)0x07)
N/**
N  * @}
N  */
N
N/** @defgroup RTC_AlarmDateWeekDay_Definitions RTC Alarm Date WeekDay Definitions
N  * @{
N  */
N#define RTC_ALARMDATEWEEKDAYSEL_DATE      0x00000000U
N#define RTC_ALARMDATEWEEKDAYSEL_WEEKDAY   0x40000000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_AlarmMask_Definitions RTC Alarm Mask Definitions
N  * @{
N  */
N#define RTC_ALARMMASK_NONE                0x00000000U
N#define RTC_ALARMMASK_DATEWEEKDAY         RTC_ALRMAR_MSK4
N#define RTC_ALARMMASK_HOURS               RTC_ALRMAR_MSK3
N#define RTC_ALARMMASK_MINUTES             RTC_ALRMAR_MSK2
N#define RTC_ALARMMASK_SECONDS             RTC_ALRMAR_MSK1
N#define RTC_ALARMMASK_ALL                 0x80808080U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Alarms_Definitions RTC Alarms Definitions
N  * @{
N  */
N#define RTC_ALARM_A                       RTC_CR_ALRAE
N#define RTC_ALARM_B                       RTC_CR_ALRBE
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions RTC Alarm Sub Seconds Masks Definitions
N  * @{
N  */
N#define RTC_ALARMSUBSECONDMASK_ALL         0x00000000U  /*!< All Alarm SS fields are masked.
N                                                                        There is no comparison on sub seconds
N                                                                        for Alarm */
N#define RTC_ALARMSUBSECONDMASK_SS14_1      0x01000000U  /*!< SS[14:1] are don't care in Alarm
N                                                                        comparison. Only SS[0] is compared.    */
N#define RTC_ALARMSUBSECONDMASK_SS14_2      0x02000000U  /*!< SS[14:2] are don't care in Alarm
N                                                                        comparison. Only SS[1:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_3      0x03000000U  /*!< SS[14:3] are don't care in Alarm
N                                                                        comparison. Only SS[2:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_4      0x04000000U  /*!< SS[14:4] are don't care in Alarm
N                                                                        comparison. Only SS[3:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_5      0x05000000U  /*!< SS[14:5] are don't care in Alarm
N                                                                        comparison. Only SS[4:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_6      0x06000000U  /*!< SS[14:6] are don't care in Alarm
N                                                                        comparison. Only SS[5:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_7      0x07000000U  /*!< SS[14:7] are don't care in Alarm
N                                                                        comparison. Only SS[6:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_8      0x08000000U  /*!< SS[14:8] are don't care in Alarm
N                                                                        comparison. Only SS[7:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_9      0x09000000U  /*!< SS[14:9] are don't care in Alarm
N                                                                        comparison. Only SS[8:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_10     0x0A000000U  /*!< SS[14:10] are don't care in Alarm
N                                                                        comparison. Only SS[9:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_11     0x0B000000U  /*!< SS[14:11] are don't care in Alarm
N                                                                        comparison. Only SS[10:0] are compared */
N#define RTC_ALARMSUBSECONDMASK_SS14_12     0x0C000000U  /*!< SS[14:12] are don't care in Alarm
N                                                                        comparison.Only SS[11:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_13     0x0D000000U  /*!< SS[14:13] are don't care in Alarm
N                                                                        comparison. Only SS[12:0] are compared */
N#define RTC_ALARMSUBSECONDMASK_SS14        0x0E000000U  /*!< SS[14] is don't care in Alarm
N                                                                        comparison.Only SS[13:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_NONE        0x0F000000U  /*!< SS[14:0] are compared and must match
N                                                                        to activate alarm. */
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Interrupts_Definitions RTC Interrupts Definitions
N  * @{
N  */
N#define RTC_IT_TS                         0x00008000U
N#define RTC_IT_WUT                        0x00004000U
N#define RTC_IT_ALRB                       0x00002000U
N#define RTC_IT_ALRA                       0x00001000U
N#define RTC_IT_TAMP                       0x00000004U /* Used only to Enable the Tamper Interrupt */
N#define RTC_IT_TAMP1                      0x00020000U
N#define RTC_IT_TAMP2                      0x00040000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Flags_Definitions RTC Flags Definitions
N  * @{
N  */
N#define RTC_FLAG_RECALPF                  0x00010000U
N#define RTC_FLAG_TAMP2F                   0x00004000U
N#define RTC_FLAG_TAMP1F                   0x00002000U
N#define RTC_FLAG_TSOVF                    0x00001000U
N#define RTC_FLAG_TSF                      0x00000800U
N#define RTC_FLAG_WUTF                     0x00000400U
N#define RTC_FLAG_ALRBF                    0x00000200U
N#define RTC_FLAG_ALRAF                    0x00000100U
N#define RTC_FLAG_INITF                    0x00000040U
N#define RTC_FLAG_RSF                      0x00000020U
N#define RTC_FLAG_INITS                    0x00000010U
N#define RTC_FLAG_SHPF                     0x00000008U
N#define RTC_FLAG_WUTWF                    0x00000004U
N#define RTC_FLAG_ALRBWF                   0x00000002U
N#define RTC_FLAG_ALRAWF                   0x00000001U
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RTC_Exported_Macros RTC Exported Macros
N  * @{
N  */
N
N/** @brief Reset RTC handle state
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
S#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) do{\
S                                                      (__HANDLE__)->State = HAL_RTC_STATE_RESET;\
S                                                      (__HANDLE__)->MspInitCallback = NULL;\
S                                                      (__HANDLE__)->MspDeInitCallback = NULL;\
S                                                     }while(0u)
X#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) do{                                                      (__HANDLE__)->State = HAL_RTC_STATE_RESET;                                                      (__HANDLE__)->MspInitCallback = NULL;                                                      (__HANDLE__)->MspDeInitCallback = NULL;                                                     }while(0u)
N#else
N#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_RTC_STATE_RESET)
N#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
N
N/**
N  * @brief  Disable the write protection for RTC registers.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__)             \
N                        do{                                       \
N                            (__HANDLE__)->Instance->WPR = 0xCAU;  \
N                            (__HANDLE__)->Instance->WPR = 0x53U;  \
N                          } while(0U)
X#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__)                                     do{                                                                   (__HANDLE__)->Instance->WPR = 0xCAU;                              (__HANDLE__)->Instance->WPR = 0x53U;                            } while(0U)
N
N/**
N  * @brief  Enable the write protection for RTC registers.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__)              \
N                        do{                                       \
N                            (__HANDLE__)->Instance->WPR = 0xFFU;  \
N                          } while(0U)
X#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__)                                      do{                                                                   (__HANDLE__)->Instance->WPR = 0xFFU;                            } while(0U)
N
N/**
N  * @brief  Enable the RTC ALARMA peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMA_ENABLE(__HANDLE__)                           ((__HANDLE__)->Instance->CR |= (RTC_CR_ALRAE))
N
N/**
N  * @brief  Disable the RTC ALARMA peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMA_DISABLE(__HANDLE__)                          ((__HANDLE__)->Instance->CR &= ~(RTC_CR_ALRAE))
N
N/**
N  * @brief  Enable the RTC ALARMB peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMB_ENABLE(__HANDLE__)                           ((__HANDLE__)->Instance->CR |= (RTC_CR_ALRBE))
N
N/**
N  * @brief  Disable the RTC ALARMB peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMB_DISABLE(__HANDLE__)                          ((__HANDLE__)->Instance->CR &= ~(RTC_CR_ALRBE))
N
N/**
N  * @brief  Enable the RTC Alarm interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to be enabled or disabled.
N  *          This parameter can be any combination of the following values:
N  *             @arg RTC_IT_ALRA: Alarm A interrupt
N  *             @arg RTC_IT_ALRB: Alarm B interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_ENABLE_IT(__HANDLE__, __INTERRUPT__)          ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC Alarm interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to be enabled or disabled.
N  *         This parameter can be any combination of the following values:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  *            @arg RTC_IT_ALRB: Alarm B interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_DISABLE_IT(__HANDLE__, __INTERRUPT__)         ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC Alarm interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  *            @arg RTC_IT_ALRB: Alarm B interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_IT(__HANDLE__, __INTERRUPT__)           (((((__HANDLE__)->Instance->ISR)& ((__INTERRUPT__)>> 4U)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC Alarm's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Alarm Flag to check.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_ALRAF
N  *            @arg RTC_FLAG_ALRBF
N  *            @arg RTC_FLAG_ALRAWF
N  *            @arg RTC_FLAG_ALRBWF
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_FLAG(__HANDLE__, __FLAG__)                (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Alarm's pending flags.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Alarm Flag sources to be enabled or disabled.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_ALRAF
N  *             @arg RTC_FLAG_ALRBF
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_CLEAR_FLAG(__HANDLE__, __FLAG__)                  ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N
N
N/**
N  * @brief  Check whether the specified RTC Alarm interrupt has been enabled or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  *            @arg RTC_IT_ALRB: Alarm B interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Enable interrupt on the RTC Alarm associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_IT()            (EXTI->IMR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC Alarm associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_IT()           (EXTI->IMR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable event on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_EVENT()         (EXTI->EMR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable event on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_EVENT()         (EXTI->EMR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE(); \
N                                                               __HAL_RTC_ALARM_EXTI_ENABLE_FALLING_EDGE();\
N                                                             } while(0U)
X#define __HAL_RTC_ALARM_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();                                                                __HAL_RTC_ALARM_EXTI_ENABLE_FALLING_EDGE();                                                             } while(0U)
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_RTC_ALARM_EXTI_DISABLE_RISING_EDGE();\
N                                                                __HAL_RTC_ALARM_EXTI_DISABLE_FALLING_EDGE();\
N                                                              } while(0U)
X#define __HAL_RTC_ALARM_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_RTC_ALARM_EXTI_DISABLE_RISING_EDGE();                                                                __HAL_RTC_ALARM_EXTI_DISABLE_FALLING_EDGE();                                                              } while(0U)
N
N/**
N  * @brief Check whether the RTC Alarm associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_ALARM_EXTI_GET_FLAG()              (EXTI->PR & RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief Clear the RTC Alarm associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_CLEAR_FLAG()            (EXTI->PR = RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_GENERATE_SWIT()         (EXTI->SWIER |= RTC_EXTI_LINE_ALARM_EVENT)
N/**
N  * @}
N  */
N
N/* Include RTC HAL Extension module */
N#include "stm32f4xx_hal_rtc_ex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rtc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_rtc_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of RTC HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_RTC_EX_H
N#define __STM32F4xx_HAL_RTC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RTCEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup RTCEx_Exported_Types RTCEx Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  RTC Tamper structure definition  
N  */
Ntypedef struct 
N{
N  uint32_t Tamper;                      /*!< Specifies the Tamper Pin.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_Pins_Definitions */
N
N  uint32_t PinSelection;                /*!< Specifies the Tamper Pin.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_Pins_Selection */
N
N  uint32_t Trigger;                     /*!< Specifies the Tamper Trigger.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_Trigger_Definitions */
N
N  uint32_t Filter;                      /*!< Specifies the RTC Filter Tamper.
N                                             This parameter can be a value of @ref RTCEx_Tamper_Filter_Definitions */
N
N  uint32_t SamplingFrequency;           /*!< Specifies the sampling frequency.
N                                             This parameter can be a value of @ref RTCEx_Tamper_Sampling_Frequencies_Definitions */
N
N  uint32_t PrechargeDuration;           /*!< Specifies the Precharge Duration .
N                                             This parameter can be a value of @ref RTCEx_Tamper_Pin_Precharge_Duration_Definitions */ 
N
N  uint32_t TamperPullUp;                /*!< Specifies the Tamper PullUp .
N                                             This parameter can be a value of @ref RTCEx_Tamper_Pull_UP_Definitions */           
N
N  uint32_t TimeStampOnTamperDetection;  /*!< Specifies the TimeStampOnTamperDetection.
N                                             This parameter can be a value of @ref RTCEx_Tamper_TimeStampOnTamperDetection_Definitions */
N}RTC_TamperTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Constants RTCEx Exported Constants
N  * @{
N  */ 
N
N/** @defgroup RTCEx_Backup_Registers_Definitions RTC Backup Registers Definitions
N  * @{
N  */
N#define RTC_BKP_DR0                       0x00000000U
N#define RTC_BKP_DR1                       0x00000001U
N#define RTC_BKP_DR2                       0x00000002U
N#define RTC_BKP_DR3                       0x00000003U
N#define RTC_BKP_DR4                       0x00000004U
N#define RTC_BKP_DR5                       0x00000005U
N#define RTC_BKP_DR6                       0x00000006U
N#define RTC_BKP_DR7                       0x00000007U
N#define RTC_BKP_DR8                       0x00000008U
N#define RTC_BKP_DR9                       0x00000009U
N#define RTC_BKP_DR10                      0x0000000AU
N#define RTC_BKP_DR11                      0x0000000BU
N#define RTC_BKP_DR12                      0x0000000CU
N#define RTC_BKP_DR13                      0x0000000DU
N#define RTC_BKP_DR14                      0x0000000EU
N#define RTC_BKP_DR15                      0x0000000FU
N#define RTC_BKP_DR16                      0x00000010U
N#define RTC_BKP_DR17                      0x00000011U
N#define RTC_BKP_DR18                      0x00000012U
N#define RTC_BKP_DR19                      0x00000013U
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_Time_Stamp_Edges_definitions RTC TimeStamp Edges Definitions
N  * @{
N  */ 
N#define RTC_TIMESTAMPEDGE_RISING          0x00000000U
N#define RTC_TIMESTAMPEDGE_FALLING         0x00000008U
N/**
N  * @}
N  */
N  
N/** @defgroup RTCEx_Tamper_Pins_Definitions RTC Tamper Pins Definitions
N  * @{
N  */
N#define RTC_TAMPER_1                    RTC_TAFCR_TAMP1E
N
N#if !defined(STM32F412Zx) && !defined(STM32F412Vx) && !defined(STM32F412Rx) && !defined(STM32F412Cx) && !defined(STM32F413xx) && !defined(STM32F423xx)
X#if !0L && !0L && !0L && !0L && !0L && !0L
N#define RTC_TAMPER_2                    RTC_TAFCR_TAMP2E
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Pins_Selection RTC tamper Pins Selection
N  * @{
N  */
N
N#define RTC_TAMPERPIN_DEFAULT               0x00000000U
N
N#if !defined(STM32F412Zx) && !defined(STM32F412Vx) && !defined(STM32F412Rx) && !defined(STM32F412Cx) && !defined(STM32F413xx) && !defined(STM32F423xx)
X#if !0L && !0L && !0L && !0L && !0L && !0L
N#define RTC_TAMPERPIN_POS1                  0x00010000U
N#endif
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_TimeStamp_Pin_Selection RTC TimeStamp Pins Selection
N  * @{
N  */ 
N#define RTC_TIMESTAMPPIN_DEFAULT            0x00000000U
N
N#if !defined(STM32F412Zx) && !defined(STM32F412Vx) && !defined(STM32F412Rx) && !defined(STM32F412Cx) && !defined(STM32F413xx) && !defined(STM32F423xx)
X#if !0L && !0L && !0L && !0L && !0L && !0L
N#define RTC_TIMESTAMPPIN_POS1               0x00020000U
N#endif
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_Tamper_Trigger_Definitions RTC Tamper Triggers Definitions
N  * @{
N  */ 
N#define RTC_TAMPERTRIGGER_RISINGEDGE       0x00000000U
N#define RTC_TAMPERTRIGGER_FALLINGEDGE      0x00000002U
N#define RTC_TAMPERTRIGGER_LOWLEVEL         RTC_TAMPERTRIGGER_RISINGEDGE
N#define RTC_TAMPERTRIGGER_HIGHLEVEL        RTC_TAMPERTRIGGER_FALLINGEDGE
N/**
N  * @}
N  */  
N
N/** @defgroup RTCEx_Tamper_Filter_Definitions RTC Tamper Filter Definitions
N  * @{
N  */ 
N#define RTC_TAMPERFILTER_DISABLE   0x00000000U  /*!< Tamper filter is disabled */
N
N#define RTC_TAMPERFILTER_2SAMPLE   0x00000800U  /*!< Tamper is activated after 2 
N                                                                consecutive samples at the active level */
N#define RTC_TAMPERFILTER_4SAMPLE   0x00001000U  /*!< Tamper is activated after 4 
N                                                                consecutive samples at the active level */
N#define RTC_TAMPERFILTER_8SAMPLE   0x00001800U  /*!< Tamper is activated after 8 
N                                                                consecutive samples at the active level. */
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Sampling_Frequencies_Definitions RTC Tamper Sampling Frequencies Definitions
N  * @{
N  */ 
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768  0x00000000U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 32768 */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384  0x00000100U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 16384 */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192   0x00000200U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 8192  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096   0x00000300U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 4096  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048   0x00000400U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 2048  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024   0x00000500U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 1024  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512    0x00000600U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 512   */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256    0x00000700U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 256   */
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Pin_Precharge_Duration_Definitions RTC Tamper Pin Precharge Duration Definitions
N  * @{
N  */ 
N#define RTC_TAMPERPRECHARGEDURATION_1RTCCLK 0x00000000U  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 1 RTCCLK cycle */
N#define RTC_TAMPERPRECHARGEDURATION_2RTCCLK 0x00002000U  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 2 RTCCLK cycles */
N#define RTC_TAMPERPRECHARGEDURATION_4RTCCLK 0x00004000U  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 4 RTCCLK cycles */
N#define RTC_TAMPERPRECHARGEDURATION_8RTCCLK 0x00006000U  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 8 RTCCLK cycles */
N/**
N  * @}
N  */
N  
N/** @defgroup RTCEx_Tamper_TimeStampOnTamperDetection_Definitions RTC Tamper TimeStamp On Tamper Detection Definitions
N  * @{
N  */ 
N#define RTC_TIMESTAMPONTAMPERDETECTION_ENABLE  ((uint32_t)RTC_TAFCR_TAMPTS)  /*!< TimeStamp on Tamper Detection event saved        */
N#define RTC_TIMESTAMPONTAMPERDETECTION_DISABLE 0x00000000U        /*!< TimeStamp on Tamper Detection event is not saved */
N/**
N  * @}
N  */
N  
N/** @defgroup  RTCEx_Tamper_Pull_UP_Definitions RTC Tamper Pull Up Definitions
N  * @{
N  */ 
N#define RTC_TAMPER_PULLUP_ENABLE  0x00000000U            /*!< TimeStamp on Tamper Detection event saved        */
N#define RTC_TAMPER_PULLUP_DISABLE ((uint32_t)RTC_TAFCR_TAMPPUDIS)   /*!< TimeStamp on Tamper Detection event is not saved */
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Wakeup_Timer_Definitions RTC Wake-up Timer Definitions
N  * @{
N  */ 
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV16        0x00000000U
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV8         0x00000001U
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV4         0x00000002U
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV2         0x00000003U
N#define RTC_WAKEUPCLOCK_CK_SPRE_16BITS      0x00000004U
N#define RTC_WAKEUPCLOCK_CK_SPRE_17BITS      0x00000006U
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_Digital_Calibration_Definitions RTC Digital Calib Definitions
N  * @{
N  */ 
N#define RTC_CALIBSIGN_POSITIVE            0x00000000U 
N#define RTC_CALIBSIGN_NEGATIVE            0x00000080U
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Smooth_calib_period_Definitions RTC Smooth Calib Period Definitions
N  * @{
N  */ 
N#define RTC_SMOOTHCALIB_PERIOD_32SEC   0x00000000U  /*!< If RTCCLK = 32768 Hz, Smooth calibration
N                                                                    period is 32s,  else 2exp20 RTCCLK seconds */
N#define RTC_SMOOTHCALIB_PERIOD_16SEC   0x00002000U  /*!< If RTCCLK = 32768 Hz, Smooth calibration 
N                                                                    period is 16s, else 2exp19 RTCCLK seconds */
N#define RTC_SMOOTHCALIB_PERIOD_8SEC    0x00004000U  /*!< If RTCCLK = 32768 Hz, Smooth calibration 
N                                                                    period is 8s, else 2exp18 RTCCLK seconds */
N/**
N  * @}
N  */ 
N
N/** @defgroup RTCEx_Smooth_calib_Plus_pulses_Definitions RTC Smooth Calib Plus Pulses Definitions
N  * @{
N  */ 
N#define RTC_SMOOTHCALIB_PLUSPULSES_SET    0x00008000U  /*!< The number of RTCCLK pulses added  
N                                                                       during a X -second window = Y - CALM[8:0] 
N                                                                       with Y = 512, 256, 128 when X = 32, 16, 8 */
N#define RTC_SMOOTHCALIB_PLUSPULSES_RESET  0x00000000U  /*!< The number of RTCCLK pulses subbstited
N                                                                       during a 32-second window = CALM[8:0] */
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Add_1_Second_Parameter_Definitions RTC Add 1 Second Parameter Definitions
N  * @{
N  */ 
N#define RTC_SHIFTADD1S_RESET      0x00000000U
N#define RTC_SHIFTADD1S_SET        0x80000000U
N/**
N  * @}
N  */ 
N
N
N /** @defgroup RTCEx_Calib_Output_selection_Definitions RTC Calib Output Selection Definitions
N  * @{
N  */ 
N#define RTC_CALIBOUTPUT_512HZ            0x00000000U 
N#define RTC_CALIBOUTPUT_1HZ              0x00080000U
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Macros RTCEx Exported Macros
N  * @{
N  */
N
N/* ---------------------------------WAKEUPTIMER---------------------------------*/
N/** @defgroup RTCEx_WakeUp_Timer RTC WakeUp Timer
N  * @{
N  */
N
N/**
N  * @brief  Enable the RTC WakeUp Timer peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_ENABLE(__HANDLE__)                      ((__HANDLE__)->Instance->CR |= (RTC_CR_WUTE))
N
N/**
N  * @brief  Disable the RTC Wake-up Timer peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_DISABLE(__HANDLE__)                     ((__HANDLE__)->Instance->CR &= ~(RTC_CR_WUTE))
N
N/**
N  * @brief  Enable the RTC WakeUpTimer interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC WakeUpTimer interrupt sources to be enabled or disabled. 
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT: WakeUpTimer A interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_ENABLE_IT(__HANDLE__, __INTERRUPT__)    ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC WakeUpTimer interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC WakeUpTimer interrupt sources to be enabled or disabled. 
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT: WakeUpTimer A interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_DISABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC WakeUpTimer interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC WakeUpTimer interrupt to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT:  WakeUpTimer A interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_IT(__HANDLE__, __INTERRUPT__)            (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4U)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Check whether the specified RTC Wake Up timer interrupt has been enabled or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Wake Up timer interrupt sources to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT:  WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)   (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC WakeUpTimer's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC WakeUpTimer Flag to check.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_WUTF   
N  *             @arg RTC_FLAG_WUTWF     
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_FLAG(__HANDLE__, __FLAG__)          (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Wake Up timer's pending flags.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Tamper Flag sources to be enabled or disabled.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_WUTF   
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(__HANDLE__, __FLAG__)            ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT)) 
N
N/**
N  * @brief  Enable interrupt on the RTC Wake-up Timer associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT()       (EXTI->IMR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC Wake-up Timer associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT()      (EXTI->IMR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable event on the RTC Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_EVENT()    (EXTI->EMR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable event on the RTC Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_EVENT()   (EXTI->EMR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC Wake-up Timer associated Exti line. 
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();\
N                                                                     __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE();\
N                                                                   } while(0U)  
X#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();                                                                     __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE();                                                                   } while(0U)  
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC Wake-up Timer associated Exti line.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE();\
N                                                                      __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE();\
N                                                                    } while(0U)  
X#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE();                                                                      __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE();                                                                    } while(0U)  
N
N/**
N  * @brief Check whether the RTC Wake-up Timer associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG()              (EXTI->PR & RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief Clear the RTC Wake-up Timer associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG()            (EXTI->PR = RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on the RTC Wake-up Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT()         (EXTI->SWIER |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @}
N  */
N
N/* ---------------------------------TIMESTAMP---------------------------------*/
N/** @defgroup RTCEx_Timestamp RTC Timestamp
N  * @{
N  */
N
N/**
N  * @brief  Enable the RTC TimeStamp peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_ENABLE(__HANDLE__)                        ((__HANDLE__)->Instance->CR |= (RTC_CR_TSE))
N
N/**
N  * @brief  Disable the RTC TimeStamp peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_DISABLE(__HANDLE__)                       ((__HANDLE__)->Instance->CR &= ~(RTC_CR_TSE))
N
N/**
N  * @brief  Enable the RTC TimeStamp interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC TimeStamp interrupt sources to be enabled or disabled. 
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_ENABLE_IT(__HANDLE__, __INTERRUPT__)      ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC TimeStamp interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC TimeStamp interrupt sources to be enabled or disabled. 
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_DISABLE_IT(__HANDLE__, __INTERRUPT__)     ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC TimeStamp interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC TimeStamp interrupt to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_IT(__HANDLE__, __INTERRUPT__)         (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4U)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Check whether the specified RTC Time Stamp interrupt has been enabled or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Time Stamp interrupt source to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC TimeStamp's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC TimeStamp flag to check.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_TSF   
N  *            @arg RTC_FLAG_TSOVF     
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_FLAG(__HANDLE__, __FLAG__)            (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Time Stamp's pending flags.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Alarm Flag sources to be enabled or disabled.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TSF  
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_CLEAR_FLAG(__HANDLE__, __FLAG__)          ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N
N/**
N  * @}
N  */
N
N/* ---------------------------------TAMPER------------------------------------*/
N/** @defgroup RTCEx_Tamper RTC Tamper
N  * @{
N  */
N
N/**
N  * @brief  Enable the RTC Tamper1 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER1_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->TAFCR |= (RTC_TAFCR_TAMP1E))
N
N/**
N  * @brief  Disable the RTC Tamper1 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER1_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->TAFCR &= ~(RTC_TAFCR_TAMP1E))
N                                                                      
N#if !defined(STM32F412Zx) && !defined(STM32F412Vx) && !defined(STM32F412Rx) && !defined(STM32F412Cx) && !defined(STM32F413xx) && !defined(STM32F423xx)
X#if !0L && !0L && !0L && !0L && !0L && !0L
N/**
N  * @brief  Enable the RTC Tamper2 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER2_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->TAFCR |= (RTC_TAFCR_TAMP2E))
N
N/**
N  * @brief  Disable the RTC Tamper2 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER2_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->TAFCR &= ~(RTC_TAFCR_TAMP2E))
N#endif
N                                                                      
N/**
N  * @brief  Check whether the specified RTC Tamper interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Tamper interrupt to check.
N  *         This parameter can be:
N  *            @arg  RTC_IT_TAMP1
N  *            @arg  RTC_IT_TAMP2
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_IT(__HANDLE__, __INTERRUPT__)       (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4U)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Check whether the specified RTC Tamper interrupt has been enabled or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Tamper interrupt source to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_TAMP: Tamper interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->TAFCR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC Tamper's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Tamper Flag sources to be enabled or disabled.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TAMP1F 
N  *             @arg RTC_FLAG_TAMP2F  
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_FLAG(__HANDLE__, __FLAG__)               (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Tamper's pending flags.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Tamper Flag to clear.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TAMP1F
N  *             @arg RTC_FLAG_TAMP2F 
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_CLEAR_FLAG(__HANDLE__, __FLAG__)         ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N/**
N  * @}
N  */
N
N/* --------------------------TAMPER/TIMESTAMP---------------------------------*/
N/** @defgroup RTCEx_Tamper_Timestamp EXTI RTC Tamper Timestamp EXTI
N  * @{
N  */
N
N/**
N  * @brief  Enable interrupt on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()        (EXTI->IMR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()       (EXTI->IMR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable event on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_EVENT()    (EXTI->EMR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable event on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_EVENT()   (EXTI->EMR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC Tamper and Timestamp associated Exti line. 
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();\
N                                                                          __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_FALLING_EDGE(); \
N                                                                        } while(0U)  
X#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();                                                                          __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_FALLING_EDGE();                                                                         } while(0U)  
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_EDGE();\
N                                                                           __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_FALLING_EDGE();\
N                                                                         } while(0U)  
X#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_EDGE();                                                                           __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_FALLING_EDGE();                                                                         } while(0U)  
N
N/**
N  * @brief Check whether the RTC Tamper and Timestamp associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()         (EXTI->PR & RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief Clear the RTC Tamper and Timestamp associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()       (EXTI->PR = RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on the RTC Tamper and Timestamp associated Exti line
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()    (EXTI->SWIER |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N/**
N  * @}
N  */
N
N/* ------------------------------Calibration----------------------------------*/
N/** @defgroup RTCEx_Calibration RTC Calibration
N  * @{
N  */
N
N/**
N  * @brief  Enable the Coarse calibration process.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_COARSE_CALIB_ENABLE(__HANDLE__)                       ((__HANDLE__)->Instance->CR |= (RTC_CR_DCE))
N
N/**
N  * @brief  Disable the Coarse calibration process.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_COARSE_CALIB_DISABLE(__HANDLE__)                      ((__HANDLE__)->Instance->CR &= ~(RTC_CR_DCE))
N
N/**
N  * @brief  Enable the RTC calibration output.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(__HANDLE__)                 ((__HANDLE__)->Instance->CR |= (RTC_CR_COE))
N
N/**
N  * @brief  Disable the calibration output.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR &= ~(RTC_CR_COE))
N
N/**
N  * @brief  Enable the clock reference detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CLOCKREF_DETECTION_ENABLE(__HANDLE__)                 ((__HANDLE__)->Instance->CR |= (RTC_CR_REFCKON))
N
N/**
N  * @brief  Disable the clock reference detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CLOCKREF_DETECTION_DISABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR &= ~(RTC_CR_REFCKON))
N
N/**
N  * @brief  Get the selected RTC shift operation's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC shift operation Flag is pending or not.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_SHPF   
N  * @retval None
N  */
N#define __HAL_RTC_SHIFT_GET_FLAG(__HANDLE__, __FLAG__)                (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Functions RTCEx Exported Functions
N  * @{
N  */
N
N/** @addtogroup RTCEx_Exported_Functions_Group1
N  * @{
N  */
N/* RTC TimeStamp and Tamper functions *****************************************/
NHAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin);
NHAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTimeStamp, RTC_DateTypeDef *sTimeStampDate, uint32_t Format);
N
NHAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper);
NHAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper);
Nvoid HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc);
N
Nvoid HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc);
Nvoid HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc);
Nvoid HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N/**
N  * @}
N  */
N
N/** @addtogroup RTCEx_Exported_Functions_Group2
N  * @{
N  */
N/* RTC Wake-up functions ******************************************************/
NHAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock);
NHAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock);
Nuint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc);
Nuint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc);
Nvoid HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc);
Nvoid HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N/**
N  * @}
N  */
N
N/** @addtogroup RTCEx_Exported_Functions_Group3
N  * @{
N  */
N/* Extension Control functions ************************************************/
Nvoid HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data);
Nuint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister);
N
NHAL_StatusTypeDef HAL_RTCEx_SetCoarseCalib(RTC_HandleTypeDef *hrtc, uint32_t CalibSign, uint32_t Value);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateCoarseCalib(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef *hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmouthCalibMinusPulsesValue);
NHAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef *hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS);
NHAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef *hrtc, uint32_t CalibOutput);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/** @addtogroup RTCEx_Exported_Functions_Group4
N  * @{
N  */
N/* Extension RTC features functions *******************************************/
Nvoid HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc); 
NHAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RTCEx_Private_Constants RTCEx Private Constants
N  * @{
N  */
N#define RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT  ((uint32_t)EXTI_IMR_MR21)  /*!< External interrupt line 21 Connected to the RTC Tamper and Time Stamp events */
N#define RTC_EXTI_LINE_WAKEUPTIMER_EVENT       ((uint32_t)EXTI_IMR_MR22)  /*!< External interrupt line 22 Connected to the RTC Wake-up event */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RTCEx_Private_Macros RTCEx Private Macros
N  * @{
N  */
N
N/** @defgroup RTCEx_IS_RTC_Definitions Private macros to check input parameters
N  * @{
N  */ 
N#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0)  || \
N                                           ((BKP) == RTC_BKP_DR1)  || \
N                                           ((BKP) == RTC_BKP_DR2)  || \
N                                           ((BKP) == RTC_BKP_DR3)  || \
N                                           ((BKP) == RTC_BKP_DR4)  || \
N                                           ((BKP) == RTC_BKP_DR5)  || \
N                                           ((BKP) == RTC_BKP_DR6)  || \
N                                           ((BKP) == RTC_BKP_DR7)  || \
N                                           ((BKP) == RTC_BKP_DR8)  || \
N                                           ((BKP) == RTC_BKP_DR9)  || \
N                                           ((BKP) == RTC_BKP_DR10) || \
N                                           ((BKP) == RTC_BKP_DR11) || \
N                                           ((BKP) == RTC_BKP_DR12) || \
N                                           ((BKP) == RTC_BKP_DR13) || \
N                                           ((BKP) == RTC_BKP_DR14) || \
N                                           ((BKP) == RTC_BKP_DR15) || \
N                                           ((BKP) == RTC_BKP_DR16) || \
N                                           ((BKP) == RTC_BKP_DR17) || \
N                                           ((BKP) == RTC_BKP_DR18) || \
N                                           ((BKP) == RTC_BKP_DR19))
X#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0)  ||                                            ((BKP) == RTC_BKP_DR1)  ||                                            ((BKP) == RTC_BKP_DR2)  ||                                            ((BKP) == RTC_BKP_DR3)  ||                                            ((BKP) == RTC_BKP_DR4)  ||                                            ((BKP) == RTC_BKP_DR5)  ||                                            ((BKP) == RTC_BKP_DR6)  ||                                            ((BKP) == RTC_BKP_DR7)  ||                                            ((BKP) == RTC_BKP_DR8)  ||                                            ((BKP) == RTC_BKP_DR9)  ||                                            ((BKP) == RTC_BKP_DR10) ||                                            ((BKP) == RTC_BKP_DR11) ||                                            ((BKP) == RTC_BKP_DR12) ||                                            ((BKP) == RTC_BKP_DR13) ||                                            ((BKP) == RTC_BKP_DR14) ||                                            ((BKP) == RTC_BKP_DR15) ||                                            ((BKP) == RTC_BKP_DR16) ||                                            ((BKP) == RTC_BKP_DR17) ||                                            ((BKP) == RTC_BKP_DR18) ||                                            ((BKP) == RTC_BKP_DR19))
N#define IS_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TIMESTAMPEDGE_RISING) || \
N                                 ((EDGE) == RTC_TIMESTAMPEDGE_FALLING))
X#define IS_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TIMESTAMPEDGE_RISING) ||                                  ((EDGE) == RTC_TIMESTAMPEDGE_FALLING))
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_RTC_TAMPER(TAMPER) ((((TAMPER) & ((uint32_t)!(RTC_TAFCR_TAMP1E ))) == 0x00U) && ((TAMPER) != (uint32_t)RESET))
N#else
N#define IS_RTC_TAMPER(TAMPER) ((((TAMPER) & ((uint32_t)!(RTC_TAFCR_TAMP1E | RTC_TAFCR_TAMP2E))) == 0x00U) && ((TAMPER) != (uint32_t)RESET))
N#endif
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_RTC_TAMPER_PIN(PIN) ((PIN) == RTC_TAMPERPIN_DEFAULT)
N#else
N#define IS_RTC_TAMPER_PIN(PIN) (((PIN) == RTC_TAMPERPIN_DEFAULT) || \
N                                ((PIN) == RTC_TAMPERPIN_POS1))
X#define IS_RTC_TAMPER_PIN(PIN) (((PIN) == RTC_TAMPERPIN_DEFAULT) ||                                 ((PIN) == RTC_TAMPERPIN_POS1))
N#endif 
N
N#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S#define IS_RTC_TIMESTAMP_PIN(PIN) ((PIN) == RTC_TIMESTAMPPIN_DEFAULT)
N#else
N#define IS_RTC_TIMESTAMP_PIN(PIN) (((PIN) == RTC_TIMESTAMPPIN_DEFAULT) || \
N                                   ((PIN) == RTC_TIMESTAMPPIN_POS1))
X#define IS_RTC_TIMESTAMP_PIN(PIN) (((PIN) == RTC_TIMESTAMPPIN_DEFAULT) ||                                    ((PIN) == RTC_TIMESTAMPPIN_POS1))
N#endif
N#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TAMPERTRIGGER_RISINGEDGE) || \
N                                        ((TRIGGER) == RTC_TAMPERTRIGGER_FALLINGEDGE) || \
N                                        ((TRIGGER) == RTC_TAMPERTRIGGER_LOWLEVEL) || \
N                                        ((TRIGGER) == RTC_TAMPERTRIGGER_HIGHLEVEL)) 
X#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TAMPERTRIGGER_RISINGEDGE) ||                                         ((TRIGGER) == RTC_TAMPERTRIGGER_FALLINGEDGE) ||                                         ((TRIGGER) == RTC_TAMPERTRIGGER_LOWLEVEL) ||                                         ((TRIGGER) == RTC_TAMPERTRIGGER_HIGHLEVEL)) 
N#define IS_RTC_TAMPER_FILTER(FILTER)  (((FILTER) == RTC_TAMPERFILTER_DISABLE) || \
N                                       ((FILTER) == RTC_TAMPERFILTER_2SAMPLE) || \
N                                       ((FILTER) == RTC_TAMPERFILTER_4SAMPLE) || \
N                                       ((FILTER) == RTC_TAMPERFILTER_8SAMPLE))
X#define IS_RTC_TAMPER_FILTER(FILTER)  (((FILTER) == RTC_TAMPERFILTER_DISABLE) ||                                        ((FILTER) == RTC_TAMPERFILTER_2SAMPLE) ||                                        ((FILTER) == RTC_TAMPERFILTER_4SAMPLE) ||                                        ((FILTER) == RTC_TAMPERFILTER_8SAMPLE))
N#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768)|| \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384)|| \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192) || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096) || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048) || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024) || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512)  || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256))
X#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768)||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384)||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192) ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096) ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048) ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024) ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512)  ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256))
N#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TAMPERPRECHARGEDURATION_1RTCCLK) || \
N                                                    ((DURATION) == RTC_TAMPERPRECHARGEDURATION_2RTCCLK) || \
N                                                    ((DURATION) == RTC_TAMPERPRECHARGEDURATION_4RTCCLK) || \
N                                                    ((DURATION) == RTC_TAMPERPRECHARGEDURATION_8RTCCLK))
X#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TAMPERPRECHARGEDURATION_1RTCCLK) ||                                                     ((DURATION) == RTC_TAMPERPRECHARGEDURATION_2RTCCLK) ||                                                     ((DURATION) == RTC_TAMPERPRECHARGEDURATION_4RTCCLK) ||                                                     ((DURATION) == RTC_TAMPERPRECHARGEDURATION_8RTCCLK))
N#define IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(DETECTION) (((DETECTION) == RTC_TIMESTAMPONTAMPERDETECTION_ENABLE) || \
N                                                              ((DETECTION) == RTC_TIMESTAMPONTAMPERDETECTION_DISABLE))
X#define IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(DETECTION) (((DETECTION) == RTC_TIMESTAMPONTAMPERDETECTION_ENABLE) ||                                                               ((DETECTION) == RTC_TIMESTAMPONTAMPERDETECTION_DISABLE))
N#define IS_RTC_TAMPER_PULLUP_STATE(STATE) (((STATE) == RTC_TAMPER_PULLUP_ENABLE) || \
N                                           ((STATE) == RTC_TAMPER_PULLUP_DISABLE))
X#define IS_RTC_TAMPER_PULLUP_STATE(STATE) (((STATE) == RTC_TAMPER_PULLUP_ENABLE) ||                                            ((STATE) == RTC_TAMPER_PULLUP_DISABLE))
N#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV16)   || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV8)    || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV4)    || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV2)    || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_16BITS) || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_17BITS))
X#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV16)   ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV8)    ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV4)    ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV2)    ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_16BITS) ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_17BITS))
N
N#define IS_RTC_WAKEUP_COUNTER(COUNTER)  ((COUNTER) <= 0xFFFFU)
N#define IS_RTC_CALIB_SIGN(SIGN) (((SIGN) == RTC_CALIBSIGN_POSITIVE) || \
N                                 ((SIGN) == RTC_CALIBSIGN_NEGATIVE))
X#define IS_RTC_CALIB_SIGN(SIGN) (((SIGN) == RTC_CALIBSIGN_POSITIVE) ||                                  ((SIGN) == RTC_CALIBSIGN_NEGATIVE))
N
N#define IS_RTC_CALIB_VALUE(VALUE) ((VALUE) < 0x20U)
N
N#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SMOOTHCALIB_PERIOD_32SEC) || \
N                                            ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_16SEC) || \
N                                            ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_8SEC)) 
X#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SMOOTHCALIB_PERIOD_32SEC) ||                                             ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_16SEC) ||                                             ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_8SEC)) 
N#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_SET) || \
N                                        ((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_RESET))
X#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_SET) ||                                         ((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_RESET))
N
N#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= 0x000001FFU)
N#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_SHIFTADD1S_RESET) || \
N                                 ((SEL) == RTC_SHIFTADD1S_SET)) 
X#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_SHIFTADD1S_RESET) ||                                  ((SEL) == RTC_SHIFTADD1S_SET)) 
N#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= 0x00007FFFU)
N#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CALIBOUTPUT_512HZ) || \
N                                      ((OUTPUT) == RTC_CALIBOUTPUT_1HZ))
X#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CALIBOUTPUT_512HZ) ||                                       ((OUTPUT) == RTC_CALIBOUTPUT_1HZ))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_RTC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 672 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_rtc.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup RTC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc);
Nvoid       HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc);
Nvoid       HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc);
N
N/* Callbacks Register/UnRegister functions  ***********************************/
N#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
SHAL_StatusTypeDef HAL_RTC_RegisterCallback(RTC_HandleTypeDef *hrtc, HAL_RTC_CallbackIDTypeDef CallbackID, pRTC_CallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_RTC_UnRegisterCallback(RTC_HandleTypeDef *hrtc, HAL_RTC_CallbackIDTypeDef CallbackID);
N#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group2
N  * @{
N  */
N/* RTC Time and Date functions ************************************************/
NHAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format);
N/**
N  * @}
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group3
N  * @{
N  */
N/* RTC Alarm functions ********************************************************/
NHAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm);
NHAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format);
Nvoid                HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef   HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
Nvoid         HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group4
N  * @{
N  */
N/* Peripheral Control functions ***********************************************/
NHAL_StatusTypeDef   HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc);
N/**
N  * @}
N  */
N
N/** @addtogroup RTC_Exported_Functions_Group5
N  * @{
N  */
N/* Peripheral State functions *************************************************/
NHAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RTC_Private_Constants RTC Private Constants
N  * @{
N  */
N/* Masks Definition */
N#define RTC_TR_RESERVED_MASK    0x007F7F7FU
N#define RTC_DR_RESERVED_MASK    0x00FFFF3FU
N#define RTC_INIT_MASK           0xFFFFFFFFU
N#define RTC_RSF_MASK            0xFFFFFF5FU
N#define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
N                                            RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
N                                            RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
N                                            RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F | \
N                                            RTC_FLAG_RECALPF | RTC_FLAG_SHPF))
X#define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF |                                             RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF |                                             RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF |                                             RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F |                                             RTC_FLAG_RECALPF | RTC_FLAG_SHPF))
N
N#define RTC_TIMEOUT_VALUE       1000
N
N#define RTC_EXTI_LINE_ALARM_EVENT             ((uint32_t)EXTI_IMR_MR17)  /*!< External interrupt line 17 Connected to the RTC Alarm event */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RTC_Private_Macros RTC Private Macros
N  * @{
N  */
N
N/** @defgroup RTC_IS_RTC_Definitions RTC Private macros to check input parameters
N  * @{
N  */
N#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HOURFORMAT_12) || \
N                                        ((FORMAT) == RTC_HOURFORMAT_24))
X#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HOURFORMAT_12) ||                                         ((FORMAT) == RTC_HOURFORMAT_24))
N#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_OUTPUT_DISABLE) || \
N                               ((OUTPUT) == RTC_OUTPUT_ALARMA)  || \
N                               ((OUTPUT) == RTC_OUTPUT_ALARMB)  || \
N                               ((OUTPUT) == RTC_OUTPUT_WAKEUP))
X#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_OUTPUT_DISABLE) ||                                ((OUTPUT) == RTC_OUTPUT_ALARMA)  ||                                ((OUTPUT) == RTC_OUTPUT_ALARMB)  ||                                ((OUTPUT) == RTC_OUTPUT_WAKEUP))
N#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OUTPUT_POLARITY_HIGH) || \
N                                ((POL) == RTC_OUTPUT_POLARITY_LOW))
X#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OUTPUT_POLARITY_HIGH) ||                                 ((POL) == RTC_OUTPUT_POLARITY_LOW))
N#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OUTPUT_TYPE_OPENDRAIN) || \
N                                  ((TYPE) == RTC_OUTPUT_TYPE_PUSHPULL))
X#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OUTPUT_TYPE_OPENDRAIN) ||                                   ((TYPE) == RTC_OUTPUT_TYPE_PUSHPULL))
N#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0U) && ((HOUR) <= 12U))
N#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23U)
N#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7FU)
N#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFFU)
N#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59U)
N#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59U)
N
N#define IS_RTC_HOURFORMAT12(PM)  (((PM) == RTC_HOURFORMAT12_AM) || ((PM) == RTC_HOURFORMAT12_PM))
N#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DAYLIGHTSAVING_SUB1H) || \
N                                      ((SAVE) == RTC_DAYLIGHTSAVING_ADD1H) || \
N                                      ((SAVE) == RTC_DAYLIGHTSAVING_NONE))
X#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DAYLIGHTSAVING_SUB1H) ||                                       ((SAVE) == RTC_DAYLIGHTSAVING_ADD1H) ||                                       ((SAVE) == RTC_DAYLIGHTSAVING_NONE))
N#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_STOREOPERATION_RESET) || \
N                                           ((OPERATION) == RTC_STOREOPERATION_SET))
X#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_STOREOPERATION_RESET) ||                                            ((OPERATION) == RTC_STOREOPERATION_SET))
N#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_FORMAT_BIN) || ((FORMAT) == RTC_FORMAT_BCD))
N#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99U)
N#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1U) && ((MONTH) <= 12U))
N#define IS_RTC_DATE(DATE)              (((DATE) >= 1U) && ((DATE) <= 31U))
N#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
X#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    ||                                  ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   ||                                  ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) ||                                  ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  ||                                  ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    ||                                  ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  ||                                  ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
N#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0U) && ((DATE) <= 31U))
N#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
X#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    ||                                                     ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   ||                                                     ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) ||                                                     ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  ||                                                     ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    ||                                                     ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  ||                                                     ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
N#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_ALARMDATEWEEKDAYSEL_DATE) || \
N                                            ((SEL) == RTC_ALARMDATEWEEKDAYSEL_WEEKDAY))
X#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_ALARMDATEWEEKDAYSEL_DATE) ||                                             ((SEL) == RTC_ALARMDATEWEEKDAYSEL_WEEKDAY))
N#define IS_RTC_ALARM_MASK(MASK)  (((MASK) & 0x7F7F7F7FU) == (uint32_t)RESET)
N#define IS_RTC_ALARM(ALARM)      (((ALARM) == RTC_ALARM_A) || ((ALARM) == RTC_ALARM_B))
N#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= 0x00007FFFU)
N
N#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_ALARMSUBSECONDMASK_ALL) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_1) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_2) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_3) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_4) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_5) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_6) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_7) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_8) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_9) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_10) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_11) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_12) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_13) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_NONE))
X#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_ALARMSUBSECONDMASK_ALL) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_1) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_2) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_3) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_4) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_5) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_6) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_7) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_8) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_9) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_10) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_11) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_12) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_13) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_NONE))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup RTC_Private_Functions RTC Private Functions
N  * @{
N  */
NHAL_StatusTypeDef  RTC_EnterInitMode(RTC_HandleTypeDef* hrtc);
Nuint8_t            RTC_ByteToBcd2(uint8_t Value);
Nuint8_t            RTC_Bcd2ToByte(uint8_t Value);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_RTC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 299 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_RTC_MODULE_ENABLED */
N
N#ifdef HAL_SAI_MODULE_ENABLED
S#include "stm32f4xx_hal_sai.h"
N#endif /* HAL_SAI_MODULE_ENABLED */
N
N#ifdef HAL_SD_MODULE_ENABLED
S#include "stm32f4xx_hal_sd.h"
N#endif /* HAL_SD_MODULE_ENABLED */
N
N#ifdef HAL_SMBUS_MODULE_ENABLED
S#include "stm32f4xx_hal_smbus.h"
N#endif /* HAL_SMBUS_MODULE_ENABLED */
N
N#ifdef HAL_SPI_MODULE_ENABLED
N#include "stm32f4xx_hal_spi.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_spi.h
N  * @author  MCD Application Team
N  * @brief   Header file of SPI HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32F4xx_HAL_SPI_H
N#define STM32F4xx_HAL_SPI_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup SPI
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup SPI_Exported_Types SPI Exported Types
N  * @{
N  */
N
N/**
N  * @brief  SPI Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Mode;                /*!< Specifies the SPI operating mode.
N                                     This parameter can be a value of @ref SPI_Mode */
N
N  uint32_t Direction;           /*!< Specifies the SPI bidirectional mode state.
N                                     This parameter can be a value of @ref SPI_Direction */
N
N  uint32_t DataSize;            /*!< Specifies the SPI data size.
N                                     This parameter can be a value of @ref SPI_Data_Size */
N
N  uint32_t CLKPolarity;         /*!< Specifies the serial clock steady state.
N                                     This parameter can be a value of @ref SPI_Clock_Polarity */
N
N  uint32_t CLKPhase;            /*!< Specifies the clock active edge for the bit capture.
N                                     This parameter can be a value of @ref SPI_Clock_Phase */
N
N  uint32_t NSS;                 /*!< Specifies whether the NSS signal is managed by
N                                     hardware (NSS pin) or by software using the SSI bit.
N                                     This parameter can be a value of @ref SPI_Slave_Select_management */
N
N  uint32_t BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
N                                     used to configure the transmit and receive SCK clock.
N                                     This parameter can be a value of @ref SPI_BaudRate_Prescaler
N                                     @note The communication clock is derived from the master
N                                     clock. The slave clock does not need to be set. */
N
N  uint32_t FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                     This parameter can be a value of @ref SPI_MSB_LSB_transmission */
N
N  uint32_t TIMode;              /*!< Specifies if the TI mode is enabled or not.
N                                     This parameter can be a value of @ref SPI_TI_mode */
N
N  uint32_t CRCCalculation;      /*!< Specifies if the CRC calculation is enabled or not.
N                                     This parameter can be a value of @ref SPI_CRC_Calculation */
N
N  uint32_t CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation.
N                                     This parameter must be an odd number between Min_Data = 1 and Max_Data = 65535 */
N} SPI_InitTypeDef;
N
N/**
N  * @brief  HAL SPI State structure definition
N  */
Ntypedef enum
N{
N  HAL_SPI_STATE_RESET      = 0x00U,    /*!< Peripheral not Initialized                         */
N  HAL_SPI_STATE_READY      = 0x01U,    /*!< Peripheral Initialized and ready for use           */
N  HAL_SPI_STATE_BUSY       = 0x02U,    /*!< an internal process is ongoing                     */
N  HAL_SPI_STATE_BUSY_TX    = 0x03U,    /*!< Data Transmission process is ongoing               */
N  HAL_SPI_STATE_BUSY_RX    = 0x04U,    /*!< Data Reception process is ongoing                  */
N  HAL_SPI_STATE_BUSY_TX_RX = 0x05U,    /*!< Data Transmission and Reception process is ongoing */
N  HAL_SPI_STATE_ERROR      = 0x06U,    /*!< SPI error state                                    */
N  HAL_SPI_STATE_ABORT      = 0x07U     /*!< SPI abort is ongoing                               */
N} HAL_SPI_StateTypeDef;
N
N/**
N  * @brief  SPI handle Structure definition
N  */
Ntypedef struct __SPI_HandleTypeDef
N{
N  SPI_TypeDef                *Instance;      /*!< SPI registers base address               */
N
N  SPI_InitTypeDef            Init;           /*!< SPI communication parameters             */
N
N  uint8_t                    *pTxBuffPtr;    /*!< Pointer to SPI Tx transfer Buffer        */
N
N  uint16_t                   TxXferSize;     /*!< SPI Tx Transfer size                     */
N
N  __IO uint16_t              TxXferCount;    /*!< SPI Tx Transfer Counter                  */
X  volatile uint16_t              TxXferCount;     
N
N  uint8_t                    *pRxBuffPtr;    /*!< Pointer to SPI Rx transfer Buffer        */
N
N  uint16_t                   RxXferSize;     /*!< SPI Rx Transfer size                     */
N
N  __IO uint16_t              RxXferCount;    /*!< SPI Rx Transfer Counter                  */
X  volatile uint16_t              RxXferCount;     
N
N  void (*RxISR)(struct __SPI_HandleTypeDef *hspi);   /*!< function pointer on Rx ISR       */
N
N  void (*TxISR)(struct __SPI_HandleTypeDef *hspi);   /*!< function pointer on Tx ISR       */
N
N  DMA_HandleTypeDef          *hdmatx;        /*!< SPI Tx DMA Handle parameters             */
N
N  DMA_HandleTypeDef          *hdmarx;        /*!< SPI Rx DMA Handle parameters             */
N
N  HAL_LockTypeDef            Lock;           /*!< Locking object                           */
N
N  __IO HAL_SPI_StateTypeDef  State;          /*!< SPI communication state                  */
X  volatile HAL_SPI_StateTypeDef  State;           
N
N  __IO uint32_t              ErrorCode;      /*!< SPI Error code                           */
X  volatile uint32_t              ErrorCode;       
N
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
S  void (* TxCpltCallback)(struct __SPI_HandleTypeDef *hspi);             /*!< SPI Tx Completed callback          */
S  void (* RxCpltCallback)(struct __SPI_HandleTypeDef *hspi);             /*!< SPI Rx Completed callback          */
S  void (* TxRxCpltCallback)(struct __SPI_HandleTypeDef *hspi);           /*!< SPI TxRx Completed callback        */
S  void (* TxHalfCpltCallback)(struct __SPI_HandleTypeDef *hspi);         /*!< SPI Tx Half Completed callback     */
S  void (* RxHalfCpltCallback)(struct __SPI_HandleTypeDef *hspi);         /*!< SPI Rx Half Completed callback     */
S  void (* TxRxHalfCpltCallback)(struct __SPI_HandleTypeDef *hspi);       /*!< SPI TxRx Half Completed callback   */
S  void (* ErrorCallback)(struct __SPI_HandleTypeDef *hspi);              /*!< SPI Error callback                 */
S  void (* AbortCpltCallback)(struct __SPI_HandleTypeDef *hspi);          /*!< SPI Abort callback                 */
S  void (* MspInitCallback)(struct __SPI_HandleTypeDef *hspi);            /*!< SPI Msp Init callback              */
S  void (* MspDeInitCallback)(struct __SPI_HandleTypeDef *hspi);          /*!< SPI Msp DeInit callback            */
S
N#endif  /* USE_HAL_SPI_REGISTER_CALLBACKS */
N} SPI_HandleTypeDef;
N
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
S/**
S  * @brief  HAL SPI Callback ID enumeration definition
S  */
Stypedef enum
S{
S  HAL_SPI_TX_COMPLETE_CB_ID             = 0x00U,    /*!< SPI Tx Completed callback ID         */
S  HAL_SPI_RX_COMPLETE_CB_ID             = 0x01U,    /*!< SPI Rx Completed callback ID         */
S  HAL_SPI_TX_RX_COMPLETE_CB_ID          = 0x02U,    /*!< SPI TxRx Completed callback ID       */
S  HAL_SPI_TX_HALF_COMPLETE_CB_ID        = 0x03U,    /*!< SPI Tx Half Completed callback ID    */
S  HAL_SPI_RX_HALF_COMPLETE_CB_ID        = 0x04U,    /*!< SPI Rx Half Completed callback ID    */
S  HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID     = 0x05U,    /*!< SPI TxRx Half Completed callback ID  */
S  HAL_SPI_ERROR_CB_ID                   = 0x06U,    /*!< SPI Error callback ID                */
S  HAL_SPI_ABORT_CB_ID                   = 0x07U,    /*!< SPI Abort callback ID                */
S  HAL_SPI_MSPINIT_CB_ID                 = 0x08U,    /*!< SPI Msp Init callback ID             */
S  HAL_SPI_MSPDEINIT_CB_ID               = 0x09U     /*!< SPI Msp DeInit callback ID           */
S
S} HAL_SPI_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL SPI Callback pointer definition
S  */
Stypedef  void (*pSPI_CallbackTypeDef)(SPI_HandleTypeDef *hspi); /*!< pointer to an SPI callback function */
S
N#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SPI_Exported_Constants SPI Exported Constants
N  * @{
N  */
N
N/** @defgroup SPI_Error_Code SPI Error Code
N  * @{
N  */
N#define HAL_SPI_ERROR_NONE              (0x00000000U)   /*!< No error                               */
N#define HAL_SPI_ERROR_MODF              (0x00000001U)   /*!< MODF error                             */
N#define HAL_SPI_ERROR_CRC               (0x00000002U)   /*!< CRC error                              */
N#define HAL_SPI_ERROR_OVR               (0x00000004U)   /*!< OVR error                              */
N#define HAL_SPI_ERROR_FRE               (0x00000008U)   /*!< FRE error                              */
N#define HAL_SPI_ERROR_DMA               (0x00000010U)   /*!< DMA transfer error                     */
N#define HAL_SPI_ERROR_FLAG              (0x00000020U)   /*!< Error on RXNE/TXE/BSY Flag             */
N#define HAL_SPI_ERROR_ABORT             (0x00000040U)   /*!< Error during SPI Abort procedure       */
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
S#define HAL_SPI_ERROR_INVALID_CALLBACK  (0x00000080U)   /*!< Invalid Callback error                 */
N#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Mode SPI Mode
N  * @{
N  */
N#define SPI_MODE_SLAVE                  (0x00000000U)
N#define SPI_MODE_MASTER                 (SPI_CR1_MSTR | SPI_CR1_SSI)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Direction SPI Direction Mode
N  * @{
N  */
N#define SPI_DIRECTION_2LINES            (0x00000000U)
N#define SPI_DIRECTION_2LINES_RXONLY     SPI_CR1_RXONLY
N#define SPI_DIRECTION_1LINE             SPI_CR1_BIDIMODE
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Data_Size SPI Data Size
N  * @{
N  */
N#define SPI_DATASIZE_8BIT               (0x00000000U)
N#define SPI_DATASIZE_16BIT              SPI_CR1_DFF
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Polarity SPI Clock Polarity
N  * @{
N  */
N#define SPI_POLARITY_LOW                (0x00000000U)
N#define SPI_POLARITY_HIGH               SPI_CR1_CPOL
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Phase SPI Clock Phase
N  * @{
N  */
N#define SPI_PHASE_1EDGE                 (0x00000000U)
N#define SPI_PHASE_2EDGE                 SPI_CR1_CPHA
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Slave_Select_management SPI Slave Select Management
N  * @{
N  */
N#define SPI_NSS_SOFT                    SPI_CR1_SSM
N#define SPI_NSS_HARD_INPUT              (0x00000000U)
N#define SPI_NSS_HARD_OUTPUT             (SPI_CR2_SSOE << 16U)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_BaudRate_Prescaler SPI BaudRate Prescaler
N  * @{
N  */
N#define SPI_BAUDRATEPRESCALER_2         (0x00000000U)
N#define SPI_BAUDRATEPRESCALER_4         (SPI_CR1_BR_0)
N#define SPI_BAUDRATEPRESCALER_8         (SPI_CR1_BR_1)
N#define SPI_BAUDRATEPRESCALER_16        (SPI_CR1_BR_1 | SPI_CR1_BR_0)
N#define SPI_BAUDRATEPRESCALER_32        (SPI_CR1_BR_2)
N#define SPI_BAUDRATEPRESCALER_64        (SPI_CR1_BR_2 | SPI_CR1_BR_0)
N#define SPI_BAUDRATEPRESCALER_128       (SPI_CR1_BR_2 | SPI_CR1_BR_1)
N#define SPI_BAUDRATEPRESCALER_256       (SPI_CR1_BR_2 | SPI_CR1_BR_1 | SPI_CR1_BR_0)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_MSB_LSB_transmission SPI MSB LSB Transmission
N  * @{
N  */
N#define SPI_FIRSTBIT_MSB                (0x00000000U)
N#define SPI_FIRSTBIT_LSB                SPI_CR1_LSBFIRST
N/**
N  * @}
N  */
N
N/** @defgroup SPI_TI_mode SPI TI Mode
N  * @{
N  */
N#define SPI_TIMODE_DISABLE              (0x00000000U)
N#define SPI_TIMODE_ENABLE               SPI_CR2_FRF
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_Calculation SPI CRC Calculation
N  * @{
N  */
N#define SPI_CRCCALCULATION_DISABLE      (0x00000000U)
N#define SPI_CRCCALCULATION_ENABLE       SPI_CR1_CRCEN
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Interrupt_definition SPI Interrupt Definition
N  * @{
N  */
N#define SPI_IT_TXE                      SPI_CR2_TXEIE
N#define SPI_IT_RXNE                     SPI_CR2_RXNEIE
N#define SPI_IT_ERR                      SPI_CR2_ERRIE
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Flags_definition SPI Flags Definition
N  * @{
N  */
N#define SPI_FLAG_RXNE                   SPI_SR_RXNE   /* SPI status flag: Rx buffer not empty flag       */
N#define SPI_FLAG_TXE                    SPI_SR_TXE    /* SPI status flag: Tx buffer empty flag           */
N#define SPI_FLAG_BSY                    SPI_SR_BSY    /* SPI status flag: Busy flag                      */
N#define SPI_FLAG_CRCERR                 SPI_SR_CRCERR /* SPI Error flag: CRC error flag                  */
N#define SPI_FLAG_MODF                   SPI_SR_MODF   /* SPI Error flag: Mode fault flag                 */
N#define SPI_FLAG_OVR                    SPI_SR_OVR    /* SPI Error flag: Overrun flag                    */
N#define SPI_FLAG_FRE                    SPI_SR_FRE    /* SPI Error flag: TI mode frame format error flag */
N#define SPI_FLAG_MASK                   (SPI_SR_RXNE | SPI_SR_TXE | SPI_SR_BSY | SPI_SR_CRCERR | SPI_SR_MODF | SPI_SR_OVR | SPI_SR_FRE)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup SPI_Exported_Macros SPI Exported Macros
N  * @{
N  */
N
N/** @brief  Reset SPI handle state.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
S#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__)                do{                                                  \
S                                                                    (__HANDLE__)->State = HAL_SPI_STATE_RESET;       \
S                                                                    (__HANDLE__)->MspInitCallback = NULL;            \
S                                                                    (__HANDLE__)->MspDeInitCallback = NULL;          \
S                                                                  } while(0)
X#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__)                do{                                                                                                                      (__HANDLE__)->State = HAL_SPI_STATE_RESET;                                                                           (__HANDLE__)->MspInitCallback = NULL;                                                                                (__HANDLE__)->MspDeInitCallback = NULL;                                                                            } while(0)
N#else
N#define __HAL_SPI_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_SPI_STATE_RESET)
N#endif
N
N/** @brief  Enable the specified SPI interrupts.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __INTERRUPT__ specifies the interrupt source to enable.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval None
N  */
N#define __HAL_SPI_ENABLE_IT(__HANDLE__, __INTERRUPT__)   SET_BIT((__HANDLE__)->Instance->CR2, (__INTERRUPT__))
N
N/** @brief  Disable the specified SPI interrupts.
N  * @param  __HANDLE__ specifies the SPI handle.
N  *         This parameter can be SPIx where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __INTERRUPT__ specifies the interrupt source to disable.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval None
N  */
N#define __HAL_SPI_DISABLE_IT(__HANDLE__, __INTERRUPT__)  CLEAR_BIT((__HANDLE__)->Instance->CR2, (__INTERRUPT__))
N
N/** @brief  Check whether the specified SPI interrupt source is enabled or not.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __INTERRUPT__ specifies the SPI interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_SPI_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Check whether the specified SPI flag is set or not.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag
N  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag
N  *            @arg SPI_FLAG_CRCERR: CRC error flag
N  *            @arg SPI_FLAG_MODF: Mode fault flag
N  *            @arg SPI_FLAG_OVR: Overrun flag
N  *            @arg SPI_FLAG_BSY: Busy flag
N  *            @arg SPI_FLAG_FRE: Frame format error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_SPI_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the SPI CRCERR pending flag.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_CRCERRFLAG(__HANDLE__) ((__HANDLE__)->Instance->SR = (uint16_t)(~SPI_FLAG_CRCERR))
N
N/** @brief  Clear the SPI MODF pending flag.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_MODFFLAG(__HANDLE__)             \
N  do{                                                    \
N    __IO uint32_t tmpreg_modf = 0x00U;                   \
N    tmpreg_modf = (__HANDLE__)->Instance->SR;            \
N    CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_SPE); \
N    UNUSED(tmpreg_modf);                                 \
N  } while(0U)
X#define __HAL_SPI_CLEAR_MODFFLAG(__HANDLE__)               do{                                                        __IO uint32_t tmpreg_modf = 0x00U;                       tmpreg_modf = (__HANDLE__)->Instance->SR;                CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_SPE);     UNUSED(tmpreg_modf);                                   } while(0U)
N
N/** @brief  Clear the SPI OVR pending flag.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_OVRFLAG(__HANDLE__)        \
N  do{                                              \
N    __IO uint32_t tmpreg_ovr = 0x00U;              \
N    tmpreg_ovr = (__HANDLE__)->Instance->DR;       \
N    tmpreg_ovr = (__HANDLE__)->Instance->SR;       \
N    UNUSED(tmpreg_ovr);                            \
N  } while(0U)
X#define __HAL_SPI_CLEAR_OVRFLAG(__HANDLE__)          do{                                                  __IO uint32_t tmpreg_ovr = 0x00U;                  tmpreg_ovr = (__HANDLE__)->Instance->DR;           tmpreg_ovr = (__HANDLE__)->Instance->SR;           UNUSED(tmpreg_ovr);                              } while(0U)
N
N/** @brief  Clear the SPI FRE pending flag.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_CLEAR_FREFLAG(__HANDLE__)        \
N  do{                                              \
N  __IO uint32_t tmpreg_fre = 0x00U;                \
N  tmpreg_fre = (__HANDLE__)->Instance->SR;         \
N  UNUSED(tmpreg_fre);                              \
N  }while(0U)
X#define __HAL_SPI_CLEAR_FREFLAG(__HANDLE__)          do{                                                __IO uint32_t tmpreg_fre = 0x00U;                  tmpreg_fre = (__HANDLE__)->Instance->SR;           UNUSED(tmpreg_fre);                                }while(0U)
N
N/** @brief  Enable the SPI peripheral.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_ENABLE(__HANDLE__)  SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_SPE)
N
N/** @brief  Disable the SPI peripheral.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define __HAL_SPI_DISABLE(__HANDLE__) CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_SPE)
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup SPI_Private_Macros SPI Private Macros
N  * @{
N  */
N
N/** @brief  Set the SPI transmit-only mode.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_1LINE_TX(__HANDLE__)  SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_BIDIOE)
N
N/** @brief  Set the SPI receive-only mode.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_1LINE_RX(__HANDLE__)  CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_BIDIOE)
N
N/** @brief  Reset the CRC calculation of the SPI.
N  * @param  __HANDLE__ specifies the SPI Handle.
N  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.
N  * @retval None
N  */
N#define SPI_RESET_CRC(__HANDLE__) do{CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);\
N                                       SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);}while(0U)
X#define SPI_RESET_CRC(__HANDLE__) do{CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);                                       SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);}while(0U)
N
N/** @brief  Check whether the specified SPI flag is set or not.
N  * @param  __SR__  copy of SPI SR regsiter.
N  * @param  __FLAG__ specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag
N  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag
N  *            @arg SPI_FLAG_CRCERR: CRC error flag
N  *            @arg SPI_FLAG_MODF: Mode fault flag
N  *            @arg SPI_FLAG_OVR: Overrun flag
N  *            @arg SPI_FLAG_BSY: Busy flag
N  *            @arg SPI_FLAG_FRE: Frame format error flag
N  * @retval SET or RESET.
N  */
N#define SPI_CHECK_FLAG(__SR__, __FLAG__)         ((((__SR__) & ((__FLAG__) & SPI_FLAG_MASK)) == ((__FLAG__) & SPI_FLAG_MASK)) ? SET : RESET)
N
N/** @brief  Check whether the specified SPI Interrupt is set or not.
N  * @param  __CR2__  copy of SPI CR2 regsiter.
N  * @param  __INTERRUPT__ specifies the SPI interrupt source to check.
N  *         This parameter can be one of the following values:
N  *            @arg SPI_IT_TXE: Tx buffer empty interrupt enable
N  *            @arg SPI_IT_RXNE: RX buffer not empty interrupt enable
N  *            @arg SPI_IT_ERR: Error interrupt enable
N  * @retval SET or RESET.
N  */
N#define SPI_CHECK_IT_SOURCE(__CR2__, __INTERRUPT__)      ((((__CR2__) & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Checks if SPI Mode parameter is in allowed range.
N  * @param  __MODE__ specifies the SPI Mode.
N  *         This parameter can be a value of @ref SPI_Mode
N  * @retval None
N  */
N#define IS_SPI_MODE(__MODE__) (((__MODE__) == SPI_MODE_SLAVE) || \
N                               ((__MODE__) == SPI_MODE_MASTER))
X#define IS_SPI_MODE(__MODE__) (((__MODE__) == SPI_MODE_SLAVE) ||                                ((__MODE__) == SPI_MODE_MASTER))
N
N/** @brief  Checks if SPI Direction Mode parameter is in allowed range.
N  * @param  __MODE__ specifies the SPI Direction Mode.
N  *         This parameter can be a value of @ref SPI_Direction
N  * @retval None
N  */
N#define IS_SPI_DIRECTION(__MODE__) (((__MODE__) == SPI_DIRECTION_2LINES)        || \
N                                    ((__MODE__) == SPI_DIRECTION_2LINES_RXONLY) || \
N                                    ((__MODE__) == SPI_DIRECTION_1LINE))
X#define IS_SPI_DIRECTION(__MODE__) (((__MODE__) == SPI_DIRECTION_2LINES)        ||                                     ((__MODE__) == SPI_DIRECTION_2LINES_RXONLY) ||                                     ((__MODE__) == SPI_DIRECTION_1LINE))
N
N/** @brief  Checks if SPI Direction Mode parameter is 2 lines.
N  * @param  __MODE__ specifies the SPI Direction Mode.
N  * @retval None
N  */
N#define IS_SPI_DIRECTION_2LINES(__MODE__) ((__MODE__) == SPI_DIRECTION_2LINES)
N
N/** @brief  Checks if SPI Direction Mode parameter is 1 or 2 lines.
N  * @param  __MODE__ specifies the SPI Direction Mode.
N  * @retval None
N  */
N#define IS_SPI_DIRECTION_2LINES_OR_1LINE(__MODE__) (((__MODE__) == SPI_DIRECTION_2LINES) || \
N                                                    ((__MODE__) == SPI_DIRECTION_1LINE))
X#define IS_SPI_DIRECTION_2LINES_OR_1LINE(__MODE__) (((__MODE__) == SPI_DIRECTION_2LINES) ||                                                     ((__MODE__) == SPI_DIRECTION_1LINE))
N
N/** @brief  Checks if SPI Data Size parameter is in allowed range.
N  * @param  __DATASIZE__ specifies the SPI Data Size.
N  *         This parameter can be a value of @ref SPI_Data_Size
N  * @retval None
N  */
N#define IS_SPI_DATASIZE(__DATASIZE__) (((__DATASIZE__) == SPI_DATASIZE_16BIT) || \
N                                       ((__DATASIZE__) == SPI_DATASIZE_8BIT))
X#define IS_SPI_DATASIZE(__DATASIZE__) (((__DATASIZE__) == SPI_DATASIZE_16BIT) ||                                        ((__DATASIZE__) == SPI_DATASIZE_8BIT))
N
N/** @brief  Checks if SPI Serial clock steady state parameter is in allowed range.
N  * @param  __CPOL__ specifies the SPI serial clock steady state.
N  *         This parameter can be a value of @ref SPI_Clock_Polarity
N  * @retval None
N  */
N#define IS_SPI_CPOL(__CPOL__) (((__CPOL__) == SPI_POLARITY_LOW) || \
N                               ((__CPOL__) == SPI_POLARITY_HIGH))
X#define IS_SPI_CPOL(__CPOL__) (((__CPOL__) == SPI_POLARITY_LOW) ||                                ((__CPOL__) == SPI_POLARITY_HIGH))
N
N/** @brief  Checks if SPI Clock Phase parameter is in allowed range.
N  * @param  __CPHA__ specifies the SPI Clock Phase.
N  *         This parameter can be a value of @ref SPI_Clock_Phase
N  * @retval None
N  */
N#define IS_SPI_CPHA(__CPHA__) (((__CPHA__) == SPI_PHASE_1EDGE) || \
N                               ((__CPHA__) == SPI_PHASE_2EDGE))
X#define IS_SPI_CPHA(__CPHA__) (((__CPHA__) == SPI_PHASE_1EDGE) ||                                ((__CPHA__) == SPI_PHASE_2EDGE))
N
N/** @brief  Checks if SPI Slave Select parameter is in allowed range.
N  * @param  __NSS__ specifies the SPI Slave Select management parameter.
N  *         This parameter can be a value of @ref SPI_Slave_Select_management
N  * @retval None
N  */
N#define IS_SPI_NSS(__NSS__) (((__NSS__) == SPI_NSS_SOFT)       || \
N                             ((__NSS__) == SPI_NSS_HARD_INPUT) || \
N                             ((__NSS__) == SPI_NSS_HARD_OUTPUT))
X#define IS_SPI_NSS(__NSS__) (((__NSS__) == SPI_NSS_SOFT)       ||                              ((__NSS__) == SPI_NSS_HARD_INPUT) ||                              ((__NSS__) == SPI_NSS_HARD_OUTPUT))
N
N/** @brief  Checks if SPI Baudrate prescaler parameter is in allowed range.
N  * @param  __PRESCALER__ specifies the SPI Baudrate prescaler.
N  *         This parameter can be a value of @ref SPI_BaudRate_Prescaler
N  * @retval None
N  */
N#define IS_SPI_BAUDRATE_PRESCALER(__PRESCALER__) (((__PRESCALER__) == SPI_BAUDRATEPRESCALER_2)   || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_4)   || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_8)   || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_16)  || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_32)  || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_64)  || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_128) || \
N                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_256))
X#define IS_SPI_BAUDRATE_PRESCALER(__PRESCALER__) (((__PRESCALER__) == SPI_BAUDRATEPRESCALER_2)   ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_4)   ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_8)   ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_16)  ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_32)  ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_64)  ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_128) ||                                                   ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_256))
N
N/** @brief  Checks if SPI MSB LSB transmission parameter is in allowed range.
N  * @param  __BIT__ specifies the SPI MSB LSB transmission (whether data transfer starts from MSB or LSB bit).
N  *         This parameter can be a value of @ref SPI_MSB_LSB_transmission
N  * @retval None
N  */
N#define IS_SPI_FIRST_BIT(__BIT__) (((__BIT__) == SPI_FIRSTBIT_MSB) || \
N                                   ((__BIT__) == SPI_FIRSTBIT_LSB))
X#define IS_SPI_FIRST_BIT(__BIT__) (((__BIT__) == SPI_FIRSTBIT_MSB) ||                                    ((__BIT__) == SPI_FIRSTBIT_LSB))
N
N/** @brief  Checks if SPI TI mode parameter is in allowed range.
N  * @param  __MODE__ specifies the SPI TI mode.
N  *         This parameter can be a value of @ref SPI_TI_mode
N  * @retval None
N  */
N#define IS_SPI_TIMODE(__MODE__) (((__MODE__) == SPI_TIMODE_DISABLE) || \
N                                 ((__MODE__) == SPI_TIMODE_ENABLE))
X#define IS_SPI_TIMODE(__MODE__) (((__MODE__) == SPI_TIMODE_DISABLE) ||                                  ((__MODE__) == SPI_TIMODE_ENABLE))
N
N/** @brief  Checks if SPI CRC calculation enabled state is in allowed range.
N  * @param  __CALCULATION__ specifies the SPI CRC calculation enable state.
N  *         This parameter can be a value of @ref SPI_CRC_Calculation
N  * @retval None
N  */
N#define IS_SPI_CRC_CALCULATION(__CALCULATION__) (((__CALCULATION__) == SPI_CRCCALCULATION_DISABLE) || \
N                                                 ((__CALCULATION__) == SPI_CRCCALCULATION_ENABLE))
X#define IS_SPI_CRC_CALCULATION(__CALCULATION__) (((__CALCULATION__) == SPI_CRCCALCULATION_DISABLE) ||                                                  ((__CALCULATION__) == SPI_CRCCALCULATION_ENABLE))
N
N/** @brief  Checks if SPI polynomial value to be used for the CRC calculation, is in allowed range.
N  * @param  __POLYNOMIAL__ specifies the SPI polynomial value to be used for the CRC calculation.
N  *         This parameter must be a number between Min_Data = 0 and Max_Data = 65535
N  * @retval None
N  */
N#define IS_SPI_CRC_POLYNOMIAL(__POLYNOMIAL__) (((__POLYNOMIAL__) >= 0x1U) && ((__POLYNOMIAL__) <= 0xFFFFU) && (((__POLYNOMIAL__)&0x1U) != 0U))
N
N/** @brief  Checks if DMA handle is valid.
N  * @param  __HANDLE__ specifies a DMA Handle.
N  * @retval None
N  */
N#define IS_SPI_DMA_HANDLE(__HANDLE__) ((__HANDLE__) != NULL)
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup SPI_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization/de-initialization functions  ********************************/
NHAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_MspInit(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi);
N
N/* Callbacks Register/UnRegister functions  ***********************************/
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
SHAL_StatusTypeDef HAL_SPI_RegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID, pSPI_CallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_SPI_UnRegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID);
N#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group2
N  * @{
N  */
N/* I/O operation functions  ***************************************************/
NHAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
N                                          uint32_t Timeout);
NHAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
N                                             uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
N                                              uint16_t Size);
NHAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi);
N/* Transfer Abort functions */
NHAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi);
NHAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi);
N
Nvoid HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi);
Nvoid HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi);
N/**
N  * @}
N  */
N
N/** @addtogroup SPI_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State and Error functions ***************************************/
NHAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi);
Nuint32_t             HAL_SPI_GetError(SPI_HandleTypeDef *hspi);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32F4xx_HAL_SPI_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 315 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_SPI_MODULE_ENABLED */
N
N#ifdef HAL_SWPMI_MODULE_ENABLED
S#include "stm32f4xx_hal_swpmi.h"
N#endif /* HAL_SWPMI_MODULE_ENABLED */
N
N#ifdef HAL_TIM_MODULE_ENABLED
N#include "stm32f4xx_hal_tim.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_tim.h
N  * @author  MCD Application Team
N  * @brief   Header file of TIM HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32F4xx_HAL_TIM_H
N#define STM32F4xx_HAL_TIM_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup TIM
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup TIM_Exported_Types TIM Exported Types
N  * @{
N  */
N
N/**
N  * @brief  TIM Time base Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                   This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t CounterMode;       /*!< Specifies the counter mode.
N                                   This parameter can be a value of @ref TIM_Counter_Mode */
N
N  uint32_t Period;            /*!< Specifies the period value to be loaded into the active
N                                   Auto-Reload Register at the next update event.
N                                   This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.  */
N
N  uint32_t ClockDivision;     /*!< Specifies the clock division.
N                                   This parameter can be a value of @ref TIM_ClockDivision */
N
N  uint32_t RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
N                                    reaches zero, an update event is generated and counting restarts
N                                    from the RCR value (N).
N                                    This means in PWM mode that (N+1) corresponds to:
N                                        - the number of PWM periods in edge-aligned mode
N                                        - the number of half PWM period in center-aligned mode
N                                     GP timers: this parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF.
N                                     Advanced timers: this parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF. */
N
N  uint32_t AutoReloadPreload;  /*!< Specifies the auto-reload preload.
N                                   This parameter can be a value of @ref TIM_AutoReloadPreload */
N} TIM_Base_InitTypeDef;
N
N/**
N  * @brief  TIM Output Compare Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t OCMode;        /*!< Specifies the TIM mode.
N                               This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
N
N  uint32_t Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
N                               This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t OCPolarity;    /*!< Specifies the output polarity.
N                               This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
N                               This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                               @note This parameter is valid only for timer instances supporting break feature. */
N
N  uint32_t OCFastMode;    /*!< Specifies the Fast mode state.
N                               This parameter can be a value of @ref TIM_Output_Fast_State
N                               @note This parameter is valid only in PWM1 and PWM2 mode. */
N
N
N  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                               @note This parameter is valid only for timer instances supporting break feature. */
N
N  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                               @note This parameter is valid only for timer instances supporting break feature. */
N} TIM_OC_InitTypeDef;
N
N/**
N  * @brief  TIM One Pulse Mode Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t OCMode;        /*!< Specifies the TIM mode.
N                               This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
N
N  uint32_t Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
N                               This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N
N  uint32_t OCPolarity;    /*!< Specifies the output polarity.
N                               This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
N                               This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                               @note This parameter is valid only for timer instances supporting break feature. */
N
N  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                               @note This parameter is valid only for timer instances supporting break feature. */
N
N  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                               This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                               @note This parameter is valid only for timer instances supporting break feature. */
N
N  uint32_t ICPolarity;    /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t ICSelection;   /*!< Specifies the input.
N                              This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint32_t ICFilter;      /*!< Specifies the input capture filter.
N                              This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N} TIM_OnePulse_InitTypeDef;
N
N/**
N  * @brief  TIM Input Capture Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t  ICPolarity;  /*!< Specifies the active edge of the input signal.
N                              This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t ICSelection;  /*!< Specifies the input.
N                              This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint32_t ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
N                              This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint32_t ICFilter;     /*!< Specifies the input capture filter.
N                              This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N} TIM_IC_InitTypeDef;
N
N/**
N  * @brief  TIM Encoder Configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t EncoderMode;   /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Encoder_Mode */
N
N  uint32_t IC1Polarity;   /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t IC1Selection;  /*!< Specifies the input.
N                               This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint32_t IC1Prescaler;  /*!< Specifies the Input Capture Prescaler.
N                               This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint32_t IC1Filter;     /*!< Specifies the input capture filter.
N                               This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N
N  uint32_t IC2Polarity;   /*!< Specifies the active edge of the input signal.
N                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t IC2Selection;  /*!< Specifies the input.
N                              This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint32_t IC2Prescaler;  /*!< Specifies the Input Capture Prescaler.
N                               This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint32_t IC2Filter;     /*!< Specifies the input capture filter.
N                               This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N} TIM_Encoder_InitTypeDef;
N
N/**
N  * @brief  Clock Configuration Handle Structure definition
N  */
Ntypedef struct
N{
N  uint32_t ClockSource;     /*!< TIM clock sources
N                                 This parameter can be a value of @ref TIM_Clock_Source */
N  uint32_t ClockPolarity;   /*!< TIM clock polarity
N                                 This parameter can be a value of @ref TIM_Clock_Polarity */
N  uint32_t ClockPrescaler;  /*!< TIM clock prescaler
N                                 This parameter can be a value of @ref TIM_Clock_Prescaler */
N  uint32_t ClockFilter;     /*!< TIM clock filter
N                                 This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N} TIM_ClockConfigTypeDef;
N
N/**
N  * @brief  TIM Clear Input Configuration Handle Structure definition
N  */
Ntypedef struct
N{
N  uint32_t ClearInputState;      /*!< TIM clear Input state
N                                      This parameter can be ENABLE or DISABLE */
N  uint32_t ClearInputSource;     /*!< TIM clear Input sources
N                                      This parameter can be a value of @ref TIM_ClearInput_Source */
N  uint32_t ClearInputPolarity;   /*!< TIM Clear Input polarity
N                                      This parameter can be a value of @ref TIM_ClearInput_Polarity */
N  uint32_t ClearInputPrescaler;  /*!< TIM Clear Input prescaler
N                                      This parameter must be 0: When OCRef clear feature is used with ETR source, ETR prescaler must be off */
N  uint32_t ClearInputFilter;     /*!< TIM Clear Input filter
N                                      This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N} TIM_ClearInputConfigTypeDef;
N
N/**
N  * @brief  TIM Master configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t  MasterOutputTrigger;   /*!< Trigger output (TRGO) selection
N                                        This parameter can be a value of @ref TIM_Master_Mode_Selection */
N  uint32_t  MasterSlaveMode;       /*!< Master/slave mode selection
N                                        This parameter can be a value of @ref TIM_Master_Slave_Mode */
N} TIM_MasterConfigTypeDef;
N
N/**
N  * @brief  TIM Slave configuration Structure definition
N  */
Ntypedef struct
N{
N  uint32_t  SlaveMode;         /*!< Slave mode selection
N                                    This parameter can be a value of @ref TIM_Slave_Mode */
N  uint32_t  InputTrigger;      /*!< Input Trigger source
N                                    This parameter can be a value of @ref TIM_Trigger_Selection */
N  uint32_t  TriggerPolarity;   /*!< Input Trigger polarity
N                                    This parameter can be a value of @ref TIM_Trigger_Polarity */
N  uint32_t  TriggerPrescaler;  /*!< Input trigger prescaler
N                                    This parameter can be a value of @ref TIM_Trigger_Prescaler */
N  uint32_t  TriggerFilter;     /*!< Input trigger filter
N                                    This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF  */
N
N} TIM_SlaveConfigTypeDef;
N
N/**
N  * @brief  TIM Break input(s) and Dead time configuration Structure definition
N  * @note   2 break inputs can be configured (BKIN and BKIN2) with configurable
N  *        filter and polarity.
N  */
Ntypedef struct
N{
N  uint32_t OffStateRunMode;      /*!< TIM off state in run mode
N                                      This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */
N  uint32_t OffStateIDLEMode;     /*!< TIM off state in IDLE mode
N                                      This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */
N  uint32_t LockLevel;            /*!< TIM Lock level
N                                      This parameter can be a value of @ref TIM_Lock_level */
N  uint32_t DeadTime;             /*!< TIM dead Time
N                                      This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF */
N  uint32_t BreakState;           /*!< TIM Break State
N                                      This parameter can be a value of @ref TIM_Break_Input_enable_disable */
N  uint32_t BreakPolarity;        /*!< TIM Break input polarity
N                                      This parameter can be a value of @ref TIM_Break_Polarity */
N  uint32_t BreakFilter;          /*!< Specifies the break input filter.
N                                      This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N  uint32_t AutomaticOutput;      /*!< TIM Automatic Output Enable state
N                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
N} TIM_BreakDeadTimeConfigTypeDef;
N
N/**
N  * @brief  HAL State structures definition
N  */
Ntypedef enum
N{
N  HAL_TIM_STATE_RESET             = 0x00U,    /*!< Peripheral not yet initialized or disabled  */
N  HAL_TIM_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use    */
N  HAL_TIM_STATE_BUSY              = 0x02U,    /*!< An internal process is ongoing              */
N  HAL_TIM_STATE_TIMEOUT           = 0x03U,    /*!< Timeout state                               */
N  HAL_TIM_STATE_ERROR             = 0x04U     /*!< Reception process is ongoing                */
N} HAL_TIM_StateTypeDef;
N
N/**
N  * @brief  HAL Active channel structures definition
N  */
Ntypedef enum
N{
N  HAL_TIM_ACTIVE_CHANNEL_1        = 0x01U,    /*!< The active channel is 1     */
N  HAL_TIM_ACTIVE_CHANNEL_2        = 0x02U,    /*!< The active channel is 2     */
N  HAL_TIM_ACTIVE_CHANNEL_3        = 0x04U,    /*!< The active channel is 3     */
N  HAL_TIM_ACTIVE_CHANNEL_4        = 0x08U,    /*!< The active channel is 4     */
N  HAL_TIM_ACTIVE_CHANNEL_CLEARED  = 0x00U     /*!< All active channels cleared */
N} HAL_TIM_ActiveChannel;
N
N/**
N  * @brief  TIM Time Base Handle Structure definition
N  */
N#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
Stypedef struct __TIM_HandleTypeDef
N#else
Ntypedef struct
N#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
N{
N  TIM_TypeDef                 *Instance;     /*!< Register base address             */
N  TIM_Base_InitTypeDef        Init;          /*!< TIM Time Base required parameters */
N  HAL_TIM_ActiveChannel       Channel;       /*!< Active channel                    */
N  DMA_HandleTypeDef           *hdma[7];      /*!< DMA Handlers array
N                                                  This array is accessed by a @ref DMA_Handle_index */
N  HAL_LockTypeDef             Lock;          /*!< Locking object                    */
N  __IO HAL_TIM_StateTypeDef   State;         /*!< TIM operation state               */
X  volatile HAL_TIM_StateTypeDef   State;          
N
N#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
S  void (* Base_MspInitCallback)(struct __TIM_HandleTypeDef *htim);              /*!< TIM Base Msp Init Callback                              */
S  void (* Base_MspDeInitCallback)(struct __TIM_HandleTypeDef *htim);            /*!< TIM Base Msp DeInit Callback                            */
S  void (* IC_MspInitCallback)(struct __TIM_HandleTypeDef *htim);                /*!< TIM IC Msp Init Callback                                */
S  void (* IC_MspDeInitCallback)(struct __TIM_HandleTypeDef *htim);              /*!< TIM IC Msp DeInit Callback                              */
S  void (* OC_MspInitCallback)(struct __TIM_HandleTypeDef *htim);                /*!< TIM OC Msp Init Callback                                */
S  void (* OC_MspDeInitCallback)(struct __TIM_HandleTypeDef *htim);              /*!< TIM OC Msp DeInit Callback                              */
S  void (* PWM_MspInitCallback)(struct __TIM_HandleTypeDef *htim);               /*!< TIM PWM Msp Init Callback                               */
S  void (* PWM_MspDeInitCallback)(struct __TIM_HandleTypeDef *htim);             /*!< TIM PWM Msp DeInit Callback                             */
S  void (* OnePulse_MspInitCallback)(struct __TIM_HandleTypeDef *htim);          /*!< TIM One Pulse Msp Init Callback                         */
S  void (* OnePulse_MspDeInitCallback)(struct __TIM_HandleTypeDef *htim);        /*!< TIM One Pulse Msp DeInit Callback                       */
S  void (* Encoder_MspInitCallback)(struct __TIM_HandleTypeDef *htim);           /*!< TIM Encoder Msp Init Callback                           */
S  void (* Encoder_MspDeInitCallback)(struct __TIM_HandleTypeDef *htim);         /*!< TIM Encoder Msp DeInit Callback                         */
S  void (* HallSensor_MspInitCallback)(struct __TIM_HandleTypeDef *htim);        /*!< TIM Hall Sensor Msp Init Callback                       */
S  void (* HallSensor_MspDeInitCallback)(struct __TIM_HandleTypeDef *htim);      /*!< TIM Hall Sensor Msp DeInit Callback                     */
S  void (* PeriodElapsedCallback)(struct __TIM_HandleTypeDef *htim);             /*!< TIM Period Elapsed Callback                             */
S  void (* PeriodElapsedHalfCpltCallback)(struct __TIM_HandleTypeDef *htim);     /*!< TIM Period Elapsed half complete Callback               */
S  void (* TriggerCallback)(struct __TIM_HandleTypeDef *htim);                   /*!< TIM Trigger Callback                                    */
S  void (* TriggerHalfCpltCallback)(struct __TIM_HandleTypeDef *htim);           /*!< TIM Trigger half complete Callback                      */
S  void (* IC_CaptureCallback)(struct __TIM_HandleTypeDef *htim);                /*!< TIM Input Capture Callback                              */
S  void (* IC_CaptureHalfCpltCallback)(struct __TIM_HandleTypeDef *htim);        /*!< TIM Input Capture half complete Callback                */
S  void (* OC_DelayElapsedCallback)(struct __TIM_HandleTypeDef *htim);           /*!< TIM Output Compare Delay Elapsed Callback               */
S  void (* PWM_PulseFinishedCallback)(struct __TIM_HandleTypeDef *htim);         /*!< TIM PWM Pulse Finished Callback                         */
S  void (* PWM_PulseFinishedHalfCpltCallback)(struct __TIM_HandleTypeDef *htim); /*!< TIM PWM Pulse Finished half complete Callback           */
S  void (* ErrorCallback)(struct __TIM_HandleTypeDef *htim);                     /*!< TIM Error Callback                                      */
S  void (* CommutationCallback)(struct __TIM_HandleTypeDef *htim);               /*!< TIM Commutation Callback                                */
S  void (* CommutationHalfCpltCallback)(struct __TIM_HandleTypeDef *htim);       /*!< TIM Commutation half complete Callback                  */
S  void (* BreakCallback)(struct __TIM_HandleTypeDef *htim);                     /*!< TIM Break Callback                                      */
N#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
N} TIM_HandleTypeDef;
N
N#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
S/**
S  * @brief  HAL TIM Callback ID enumeration definition
S  */
Stypedef enum
S{
S   HAL_TIM_BASE_MSPINIT_CB_ID            = 0x00U    /*!< TIM Base MspInit Callback ID                              */
S  ,HAL_TIM_BASE_MSPDEINIT_CB_ID          = 0x01U    /*!< TIM Base MspDeInit Callback ID                            */
S  ,HAL_TIM_IC_MSPINIT_CB_ID              = 0x02U    /*!< TIM IC MspInit Callback ID                                */
S  ,HAL_TIM_IC_MSPDEINIT_CB_ID            = 0x03U    /*!< TIM IC MspDeInit Callback ID                              */
S  ,HAL_TIM_OC_MSPINIT_CB_ID              = 0x04U    /*!< TIM OC MspInit Callback ID                                */
S  ,HAL_TIM_OC_MSPDEINIT_CB_ID            = 0x05U    /*!< TIM OC MspDeInit Callback ID                              */
S  ,HAL_TIM_PWM_MSPINIT_CB_ID             = 0x06U    /*!< TIM PWM MspInit Callback ID                               */
S  ,HAL_TIM_PWM_MSPDEINIT_CB_ID           = 0x07U    /*!< TIM PWM MspDeInit Callback ID                             */
S  ,HAL_TIM_ONE_PULSE_MSPINIT_CB_ID       = 0x08U    /*!< TIM One Pulse MspInit Callback ID                         */
S  ,HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID     = 0x09U    /*!< TIM One Pulse MspDeInit Callback ID                       */
S  ,HAL_TIM_ENCODER_MSPINIT_CB_ID         = 0x0AU    /*!< TIM Encoder MspInit Callback ID                           */
S  ,HAL_TIM_ENCODER_MSPDEINIT_CB_ID       = 0x0BU    /*!< TIM Encoder MspDeInit Callback ID                         */
S  ,HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID     = 0x0CU    /*!< TIM Hall Sensor MspDeInit Callback ID                     */
S  ,HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID   = 0x0DU    /*!< TIM Hall Sensor MspDeInit Callback ID                     */
S  ,HAL_TIM_PERIOD_ELAPSED_CB_ID          = 0x0EU    /*!< TIM Period Elapsed Callback ID                             */
S  ,HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID     = 0x0FU    /*!< TIM Period Elapsed half complete Callback ID               */
S  ,HAL_TIM_TRIGGER_CB_ID                 = 0x10U    /*!< TIM Trigger Callback ID                                    */
S  ,HAL_TIM_TRIGGER_HALF_CB_ID            = 0x11U    /*!< TIM Trigger half complete Callback ID                      */
S
S  ,HAL_TIM_IC_CAPTURE_CB_ID              = 0x12U    /*!< TIM Input Capture Callback ID                              */
S  ,HAL_TIM_IC_CAPTURE_HALF_CB_ID         = 0x13U    /*!< TIM Input Capture half complete Callback ID                */
S  ,HAL_TIM_OC_DELAY_ELAPSED_CB_ID        = 0x14U    /*!< TIM Output Compare Delay Elapsed Callback ID               */
S  ,HAL_TIM_PWM_PULSE_FINISHED_CB_ID      = 0x15U    /*!< TIM PWM Pulse Finished Callback ID           */
S  ,HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID = 0x16U    /*!< TIM PWM Pulse Finished half complete Callback ID           */
S  ,HAL_TIM_ERROR_CB_ID                   = 0x17U    /*!< TIM Error Callback ID                                      */
S  ,HAL_TIM_COMMUTATION_CB_ID             = 0x18U    /*!< TIM Commutation Callback ID                                */
S  ,HAL_TIM_COMMUTATION_HALF_CB_ID        = 0x19U    /*!< TIM Commutation half complete Callback ID                  */
S  ,HAL_TIM_BREAK_CB_ID                   = 0x1AU    /*!< TIM Break Callback ID                                      */
S} HAL_TIM_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL TIM Callback pointer definition
S  */
Stypedef  void (*pTIM_CallbackTypeDef)(TIM_HandleTypeDef *htim);  /*!< pointer to the TIM callback function */
S
N#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
N
N/**
N  * @}
N  */
N/* End of exported types -----------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup TIM_Exported_Constants TIM Exported Constants
N  * @{
N  */
N
N/** @defgroup TIM_ClearInput_Source TIM Clear Input Source
N  * @{
N  */
N#define TIM_CLEARINPUTSOURCE_NONE           0x00000000U   /*!< OCREF_CLR is disabled */
N#define TIM_CLEARINPUTSOURCE_ETR            0x00000001U   /*!< OCREF_CLR is connected to ETRF input */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_DMA_Base_address TIM DMA Base Address
N  * @{
N  */
N#define TIM_DMABASE_CR1                    0x00000000U
N#define TIM_DMABASE_CR2                    0x00000001U
N#define TIM_DMABASE_SMCR                   0x00000002U
N#define TIM_DMABASE_DIER                   0x00000003U
N#define TIM_DMABASE_SR                     0x00000004U
N#define TIM_DMABASE_EGR                    0x00000005U
N#define TIM_DMABASE_CCMR1                  0x00000006U
N#define TIM_DMABASE_CCMR2                  0x00000007U
N#define TIM_DMABASE_CCER                   0x00000008U
N#define TIM_DMABASE_CNT                    0x00000009U
N#define TIM_DMABASE_PSC                    0x0000000AU
N#define TIM_DMABASE_ARR                    0x0000000BU
N#define TIM_DMABASE_RCR                    0x0000000CU
N#define TIM_DMABASE_CCR1                   0x0000000DU
N#define TIM_DMABASE_CCR2                   0x0000000EU
N#define TIM_DMABASE_CCR3                   0x0000000FU
N#define TIM_DMABASE_CCR4                   0x00000010U
N#define TIM_DMABASE_BDTR                   0x00000011U
N#define TIM_DMABASE_DCR                    0x00000012U
N#define TIM_DMABASE_DMAR                   0x00000013U
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Event_Source TIM Event Source
N  * @{
N  */
N#define TIM_EVENTSOURCE_UPDATE              TIM_EGR_UG     /*!< Reinitialize the counter and generates an update of the registers */
N#define TIM_EVENTSOURCE_CC1                 TIM_EGR_CC1G   /*!< A capture/compare event is generated on channel 1 */
N#define TIM_EVENTSOURCE_CC2                 TIM_EGR_CC2G   /*!< A capture/compare event is generated on channel 2 */
N#define TIM_EVENTSOURCE_CC3                 TIM_EGR_CC3G   /*!< A capture/compare event is generated on channel 3 */
N#define TIM_EVENTSOURCE_CC4                 TIM_EGR_CC4G   /*!< A capture/compare event is generated on channel 4 */
N#define TIM_EVENTSOURCE_COM                 TIM_EGR_COMG   /*!< A commutation event is generated */
N#define TIM_EVENTSOURCE_TRIGGER             TIM_EGR_TG     /*!< A trigger event is generated */
N#define TIM_EVENTSOURCE_BREAK               TIM_EGR_BG     /*!< A break event is generated */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Input_Channel_Polarity TIM Input Channel polarity
N  * @{
N  */
N#define  TIM_INPUTCHANNELPOLARITY_RISING      0x00000000U                       /*!< Polarity for TIx source */
N#define  TIM_INPUTCHANNELPOLARITY_FALLING     TIM_CCER_CC1P                     /*!< Polarity for TIx source */
N#define  TIM_INPUTCHANNELPOLARITY_BOTHEDGE    (TIM_CCER_CC1P | TIM_CCER_CC1NP)  /*!< Polarity for TIx source */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ETR_Polarity TIM ETR Polarity
N  * @{
N  */
N#define TIM_ETRPOLARITY_INVERTED              TIM_SMCR_ETP                      /*!< Polarity for ETR source */
N#define TIM_ETRPOLARITY_NONINVERTED           0x00000000U                       /*!< Polarity for ETR source */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ETR_Prescaler TIM ETR Prescaler
N  * @{
N  */
N#define TIM_ETRPRESCALER_DIV1                 0x00000000U                       /*!< No prescaler is used */
N#define TIM_ETRPRESCALER_DIV2                 TIM_SMCR_ETPS_0                   /*!< ETR input source is divided by 2 */
N#define TIM_ETRPRESCALER_DIV4                 TIM_SMCR_ETPS_1                   /*!< ETR input source is divided by 4 */
N#define TIM_ETRPRESCALER_DIV8                 TIM_SMCR_ETPS                     /*!< ETR input source is divided by 8 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Counter_Mode TIM Counter Mode
N  * @{
N  */
N#define TIM_COUNTERMODE_UP                 0x00000000U                          /*!< Counter used as up-counter   */
N#define TIM_COUNTERMODE_DOWN               TIM_CR1_DIR                          /*!< Counter used as down-counter */
N#define TIM_COUNTERMODE_CENTERALIGNED1     TIM_CR1_CMS_0                        /*!< Center-aligned mode 1        */
N#define TIM_COUNTERMODE_CENTERALIGNED2     TIM_CR1_CMS_1                        /*!< Center-aligned mode 2        */
N#define TIM_COUNTERMODE_CENTERALIGNED3     TIM_CR1_CMS                          /*!< Center-aligned mode 3        */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ClockDivision TIM Clock Division
N  * @{
N  */
N#define TIM_CLOCKDIVISION_DIV1             0x00000000U                          /*!< Clock division: tDTS=tCK_INT   */
N#define TIM_CLOCKDIVISION_DIV2             TIM_CR1_CKD_0                        /*!< Clock division: tDTS=2*tCK_INT */
N#define TIM_CLOCKDIVISION_DIV4             TIM_CR1_CKD_1                        /*!< Clock division: tDTS=4*tCK_INT */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_State TIM Output Compare State
N  * @{
N  */
N#define TIM_OUTPUTSTATE_DISABLE            0x00000000U                          /*!< Capture/Compare 1 output disabled */
N#define TIM_OUTPUTSTATE_ENABLE             TIM_CCER_CC1E                        /*!< Capture/Compare 1 output enabled */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_AutoReloadPreload TIM Auto-Reload Preload
N  * @{
N  */
N#define TIM_AUTORELOAD_PRELOAD_DISABLE                0x00000000U               /*!< TIMx_ARR register is not buffered */
N#define TIM_AUTORELOAD_PRELOAD_ENABLE                 TIM_CR1_ARPE              /*!< TIMx_ARR register is buffered */
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Fast_State TIM Output Fast State
N  * @{
N  */
N#define TIM_OCFAST_DISABLE                 0x00000000U                          /*!< Output Compare fast disable */
N#define TIM_OCFAST_ENABLE                  TIM_CCMR1_OC1FE                      /*!< Output Compare fast enable  */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_State TIM Complementary Output Compare State
N  * @{
N  */
N#define TIM_OUTPUTNSTATE_DISABLE           0x00000000U                          /*!< OCxN is disabled  */
N#define TIM_OUTPUTNSTATE_ENABLE            TIM_CCER_CC1NE                       /*!< OCxN is enabled   */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_Polarity TIM Output Compare Polarity
N  * @{
N  */
N#define TIM_OCPOLARITY_HIGH                0x00000000U                          /*!< Capture/Compare output polarity  */
N#define TIM_OCPOLARITY_LOW                 TIM_CCER_CC1P                        /*!< Capture/Compare output polarity  */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_Polarity TIM Complementary Output Compare Polarity
N  * @{
N  */
N#define TIM_OCNPOLARITY_HIGH               0x00000000U                          /*!< Capture/Compare complementary output polarity */
N#define TIM_OCNPOLARITY_LOW                TIM_CCER_CC1NP                       /*!< Capture/Compare complementary output polarity */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_Idle_State TIM Output Compare Idle State
N  * @{
N  */
N#define TIM_OCIDLESTATE_SET                TIM_CR2_OIS1                         /*!< Output Idle state: OCx=1 when MOE=0 */
N#define TIM_OCIDLESTATE_RESET              0x00000000U                          /*!< Output Idle state: OCx=0 when MOE=0 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_Idle_State TIM Complementary Output Compare Idle State
N  * @{
N  */
N#define TIM_OCNIDLESTATE_SET               TIM_CR2_OIS1N                        /*!< Complementary output Idle state: OCxN=1 when MOE=0 */
N#define TIM_OCNIDLESTATE_RESET             0x00000000U                          /*!< Complementary output Idle state: OCxN=0 when MOE=0 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Input_Capture_Polarity TIM Input Capture Polarity
N  * @{
N  */
N#define  TIM_ICPOLARITY_RISING             TIM_INPUTCHANNELPOLARITY_RISING      /*!< Capture triggered by rising edge on timer input                  */
N#define  TIM_ICPOLARITY_FALLING            TIM_INPUTCHANNELPOLARITY_FALLING     /*!< Capture triggered by falling edge on timer input                 */
N#define  TIM_ICPOLARITY_BOTHEDGE           TIM_INPUTCHANNELPOLARITY_BOTHEDGE    /*!< Capture triggered by both rising and falling edges on timer input*/
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Input_Capture_Selection TIM Input Capture Selection
N  * @{
N  */
N#define TIM_ICSELECTION_DIRECTTI           TIM_CCMR1_CC1S_0                     /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                                     connected to IC1, IC2, IC3 or IC4, respectively */
N#define TIM_ICSELECTION_INDIRECTTI         TIM_CCMR1_CC1S_1                     /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                                     connected to IC2, IC1, IC4 or IC3, respectively */
N#define TIM_ICSELECTION_TRC                TIM_CCMR1_CC1S                       /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Input_Capture_Prescaler TIM Input Capture Prescaler
N  * @{
N  */
N#define TIM_ICPSC_DIV1                     0x00000000U                          /*!< Capture performed each time an edge is detected on the capture input */
N#define TIM_ICPSC_DIV2                     TIM_CCMR1_IC1PSC_0                   /*!< Capture performed once every 2 events                                */
N#define TIM_ICPSC_DIV4                     TIM_CCMR1_IC1PSC_1                   /*!< Capture performed once every 4 events                                */
N#define TIM_ICPSC_DIV8                     TIM_CCMR1_IC1PSC                     /*!< Capture performed once every 8 events                                */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_One_Pulse_Mode TIM One Pulse Mode
N  * @{
N  */
N#define TIM_OPMODE_SINGLE                  TIM_CR1_OPM                          /*!< Counter stops counting at the next update event */
N#define TIM_OPMODE_REPETITIVE              0x00000000U                          /*!< Counter is not stopped at update event          */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Encoder_Mode TIM Encoder Mode
N  * @{
N  */
N#define TIM_ENCODERMODE_TI1                      TIM_SMCR_SMS_0                                                      /*!< Quadrature encoder mode 1, x2 mode, counts up/down on TI1FP1 edge depending on TI2FP2 level  */
N#define TIM_ENCODERMODE_TI2                      TIM_SMCR_SMS_1                                                      /*!< Quadrature encoder mode 2, x2 mode, counts up/down on TI2FP2 edge depending on TI1FP1 level. */
N#define TIM_ENCODERMODE_TI12                     (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)                                   /*!< Quadrature encoder mode 3, x4 mode, counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input. */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Interrupt_definition TIM interrupt Definition
N  * @{
N  */
N#define TIM_IT_UPDATE                      TIM_DIER_UIE                         /*!< Update interrupt            */
N#define TIM_IT_CC1                         TIM_DIER_CC1IE                       /*!< Capture/Compare 1 interrupt */
N#define TIM_IT_CC2                         TIM_DIER_CC2IE                       /*!< Capture/Compare 2 interrupt */
N#define TIM_IT_CC3                         TIM_DIER_CC3IE                       /*!< Capture/Compare 3 interrupt */
N#define TIM_IT_CC4                         TIM_DIER_CC4IE                       /*!< Capture/Compare 4 interrupt */
N#define TIM_IT_COM                         TIM_DIER_COMIE                       /*!< Commutation interrupt       */
N#define TIM_IT_TRIGGER                     TIM_DIER_TIE                         /*!< Trigger interrupt           */
N#define TIM_IT_BREAK                       TIM_DIER_BIE                         /*!< Break interrupt             */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Commutation_Source  TIM Commutation Source
N  * @{
N  */
N#define TIM_COMMUTATION_TRGI              TIM_CR2_CCUS                          /*!< When Capture/compare control bits are preloaded, they are updated by setting the COMG bit or when an rising edge occurs on trigger input */
N#define TIM_COMMUTATION_SOFTWARE          0x00000000U                           /*!< When Capture/compare control bits are preloaded, they are updated by setting the COMG bit */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_DMA_sources TIM DMA Sources
N  * @{
N  */
N#define TIM_DMA_UPDATE                     TIM_DIER_UDE                         /*!< DMA request is triggered by the update event */
N#define TIM_DMA_CC1                        TIM_DIER_CC1DE                       /*!< DMA request is triggered by the capture/compare macth 1 event */
N#define TIM_DMA_CC2                        TIM_DIER_CC2DE                       /*!< DMA request is triggered by the capture/compare macth 2 event event */
N#define TIM_DMA_CC3                        TIM_DIER_CC3DE                       /*!< DMA request is triggered by the capture/compare macth 3 event event */
N#define TIM_DMA_CC4                        TIM_DIER_CC4DE                       /*!< DMA request is triggered by the capture/compare macth 4 event event */
N#define TIM_DMA_COM                        TIM_DIER_COMDE                       /*!< DMA request is triggered by the commutation event */
N#define TIM_DMA_TRIGGER                    TIM_DIER_TDE                         /*!< DMA request is triggered by the trigger event */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Flag_definition TIM Flag Definition
N  * @{
N  */
N#define TIM_FLAG_UPDATE                    TIM_SR_UIF                           /*!< Update interrupt flag         */
N#define TIM_FLAG_CC1                       TIM_SR_CC1IF                         /*!< Capture/Compare 1 interrupt flag */
N#define TIM_FLAG_CC2                       TIM_SR_CC2IF                         /*!< Capture/Compare 2 interrupt flag */
N#define TIM_FLAG_CC3                       TIM_SR_CC3IF                         /*!< Capture/Compare 3 interrupt flag */
N#define TIM_FLAG_CC4                       TIM_SR_CC4IF                         /*!< Capture/Compare 4 interrupt flag */
N#define TIM_FLAG_COM                       TIM_SR_COMIF                         /*!< Commutation interrupt flag    */
N#define TIM_FLAG_TRIGGER                   TIM_SR_TIF                           /*!< Trigger interrupt flag        */
N#define TIM_FLAG_BREAK                     TIM_SR_BIF                           /*!< Break interrupt flag          */
N#define TIM_FLAG_CC1OF                     TIM_SR_CC1OF                         /*!< Capture 1 overcapture flag    */
N#define TIM_FLAG_CC2OF                     TIM_SR_CC2OF                         /*!< Capture 2 overcapture flag    */
N#define TIM_FLAG_CC3OF                     TIM_SR_CC3OF                         /*!< Capture 3 overcapture flag    */
N#define TIM_FLAG_CC4OF                     TIM_SR_CC4OF                         /*!< Capture 4 overcapture flag    */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Channel TIM Channel
N  * @{
N  */
N#define TIM_CHANNEL_1                      0x00000000U                          /*!< Capture/compare channel 1 identifier      */
N#define TIM_CHANNEL_2                      0x00000004U                          /*!< Capture/compare channel 2 identifier      */
N#define TIM_CHANNEL_3                      0x00000008U                          /*!< Capture/compare channel 3 identifier      */
N#define TIM_CHANNEL_4                      0x0000000CU                          /*!< Capture/compare channel 4 identifier      */
N#define TIM_CHANNEL_ALL                    0x0000003CU                          /*!< Global Capture/compare channel identifier  */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Clock_Source TIM Clock Source
N  * @{
N  */
N#define TIM_CLOCKSOURCE_ETRMODE2    TIM_SMCR_ETPS_1      /*!< External clock source mode 2                          */
N#define TIM_CLOCKSOURCE_INTERNAL    TIM_SMCR_ETPS_0      /*!< Internal clock source                                 */
N#define TIM_CLOCKSOURCE_ITR0        TIM_TS_ITR0          /*!< External clock source mode 1 (ITR0)                   */
N#define TIM_CLOCKSOURCE_ITR1        TIM_TS_ITR1          /*!< External clock source mode 1 (ITR1)                   */
N#define TIM_CLOCKSOURCE_ITR2        TIM_TS_ITR2          /*!< External clock source mode 1 (ITR2)                   */
N#define TIM_CLOCKSOURCE_ITR3        TIM_TS_ITR3          /*!< External clock source mode 1 (ITR3)                   */
N#define TIM_CLOCKSOURCE_TI1ED       TIM_TS_TI1F_ED       /*!< External clock source mode 1 (TTI1FP1 + edge detect.) */
N#define TIM_CLOCKSOURCE_TI1         TIM_TS_TI1FP1        /*!< External clock source mode 1 (TTI1FP1)                */
N#define TIM_CLOCKSOURCE_TI2         TIM_TS_TI2FP2        /*!< External clock source mode 1 (TTI2FP2)                */
N#define TIM_CLOCKSOURCE_ETRMODE1    TIM_TS_ETRF          /*!< External clock source mode 1 (ETRF)                   */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Clock_Polarity TIM Clock Polarity
N  * @{
N  */
N#define TIM_CLOCKPOLARITY_INVERTED           TIM_ETRPOLARITY_INVERTED           /*!< Polarity for ETRx clock sources */
N#define TIM_CLOCKPOLARITY_NONINVERTED        TIM_ETRPOLARITY_NONINVERTED        /*!< Polarity for ETRx clock sources */
N#define TIM_CLOCKPOLARITY_RISING             TIM_INPUTCHANNELPOLARITY_RISING    /*!< Polarity for TIx clock sources */
N#define TIM_CLOCKPOLARITY_FALLING            TIM_INPUTCHANNELPOLARITY_FALLING   /*!< Polarity for TIx clock sources */
N#define TIM_CLOCKPOLARITY_BOTHEDGE           TIM_INPUTCHANNELPOLARITY_BOTHEDGE  /*!< Polarity for TIx clock sources */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Clock_Prescaler TIM Clock Prescaler
N  * @{
N  */
N#define TIM_CLOCKPRESCALER_DIV1                 TIM_ETRPRESCALER_DIV1           /*!< No prescaler is used                                                     */
N#define TIM_CLOCKPRESCALER_DIV2                 TIM_ETRPRESCALER_DIV2           /*!< Prescaler for External ETR Clock: Capture performed once every 2 events. */
N#define TIM_CLOCKPRESCALER_DIV4                 TIM_ETRPRESCALER_DIV4           /*!< Prescaler for External ETR Clock: Capture performed once every 4 events. */
N#define TIM_CLOCKPRESCALER_DIV8                 TIM_ETRPRESCALER_DIV8           /*!< Prescaler for External ETR Clock: Capture performed once every 8 events. */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ClearInput_Polarity TIM Clear Input Polarity
N  * @{
N  */
N#define TIM_CLEARINPUTPOLARITY_INVERTED           TIM_ETRPOLARITY_INVERTED      /*!< Polarity for ETRx pin */
N#define TIM_CLEARINPUTPOLARITY_NONINVERTED        TIM_ETRPOLARITY_NONINVERTED   /*!< Polarity for ETRx pin */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_ClearInput_Prescaler TIM Clear Input Prescaler
N  * @{
N  */
N#define TIM_CLEARINPUTPRESCALER_DIV1              TIM_ETRPRESCALER_DIV1         /*!< No prescaler is used                                                   */
N#define TIM_CLEARINPUTPRESCALER_DIV2              TIM_ETRPRESCALER_DIV2         /*!< Prescaler for External ETR pin: Capture performed once every 2 events. */
N#define TIM_CLEARINPUTPRESCALER_DIV4              TIM_ETRPRESCALER_DIV4         /*!< Prescaler for External ETR pin: Capture performed once every 4 events. */
N#define TIM_CLEARINPUTPRESCALER_DIV8              TIM_ETRPRESCALER_DIV8         /*!< Prescaler for External ETR pin: Capture performed once every 8 events. */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state TIM OSSR OffState Selection for Run mode state
N  * @{
N  */
N#define TIM_OSSR_ENABLE                          TIM_BDTR_OSSR                  /*!< When inactive, OC/OCN outputs are enabled (still controlled by the timer)           */
N#define TIM_OSSR_DISABLE                         0x00000000U                    /*!< When inactive, OC/OCN outputs are disabled (not controlled any longer by the timer) */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state TIM OSSI OffState Selection for Idle mode state
N  * @{
N  */
N#define TIM_OSSI_ENABLE                          TIM_BDTR_OSSI                  /*!< When inactive, OC/OCN outputs are enabled (still controlled by the timer)           */
N#define TIM_OSSI_DISABLE                         0x00000000U                    /*!< When inactive, OC/OCN outputs are disabled (not controlled any longer by the timer) */
N/**
N  * @}
N  */
N/** @defgroup TIM_Lock_level  TIM Lock level
N  * @{
N  */
N#define TIM_LOCKLEVEL_OFF                  0x00000000U                          /*!< LOCK OFF     */
N#define TIM_LOCKLEVEL_1                    TIM_BDTR_LOCK_0                      /*!< LOCK Level 1 */
N#define TIM_LOCKLEVEL_2                    TIM_BDTR_LOCK_1                      /*!< LOCK Level 2 */
N#define TIM_LOCKLEVEL_3                    TIM_BDTR_LOCK                        /*!< LOCK Level 3 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Break_Input_enable_disable TIM Break Input Enable
N  * @{
N  */
N#define TIM_BREAK_ENABLE                   TIM_BDTR_BKE                         /*!< Break input BRK is enabled  */
N#define TIM_BREAK_DISABLE                  0x00000000U                          /*!< Break input BRK is disabled */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Break_Polarity TIM Break Input Polarity
N  * @{
N  */
N#define TIM_BREAKPOLARITY_LOW              0x00000000U                          /*!< Break input BRK is active low  */
N#define TIM_BREAKPOLARITY_HIGH             TIM_BDTR_BKP                         /*!< Break input BRK is active high */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_AOE_Bit_Set_Reset TIM Automatic Output Enable
N  * @{
N  */
N#define TIM_AUTOMATICOUTPUT_DISABLE        0x00000000U                          /*!< MOE can be set only by software */
N#define TIM_AUTOMATICOUTPUT_ENABLE         TIM_BDTR_AOE                         /*!< MOE can be set by software or automatically at the next update event 
N                                                                                    (if none of the break inputs BRK and BRK2 is active) */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Master_Mode_Selection TIM Master Mode Selection
N  * @{
N  */
N#define TIM_TRGO_RESET            0x00000000U                                      /*!< TIMx_EGR.UG bit is used as trigger output (TRGO)              */
N#define TIM_TRGO_ENABLE           TIM_CR2_MMS_0                                    /*!< TIMx_CR1.CEN bit is used as trigger output (TRGO)             */
N#define TIM_TRGO_UPDATE           TIM_CR2_MMS_1                                    /*!< Update event is used as trigger output (TRGO)                 */
N#define TIM_TRGO_OC1              (TIM_CR2_MMS_1 | TIM_CR2_MMS_0)                  /*!< Capture or a compare match 1 is used as trigger output (TRGO) */
N#define TIM_TRGO_OC1REF           TIM_CR2_MMS_2                                    /*!< OC1REF signal is used as trigger output (TRGO)                */
N#define TIM_TRGO_OC2REF           (TIM_CR2_MMS_2 | TIM_CR2_MMS_0)                  /*!< OC2REF signal is used as trigger output(TRGO)                 */
N#define TIM_TRGO_OC3REF           (TIM_CR2_MMS_2 | TIM_CR2_MMS_1)                  /*!< OC3REF signal is used as trigger output(TRGO)                 */
N#define TIM_TRGO_OC4REF           (TIM_CR2_MMS_2 | TIM_CR2_MMS_1 | TIM_CR2_MMS_0)  /*!< OC4REF signal is used as trigger output(TRGO)                 */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Master_Slave_Mode TIM Master/Slave Mode
N  * @{
N  */
N#define TIM_MASTERSLAVEMODE_ENABLE         TIM_SMCR_MSM                         /*!< No action */
N#define TIM_MASTERSLAVEMODE_DISABLE        0x00000000U                          /*!< Master/slave mode is selected */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Slave_Mode TIM Slave mode
N  * @{
N  */
N#define TIM_SLAVEMODE_DISABLE                0x00000000U                                        /*!< Slave mode disabled           */
N#define TIM_SLAVEMODE_RESET                  TIM_SMCR_SMS_2                                     /*!< Reset Mode                    */
N#define TIM_SLAVEMODE_GATED                  (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0)                  /*!< Gated Mode                    */
N#define TIM_SLAVEMODE_TRIGGER                (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1)                  /*!< Trigger Mode                  */
N#define TIM_SLAVEMODE_EXTERNAL1              (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0) /*!< External Clock Mode 1         */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_and_PWM_modes TIM Output Compare and PWM Modes
N  * @{
N  */
N#define TIM_OCMODE_TIMING                   0x00000000U                                              /*!< Frozen                                 */
N#define TIM_OCMODE_ACTIVE                   TIM_CCMR1_OC1M_0                                         /*!< Set channel to active level on match   */
N#define TIM_OCMODE_INACTIVE                 TIM_CCMR1_OC1M_1                                         /*!< Set channel to inactive level on match */
N#define TIM_OCMODE_TOGGLE                   (TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)                    /*!< Toggle                                 */
N#define TIM_OCMODE_PWM1                     (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1)                    /*!< PWM mode 1                             */
N#define TIM_OCMODE_PWM2                     (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0) /*!< PWM mode 2                             */
N#define TIM_OCMODE_FORCED_ACTIVE            (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_0)                    /*!< Force active level                     */
N#define TIM_OCMODE_FORCED_INACTIVE          TIM_CCMR1_OC1M_2                                         /*!< Force inactive level                   */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Trigger_Selection TIM Trigger Selection
N  * @{
N  */
N#define TIM_TS_ITR0          0x00000000U                                                       /*!< Internal Trigger 0 (ITR0)              */
N#define TIM_TS_ITR1          TIM_SMCR_TS_0                                                     /*!< Internal Trigger 1 (ITR1)              */
N#define TIM_TS_ITR2          TIM_SMCR_TS_1                                                     /*!< Internal Trigger 2 (ITR2)              */
N#define TIM_TS_ITR3          (TIM_SMCR_TS_0 | TIM_SMCR_TS_1)                                   /*!< Internal Trigger 3 (ITR3)              */
N#define TIM_TS_TI1F_ED       TIM_SMCR_TS_2                                                     /*!< TI1 Edge Detector (TI1F_ED)            */
N#define TIM_TS_TI1FP1        (TIM_SMCR_TS_0 | TIM_SMCR_TS_2)                                   /*!< Filtered Timer Input 1 (TI1FP1)        */
N#define TIM_TS_TI2FP2        (TIM_SMCR_TS_1 | TIM_SMCR_TS_2)                                   /*!< Filtered Timer Input 2 (TI2FP2)        */
N#define TIM_TS_ETRF          (TIM_SMCR_TS_0 | TIM_SMCR_TS_1 | TIM_SMCR_TS_2)                   /*!< Filtered External Trigger input (ETRF) */
N#define TIM_TS_NONE          0x0000FFFFU                                                       /*!< No trigger selected                    */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Trigger_Polarity TIM Trigger Polarity
N  * @{
N  */
N#define TIM_TRIGGERPOLARITY_INVERTED           TIM_ETRPOLARITY_INVERTED               /*!< Polarity for ETRx trigger sources             */
N#define TIM_TRIGGERPOLARITY_NONINVERTED        TIM_ETRPOLARITY_NONINVERTED            /*!< Polarity for ETRx trigger sources             */
N#define TIM_TRIGGERPOLARITY_RISING             TIM_INPUTCHANNELPOLARITY_RISING        /*!< Polarity for TIxFPx or TI1_ED trigger sources */
N#define TIM_TRIGGERPOLARITY_FALLING            TIM_INPUTCHANNELPOLARITY_FALLING       /*!< Polarity for TIxFPx or TI1_ED trigger sources */
N#define TIM_TRIGGERPOLARITY_BOTHEDGE           TIM_INPUTCHANNELPOLARITY_BOTHEDGE      /*!< Polarity for TIxFPx or TI1_ED trigger sources */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Trigger_Prescaler TIM Trigger Prescaler
N  * @{
N  */
N#define TIM_TRIGGERPRESCALER_DIV1             TIM_ETRPRESCALER_DIV1             /*!< No prescaler is used                                                       */
N#define TIM_TRIGGERPRESCALER_DIV2             TIM_ETRPRESCALER_DIV2             /*!< Prescaler for External ETR Trigger: Capture performed once every 2 events. */
N#define TIM_TRIGGERPRESCALER_DIV4             TIM_ETRPRESCALER_DIV4             /*!< Prescaler for External ETR Trigger: Capture performed once every 4 events. */
N#define TIM_TRIGGERPRESCALER_DIV8             TIM_ETRPRESCALER_DIV8             /*!< Prescaler for External ETR Trigger: Capture performed once every 8 events. */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_TI1_Selection TIM TI1 Input Selection
N  * @{
N  */
N#define TIM_TI1SELECTION_CH1               0x00000000U                          /*!< The TIMx_CH1 pin is connected to TI1 input */
N#define TIM_TI1SELECTION_XORCOMBINATION    TIM_CR2_TI1S                         /*!< The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) */
N/**
N  * @}
N  */
N
N/** @defgroup TIM_DMA_Burst_Length TIM DMA Burst Length
N  * @{
N  */
N#define TIM_DMABURSTLENGTH_1TRANSFER       0x00000000U                          /*!< The transfer is done to 1 register starting trom TIMx_CR1 + TIMx_DCR.DBA   */
N#define TIM_DMABURSTLENGTH_2TRANSFERS      0x00000100U                          /*!< The transfer is done to 2 registers starting trom TIMx_CR1 + TIMx_DCR.DBA  */
N#define TIM_DMABURSTLENGTH_3TRANSFERS      0x00000200U                          /*!< The transfer is done to 3 registers starting trom TIMx_CR1 + TIMx_DCR.DBA  */
N#define TIM_DMABURSTLENGTH_4TRANSFERS      0x00000300U                          /*!< The transfer is done to 4 registers starting trom TIMx_CR1 + TIMx_DCR.DBA  */
N#define TIM_DMABURSTLENGTH_5TRANSFERS      0x00000400U                          /*!< The transfer is done to 5 registers starting trom TIMx_CR1 + TIMx_DCR.DBA  */
N#define TIM_DMABURSTLENGTH_6TRANSFERS      0x00000500U                          /*!< The transfer is done to 6 registers starting trom TIMx_CR1 + TIMx_DCR.DBA  */
N#define TIM_DMABURSTLENGTH_7TRANSFERS      0x00000600U                          /*!< The transfer is done to 7 registers starting trom TIMx_CR1 + TIMx_DCR.DBA  */
N#define TIM_DMABURSTLENGTH_8TRANSFERS      0x00000700U                          /*!< The transfer is done to 8 registers starting trom TIMx_CR1 + TIMx_DCR.DBA  */
N#define TIM_DMABURSTLENGTH_9TRANSFERS      0x00000800U                          /*!< The transfer is done to 9 registers starting trom TIMx_CR1 + TIMx_DCR.DBA  */
N#define TIM_DMABURSTLENGTH_10TRANSFERS     0x00000900U                          /*!< The transfer is done to 10 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N#define TIM_DMABURSTLENGTH_11TRANSFERS     0x00000A00U                          /*!< The transfer is done to 11 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N#define TIM_DMABURSTLENGTH_12TRANSFERS     0x00000B00U                          /*!< The transfer is done to 12 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N#define TIM_DMABURSTLENGTH_13TRANSFERS     0x00000C00U                          /*!< The transfer is done to 13 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N#define TIM_DMABURSTLENGTH_14TRANSFERS     0x00000D00U                          /*!< The transfer is done to 14 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N#define TIM_DMABURSTLENGTH_15TRANSFERS     0x00000E00U                          /*!< The transfer is done to 15 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N#define TIM_DMABURSTLENGTH_16TRANSFERS     0x00000F00U                          /*!< The transfer is done to 16 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N#define TIM_DMABURSTLENGTH_17TRANSFERS     0x00001000U                          /*!< The transfer is done to 17 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N#define TIM_DMABURSTLENGTH_18TRANSFERS     0x00001100U                          /*!< The transfer is done to 18 registers starting trom TIMx_CR1 + TIMx_DCR.DBA */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Handle_index TIM DMA Handle Index
N  * @{
N  */
N#define TIM_DMA_ID_UPDATE                ((uint16_t) 0x0000)       /*!< Index of the DMA handle used for Update DMA requests */
N#define TIM_DMA_ID_CC1                   ((uint16_t) 0x0001)       /*!< Index of the DMA handle used for Capture/Compare 1 DMA requests */
N#define TIM_DMA_ID_CC2                   ((uint16_t) 0x0002)       /*!< Index of the DMA handle used for Capture/Compare 2 DMA requests */
N#define TIM_DMA_ID_CC3                   ((uint16_t) 0x0003)       /*!< Index of the DMA handle used for Capture/Compare 3 DMA requests */
N#define TIM_DMA_ID_CC4                   ((uint16_t) 0x0004)       /*!< Index of the DMA handle used for Capture/Compare 4 DMA requests */
N#define TIM_DMA_ID_COMMUTATION           ((uint16_t) 0x0005)       /*!< Index of the DMA handle used for Commutation DMA requests */
N#define TIM_DMA_ID_TRIGGER               ((uint16_t) 0x0006)       /*!< Index of the DMA handle used for Trigger DMA requests */
N/**
N  * @}
N  */
N
N/** @defgroup Channel_CC_State TIM Capture/Compare Channel State
N  * @{
N  */
N#define TIM_CCx_ENABLE                   0x00000001U                            /*!< Input or output channel is enabled */
N#define TIM_CCx_DISABLE                  0x00000000U                            /*!< Input or output channel is disabled */
N#define TIM_CCxN_ENABLE                  0x00000004U                            /*!< Complementary output channel is enabled */
N#define TIM_CCxN_DISABLE                 0x00000000U                            /*!< Complementary output channel is enabled */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* End of exported constants -------------------------------------------------*/
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup TIM_Exported_Macros TIM Exported Macros
N  * @{
N  */
N
N/** @brief  Reset TIM handle state.
N  * @param  __HANDLE__ TIM handle.
N  * @retval None
N  */
N#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
S#define __HAL_TIM_RESET_HANDLE_STATE(__HANDLE__) do {                                                        \
S                                                      (__HANDLE__)->State             = HAL_TIM_STATE_RESET; \
S                                                      (__HANDLE__)->Base_MspInitCallback         = NULL;     \
S                                                      (__HANDLE__)->Base_MspDeInitCallback       = NULL;     \
S                                                      (__HANDLE__)->IC_MspInitCallback           = NULL;     \
S                                                      (__HANDLE__)->IC_MspDeInitCallback         = NULL;     \
S                                                      (__HANDLE__)->OC_MspInitCallback           = NULL;     \
S                                                      (__HANDLE__)->OC_MspDeInitCallback         = NULL;     \
S                                                      (__HANDLE__)->PWM_MspInitCallback          = NULL;     \
S                                                      (__HANDLE__)->PWM_MspDeInitCallback        = NULL;     \
S                                                      (__HANDLE__)->OnePulse_MspInitCallback     = NULL;     \
S                                                      (__HANDLE__)->OnePulse_MspDeInitCallback   = NULL;     \
S                                                      (__HANDLE__)->Encoder_MspInitCallback      = NULL;     \
S                                                      (__HANDLE__)->Encoder_MspDeInitCallback    = NULL;     \
S                                                      (__HANDLE__)->HallSensor_MspInitCallback   = NULL;     \
S                                                      (__HANDLE__)->HallSensor_MspDeInitCallback = NULL;     \
S                                                     } while(0)
X#define __HAL_TIM_RESET_HANDLE_STATE(__HANDLE__) do {                                                                                                              (__HANDLE__)->State             = HAL_TIM_STATE_RESET;                                                       (__HANDLE__)->Base_MspInitCallback         = NULL;                                                           (__HANDLE__)->Base_MspDeInitCallback       = NULL;                                                           (__HANDLE__)->IC_MspInitCallback           = NULL;                                                           (__HANDLE__)->IC_MspDeInitCallback         = NULL;                                                           (__HANDLE__)->OC_MspInitCallback           = NULL;                                                           (__HANDLE__)->OC_MspDeInitCallback         = NULL;                                                           (__HANDLE__)->PWM_MspInitCallback          = NULL;                                                           (__HANDLE__)->PWM_MspDeInitCallback        = NULL;                                                           (__HANDLE__)->OnePulse_MspInitCallback     = NULL;                                                           (__HANDLE__)->OnePulse_MspDeInitCallback   = NULL;                                                           (__HANDLE__)->Encoder_MspInitCallback      = NULL;                                                           (__HANDLE__)->Encoder_MspDeInitCallback    = NULL;                                                           (__HANDLE__)->HallSensor_MspInitCallback   = NULL;                                                           (__HANDLE__)->HallSensor_MspDeInitCallback = NULL;                                                          } while(0)
N#else
N#define __HAL_TIM_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_TIM_STATE_RESET)
N#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
N
N/**
N  * @brief  Enable the TIM peripheral.
N  * @param  __HANDLE__ TIM handle
N  * @retval None
N  */
N#define __HAL_TIM_ENABLE(__HANDLE__)                 ((__HANDLE__)->Instance->CR1|=(TIM_CR1_CEN))
N
N/**
N  * @brief  Enable the TIM main Output.
N  * @param  __HANDLE__ TIM handle
N  * @retval None
N  */
N#define __HAL_TIM_MOE_ENABLE(__HANDLE__)             ((__HANDLE__)->Instance->BDTR|=(TIM_BDTR_MOE))
N
N/**
N  * @brief  Disable the TIM peripheral.
N  * @param  __HANDLE__ TIM handle
N  * @retval None
N  */
N#define __HAL_TIM_DISABLE(__HANDLE__) \
N                        do { \
N                          if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL) \
N                            { \
N                            if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL) \
N                            { \
N                              (__HANDLE__)->Instance->CR1 &= ~(TIM_CR1_CEN); \
N                            } \
N                          } \
N                        } while(0)
X#define __HAL_TIM_DISABLE(__HANDLE__)                         do {                           if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL)                             {                             if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL)                             {                               (__HANDLE__)->Instance->CR1 &= ~(TIM_CR1_CEN);                             }                           }                         } while(0)
N
N/**
N  * @brief  Disable the TIM main Output.
N  * @param  __HANDLE__ TIM handle
N  * @retval None
N  * @note The Main Output Enable of a timer instance is disabled only if all the CCx and CCxN channels have been disabled
N  */
N#define __HAL_TIM_MOE_DISABLE(__HANDLE__) \
N                        do { \
N                          if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL) \
N                          { \
N                            if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL) \
N                            { \
N                              (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE); \
N                            } \
N                            } \
N                        } while(0)
X#define __HAL_TIM_MOE_DISABLE(__HANDLE__)                         do {                           if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL)                           {                             if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL)                             {                               (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE);                             }                             }                         } while(0)
N
N/**
N  * @brief  Disable the TIM main Output.
N  * @param  __HANDLE__ TIM handle
N  * @retval None
N  * @note The Main Output Enable of a timer instance is disabled unconditionally
N  */
N#define __HAL_TIM_MOE_DISABLE_UNCONDITIONALLY(__HANDLE__)  (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE)
N
N/** @brief  Enable the specified TIM interrupt.
N  * @param  __HANDLE__ specifies the TIM Handle.
N  * @param  __INTERRUPT__ specifies the TIM interrupt source to enable.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_IT_UPDATE: Update interrupt
N  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
N  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
N  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
N  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
N  *            @arg TIM_IT_COM:   Commutation interrupt
N  *            @arg TIM_IT_TRIGGER: Trigger interrupt
N  *            @arg TIM_IT_BREAK: Break interrupt
N  * @retval None
N  */
N#define __HAL_TIM_ENABLE_IT(__HANDLE__, __INTERRUPT__)    ((__HANDLE__)->Instance->DIER |= (__INTERRUPT__))
N
N/** @brief  Disable the specified TIM interrupt.
N  * @param  __HANDLE__ specifies the TIM Handle.
N  * @param  __INTERRUPT__ specifies the TIM interrupt source to disable.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_IT_UPDATE: Update interrupt
N  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
N  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
N  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
N  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
N  *            @arg TIM_IT_COM:   Commutation interrupt
N  *            @arg TIM_IT_TRIGGER: Trigger interrupt
N  *            @arg TIM_IT_BREAK: Break interrupt
N  * @retval None
N  */
N#define __HAL_TIM_DISABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->DIER &= ~(__INTERRUPT__))
N
N/** @brief  Enable the specified DMA request.
N  * @param  __HANDLE__ specifies the TIM Handle.
N  * @param  __DMA__ specifies the TIM DMA request to enable.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_DMA_UPDATE: Update DMA request
N  *            @arg TIM_DMA_CC1:   Capture/Compare 1 DMA request
N  *            @arg TIM_DMA_CC2:  Capture/Compare 2 DMA request
N  *            @arg TIM_DMA_CC3:  Capture/Compare 3 DMA request
N  *            @arg TIM_DMA_CC4:  Capture/Compare 4 DMA request
N  *            @arg TIM_DMA_COM:   Commutation DMA request
N  *            @arg TIM_DMA_TRIGGER: Trigger DMA request
N  * @retval None
N  */
N#define __HAL_TIM_ENABLE_DMA(__HANDLE__, __DMA__)         ((__HANDLE__)->Instance->DIER |= (__DMA__))
N
N/** @brief  Disable the specified DMA request.
N  * @param  __HANDLE__ specifies the TIM Handle.
N  * @param  __DMA__ specifies the TIM DMA request to disable.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_DMA_UPDATE: Update DMA request
N  *            @arg TIM_DMA_CC1:   Capture/Compare 1 DMA request
N  *            @arg TIM_DMA_CC2:  Capture/Compare 2 DMA request
N  *            @arg TIM_DMA_CC3:  Capture/Compare 3 DMA request
N  *            @arg TIM_DMA_CC4:  Capture/Compare 4 DMA request
N  *            @arg TIM_DMA_COM:   Commutation DMA request
N  *            @arg TIM_DMA_TRIGGER: Trigger DMA request
N  * @retval None
N  */
N#define __HAL_TIM_DISABLE_DMA(__HANDLE__, __DMA__)        ((__HANDLE__)->Instance->DIER &= ~(__DMA__))
N
N/** @brief  Check whether the specified TIM interrupt flag is set or not.
N  * @param  __HANDLE__ specifies the TIM Handle.
N  * @param  __FLAG__ specifies the TIM interrupt flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg TIM_FLAG_UPDATE: Update interrupt flag
N  *            @arg TIM_FLAG_CC1: Capture/Compare 1 interrupt flag
N  *            @arg TIM_FLAG_CC2: Capture/Compare 2 interrupt flag
N  *            @arg TIM_FLAG_CC3: Capture/Compare 3 interrupt flag
N  *            @arg TIM_FLAG_CC4: Capture/Compare 4 interrupt flag
N  *            @arg TIM_FLAG_COM:  Commutation interrupt flag
N  *            @arg TIM_FLAG_TRIGGER: Trigger interrupt flag
N  *            @arg TIM_FLAG_BREAK: Break interrupt flag
N  *            @arg TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag
N  *            @arg TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag
N  *            @arg TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag
N  *            @arg TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_TIM_GET_FLAG(__HANDLE__, __FLAG__)          (((__HANDLE__)->Instance->SR &(__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the specified TIM interrupt flag.
N  * @param  __HANDLE__ specifies the TIM Handle.
N  * @param  __FLAG__ specifies the TIM interrupt flag to clear.
N  *        This parameter can be one of the following values:
N  *            @arg TIM_FLAG_UPDATE: Update interrupt flag
N  *            @arg TIM_FLAG_CC1: Capture/Compare 1 interrupt flag
N  *            @arg TIM_FLAG_CC2: Capture/Compare 2 interrupt flag
N  *            @arg TIM_FLAG_CC3: Capture/Compare 3 interrupt flag
N  *            @arg TIM_FLAG_CC4: Capture/Compare 4 interrupt flag
N  *            @arg TIM_FLAG_COM:  Commutation interrupt flag
N  *            @arg TIM_FLAG_TRIGGER: Trigger interrupt flag
N  *            @arg TIM_FLAG_BREAK: Break interrupt flag
N  *            @arg TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag
N  *            @arg TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag
N  *            @arg TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag
N  *            @arg TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_TIM_CLEAR_FLAG(__HANDLE__, __FLAG__)        ((__HANDLE__)->Instance->SR = ~(__FLAG__))
N
N/**
N  * @brief  Check whether the specified TIM interrupt source is enabled or not.
N  * @param  __HANDLE__ TIM handle
N  * @param  __INTERRUPT__ specifies the TIM interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_IT_UPDATE: Update interrupt
N  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
N  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
N  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
N  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
N  *            @arg TIM_IT_COM:   Commutation interrupt
N  *            @arg TIM_IT_TRIGGER: Trigger interrupt
N  *            @arg TIM_IT_BREAK: Break interrupt
N  * @retval The state of TIM_IT (SET or RESET).
N  */
N#define __HAL_TIM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__) ((((__HANDLE__)->Instance->DIER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief Clear the TIM interrupt pending bits.
N  * @param  __HANDLE__ TIM handle
N  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_IT_UPDATE: Update interrupt
N  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
N  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
N  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
N  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
N  *            @arg TIM_IT_COM:   Commutation interrupt
N  *            @arg TIM_IT_TRIGGER: Trigger interrupt
N  *            @arg TIM_IT_BREAK: Break interrupt
N  * @retval None
N  */
N#define __HAL_TIM_CLEAR_IT(__HANDLE__, __INTERRUPT__)      ((__HANDLE__)->Instance->SR = ~(__INTERRUPT__))
N
N/**
N  * @brief  Indicates whether or not the TIM Counter is used as downcounter.
N  * @param  __HANDLE__ TIM handle.
N  * @retval False (Counter used as upcounter) or True (Counter used as downcounter)
N  * @note This macro is particularly useful to get the counting mode when the timer operates in Center-aligned mode or Encoder
Nmode.
N  */
N#define __HAL_TIM_IS_TIM_COUNTING_DOWN(__HANDLE__)    (((__HANDLE__)->Instance->CR1 &(TIM_CR1_DIR)) == (TIM_CR1_DIR))
N
N/**
N  * @brief  Set the TIM Prescaler on runtime.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __PRESC__ specifies the Prescaler new value.
N  * @retval None
N  */
N#define __HAL_TIM_SET_PRESCALER(__HANDLE__, __PRESC__)       ((__HANDLE__)->Instance->PSC = (__PRESC__))
N
N/**
N  * @brief  Set the TIM Counter Register value on runtime.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __COUNTER__ specifies the Counter register new value.
N  * @retval None
N  */
N#define __HAL_TIM_SET_COUNTER(__HANDLE__, __COUNTER__)  ((__HANDLE__)->Instance->CNT = (__COUNTER__))
N
N/**
N  * @brief  Get the TIM Counter Register value on runtime.
N  * @param  __HANDLE__ TIM handle.
N  * @retval 16-bit or 32-bit value of the timer counter register (TIMx_CNT)
N  */
N#define __HAL_TIM_GET_COUNTER(__HANDLE__) \
N   ((__HANDLE__)->Instance->CNT)
X#define __HAL_TIM_GET_COUNTER(__HANDLE__)    ((__HANDLE__)->Instance->CNT)
N
N/**
N  * @brief  Set the TIM Autoreload Register value on runtime without calling another time any Init function.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __AUTORELOAD__ specifies the Counter register new value.
N  * @retval None
N  */
N#define __HAL_TIM_SET_AUTORELOAD(__HANDLE__, __AUTORELOAD__) \
N                        do{                                                    \
N                              (__HANDLE__)->Instance->ARR = (__AUTORELOAD__);  \
N                              (__HANDLE__)->Init.Period = (__AUTORELOAD__);    \
N                          } while(0)
X#define __HAL_TIM_SET_AUTORELOAD(__HANDLE__, __AUTORELOAD__)                         do{                                                                                  (__HANDLE__)->Instance->ARR = (__AUTORELOAD__);                                (__HANDLE__)->Init.Period = (__AUTORELOAD__);                              } while(0)
N
N/**
N  * @brief  Get the TIM Autoreload Register value on runtime.
N  * @param  __HANDLE__ TIM handle.
N  * @retval 16-bit or 32-bit value of the timer auto-reload register(TIMx_ARR)
N  */
N#define __HAL_TIM_GET_AUTORELOAD(__HANDLE__) \
N   ((__HANDLE__)->Instance->ARR)
X#define __HAL_TIM_GET_AUTORELOAD(__HANDLE__)    ((__HANDLE__)->Instance->ARR)
N
N/**
N  * @brief  Set the TIM Clock Division value on runtime without calling another time any Init function.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __CKD__ specifies the clock division value.
N  *          This parameter can be one of the following value:
N  *            @arg TIM_CLOCKDIVISION_DIV1: tDTS=tCK_INT
N  *            @arg TIM_CLOCKDIVISION_DIV2: tDTS=2*tCK_INT
N  *            @arg TIM_CLOCKDIVISION_DIV4: tDTS=4*tCK_INT
N  * @retval None
N  */
N#define __HAL_TIM_SET_CLOCKDIVISION(__HANDLE__, __CKD__) \
N                        do{                                                   \
N                              (__HANDLE__)->Instance->CR1 &= (~TIM_CR1_CKD);  \
N                              (__HANDLE__)->Instance->CR1 |= (__CKD__);       \
N                              (__HANDLE__)->Init.ClockDivision = (__CKD__);   \
N                          } while(0)
X#define __HAL_TIM_SET_CLOCKDIVISION(__HANDLE__, __CKD__)                         do{                                                                                 (__HANDLE__)->Instance->CR1 &= (~TIM_CR1_CKD);                                (__HANDLE__)->Instance->CR1 |= (__CKD__);                                     (__HANDLE__)->Init.ClockDivision = (__CKD__);                             } while(0)
N
N/**
N  * @brief  Get the TIM Clock Division value on runtime.
N  * @param  __HANDLE__ TIM handle.
N  * @retval The clock division can be one of the following values:
N  *            @arg TIM_CLOCKDIVISION_DIV1: tDTS=tCK_INT
N  *            @arg TIM_CLOCKDIVISION_DIV2: tDTS=2*tCK_INT
N  *            @arg TIM_CLOCKDIVISION_DIV4: tDTS=4*tCK_INT
N  */
N#define __HAL_TIM_GET_CLOCKDIVISION(__HANDLE__)  \
N   ((__HANDLE__)->Instance->CR1 & TIM_CR1_CKD)
X#define __HAL_TIM_GET_CLOCKDIVISION(__HANDLE__)     ((__HANDLE__)->Instance->CR1 & TIM_CR1_CKD)
N
N/**
N  * @brief  Set the TIM Input Capture prescaler on runtime without calling another time HAL_TIM_IC_ConfigChannel() function.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __CHANNEL__ TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
N  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
N  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
N  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
N  * @param  __ICPSC__ specifies the Input Capture4 prescaler new value.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPSC_DIV1: no prescaler
N  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
N  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
N  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
N  * @retval None
N  */
N#define __HAL_TIM_SET_ICPRESCALER(__HANDLE__, __CHANNEL__, __ICPSC__) \
N                        do{                                                    \
N                              TIM_RESET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__));  \
N                              TIM_SET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__), (__ICPSC__)); \
N                          } while(0)
X#define __HAL_TIM_SET_ICPRESCALER(__HANDLE__, __CHANNEL__, __ICPSC__)                         do{                                                                                  TIM_RESET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__));                                TIM_SET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__), (__ICPSC__));                           } while(0)
N
N/**
N  * @brief  Get the TIM Input Capture prescaler on runtime.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __CHANNEL__ TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: get input capture 1 prescaler value
N  *            @arg TIM_CHANNEL_2: get input capture 2 prescaler value
N  *            @arg TIM_CHANNEL_3: get input capture 3 prescaler value
N  *            @arg TIM_CHANNEL_4: get input capture 4 prescaler value
N  * @retval The input capture prescaler can be one of the following values:
N  *            @arg TIM_ICPSC_DIV1: no prescaler
N  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
N  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
N  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
N  */
N#define __HAL_TIM_GET_ICPRESCALER(__HANDLE__, __CHANNEL__)  \
N  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC1PSC) :\
N   ((__CHANNEL__) == TIM_CHANNEL_2) ? (((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC2PSC) >> 8U) :\
N   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC3PSC) :\
N   (((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC4PSC)) >> 8U)
X#define __HAL_TIM_GET_ICPRESCALER(__HANDLE__, __CHANNEL__)    (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC1PSC) :   ((__CHANNEL__) == TIM_CHANNEL_2) ? (((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC2PSC) >> 8U) :   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC3PSC) :   (((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC4PSC)) >> 8U)
N
N/**
N  * @brief  Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __CHANNEL__ TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
N  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
N  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
N  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
N  * @param  __COMPARE__ specifies the Capture Compare register new value.
N  * @retval None
N  */
N#define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1 = (__COMPARE__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2 = (__COMPARE__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3 = (__COMPARE__)) :\
N ((__HANDLE__)->Instance->CCR4 = (__COMPARE__)))
X#define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3 = (__COMPARE__)) : ((__HANDLE__)->Instance->CCR4 = (__COMPARE__)))
N
N/**
N  * @brief  Get the TIM Capture Compare Register value on runtime.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __CHANNEL__ TIM Channel associated with the capture compare register
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: get capture/compare 1 register value
N  *            @arg TIM_CHANNEL_2: get capture/compare 2 register value
N  *            @arg TIM_CHANNEL_3: get capture/compare 3 register value
N  *            @arg TIM_CHANNEL_4: get capture/compare 4 register value
N  * @retval 16-bit or 32-bit value of the capture/compare register (TIMx_CCRy)
N  */
N#define __HAL_TIM_GET_COMPARE(__HANDLE__, __CHANNEL__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3) :\
N ((__HANDLE__)->Instance->CCR4))
X#define __HAL_TIM_GET_COMPARE(__HANDLE__, __CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3) : ((__HANDLE__)->Instance->CCR4))
N
N/**
N  * @brief  Set the TIM Output compare preload.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __CHANNEL__ TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
N  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
N  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
N  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
N  * @retval None
N  */
N#define __HAL_TIM_ENABLE_OCxPRELOAD(__HANDLE__, __CHANNEL__)    \
N        (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC1PE) :\
N         ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC2PE) :\
N         ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC3PE) :\
N         ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC4PE))
X#define __HAL_TIM_ENABLE_OCxPRELOAD(__HANDLE__, __CHANNEL__)            (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC1PE) :         ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC2PE) :         ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC3PE) :         ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC4PE))
N
N/**
N  * @brief  Reset the TIM Output compare preload.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __CHANNEL__ TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
N  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
N  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
N  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
N  * @retval None
N  */
N#define __HAL_TIM_DISABLE_OCxPRELOAD(__HANDLE__, __CHANNEL__)    \
N        (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_OC1PE) :\
N         ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_OC2PE) :\
N         ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_OC3PE) :\
N         ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_OC4PE))
X#define __HAL_TIM_DISABLE_OCxPRELOAD(__HANDLE__, __CHANNEL__)            (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_OC1PE) :         ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_OC2PE) :         ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_OC3PE) :         ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_OC4PE))
N
N/**
N  * @brief  Set the Update Request Source (URS) bit of the TIMx_CR1 register.
N  * @param  __HANDLE__ TIM handle.
N  * @note  When the URS bit of the TIMx_CR1 register is set, only counter
N  *        overflow/underflow generates an update interrupt or DMA request (if
N  *        enabled)
N  * @retval None
N  */
N#define __HAL_TIM_URS_ENABLE(__HANDLE__) \
N    ((__HANDLE__)->Instance->CR1|= TIM_CR1_URS)
X#define __HAL_TIM_URS_ENABLE(__HANDLE__)     ((__HANDLE__)->Instance->CR1|= TIM_CR1_URS)
N
N/**
N  * @brief  Reset the Update Request Source (URS) bit of the TIMx_CR1 register.
N  * @param  __HANDLE__ TIM handle.
N  * @note  When the URS bit of the TIMx_CR1 register is reset, any of the
N  *        following events generate an update interrupt or DMA request (if
N  *        enabled):
N  *           _ Counter overflow underflow
N  *           _ Setting the UG bit
N  *           _ Update generation through the slave mode controller
N  * @retval None
N  */
N#define __HAL_TIM_URS_DISABLE(__HANDLE__) \
N      ((__HANDLE__)->Instance->CR1&=~TIM_CR1_URS)
X#define __HAL_TIM_URS_DISABLE(__HANDLE__)       ((__HANDLE__)->Instance->CR1&=~TIM_CR1_URS)
N
N/**
N  * @brief  Set the TIM Capture x input polarity on runtime.
N  * @param  __HANDLE__ TIM handle.
N  * @param  __CHANNEL__ TIM Channels to be configured.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
N  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
N  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
N  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
N  * @param  __POLARITY__ Polarity for TIx source
N  *            @arg TIM_INPUTCHANNELPOLARITY_RISING: Rising Edge
N  *            @arg TIM_INPUTCHANNELPOLARITY_FALLING: Falling Edge
N  *            @arg TIM_INPUTCHANNELPOLARITY_BOTHEDGE: Rising and Falling Edge
N  * @retval None
N  */
N#define __HAL_TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__)    \
N        do{                                                                     \
N          TIM_RESET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__));               \
N          TIM_SET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__), (__POLARITY__)); \
N        }while(0)
X#define __HAL_TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__)            do{                                                                               TIM_RESET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__));                         TIM_SET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__), (__POLARITY__));         }while(0)
N
N/**
N  * @}
N  */
N/* End of exported macros ----------------------------------------------------*/
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup TIM_Private_Constants TIM Private Constants
N  * @{
N  */
N/* The counter of a timer instance is disabled only if all the CCx and CCxN
N   channels have been disabled */
N#define TIM_CCER_CCxE_MASK  ((uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E))
N#define TIM_CCER_CCxNE_MASK ((uint32_t)(TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE))
N/**
N  * @}
N  */
N/* End of private constants --------------------------------------------------*/
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup TIM_Private_Macros TIM Private Macros
N  * @{
N  */
N#define IS_TIM_CLEARINPUT_SOURCE(__MODE__)  (((__MODE__) == TIM_CLEARINPUTSOURCE_NONE)      || \
N                                             ((__MODE__) == TIM_CLEARINPUTSOURCE_ETR))
X#define IS_TIM_CLEARINPUT_SOURCE(__MODE__)  (((__MODE__) == TIM_CLEARINPUTSOURCE_NONE)      ||                                              ((__MODE__) == TIM_CLEARINPUTSOURCE_ETR))
N
N#define IS_TIM_DMA_BASE(__BASE__) (((__BASE__) == TIM_DMABASE_CR1)   || \
N                                   ((__BASE__) == TIM_DMABASE_CR2)   || \
N                                   ((__BASE__) == TIM_DMABASE_SMCR)  || \
N                                   ((__BASE__) == TIM_DMABASE_DIER)  || \
N                                   ((__BASE__) == TIM_DMABASE_SR)    || \
N                                   ((__BASE__) == TIM_DMABASE_EGR)   || \
N                                   ((__BASE__) == TIM_DMABASE_CCMR1) || \
N                                   ((__BASE__) == TIM_DMABASE_CCMR2) || \
N                                   ((__BASE__) == TIM_DMABASE_CCER)  || \
N                                   ((__BASE__) == TIM_DMABASE_CNT)   || \
N                                   ((__BASE__) == TIM_DMABASE_PSC)   || \
N                                   ((__BASE__) == TIM_DMABASE_ARR)   || \
N                                   ((__BASE__) == TIM_DMABASE_RCR)   || \
N                                   ((__BASE__) == TIM_DMABASE_CCR1)  || \
N                                   ((__BASE__) == TIM_DMABASE_CCR2)  || \
N                                   ((__BASE__) == TIM_DMABASE_CCR3)  || \
N                                   ((__BASE__) == TIM_DMABASE_CCR4)  || \
N                                   ((__BASE__) == TIM_DMABASE_BDTR))
X#define IS_TIM_DMA_BASE(__BASE__) (((__BASE__) == TIM_DMABASE_CR1)   ||                                    ((__BASE__) == TIM_DMABASE_CR2)   ||                                    ((__BASE__) == TIM_DMABASE_SMCR)  ||                                    ((__BASE__) == TIM_DMABASE_DIER)  ||                                    ((__BASE__) == TIM_DMABASE_SR)    ||                                    ((__BASE__) == TIM_DMABASE_EGR)   ||                                    ((__BASE__) == TIM_DMABASE_CCMR1) ||                                    ((__BASE__) == TIM_DMABASE_CCMR2) ||                                    ((__BASE__) == TIM_DMABASE_CCER)  ||                                    ((__BASE__) == TIM_DMABASE_CNT)   ||                                    ((__BASE__) == TIM_DMABASE_PSC)   ||                                    ((__BASE__) == TIM_DMABASE_ARR)   ||                                    ((__BASE__) == TIM_DMABASE_RCR)   ||                                    ((__BASE__) == TIM_DMABASE_CCR1)  ||                                    ((__BASE__) == TIM_DMABASE_CCR2)  ||                                    ((__BASE__) == TIM_DMABASE_CCR3)  ||                                    ((__BASE__) == TIM_DMABASE_CCR4)  ||                                    ((__BASE__) == TIM_DMABASE_BDTR))
N
N#define IS_TIM_EVENT_SOURCE(__SOURCE__) ((((__SOURCE__) & 0xFFFFFF00U) == 0x00000000U) && ((__SOURCE__) != 0x00000000U))
N
N#define IS_TIM_COUNTER_MODE(__MODE__)      (((__MODE__) == TIM_COUNTERMODE_UP)              || \
N                                            ((__MODE__) == TIM_COUNTERMODE_DOWN)            || \
N                                            ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED1)  || \
N                                            ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED2)  || \
N                                            ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED3))
X#define IS_TIM_COUNTER_MODE(__MODE__)      (((__MODE__) == TIM_COUNTERMODE_UP)              ||                                             ((__MODE__) == TIM_COUNTERMODE_DOWN)            ||                                             ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED1)  ||                                             ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED2)  ||                                             ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED3))
N
N#define IS_TIM_CLOCKDIVISION_DIV(__DIV__)  (((__DIV__) == TIM_CLOCKDIVISION_DIV1) || \
N                                            ((__DIV__) == TIM_CLOCKDIVISION_DIV2) || \
N                                            ((__DIV__) == TIM_CLOCKDIVISION_DIV4))
X#define IS_TIM_CLOCKDIVISION_DIV(__DIV__)  (((__DIV__) == TIM_CLOCKDIVISION_DIV1) ||                                             ((__DIV__) == TIM_CLOCKDIVISION_DIV2) ||                                             ((__DIV__) == TIM_CLOCKDIVISION_DIV4))
N
N#define IS_TIM_AUTORELOAD_PRELOAD(PRELOAD) (((PRELOAD) == TIM_AUTORELOAD_PRELOAD_DISABLE) || \
N                                            ((PRELOAD) == TIM_AUTORELOAD_PRELOAD_ENABLE))
X#define IS_TIM_AUTORELOAD_PRELOAD(PRELOAD) (((PRELOAD) == TIM_AUTORELOAD_PRELOAD_DISABLE) ||                                             ((PRELOAD) == TIM_AUTORELOAD_PRELOAD_ENABLE))
N
N#define IS_TIM_FAST_STATE(__STATE__)       (((__STATE__) == TIM_OCFAST_DISABLE) || \
N                                            ((__STATE__) == TIM_OCFAST_ENABLE))
X#define IS_TIM_FAST_STATE(__STATE__)       (((__STATE__) == TIM_OCFAST_DISABLE) ||                                             ((__STATE__) == TIM_OCFAST_ENABLE))
N
N#define IS_TIM_OC_POLARITY(__POLARITY__)   (((__POLARITY__) == TIM_OCPOLARITY_HIGH) || \
N                                            ((__POLARITY__) == TIM_OCPOLARITY_LOW))
X#define IS_TIM_OC_POLARITY(__POLARITY__)   (((__POLARITY__) == TIM_OCPOLARITY_HIGH) ||                                             ((__POLARITY__) == TIM_OCPOLARITY_LOW))
N
N#define IS_TIM_OCN_POLARITY(__POLARITY__)  (((__POLARITY__) == TIM_OCNPOLARITY_HIGH) || \
N                                            ((__POLARITY__) == TIM_OCNPOLARITY_LOW))
X#define IS_TIM_OCN_POLARITY(__POLARITY__)  (((__POLARITY__) == TIM_OCNPOLARITY_HIGH) ||                                             ((__POLARITY__) == TIM_OCNPOLARITY_LOW))
N
N#define IS_TIM_OCIDLE_STATE(__STATE__)     (((__STATE__) == TIM_OCIDLESTATE_SET) || \
N                                            ((__STATE__) == TIM_OCIDLESTATE_RESET))
X#define IS_TIM_OCIDLE_STATE(__STATE__)     (((__STATE__) == TIM_OCIDLESTATE_SET) ||                                             ((__STATE__) == TIM_OCIDLESTATE_RESET))
N
N#define IS_TIM_OCNIDLE_STATE(__STATE__)    (((__STATE__) == TIM_OCNIDLESTATE_SET) || \
N                                            ((__STATE__) == TIM_OCNIDLESTATE_RESET))
X#define IS_TIM_OCNIDLE_STATE(__STATE__)    (((__STATE__) == TIM_OCNIDLESTATE_SET) ||                                             ((__STATE__) == TIM_OCNIDLESTATE_RESET))
N
N#define IS_TIM_IC_POLARITY(__POLARITY__)   (((__POLARITY__) == TIM_ICPOLARITY_RISING)   || \
N                                            ((__POLARITY__) == TIM_ICPOLARITY_FALLING)  || \
N                                            ((__POLARITY__) == TIM_ICPOLARITY_BOTHEDGE))
X#define IS_TIM_IC_POLARITY(__POLARITY__)   (((__POLARITY__) == TIM_ICPOLARITY_RISING)   ||                                             ((__POLARITY__) == TIM_ICPOLARITY_FALLING)  ||                                             ((__POLARITY__) == TIM_ICPOLARITY_BOTHEDGE))
N
N#define IS_TIM_IC_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_ICSELECTION_DIRECTTI) || \
N                                            ((__SELECTION__) == TIM_ICSELECTION_INDIRECTTI) || \
N                                            ((__SELECTION__) == TIM_ICSELECTION_TRC))
X#define IS_TIM_IC_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_ICSELECTION_DIRECTTI) ||                                             ((__SELECTION__) == TIM_ICSELECTION_INDIRECTTI) ||                                             ((__SELECTION__) == TIM_ICSELECTION_TRC))
N
N#define IS_TIM_IC_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_ICPSC_DIV1) || \
N                                            ((__PRESCALER__) == TIM_ICPSC_DIV2) || \
N                                            ((__PRESCALER__) == TIM_ICPSC_DIV4) || \
N                                            ((__PRESCALER__) == TIM_ICPSC_DIV8))
X#define IS_TIM_IC_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_ICPSC_DIV1) ||                                             ((__PRESCALER__) == TIM_ICPSC_DIV2) ||                                             ((__PRESCALER__) == TIM_ICPSC_DIV4) ||                                             ((__PRESCALER__) == TIM_ICPSC_DIV8))
N
N#define IS_TIM_OPM_MODE(__MODE__)          (((__MODE__) == TIM_OPMODE_SINGLE) || \
N                                            ((__MODE__) == TIM_OPMODE_REPETITIVE))
X#define IS_TIM_OPM_MODE(__MODE__)          (((__MODE__) == TIM_OPMODE_SINGLE) ||                                             ((__MODE__) == TIM_OPMODE_REPETITIVE))
N
N#define IS_TIM_ENCODER_MODE(__MODE__)      (((__MODE__) == TIM_ENCODERMODE_TI1) || \
N                                            ((__MODE__) == TIM_ENCODERMODE_TI2) || \
N                                            ((__MODE__) == TIM_ENCODERMODE_TI12))
X#define IS_TIM_ENCODER_MODE(__MODE__)      (((__MODE__) == TIM_ENCODERMODE_TI1) ||                                             ((__MODE__) == TIM_ENCODERMODE_TI2) ||                                             ((__MODE__) == TIM_ENCODERMODE_TI12))
N
N#define IS_TIM_DMA_SOURCE(__SOURCE__) ((((__SOURCE__) & 0xFFFF80FFU) == 0x00000000U) && ((__SOURCE__) != 0x00000000U))
N
N#define IS_TIM_CHANNELS(__CHANNEL__)       (((__CHANNEL__) == TIM_CHANNEL_1) || \
N                                            ((__CHANNEL__) == TIM_CHANNEL_2) || \
N                                            ((__CHANNEL__) == TIM_CHANNEL_3) || \
N                                            ((__CHANNEL__) == TIM_CHANNEL_4) || \
N                                            ((__CHANNEL__) == TIM_CHANNEL_ALL))
X#define IS_TIM_CHANNELS(__CHANNEL__)       (((__CHANNEL__) == TIM_CHANNEL_1) ||                                             ((__CHANNEL__) == TIM_CHANNEL_2) ||                                             ((__CHANNEL__) == TIM_CHANNEL_3) ||                                             ((__CHANNEL__) == TIM_CHANNEL_4) ||                                             ((__CHANNEL__) == TIM_CHANNEL_ALL))
N
N#define IS_TIM_OPM_CHANNELS(__CHANNEL__)   (((__CHANNEL__) == TIM_CHANNEL_1) || \
N                                            ((__CHANNEL__) == TIM_CHANNEL_2))
X#define IS_TIM_OPM_CHANNELS(__CHANNEL__)   (((__CHANNEL__) == TIM_CHANNEL_1) ||                                             ((__CHANNEL__) == TIM_CHANNEL_2))
N
N#define IS_TIM_COMPLEMENTARY_CHANNELS(__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) || \
N                                                    ((__CHANNEL__) == TIM_CHANNEL_2) || \
N                                                    ((__CHANNEL__) == TIM_CHANNEL_3))
X#define IS_TIM_COMPLEMENTARY_CHANNELS(__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ||                                                     ((__CHANNEL__) == TIM_CHANNEL_2) ||                                                     ((__CHANNEL__) == TIM_CHANNEL_3))
N
N#define IS_TIM_CLOCKSOURCE(__CLOCK__) (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0)     || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1)     || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2)     || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3)     || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED)    || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_TI1)      || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_TI2)      || \
N                                       ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1))
X#define IS_TIM_CLOCKSOURCE(__CLOCK__) (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0)     ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1)     ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2)     ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3)     ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED)    ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_TI1)      ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_TI2)      ||                                        ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1))
N
N#define IS_TIM_CLOCKPOLARITY(__POLARITY__) (((__POLARITY__) == TIM_CLOCKPOLARITY_INVERTED)    || \
N                                            ((__POLARITY__) == TIM_CLOCKPOLARITY_NONINVERTED) || \
N                                            ((__POLARITY__) == TIM_CLOCKPOLARITY_RISING)      || \
N                                            ((__POLARITY__) == TIM_CLOCKPOLARITY_FALLING)     || \
N                                            ((__POLARITY__) == TIM_CLOCKPOLARITY_BOTHEDGE))
X#define IS_TIM_CLOCKPOLARITY(__POLARITY__) (((__POLARITY__) == TIM_CLOCKPOLARITY_INVERTED)    ||                                             ((__POLARITY__) == TIM_CLOCKPOLARITY_NONINVERTED) ||                                             ((__POLARITY__) == TIM_CLOCKPOLARITY_RISING)      ||                                             ((__POLARITY__) == TIM_CLOCKPOLARITY_FALLING)     ||                                             ((__POLARITY__) == TIM_CLOCKPOLARITY_BOTHEDGE))
N
N#define IS_TIM_CLOCKPRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV1) || \
N                                              ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV2) || \
N                                              ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV4) || \
N                                              ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV8))
X#define IS_TIM_CLOCKPRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV1) ||                                               ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV2) ||                                               ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV4) ||                                               ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV8))
N
N#define IS_TIM_CLOCKFILTER(__ICFILTER__)      ((__ICFILTER__) <= 0xFU)
N
N#define IS_TIM_CLEARINPUT_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_CLEARINPUTPOLARITY_INVERTED) || \
N                                                  ((__POLARITY__) == TIM_CLEARINPUTPOLARITY_NONINVERTED))
X#define IS_TIM_CLEARINPUT_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_CLEARINPUTPOLARITY_INVERTED) ||                                                   ((__POLARITY__) == TIM_CLEARINPUTPOLARITY_NONINVERTED))
N
N#define IS_TIM_CLEARINPUT_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV1) || \
N                                                    ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV2) || \
N                                                    ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV4) || \
N                                                    ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV8))
X#define IS_TIM_CLEARINPUT_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV1) ||                                                     ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV2) ||                                                     ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV4) ||                                                     ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV8))
N
N#define IS_TIM_CLEARINPUT_FILTER(__ICFILTER__) ((__ICFILTER__) <= 0xFU)
N
N#define IS_TIM_OSSR_STATE(__STATE__)       (((__STATE__) == TIM_OSSR_ENABLE) || \
N                                            ((__STATE__) == TIM_OSSR_DISABLE))
X#define IS_TIM_OSSR_STATE(__STATE__)       (((__STATE__) == TIM_OSSR_ENABLE) ||                                             ((__STATE__) == TIM_OSSR_DISABLE))
N
N#define IS_TIM_OSSI_STATE(__STATE__)       (((__STATE__) == TIM_OSSI_ENABLE) || \
N                                            ((__STATE__) == TIM_OSSI_DISABLE))
X#define IS_TIM_OSSI_STATE(__STATE__)       (((__STATE__) == TIM_OSSI_ENABLE) ||                                             ((__STATE__) == TIM_OSSI_DISABLE))
N
N#define IS_TIM_LOCK_LEVEL(__LEVEL__)       (((__LEVEL__) == TIM_LOCKLEVEL_OFF) || \
N                                            ((__LEVEL__) == TIM_LOCKLEVEL_1)   || \
N                                            ((__LEVEL__) == TIM_LOCKLEVEL_2)   || \
N                                            ((__LEVEL__) == TIM_LOCKLEVEL_3))
X#define IS_TIM_LOCK_LEVEL(__LEVEL__)       (((__LEVEL__) == TIM_LOCKLEVEL_OFF) ||                                             ((__LEVEL__) == TIM_LOCKLEVEL_1)   ||                                             ((__LEVEL__) == TIM_LOCKLEVEL_2)   ||                                             ((__LEVEL__) == TIM_LOCKLEVEL_3))
N
N#define IS_TIM_BREAK_FILTER(__BRKFILTER__) ((__BRKFILTER__) <= 0xFUL)
N
N
N#define IS_TIM_BREAK_STATE(__STATE__)      (((__STATE__) == TIM_BREAK_ENABLE) || \
N                                            ((__STATE__) == TIM_BREAK_DISABLE))
X#define IS_TIM_BREAK_STATE(__STATE__)      (((__STATE__) == TIM_BREAK_ENABLE) ||                                             ((__STATE__) == TIM_BREAK_DISABLE))
N
N#define IS_TIM_BREAK_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAKPOLARITY_LOW) || \
N                                             ((__POLARITY__) == TIM_BREAKPOLARITY_HIGH))
X#define IS_TIM_BREAK_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAKPOLARITY_LOW) ||                                              ((__POLARITY__) == TIM_BREAKPOLARITY_HIGH))
N
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(__STATE__) (((__STATE__) == TIM_AUTOMATICOUTPUT_ENABLE) || \
N                                                  ((__STATE__) == TIM_AUTOMATICOUTPUT_DISABLE))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(__STATE__) (((__STATE__) == TIM_AUTOMATICOUTPUT_ENABLE) ||                                                   ((__STATE__) == TIM_AUTOMATICOUTPUT_DISABLE))
N
N#define IS_TIM_TRGO_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_TRGO_RESET)  || \
N                                        ((__SOURCE__) == TIM_TRGO_ENABLE) || \
N                                        ((__SOURCE__) == TIM_TRGO_UPDATE) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC1)    || \
N                                        ((__SOURCE__) == TIM_TRGO_OC1REF) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC2REF) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC3REF) || \
N                                        ((__SOURCE__) == TIM_TRGO_OC4REF))
X#define IS_TIM_TRGO_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_TRGO_RESET)  ||                                         ((__SOURCE__) == TIM_TRGO_ENABLE) ||                                         ((__SOURCE__) == TIM_TRGO_UPDATE) ||                                         ((__SOURCE__) == TIM_TRGO_OC1)    ||                                         ((__SOURCE__) == TIM_TRGO_OC1REF) ||                                         ((__SOURCE__) == TIM_TRGO_OC2REF) ||                                         ((__SOURCE__) == TIM_TRGO_OC3REF) ||                                         ((__SOURCE__) == TIM_TRGO_OC4REF))
N
N#define IS_TIM_MSM_STATE(__STATE__)      (((__STATE__) == TIM_MASTERSLAVEMODE_ENABLE) || \
N                                          ((__STATE__) == TIM_MASTERSLAVEMODE_DISABLE))
X#define IS_TIM_MSM_STATE(__STATE__)      (((__STATE__) == TIM_MASTERSLAVEMODE_ENABLE) ||                                           ((__STATE__) == TIM_MASTERSLAVEMODE_DISABLE))
N
N#define IS_TIM_SLAVE_MODE(__MODE__) (((__MODE__) == TIM_SLAVEMODE_DISABLE)   || \
N                                     ((__MODE__) == TIM_SLAVEMODE_RESET)     || \
N                                     ((__MODE__) == TIM_SLAVEMODE_GATED)     || \
N                                     ((__MODE__) == TIM_SLAVEMODE_TRIGGER)   || \
N                                     ((__MODE__) == TIM_SLAVEMODE_EXTERNAL1))
X#define IS_TIM_SLAVE_MODE(__MODE__) (((__MODE__) == TIM_SLAVEMODE_DISABLE)   ||                                      ((__MODE__) == TIM_SLAVEMODE_RESET)     ||                                      ((__MODE__) == TIM_SLAVEMODE_GATED)     ||                                      ((__MODE__) == TIM_SLAVEMODE_TRIGGER)   ||                                      ((__MODE__) == TIM_SLAVEMODE_EXTERNAL1))
N
N#define IS_TIM_PWM_MODE(__MODE__) (((__MODE__) == TIM_OCMODE_PWM1)               || \
N                                   ((__MODE__) == TIM_OCMODE_PWM2))
X#define IS_TIM_PWM_MODE(__MODE__) (((__MODE__) == TIM_OCMODE_PWM1)               ||                                    ((__MODE__) == TIM_OCMODE_PWM2))
N
N#define IS_TIM_OC_MODE(__MODE__)  (((__MODE__) == TIM_OCMODE_TIMING)             || \
N                                   ((__MODE__) == TIM_OCMODE_ACTIVE)             || \
N                                   ((__MODE__) == TIM_OCMODE_INACTIVE)           || \
N                                   ((__MODE__) == TIM_OCMODE_TOGGLE)             || \
N                                   ((__MODE__) == TIM_OCMODE_FORCED_ACTIVE)      || \
N                                   ((__MODE__) == TIM_OCMODE_FORCED_INACTIVE))
X#define IS_TIM_OC_MODE(__MODE__)  (((__MODE__) == TIM_OCMODE_TIMING)             ||                                    ((__MODE__) == TIM_OCMODE_ACTIVE)             ||                                    ((__MODE__) == TIM_OCMODE_INACTIVE)           ||                                    ((__MODE__) == TIM_OCMODE_TOGGLE)             ||                                    ((__MODE__) == TIM_OCMODE_FORCED_ACTIVE)      ||                                    ((__MODE__) == TIM_OCMODE_FORCED_INACTIVE))
N
N#define IS_TIM_TRIGGER_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_TS_ITR0) || \
N                                                 ((__SELECTION__) == TIM_TS_ITR1) || \
N                                                 ((__SELECTION__) == TIM_TS_ITR2) || \
N                                                 ((__SELECTION__) == TIM_TS_ITR3) || \
N                                                 ((__SELECTION__) == TIM_TS_TI1F_ED) || \
N                                                 ((__SELECTION__) == TIM_TS_TI1FP1) || \
N                                                 ((__SELECTION__) == TIM_TS_TI2FP2) || \
N                                                 ((__SELECTION__) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_TS_ITR0) ||                                                  ((__SELECTION__) == TIM_TS_ITR1) ||                                                  ((__SELECTION__) == TIM_TS_ITR2) ||                                                  ((__SELECTION__) == TIM_TS_ITR3) ||                                                  ((__SELECTION__) == TIM_TS_TI1F_ED) ||                                                  ((__SELECTION__) == TIM_TS_TI1FP1) ||                                                  ((__SELECTION__) == TIM_TS_TI2FP2) ||                                                  ((__SELECTION__) == TIM_TS_ETRF))
N
N#define IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_TS_ITR0) || \
N                                                               ((__SELECTION__) == TIM_TS_ITR1) || \
N                                                               ((__SELECTION__) == TIM_TS_ITR2) || \
N                                                               ((__SELECTION__) == TIM_TS_ITR3) || \
N                                                               ((__SELECTION__) == TIM_TS_NONE))
X#define IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_TS_ITR0) ||                                                                ((__SELECTION__) == TIM_TS_ITR1) ||                                                                ((__SELECTION__) == TIM_TS_ITR2) ||                                                                ((__SELECTION__) == TIM_TS_ITR3) ||                                                                ((__SELECTION__) == TIM_TS_NONE))
N
N#define IS_TIM_TRIGGERPOLARITY(__POLARITY__)   (((__POLARITY__) == TIM_TRIGGERPOLARITY_INVERTED   ) || \
N                                                ((__POLARITY__) == TIM_TRIGGERPOLARITY_NONINVERTED) || \
N                                                ((__POLARITY__) == TIM_TRIGGERPOLARITY_RISING     ) || \
N                                                ((__POLARITY__) == TIM_TRIGGERPOLARITY_FALLING    ) || \
N                                                ((__POLARITY__) == TIM_TRIGGERPOLARITY_BOTHEDGE   ))
X#define IS_TIM_TRIGGERPOLARITY(__POLARITY__)   (((__POLARITY__) == TIM_TRIGGERPOLARITY_INVERTED   ) ||                                                 ((__POLARITY__) == TIM_TRIGGERPOLARITY_NONINVERTED) ||                                                 ((__POLARITY__) == TIM_TRIGGERPOLARITY_RISING     ) ||                                                 ((__POLARITY__) == TIM_TRIGGERPOLARITY_FALLING    ) ||                                                 ((__POLARITY__) == TIM_TRIGGERPOLARITY_BOTHEDGE   ))
N
N#define IS_TIM_TRIGGERPRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV1) || \
N                                                ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV2) || \
N                                                ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV4) || \
N                                                ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV8))
X#define IS_TIM_TRIGGERPRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV1) ||                                                 ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV2) ||                                                 ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV4) ||                                                 ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV8))
N
N#define IS_TIM_TRIGGERFILTER(__ICFILTER__) ((__ICFILTER__) <= 0xFU)
N
N#define IS_TIM_TI1SELECTION(__TI1SELECTION__)  (((__TI1SELECTION__) == TIM_TI1SELECTION_CH1) || \
N                                                ((__TI1SELECTION__) == TIM_TI1SELECTION_XORCOMBINATION))
X#define IS_TIM_TI1SELECTION(__TI1SELECTION__)  (((__TI1SELECTION__) == TIM_TI1SELECTION_CH1) ||                                                 ((__TI1SELECTION__) == TIM_TI1SELECTION_XORCOMBINATION))
N
N#define IS_TIM_DMA_LENGTH(__LENGTH__)      (((__LENGTH__) == TIM_DMABURSTLENGTH_1TRANSFER) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_2TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_3TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_4TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_5TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_6TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_7TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_8TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_9TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_10TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_11TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_12TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_13TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_14TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_15TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_16TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_17TRANSFERS) || \
N                                            ((__LENGTH__) == TIM_DMABURSTLENGTH_18TRANSFERS))
X#define IS_TIM_DMA_LENGTH(__LENGTH__)      (((__LENGTH__) == TIM_DMABURSTLENGTH_1TRANSFER) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_2TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_3TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_4TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_5TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_6TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_7TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_8TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_9TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_10TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_11TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_12TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_13TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_14TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_15TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_16TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_17TRANSFERS) ||                                             ((__LENGTH__) == TIM_DMABURSTLENGTH_18TRANSFERS))
N
N#define IS_TIM_IC_FILTER(__ICFILTER__)   ((__ICFILTER__) <= 0xFU)
N
N#define IS_TIM_DEADTIME(__DEADTIME__)    ((__DEADTIME__) <= 0xFFU)
N
N#define IS_TIM_SLAVEMODE_TRIGGER_ENABLED(__TRIGGER__) ((__TRIGGER__) == TIM_SLAVEMODE_TRIGGER)
N
N#define TIM_SET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__, __ICPSC__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= (__ICPSC__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= ((__ICPSC__) << 8U)) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= (__ICPSC__)) :\
N ((__HANDLE__)->Instance->CCMR2 |= ((__ICPSC__) << 8U)))
X#define TIM_SET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__, __ICPSC__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= (__ICPSC__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= ((__ICPSC__) << 8U)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= (__ICPSC__)) : ((__HANDLE__)->Instance->CCMR2 |= ((__ICPSC__) << 8U)))
N
N#define TIM_RESET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC) :\
N ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC))
X#define TIM_RESET_ICPRESCALERVALUE(__HANDLE__, __CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC) : ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC))
N
N#define TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER |= (__POLARITY__)) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 4U)) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 8U)) :\
N ((__HANDLE__)->Instance->CCER |= (((__POLARITY__) << 12U))))
X#define TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER |= (__POLARITY__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 4U)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 8U)) : ((__HANDLE__)->Instance->CCER |= (((__POLARITY__) << 12U))))
N
N#define TIM_RESET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__) \
N(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP)) :\
N ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP)) :\
N ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP)) :\
N ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP)))
X#define TIM_RESET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP)) : ((__HANDLE__)->Instance->CCER &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP)))
N
N/**
N  * @}
N  */
N/* End of private macros -----------------------------------------------------*/
N
N/* Include TIM HAL Extended module */
N#include "stm32f4xx_hal_tim_ex.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_tim_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_tim_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of TIM HAL Extended module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef STM32F4xx_HAL_TIM_EX_H
N#define STM32F4xx_HAL_TIM_EX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup TIMEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup TIMEx_Exported_Types TIM Extended Exported Types
N  * @{
N  */
N
N/**
N  * @brief  TIM Hall sensor Configuration Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t IC1Polarity;         /*!< Specifies the active edge of the input signal.
N                                     This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint32_t IC1Prescaler;        /*!< Specifies the Input Capture Prescaler.
N                                     This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint32_t IC1Filter;           /*!< Specifies the input capture filter.
N                                     This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
N
N  uint32_t Commutation_Delay;   /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
N                                     This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
N} TIM_HallSensor_InitTypeDef;
N/**
N  * @}
N  */
N/* End of exported types -----------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup TIMEx_Exported_Constants TIM Extended Exported Constants
N  * @{
N  */
N
N/** @defgroup TIMEx_Remap TIM Extended Remapping
N  * @{
N  */
N#if defined (TIM2)
X#if 1L
N#if defined(TIM8)
X#if 0L
S#define TIM_TIM2_TIM8_TRGO                     0x00000000U                              /*!< TIM2 ITR1 is connected to TIM8 TRGO */
N#else
N#define TIM_TIM2_ETH_PTP                       TIM_OR_ITR1_RMP_0                        /*!< TIM2 ITR1 is connected to PTP trigger output */
N#endif /*  TIM8 */
N#define TIM_TIM2_USBFS_SOF                     TIM_OR_ITR1_RMP_1                        /*!< TIM2 ITR1 is connected to OTG FS SOF */
N#define TIM_TIM2_USBHS_SOF                     (TIM_OR_ITR1_RMP_1 | TIM_OR_ITR1_RMP_0)  /*!< TIM2 ITR1 is connected to OTG HS SOF */
N#endif /* TIM2 */
N
N#define TIM_TIM5_GPIO                          0x00000000U                              /*!< TIM5 TI4 is connected to GPIO */
N#define TIM_TIM5_LSI                           TIM_OR_TI4_RMP_0                         /*!< TIM5 TI4 is connected to LSI */
N#define TIM_TIM5_LSE                           TIM_OR_TI4_RMP_1                         /*!< TIM5 TI4 is connected to LSE */
N#define TIM_TIM5_RTC                           (TIM_OR_TI4_RMP_1 | TIM_OR_TI4_RMP_0)    /*!< TIM5 TI4 is connected to the RTC wakeup interrupt */
N
N#define TIM_TIM11_GPIO                         0x00000000U                              /*!< TIM11 TI1 is connected to GPIO */
N#define TIM_TIM11_HSE                          TIM_OR_TI1_RMP_1                         /*!< TIM11 TI1 is connected to HSE_RTC clock */
N#if defined(SPDIFRX)
X#if 0L
S#define TIM_TIM11_SPDIFRX                      TIM_OR_TI1_RMP_0                         /*!< TIM11 TI1 is connected to SPDIFRX_FRAME_SYNC */
N#endif /* SPDIFRX*/
N
N#if defined(LPTIM_OR_TIM1_ITR2_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP)
X#if 0L && 0L && 0L
S#define LPTIM_REMAP_MASK                       0x10000000U
S
S#define TIM_TIM9_TIM3_TRGO                     LPTIM_REMAP_MASK                             /*!< TIM9 ITR1 is connected to TIM3 TRGO */
S#define TIM_TIM9_LPTIM                         (LPTIM_REMAP_MASK | LPTIM_OR_TIM9_ITR1_RMP)  /*!< TIM9 ITR1 is connected to LPTIM1 output */
S
S#define TIM_TIM5_TIM3_TRGO                     LPTIM_REMAP_MASK                             /*!< TIM5 ITR1 is connected to TIM3 TRGO */
S#define TIM_TIM5_LPTIM                         (LPTIM_REMAP_MASK | LPTIM_OR_TIM5_ITR1_RMP)  /*!< TIM5 ITR1 is connected to LPTIM1 output */
S
S#define TIM_TIM1_TIM3_TRGO                     LPTIM_REMAP_MASK                             /*!< TIM1 ITR2 is connected to TIM3 TRGO */
S#define TIM_TIM1_LPTIM                         (LPTIM_REMAP_MASK | LPTIM_OR_TIM1_ITR2_RMP)  /*!< TIM1 ITR2 is connected to LPTIM1 output */
N#endif /* LPTIM_OR_TIM1_ITR2_RMP &&  LPTIM_OR_TIM5_ITR1_RMP && LPTIM_OR_TIM5_ITR1_RMP */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* End of exported constants -------------------------------------------------*/
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup TIMEx_Exported_Macros TIM Extended Exported Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N/* End of exported macro -----------------------------------------------------*/
N
N/* Private macro -------------------------------------------------------------*/
N/** @defgroup TIMEx_Private_Macros TIM Extended Private Macros
N  * @{
N  */
N#if defined(SPDIFRX)
X#if 0L
S#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                       \
S        ((((INSTANCE) == TIM2)  && (((TIM_REMAP) == TIM_TIM2_TIM8_TRGO)      || \
S                                    ((TIM_REMAP) == TIM_TIM2_USBFS_SOF)      || \
S                                    ((TIM_REMAP) == TIM_TIM2_USBHS_SOF)))    || \
S         (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           || \
S                                    ((TIM_REMAP) == TIM_TIM5_LSI)            || \
S                                    ((TIM_REMAP) == TIM_TIM5_LSE)            || \
S                                    ((TIM_REMAP) == TIM_TIM5_RTC)))          || \
S         (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          || \
S                                    ((TIM_REMAP) == TIM_TIM11_SPDIFRX)       || \
S                                    ((TIM_REMAP) == TIM_TIM11_HSE))))
X#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                               ((((INSTANCE) == TIM2)  && (((TIM_REMAP) == TIM_TIM2_TIM8_TRGO)      ||                                     ((TIM_REMAP) == TIM_TIM2_USBFS_SOF)      ||                                     ((TIM_REMAP) == TIM_TIM2_USBHS_SOF)))    ||          (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           ||                                     ((TIM_REMAP) == TIM_TIM5_LSI)            ||                                     ((TIM_REMAP) == TIM_TIM5_LSE)            ||                                     ((TIM_REMAP) == TIM_TIM5_RTC)))          ||          (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          ||                                     ((TIM_REMAP) == TIM_TIM11_SPDIFRX)       ||                                     ((TIM_REMAP) == TIM_TIM11_HSE))))
N#elif defined(TIM2)
X#elif 1L
N#if defined(LPTIM_OR_TIM1_ITR2_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP)
X#if 0L && 0L && 0L
S#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                       \
S        ((((INSTANCE) == TIM2)  && (((TIM_REMAP) == TIM_TIM2_TIM8_TRGO)      || \
S                                    ((TIM_REMAP) == TIM_TIM2_USBFS_SOF)      || \
S                                    ((TIM_REMAP) == TIM_TIM2_USBHS_SOF)))    || \
S         (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           || \
S                                    ((TIM_REMAP) == TIM_TIM5_LSI)            || \
S                                    ((TIM_REMAP) == TIM_TIM5_LSE)            || \
S                                    ((TIM_REMAP) == TIM_TIM5_RTC)))          || \
S         (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          || \
S                                    ((TIM_REMAP) == TIM_TIM11_HSE)))         || \
S         (((INSTANCE) == TIM1)  && (((TIM_REMAP) == TIM_TIM1_TIM3_TRGO)      || \
S                                    ((TIM_REMAP) == TIM_TIM1_LPTIM)))        || \
S         (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_TIM3_TRGO)      || \
S                                    ((TIM_REMAP) == TIM_TIM5_LPTIM)))        || \
S         (((INSTANCE) == TIM9)  && (((TIM_REMAP) == TIM_TIM9_TIM3_TRGO)      || \
S                                    ((TIM_REMAP) == TIM_TIM9_LPTIM))))
X#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                               ((((INSTANCE) == TIM2)  && (((TIM_REMAP) == TIM_TIM2_TIM8_TRGO)      ||                                     ((TIM_REMAP) == TIM_TIM2_USBFS_SOF)      ||                                     ((TIM_REMAP) == TIM_TIM2_USBHS_SOF)))    ||          (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           ||                                     ((TIM_REMAP) == TIM_TIM5_LSI)            ||                                     ((TIM_REMAP) == TIM_TIM5_LSE)            ||                                     ((TIM_REMAP) == TIM_TIM5_RTC)))          ||          (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          ||                                     ((TIM_REMAP) == TIM_TIM11_HSE)))         ||          (((INSTANCE) == TIM1)  && (((TIM_REMAP) == TIM_TIM1_TIM3_TRGO)      ||                                     ((TIM_REMAP) == TIM_TIM1_LPTIM)))        ||          (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_TIM3_TRGO)      ||                                     ((TIM_REMAP) == TIM_TIM5_LPTIM)))        ||          (((INSTANCE) == TIM9)  && (((TIM_REMAP) == TIM_TIM9_TIM3_TRGO)      ||                                     ((TIM_REMAP) == TIM_TIM9_LPTIM))))
S#elif defined(TIM8)
X#elif 0L
S#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                       \
S        ((((INSTANCE) == TIM2)  && (((TIM_REMAP) == TIM_TIM2_TIM8_TRGO)      || \
S                                    ((TIM_REMAP) == TIM_TIM2_USBFS_SOF)      || \
S                                    ((TIM_REMAP) == TIM_TIM2_USBHS_SOF)))    || \
S         (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           || \
S                                    ((TIM_REMAP) == TIM_TIM5_LSI)            || \
S                                    ((TIM_REMAP) == TIM_TIM5_LSE)            || \
S                                    ((TIM_REMAP) == TIM_TIM5_RTC)))          || \
S         (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          || \
S                                    ((TIM_REMAP) == TIM_TIM11_HSE))))
X#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                               ((((INSTANCE) == TIM2)  && (((TIM_REMAP) == TIM_TIM2_TIM8_TRGO)      ||                                     ((TIM_REMAP) == TIM_TIM2_USBFS_SOF)      ||                                     ((TIM_REMAP) == TIM_TIM2_USBHS_SOF)))    ||          (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           ||                                     ((TIM_REMAP) == TIM_TIM5_LSI)            ||                                     ((TIM_REMAP) == TIM_TIM5_LSE)            ||                                     ((TIM_REMAP) == TIM_TIM5_RTC)))          ||          (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          ||                                     ((TIM_REMAP) == TIM_TIM11_HSE))))
N#else
N#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                       \
N        ((((INSTANCE) == TIM2)  && (((TIM_REMAP) == TIM_TIM2_ETH_PTP)        || \
N                                    ((TIM_REMAP) == TIM_TIM2_USBFS_SOF)      || \
N                                    ((TIM_REMAP) == TIM_TIM2_USBHS_SOF)))    || \
N         (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           || \
N                                    ((TIM_REMAP) == TIM_TIM5_LSI)            || \
N                                    ((TIM_REMAP) == TIM_TIM5_LSE)            || \
N                                    ((TIM_REMAP) == TIM_TIM5_RTC)))          || \
N         (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          || \
N                                    ((TIM_REMAP) == TIM_TIM11_HSE))))
X#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                               ((((INSTANCE) == TIM2)  && (((TIM_REMAP) == TIM_TIM2_ETH_PTP)        ||                                     ((TIM_REMAP) == TIM_TIM2_USBFS_SOF)      ||                                     ((TIM_REMAP) == TIM_TIM2_USBHS_SOF)))    ||          (((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           ||                                     ((TIM_REMAP) == TIM_TIM5_LSI)            ||                                     ((TIM_REMAP) == TIM_TIM5_LSE)            ||                                     ((TIM_REMAP) == TIM_TIM5_RTC)))          ||          (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          ||                                     ((TIM_REMAP) == TIM_TIM11_HSE))))
N#endif /* LPTIM_OR_TIM1_ITR2_RMP &&  LPTIM_OR_TIM5_ITR1_RMP && LPTIM_OR_TIM5_ITR1_RMP */
N#else
S#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                       \
S        ((((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           || \
S                                    ((TIM_REMAP) == TIM_TIM5_LSI)            || \
S                                    ((TIM_REMAP) == TIM_TIM5_LSE)            || \
S                                    ((TIM_REMAP) == TIM_TIM5_RTC)))          || \
S         (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          || \
S                                    ((TIM_REMAP) == TIM_TIM11_HSE))))
X#define IS_TIM_REMAP(INSTANCE, TIM_REMAP)                                               ((((INSTANCE) == TIM5)  && (((TIM_REMAP) == TIM_TIM5_GPIO)           ||                                     ((TIM_REMAP) == TIM_TIM5_LSI)            ||                                     ((TIM_REMAP) == TIM_TIM5_LSE)            ||                                     ((TIM_REMAP) == TIM_TIM5_RTC)))          ||          (((INSTANCE) == TIM11) && (((TIM_REMAP) == TIM_TIM11_GPIO)          ||                                     ((TIM_REMAP) == TIM_TIM11_HSE))))
N#endif /* SPDIFRX */
N
N/**
N  * @}
N  */
N/* End of private macro ------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup TIMEx_Exported_Functions TIM Extended Exported Functions
N  * @{
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions
N *  @brief    Timer Hall Sensor functions
N * @{
N */
N/*  Timer Hall Sensor functions  **********************************************/
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig);
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim);
N
Nvoid HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim);
N
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions
N *  @brief   Timer Complementary Output Compare functions
N * @{
N */
N/*  Timer Complementary Output Compare functions  *****************************/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions
N *  @brief    Timer Complementary PWM functions
N * @{
N */
N/*  Timer Complementary PWM functions  ****************************************/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions
N *  @brief    Timer Complementary One Pulse functions
N * @{
N */
N/*  Timer Complementary One Pulse functions  **********************************/
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
NHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
N
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
NHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions
N *  @brief    Peripheral Control functions
N * @{
N */
N/* Extended Control functions  ************************************************/
NHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource);
NHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource);
NHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource);
NHAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef *sMasterConfig);
NHAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig);
NHAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions
N  * @brief    Extended Callbacks functions
N  * @{
N  */
N/* Extended Callback **********************************************************/
Nvoid HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim);
N/**
N  * @}
N  */
N
N/** @addtogroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions
N  * @brief    Extended Peripheral State functions
N  * @{
N  */
N/* Extended Peripheral State functions  ***************************************/
NHAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* End of exported functions -------------------------------------------------*/
N
N/* Private functions----------------------------------------------------------*/
N/** @defgroup TIMEx_Private_Functions TIM Extended Private Functions
N  * @{
N  */
Nvoid TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma);
Nvoid TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */
N/* End of private functions --------------------------------------------------*/
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* STM32F4xx_HAL_TIM_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 1714 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_tim.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup TIM_Exported_Functions TIM Exported Functions
N  * @{
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group1 TIM Time Base functions
N  *  @brief   Time Base functions
N  * @{
N  */
N/* Time Base functions ********************************************************/
NHAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim);
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group2 TIM Output Compare functions
N  *  @brief   TIM Output Compare functions
N  * @{
N  */
N/* Timer Output Compare functions *********************************************/
NHAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group3 TIM PWM functions
N  *  @brief   TIM PWM functions
N  * @{
N  */
N/* Timer PWM functions ********************************************************/
NHAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group4 TIM Input Capture functions
N  *  @brief   TIM Input Capture functions
N  * @{
N  */
N/* Timer Input Capture functions **********************************************/
NHAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim);
NHAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group5 TIM One Pulse functions
N  *  @brief   TIM One Pulse functions
N  * @{
N  */
N/* Timer One Pulse functions **************************************************/
NHAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode);
NHAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
NHAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
NHAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group6 TIM Encoder functions
N  *  @brief   TIM Encoder functions
N  * @{
N  */
N/* Timer Encoder functions ****************************************************/
NHAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig);
NHAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim);
N/* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
N/* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length);
NHAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @addtogroup TIM_Exported_Functions_Group7 TIM IRQ handler management
N  *  @brief   IRQ handler management
N  * @{
N  */
N/* Interrupt Handler functions  ***********************************************/
Nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim);
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
N  *  @brief   Peripheral Control functions
N  * @{
N  */
N/* Control functions  *********************************************************/
NHAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef *sConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef *sConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OnePulse_InitTypeDef *sConfig, uint32_t OutputChannel,  uint32_t InputChannel);
NHAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef *sClearInputConfig, uint32_t Channel);
NHAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig);
NHAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection);
NHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig);
NHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig);
NHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc, \
N                                              uint32_t  *BurstBuffer, uint32_t  BurstLength);
XHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,                                               uint32_t  *BurstBuffer, uint32_t  BurstLength);
NHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc);
NHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc, \
N                                             uint32_t  *BurstBuffer, uint32_t  BurstLength);
XHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,                                              uint32_t  *BurstBuffer, uint32_t  BurstLength);
NHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc);
NHAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource);
Nuint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel);
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
N  *  @brief   TIM Callbacks functions
N  * @{
N  */
N/* Callback in non blocking modes (Interrupt and DMA) *************************/
Nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim);
Nvoid HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim);
N
N/* Callbacks Register/UnRegister functions  ***********************************/
N#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
SHAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID, pTIM_CallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID);
N#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
N  *  @brief  Peripheral State functions
N  * @{
N  */
N/* Peripheral State functions  ************************************************/
NHAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim);
NHAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* End of exported functions -------------------------------------------------*/
N
N/* Private functions----------------------------------------------------------*/
N/** @defgroup TIM_Private_Functions TIM Private Functions
N* @{
N*/
Nvoid TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure);
Nvoid TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
Nvoid TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
Nvoid TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
N                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
N
Nvoid TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma);
Nvoid TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma);
Nvoid TIM_DMAError(DMA_HandleTypeDef *hdma);
Nvoid TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma);
Nvoid TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma);
Nvoid TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState);
N
N#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
Svoid TIM_ResetCallback(TIM_HandleTypeDef *htim);
N#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
N
N/**
N* @}
N*/
N/* End of private functions --------------------------------------------------*/
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32F4xx_HAL_TIM_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 323 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_TIM_MODULE_ENABLED */
N
N#ifdef HAL_TSC_MODULE_ENABLED
S#include "stm32f4xx_hal_tsc.h"
N#endif /* HAL_TSC_MODULE_ENABLED */
N
N#ifdef HAL_UART_MODULE_ENABLED
N#include "stm32f4xx_hal_uart.h"
L 1 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_uart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hal_uart.h
N  * @author  MCD Application Team
N  * @brief   Header file of UART HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HAL_UART_H
N#define __STM32F4xx_HAL_UART_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal_def.h"
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup UART
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup UART_Exported_Types UART Exported Types
N  * @{
N  */
N
N/**
N  * @brief UART Init Structure definition
N  */
Ntypedef struct
N{
N  uint32_t BaudRate;                  /*!< This member configures the UART communication baud rate.
N                                           The baud rate is computed using the following formula:
N                                           - IntegerDivider = ((PCLKx) / (8 * (OVR8+1) * (huart->Init.BaudRate)))
N                                           - FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 8 * (OVR8+1)) + 0.5
N                                           Where OVR8 is the "oversampling by 8 mode" configuration bit in the CR1 register. */
N
N  uint32_t WordLength;                /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref UART_Word_Length */
N
N  uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref UART_Stop_Bits */
N
N  uint32_t Parity;                    /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref UART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N
N  uint32_t Mode;                      /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref UART_Mode */
N
N  uint32_t HwFlowCtl;                 /*!< Specifies whether the hardware flow control mode is enabled or disabled.
N                                           This parameter can be a value of @ref UART_Hardware_Flow_Control */
N
N  uint32_t OverSampling;              /*!< Specifies whether the Over sampling 8 is enabled or disabled, to achieve higher speed (up to fPCLK/8).
N                                           This parameter can be a value of @ref UART_Over_Sampling */
N} UART_InitTypeDef;
N
N/**
N  * @brief HAL UART State structures definition
N  * @note  HAL UART State value is a combination of 2 different substates: gState and RxState.
N  *        - gState contains UART state information related to global Handle management
N  *          and also information related to Tx operations.
N  *          gState value coding follow below described bitmap :
N  *          b7-b6  Error information
N  *             00 : No Error
N  *             01 : (Not Used)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     Peripheral initialization status
N  *             0  : Reset (Peripheral not initialized)
N  *             1  : Init done (Peripheral not initialized. HAL UART Init function already called)
N  *          b4-b3  (not used)
N  *             xx : Should be set to 00
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (Peripheral busy with some configuration or internal operations)
N  *          b1     (not used)
N  *             x  : Should be set to 0
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  *        - RxState contains information related to Rx operations.
N  *          RxState value coding follow below described bitmap :
N  *          b7-b6  (not used)
N  *             xx : Should be set to 00
N  *          b5     Peripheral initialization status
N  *             0  : Reset (Peripheral not initialized)
N  *             1  : Init done (Peripheral not initialized)
N  *          b4-b2  (not used)
N  *            xxx : Should be set to 000
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     (not used)
N  *             x  : Should be set to 0.
N  */
Ntypedef enum
N{
N  HAL_UART_STATE_RESET             = 0x00U,    /*!< Peripheral is not yet Initialized
N                                                   Value is allowed for gState and RxState */
N  HAL_UART_STATE_READY             = 0x20U,    /*!< Peripheral Initialized and ready for use
N                                                   Value is allowed for gState and RxState */
N  HAL_UART_STATE_BUSY              = 0x24U,    /*!< an internal process is ongoing
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_BUSY_TX           = 0x21U,    /*!< Data Transmission process is ongoing
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_BUSY_RX           = 0x22U,    /*!< Data Reception process is ongoing
N                                                   Value is allowed for RxState only */
N  HAL_UART_STATE_BUSY_TX_RX        = 0x23U,    /*!< Data Transmission and Reception process is ongoing
N                                                   Not to be used for neither gState nor RxState.
N                                                   Value is result of combination (Or) between gState and RxState values */
N  HAL_UART_STATE_TIMEOUT           = 0xA0U,    /*!< Timeout state
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_ERROR             = 0xE0U     /*!< Error
N                                                   Value is allowed for gState only */
N} HAL_UART_StateTypeDef;
N
N/**
N  * @brief  UART handle Structure definition
N  */
Ntypedef struct __UART_HandleTypeDef
N{
N  USART_TypeDef                 *Instance;        /*!< UART registers base address        */
N
N  UART_InitTypeDef              Init;             /*!< UART communication parameters      */
N
N  uint8_t                       *pTxBuffPtr;      /*!< Pointer to UART Tx transfer Buffer */
N
N  uint16_t                      TxXferSize;       /*!< UART Tx Transfer size              */
N
N  __IO uint16_t                 TxXferCount;      /*!< UART Tx Transfer Counter           */
X  volatile uint16_t                 TxXferCount;       
N
N  uint8_t                       *pRxBuffPtr;      /*!< Pointer to UART Rx transfer Buffer */
N
N  uint16_t                      RxXferSize;       /*!< UART Rx Transfer size              */
N
N  __IO uint16_t                 RxXferCount;      /*!< UART Rx Transfer Counter           */
X  volatile uint16_t                 RxXferCount;       
N
N  DMA_HandleTypeDef             *hdmatx;          /*!< UART Tx DMA Handle parameters      */
N
N  DMA_HandleTypeDef             *hdmarx;          /*!< UART Rx DMA Handle parameters      */
N
N  HAL_LockTypeDef               Lock;             /*!< Locking object                     */
N
N  __IO HAL_UART_StateTypeDef    gState;           /*!< UART state information related to global Handle management
X  volatile HAL_UART_StateTypeDef    gState;           
N                                                       and also related to Tx operations.
N                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO HAL_UART_StateTypeDef    RxState;          /*!< UART state information related to Rx operations.
X  volatile HAL_UART_StateTypeDef    RxState;          
N                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO uint32_t                 ErrorCode;        /*!< UART Error code                    */
X  volatile uint32_t                 ErrorCode;         
N
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
S  void (* TxHalfCpltCallback)(struct __UART_HandleTypeDef *huart);        /*!< UART Tx Half Complete Callback        */
S  void (* TxCpltCallback)(struct __UART_HandleTypeDef *huart);            /*!< UART Tx Complete Callback             */
S  void (* RxHalfCpltCallback)(struct __UART_HandleTypeDef *huart);        /*!< UART Rx Half Complete Callback        */
S  void (* RxCpltCallback)(struct __UART_HandleTypeDef *huart);            /*!< UART Rx Complete Callback             */
S  void (* ErrorCallback)(struct __UART_HandleTypeDef *huart);             /*!< UART Error Callback                   */
S  void (* AbortCpltCallback)(struct __UART_HandleTypeDef *huart);         /*!< UART Abort Complete Callback          */
S  void (* AbortTransmitCpltCallback)(struct __UART_HandleTypeDef *huart); /*!< UART Abort Transmit Complete Callback */
S  void (* AbortReceiveCpltCallback)(struct __UART_HandleTypeDef *huart);  /*!< UART Abort Receive Complete Callback  */
S  void (* WakeupCallback)(struct __UART_HandleTypeDef *huart);            /*!< UART Wakeup Callback                  */
S
S  void (* MspInitCallback)(struct __UART_HandleTypeDef *huart);           /*!< UART Msp Init callback                */
S  void (* MspDeInitCallback)(struct __UART_HandleTypeDef *huart);         /*!< UART Msp DeInit callback              */
N#endif  /* USE_HAL_UART_REGISTER_CALLBACKS */
N
N} UART_HandleTypeDef;
N
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
S/**
S  * @brief  HAL UART Callback ID enumeration definition
S  */
Stypedef enum
S{
S  HAL_UART_TX_HALFCOMPLETE_CB_ID         = 0x00U,    /*!< UART Tx Half Complete Callback ID        */
S  HAL_UART_TX_COMPLETE_CB_ID             = 0x01U,    /*!< UART Tx Complete Callback ID             */
S  HAL_UART_RX_HALFCOMPLETE_CB_ID         = 0x02U,    /*!< UART Rx Half Complete Callback ID        */
S  HAL_UART_RX_COMPLETE_CB_ID             = 0x03U,    /*!< UART Rx Complete Callback ID             */
S  HAL_UART_ERROR_CB_ID                   = 0x04U,    /*!< UART Error Callback ID                   */
S  HAL_UART_ABORT_COMPLETE_CB_ID          = 0x05U,    /*!< UART Abort Complete Callback ID          */
S  HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID = 0x06U,    /*!< UART Abort Transmit Complete Callback ID */
S  HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID  = 0x07U,    /*!< UART Abort Receive Complete Callback ID  */
S  HAL_UART_WAKEUP_CB_ID                  = 0x08U,    /*!< UART Wakeup Callback ID                  */
S
S  HAL_UART_MSPINIT_CB_ID                 = 0x0BU,    /*!< UART MspInit callback ID                 */
S  HAL_UART_MSPDEINIT_CB_ID               = 0x0CU     /*!< UART MspDeInit callback ID               */
S
S} HAL_UART_CallbackIDTypeDef;
S
S/**
S  * @brief  HAL UART Callback pointer definition
S  */
Stypedef  void (*pUART_CallbackTypeDef)(UART_HandleTypeDef *huart);  /*!< pointer to an UART callback function */
S
N#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup UART_Exported_Constants UART Exported Constants
N  * @{
N  */
N
N/** @defgroup UART_Error_Code UART Error Code
N  * @{
N  */
N#define HAL_UART_ERROR_NONE              0x00000000U   /*!< No error            */
N#define HAL_UART_ERROR_PE                0x00000001U   /*!< Parity error        */
N#define HAL_UART_ERROR_NE                0x00000002U   /*!< Noise error         */
N#define HAL_UART_ERROR_FE                0x00000004U   /*!< Frame error         */
N#define HAL_UART_ERROR_ORE               0x00000008U   /*!< Overrun error       */
N#define HAL_UART_ERROR_DMA               0x00000010U   /*!< DMA transfer error  */
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
S#define  HAL_UART_ERROR_INVALID_CALLBACK 0x00000020U   /*!< Invalid Callback error  */
N#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Word_Length UART Word Length
N  * @{
N  */
N#define UART_WORDLENGTH_8B                  0x00000000U
N#define UART_WORDLENGTH_9B                  ((uint32_t)USART_CR1_M)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Stop_Bits UART Number of Stop Bits
N  * @{
N  */
N#define UART_STOPBITS_1                     0x00000000U
N#define UART_STOPBITS_2                     ((uint32_t)USART_CR2_STOP_1)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Parity UART Parity
N  * @{
N  */
N#define UART_PARITY_NONE                    0x00000000U
N#define UART_PARITY_EVEN                    ((uint32_t)USART_CR1_PCE)
N#define UART_PARITY_ODD                     ((uint32_t)(USART_CR1_PCE | USART_CR1_PS))
N/**
N  * @}
N  */
N
N/** @defgroup UART_Hardware_Flow_Control UART Hardware Flow Control
N  * @{
N  */
N#define UART_HWCONTROL_NONE                  0x00000000U
N#define UART_HWCONTROL_RTS                   ((uint32_t)USART_CR3_RTSE)
N#define UART_HWCONTROL_CTS                   ((uint32_t)USART_CR3_CTSE)
N#define UART_HWCONTROL_RTS_CTS               ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE))
N/**
N  * @}
N  */
N
N/** @defgroup UART_Mode UART Transfer Mode
N  * @{
N  */
N#define UART_MODE_RX                        ((uint32_t)USART_CR1_RE)
N#define UART_MODE_TX                        ((uint32_t)USART_CR1_TE)
N#define UART_MODE_TX_RX                     ((uint32_t)(USART_CR1_TE | USART_CR1_RE))
N/**
N  * @}
N  */
N
N/** @defgroup UART_State UART State
N  * @{
N  */
N#define UART_STATE_DISABLE                  0x00000000U
N#define UART_STATE_ENABLE                   ((uint32_t)USART_CR1_UE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Over_Sampling UART Over Sampling
N  * @{
N  */
N#define UART_OVERSAMPLING_16                    0x00000000U
N#define UART_OVERSAMPLING_8                     ((uint32_t)USART_CR1_OVER8)
N/**
N  * @}
N  */
N
N/** @defgroup UART_LIN_Break_Detection_Length  UART LIN Break Detection Length
N  * @{
N  */
N#define UART_LINBREAKDETECTLENGTH_10B      0x00000000U
N#define UART_LINBREAKDETECTLENGTH_11B      ((uint32_t)USART_CR2_LBDL)
N/**
N  * @}
N  */
N
N/** @defgroup UART_WakeUp_functions  UART Wakeup Functions
N  * @{
N  */
N#define UART_WAKEUPMETHOD_IDLELINE                0x00000000U
N#define UART_WAKEUPMETHOD_ADDRESSMARK             ((uint32_t)USART_CR1_WAKE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Flags   UART FLags
N  *        Elements values convention: 0xXXXX
N  *           - 0xXXXX  : Flag mask in the SR register
N  * @{
N  */
N#define UART_FLAG_CTS                       ((uint32_t)USART_SR_CTS)
N#define UART_FLAG_LBD                       ((uint32_t)USART_SR_LBD)
N#define UART_FLAG_TXE                       ((uint32_t)USART_SR_TXE)
N#define UART_FLAG_TC                        ((uint32_t)USART_SR_TC)
N#define UART_FLAG_RXNE                      ((uint32_t)USART_SR_RXNE)
N#define UART_FLAG_IDLE                      ((uint32_t)USART_SR_IDLE)
N#define UART_FLAG_ORE                       ((uint32_t)USART_SR_ORE)
N#define UART_FLAG_NE                        ((uint32_t)USART_SR_NE)
N#define UART_FLAG_FE                        ((uint32_t)USART_SR_FE)
N#define UART_FLAG_PE                        ((uint32_t)USART_SR_PE)
N/**
N  * @}
N  */
N
N/** @defgroup UART_Interrupt_definition  UART Interrupt Definitions
N  *        Elements values convention: 0xY000XXXX
N  *           - XXXX  : Interrupt mask (16 bits) in the Y register
N  *           - Y  : Interrupt source register (2bits)
N  *                   - 0001: CR1 register
N  *                   - 0010: CR2 register
N  *                   - 0011: CR3 register
N  * @{
N  */
N
N#define UART_IT_PE                       ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_PEIE))
N#define UART_IT_TXE                      ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_TXEIE))
N#define UART_IT_TC                       ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_TCIE))
N#define UART_IT_RXNE                     ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_RXNEIE))
N#define UART_IT_IDLE                     ((uint32_t)(UART_CR1_REG_INDEX << 28U | USART_CR1_IDLEIE))
N
N#define UART_IT_LBD                      ((uint32_t)(UART_CR2_REG_INDEX << 28U | USART_CR2_LBDIE))
N
N#define UART_IT_CTS                      ((uint32_t)(UART_CR3_REG_INDEX << 28U | USART_CR3_CTSIE))
N#define UART_IT_ERR                      ((uint32_t)(UART_CR3_REG_INDEX << 28U | USART_CR3_EIE))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup UART_Exported_Macros UART Exported Macros
N  * @{
N  */
N
N/** @brief Reset UART handle gstate & RxState
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
S#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
S                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
S                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
S                                                       (__HANDLE__)->MspInitCallback = NULL;             \
S                                                       (__HANDLE__)->MspDeInitCallback = NULL;           \
S                                                     } while(0U)
X#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                                                                          (__HANDLE__)->gState = HAL_UART_STATE_RESET;                                                             (__HANDLE__)->RxState = HAL_UART_STATE_RESET;                                                            (__HANDLE__)->MspInitCallback = NULL;                                                                    (__HANDLE__)->MspDeInitCallback = NULL;                                                                } while(0U)
N#else
N#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
N                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
N                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
N                                                     } while(0U)
X#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                                                                          (__HANDLE__)->gState = HAL_UART_STATE_RESET;                                                             (__HANDLE__)->RxState = HAL_UART_STATE_RESET;                                                          } while(0U)
N#endif /*USE_HAL_UART_REGISTER_CALLBACKS */
N
N/** @brief  Flushes the UART DR register
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  */
N#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__) ((__HANDLE__)->Instance->DR)
N
N/** @brief  Checks whether the specified UART flag is set or not.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __FLAG__ specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg UART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
N  *            @arg UART_FLAG_LBD:  LIN Break detection flag
N  *            @arg UART_FLAG_TXE:  Transmit data register empty flag
N  *            @arg UART_FLAG_TC:   Transmission Complete flag
N  *            @arg UART_FLAG_RXNE: Receive data register not empty flag
N  *            @arg UART_FLAG_IDLE: Idle Line detection flag
N  *            @arg UART_FLAG_ORE:  Overrun Error flag
N  *            @arg UART_FLAG_NE:   Noise Error flag
N  *            @arg UART_FLAG_FE:   Framing Error flag
N  *            @arg UART_FLAG_PE:   Parity Error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->SR & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clears the specified UART pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __FLAG__ specifies the flag to check.
N  *          This parameter can be any combination of the following values:
N  *            @arg UART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
N  *            @arg UART_FLAG_LBD:  LIN Break detection flag.
N  *            @arg UART_FLAG_TC:   Transmission Complete flag.
N  *            @arg UART_FLAG_RXNE: Receive data register not empty flag.
N  *
N  * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (Overrun
N  *          error) and IDLE (Idle line detected) flags are cleared by software
N  *          sequence: a read operation to USART_SR register followed by a read
N  *          operation to USART_DR register.
N  * @note   RXNE flag can be also cleared by a read to the USART_DR register.
N  * @note   TC flag can be also cleared by software sequence: a read operation to
N  *          USART_SR register followed by a write operation to USART_DR register.
N  * @note   TXE flag is cleared only by a write to the USART_DR register.
N  *
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->SR = ~(__FLAG__))
N
N/** @brief  Clears the UART PE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_PEFLAG(__HANDLE__)     \
N  do{                                           \
N    __IO uint32_t tmpreg = 0x00U;               \
N    tmpreg = (__HANDLE__)->Instance->SR;        \
N    tmpreg = (__HANDLE__)->Instance->DR;        \
N    UNUSED(tmpreg);                             \
N  } while(0U)
X#define __HAL_UART_CLEAR_PEFLAG(__HANDLE__)       do{                                               __IO uint32_t tmpreg = 0x00U;                   tmpreg = (__HANDLE__)->Instance->SR;            tmpreg = (__HANDLE__)->Instance->DR;            UNUSED(tmpreg);                               } while(0U)
N
N/** @brief  Clears the UART FE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_FEFLAG(__HANDLE__) __HAL_UART_CLEAR_PEFLAG(__HANDLE__)
N
N/** @brief  Clears the UART NE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_NEFLAG(__HANDLE__) __HAL_UART_CLEAR_PEFLAG(__HANDLE__)
N
N/** @brief  Clears the UART ORE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_OREFLAG(__HANDLE__) __HAL_UART_CLEAR_PEFLAG(__HANDLE__)
N
N/** @brief  Clears the UART IDLE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_IDLEFLAG(__HANDLE__) __HAL_UART_CLEAR_PEFLAG(__HANDLE__)
N
N/** @brief  Enable the specified UART interrupt.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __INTERRUPT__ specifies the UART interrupt source to enable.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CTS:  CTS change interrupt
N  *            @arg UART_IT_LBD:  LIN Break detection interrupt
N  *            @arg UART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:   Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_PE:   Parity Error interrupt
N  *            @arg UART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 |= ((__INTERRUPT__) & UART_IT_MASK)): \
N                                                           (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 |= ((__INTERRUPT__) & UART_IT_MASK)): \
N                                                           ((__HANDLE__)->Instance->CR3 |= ((__INTERRUPT__) & UART_IT_MASK)))
X#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 |= ((__INTERRUPT__) & UART_IT_MASK)):                                                            (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 |= ((__INTERRUPT__) & UART_IT_MASK)):                                                            ((__HANDLE__)->Instance->CR3 |= ((__INTERRUPT__) & UART_IT_MASK)))
N
N/** @brief  Disable the specified UART interrupt.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __INTERRUPT__ specifies the UART interrupt source to disable.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CTS:  CTS change interrupt
N  *            @arg UART_IT_LBD:  LIN Break detection interrupt
N  *            @arg UART_IT_TXE:  Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:   Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_PE:   Parity Error interrupt
N  *            @arg UART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 &= ~((__INTERRUPT__) & UART_IT_MASK)): \
N                                                           (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 &= ~((__INTERRUPT__) & UART_IT_MASK)): \
N                                                           ((__HANDLE__)->Instance->CR3 &= ~ ((__INTERRUPT__) & UART_IT_MASK)))
X#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 &= ~((__INTERRUPT__) & UART_IT_MASK)):                                                            (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 &= ~((__INTERRUPT__) & UART_IT_MASK)):                                                            ((__HANDLE__)->Instance->CR3 &= ~ ((__INTERRUPT__) & UART_IT_MASK)))
N
N/** @brief  Checks whether the specified UART interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         UART Handle selects the USARTx or UARTy peripheral
N  *         (USART,UART availability and x,y values depending on device).
N  * @param  __IT__ specifies the UART interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg UART_IT_CTS: CTS change interrupt (not available for UART4 and UART5)
N  *            @arg UART_IT_LBD: LIN Break detection interrupt
N  *            @arg UART_IT_TXE: Transmit Data Register empty interrupt
N  *            @arg UART_IT_TC:  Transmission complete interrupt
N  *            @arg UART_IT_RXNE: Receive Data register not empty interrupt
N  *            @arg UART_IT_IDLE: Idle line detection interrupt
N  *            @arg UART_IT_ERR: Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) (((((__IT__) >> 28U) == UART_CR1_REG_INDEX)? (__HANDLE__)->Instance->CR1:(((((uint32_t)(__IT__)) >> 28U) == UART_CR2_REG_INDEX)? \
N                                                      (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (((uint32_t)(__IT__)) & UART_IT_MASK))
X#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) (((((__IT__) >> 28U) == UART_CR1_REG_INDEX)? (__HANDLE__)->Instance->CR1:(((((uint32_t)(__IT__)) >> 28U) == UART_CR2_REG_INDEX)?                                                       (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (((uint32_t)(__IT__)) & UART_IT_MASK))
N
N/** @brief  Enable CTS flow control
N  * @note   This macro allows to enable CTS hardware flow control for a given UART instance,
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         The Handle Instance can be any USARTx (supporting the HW Flow control feature).
N  *         It is used to select the USART peripheral (USART availability and x value depending on device).
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)        \
N  do{                                                      \
N    SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);  \
N    (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE;        \
N  } while(0U)
X#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)          do{                                                          SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);      (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE;          } while(0U)
N
N/** @brief  Disable CTS flow control
N  * @note   This macro allows to disable CTS hardware flow control for a given UART instance,
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         The Handle Instance can be any USARTx (supporting the HW Flow control feature).
N  *         It is used to select the USART peripheral (USART availability and x value depending on device).
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)        \
N  do{                                                       \
N    CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); \
N    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE);      \
N  } while(0U)
X#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)          do{                                                           CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);     (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE);        } while(0U)
N
N/** @brief  Enable RTS flow control
N  *         This macro allows to enable RTS hardware flow control for a given UART instance,
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         The Handle Instance can be any USARTx (supporting the HW Flow control feature).
N  *         It is used to select the USART peripheral (USART availability and x value depending on device).
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)       \
N  do{                                                     \
N    SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); \
N    (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE;       \
N  } while(0U)
X#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)         do{                                                         SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);     (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE;         } while(0U)
N
N/** @brief  Disable RTS flow control
N  *         This macro allows to disable RTS hardware flow control for a given UART instance,
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).
N  * @param  __HANDLE__ specifies the UART Handle.
N  *         The Handle Instance can be any USARTx (supporting the HW Flow control feature).
N  *         It is used to select the USART peripheral (USART availability and x value depending on device).
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)       \
N  do{                                                      \
N    CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);\
N    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE);     \
N  } while(0U)
X#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)         do{                                                          CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE);       } while(0U)
N
N/** @brief  Macro to enable the UART's one bit sample method
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_ONE_BIT_SAMPLE_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3|= USART_CR3_ONEBIT)
N
N/** @brief  Macro to disable the UART's one bit sample method
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT))
N
N/** @brief  Enable UART
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_ENABLE(__HANDLE__)               ((__HANDLE__)->Instance->CR1 |=  USART_CR1_UE)
N
N/** @brief  Disable UART
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_DISABLE(__HANDLE__)              ((__HANDLE__)->Instance->CR1 &=  ~USART_CR1_UE)
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup UART_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N
N/* Initialization/de-initialization functions  **********************************/
NHAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength);
NHAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod);
NHAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart);
Nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart);
Nvoid HAL_UART_MspDeInit(UART_HandleTypeDef *huart);
N
N/* Callbacks Register/UnRegister functions  ***********************************/
N#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
SHAL_StatusTypeDef HAL_UART_RegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID, pUART_CallbackTypeDef pCallback);
SHAL_StatusTypeDef HAL_UART_UnRegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID);
N#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group2 IO operation functions
N  * @{
N  */
N
N/* IO operation functions *******************************************************/
NHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart);
N/* Transfer Abort functions */
NHAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart);
N
Nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart);
Nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral Control functions  ************************************************/
NHAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart);
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group4
N  * @{
N  */
N/* Peripheral State functions  **************************************************/
NHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart);
Nuint32_t              HAL_UART_GetError(UART_HandleTypeDef *huart);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup UART_Private_Constants UART Private Constants
N  * @{
N  */
N/** @brief UART interruptions flag mask
N  *
N  */
N#define UART_IT_MASK                     0x0000FFFFU
N
N#define UART_CR1_REG_INDEX               1U
N#define UART_CR2_REG_INDEX               2U
N#define UART_CR3_REG_INDEX               3U
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup UART_Private_Macros UART Private Macros
N  * @{
N  */
N#define IS_UART_WORD_LENGTH(LENGTH) (((LENGTH) == UART_WORDLENGTH_8B) || \
N                                     ((LENGTH) == UART_WORDLENGTH_9B))
X#define IS_UART_WORD_LENGTH(LENGTH) (((LENGTH) == UART_WORDLENGTH_8B) ||                                      ((LENGTH) == UART_WORDLENGTH_9B))
N#define IS_UART_LIN_WORD_LENGTH(LENGTH) (((LENGTH) == UART_WORDLENGTH_8B))
N#define IS_UART_STOPBITS(STOPBITS) (((STOPBITS) == UART_STOPBITS_1) || \
N                                    ((STOPBITS) == UART_STOPBITS_2))
X#define IS_UART_STOPBITS(STOPBITS) (((STOPBITS) == UART_STOPBITS_1) ||                                     ((STOPBITS) == UART_STOPBITS_2))
N#define IS_UART_PARITY(PARITY) (((PARITY) == UART_PARITY_NONE) || \
N                                ((PARITY) == UART_PARITY_EVEN) || \
N                                ((PARITY) == UART_PARITY_ODD))
X#define IS_UART_PARITY(PARITY) (((PARITY) == UART_PARITY_NONE) ||                                 ((PARITY) == UART_PARITY_EVEN) ||                                 ((PARITY) == UART_PARITY_ODD))
N#define IS_UART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == UART_HWCONTROL_NONE) || \
N                               ((CONTROL) == UART_HWCONTROL_RTS) || \
N                               ((CONTROL) == UART_HWCONTROL_CTS) || \
N                               ((CONTROL) == UART_HWCONTROL_RTS_CTS))
X#define IS_UART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == UART_HWCONTROL_NONE) ||                                ((CONTROL) == UART_HWCONTROL_RTS) ||                                ((CONTROL) == UART_HWCONTROL_CTS) ||                                ((CONTROL) == UART_HWCONTROL_RTS_CTS))
N#define IS_UART_MODE(MODE) ((((MODE) & 0x0000FFF3U) == 0x00U) && ((MODE) != 0x00U))
N#define IS_UART_STATE(STATE) (((STATE) == UART_STATE_DISABLE) || \
N                              ((STATE) == UART_STATE_ENABLE))
X#define IS_UART_STATE(STATE) (((STATE) == UART_STATE_DISABLE) ||                               ((STATE) == UART_STATE_ENABLE))
N#define IS_UART_OVERSAMPLING(SAMPLING) (((SAMPLING) == UART_OVERSAMPLING_16) || \
N                                        ((SAMPLING) == UART_OVERSAMPLING_8))
X#define IS_UART_OVERSAMPLING(SAMPLING) (((SAMPLING) == UART_OVERSAMPLING_16) ||                                         ((SAMPLING) == UART_OVERSAMPLING_8))
N#define IS_UART_LIN_OVERSAMPLING(SAMPLING) (((SAMPLING) == UART_OVERSAMPLING_16))
N#define IS_UART_LIN_BREAK_DETECT_LENGTH(LENGTH) (((LENGTH) == UART_LINBREAKDETECTLENGTH_10B) || \
N                                                 ((LENGTH) == UART_LINBREAKDETECTLENGTH_11B))
X#define IS_UART_LIN_BREAK_DETECT_LENGTH(LENGTH) (((LENGTH) == UART_LINBREAKDETECTLENGTH_10B) ||                                                  ((LENGTH) == UART_LINBREAKDETECTLENGTH_11B))
N#define IS_UART_WAKEUPMETHOD(WAKEUP) (((WAKEUP) == UART_WAKEUPMETHOD_IDLELINE) || \
N                                      ((WAKEUP) == UART_WAKEUPMETHOD_ADDRESSMARK))
X#define IS_UART_WAKEUPMETHOD(WAKEUP) (((WAKEUP) == UART_WAKEUPMETHOD_IDLELINE) ||                                       ((WAKEUP) == UART_WAKEUPMETHOD_ADDRESSMARK))
N#define IS_UART_BAUDRATE(BAUDRATE) ((BAUDRATE) <= 10500000U)
N#define IS_UART_ADDRESS(ADDRESS) ((ADDRESS) <= 0x0FU)
N
N#define UART_DIV_SAMPLING16(_PCLK_, _BAUD_)            (((_PCLK_)*25U)/(4U*(_BAUD_)))
N#define UART_DIVMANT_SAMPLING16(_PCLK_, _BAUD_)        (UART_DIV_SAMPLING16((_PCLK_), (_BAUD_))/100U)
N#define UART_DIVFRAQ_SAMPLING16(_PCLK_, _BAUD_)        (((UART_DIV_SAMPLING16((_PCLK_), (_BAUD_)) - (UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) * 100U)) * 16U + 50U) / 100U)
N/* UART BRR = mantissa + overflow + fraction
N            = (UART DIVMANT << 4) + (UART DIVFRAQ & 0xF0) + (UART DIVFRAQ & 0x0FU) */
N#define UART_BRR_SAMPLING16(_PCLK_, _BAUD_)            (((UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) << 4U) + \
N                                                        (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0xF0U)) + \
N                                                        (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0x0FU))
X#define UART_BRR_SAMPLING16(_PCLK_, _BAUD_)            (((UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) << 4U) +                                                         (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0xF0U)) +                                                         (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0x0FU))
N
N#define UART_DIV_SAMPLING8(_PCLK_, _BAUD_)             (((_PCLK_)*25U)/(2U*(_BAUD_)))
N#define UART_DIVMANT_SAMPLING8(_PCLK_, _BAUD_)         (UART_DIV_SAMPLING8((_PCLK_), (_BAUD_))/100U)
N#define UART_DIVFRAQ_SAMPLING8(_PCLK_, _BAUD_)         (((UART_DIV_SAMPLING8((_PCLK_), (_BAUD_)) - (UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) * 100U)) * 8U + 50U) / 100U)
N/* UART BRR = mantissa + overflow + fraction
N            = (UART DIVMANT << 4) + ((UART DIVFRAQ & 0xF8) << 1) + (UART DIVFRAQ & 0x07U) */
N#define UART_BRR_SAMPLING8(_PCLK_, _BAUD_)             (((UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) << 4U) + \
N                                                        ((UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0xF8U) << 1U)) + \
N                                                        (UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0x07U))
X#define UART_BRR_SAMPLING8(_PCLK_, _BAUD_)             (((UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) << 4U) +                                                         ((UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0xF8U) << 1U)) +                                                         (UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0x07U))
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup UART_Private_Functions UART Private Functions
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_UART_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 331 "..\Inc\stm32f4xx_hal_conf.h" 2
N#endif /* HAL_UART_MODULE_ENABLED */
N
N#ifdef HAL_USART_MODULE_ENABLED
S#include "stm32f4xx_hal_usart.h"
N#endif /* HAL_USART_MODULE_ENABLED */
N
N#ifdef HAL_IRDA_MODULE_ENABLED
S#include "stm32f4xx_hal_irda.h"
N#endif /* HAL_IRDA_MODULE_ENABLED */
N
N#ifdef HAL_SMARTCARD_MODULE_ENABLED
S#include "stm32f4xx_hal_smartcard.h"
N#endif /* HAL_SMARTCARD_MODULE_ENABLED */
N
N#ifdef HAL_WWDG_MODULE_ENABLED
S#include "stm32f4xx_hal_wwdg.h"
N#endif /* HAL_WWDG_MODULE_ENABLED */
N
N#ifdef HAL_PCD_MODULE_ENABLED
S#include "stm32f4xx_hal_pcd.h"
N#endif /* HAL_PCD_MODULE_ENABLED */
N
N#ifdef HAL_HCD_MODULE_ENABLED
S#include "stm32f4xx_hal_hcd.h"
N#endif /* HAL_HCD_MODULE_ENABLED */
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S/**
S * @brief  The assert_param macro is used for function's parameters check.
S * @param  expr: If expr is false, it calls assert_failed function
S *         which reports the name of the source file and the source
S *         line number of the call that failed.
S *         If expr is true, it returns no value.
S * @retval None
S */
S#define assert_param(expr) ((expr) ? (void)0U : assert_failed((char *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
Svoid assert_failed(char *file, uint32_t line);
N#else
N#define assert_param(expr) ((void)0U)
N#endif /* USE_FULL_ASSERT */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* STM32F4xx_HAL_CONF_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 31 "..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal.h" 2
N
N/** @addtogroup STM32F4xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup HAL
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup HAL_Exported_Constants HAL Exported Constants
N  * @{
N  */
N
N/** @defgroup HAL_TICK_FREQ Tick Frequency
N  * @{
N  */
Ntypedef enum
N{
N  HAL_TICK_FREQ_10HZ         = 100U,
N  HAL_TICK_FREQ_100HZ        = 10U,
N  HAL_TICK_FREQ_1KHZ         = 1U,
N  HAL_TICK_FREQ_DEFAULT      = HAL_TICK_FREQ_1KHZ
N} HAL_TickFreqTypeDef;
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N   
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup HAL_Exported_Macros HAL Exported Macros
N  * @{
N  */
N
N/** @brief  Freeze/Unfreeze Peripherals in Debug mode 
N  */
N#define __HAL_DBGMCU_FREEZE_TIM2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM2_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM3()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM3_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM4()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM4_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM5()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM5_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM6()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM6_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM7()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM7_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM12()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM12_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM13()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM13_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM14()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM14_STOP))
N#define __HAL_DBGMCU_FREEZE_RTC()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_RTC_STOP))
N#define __HAL_DBGMCU_FREEZE_WWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_WWDG_STOP))
N#define __HAL_DBGMCU_FREEZE_IWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_IWDG_STOP))
N#define __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_FREEZE_CAN1()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN1_STOP))
N#define __HAL_DBGMCU_FREEZE_CAN2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN2_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM1()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM1_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM8()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM8_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM9()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM9_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM10()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM10_STOP))
N#define __HAL_DBGMCU_FREEZE_TIM11()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM11_STOP))
N
N#define __HAL_DBGMCU_UNFREEZE_TIM2()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM2_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM3()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM3_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM4()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM4_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM5()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM5_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM6()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM6_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM7()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM7_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM12()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM12_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM13()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM13_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM14()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM14_STOP))
N#define __HAL_DBGMCU_UNFREEZE_RTC()            (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_RTC_STOP))
N#define __HAL_DBGMCU_UNFREEZE_WWDG()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_WWDG_STOP))
N#define __HAL_DBGMCU_UNFREEZE_IWDG()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_IWDG_STOP))
N#define __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_CAN1()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN1_STOP))
N#define __HAL_DBGMCU_UNFREEZE_CAN2()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN2_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM1()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM1_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM8()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM8_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM9()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM9_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM10()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM10_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM11()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM11_STOP))
N
N/** @brief  Main Flash memory mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_FLASH()             (SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE))
N
N/** @brief  System Flash memory mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
N                                                         SYSCFG->MEMRMP |= SYSCFG_MEMRMP_MEM_MODE_0;\
N                                                        }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                         SYSCFG->MEMRMP |= SYSCFG_MEMRMP_MEM_MODE_0;                                                        }while(0);
N
N/** @brief  Embedded SRAM mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_SRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
N                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_0 | SYSCFG_MEMRMP_MEM_MODE_1);\
N                                                 }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_SRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_0 | SYSCFG_MEMRMP_MEM_MODE_1);                                                 }while(0);
N
N#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)
X#if 0L || 0L || 0L|| 0L
S/** @brief  FSMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FSMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);\
S                                                 }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FSMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                  SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);                                                 }while(0);
N#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
N
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
S/** @brief  FMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                 SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);\
S                                                }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                 SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);                                                }while(0);
S
S/** @brief  FMC/SDRAM Bank 1 and 2 mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
S                                                       SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_2);\
S                                                      }while(0);
X#define __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);                                                       SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_2);                                                      }while(0);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */ 
N
N#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F413xx) || defined(STM32F423xx)
X#if 0L || 0L || 0L || 0L || 0L
S/** @defgroup Cortex_Lockup_Enable Cortex Lockup Enable
S  * @{
S  */
S/** @brief  SYSCFG Break Lockup lock
S  *         Enables and locks the connection of Cortex-M4 LOCKUP (Hardfault) output to TIM1/8 input
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK); \
S                                               SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;    \
S                                              }while(0)
X#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK);                                                SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;                                                  }while(0)
S/**
S * @}
S */
S
S/** @defgroup PVD_Lock_Enable PVD Lock
S  * @{
S  */
S/** @brief  SYSCFG Break PVD lock
S  *         Enables and locks the PVD connection with Timer1/8 Break Input, , as well as the PVDE and PLS[2:0] in the PWR_CR register
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()     do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK); \
S                                                 SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;    \
S                                                }while(0)
X#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()     do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK);                                                  SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;                                                    }while(0)
S/**
S * @}
S */
N#endif /* STM32F410Tx || STM32F410Cx || STM32F410Rx || STM32F413xx || STM32F423xx */
N/**
N  * @}
N  */
N
N/** @defgroup HAL_Private_Macros HAL Private Macros
N  * @{
N  */
N#define IS_TICKFREQ(FREQ) (((FREQ) == HAL_TICK_FREQ_10HZ)  || \
N                           ((FREQ) == HAL_TICK_FREQ_100HZ) || \
N                           ((FREQ) == HAL_TICK_FREQ_1KHZ))
X#define IS_TICKFREQ(FREQ) (((FREQ) == HAL_TICK_FREQ_10HZ)  ||                            ((FREQ) == HAL_TICK_FREQ_100HZ) ||                            ((FREQ) == HAL_TICK_FREQ_1KHZ))
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup HAL_Exported_Functions
N  * @{
N  */
N/** @addtogroup HAL_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and Configuration functions  ******************************/
NHAL_StatusTypeDef HAL_Init(void);
NHAL_StatusTypeDef HAL_DeInit(void);
Nvoid HAL_MspInit(void);
Nvoid HAL_MspDeInit(void);
NHAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority);
N/**
N  * @}
N  */
N
N/** @addtogroup HAL_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions  ************************************************/
Nvoid HAL_IncTick(void);
Nvoid HAL_Delay(uint32_t Delay);
Nuint32_t HAL_GetTick(void);
Nuint32_t HAL_GetTickPrio(void);
NHAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq);
NHAL_TickFreqTypeDef HAL_GetTickFreq(void);
Nvoid HAL_SuspendTick(void);
Nvoid HAL_ResumeTick(void);
Nuint32_t HAL_GetHalVersion(void);
Nuint32_t HAL_GetREVID(void);
Nuint32_t HAL_GetDEVID(void);
Nvoid HAL_DBGMCU_EnableDBGSleepMode(void);
Nvoid HAL_DBGMCU_DisableDBGSleepMode(void);
Nvoid HAL_DBGMCU_EnableDBGStopMode(void);
Nvoid HAL_DBGMCU_DisableDBGStopMode(void);
Nvoid HAL_DBGMCU_EnableDBGStandbyMode(void);
Nvoid HAL_DBGMCU_DisableDBGStandbyMode(void);
Nvoid HAL_EnableCompensationCell(void);
Nvoid HAL_DisableCompensationCell(void);
Nuint32_t HAL_GetUIDw0(void);
Nuint32_t HAL_GetUIDw1(void);
Nuint32_t HAL_GetUIDw2(void);
N#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
N    defined(STM32F469xx) || defined(STM32F479xx)
X#if 0L || 0L || 0L|| 0L ||    0L || 0L
Svoid HAL_EnableMemorySwappingBank(void);
Svoid HAL_DisableMemorySwappingBank(void);
N#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */ 
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Private types -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/** @defgroup HAL_Private_Variables HAL Private Variables
N  * @{
N  */
N/**
N  * @}
N  */
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup HAL_Private_Constants HAL Private Constants
N  * @{
N  */
N/**
N  * @}
N  */
N/* Private macros ------------------------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_HAL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 43 "..\Inc\cube_hal.h" 2
N#include "stm32f4xx_nucleo.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo\stm32f4xx_nucleo.h" 1
N/** 
N  ******************************************************************************
N  * @file    stm32f4xx_nucleo.h
N  * @author  MCD Application Team
N  * @brief   This file contains definitions for:
N  *          - LEDs and push-button available on STM32F4XX-Nucleo Kit 
N  *            from STMicroelectronics
N  *          - LCD, joystick and microSD available on Adafruit 1.8" TFT LCD 
N  *            shield (reference ID 802)
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */ 
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4XX_NUCLEO_H
N#define __STM32F4XX_NUCLEO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx_hal.h"
N   
N/* To be defined only if the board is provided with the related shield */
N/* https://www.adafruit.com/products/802 */
N#define ADAFRUIT_TFT_JOY_SD_ID802
N   
N/** @addtogroup BSP
N  * @{
N  */
N
N/** @addtogroup STM32F4XX_NUCLEO
N  * @{
N  */
N
N/** @addtogroup STM32F4XX_NUCLEO_LOW_LEVEL
N  * @{
N  */ 
N
N/** @defgroup STM32F4XX_NUCLEO_LOW_LEVEL_Exported_Types STM32F4XX NUCLEO LOW LEVEL Exported Types
N  * @{
N  */
Ntypedef enum 
N{
N  LED2 = 0
N}Led_TypeDef;
N
Ntypedef enum 
N{  
N  BUTTON_USER = 0,
N  /* Alias */
N  BUTTON_KEY  = BUTTON_USER
N} Button_TypeDef;
N
Ntypedef enum 
N{  
N  BUTTON_MODE_GPIO = 0,
N  BUTTON_MODE_EXTI = 1
N}ButtonMode_TypeDef;
N
Ntypedef enum 
N{ 
N  JOY_NONE  = 0,
N  JOY_SEL   = 1,
N  JOY_DOWN  = 2,
N  JOY_LEFT  = 3,
N  JOY_RIGHT = 4,
N  JOY_UP    = 5
N}JOYState_TypeDef;
N
N/**
N  * @}
N  */ 
N
N/** @defgroup STM32F4XX_NUCLEO_LOW_LEVEL_Exported_Constants STM32F4XX NUCLEO LOW LEVEL Exported Constants
N  * @{
N  */ 
N
N/** 
N  * @brief Define for STM32F4XX_NUCLEO board  
N  */ 
N#if !defined (USE_STM32F4XX_NUCLEO)
X#if !1L
S #define USE_STM32F4XX_NUCLEO
N#endif
N
N/** @defgroup STM32F4XX_NUCLEO_LOW_LEVEL_LED STM32F4XX NUCLEO LOW LEVEL LED
N  * @{
N  */
N#define LEDn                                    1
N
N#define LED2_PIN                                GPIO_PIN_5
N#define LED2_GPIO_PORT                          GPIOA
N#define LED2_GPIO_CLK_ENABLE()                  __HAL_RCC_GPIOA_CLK_ENABLE()
N#define LED2_GPIO_CLK_DISABLE()                 __HAL_RCC_GPIOA_CLK_DISABLE()  
N
N#define LEDx_GPIO_CLK_ENABLE(__INDEX__)         LED2_GPIO_CLK_ENABLE()
N#define LEDx_GPIO_CLK_DISABLE(__INDEX__)        LED2_GPIO_CLK_DISABLE()
N/**
N  * @}
N  */ 
N  
N/** @defgroup STM32F4XX_NUCLEO_LOW_LEVEL_BUTTON STM32F4XX NUCLEO LOW LEVEL BUTTON
N  * @{
N  */  
N#define BUTTONn                                 1  
N
N/**
N  * @brief Key push-button
N  */
N#define USER_BUTTON_PIN                         GPIO_PIN_13
N#define USER_BUTTON_GPIO_PORT                   GPIOC
N#define USER_BUTTON_GPIO_CLK_ENABLE()           __HAL_RCC_GPIOC_CLK_ENABLE()   
N#define USER_BUTTON_GPIO_CLK_DISABLE()          __HAL_RCC_GPIOC_CLK_DISABLE()  
N#define USER_BUTTON_EXTI_LINE                   GPIO_PIN_13
N#define USER_BUTTON_EXTI_IRQn                   EXTI15_10_IRQn
N
N#define BUTTONx_GPIO_CLK_ENABLE(__INDEX__)       USER_BUTTON_GPIO_CLK_ENABLE()
N#define BUTTONx_GPIO_CLK_DISABLE(__INDEX__)      USER_BUTTON_GPIO_CLK_DISABLE()
N
N/* Aliases */
N#define KEY_BUTTON_PIN                       USER_BUTTON_PIN
N#define KEY_BUTTON_GPIO_PORT                 USER_BUTTON_GPIO_PORT
N#define KEY_BUTTON_GPIO_CLK_ENABLE()         USER_BUTTON_GPIO_CLK_ENABLE()
N#define KEY_BUTTON_GPIO_CLK_DISABLE()        USER_BUTTON_GPIO_CLK_DISABLE()
N#define KEY_BUTTON_EXTI_LINE                 USER_BUTTON_EXTI_LINE
N#define KEY_BUTTON_EXTI_IRQn                 USER_BUTTON_EXTI_IRQn
N
N/**
N  * @}
N  */ 
N
N/** @defgroup STM32F4XX_NUCLEO_LOW_LEVEL_BUS STM32F4XX NUCLEO LOW LEVEL BUS
N  * @{
N  */
N/*############################### SPI1 #######################################*/
N#ifdef HAL_SPI_MODULE_ENABLED
N
N#define NUCLEO_SPIx                                     SPI1
N#define NUCLEO_SPIx_CLK_ENABLE()                        __HAL_RCC_SPI1_CLK_ENABLE()
N
N#define NUCLEO_SPIx_SCK_AF                              GPIO_AF5_SPI1
N#define NUCLEO_SPIx_SCK_GPIO_PORT                       GPIOA
N#define NUCLEO_SPIx_SCK_PIN                             GPIO_PIN_5
N#define NUCLEO_SPIx_SCK_GPIO_CLK_ENABLE()               __HAL_RCC_GPIOA_CLK_ENABLE()
N#define NUCLEO_SPIx_SCK_GPIO_CLK_DISABLE()              __HAL_RCC_GPIOA_CLK_DISABLE()
N
N#define NUCLEO_SPIx_MISO_MOSI_AF                        GPIO_AF5_SPI1
N#define NUCLEO_SPIx_MISO_MOSI_GPIO_PORT                 GPIOA
N#define NUCLEO_SPIx_MISO_MOSI_GPIO_CLK_ENABLE()         __HAL_RCC_GPIOA_CLK_ENABLE()
N#define NUCLEO_SPIx_MISO_MOSI_GPIO_CLK_DISABLE()        __HAL_RCC_GPIOA_CLK_DISABLE()
N#define NUCLEO_SPIx_MISO_PIN                            GPIO_PIN_6
N#define NUCLEO_SPIx_MOSI_PIN                            GPIO_PIN_7
N/* Maximum Timeout values for flags waiting loops. These timeouts are not based
N   on accurate values, they just guarantee that the application will not remain
N   stuck if the SPI communication is corrupted.
N   You may modify these timeout values depending on CPU frequency and application
N   conditions (interrupts routines ...). */   
N#define NUCLEO_SPIx_TIMEOUT_MAX                   1000
N
N/**
N  * @brief  SD Control Lines management
N  */
N#define SD_CS_LOW()       HAL_GPIO_WritePin(SD_CS_GPIO_PORT, SD_CS_PIN, GPIO_PIN_RESET)
N#define SD_CS_HIGH()      HAL_GPIO_WritePin(SD_CS_GPIO_PORT, SD_CS_PIN, GPIO_PIN_SET)
N
N/**
N  * @brief  LCD Control Lines management
N  */
N#define LCD_CS_LOW()      HAL_GPIO_WritePin(LCD_CS_GPIO_PORT, LCD_CS_PIN, GPIO_PIN_RESET)
N#define LCD_CS_HIGH()     HAL_GPIO_WritePin(LCD_CS_GPIO_PORT, LCD_CS_PIN, GPIO_PIN_SET)
N#define LCD_DC_LOW()      HAL_GPIO_WritePin(LCD_DC_GPIO_PORT, LCD_DC_PIN, GPIO_PIN_RESET)
N#define LCD_DC_HIGH()     HAL_GPIO_WritePin(LCD_DC_GPIO_PORT, LCD_DC_PIN, GPIO_PIN_SET)
N     
N/**
N  * @brief  SD Control Interface pins (shield D4)
N  */
N#define SD_CS_PIN                                 GPIO_PIN_5
N#define SD_CS_GPIO_PORT                           GPIOB
N#define SD_CS_GPIO_CLK_ENABLE()                 __HAL_RCC_GPIOB_CLK_ENABLE()
N#define SD_CS_GPIO_CLK_DISABLE()                __HAL_RCC_GPIOB_CLK_DISABLE()
N
N/**
N  * @brief  LCD Control Interface pins (shield D10)
N  */
N#define LCD_CS_PIN                                 GPIO_PIN_6
N#define LCD_CS_GPIO_PORT                           GPIOB
N#define LCD_CS_GPIO_CLK_ENABLE()                 __HAL_RCC_GPIOB_CLK_ENABLE()
N#define LCD_CS_GPIO_CLK_DISABLE()                __HAL_RCC_GPIOB_CLK_DISABLE()
N    
N/**
N  * @brief  LCD Data/Command Interface pins (shield D8)
N  */
N#define LCD_DC_PIN                                 GPIO_PIN_9
N#define LCD_DC_GPIO_PORT                           GPIOA
N#define LCD_DC_GPIO_CLK_ENABLE()                 __HAL_RCC_GPIOA_CLK_ENABLE()
N#define LCD_DC_GPIO_CLK_DISABLE()                __HAL_RCC_GPIOA_CLK_DISABLE()
N
N#endif /* HAL_SPI_MODULE_ENABLED */
N
N/*################################ ADC1 ######################################*/
N/**
N  * @brief  ADC Interface pins
N  *         used to detect motion of Joystick available on Adafruit 1.8" TFT shield
N  */
N  
N#ifdef HAL_ADC_MODULE_ENABLED
N  
N#define NUCLEO_ADCx                                 ADC1
N#define NUCLEO_ADCx_CLK_ENABLE()                  __HAL_RCC_ADC1_CLK_ENABLE()
N#define NUCLEO_ADCx_CLK_DISABLE()                 __HAL_RCC_ADC1_CLK_DISABLE()
N
N#define NUCLEO_ADCx_CHANNEL                       ADC_CHANNEL_8
N   
N#define NUCLEO_ADCx_GPIO_PORT                       GPIOB
N#define NUCLEO_ADCx_GPIO_PIN                        GPIO_PIN_0
N#define NUCLEO_ADCx_GPIO_CLK_ENABLE()             __HAL_RCC_GPIOB_CLK_ENABLE()
N#define NUCLEO_ADCx_GPIO_CLK_DISABLE()            __HAL_RCC_GPIOB_CLK_DISABLE()
N#endif /* HAL_ADC_MODULE_ENABLED */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup STM32F4XX_NUCLEO_LOW_LEVEL_Exported_Macros STM32F4XX NUCLEO LOW LEVEL Exported Macros
N  * @{
N  */  
N/**
N  * @}
N  */ 
N
N/** @defgroup STM32F4XX_NUCLEO_LOW_LEVEL_Exported_Functions STM32F4XX NUCLEO LOW LEVEL Exported Functions
N  * @{
N  */
Nuint32_t         BSP_GetVersion(void);  
Nvoid             BSP_LED_Init(Led_TypeDef Led);
Nvoid             BSP_LED_DeInit(Led_TypeDef Led);
Nvoid             BSP_LED_On(Led_TypeDef Led);
Nvoid             BSP_LED_Off(Led_TypeDef Led);
Nvoid             BSP_LED_Toggle(Led_TypeDef Led);
Nvoid             BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode);
Nvoid             BSP_PB_DeInit(Button_TypeDef Button);
Nuint32_t         BSP_PB_GetState(Button_TypeDef Button);
N#ifdef HAL_ADC_MODULE_ENABLED
Nuint8_t          BSP_JOY_Init(void);
NJOYState_TypeDef BSP_JOY_GetState(void);
Nvoid             BSP_JOY_DeInit(void);
N#endif /* HAL_ADC_MODULE_ENABLED */
N
N  
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4XX_NUCLEO_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 44 "..\Inc\cube_hal.h" 2
N#include "stm32f4xx_hal_conf.h"
N#include "stm32f4xx_hal_def.h"
N#endif
N
N#ifdef USE_STM32L0XX_NUCLEO
S#include "stm32l0xx_hal.h"
S#include "stm32l0xx_nucleo.h"
S#include "stm32l0xx_hal_conf.h"
S#include "stm32l0xx_hal_def.h"
N#endif
N
N#ifdef USE_STM32L1XX_NUCLEO
S#include "stm32l1xx_hal.h"
S#include "stm32l1xx_nucleo.h"
S#include "stm32l1xx_hal_conf.h"
S#include "stm32l1xx_hal_def.h"
N#endif
N
N#ifdef USE_STM32L4XX_NUCLEO
S#include "stm32l4xx_hal.h"
S#include "stm32l4xx_nucleo.h"
S#include "stm32l4xx_hal_conf.h"
S#include "stm32l4xx_hal_def.h"
N#endif
N
N#ifdef USE_STM32F4XX_NUCLEO
N#define USARTx_TX_AF                     GPIO_AF7_USART2
N#define USARTx_RX_AF                     GPIO_AF7_USART2
N
N#define RTC_ASYNCH_PREDIV_LSI  0x7F
N#define RTC_SYNCH_PREDIV_LSI   0xF9
N
N#define RTC_ASYNCH_PREDIV_LSE  0x7F
N#define RTC_SYNCH_PREDIV_LSE   0x00FF
N#endif
N
N#ifdef USE_STM32L0XX_NUCLEO
S#define USARTx_TX_AF                     GPIO_AF4_USART2
S#define USARTx_RX_AF                     GPIO_AF4_USART2
S
S#define RTC_ASYNCH_PREDIV_LSI  0x7F
S#define RTC_SYNCH_PREDIV_LSI   0x0130
S
S#define RTC_ASYNCH_PREDIV_LSE  0x7F
S#define RTC_SYNCH_PREDIV_LSE   0x00FF
N#endif
N
N#ifdef USE_STM32L1XX_NUCLEO
S#define USARTx_TX_AF                     GPIO_AF7_USART2
S#define USARTx_RX_AF                     GPIO_AF7_USART2
S
S#define RTC_ASYNCH_PREDIV_LSI  0x7F
S#define RTC_SYNCH_PREDIV_LSI   0x0130
S
S#define RTC_ASYNCH_PREDIV_LSE  0x7F
S#define RTC_SYNCH_PREDIV_LSE   0x00FF
N#endif
N
N#ifdef USE_STM32L4XX_NUCLEO
S#define USARTx_TX_AF                     GPIO_AF7_USART2
S#define USARTx_RX_AF                     GPIO_AF7_USART2
S
S#define RTC_ASYNCH_PREDIV_LSI  0x7F
S#define RTC_SYNCH_PREDIV_LSI   0xF9
S
S#define RTC_ASYNCH_PREDIV_LSE  0x7F
S#define RTC_SYNCH_PREDIV_LSE   0x00FF
N#endif
N
Nvoid SystemClock_Config(void);
Nuint32_t Get_DMA_Flag_Status(DMA_HandleTypeDef *handle_dma);
Nuint32_t Get_DMA_Counter(DMA_HandleTypeDef *handle_dma);
Nvoid Config_DMA_Handler(DMA_HandleTypeDef *handle_dma);
N
N#endif /* CUBE_HAL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 46 "..\Inc\main.h" 2
N
N#if (defined (USE_STM32F4XX_NUCLEO))
X#if (1L)
N#include "nucleo_f401re_bus.h"
L 1 "..\Inc\nucleo_f401re_bus.h" 1
N/**
N  ******************************************************************************
N  * @file           : nucleo_f401re_bus.h
N  * @brief          : header file for the BSP BUS IO driver
N  ******************************************************************************
N  * This notice applies to any and all portions of this file
N  * that are not between comment pairs USER CODE BEGIN and
N  * USER CODE END. Other portions of this file, whether
N  * inserted by the user or by software development tools
N  * are owned by their respective copyright owners.
N  *
N  * Copyright (c) 2018 STMicroelectronics International N.V.
N  * All rights reserved.
N  *
N  * Redistribution and use in source and binary forms, with or without
N  * modification, are permitted, provided that the following conditions are met:
N  *
N  * 1. Redistribution of source code must retain the above copyright notice,
N  *    this list of conditions and the following disclaimer.
N  * 2. Redistributions in binary form must reproduce the above copyright notice,
N  *    this list of conditions and the following disclaimer in the documentation
N  *    and/or other materials provided with the distribution.
N  * 3. Neither the name of STMicroelectronics nor the names of other
N  *    contributors to this software may be used to endorse or promote products
N  *    derived from this software without specific written permission.
N  * 4. This software, including modifications and/or derivative works of this
N  *    software, must execute solely and exclusively on microcontroller or
N  *    microprocessor devices manufactured by or for STMicroelectronics.
N  * 5. Redistribution and use of this software other than as permitted under
N  *    this license is void and will automatically terminate your rights under
N  *    this license.
N  *
N  * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
N  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
N  * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
N  * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
N  * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N*/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __NUCLEO_F401RE_BUS_H
N#define __NUCLEO_F401RE_BUS_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define USE_HAL_SPI_REGISTER_CALLBACKS 0
N#define USE_HAL_I2C_REGISTER_CALLBACKS 0
N
N#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
X#if (0 == 1)
Stypedef struct
S{
S  pI2C_CallbackTypeDef  pMspI2cInitCb;
S  pI2C_CallbackTypeDef  pMspI2cDeInitCb;
S} BSP_I2C_Cb_t;
N#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 1) */
N
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1)
X#if (0 == 1)
Stypedef struct
S{
S  pSPI_CallbackTypeDef  pMspSpiInitCb;
S  pSPI_CallbackTypeDef  pMspSpiDeInitCb;
S} BSP_SPI_Cb_t;
N#endif /* (USE_HAL_SPI_REGISTER_CALLBACKS == 1) */
N
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N/* BUS IO driver over I2C Peripheral */
Nint32_t BSP_I2C1_Init(void);
Nint32_t BSP_I2C3_Init(void);
Nint32_t BSP_I2C1_DeInit(void);
Nint32_t BSP_I2C1_IsReady(void);
Nint32_t BSP_I2C1_WriteReg(uint16_t Addr, uint16_t Reg, uint8_t *pData, uint16_t len);
Nint32_t BSP_I2C1_ReadReg(uint16_t Addr, uint16_t Reg, uint8_t *pData, uint16_t len);
Nint32_t BSP_I2C1_WriteReg16(uint16_t Addr, uint16_t Reg, uint8_t *pData, uint16_t len);
Nint32_t BSP_I2C1_ReadReg16(uint16_t Addr, uint16_t Reg, uint8_t *pData, uint16_t len);
Nint32_t BSP_I2C1_Send(uint16_t DevAddr, uint8_t *pData, uint16_t Length);
Nint32_t BSP_I2C1_Recv(uint16_t DevAddr, uint8_t *pData, uint16_t Length);
Nint32_t BSP_I2C1_SendRecv(uint16_t DevAddr, uint8_t *pTxdata, uint8_t *pRxdata, uint16_t Length);
N
Nint32_t BSP_GetTick(void);
N
N#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1)
X#if (0 == 1)
Sint32_t BSP_BUS_RegisterDefaultMspCallbacks(void);
Sint32_t BSP_BUS_RegisterMspCallbacks(BSP_BUS_Cb_t *Callbacks);
N#endif /* ((USE_HAL_I2C_REGISTER_CALLBACKS == 1) || (USE_HAL_SPI_REGISTER_CALLBACKS == 1)) */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __NUCLEO_F401RE_BUS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 49 "..\Inc\main.h" 2
N#include "nucleo_f401re_errno.h"
L 1 "..\Inc\nucleo_f401re_errno.h" 1
N/**
N  ******************************************************************************
N  * @file           : nucleo_f401re_errno.h
N  * @brief          : Error Code
N  ******************************************************************************
N  * This notice applies to any and all portions of this file
N  * that are not between comment pairs USER CODE BEGIN and
N  * USER CODE END. Other portions of this file, whether
N  * inserted by the user or by software development tools
N  * are owned by their respective copyright owners.
N  *
N  * Copyright (c) 2018 STMicroelectronics International N.V.
N  * All rights reserved.
N  *
N  * Redistribution and use in source and binary forms, with or without
N  * modification, are permitted, provided that the following conditions are met:
N  *
N  * 1. Redistribution of source code must retain the above copyright notice,
N  *    this list of conditions and the following disclaimer.
N  * 2. Redistributions in binary form must reproduce the above copyright notice,
N  *    this list of conditions and the following disclaimer in the documentation
N  *    and/or other materials provided with the distribution.
N  * 3. Neither the name of STMicroelectronics nor the names of other
N  *    contributors to this software may be used to endorse or promote products
N  *    derived from this software without specific written permission.
N  * 4. This software, including modifications and/or derivative works of this
N  *    software, must execute solely and exclusively on microcontroller or
N  *    microprocessor devices manufactured by or for STMicroelectronics.
N  * 5. Redistribution and use of this software other than as permitted under
N  *    this license is void and will automatically terminate your rights under
N  *    this license.
N  *
N  * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
N  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
N  * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
N  * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
N  * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N*/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __NUCLEO_F401RE_ERRNO_H
N#define __NUCLEO_F401RE_ERRNO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Common Error codes */
N#define BSP_ERROR_NONE                    0
N#define BSP_ERROR_NO_INIT                -1
N#define BSP_ERROR_WRONG_PARAM            -2
N#define BSP_ERROR_BUSY                   -3
N#define BSP_ERROR_PERIPH_FAILURE         -4
N#define BSP_ERROR_COMPONENT_FAILURE      -5
N#define BSP_ERROR_UNKNOWN_FAILURE        -6
N#define BSP_ERROR_UNKNOWN_COMPONENT      -7
N#define BSP_ERROR_BUS_FAILURE            -8
N#define BSP_ERROR_CLOCK_FAILURE          -9
N#define BSP_ERROR_MSP_FAILURE            -10
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __NUCLEO_F401RE_ERRNO_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 50 "..\Inc\main.h" 2
N
N#elif (defined (USE_STM32L0XX_NUCLEO))
S#include "nucleo_l073rz_bus.h"
S#include "nucleo_l073rz_errno.h"
S
S#elif (defined (USE_STM32L1XX_NUCLEO))
S#include "nucleo_l152re_bus.h"
S#include "nucleo_l152re_errno.h"
S
S#elif (defined (USE_STM32L4XX_NUCLEO))
S#include "nucleo_l476rg_bus.h"
S#include "nucleo_l476rg_errno.h"
S
S#else
S#error Not supported platform
N#endif
N
N#if (defined (USE_IKS01A2))
X#if (1L)
N#include "iks01a2_env_sensors.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_env_sensors.h" 1
N/**
N ******************************************************************************
N * @file    iks01a2_env_sensors.h
N * @author  MEMS Software Solutions Team
N * @brief   This file provides a set of functions needed to manage the environmental sensors
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics International N.V.
N * All rights reserved.</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted, provided that the following conditions are met:
N *
N * 1. Redistribution of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. Neither the name of STMicroelectronics nor the names of other
N *    contributors to this software may be used to endorse or promote products
N *    derived from this software without specific written permission.
N * 4. This software, including modifications and/or derivative works of this
N *    software, must execute solely and exclusively on microcontroller or
N *    microprocessor devices manufactured by or for STMicroelectronics.
N * 5. Redistribution and use of this software other than as permitted under
N *    this license is void and will automatically terminate your rights under
N *    this license.
N *
N * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
N * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
N * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
N * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
N * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef IKS01A2_ENV_SENSORS_H
N#define IKS01A2_ENV_SENSORS_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "iks01a2_conf.h"
L 1 "..\Inc\iks01a2_conf.h" 1
N/**
N ******************************************************************************
N * @file    iks01a2_conf.h
N * @author  MEMS Application Team
N * @version V0.0.1
N * @date    29-January-2018
N * @brief   This file contains definitions for the MEMS components bus interfaces
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N#if (defined (USE_STM32F4XX_NUCLEO))
X#if (1L)
N#include "stm32f4xx_hal.h"
N#include "nucleo_f401re_bus.h"
N#include "nucleo_f401re_errno.h"
N
N#elif (defined (USE_STM32L0XX_NUCLEO))
S#include "stm32l0xx_hal.h"
S#include "nucleo_l073rz_bus.h"
S#include "nucleo_l073rz_errno.h"
S
S#elif (defined (USE_STM32L1XX_NUCLEO))
S#include "stm32l1xx_hal.h"
S#include "nucleo_l152re_bus.h"
S#include "nucleo_l152re_errno.h"
S
S#elif (defined (USE_STM32L4XX_NUCLEO))
S#include "stm32l4xx_hal.h"
S#include "nucleo_l476rg_bus.h"
S#include "nucleo_l476rg_errno.h"
S
S#else
S#error Not supported platform
N#endif
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __IKS01A2_CONF_H__
N#define __IKS01A2_CONF_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define USE_IKS01A2_ENV_SENSOR_HTS221_0                1U
N#define USE_IKS01A2_ENV_SENSOR_LPS22HB_0               1U
N
N#define USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0            1U
N#define USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0      1U
N#define USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0      1U
N
N#define IKS01A2_I2C_Init BSP_I2C1_Init
N#define IKS01A2_I2C_DeInit BSP_I2C1_DeInit
N#define IKS01A2_I2C_ReadReg BSP_I2C1_ReadReg
N#define IKS01A2_I2C_WriteReg BSP_I2C1_WriteReg
N#define IKS01A2_GetTick BSP_GetTick
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __IKS01A2_CONF_H__*/
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 56 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_env_sensors.h" 2
N#include "env_sensor.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\Common\env_sensor.h" 1
N/**
N ******************************************************************************
N * @file    env_sensor.h
N * @author  MCD Application Team
N * @brief   This header file contains the functions prototypes for the
N *          temperature driver
N ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef ENV_SENSORS_H
N#define ENV_SENSORS_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup COMPONENTS COMPONENTS
N * @{
N */
N
N/** @addtogroup COMMON COMMON
N * @{
N */
N
N/** @addtogroup ENV_SENSORS ENV_SENSORS
N * @{
N */
N
N/** @addtogroup ENV_SENSORS_Public_Types ENV_SENSORS Public types
N * @{
N */
N
N/**
N * @brief  ENV_SENSORS driver structure definition
N */
Ntypedef struct
N{
N  int32_t ( *Init              ) ( void * );
N  int32_t ( *DeInit            ) ( void * );
N  int32_t ( *ReadID            ) ( void *, uint8_t * ); 
N  int32_t ( *GetCapabilities   ) ( void *, void * );
N} ENV_SENSOR_CommonDrv_t;
N
Ntypedef struct
N{
N  int32_t ( *Enable            ) ( void * );
N  int32_t ( *Disable           ) ( void * );
N  int32_t ( *GetOutputDataRate ) ( void *, float * );
N  int32_t ( *SetOutputDataRate ) ( void *, float );
N  int32_t ( *GetValue          ) ( void *, float * );
N} ENV_SENSOR_FuncDrv_t;
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ENV_SENSORS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 57 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_env_sensors.h" 2
N
N#ifndef USE_IKS01A2_ENV_SENSOR_HTS221_0
S#define USE_IKS01A2_ENV_SENSOR_HTS221_0          1
N#endif
N
N#ifndef USE_IKS01A2_ENV_SENSOR_LPS22HB_0
S#define USE_IKS01A2_ENV_SENSOR_LPS22HB_0         1
N#endif
N
N#ifndef USE_IKS01A2_ENV_SENSOR_LPS33HW_0
N#define USE_IKS01A2_ENV_SENSOR_LPS33HW_0         0
N#endif
N
N#ifndef USE_IKS01A2_ENV_SENSOR_LPS22HH_0
N#define USE_IKS01A2_ENV_SENSOR_LPS22HH_0         0
N#endif
N
N#if (USE_IKS01A2_ENV_SENSOR_LPS22HB_0 == 1)
X#if (1U == 1)
N#include "lps22hb.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lps22hb\lps22hb.h" 1
N/**
N ******************************************************************************
N * @file    lps22hb.h
N * @author  MEMS Software Solutions Team
N * @brief   LPS22HB header driver file
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef LPS22HB_H
N#define LPS22HB_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "lps22hb_reg.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lps22hb\lps22hb_reg.h" 1
N/*
N ******************************************************************************
N * @file    lps22hb_reg.h
N * @author  Sensors Software Solution Team
N * @brief   This file contains all the functions prototypes for the
N *          lps22hb_reg.c driver.
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2019 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright
N *      notice, this list of conditions and the following disclaimer in the
N *      documentation and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its
N *      contributors may be used to endorse or promote products derived from
N *      this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef LPS22HB_REGS_H
N#define LPS22HB_REGS_H
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
N#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 1L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 48 "..\..\..\..\..\..\Drivers\BSP\Components\lps22hb\lps22hb_reg.h" 2
N
N/** @addtogroup LPS22HB
N  * @{
N  *
N  */
N
N/** @defgroup LPS22HB_sensors_common_types
N  * @{
N  *
N  */
N
N#ifndef MEMS_SHARED_TYPES
N#define MEMS_SHARED_TYPES
N
N/**
N  * @defgroup axisXbitXX_t
N  * @brief    These unions are useful to represent different sensors data type.
N  *           These unions are not need by the driver.
N  *
N  *           REMOVING the unions you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
N
Ntypedef union{
N  int16_t i16bit[3];
N  uint8_t u8bit[6];
N} axis3bit16_t;
N
Ntypedef union{
N  int16_t i16bit;
N  uint8_t u8bit[2];
N} axis1bit16_t;
N
Ntypedef union{
N  int32_t i32bit[3];
N  uint8_t u8bit[12];
N} axis3bit32_t;
N
Ntypedef union{
N  int32_t i32bit;
N  uint8_t u8bit[4];
N} axis1bit32_t;
N
N/**
N  * @}
N  *
N  */
N
Ntypedef struct{
N  uint8_t bit0       : 1;
N  uint8_t bit1       : 1;
N  uint8_t bit2       : 1;
N  uint8_t bit3       : 1;
N  uint8_t bit4       : 1;
N  uint8_t bit5       : 1;
N  uint8_t bit6       : 1;
N  uint8_t bit7       : 1;
N} bitwise_t;
N
N#define PROPERTY_DISABLE                (0U)
N#define PROPERTY_ENABLE                 (1U)
N
N#endif /* MEMS_SHARED_TYPES */
N
N/**
N  * @}
N  *
N  */
N
N/** @addtogroup  LPS22HB_Interfaces_Functions
N  * @brief       This section provide a set of functions used to read and
N  *              write a generic register of the device.
N  *              MANDATORY: return 0 -> no Error.
N  * @{
N  *
N  */
N
Ntypedef int32_t (*lps22hb_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);
Ntypedef int32_t (*lps22hb_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);
N
Ntypedef struct {
N  /** Component mandatory fields **/
N  lps22hb_write_ptr  write_reg;
N  lps22hb_read_ptr   read_reg;
N  /** Customizable optional pointer **/
N  void *handle;
N} lps22hb_ctx_t;
N
N/**
N  * @}
N  *
N  */
N
N
N/** @defgroup LSM9DS1_Infos
N  * @{
N  *
N  */
N
N  /** I2C Device Address 8 bit format: if SA0=0 -> 0xB9 if SA0=1 -> 0xBB **/
N#define LPS22HB_I2C_ADD_H   0xBBU
N#define LPS22HB_I2C_ADD_L   0xB9U
N
N/** Device Identification (Who am I) **/
N#define LPS22HB_ID            0xB1U
N
N/**
N  * @}
N  *
N  */
N
N#define LPS22HB_INTERRUPT_CFG  0x0BU
Ntypedef struct {
N  uint8_t pe               : 2; /* ple + phe -> pe */
N  uint8_t lir              : 1;
N  uint8_t diff_en          : 1;
N  uint8_t reset_az         : 1;
N  uint8_t autozero         : 1;
N  uint8_t reset_arp        : 1;
N  uint8_t autorifp         : 1;
N} lps22hb_interrupt_cfg_t;
N
N#define LPS22HB_THS_P_L        0x0CU
N#define LPS22HB_THS_P_H        0x0DU
N#define LPS22HB_WHO_AM_I       0x0FU
N#define LPS22HB_CTRL_REG1      0x10U
Ntypedef struct {
N  uint8_t sim              : 1;
N  uint8_t bdu              : 1;
N  uint8_t lpfp             : 2; /* en_lpfp + lpfp_cfg -> lpfp */
N  uint8_t odr              : 3;
N  uint8_t not_used_01      : 1;
N} lps22hb_ctrl_reg1_t;
N
N#define LPS22HB_CTRL_REG2      0x11U
Ntypedef struct {
N  uint8_t one_shot         : 1;
N  uint8_t not_used_01      : 1;
N  uint8_t swreset          : 1;
N  uint8_t i2c_dis          : 1;
N  uint8_t if_add_inc       : 1;
N  uint8_t stop_on_fth      : 1;
N  uint8_t fifo_en          : 1;
N  uint8_t boot             : 1;
N} lps22hb_ctrl_reg2_t;
N
N#define LPS22HB_CTRL_REG3      0x12U
Ntypedef struct {
N  uint8_t int_s            : 2;
N  uint8_t drdy             : 1;
N  uint8_t f_ovr            : 1;
N  uint8_t f_fth            : 1;
N  uint8_t f_fss5           : 1;
N  uint8_t pp_od            : 1;
N  uint8_t int_h_l          : 1;
N} lps22hb_ctrl_reg3_t;
N
N
N#define LPS22HB_FIFO_CTRL      0x14U
Ntypedef struct {
N  uint8_t wtm              : 5;
N  uint8_t f_mode           : 3;
N} lps22hb_fifo_ctrl_t;
N
N#define LPS22HB_REF_P_XL       0x15U
N#define LPS22HB_REF_P_L        0x16U
N#define LPS22HB_REF_P_H        0x17U
N#define LPS22HB_RPDS_L         0x18U
N#define LPS22HB_RPDS_H         0x19U
N
N#define LPS22HB_RES_CONF       0x1AU
Ntypedef struct {
N  uint8_t lc_en            : 1;
N  uint8_t not_used_01      : 7;
N} lps22hb_res_conf_t;
N
N#define LPS22HB_INT_SOURCE     0x25U
Ntypedef struct {
N  uint8_t ph               : 1;
N  uint8_t pl               : 1;
N  uint8_t ia               : 1;
N  uint8_t not_used_01      : 4;
N  uint8_t boot_status      : 1;
N} lps22hb_int_source_t;
N
N#define LPS22HB_FIFO_STATUS    0x26U
Ntypedef struct {
N  uint8_t fss              : 6;
N  uint8_t ovr              : 1;
N  uint8_t fth_fifo         : 1;
N} lps22hb_fifo_status_t;
N
N#define LPS22HB_STATUS         0x27U
Ntypedef struct {
N  uint8_t p_da             : 1;
N  uint8_t t_da             : 1;
N  uint8_t not_used_02      : 2;
N  uint8_t p_or             : 1;
N  uint8_t t_or             : 1;
N  uint8_t not_used_01      : 2;
N} lps22hb_status_t;
N
N#define LPS22HB_PRESS_OUT_XL   0x28U
N#define LPS22HB_PRESS_OUT_L    0x29U
N#define LPS22HB_PRESS_OUT_H    0x2AU
N#define LPS22HB_TEMP_OUT_L     0x2BU
N#define LPS22HB_TEMP_OUT_H     0x2CU
N#define LPS22HB_LPFP_RES       0x33U
N
N/**
N  * @defgroup LPS22HB_Register_Union
N  * @brief    This union group all the registers that has a bit-field
N  *           description.
N  *           This union is useful but not need by the driver.
N  *
N  *           REMOVING this union you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
N
Ntypedef union{
N  lps22hb_interrupt_cfg_t      interrupt_cfg;
N  lps22hb_ctrl_reg1_t          ctrl_reg1;
N  lps22hb_ctrl_reg2_t          ctrl_reg2;
N  lps22hb_ctrl_reg3_t          ctrl_reg3;
N  lps22hb_fifo_ctrl_t          fifo_ctrl;
N  lps22hb_res_conf_t           res_conf;
N  lps22hb_int_source_t         int_source;
N  lps22hb_fifo_status_t        fifo_status;
N  lps22hb_status_t             status;
N  bitwise_t                    bitwise;
N  uint8_t                      byte;
N} lps22hb_reg_t;
N
N/**
N  * @}
N  *
N  */
N
Nint32_t lps22hb_read_reg(lps22hb_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                         uint16_t len);
Nint32_t lps22hb_write_reg(lps22hb_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                          uint16_t len);
N
Nextern float_t lps22hb_from_lsb_to_hpa(int32_t lsb);
Nextern float_t lps22hb_from_lsb_to_degc(int16_t lsb);
N
Nint32_t lps22hb_autozero_rst_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_autozero_rst_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_autozero_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_autozero_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_pressure_snap_rst_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_pressure_snap_rst_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_pressure_snap_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_pressure_snap_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_block_data_update_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_block_data_update_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LPS22HB_LPF_ODR_DIV_2  = 0,
N  LPS22HB_LPF_ODR_DIV_9  = 2,
N  LPS22HB_LPF_ODR_DIV_20 = 3,
N} lps22hb_lpfp_t;
Nint32_t lps22hb_low_pass_filter_mode_set(lps22hb_ctx_t *ctx,
N                                         lps22hb_lpfp_t val);
Nint32_t lps22hb_low_pass_filter_mode_get(lps22hb_ctx_t *ctx,
N                                         lps22hb_lpfp_t *val);
N
Ntypedef enum {
N  LPS22HB_POWER_DOWN  = 0,
N  LPS22HB_ODR_1_Hz    = 1,
N  LPS22HB_ODR_10_Hz   = 2,
N  LPS22HB_ODR_25_Hz   = 3,
N  LPS22HB_ODR_50_Hz   = 4,
N  LPS22HB_ODR_75_Hz   = 5,
N} lps22hb_odr_t;
Nint32_t lps22hb_data_rate_set(lps22hb_ctx_t *ctx, lps22hb_odr_t val);
Nint32_t lps22hb_data_rate_get(lps22hb_ctx_t *ctx, lps22hb_odr_t *val);
N
Nint32_t lps22hb_one_shoot_trigger_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_one_shoot_trigger_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_pressure_ref_set(lps22hb_ctx_t *ctx, uint8_t *buff);
Nint32_t lps22hb_pressure_ref_get(lps22hb_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lps22hb_pressure_offset_set(lps22hb_ctx_t *ctx, uint8_t *buff);
Nint32_t lps22hb_pressure_offset_get(lps22hb_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lps22hb_press_data_ready_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_temp_data_ready_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_press_data_ovr_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_temp_data_ovr_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_pressure_raw_get(lps22hb_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lps22hb_temperature_raw_get(lps22hb_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lps22hb_low_pass_rst_get(lps22hb_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lps22hb_device_id_get(lps22hb_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lps22hb_reset_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_reset_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_boot_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_boot_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_low_power_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_low_power_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_boot_status_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Ntypedef struct{
N  lps22hb_fifo_status_t  fifo_status;
N  lps22hb_status_t       status;
N} lps22hb_dev_stat_t;
Nint32_t lps22hb_dev_status_get(lps22hb_ctx_t *ctx, lps22hb_dev_stat_t *val);
N
Ntypedef enum {
N  LPS22HB_NO_THRESHOLD = 0,
N  LPS22HB_POSITIVE     = 1,
N  LPS22HB_NEGATIVE     = 2,
N  LPS22HB_BOTH         = 3,
N} lps22hb_pe_t;
Nint32_t lps22hb_sign_of_int_threshold_set(lps22hb_ctx_t *ctx,
N                                          lps22hb_pe_t val);
Nint32_t lps22hb_sign_of_int_threshold_get(lps22hb_ctx_t *ctx,
N                                          lps22hb_pe_t *val);
N
Ntypedef enum {
N  LPS22HB_INT_PULSED  = 0,
N  LPS22HB_INT_LATCHED = 1,
N} lps22hb_lir_t;
Nint32_t lps22hb_int_notification_mode_set(lps22hb_ctx_t *ctx,
N                                          lps22hb_lir_t val);
Nint32_t lps22hb_int_notification_mode_get(lps22hb_ctx_t *ctx,
N                                          lps22hb_lir_t *val);
N
Nint32_t lps22hb_int_generation_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_int_generation_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_int_threshold_set(lps22hb_ctx_t *ctx, uint8_t *buff);
Nint32_t lps22hb_int_threshold_get(lps22hb_ctx_t *ctx, uint8_t *buff);
N
Ntypedef enum {
N  LPS22HB_DRDY_OR_FIFO_FLAGS = 0,
N  LPS22HB_HIGH_PRES_INT      = 1,
N  LPS22HB_LOW_PRES_INT       = 2,
N  LPS22HB_EVERY_PRES_INT     = 3,
N} lps22hb_int_s_t;
Nint32_t lps22hb_int_pin_mode_set(lps22hb_ctx_t *ctx, lps22hb_int_s_t val);
Nint32_t lps22hb_int_pin_mode_get(lps22hb_ctx_t *ctx, lps22hb_int_s_t *val);
N
Nint32_t lps22hb_drdy_on_int_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_drdy_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_fifo_ovr_on_int_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_fifo_ovr_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_fifo_threshold_on_int_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_fifo_threshold_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_fifo_full_on_int_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_fifo_full_on_int_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LPS22HB_PUSH_PULL  = 0,
N  LPS22HB_OPEN_DRAIN = 1,
N} lps22hb_pp_od_t;
Nint32_t lps22hb_pin_mode_set(lps22hb_ctx_t *ctx, lps22hb_pp_od_t val);
Nint32_t lps22hb_pin_mode_get(lps22hb_ctx_t *ctx, lps22hb_pp_od_t *val);
N
Ntypedef enum {
N  LPS22HB_ACTIVE_HIGH = 0,
N  LPS22HB_ACTIVE_LOW = 1,
N} lps22hb_int_h_l_t;
Nint32_t lps22hb_int_polarity_set(lps22hb_ctx_t *ctx, lps22hb_int_h_l_t val);
Nint32_t lps22hb_int_polarity_get(lps22hb_ctx_t *ctx, lps22hb_int_h_l_t *val);
N
Nint32_t lps22hb_int_source_get(lps22hb_ctx_t *ctx, lps22hb_int_source_t *val);
N
Nint32_t lps22hb_int_on_press_high_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_int_on_press_low_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_interrupt_event_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_stop_on_fifo_threshold_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_stop_on_fifo_threshold_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_fifo_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_fifo_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_fifo_watermark_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_fifo_watermark_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LPS22HB_BYPASS_MODE           = 0,
N  LPS22HB_FIFO_MODE             = 1,
N  LPS22HB_STREAM_MODE           = 2,
N  LPS22HB_STREAM_TO_FIFO_MODE   = 3,
N  LPS22HB_BYPASS_TO_STREAM_MODE = 4,
N  LPS22HB_DYNAMIC_STREAM_MODE   = 6,
N  LPS22HB_BYPASS_TO_FIFO_MODE   = 7,
N} lps22hb_f_mode_t;
Nint32_t lps22hb_fifo_mode_set(lps22hb_ctx_t *ctx, lps22hb_f_mode_t val);
Nint32_t lps22hb_fifo_mode_get(lps22hb_ctx_t *ctx, lps22hb_f_mode_t *val);
N
Nint32_t lps22hb_fifo_data_level_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_fifo_ovr_flag_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Nint32_t lps22hb_fifo_fth_flag_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LPS22HB_SPI_4_WIRE = 0,
N  LPS22HB_SPI_3_WIRE = 1,
N} lps22hb_sim_t;
Nint32_t lps22hb_spi_mode_set(lps22hb_ctx_t *ctx, lps22hb_sim_t val);
Nint32_t lps22hb_spi_mode_get(lps22hb_ctx_t *ctx, lps22hb_sim_t *val);
N
Ntypedef enum {
N  LPS22HB_I2C_ENABLE = 0,
N  LPS22HB_I2C_DISABLE = 1,
N} lps22hb_i2c_dis_t;
Nint32_t lps22hb_i2c_interface_set(lps22hb_ctx_t *ctx, lps22hb_i2c_dis_t val);
Nint32_t lps22hb_i2c_interface_get(lps22hb_ctx_t *ctx, lps22hb_i2c_dis_t *val);
N
Nint32_t lps22hb_auto_add_inc_set(lps22hb_ctx_t *ctx, uint8_t val);
Nint32_t lps22hb_auto_add_inc_get(lps22hb_ctx_t *ctx, uint8_t *val);
N
N/**
N  *@}
N  *
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LPS22HB_REGS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "..\..\..\..\..\..\Drivers\BSP\Components\lps22hb\lps22hb.h" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 48 "..\..\..\..\..\..\Drivers\BSP\Components\lps22hb\lps22hb.h" 2
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup Component Component
N * @{
N */
N
N/** @addtogroup LPS22HB LPS22HB
N * @{
N */
N
N/** @defgroup LPS22HB_Exported_Types LPS22HB Exported Types
N * @{
N */
N
Ntypedef int32_t (*LPS22HB_Init_Func)(void);
Ntypedef int32_t (*LPS22HB_DeInit_Func)(void);
Ntypedef int32_t (*LPS22HB_GetTick_Func)(void);
Ntypedef int32_t (*LPS22HB_WriteReg_Func)(uint16_t, uint16_t, uint8_t *, uint16_t);
Ntypedef int32_t (*LPS22HB_ReadReg_Func)(uint16_t, uint16_t, uint8_t *, uint16_t);
N
Ntypedef struct
N{
N  LPS22HB_Init_Func          Init;
N  LPS22HB_DeInit_Func        DeInit;
N  uint32_t                   BusType; /*0 means I2C, 1 means SPI 4-Wires, 2 means SPI-3-Wires */
N  uint8_t                    Address;
N  LPS22HB_WriteReg_Func      WriteReg;
N  LPS22HB_ReadReg_Func       ReadReg;
N  LPS22HB_GetTick_Func       GetTick;
N} LPS22HB_IO_t;
N
Ntypedef struct
N{
N  LPS22HB_IO_t        IO;
N  lps22hb_ctx_t       Ctx;
N  uint8_t             is_initialized;
N  uint8_t             press_is_enabled;
N  uint8_t             temp_is_enabled;
N  lps22hb_odr_t       last_odr;
N} LPS22HB_Object_t;
N
Ntypedef struct
N{
N  uint8_t Temperature;
N  uint8_t Pressure;
N  uint8_t Humidity;
N  uint8_t LowPower;
N  float   HumMaxOdr;
N  float   TempMaxOdr;
N  float   PressMaxOdr;
N} LPS22HB_Capabilities_t;
N
Ntypedef struct
N{
N  int32_t (*Init)(LPS22HB_Object_t *);
N  int32_t (*DeInit)(LPS22HB_Object_t *);
N  int32_t (*ReadID)(LPS22HB_Object_t *, uint8_t *);
N  int32_t (*GetCapabilities)(LPS22HB_Object_t *, LPS22HB_Capabilities_t *);
N} LPS22HB_CommonDrv_t;
N
Ntypedef struct
N{
N  int32_t (*Enable)(LPS22HB_Object_t *);
N  int32_t (*Disable)(LPS22HB_Object_t *);
N  int32_t (*GetOutputDataRate)(LPS22HB_Object_t *, float *);
N  int32_t (*SetOutputDataRate)(LPS22HB_Object_t *, float);
N  int32_t (*GetTemperature)(LPS22HB_Object_t *, float *);
N} LPS22HB_TEMP_Drv_t;
N
Ntypedef struct
N{
N  int32_t (*Enable)(LPS22HB_Object_t *);
N  int32_t (*Disable)(LPS22HB_Object_t *);
N  int32_t (*GetOutputDataRate)(LPS22HB_Object_t *, float *);
N  int32_t (*SetOutputDataRate)(LPS22HB_Object_t *, float);
N  int32_t (*GetPressure)(LPS22HB_Object_t *, float *);
N} LPS22HB_PRESS_Drv_t;
N
Ntypedef enum
N{
N  LPS22HB_FIFO_BYPASS_MODE                    = (uint8_t)0x00,    /*!< The FIFO is disabled and empty. The pressure is read directly*/
N  LPS22HB_FIFO_FIFO_MODE                      = (uint8_t)0x20,    /*!< Stops collecting data when full */
N  LPS22HB_FIFO_STREAM_MODE                    = (uint8_t)0x40,    /*!< Keep the newest measurements in the FIFO*/
N  LPS22HB_FIFO_TRIGGER_STREAMTOFIFO_MODE      = (uint8_t)0x60,    /*!< STREAM MODE until trigger deasserted, then change to FIFO MODE*/
N  LPS22HB_FIFO_TRIGGER_BYPASSTOSTREAM_MODE    = (uint8_t)0x80,    /*!< BYPASS MODE until trigger deasserted, then STREAM MODE*/
N  LPS22HB_FIFO_TRIGGER_BYPASSTOFIFO_MODE      = (uint8_t)0xE0     /*!< BYPASS mode until trigger deasserted, then FIFO MODE*/
N} LPS22HB_FifoMode;
N
N/**
N * @}
N */
N
N/** @defgroup LPS22HB_Exported_Constants LPS22HB Exported Constants
N * @{
N */
N
N#define LPS22HB_OK                0
N#define LPS22HB_ERROR            -1
N
N#define LPS22HB_I2C_BUS          0U
N#define LPS22HB_SPI_4WIRES_BUS   1U
N#define LPS22HB_SPI_3WIRES_BUS   2U
N
N#define LPS22HB_FIFO_FULL        (uint8_t)0x20
N
N/**
N * @}
N */
N
N/** @addtogroup LPS22HB_Exported_Functions LPS22HB Exported Functions
N * @{
N */
N
Nint32_t LPS22HB_RegisterBusIO(LPS22HB_Object_t *pObj, LPS22HB_IO_t *pIO);
Nint32_t LPS22HB_Init(LPS22HB_Object_t *pObj);
Nint32_t LPS22HB_DeInit(LPS22HB_Object_t *pObj);
Nint32_t LPS22HB_ReadID(LPS22HB_Object_t *pObj, uint8_t *Id);
Nint32_t LPS22HB_GetCapabilities(LPS22HB_Object_t *pObj, LPS22HB_Capabilities_t *Capabilities);
Nint32_t LPS22HB_Get_Init_Status(LPS22HB_Object_t *pObj, uint8_t *Status);
N
Nint32_t LPS22HB_PRESS_Enable(LPS22HB_Object_t *pObj);
Nint32_t LPS22HB_PRESS_Disable(LPS22HB_Object_t *pObj);
Nint32_t LPS22HB_PRESS_GetOutputDataRate(LPS22HB_Object_t *pObj, float *Odr);
Nint32_t LPS22HB_PRESS_SetOutputDataRate(LPS22HB_Object_t *pObj, float Odr);
Nint32_t LPS22HB_PRESS_GetPressure(LPS22HB_Object_t *pObj, float *Value);
Nint32_t LPS22HB_PRESS_Get_DRDY_Status(LPS22HB_Object_t *pObj, uint8_t *Status);
Nint32_t LPS22HB_PRESS_Get_FThStatus(LPS22HB_Object_t *pObj, uint8_t *Status);
N
Nint32_t LPS22HB_TEMP_Enable(LPS22HB_Object_t *pObj);
Nint32_t LPS22HB_TEMP_Disable(LPS22HB_Object_t *pObj);
Nint32_t LPS22HB_TEMP_GetOutputDataRate(LPS22HB_Object_t *pObj, float *Odr);
Nint32_t LPS22HB_TEMP_SetOutputDataRate(LPS22HB_Object_t *pObj, float Odr);
Nint32_t LPS22HB_TEMP_GetTemperature(LPS22HB_Object_t *pObj, float *Value);
Nint32_t LPS22HB_TEMP_Get_DRDY_Status(LPS22HB_Object_t *pObj, uint8_t *Status);
N
Nint32_t LPS22HB_FIFO_Get_Data(LPS22HB_Object_t *pObj, float *Press, float *Temp);
Nint32_t LPS22HB_FIFO_Get_FTh_Status(LPS22HB_Object_t *pObj, uint8_t *Status);
Nint32_t LPS22HB_FIFO_Get_Full_Status(LPS22HB_Object_t *pObj, uint8_t *Status);
Nint32_t LPS22HB_FIFO_Get_Level(LPS22HB_Object_t *pObj, uint8_t *Status);
Nint32_t LPS22HB_FIFO_Get_Ovr_Status(LPS22HB_Object_t *pObj, uint8_t *Status);
Nint32_t LPS22HB_FIFO_Reset_Interrupt(LPS22HB_Object_t *pObj, uint8_t interrupt);
Nint32_t LPS22HB_FIFO_Set_Interrupt(LPS22HB_Object_t *pObj, uint8_t interrupt);
Nint32_t LPS22HB_FIFO_Set_Mode(LPS22HB_Object_t *pObj, uint8_t Mode);
Nint32_t LPS22HB_FIFO_Set_Watermark_Level(LPS22HB_Object_t *pObj, uint8_t Watermark);
Nint32_t LPS22HB_FIFO_Usage(LPS22HB_Object_t *pObj, uint8_t Status);
N
N
Nint32_t LPS22HB_Read_Reg(LPS22HB_Object_t *pObj, uint8_t reg, uint8_t *Data);
Nint32_t LPS22HB_Write_Reg(LPS22HB_Object_t *pObj, uint8_t reg, uint8_t Data);
N
Nint32_t LPS22HB_Get_Press(LPS22HB_Object_t *pObj, float *Data);
Nint32_t LPS22HB_Get_Temp(LPS22HB_Object_t *pObj, float *Data);
N
Nint32_t LPS22HB_Set_One_Shot(LPS22HB_Object_t *pObj);
Nint32_t LPS22HB_Get_One_Shot_Status(LPS22HB_Object_t *pObj, uint8_t *Status);
N
N/**
N * @}
N */
N
N/** @addtogroup LPS22HB_Exported_Variables LPS22HB Exported Variables
N * @{
N */
Nextern LPS22HB_CommonDrv_t LPS22HB_COMMON_Driver;
Nextern LPS22HB_PRESS_Drv_t LPS22HB_PRESS_Driver;
Nextern LPS22HB_TEMP_Drv_t LPS22HB_TEMP_Driver;
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 76 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_env_sensors.h" 2
N#endif
N
N#if (USE_IKS01A2_ENV_SENSOR_HTS221_0 == 1)
X#if (1U == 1)
N#include "hts221.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\hts221\hts221.h" 1
N/**
N ******************************************************************************
N * @file    hts221.h
N * @author  MEMS Software Solutions Team
N * @brief   HTS221 header driver file 
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef HTS221_H
N#define HTS221_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "hts221_reg.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\hts221\hts221_reg.h" 1
N/*
N ******************************************************************************
N * @file    hts221_reg.h
N * @author  MEMS Software Solution Team
N * @brief   This file contains all the functions prototypes for the
N *          hts221_reg.c driver.
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright
N *      notice, this list of conditions and the following disclaimer in the
N *      documentation and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its
N *      contributors may be used to endorse or promote products derived from
N *      this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef HTS221_REGS_H
N#define HTS221_REGS_H
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include <math.h>
N
N/** @addtogroup HTS221
N  * @{
N  *
N  */
N
N/** @defgroup HTS221_sensors_common_types
N  * @{
N  *
N  */
N
N#ifndef MEMS_SHARED_TYPES
S#define MEMS_SHARED_TYPES
S
S/**
S  * @defgroup axisXbitXX_t
S  * @brief    These unions are useful to represent different sensors data type.
S  *           These unions are not need by the driver.
S  *
S  *           REMOVING the unions you are compliant with:
S  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
S  *
S  * @{
S  *
S  */
S
Stypedef union{
S  int16_t i16bit[3];
S  uint8_t u8bit[6];
S} axis3bit16_t;
S
Stypedef union{
S  int16_t i16bit;
S  uint8_t u8bit[2];
S} axis1bit16_t;
S
Stypedef union{
S  int32_t i32bit[3];
S  uint8_t u8bit[12];
S} axis3bit32_t;
S
Stypedef union{
S  int32_t i32bit;
S  uint8_t u8bit[4];
S} axis1bit32_t;
S
S/**
S  * @}
S  *
S  */
S
Stypedef struct{
S  uint8_t bit0       : 1;
S  uint8_t bit1       : 1;
S  uint8_t bit2       : 1;
S  uint8_t bit3       : 1;
S  uint8_t bit4       : 1;
S  uint8_t bit5       : 1;
S  uint8_t bit6       : 1;
S  uint8_t bit7       : 1;
S} bitwise_t;
S
S#define PROPERTY_DISABLE                (0U)
S#define PROPERTY_ENABLE                 (1U)
S
N#endif /* MEMS_SHARED_TYPES */
N
N/**
N  * @}
N  *
N  */
N
N/** @addtogroup  HTS221_Interfaces_Functions
N  * @brief       This section provide a set of functions used to read and
N  *              write a generic register of the device.
N  *              MANDATORY: return 0 -> no Error.
N  * @{
N  *
N  */
N
Ntypedef int32_t (*hts221_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);
Ntypedef int32_t (*hts221_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);
N
Ntypedef struct {
N  /** Component mandatory fields **/
N  hts221_write_ptr  write_reg;
N  hts221_read_ptr   read_reg;
N  /** Customizable optional pointer **/
N  void *handle;
N} hts221_ctx_t;
N
N/**
N  * @}
N  *
N  */
N
N/** @defgroup HTS221_Infos
N  * @{
N  *
N  */
N
N/** I2C Device Address 8 bit format  **/
N#define HTS221_I2C_ADDRESS         0xBFU
N
N/** Device Identification (Who am I) **/
N#define HTS221_ID                  0xBCU
N
N/**
N  * @}
N  *
N  */
N
N#define HTS221_WHO_AM_I            0x0FU
N#define HTS221_AV_CONF             0x10U
Ntypedef struct {
N  uint8_t avgh                 : 3;
N  uint8_t avgt                 : 3;
N  uint8_t not_used_01          : 2;
N} hts221_av_conf_t;
N
N#define HTS221_CTRL_REG1           0x20U
Ntypedef struct {
N  uint8_t odr                  : 2;
N  uint8_t bdu                  : 1;
N  uint8_t not_used_01          : 4;
N  uint8_t pd                   : 1;
N} hts221_ctrl_reg1_t;
N
N#define HTS221_CTRL_REG2           0x21U
Ntypedef struct {
N  uint8_t one_shot             : 1;
N  uint8_t heater               : 1;
N  uint8_t not_used_01          : 5;
N  uint8_t boot                 : 1;
N} hts221_ctrl_reg2_t;
N
N#define HTS221_CTRL_REG3           0x22U
Ntypedef struct {
N  uint8_t not_used_01          : 2;
N  uint8_t drdy                 : 1;
N  uint8_t not_used_02          : 3;
N  uint8_t pp_od                : 1;
N  uint8_t drdy_h_l             : 1;
N} hts221_ctrl_reg3_t;
N
N#define HTS221_STATUS_REG          0x27U
Ntypedef struct {
N  uint8_t t_da                 : 1;
N  uint8_t h_da                 : 1;
N  uint8_t not_used_01          : 6;
N} hts221_status_reg_t;
N
N#define HTS221_HUMIDITY_OUT_L      0x28U
N#define HTS221_HUMIDITY_OUT_H      0x29U
N#define HTS221_TEMP_OUT_L          0x2AU
N#define HTS221_TEMP_OUT_H          0x2BU
N#define HTS221_H0_RH_X2            0x30U
N#define HTS221_H1_RH_X2            0x31U
N#define HTS221_T0_DEGC_X8          0x32U
N#define HTS221_T1_DEGC_X8          0x33U
N#define HTS221_T1_T0_MSB           0x35U
Ntypedef struct {
N  uint8_t t0_msb               : 2;
N  uint8_t t1_msb               : 2;
N  uint8_t not_used_01          : 4;
N} hts221_t1_t0_msb_t;
N
N#define HTS221_H0_T0_OUT_L         0x36U
N#define HTS221_H0_T0_OUT_H         0x37U
N#define HTS221_H1_T0_OUT_L         0x3AU
N#define HTS221_H1_T0_OUT_H         0x3BU
N#define HTS221_T0_OUT_L            0x3CU
N#define HTS221_T0_OUT_H            0x3DU
N#define HTS221_T1_OUT_L            0x3EU
N#define HTS221_T1_OUT_H            0x3FU
N
N/**
N  * @defgroup HTS221_Register_Union
N  * @brief    This union group all the registers that has a bitfield
N  *           description.
N  *           This union is useful but not need by the driver.
N  *
N  *           REMOVING this union you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
Ntypedef union{
N  hts221_av_conf_t        av_conf;
N  hts221_ctrl_reg1_t      ctrl_reg1;
N  hts221_ctrl_reg2_t      ctrl_reg2;
N  hts221_ctrl_reg3_t      ctrl_reg3;
N  hts221_status_reg_t     status_reg;
N  hts221_t1_t0_msb_t      t1_t0_msb;
N  bitwise_t               bitwise;
N  uint8_t                 byte;
N} hts221_reg_t;
N
N/**
N  * @}
N  *
N  */
N
Nint32_t hts221_read_reg(hts221_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                        uint16_t len);
Nint32_t hts221_write_reg(hts221_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                         uint16_t len);
N
Ntypedef enum {
N  HTS221_H_AVG_4    = 0,
N  HTS221_H_AVG_8    = 1,
N  HTS221_H_AVG_16   = 2,
N  HTS221_H_AVG_32   = 3,
N  HTS221_H_AVG_64   = 4,
N  HTS221_H_AVG_128  = 5,
N  HTS221_H_AVG_256  = 6,
N  HTS221_H_AVG_512  = 7,
N  HTS221_H_AVG_ND   = 8,
N} hts221_avgh_t;
Nint32_t hts221_humidity_avg_set(hts221_ctx_t *ctx, hts221_avgh_t val);
Nint32_t hts221_humidity_avg_get(hts221_ctx_t *ctx, hts221_avgh_t *val);
N
Ntypedef enum {
N  HTS221_T_AVG_2   = 0,
N  HTS221_T_AVG_4   = 1,
N  HTS221_T_AVG_8   = 2,
N  HTS221_T_AVG_16  = 3,
N  HTS221_T_AVG_32  = 4,
N  HTS221_T_AVG_64  = 5,
N  HTS221_T_AVG_128 = 6,
N  HTS221_T_AVG_256 = 7,
N  HTS221_T_AVG_ND  = 8,
N} hts221_avgt_t;
Nint32_t hts221_temperature_avg_set(hts221_ctx_t *ctx, hts221_avgt_t val);
Nint32_t hts221_temperature_avg_get(hts221_ctx_t *ctx, hts221_avgt_t *val);
N
Ntypedef enum {
N  HTS221_ONE_SHOT  = 0,
N  HTS221_ODR_1Hz   = 1,
N  HTS221_ODR_7Hz   = 2,
N  HTS221_ODR_12Hz5 = 3,
N  HTS221_ODR_ND    = 4,
N} hts221_odr_t;
Nint32_t hts221_data_rate_set(hts221_ctx_t *ctx, hts221_odr_t val);
Nint32_t hts221_data_rate_get(hts221_ctx_t *ctx, hts221_odr_t *val);
N
Nint32_t hts221_block_data_update_set(hts221_ctx_t *ctx, uint8_t val);
Nint32_t hts221_block_data_update_get(hts221_ctx_t *ctx, uint8_t *val);
N
Nint32_t hts221_one_shoot_trigger_set(hts221_ctx_t *ctx, uint8_t val);
Nint32_t hts221_one_shoot_trigger_get(hts221_ctx_t *ctx, uint8_t *val);
N
Nint32_t hts221_temp_data_ready_get(hts221_ctx_t *ctx, uint8_t *val);
N
Nint32_t hts221_hum_data_ready_get(hts221_ctx_t *ctx, uint8_t *val);
N
Nint32_t hts221_humidity_raw_get(hts221_ctx_t *ctx, uint8_t *buff);
N
Nint32_t hts221_temperature_raw_get(hts221_ctx_t *ctx, uint8_t *buff);
N
Nint32_t hts221_device_id_get(hts221_ctx_t *ctx, uint8_t *buff);
N
Nint32_t hts221_power_on_set(hts221_ctx_t *ctx, uint8_t val);
N
Nint32_t hts221_power_on_get(hts221_ctx_t *ctx, uint8_t *val);
N
Nint32_t hts221_heater_set(hts221_ctx_t *ctx, uint8_t val);
Nint32_t hts221_heater_get(hts221_ctx_t *ctx, uint8_t *val);
N
Nint32_t hts221_boot_set(hts221_ctx_t *ctx, uint8_t val);
Nint32_t hts221_boot_get(hts221_ctx_t *ctx, uint8_t *val);
N
Nint32_t hts221_status_get(hts221_ctx_t *ctx, hts221_status_reg_t *val);
N
Nint32_t hts221_drdy_on_int_set(hts221_ctx_t *ctx, uint8_t val);
Nint32_t hts221_drdy_on_int_get(hts221_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  HTS221_PUSH_PULL   = 0,
N  HTS221_OPEN_DRAIN  = 1,
N  HTS221_PIN_MODE_ND = 2,
N} hts221_pp_od_t;
Nint32_t hts221_pin_mode_set(hts221_ctx_t *ctx, hts221_pp_od_t val);
Nint32_t hts221_pin_mode_get(hts221_ctx_t *ctx, hts221_pp_od_t *val);
N
Ntypedef enum {
N  HTS221_ACTIVE_HIGH = 0,
N  HTS221_ACTIVE_LOW  = 1,
N  HTS221_ACTIVE_ND   = 2,
N} hts221_drdy_h_l_t;
Nint32_t hts221_int_polarity_set(hts221_ctx_t *ctx, hts221_drdy_h_l_t val);
Nint32_t hts221_int_polarity_get(hts221_ctx_t *ctx, hts221_drdy_h_l_t *val);
N
Nint32_t hts221_hum_rh_point_0_get(hts221_ctx_t *ctx, uint8_t *buff);
Nint32_t hts221_hum_rh_point_1_get(hts221_ctx_t *ctx, uint8_t *buff);
N
Nint32_t hts221_temp_deg_point_0_get(hts221_ctx_t *ctx, uint8_t *buff);
Nint32_t hts221_temp_deg_point_1_get(hts221_ctx_t *ctx, uint8_t *buff);
N
Nint32_t hts221_hum_adc_point_0_get(hts221_ctx_t *ctx, uint8_t *buff);
Nint32_t hts221_hum_adc_point_1_get(hts221_ctx_t *ctx, uint8_t *buff);
N
Nint32_t hts221_temp_adc_point_0_get(hts221_ctx_t *ctx, uint8_t *buff);
Nint32_t hts221_temp_adc_point_1_get(hts221_ctx_t *ctx, uint8_t *buff);
N
N/**
N  * @}
N  *
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*HTS221_REGS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "..\..\..\..\..\..\Drivers\BSP\Components\hts221\hts221.h" 2
N#include <string.h>
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup Component Component
N * @{
N */
N
N/** @addtogroup HTS221 HTS221
N * @{
N */
N
N/** @defgroup HTS221_Exported_Types HTS221 Exported Types
N * @{
N */
N
Ntypedef int32_t (*HTS221_Init_Func)(void);
Ntypedef int32_t (*HTS221_DeInit_Func)(void);
Ntypedef int32_t (*HTS221_GetTick_Func)(void);
Ntypedef int32_t (*HTS221_WriteReg_Func)(uint16_t, uint16_t, uint8_t *, uint16_t);
Ntypedef int32_t (*HTS221_ReadReg_Func)(uint16_t, uint16_t, uint8_t *, uint16_t);
N
Ntypedef struct
N{
N  HTS221_Init_Func          Init;
N  HTS221_DeInit_Func        DeInit;
N  uint32_t                  BusType; /*0 means I2C, 1 means SPI-3-Wires */
N  uint8_t                   Address;
N  HTS221_WriteReg_Func      WriteReg;
N  HTS221_ReadReg_Func       ReadReg;
N  HTS221_GetTick_Func       GetTick;
N} HTS221_IO_t;
N
Ntypedef struct
N{
N  float x0;
N  float y0;
N  float x1;
N  float y1;
N} lin_t;
N
Ntypedef struct
N{
N  HTS221_IO_t        IO;
N  hts221_ctx_t       Ctx;
N  uint8_t            is_initialized;
N  uint8_t            hum_is_enabled;
N  uint8_t            temp_is_enabled;
N} HTS221_Object_t;
N
Ntypedef struct
N{
N  uint8_t Temperature;
N  uint8_t Pressure;
N  uint8_t Humidity;
N  uint8_t LowPower;
N  float   HumMaxOdr;
N  float   TempMaxOdr;
N  float   PressMaxOdr;
N} HTS221_Capabilities_t;
N
Ntypedef struct
N{
N  int32_t (*Init)(HTS221_Object_t *);
N  int32_t (*DeInit)(HTS221_Object_t *);
N  int32_t (*ReadID)(HTS221_Object_t *, uint8_t *);
N  int32_t (*GetCapabilities)(HTS221_Object_t *, HTS221_Capabilities_t *);
N} HTS221_CommonDrv_t;
N
Ntypedef struct
N{
N  int32_t (*Enable)(HTS221_Object_t *);
N  int32_t (*Disable)(HTS221_Object_t *);
N  int32_t (*GetOutputDataRate)(HTS221_Object_t *, float *);
N  int32_t (*SetOutputDataRate)(HTS221_Object_t *, float);
N  int32_t (*GetHumidity)(HTS221_Object_t *, float *);
N} HTS221_HUM_Drv_t;
N
Ntypedef struct
N{
N  int32_t (*Enable)(HTS221_Object_t *);
N  int32_t (*Disable)(HTS221_Object_t *);
N  int32_t (*GetOutputDataRate)(HTS221_Object_t *, float *);
N  int32_t (*SetOutputDataRate)(HTS221_Object_t *, float);
N  int32_t (*GetTemperature)(HTS221_Object_t *, float *);
N} HTS221_TEMP_Drv_t;
N
N/**
N * @}
N */
N
N/** @defgroup HTS221_Exported_Constants HTS221 Exported Constants
N * @{
N */
N#define HTS221_I2C_BUS           0U
N#define HTS221_SPI_3WIRES_BUS    1U
N
N/** HTS221 error codes  **/
N#define HTS221_OK                 0
N#define HTS221_ERROR             -1
N
N/**
N * @}
N */
N
N/** @addtogroup HTS221_Exported_Functions HTS221 Exported Functions
N * @{
N */
N
Nint32_t HTS221_RegisterBusIO(HTS221_Object_t *pObj, HTS221_IO_t *pIO);
Nint32_t HTS221_Init(HTS221_Object_t *pObj);
Nint32_t HTS221_DeInit(HTS221_Object_t *pObj);
Nint32_t HTS221_ReadID(HTS221_Object_t *pObj, uint8_t *Id);
Nint32_t HTS221_GetCapabilities(HTS221_Object_t *pObj, HTS221_Capabilities_t *Capabilities);
Nint32_t HTS221_Get_Init_Status(HTS221_Object_t *pObj, uint8_t *Status);
N
Nint32_t HTS221_HUM_Enable(HTS221_Object_t *pObj);
Nint32_t HTS221_HUM_Disable(HTS221_Object_t *pObj);
Nint32_t HTS221_HUM_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr);
Nint32_t HTS221_HUM_SetOutputDataRate(HTS221_Object_t *pObj, float Odr);
Nint32_t HTS221_HUM_GetHumidity(HTS221_Object_t *pObj, float *Value);
Nint32_t HTS221_HUM_Get_DRDY_Status(HTS221_Object_t *pObj, uint8_t *Status);
N
Nint32_t HTS221_TEMP_Enable(HTS221_Object_t *pObj);
Nint32_t HTS221_TEMP_Disable(HTS221_Object_t *pObj);
Nint32_t HTS221_TEMP_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr);
Nint32_t HTS221_TEMP_SetOutputDataRate(HTS221_Object_t *pObj, float Odr);
Nint32_t HTS221_TEMP_GetTemperature(HTS221_Object_t *pObj, float *Value);
Nint32_t HTS221_TEMP_Get_DRDY_Status(HTS221_Object_t *pObj, uint8_t *Status);
N
Nint32_t HTS221_Read_Reg(HTS221_Object_t *pObj, uint8_t Reg, uint8_t *Data);
Nint32_t HTS221_Write_Reg(HTS221_Object_t *pObj, uint8_t Reg, uint8_t Data);
N
Nint32_t HTS221_Set_One_Shot(HTS221_Object_t *pObj);
Nint32_t HTS221_Get_One_Shot_Status(HTS221_Object_t *pObj, uint8_t *Status);
N
Nint32_t HTS221_Enable_DRDY_Interrupt(HTS221_Object_t *pObj);
N
N/**
N * @}
N */
N
N/** @addtogroup HTS221_Exported_Variables HTS221 Exported Variables
N * @{
N */
N
Nextern HTS221_CommonDrv_t HTS221_COMMON_Driver;
Nextern HTS221_HUM_Drv_t HTS221_HUM_Driver;
Nextern HTS221_TEMP_Drv_t HTS221_TEMP_Driver;
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 80 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_env_sensors.h" 2
N#endif
N
N#if (USE_IKS01A2_ENV_SENSOR_LPS33HW_0 == 1)
X#if (0 == 1)
S#include "lps33hw.h"
N#endif
N
N#if (USE_IKS01A2_ENV_SENSOR_LPS22HH_0 == 1)
X#if (0 == 1)
S#include "lps22hh.h"
N#endif
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup IKS01A2 IKS01A2
N * @{
N */
N
N/** @addtogroup IKS01A2_ENV_SENSORS IKS01A2 ENV SENSORS
N * @{
N */
N
N/** @defgroup IKS01A2_ENV_SENSORS_Exported_Types IKS01A2 ENV SENSORS Exported Types
N * @{
N */
N
N/* Environmental Sensor instance Info */
Ntypedef struct
N{
N  uint8_t Temperature;
N  uint8_t Pressure;
N  uint8_t Humidity;
N  uint8_t LowPower;
N  float   HumMaxOdr;
N  float   TempMaxOdr;
N  float   PressMaxOdr;
N} IKS01A2_ENV_SENSOR_Capabilities_t;
N
Ntypedef struct
N{
N  uint32_t Functions;
N} IKS01A2_ENV_SENSOR_Ctx_t;
N
N/**
N * @}
N */
N
N/** @defgroup IKS01A2_ENV_SENSOR_Exported_Constants IKS01A2 ENV SENSOR Exported Constants
N * @{
N */
N
N#if (USE_IKS01A2_ENV_SENSOR_HTS221_0 == 1)
X#if (1U == 1)
N#define IKS01A2_HTS221_0 0
N#endif
N
N#if (USE_IKS01A2_ENV_SENSOR_LPS22HB_0 == 1)
X#if (1U == 1)
N#define IKS01A2_LPS22HB_0 (USE_IKS01A2_ENV_SENSOR_HTS221_0)
N#endif
N
N#if (USE_IKS01A2_ENV_SENSOR_LPS33HW_0 == 1)
X#if (0 == 1)
S#define IKS01A2_LPS33HW_0 (USE_IKS01A2_ENV_SENSOR_HTS221_0 + \
S                           USE_IKS01A2_ENV_SENSOR_LPS22HB_0)
X#define IKS01A2_LPS33HW_0 (USE_IKS01A2_ENV_SENSOR_HTS221_0 +                            USE_IKS01A2_ENV_SENSOR_LPS22HB_0)
N#endif
N
N#if (USE_IKS01A2_ENV_SENSOR_LPS22HH_0 == 1)
X#if (0 == 1)
S#define IKS01A2_LPS22HH_0 (USE_IKS01A2_ENV_SENSOR_HTS221_0 + \
S                           USE_IKS01A2_ENV_SENSOR_LPS22HB_0 + \
S                           USE_IKS01A2_ENV_SENSOR_LPS33HW_0)
X#define IKS01A2_LPS22HH_0 (USE_IKS01A2_ENV_SENSOR_HTS221_0 +                            USE_IKS01A2_ENV_SENSOR_LPS22HB_0 +                            USE_IKS01A2_ENV_SENSOR_LPS33HW_0)
N#endif
N
N#ifndef ENV_TEMPERATURE
N#define ENV_TEMPERATURE      1U
N#endif
N#ifndef ENV_PRESSURE
N#define ENV_PRESSURE         2U
N#endif
N#ifndef ENV_HUMIDITY
N#define ENV_HUMIDITY         4U
N#endif
N
N#define IKS01A2_ENV_FUNCTIONS_NBR    3U
N#define IKS01A2_ENV_INSTANCES_NBR    (USE_IKS01A2_ENV_SENSOR_HTS221_0 + \
N                                      USE_IKS01A2_ENV_SENSOR_LPS22HB_0 + \
N                                      USE_IKS01A2_ENV_SENSOR_LPS33HW_0 + \
N                                      USE_IKS01A2_ENV_SENSOR_LPS22HH_0)
X#define IKS01A2_ENV_INSTANCES_NBR    (USE_IKS01A2_ENV_SENSOR_HTS221_0 +                                       USE_IKS01A2_ENV_SENSOR_LPS22HB_0 +                                       USE_IKS01A2_ENV_SENSOR_LPS33HW_0 +                                       USE_IKS01A2_ENV_SENSOR_LPS22HH_0)
N
N#if (IKS01A2_ENV_INSTANCES_NBR == 0)
X#if ((1U + 1U + 0 + 0) == 0)
S#error "No environmental sensor instance has been selected"
N#endif
N
N/**
N * @}
N */
N
N/** @addtogroup IKS01A2_ENV_SENSORS_Exported_Functions IKS01A2 ENV SENSOR Exported Functions
N * @{
N */
N
Nint32_t IKS01A2_ENV_SENSOR_Init(uint32_t Instance, uint32_t Functions);
Nint32_t IKS01A2_ENV_SENSOR_DeInit(uint32_t Instance);
Nint32_t IKS01A2_ENV_SENSOR_GetCapabilities(uint32_t Instance, IKS01A2_ENV_SENSOR_Capabilities_t *Capabilities);
Nint32_t IKS01A2_ENV_SENSOR_ReadID(uint32_t Instance, uint8_t *Id);
Nint32_t IKS01A2_ENV_SENSOR_Enable(uint32_t Instance, uint32_t Function);
Nint32_t IKS01A2_ENV_SENSOR_Disable(uint32_t Instance, uint32_t Function);
Nint32_t IKS01A2_ENV_SENSOR_GetOutputDataRate(uint32_t Instance, uint32_t Function, float *Odr);
Nint32_t IKS01A2_ENV_SENSOR_SetOutputDataRate(uint32_t Instance, uint32_t Function, float Odr);
Nint32_t IKS01A2_ENV_SENSOR_GetValue(uint32_t Instance, uint32_t Function, float *Value);
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* IKS01A2_ENV_SENSORS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 69 "..\Inc\main.h" 2
N#include "iks01a2_env_sensors_ex.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_env_sensors_ex.h" 1
N/**
N ******************************************************************************
N * @file    iks01a2_env_sensors_ex.h
N * @author  MEMS Software Solutions Team
N * @brief   This file provides a set of extended functions needed to manage the environmental sensors
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics International N.V.
N * All rights reserved.</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted, provided that the following conditions are met:
N *
N * 1. Redistribution of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. Neither the name of STMicroelectronics nor the names of other
N *    contributors to this software may be used to endorse or promote products
N *    derived from this software without specific written permission.
N * 4. This software, including modifications and/or derivative works of this
N *    software, must execute solely and exclusively on microcontroller or
N *    microprocessor devices manufactured by or for STMicroelectronics.
N * 5. Redistribution and use of this software other than as permitted under
N *    this license is void and will automatically terminate your rights under
N *    this license.
N *
N * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
N * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
N * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
N * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
N * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef IKS01A2_ENV_SENSOR_EX_H
N#define IKS01A2_ENV_SENSOR_EX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "iks01a2_env_sensors.h"
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup IKS01A2 IKS01A2
N * @{
N */
N
N/** @addtogroup IKS01A2_ENV_SENSOR_EX IKS01A2_ENV_SENSOR_EX
N * @{
N */
N
N/** @addtogroup IKS01A2_ENV_SENSOR_EX_Exported_Functions IKS01A2_ENV_SENSOR_EX Exported Functions
N * @{
N */
N
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Get_Data(uint32_t Instance, float *Press, float *Temp);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Get_Fth_Status(uint32_t Instance, uint8_t *Status);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Get_Full_Status(uint32_t Instance, uint8_t *Status);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Get_Num_Samples(uint32_t Instance, uint8_t *NumSamples);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Get_Ovr_Status(uint32_t Instance, uint8_t *Status);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Reset_Interrupt(uint32_t Instance, uint8_t interrupt);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Set_Interrupt(uint32_t Instance, uint8_t Interrupt);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Set_Mode(uint32_t Instance, uint8_t Mode);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Set_Watermark_Level(uint32_t Instance, uint8_t Watermark);
Nint32_t IKS01A2_ENV_SENSOR_FIFO_Usage(uint32_t Instance, uint8_t Status);
Nint32_t IKS01A2_ENV_SENSOR_Get_DRDY_Status(uint32_t Instance, uint32_t Function, uint8_t *Status);
Nint32_t IKS01A2_ENV_SENSOR_Read_Register(uint32_t Instance, uint8_t Reg, uint8_t *Data);
Nint32_t IKS01A2_ENV_SENSOR_Write_Register(uint32_t Instance, uint8_t Reg, uint8_t Data);
Nint32_t IKS01A2_ENV_SENSOR_Set_One_Shot(uint32_t Instance);
Nint32_t IKS01A2_ENV_SENSOR_Get_One_Shot_Status(uint32_t Instance, uint8_t *Status);
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* IKS01A2_ENV_SENSOR_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 70 "..\Inc\main.h" 2
N#include "iks01a2_motion_sensors.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_motion_sensors.h" 1
N/**
N ******************************************************************************
N * @file    iks01a2_motion_sensors.h
N * @author  MEMS Software Solutions Team
N * @brief   This file provides a set of functions needed to manage the motion sensors
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics International N.V.
N * All rights reserved.</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted, provided that the following conditions are met:
N *
N * 1. Redistribution of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. Neither the name of STMicroelectronics nor the names of other
N *    contributors to this software may be used to endorse or promote products
N *    derived from this software without specific written permission.
N * 4. This software, including modifications and/or derivative works of this
N *    software, must execute solely and exclusively on microcontroller or
N *    microprocessor devices manufactured by or for STMicroelectronics.
N * 5. Redistribution and use of this software other than as permitted under
N *    this license is void and will automatically terminate your rights under
N *    this license.
N *
N * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
N * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
N * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
N * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
N * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef IKS01A2_MOTION_SENSOR_H
N#define IKS01A2_MOTION_SENSOR_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "iks01a2_conf.h"
L 1 "..\Inc\iks01a2_conf.h" 1
N/**
N ******************************************************************************
N * @file    iks01a2_conf.h
N * @author  MEMS Application Team
N * @version V0.0.1
N * @date    29-January-2018
N * @brief   This file contains definitions for the MEMS components bus interfaces
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N#if (defined (USE_STM32F4XX_NUCLEO))
X#if (1L)
N#include "stm32f4xx_hal.h"
N#include "nucleo_f401re_bus.h"
N#include "nucleo_f401re_errno.h"
N
N#elif (defined (USE_STM32L0XX_NUCLEO))
S#include "stm32l0xx_hal.h"
S#include "nucleo_l073rz_bus.h"
S#include "nucleo_l073rz_errno.h"
S
S#elif (defined (USE_STM32L1XX_NUCLEO))
S#include "stm32l1xx_hal.h"
S#include "nucleo_l152re_bus.h"
S#include "nucleo_l152re_errno.h"
S
S#elif (defined (USE_STM32L4XX_NUCLEO))
S#include "stm32l4xx_hal.h"
S#include "nucleo_l476rg_bus.h"
S#include "nucleo_l476rg_errno.h"
S
S#else
S#error Not supported platform
N#endif
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __IKS01A2_CONF_H__
S#define __IKS01A2_CONF_H__
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S#define USE_IKS01A2_ENV_SENSOR_HTS221_0                1U
S#define USE_IKS01A2_ENV_SENSOR_LPS22HB_0               1U
S
S#define USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0            1U
S#define USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0      1U
S#define USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0      1U
S
S#define IKS01A2_I2C_Init BSP_I2C1_Init
S#define IKS01A2_I2C_DeInit BSP_I2C1_DeInit
S#define IKS01A2_I2C_ReadReg BSP_I2C1_ReadReg
S#define IKS01A2_I2C_WriteReg BSP_I2C1_WriteReg
S#define IKS01A2_GetTick BSP_GetTick
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __IKS01A2_CONF_H__*/
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 56 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_motion_sensors.h" 2
N#include "motion_sensor.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\Common\motion_sensor.h" 1
N/**
N ******************************************************************************
N * @file    motion_sensor.h
N * @author  MCD Application Team
N * @brief   This header file contains the functions prototypes for the
N *          accelerometer driver
N ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
N  * All rights reserved.</center></h2>
N  *
N  * This software component is licensed by ST under BSD 3-Clause license,
N  * the "License"; You may not use this file except in compliance with the
N  * License. You may obtain a copy of the License at:
N  *                        opensource.org/licenses/BSD-3-Clause
N  *
N  ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef MOTION_SENSOR_H
N#define MOTION_SENSOR_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup COMPONENTS COMPONENTS
N * @{
N */
N
N/** @addtogroup COMMON COMMON
N * @{
N */
N
N/** @addtogroup MOTION_SENSOR MOTION SENSOR
N * @{
N */
N
N/** @addtogroup MOTION_SENSOR_Public_Types MOTION SENSOR Public types
N * @{
N */
N
N/**
N * @brief  MOTION_SENSOR driver structure definition
N */
Ntypedef struct
N{
N  int32_t ( *Init              ) ( void * );
N  int32_t ( *DeInit            ) ( void * );
N  int32_t ( *ReadID            ) ( void *, uint8_t * ); 
N  int32_t ( *GetCapabilities   ) ( void *, void * );
N} MOTION_SENSOR_CommonDrv_t;
N
Ntypedef struct
N{
N  int32_t ( *Enable            ) ( void * );
N  int32_t ( *Disable           ) ( void * );
N  int32_t ( *GetSensitivity    ) ( void *, float * );
N  int32_t ( *GetOutputDataRate ) ( void *, float * );
N  int32_t ( *SetOutputDataRate ) ( void *, float );
N  int32_t ( *GetFullScale      ) ( void *, int32_t * );
N  int32_t ( *SetFullScale      ) ( void *, int32_t );
N  int32_t ( *GetAxes           ) ( void *, void * );
N  int32_t ( *GetAxesRaw        ) ( void *, void * );
N} MOTION_SENSOR_FuncDrv_t;
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* MOTION_SENSOR_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 57 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_motion_sensors.h" 2
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0
S#define USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0          1
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0
S#define USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0    1
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0
S#define USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0    1
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0
N#define USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0        0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0
N#define USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0         0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0
N#define USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0          0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0
N#define USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0    0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0
N#define USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0    0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0
N#define USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0        0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0
N#define USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0         0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0
N#define USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0         0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0
N#define USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0          0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0
N#define USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0          0
N#endif
N
N#ifndef USE_IKS01A2_MOTION_SENSOR_LSM6DSOX_0
N#define USE_IKS01A2_MOTION_SENSOR_LSM6DSOX_0         0
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 == 1)
X#if (1U == 1)
N#include "lsm6dsl.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl\lsm6dsl.h" 1
N/**
N ******************************************************************************
N * @file    lsm6dsl.h
N * @author  MEMS Software Solutions Team
N * @brief   LSM6DSL header driver file
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef LSM6DSL_H
N#define LSM6DSL_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "lsm6dsl_reg.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl\lsm6dsl_reg.h" 1
N/*
N ******************************************************************************
N * @file    lsm6dsl_reg.h
N * @author  Sensors Software Solution Team
N * @brief   This file contains all the functions prototypes for the
N *          lsm6dsl_reg.c driver.
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright
N *      notice, this list of conditions and the following disclaimer in the
N *      documentation and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its
N *      contributors may be used to endorse or promote products derived from
N *      this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef LSM6DSL_DRIVER_H
N#define LSM6DSL_DRIVER_H
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include <math.h>
N
N/** @addtogroup LSM6DSL
N  * @{
N  *
N  */
N
N/** @defgroup LSM6DSL_sensors_common_types
N  * @{
N  *
N  */
N
N#ifndef MEMS_SHARED_TYPES
S#define MEMS_SHARED_TYPES
S
S/**
S  * @defgroup axisXbitXX_t
S  * @brief    These unions are useful to represent different sensors data type.
S  *           These unions are not need by the driver.
S  *
S  *           REMOVING the unions you are compliant with:
S  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
S  *
S  * @{
S  *
S  */
S
Stypedef union{
S  int16_t i16bit[3];
S  uint8_t u8bit[6];
S} axis3bit16_t;
S
Stypedef union{
S  int16_t i16bit;
S  uint8_t u8bit[2];
S} axis1bit16_t;
S
Stypedef union{
S  int32_t i32bit[3];
S  uint8_t u8bit[12];
S} axis3bit32_t;
S
Stypedef union{
S  int32_t i32bit;
S  uint8_t u8bit[4];
S} axis1bit32_t;
S
S/**
S  * @}
S  *
S  */
S
Stypedef struct{
S  uint8_t bit0       : 1;
S  uint8_t bit1       : 1;
S  uint8_t bit2       : 1;
S  uint8_t bit3       : 1;
S  uint8_t bit4       : 1;
S  uint8_t bit5       : 1;
S  uint8_t bit6       : 1;
S  uint8_t bit7       : 1;
S} bitwise_t;
S
S#define PROPERTY_DISABLE                (0U)
S#define PROPERTY_ENABLE                 (1U)
S
N#endif /* MEMS_SHARED_TYPES */
N
N/**
N  * @}
N  *
N  */
N
N/** @addtogroup  LSM9DS1_Interfaces_Functions
N  * @brief       This section provide a set of functions used to read and
N  *              write a generic register of the device.
N  *              MANDATORY: return 0 -> no Error.
N  * @{
N  *
N  */
N
Ntypedef int32_t (*lsm6dsl_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);
Ntypedef int32_t (*lsm6dsl_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);
N
Ntypedef struct {
N  /** Component mandatory fields **/
N  lsm6dsl_write_ptr  write_reg;
N  lsm6dsl_read_ptr   read_reg;
N  /** Customizable optional pointer **/
N  void *handle;
N} lsm6dsl_ctx_t;
N
N/**
N  * @}
N  *
N  */
N
N/** @defgroup LSM6DSL_Infos
N  * @{
N  *
N  */
N
N/** I2C Device Address 8 bit format  if SA0=0 -> D5 if SA0=1 -> D7 **/
N#define LSM6DSL_I2C_ADD_L     0xD5U
N#define LSM6DSL_I2C_ADD_H     0xD7U
N
N/** Device Identification (Who am I) **/
N#define LSM6DSL_ID            0x6AU
N
N/**
N  * @}
N  *
N  */
N
N#define LSM6DSL_FUNC_CFG_ACCESS              0x01U
Ntypedef struct {
N  uint8_t not_used_01              : 5;
N  uint8_t func_cfg_en              : 3;  /* func_cfg_en + func_cfg_en_b */
N} lsm6dsl_func_cfg_access_t;
N
N#define LSM6DSL_SENSOR_SYNC_TIME_FRAME       0x04U
Ntypedef struct {
N  uint8_t tph                      : 4;
N  uint8_t not_used_01              : 4;
N} lsm6dsl_sensor_sync_time_frame_t;
N
N#define LSM6DSL_SENSOR_SYNC_RES_RATIO        0x05U
Ntypedef struct {
N  uint8_t rr                       : 2;
N  uint8_t not_used_01              : 6;
N} lsm6dsl_sensor_sync_res_ratio_t;
N
N#define LSM6DSL_FIFO_CTRL1                   0x06U
Ntypedef struct {
N  uint8_t fth                      : 8;  /* + FIFO_CTRL2(fth) */
N} lsm6dsl_fifo_ctrl1_t;
N
N#define LSM6DSL_FIFO_CTRL2                   0x07U
Ntypedef struct {
N  uint8_t fth                      : 3;  /* + FIFO_CTRL1(fth) */
N  uint8_t fifo_temp_en             : 1;
N  uint8_t not_used_01              : 2;
N  uint8_t  timer_pedo_fifo_drdy    : 1;
N  uint8_t timer_pedo_fifo_en       : 1;
N} lsm6dsl_fifo_ctrl2_t;
N
N#define LSM6DSL_FIFO_CTRL3                   0x08U
Ntypedef struct {
N  uint8_t dec_fifo_xl              : 3;
N  uint8_t dec_fifo_gyro            : 3;
N  uint8_t not_used_01              : 2;
N} lsm6dsl_fifo_ctrl3_t;
N
N#define LSM6DSL_FIFO_CTRL4                   0x09U
Ntypedef struct {
N  uint8_t dec_ds3_fifo             : 3;
N  uint8_t dec_ds4_fifo             : 3;
N  uint8_t only_high_data           : 1;
N  uint8_t stop_on_fth              : 1;
N} lsm6dsl_fifo_ctrl4_t;
N
N#define LSM6DSL_FIFO_CTRL5                   0x0AU
Ntypedef struct {
N  uint8_t fifo_mode                : 3;
N  uint8_t odr_fifo                 : 4;
N  uint8_t not_used_01              : 1;
N} lsm6dsl_fifo_ctrl5_t;
N
N#define LSM6DSL_DRDY_PULSE_CFG_G             0x0BU
Ntypedef struct {
N  uint8_t int2_wrist_tilt          : 1;
N  uint8_t not_used_01              : 6;
N  uint8_t drdy_pulsed              : 1;
N} lsm6dsl_drdy_pulse_cfg_g_t;
N
N#define LSM6DSL_INT1_CTRL                    0x0DU
Ntypedef struct {
N  uint8_t int1_drdy_xl             : 1;
N  uint8_t int1_drdy_g              : 1;
N  uint8_t int1_boot                : 1;
N  uint8_t int1_fth                 : 1;
N  uint8_t int1_fifo_ovr            : 1;
N  uint8_t int1_full_flag           : 1;
N  uint8_t int1_sign_mot            : 1;
N  uint8_t int1_step_detector       : 1;
N} lsm6dsl_int1_ctrl_t;
N
N#define LSM6DSL_INT2_CTRL                    0x0EU
Ntypedef struct {
N  uint8_t int2_drdy_xl             : 1;
N  uint8_t int2_drdy_g              : 1;
N  uint8_t int2_drdy_temp           : 1;
N  uint8_t int2_fth                 : 1;
N  uint8_t int2_fifo_ovr            : 1;
N  uint8_t int2_full_flag           : 1;
N  uint8_t int2_step_count_ov       : 1;
N  uint8_t int2_step_delta          : 1;
N} lsm6dsl_int2_ctrl_t;
N
N#define LSM6DSL_WHO_AM_I                     0x0FU
N#define LSM6DSL_CTRL1_XL                     0x10U
Ntypedef struct {
N  uint8_t bw0_xl                   : 1;
N  uint8_t lpf1_bw_sel              : 1;
N  uint8_t fs_xl                    : 2;
N  uint8_t odr_xl                   : 4;
N} lsm6dsl_ctrl1_xl_t;
N
N#define LSM6DSL_CTRL2_G                      0x11U
Ntypedef struct {
N  uint8_t not_used_01              : 1;
N  uint8_t fs_g                     : 3;  /* fs_g + fs_125 */
N  uint8_t odr_g                    : 4;
N} lsm6dsl_ctrl2_g_t;
N
N#define LSM6DSL_CTRL3_C                      0x12U
Ntypedef struct {
N  uint8_t sw_reset                 : 1;
N  uint8_t ble                      : 1;
N  uint8_t if_inc                   : 1;
N  uint8_t sim                      : 1;
N  uint8_t pp_od                    : 1;
N  uint8_t h_lactive                : 1;
N  uint8_t bdu                      : 1;
N  uint8_t boot                     : 1;
N} lsm6dsl_ctrl3_c_t;
N
N#define LSM6DSL_CTRL4_C                      0x13U
Ntypedef struct {
N  uint8_t not_used_01              : 1;
N  uint8_t lpf1_sel_g               : 1;
N  uint8_t i2c_disable              : 1;
N  uint8_t drdy_mask                : 1;
N  uint8_t den_drdy_int1            : 1;
N  uint8_t int2_on_int1             : 1;
N  uint8_t sleep                    : 1;
N  uint8_t den_xl_en                : 1;
N} lsm6dsl_ctrl4_c_t;
N
N#define LSM6DSL_CTRL5_C                      0x14U
Ntypedef struct {
N  uint8_t st_xl                    : 2;
N  uint8_t st_g                     : 2;
N  uint8_t den_lh                   : 1;
N  uint8_t rounding                 : 3;
N} lsm6dsl_ctrl5_c_t;
N
N#define LSM6DSL_CTRL6_C                      0x15U
Ntypedef struct {
N  uint8_t ftype                    : 2;
N  uint8_t not_used_01              : 1;
N  uint8_t usr_off_w                : 1;
N  uint8_t xl_hm_mode               : 1;
N  uint8_t den_mode                 : 3;  /* trig_en + lvl_en + lvl2_en */
N} lsm6dsl_ctrl6_c_t;
N
N#define LSM6DSL_CTRL7_G                      0x16U
Ntypedef struct {
N  uint8_t not_used_01              : 2;
N  uint8_t rounding_status          : 1;
N  uint8_t not_used_02              : 1;
N  uint8_t hpm_g                    : 2;
N  uint8_t hp_en_g                  : 1;
N  uint8_t g_hm_mode                : 1;
N} lsm6dsl_ctrl7_g_t;
N
N#define LSM6DSL_CTRL8_XL                     0x17U
Ntypedef struct {
N  uint8_t low_pass_on_6d           : 1;
N  uint8_t not_used_01              : 1;
N  uint8_t hp_slope_xl_en           : 1;
N  uint8_t input_composite          : 1;
N  uint8_t hp_ref_mode              : 1;
N  uint8_t hpcf_xl                  : 2;
N  uint8_t lpf2_xl_en               : 1;
N} lsm6dsl_ctrl8_xl_t;
N
N#define LSM6DSL_CTRL9_XL                     0x18U
Ntypedef struct {
N  uint8_t not_used_01              : 2;
N  uint8_t soft_en                  : 1;
N  uint8_t not_used_02              : 1;
N  uint8_t den_xl_g                 : 1;
N  uint8_t den_z                    : 1;
N  uint8_t den_y                    : 1;
N  uint8_t den_x                    : 1;
N} lsm6dsl_ctrl9_xl_t;
N
N#define LSM6DSL_CTRL10_C                     0x19U
Ntypedef struct {
N  uint8_t sign_motion_en           : 1;
N  uint8_t pedo_rst_step            : 1;
N  uint8_t func_en                  : 1;
N  uint8_t tilt_en                  : 1;
N  uint8_t pedo_en                  : 1;
N  uint8_t timer_en                 : 1;
N  uint8_t not_used_01              : 1;
N  uint8_t wrist_tilt_en            : 1;
N} lsm6dsl_ctrl10_c_t;
N
N#define LSM6DSL_MASTER_CONFIG                0x1AU
Ntypedef struct {
N  uint8_t master_on                : 1;
N  uint8_t iron_en                  : 1;
N  uint8_t pass_through_mode        : 1;
N  uint8_t pull_up_en               : 1;
N  uint8_t start_config             : 1;
N  uint8_t not_used_01              : 1;
N  uint8_t  data_valid_sel_fifo     : 1;
N  uint8_t drdy_on_int1             : 1;
N} lsm6dsl_master_config_t;
N
N#define LSM6DSL_WAKE_UP_SRC                  0x1BU
Ntypedef struct {
N  uint8_t z_wu                     : 1;
N  uint8_t y_wu                     : 1;
N  uint8_t x_wu                     : 1;
N  uint8_t wu_ia                    : 1;
N  uint8_t sleep_state_ia           : 1;
N  uint8_t ff_ia                    : 1;
N  uint8_t not_used_01              : 2;
N} lsm6dsl_wake_up_src_t;
N
N#define LSM6DSL_TAP_SRC                      0x1CU
Ntypedef struct {
N  uint8_t z_tap                    : 1;
N  uint8_t y_tap                    : 1;
N  uint8_t x_tap                    : 1;
N  uint8_t tap_sign                 : 1;
N  uint8_t double_tap               : 1;
N  uint8_t single_tap               : 1;
N  uint8_t tap_ia                   : 1;
N  uint8_t not_used_01              : 1;
N} lsm6dsl_tap_src_t;
N
N#define LSM6DSL_D6D_SRC                      0x1DU
Ntypedef struct {
N  uint8_t xl                       : 1;
N  uint8_t xh                       : 1;
N  uint8_t yl                       : 1;
N  uint8_t yh                       : 1;
N  uint8_t zl                       : 1;
N  uint8_t zh                       : 1;
N  uint8_t d6d_ia                   : 1;
N  uint8_t den_drdy                 : 1;
N} lsm6dsl_d6d_src_t;
N
N#define LSM6DSL_STATUS_REG                   0x1EU
Ntypedef struct {
N  uint8_t xlda                     : 1;
N  uint8_t gda                      : 1;
N  uint8_t tda                      : 1;
N  uint8_t not_used_01              : 5;
N} lsm6dsl_status_reg_t;
N
N#define LSM6DSL_OUT_TEMP_L                   0x20U
N#define LSM6DSL_OUT_TEMP_H                   0x21U
N#define LSM6DSL_OUTX_L_G                     0x22U
N#define LSM6DSL_OUTX_H_G                     0x23U
N#define LSM6DSL_OUTY_L_G                     0x24U
N#define LSM6DSL_OUTY_H_G                     0x25U
N#define LSM6DSL_OUTZ_L_G                     0x26U
N#define LSM6DSL_OUTZ_H_G                     0x27U
N#define LSM6DSL_OUTX_L_XL                    0x28U
N#define LSM6DSL_OUTX_H_XL                    0x29U
N#define LSM6DSL_OUTY_L_XL                    0x2AU
N#define LSM6DSL_OUTY_H_XL                    0x2BU
N#define LSM6DSL_OUTZ_L_XL                    0x2CU
N#define LSM6DSL_OUTZ_H_XL                    0x2DU
N#define LSM6DSL_SENSORHUB1_REG               0x2EU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub1_reg_t;
N
N#define LSM6DSL_SENSORHUB2_REG               0x2FU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub2_reg_t;
N
N#define LSM6DSL_SENSORHUB3_REG               0x30U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub3_reg_t;
N
N#define LSM6DSL_SENSORHUB4_REG               0x31U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub4_reg_t;
N
N#define LSM6DSL_SENSORHUB5_REG               0x32U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub5_reg_t;
N
N#define LSM6DSL_SENSORHUB6_REG               0x33U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub6_reg_t;
N
N#define LSM6DSL_SENSORHUB7_REG               0x34U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub7_reg_t;
N
N#define LSM6DSL_SENSORHUB8_REG               0x35U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub8_reg_t;
N
N#define LSM6DSL_SENSORHUB9_REG               0x36U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub9_reg_t;
N
N#define LSM6DSL_SENSORHUB10_REG              0x37U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub10_reg_t;
N
N#define LSM6DSL_SENSORHUB11_REG              0x38U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub11_reg_t;
N
N#define LSM6DSL_SENSORHUB12_REG              0x39U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub12_reg_t;
N
N#define LSM6DSL_FIFO_STATUS1                 0x3AU
Ntypedef struct {
N  uint8_t diff_fifo                : 8;  /* + FIFO_STATUS2(diff_fifo) */
N} lsm6dsl_fifo_status1_t;
N
N#define LSM6DSL_FIFO_STATUS2                 0x3BU
Ntypedef struct {
N  uint8_t diff_fifo                : 3;  /* + FIFO_STATUS1(diff_fifo) */
N  uint8_t not_used_01              : 1;
N  uint8_t fifo_empty               : 1;
N  uint8_t fifo_full_smart          : 1;
N  uint8_t over_run                 : 1;
N  uint8_t waterm                   : 1;
N} lsm6dsl_fifo_status2_t;
N
N#define LSM6DSL_FIFO_STATUS3                 0x3CU
Ntypedef struct {
N  uint8_t fifo_pattern             : 8;  /* + FIFO_STATUS4(fifo_pattern) */
N} lsm6dsl_fifo_status3_t;
N
N#define LSM6DSL_FIFO_STATUS4                 0x3DU
Ntypedef struct {
N  uint8_t fifo_pattern             : 2;  /* + FIFO_STATUS3(fifo_pattern) */
N  uint8_t not_used_01              : 6;
N} lsm6dsl_fifo_status4_t;
N
N#define LSM6DSL_FIFO_DATA_OUT_L              0x3EU
N#define LSM6DSL_FIFO_DATA_OUT_H              0x3FU
N#define LSM6DSL_TIMESTAMP0_REG               0x40U
N#define LSM6DSL_TIMESTAMP1_REG               0x41U
N#define LSM6DSL_TIMESTAMP2_REG               0x42U
N#define LSM6DSL_STEP_TIMESTAMP_L             0x49U
N#define LSM6DSL_STEP_TIMESTAMP_H             0x4AU
N#define LSM6DSL_STEP_COUNTER_L               0x4BU
N#define LSM6DSL_STEP_COUNTER_H               0x4CU
N
N#define LSM6DSL_SENSORHUB13_REG              0x4DU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub13_reg_t;
N
N#define LSM6DSL_SENSORHUB14_REG              0x4EU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub14_reg_t;
N
N#define LSM6DSL_SENSORHUB15_REG              0x4FU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub15_reg_t;
N
N#define LSM6DSL_SENSORHUB16_REG              0x50U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub16_reg_t;
N
N#define LSM6DSL_SENSORHUB17_REG              0x51U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub17_reg_t;
N
N#define LSM6DSL_SENSORHUB18_REG              0x52U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub18_reg_t;
N
N#define LSM6DSL_FUNC_SRC1                    0x53U
Ntypedef struct {
N  uint8_t sensorhub_end_op         : 1;
N  uint8_t si_end_op                : 1;
N  uint8_t hi_fail                  : 1;
N  uint8_t step_overflow            : 1;
N  uint8_t step_detected            : 1;
N  uint8_t tilt_ia                  : 1;
N  uint8_t sign_motion_ia           : 1;
N  uint8_t  step_count_delta_ia     : 1;
N} lsm6dsl_func_src1_t;
N
N#define LSM6DSL_FUNC_SRC2                    0x54U
Ntypedef struct {
N  uint8_t wrist_tilt_ia            : 1;
N  uint8_t not_used_01              : 2;
N  uint8_t slave0_nack              : 1;
N  uint8_t slave1_nack              : 1;
N  uint8_t slave2_nack              : 1;
N  uint8_t slave3_nack              : 1;
N  uint8_t not_used_02              : 1;
N} lsm6dsl_func_src2_t;
N
N#define LSM6DSL_WRIST_TILT_IA                0x55U
Ntypedef struct {
N  uint8_t not_used_01              : 2;
N  uint8_t wrist_tilt_ia_zneg       : 1;
N  uint8_t wrist_tilt_ia_zpos       : 1;
N  uint8_t wrist_tilt_ia_yneg       : 1;
N  uint8_t wrist_tilt_ia_ypos       : 1;
N  uint8_t wrist_tilt_ia_xneg       : 1;
N  uint8_t wrist_tilt_ia_xpos       : 1;
N} lsm6dsl_wrist_tilt_ia_t;
N
N#define LSM6DSL_TAP_CFG                      0x58U
Ntypedef struct {
N  uint8_t lir                      : 1;
N  uint8_t tap_z_en                 : 1;
N  uint8_t tap_y_en                 : 1;
N  uint8_t tap_x_en                 : 1;
N  uint8_t slope_fds                : 1;
N  uint8_t inact_en                 : 2;
N  uint8_t interrupts_enable        : 1;
N} lsm6dsl_tap_cfg_t;
N
N#define LSM6DSL_TAP_THS_6D                   0x59U
Ntypedef struct {
N  uint8_t tap_ths                  : 5;
N  uint8_t sixd_ths                 : 2;
N  uint8_t d4d_en                   : 1;
N} lsm6dsl_tap_ths_6d_t;
N
N#define LSM6DSL_INT_DUR2                     0x5AU
Ntypedef struct {
N  uint8_t shock                    : 2;
N  uint8_t quiet                    : 2;
N  uint8_t dur                      : 4;
N} lsm6dsl_int_dur2_t;
N
N#define LSM6DSL_WAKE_UP_THS                  0x5BU
Ntypedef struct {
N  uint8_t wk_ths                   : 6;
N  uint8_t not_used_01              : 1;
N  uint8_t single_double_tap        : 1;
N} lsm6dsl_wake_up_ths_t;
N
N#define LSM6DSL_WAKE_UP_DUR                  0x5CU
Ntypedef struct {
N  uint8_t sleep_dur                : 4;
N  uint8_t timer_hr                 : 1;
N  uint8_t wake_dur                 : 2;
N  uint8_t ff_dur                   : 1;
N} lsm6dsl_wake_up_dur_t;
N
N#define LSM6DSL_FREE_FALL                    0x5DU
Ntypedef struct {
N  uint8_t ff_ths                   : 3;
N  uint8_t ff_dur                   : 5;
N} lsm6dsl_free_fall_t;
N
N#define LSM6DSL_MD1_CFG                      0x5EU
Ntypedef struct {
N  uint8_t int1_timer               : 1;
N  uint8_t int1_tilt                : 1;
N  uint8_t int1_6d                  : 1;
N  uint8_t int1_double_tap          : 1;
N  uint8_t int1_ff                  : 1;
N  uint8_t int1_wu                  : 1;
N  uint8_t int1_single_tap          : 1;
N  uint8_t int1_inact_state         : 1;
N} lsm6dsl_md1_cfg_t;
N
N#define LSM6DSL_MD2_CFG                      0x5FU
Ntypedef struct {
N  uint8_t int2_iron                : 1;
N  uint8_t int2_tilt                : 1;
N  uint8_t int2_6d                  : 1;
N  uint8_t int2_double_tap          : 1;
N  uint8_t int2_ff                  : 1;
N  uint8_t int2_wu                  : 1;
N  uint8_t int2_single_tap          : 1;
N  uint8_t int2_inact_state         : 1;
N} lsm6dsl_md2_cfg_t;
N
N#define LSM6DSL_MASTER_CMD_CODE              0x60U
Ntypedef struct {
N  uint8_t master_cmd_code          : 8;
N} lsm6dsl_master_cmd_code_t;
N
N#define LSM6DSL_SENS_SYNC_SPI_ERROR_CODE     0x61U
Ntypedef struct {
N  uint8_t error_code               : 8;
N} lsm6dsl_sens_sync_spi_error_code_t;
N
N#define LSM6DSL_OUT_MAG_RAW_X_L              0x66U
N#define LSM6DSL_OUT_MAG_RAW_X_H              0x67U
N#define LSM6DSL_OUT_MAG_RAW_Y_L              0x68U
N#define LSM6DSL_OUT_MAG_RAW_Y_H              0x69U
N#define LSM6DSL_OUT_MAG_RAW_Z_L              0x6AU
N#define LSM6DSL_OUT_MAG_RAW_Z_H              0x6BU
N#define LSM6DSL_X_OFS_USR                    0x73U
N#define LSM6DSL_Y_OFS_USR                    0x74U
N#define LSM6DSL_Z_OFS_USR                    0x75U
N#define LSM6DSL_SLV0_ADD                     0x02U
Ntypedef struct {
N  uint8_t rw_0                     : 1;
N  uint8_t slave0_add               : 7;
N} lsm6dsl_slv0_add_t;
N
N#define LSM6DSL_SLV0_SUBADD                  0x03U
Ntypedef struct {
N  uint8_t slave0_reg               : 8;
N} lsm6dsl_slv0_subadd_t;
N
N#define LSM6DSL_SLAVE0_CONFIG                0x04U
Ntypedef struct {
N  uint8_t slave0_numop             : 3;
N  uint8_t src_mode                 : 1;
N  uint8_t aux_sens_on              : 2;
N  uint8_t slave0_rate              : 2;
N} lsm6dsl_slave0_config_t;
N
N#define LSM6DSL_SLV1_ADD                     0x05U
Ntypedef struct {
N  uint8_t r_1                      : 1;
N  uint8_t slave1_add               : 7;
N} lsm6dsl_slv1_add_t;
N
N#define LSM6DSL_SLV1_SUBADD                  0x06U
Ntypedef struct {
N  uint8_t slave1_reg               : 8;
N} lsm6dsl_slv1_subadd_t;
N
N#define LSM6DSL_SLAVE1_CONFIG                0x07U
Ntypedef struct {
N  uint8_t slave1_numop             : 3;
N  uint8_t not_used_01              : 2;
N  uint8_t write_once               : 1;
N  uint8_t slave1_rate              : 2;
N} lsm6dsl_slave1_config_t;
N
N#define LSM6DSL_SLV2_ADD                     0x08U
Ntypedef struct {
N  uint8_t r_2                      : 1;
N  uint8_t slave2_add               : 7;
N} lsm6dsl_slv2_add_t;
N
N#define LSM6DSL_SLV2_SUBADD                  0x09U
Ntypedef struct {
N  uint8_t slave2_reg               : 8;
N} lsm6dsl_slv2_subadd_t;
N
N#define LSM6DSL_SLAVE2_CONFIG                0x0AU
Ntypedef struct {
N  uint8_t slave2_numop             : 3;
N  uint8_t not_used_01              : 3;
N  uint8_t slave2_rate              : 2;
N} lsm6dsl_slave2_config_t;
N
N#define LSM6DSL_SLV3_ADD                     0x0BU
Ntypedef struct {
N  uint8_t r_3                      : 1;
N  uint8_t slave3_add               : 7;
N} lsm6dsl_slv3_add_t;
N
N#define LSM6DSL_SLV3_SUBADD                  0x0CU
Ntypedef struct {
N  uint8_t slave3_reg               : 8;
N} lsm6dsl_slv3_subadd_t;
N
N#define LSM6DSL_SLAVE3_CONFIG                0x0DU
Ntypedef struct {
N  uint8_t slave3_numop             : 3;
N  uint8_t not_used_01              : 3;
N  uint8_t slave3_rate              : 2;
N} lsm6dsl_slave3_config_t;
N
N#define LSM6DSL_DATAWRITE_SRC_MODE_SUB_SLV0  0x0EU
Ntypedef struct {
N  uint8_t slave_dataw              : 8;
N} lsm6dsl_datawrite_src_mode_sub_slv0_t;
N
N#define LSM6DSL_CONFIG_PEDO_THS_MIN          0x0FU
Ntypedef struct {
N  uint8_t ths_min                  : 5;
N  uint8_t not_used_01              : 2;
N  uint8_t pedo_fs                  : 1;
N} lsm6dsl_config_pedo_ths_min_t;
N
N#define LSM6DSL_SM_THS                       0x13U
N#define LSM6DSL_PEDO_DEB_REG                 0x14U
Ntypedef struct {
N  uint8_t deb_step      : 3;
N  uint8_t deb_time      : 5;
N} lsm6dsl_pedo_deb_reg_t;
N
N#define LSM6DSL_STEP_COUNT_DELTA             0x15U
N#define LSM6DSL_MAG_SI_XX                    0x24U
N#define LSM6DSL_MAG_SI_XY                    0x25U
N#define LSM6DSL_MAG_SI_XZ                    0x26U
N#define LSM6DSL_MAG_SI_YX                    0x27U
N#define LSM6DSL_MAG_SI_YY                    0x28U
N#define LSM6DSL_MAG_SI_YZ                    0x29U
N#define LSM6DSL_MAG_SI_ZX                    0x2AU
N#define LSM6DSL_MAG_SI_ZY                    0x2BU
N#define LSM6DSL_MAG_SI_ZZ                    0x2CU
N#define LSM6DSL_MAG_OFFX_L                   0x2DU
N#define LSM6DSL_MAG_OFFX_H                   0x2EU
N#define LSM6DSL_MAG_OFFY_L                   0x2FU
N#define LSM6DSL_MAG_OFFY_H                   0x30U
N#define LSM6DSL_MAG_OFFZ_L                   0x31U
N#define LSM6DSL_MAG_OFFZ_H                   0x32U
N#define LSM6DSL_A_WRIST_TILT_LAT             0x50U
N#define LSM6DSL_A_WRIST_TILT_THS             0x54U
N#define LSM6DSL_A_WRIST_TILT_MASK            0x59U
Ntypedef struct {
N  uint8_t not_used_01              : 2;
N  uint8_t  wrist_tilt_mask_zneg    : 1;
N  uint8_t  wrist_tilt_mask_zpos    : 1;
N  uint8_t  wrist_tilt_mask_yneg    : 1;
N  uint8_t  wrist_tilt_mask_ypos    : 1;
N  uint8_t  wrist_tilt_mask_xneg    : 1;
N  uint8_t  wrist_tilt_mask_xpos    : 1;
N} lsm6dsl_a_wrist_tilt_mask_t;
N
N/**
N  * @defgroup LSM6DSL_Register_Union
N  * @brief    This union group all the registers that has a bit-field
N  *           description.
N  *           This union is useful but not need by the driver.
N  *
N  *           REMOVING this union you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
Ntypedef union{
N  lsm6dsl_func_cfg_access_t                  func_cfg_access;
N  lsm6dsl_sensor_sync_time_frame_t           sensor_sync_time_frame;
N  lsm6dsl_sensor_sync_res_ratio_t            sensor_sync_res_ratio;
N  lsm6dsl_fifo_ctrl1_t                       fifo_ctrl1;
N  lsm6dsl_fifo_ctrl2_t                       fifo_ctrl2;
N  lsm6dsl_fifo_ctrl3_t                       fifo_ctrl3;
N  lsm6dsl_fifo_ctrl4_t                       fifo_ctrl4;
N  lsm6dsl_fifo_ctrl5_t                       fifo_ctrl5;
N  lsm6dsl_drdy_pulse_cfg_g_t                 drdy_pulse_cfg_g;
N  lsm6dsl_int1_ctrl_t                        int1_ctrl;
N  lsm6dsl_int2_ctrl_t                        int2_ctrl;
N  lsm6dsl_ctrl1_xl_t                         ctrl1_xl;
N  lsm6dsl_ctrl2_g_t                          ctrl2_g;
N  lsm6dsl_ctrl3_c_t                          ctrl3_c;
N  lsm6dsl_ctrl4_c_t                          ctrl4_c;
N  lsm6dsl_ctrl5_c_t                          ctrl5_c;
N  lsm6dsl_ctrl6_c_t                          ctrl6_c;
N  lsm6dsl_ctrl7_g_t                          ctrl7_g;
N  lsm6dsl_ctrl8_xl_t                         ctrl8_xl;
N  lsm6dsl_ctrl9_xl_t                         ctrl9_xl;
N  lsm6dsl_ctrl10_c_t                         ctrl10_c;
N  lsm6dsl_master_config_t                    master_config;
N  lsm6dsl_wake_up_src_t                      wake_up_src;
N  lsm6dsl_tap_src_t                          tap_src;
N  lsm6dsl_d6d_src_t                          d6d_src;
N  lsm6dsl_status_reg_t                       status_reg;
N  lsm6dsl_sensorhub1_reg_t                   sensorhub1_reg;
N  lsm6dsl_sensorhub2_reg_t                   sensorhub2_reg;
N  lsm6dsl_sensorhub3_reg_t                   sensorhub3_reg;
N  lsm6dsl_sensorhub4_reg_t                   sensorhub4_reg;
N  lsm6dsl_sensorhub5_reg_t                   sensorhub5_reg;
N  lsm6dsl_sensorhub6_reg_t                   sensorhub6_reg;
N  lsm6dsl_sensorhub7_reg_t                   sensorhub7_reg;
N  lsm6dsl_sensorhub8_reg_t                   sensorhub8_reg;
N  lsm6dsl_sensorhub9_reg_t                   sensorhub9_reg;
N  lsm6dsl_sensorhub10_reg_t                  sensorhub10_reg;
N  lsm6dsl_sensorhub11_reg_t                  sensorhub11_reg;
N  lsm6dsl_sensorhub12_reg_t                  sensorhub12_reg;
N  lsm6dsl_fifo_status1_t                     fifo_status1;
N  lsm6dsl_fifo_status2_t                     fifo_status2;
N  lsm6dsl_fifo_status3_t                     fifo_status3;
N  lsm6dsl_fifo_status4_t                     fifo_status4;
N  lsm6dsl_sensorhub13_reg_t                  sensorhub13_reg;
N  lsm6dsl_sensorhub14_reg_t                  sensorhub14_reg;
N  lsm6dsl_sensorhub15_reg_t                  sensorhub15_reg;
N  lsm6dsl_sensorhub16_reg_t                  sensorhub16_reg;
N  lsm6dsl_sensorhub17_reg_t                  sensorhub17_reg;
N  lsm6dsl_sensorhub18_reg_t                  sensorhub18_reg;
N  lsm6dsl_func_src1_t                        func_src1;
N  lsm6dsl_func_src2_t                        func_src2;
N  lsm6dsl_wrist_tilt_ia_t                    wrist_tilt_ia;
N  lsm6dsl_tap_cfg_t                          tap_cfg;
N  lsm6dsl_tap_ths_6d_t                       tap_ths_6d;
N  lsm6dsl_int_dur2_t                         int_dur2;
N  lsm6dsl_wake_up_ths_t                      wake_up_ths;
N  lsm6dsl_wake_up_dur_t                      wake_up_dur;
N  lsm6dsl_free_fall_t                        free_fall;
N  lsm6dsl_md1_cfg_t                          md1_cfg;
N  lsm6dsl_md2_cfg_t                          md2_cfg;
N  lsm6dsl_master_cmd_code_t                  master_cmd_code;
N  lsm6dsl_sens_sync_spi_error_code_t         sens_sync_spi_error_code;
N  lsm6dsl_slv0_add_t                         slv0_add;
N  lsm6dsl_slv0_subadd_t                      slv0_subadd;
N  lsm6dsl_slave0_config_t                    slave0_config;
N  lsm6dsl_slv1_add_t                         slv1_add;
N  lsm6dsl_slv1_subadd_t                      slv1_subadd;
N  lsm6dsl_slave1_config_t                    slave1_config;
N  lsm6dsl_slv2_add_t                         slv2_add;
N  lsm6dsl_slv2_subadd_t                      slv2_subadd;
N  lsm6dsl_slave2_config_t                    slave2_config;
N  lsm6dsl_slv3_add_t                         slv3_add;
N  lsm6dsl_slv3_subadd_t                      slv3_subadd;
N  lsm6dsl_slave3_config_t                    slave3_config;
N  lsm6dsl_datawrite_src_mode_sub_slv0_t      datawrite_src_mode_sub_slv0;
N  lsm6dsl_config_pedo_ths_min_t              config_pedo_ths_min;
N  lsm6dsl_pedo_deb_reg_t                     pedo_deb_reg;
N  lsm6dsl_a_wrist_tilt_mask_t                a_wrist_tilt_mask;
N  bitwise_t                                  bitwise;
N  uint8_t                                    byte;
N} lsm6dsl_reg_t;
N
N/**
N  * @}
N  *
N  */
N
Nint32_t lsm6dsl_read_reg(lsm6dsl_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                         uint16_t len);
Nint32_t lsm6dsl_write_reg(lsm6dsl_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                          uint16_t len);
N
Nextern float_t lsm6dsl_from_fs2g_to_mg(int16_t lsb);
Nextern float_t lsm6dsl_from_fs4g_to_mg(int16_t lsb);
Nextern float_t lsm6dsl_from_fs8g_to_mg(int16_t lsb);
Nextern float_t lsm6dsl_from_fs16g_to_mg(int16_t lsb);
N
Nextern float_t lsm6dsl_from_fs125dps_to_mdps(int16_t lsb);
Nextern float_t lsm6dsl_from_fs250dps_to_mdps(int16_t lsb);
Nextern float_t lsm6dsl_from_fs500dps_to_mdps(int16_t lsb);
Nextern float_t lsm6dsl_from_fs1000dps_to_mdps(int16_t lsb);
Nextern float_t lsm6dsl_from_fs2000dps_to_mdps(int16_t lsb);
N
Nextern float_t lsm6dsl_from_lsb_to_celsius(int16_t lsb);
N
Ntypedef enum {
N  LSM6DSL_2g       = 0,
N  LSM6DSL_16g      = 1,
N  LSM6DSL_4g       = 2,
N  LSM6DSL_8g       = 3,
N  LSM6DSL_XL_FS_ND = 4,  /* ERROR CODE */
N} lsm6dsl_fs_xl_t;
Nint32_t lsm6dsl_xl_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t val);
Nint32_t lsm6dsl_xl_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_ODR_OFF      =  0,
N  LSM6DSL_XL_ODR_12Hz5    =  1,
N  LSM6DSL_XL_ODR_26Hz     =  2,
N  LSM6DSL_XL_ODR_52Hz     =  3,
N  LSM6DSL_XL_ODR_104Hz    =  4,
N  LSM6DSL_XL_ODR_208Hz    =  5,
N  LSM6DSL_XL_ODR_416Hz    =  6,
N  LSM6DSL_XL_ODR_833Hz    =  7,
N  LSM6DSL_XL_ODR_1k66Hz   =  8,
N  LSM6DSL_XL_ODR_3k33Hz   =  9,
N  LSM6DSL_XL_ODR_6k66Hz   = 10,
N  LSM6DSL_XL_ODR_1Hz6     = 11,
N  LSM6DSL_XL_ODR_ND       = 12,  /* ERROR CODE */
N} lsm6dsl_odr_xl_t;
Nint32_t lsm6dsl_xl_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t val);
Nint32_t lsm6dsl_xl_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_250dps     = 0,
N  LSM6DSL_125dps     = 1,
N  LSM6DSL_500dps     = 2,
N  LSM6DSL_1000dps    = 4,
N  LSM6DSL_2000dps    = 6,
N  LSM6DSL_GY_FS_ND   = 7,    /* ERROR CODE */
N} lsm6dsl_fs_g_t;
Nint32_t lsm6dsl_gy_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t val);
Nint32_t lsm6dsl_gy_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t *val);
N
Ntypedef enum {
N  LSM6DSL_GY_ODR_OFF    =  0,
N  LSM6DSL_GY_ODR_12Hz5  =  1,
N  LSM6DSL_GY_ODR_26Hz   =  2,
N  LSM6DSL_GY_ODR_52Hz   =  3,
N  LSM6DSL_GY_ODR_104Hz  =  4,
N  LSM6DSL_GY_ODR_208Hz  =  5,
N  LSM6DSL_GY_ODR_416Hz  =  6,
N  LSM6DSL_GY_ODR_833Hz  =  7,
N  LSM6DSL_GY_ODR_1k66Hz =  8,
N  LSM6DSL_GY_ODR_3k33Hz =  9,
N  LSM6DSL_GY_ODR_6k66Hz = 10,
N  LSM6DSL_GY_ODR_ND     = 11,    /* ERROR CODE */
N} lsm6dsl_odr_g_t;
Nint32_t lsm6dsl_gy_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t val);
Nint32_t lsm6dsl_gy_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t *val);
N
Nint32_t lsm6dsl_block_data_update_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_block_data_update_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_LSb_1mg   = 0,
N  LSM6DSL_LSb_16mg  = 1,
N  LSM6DSL_WEIGHT_ND = 2,
N} lsm6dsl_usr_off_w_t;
Nint32_t lsm6dsl_xl_offset_weight_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_usr_off_w_t val);
Nint32_t lsm6dsl_xl_offset_weight_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_usr_off_w_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_HIGH_PERFORMANCE  = 0,
N  LSM6DSL_XL_NORMAL            = 1,
N  LSM6DSL_XL_PW_MODE_ND        = 2,    /* ERROR CODE */
N} lsm6dsl_xl_hm_mode_t;
Nint32_t lsm6dsl_xl_power_mode_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_xl_hm_mode_t val);
Nint32_t lsm6dsl_xl_power_mode_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_xl_hm_mode_t *val);
N
Ntypedef enum {
N  LSM6DSL_STAT_RND_DISABLE  = 0,
N  LSM6DSL_STAT_RND_ENABLE   = 1,
N  LSM6DSL_STAT_RND_ND       = 2,    /* ERROR CODE */
N} lsm6dsl_rounding_status_t;
Nint32_t lsm6dsl_rounding_on_status_set(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_rounding_status_t val);
Nint32_t lsm6dsl_rounding_on_status_get(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_rounding_status_t *val);
N
Ntypedef enum {
N  LSM6DSL_GY_HIGH_PERFORMANCE  = 0,
N  LSM6DSL_GY_NORMAL            = 1,
N  LSM6DSL_GY_PW_MODE_ND        = 2,    /* ERROR CODE */
N} lsm6dsl_g_hm_mode_t;
Nint32_t lsm6dsl_gy_power_mode_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_g_hm_mode_t val);
Nint32_t lsm6dsl_gy_power_mode_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_g_hm_mode_t *val);
N
Ntypedef struct {
N  lsm6dsl_wake_up_src_t        wake_up_src;
N  lsm6dsl_tap_src_t            tap_src;
N  lsm6dsl_d6d_src_t            d6d_src;
N  lsm6dsl_status_reg_t         status_reg;
N  lsm6dsl_func_src1_t          func_src1;
N  lsm6dsl_func_src2_t          func_src2;
N  lsm6dsl_wrist_tilt_ia_t      wrist_tilt_ia;
N  lsm6dsl_a_wrist_tilt_mask_t  a_wrist_tilt_mask;
N} lsm6dsl_all_sources_t;
Nint32_t lsm6dsl_all_sources_get(lsm6dsl_ctx_t *ctx,
N                                lsm6dsl_all_sources_t *val);
N
Nint32_t lsm6dsl_status_reg_get(lsm6dsl_ctx_t *ctx, lsm6dsl_status_reg_t *val);
N
Nint32_t lsm6dsl_xl_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_gy_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_temp_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_xl_usr_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_xl_usr_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_timestamp_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_timestamp_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_LSB_6ms4    = 0,
N  LSM6DSL_LSB_25us    = 1,
N  LSM6DSL_TS_RES_ND   = 2,    /* ERROR CODE */
N} lsm6dsl_timer_hr_t;
Nint32_t lsm6dsl_timestamp_res_set(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t val);
Nint32_t lsm6dsl_timestamp_res_get(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t *val);
N
Ntypedef enum {
N  LSM6DSL_ROUND_DISABLE            = 0,
N  LSM6DSL_ROUND_XL                 = 1,
N  LSM6DSL_ROUND_GY                 = 2,
N  LSM6DSL_ROUND_GY_XL              = 3,
N  LSM6DSL_ROUND_SH1_TO_SH6         = 4,
N  LSM6DSL_ROUND_XL_SH1_TO_SH6      = 5,
N  LSM6DSL_ROUND_GY_XL_SH1_TO_SH12  = 6,
N  LSM6DSL_ROUND_GY_XL_SH1_TO_SH6   = 7,
N  LSM6DSL_ROUND_OUT_ND             = 8,    /* ERROR CODE */
N} lsm6dsl_rounding_t;
Nint32_t lsm6dsl_rounding_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t val);
Nint32_t lsm6dsl_rounding_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t *val);
N
Nint32_t lsm6dsl_temperature_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_angular_rate_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_acceleration_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_mag_calibrated_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_fifo_raw_data_get(lsm6dsl_ctx_t *ctx, uint8_t *buffer,
N                                  uint8_t len);
N
Ntypedef enum {
N  LSM6DSL_USER_BANK   = 0,
N  LSM6DSL_BANK_A      = 4,
N  LSM6DSL_BANK_B      = 5,
N  LSM6DSL_BANK_ND     = 6,    /* ERROR CODE */
N} lsm6dsl_func_cfg_en_t;
Nint32_t lsm6dsl_mem_bank_set(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t val);
Nint32_t lsm6dsl_mem_bank_get(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t *val);
N
Ntypedef enum {
N  LSM6DSL_DRDY_LATCHED    = 0,
N  LSM6DSL_DRDY_PULSED     = 1,
N  LSM6DSL_DRDY_ND         = 2,  /* ERROR CODE */
N} lsm6dsl_drdy_pulsed_g_t;
Nint32_t lsm6dsl_data_ready_mode_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_drdy_pulsed_g_t val);
Nint32_t lsm6dsl_data_ready_mode_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_drdy_pulsed_g_t *val);
N
Nint32_t lsm6dsl_device_id_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_LSB_AT_LOW_ADD  = 0,
N  LSM6DSL_MSB_AT_LOW_ADD  = 1,
N  LSM6DSL_DATA_FMT_ND     = 2,    /* ERROR CODE */
N} lsm6dsl_ble_t;
Nint32_t lsm6dsl_data_format_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t val);
Nint32_t lsm6dsl_data_format_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t *val);
N
Nint32_t lsm6dsl_auto_increment_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_auto_increment_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_boot_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_boot_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_ST_DISABLE    = 0,
N  LSM6DSL_XL_ST_POSITIVE   = 1,
N  LSM6DSL_XL_ST_NEGATIVE   = 2,
N  LSM6DSL_XL_ST_ND         = 3,    /* ERROR CODE */
N} lsm6dsl_st_xl_t;
Nint32_t lsm6dsl_xl_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t val);
Nint32_t lsm6dsl_xl_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_GY_ST_DISABLE    = 0,
N  LSM6DSL_GY_ST_POSITIVE   = 1,
N  LSM6DSL_GY_ST_NEGATIVE   = 3,
N  LSM6DSL_GY_ST_ND         = 4,    /* ERROR CODE */
N} lsm6dsl_st_g_t;
Nint32_t lsm6dsl_gy_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t val);
Nint32_t lsm6dsl_gy_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t *val);
N
Nint32_t lsm6dsl_filter_settling_mask_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_filter_settling_mask_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_USE_SLOPE    = 0,
N  LSM6DSL_USE_HPF      = 1,
N  LSM6DSL_HP_PATH_ND   = 2,    /* ERROR CODE */
N} lsm6dsl_slope_fds_t;
Nint32_t lsm6dsl_xl_hp_path_internal_set(lsm6dsl_ctx_t *ctx,
N                                        lsm6dsl_slope_fds_t val);
Nint32_t lsm6dsl_xl_hp_path_internal_get(lsm6dsl_ctx_t *ctx,
N                                        lsm6dsl_slope_fds_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_ANA_BW_1k5Hz = 0,
N  LSM6DSL_XL_ANA_BW_400Hz = 1,
N  LSM6DSL_XL_ANA_BW_ND    = 2,    /* ERROR CODE */
N} lsm6dsl_bw0_xl_t;
Nint32_t lsm6dsl_xl_filter_analog_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_bw0_xl_t val);
Nint32_t lsm6dsl_xl_filter_analog_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_bw0_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_LP1_ODR_DIV_2 = 0,
N  LSM6DSL_XL_LP1_ODR_DIV_4 = 1,
N  LSM6DSL_XL_LP1_NA        = 2,  /* ERROR CODE */
N} lsm6dsl_lpf1_bw_sel_t;
Nint32_t lsm6dsl_xl_lp1_bandwidth_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_lpf1_bw_sel_t val);
Nint32_t lsm6dsl_xl_lp1_bandwidth_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_lpf1_bw_sel_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_50     = 0x00,
N  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_100    = 0x01,
N  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_9      = 0x02,
N  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_400    = 0x03,
N  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_50   = 0x10,
N  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_100  = 0x11,
N  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_9    = 0x12,
N  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_400  = 0x13,
N  LSM6DSL_XL_LP_NA                     = 0x20, /* ERROR CODE */
N} lsm6dsl_input_composite_t;
Nint32_t lsm6dsl_xl_lp2_bandwidth_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_input_composite_t val);
Nint32_t lsm6dsl_xl_lp2_bandwidth_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_input_composite_t *val);
N
Nint32_t lsm6dsl_xl_reference_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_xl_reference_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_HP_ODR_DIV_4      = 0x00, /* Slope filter */
N  LSM6DSL_XL_HP_ODR_DIV_100    = 0x01,
N  LSM6DSL_XL_HP_ODR_DIV_9      = 0x02,
N  LSM6DSL_XL_HP_ODR_DIV_400    = 0x03,
N  LSM6DSL_XL_HP_NA             = 0x10, /* ERROR CODE */
N} lsm6dsl_hpcf_xl_t;
Nint32_t lsm6dsl_xl_hp_bandwidth_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_hpcf_xl_t val);
Nint32_t lsm6dsl_xl_hp_bandwidth_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_hpcf_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_LP2_ONLY                    = 0x00,
N
N  LSM6DSL_HP_16mHz_LP2                = 0x80,
N  LSM6DSL_HP_65mHz_LP2                = 0x90,
N  LSM6DSL_HP_260mHz_LP2               = 0xA0,
N  LSM6DSL_HP_1Hz04_LP2                = 0xB0,
N
N  LSM6DSL_HP_DISABLE_LP1_LIGHT        = 0x0A,
N  LSM6DSL_HP_DISABLE_LP1_NORMAL       = 0x09,
N  LSM6DSL_HP_DISABLE_LP_STRONG        = 0x08,
N  LSM6DSL_HP_DISABLE_LP1_AGGRESSIVE   = 0x0B,
N
N  LSM6DSL_HP_16mHz_LP1_LIGHT          = 0x8A,
N  LSM6DSL_HP_65mHz_LP1_NORMAL         = 0x99,
N  LSM6DSL_HP_260mHz_LP1_STRONG        = 0xA8,
N  LSM6DSL_HP_1Hz04_LP1_AGGRESSIVE     = 0xBB,
N
N  LSM6DSL_HP_GY_BAND_NA               = 0xFF,    /* ERROR CODE */
N} lsm6dsl_lpf1_sel_g_t;
Nint32_t lsm6dsl_gy_band_pass_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_lpf1_sel_g_t val);
Nint32_t lsm6dsl_gy_band_pass_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_lpf1_sel_g_t *val);
N
Ntypedef enum {
N  LSM6DSL_SPI_4_WIRE  = 0,
N  LSM6DSL_SPI_3_WIRE  = 1,
N  LSM6DSL_SPI_MODE_ND = 2,    /* ERROR CODE */
N} lsm6dsl_sim_t;
Nint32_t lsm6dsl_spi_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t val);
Nint32_t lsm6dsl_spi_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t *val);
N
Ntypedef enum {
N  LSM6DSL_I2C_ENABLE   = 0,
N  LSM6DSL_I2C_DISABLE  = 1,
N  LSM6DSL_I2C_MODE_ND  = 2,    /* ERROR CODE */
N} lsm6dsl_i2c_disable_t;
Nint32_t lsm6dsl_i2c_interface_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_i2c_disable_t val);
Nint32_t lsm6dsl_i2c_interface_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_i2c_disable_t *val);
N
Ntypedef struct {
N  uint8_t int1_drdy_xl             : 1;
N  uint8_t int1_drdy_g              : 1;
N  uint8_t int1_boot                : 1;
N  uint8_t int1_fth                 : 1;
N  uint8_t int1_fifo_ovr            : 1;
N  uint8_t int1_full_flag           : 1;
N  uint8_t int1_sign_mot            : 1;
N  uint8_t int1_step_detector       : 1;
N  uint8_t int1_timer               : 1;
N  uint8_t int1_tilt                : 1;
N  uint8_t int1_6d                  : 1;
N  uint8_t int1_double_tap          : 1;
N  uint8_t int1_ff                  : 1;
N  uint8_t int1_wu                  : 1;
N  uint8_t int1_single_tap          : 1;
N  uint8_t int1_inact_state         : 1;
N  uint8_t den_drdy_int1            : 1;
N  uint8_t drdy_on_int1             : 1;
N} lsm6dsl_int1_route_t;
Nint32_t lsm6dsl_pin_int1_route_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int1_route_t val);
Nint32_t lsm6dsl_pin_int1_route_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int1_route_t *val);
N
Ntypedef struct{
N  uint8_t int2_drdy_xl             : 1;
N  uint8_t int2_drdy_g              : 1;
N  uint8_t int2_drdy_temp           : 1;
N  uint8_t int2_fth                 : 1;
N  uint8_t int2_fifo_ovr            : 1;
N  uint8_t int2_full_flag           : 1;
N  uint8_t int2_step_count_ov       : 1;
N  uint8_t int2_step_delta          : 1;
N  uint8_t int2_iron                : 1;
N  uint8_t int2_tilt                : 1;
N  uint8_t int2_6d                  : 1;
N  uint8_t int2_double_tap          : 1;
N  uint8_t int2_ff                  : 1;
N  uint8_t int2_wu                  : 1;
N  uint8_t int2_single_tap          : 1;
N  uint8_t int2_inact_state         : 1;
N  uint8_t int2_wrist_tilt          : 1;
N} lsm6dsl_int2_route_t;
Nint32_t lsm6dsl_pin_int2_route_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int2_route_t val);
Nint32_t lsm6dsl_pin_int2_route_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int2_route_t *val);
N
Ntypedef enum {
N  LSM6DSL_PUSH_PULL   = 0,
N  LSM6DSL_OPEN_DRAIN  = 1,
N  LSM6DSL_PIN_MODE_ND = 2,    /* ERROR CODE */
N} lsm6dsl_pp_od_t;
Nint32_t lsm6dsl_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t val);
Nint32_t lsm6dsl_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t *val);
N
Ntypedef enum {
N  LSM6DSL_ACTIVE_HIGH   = 0,
N  LSM6DSL_ACTIVE_LOW    = 1,
N  LSM6DSL_POLARITY_ND   = 2,    /* ERROR CODE */
N} lsm6dsl_h_lactive_t;
Nint32_t lsm6dsl_pin_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t val);
Nint32_t lsm6dsl_pin_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t *val);
N
Nint32_t lsm6dsl_all_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_all_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_INT_PULSED   = 0,
N  LSM6DSL_INT_LATCHED  = 1,
N  LSM6DSL_INT_MODE     = 2,    /* ERROR CODE */
N} lsm6dsl_lir_t;
Nint32_t lsm6dsl_int_notification_set(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t val);
Nint32_t lsm6dsl_int_notification_get(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t *val);
N
Nint32_t lsm6dsl_wkup_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_wkup_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_wkup_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_wkup_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_gy_sleep_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_gy_sleep_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_PROPERTY_DISABLE          = 0,
N  LSM6DSL_XL_12Hz5_GY_NOT_AFFECTED  = 1,
N  LSM6DSL_XL_12Hz5_GY_SLEEP         = 2,
N  LSM6DSL_XL_12Hz5_GY_PD            = 3,
N  LSM6DSL_ACT_MODE_ND               = 4,    /* ERROR CODE */
N} lsm6dsl_inact_en_t;
Nint32_t lsm6dsl_act_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t val);
Nint32_t lsm6dsl_act_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t *val);
N
Nint32_t lsm6dsl_act_sleep_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_act_sleep_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_src_get(lsm6dsl_ctx_t *ctx, lsm6dsl_tap_src_t *val);
N
Nint32_t lsm6dsl_tap_detection_on_z_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_detection_on_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_detection_on_y_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_detection_on_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_detection_on_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_detection_on_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_threshold_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_threshold_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_shock_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_shock_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_quiet_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_quiet_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_ONLY_SINGLE          = 0,
N  LSM6DSL_BOTH_SINGLE_DOUBLE   = 1,
N  LSM6DSL_TAP_MODE_ND          = 2,    /* ERROR CODE */
N} lsm6dsl_single_double_tap_t;
Nint32_t lsm6dsl_tap_mode_set(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_single_double_tap_t val);
Nint32_t lsm6dsl_tap_mode_get(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_single_double_tap_t *val);
N
Ntypedef enum {
N  LSM6DSL_ODR_DIV_2_FEED      = 0,
N  LSM6DSL_LPF2_FEED           = 1,
N  LSM6DSL_6D_FEED_ND          = 2,    /* ERROR CODE */
N} lsm6dsl_low_pass_on_6d_t;
Nint32_t lsm6dsl_6d_feed_data_set(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_low_pass_on_6d_t val);
Nint32_t lsm6dsl_6d_feed_data_get(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_low_pass_on_6d_t *val);
N
Ntypedef enum {
N  LSM6DSL_DEG_80      = 0,
N  LSM6DSL_DEG_70      = 1,
N  LSM6DSL_DEG_60      = 2,
N  LSM6DSL_DEG_50      = 3,
N  LSM6DSL_6D_TH_ND    = 4,    /* ERROR CODE */
N} lsm6dsl_sixd_ths_t;
Nint32_t lsm6dsl_6d_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t val);
Nint32_t lsm6dsl_6d_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t *val);
N
Nint32_t lsm6dsl_4d_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_4d_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_ff_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_ff_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_FF_TSH_156mg = 0,
N  LSM6DSL_FF_TSH_219mg = 1,
N  LSM6DSL_FF_TSH_250mg = 2,
N  LSM6DSL_FF_TSH_312mg = 3,
N  LSM6DSL_FF_TSH_344mg = 4,
N  LSM6DSL_FF_TSH_406mg = 5,
N  LSM6DSL_FF_TSH_469mg = 6,
N  LSM6DSL_FF_TSH_500mg = 7,
N  LSM6DSL_FF_TSH_ND    = 8,    /* ERROR CODE */
N} lsm6dsl_ff_ths_t;
Nint32_t lsm6dsl_ff_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t val);
Nint32_t lsm6dsl_ff_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t *val);
N
Nint32_t lsm6dsl_fifo_watermark_set(lsm6dsl_ctx_t *ctx, uint16_t val);
Nint32_t lsm6dsl_fifo_watermark_get(lsm6dsl_ctx_t *ctx, uint16_t *val);
N
Nint32_t lsm6dsl_fifo_data_level_get(lsm6dsl_ctx_t *ctx, uint16_t *val);
N
Nint32_t lsm6dsl_fifo_wtm_flag_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_fifo_pattern_get(lsm6dsl_ctx_t *ctx, uint16_t *val);
N
Nint32_t lsm6dsl_fifo_temp_batch_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_fifo_temp_batch_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_TRG_XL_GY_DRDY     = 0,
N  LSM6DSL_TRG_STEP_DETECT    = 1,
N  LSM6DSL_TRG_SH_DRDY        = 2,
N  LSM6DSL_TRG_SH_ND          = 3,    /* ERROR CODE */
N} lsm6dsl_trigger_fifo_t;
Nint32_t lsm6dsl_fifo_write_trigger_set(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_trigger_fifo_t val);
Nint32_t lsm6dsl_fifo_write_trigger_get(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_trigger_fifo_t *val);
N
Nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_set(lsm6dsl_ctx_t *ctx,
N                                                  uint8_t val);
Nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_get(lsm6dsl_ctx_t *ctx,
N                                                  uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_XL_DISABLE  = 0,
N  LSM6DSL_FIFO_XL_NO_DEC   = 1,
N  LSM6DSL_FIFO_XL_DEC_2    = 2,
N  LSM6DSL_FIFO_XL_DEC_3    = 3,
N  LSM6DSL_FIFO_XL_DEC_4    = 4,
N  LSM6DSL_FIFO_XL_DEC_8    = 5,
N  LSM6DSL_FIFO_XL_DEC_16   = 6,
N  LSM6DSL_FIFO_XL_DEC_32   = 7,
N  LSM6DSL_FIFO_XL_DEC_ND   = 8,    /* ERROR CODE */
N} lsm6dsl_dec_fifo_xl_t;
Nint32_t lsm6dsl_fifo_xl_batch_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_xl_t val);
Nint32_t lsm6dsl_fifo_xl_batch_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_GY_DISABLE = 0,
N  LSM6DSL_FIFO_GY_NO_DEC  = 1,
N  LSM6DSL_FIFO_GY_DEC_2   = 2,
N  LSM6DSL_FIFO_GY_DEC_3   = 3,
N  LSM6DSL_FIFO_GY_DEC_4   = 4,
N  LSM6DSL_FIFO_GY_DEC_8   = 5,
N  LSM6DSL_FIFO_GY_DEC_16  = 6,
N  LSM6DSL_FIFO_GY_DEC_32  = 7,
N  LSM6DSL_FIFO_GY_DEC_ND  = 8,    /* ERROR CODE */
N} lsm6dsl_dec_fifo_gyro_t;
Nint32_t lsm6dsl_fifo_gy_batch_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_gyro_t val);
Nint32_t lsm6dsl_fifo_gy_batch_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_gyro_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_DS3_DISABLE   = 0,
N  LSM6DSL_FIFO_DS3_NO_DEC    = 1,
N  LSM6DSL_FIFO_DS3_DEC_2     = 2,
N  LSM6DSL_FIFO_DS3_DEC_3     = 3,
N  LSM6DSL_FIFO_DS3_DEC_4     = 4,
N  LSM6DSL_FIFO_DS3_DEC_8     = 5,
N  LSM6DSL_FIFO_DS3_DEC_16    = 6,
N  LSM6DSL_FIFO_DS3_DEC_32    = 7,
N  LSM6DSL_FIFO_DS3_DEC_ND    = 8,    /* ERROR CODE */
N} lsm6dsl_dec_ds3_fifo_t;
Nint32_t lsm6dsl_fifo_dataset_3_batch_set(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds3_fifo_t val);
Nint32_t lsm6dsl_fifo_dataset_3_batch_get(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds3_fifo_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_DS4_DISABLE  = 0,
N  LSM6DSL_FIFO_DS4_NO_DEC   = 1,
N  LSM6DSL_FIFO_DS4_DEC_2    = 2,
N  LSM6DSL_FIFO_DS4_DEC_3    = 3,
N  LSM6DSL_FIFO_DS4_DEC_4    = 4,
N  LSM6DSL_FIFO_DS4_DEC_8    = 5,
N  LSM6DSL_FIFO_DS4_DEC_16   = 6,
N  LSM6DSL_FIFO_DS4_DEC_32   = 7,
N  LSM6DSL_FIFO_DS4_DEC_ND   = 8,    /* ERROR CODE */
N} lsm6dsl_dec_ds4_fifo_t;
Nint32_t lsm6dsl_fifo_dataset_4_batch_set(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds4_fifo_t val);
Nint32_t lsm6dsl_fifo_dataset_4_batch_get(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds4_fifo_t *val);
N
Nint32_t lsm6dsl_fifo_xl_gy_8bit_format_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_fifo_xl_gy_8bit_format_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_fifo_stop_on_wtm_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_fifo_stop_on_wtm_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_BYPASS_MODE           = 0,
N  LSM6DSL_FIFO_MODE             = 1,
N  LSM6DSL_STREAM_TO_FIFO_MODE   = 3,
N  LSM6DSL_BYPASS_TO_STREAM_MODE = 4,
N  LSM6DSL_STREAM_MODE           = 6,
N  LSM6DSL_FIFO_MODE_ND          = 8,    /* ERROR CODE */
N} lsm6dsl_fifo_mode_t;
Nint32_t lsm6dsl_fifo_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t val);
Nint32_t lsm6dsl_fifo_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_DISABLE   =  0,
N  LSM6DSL_FIFO_12Hz5     =  1,
N  LSM6DSL_FIFO_26Hz      =  2,
N  LSM6DSL_FIFO_52Hz      =  3,
N  LSM6DSL_FIFO_104Hz     =  4,
N  LSM6DSL_FIFO_208Hz     =  5,
N  LSM6DSL_FIFO_416Hz     =  6,
N  LSM6DSL_FIFO_833Hz     =  7,
N  LSM6DSL_FIFO_1k66Hz    =  8,
N  LSM6DSL_FIFO_3k33Hz    =  9,
N  LSM6DSL_FIFO_6k66Hz    = 10,
N  LSM6DSL_FIFO_RATE_ND   = 11,    /* ERROR CODE */
N} lsm6dsl_odr_fifo_t;
Nint32_t lsm6dsl_fifo_data_rate_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_odr_fifo_t val);
Nint32_t lsm6dsl_fifo_data_rate_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_odr_fifo_t *val);
N
Ntypedef enum {
N  LSM6DSL_DEN_ACT_LOW    = 0,
N  LSM6DSL_DEN_ACT_HIGH   = 1,
N  LSM6DSL_DEN_POL_ND     = 2,    /* ERROR CODE */
N} lsm6dsl_den_lh_t;
Nint32_t lsm6dsl_den_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t val);
Nint32_t lsm6dsl_den_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t *val);
N
Ntypedef enum {
N  LSM6DSL_DEN_DISABLE    = 0,
N  LSM6DSL_LEVEL_FIFO     = 6,
N  LSM6DSL_LEVEL_LETCHED  = 3,
N  LSM6DSL_LEVEL_TRIGGER  = 2,
N  LSM6DSL_EDGE_TRIGGER   = 4,
N  LSM6DSL_DEN_MODE_ND    = 5,    /* ERROR CODE */
N} lsm6dsl_den_mode_t;
Nint32_t lsm6dsl_den_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t val);
Nint32_t lsm6dsl_den_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t *val);
N
Ntypedef enum {
N  LSM6DSL_STAMP_IN_GY_DATA     = 0,
N  LSM6DSL_STAMP_IN_XL_DATA     = 1,
N  LSM6DSL_STAMP_IN_GY_XL_DATA  = 2,
N  LSM6DSL_DEN_STAMP_ND         = 3,    /* ERROR CODE */
N} lsm6dsl_den_xl_en_t;
Nint32_t lsm6dsl_den_enable_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t val);
Nint32_t lsm6dsl_den_enable_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t *val);
N
Nint32_t lsm6dsl_den_mark_axis_z_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_den_mark_axis_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_den_mark_axis_y_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_den_mark_axis_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_den_mark_axis_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_den_mark_axis_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_step_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_step_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_PEDO_AT_2g = 0,
N  LSM6DSL_PEDO_AT_4g = 1,
N  LSM6DSL_PEDO_FS_ND = 2,    /* ERROR CODE */
N} lsm6dsl_pedo_fs_t;
Nint32_t lsm6dsl_pedo_full_scale_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_pedo_fs_t val);
Nint32_t lsm6dsl_pedo_full_scale_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_pedo_fs_t *val);
N
Nint32_t lsm6dsl_pedo_debounce_steps_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_debounce_steps_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_timeout_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_timeout_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_steps_period_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_pedo_steps_period_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_motion_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_motion_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_motion_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_motion_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_wrist_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_wrist_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tilt_latency_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_tilt_latency_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_tilt_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_tilt_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_tilt_src_set(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_a_wrist_tilt_mask_t *val);
Nint32_t lsm6dsl_tilt_src_get(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_a_wrist_tilt_mask_t *val);
N
Nint32_t lsm6dsl_mag_soft_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_mag_soft_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_mag_hard_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_mag_hard_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_mag_soft_iron_mat_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_mag_soft_iron_mat_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_mag_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_mag_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_func_en_set(lsm6dsl_ctx_t *ctx, uint8_t val);
N
Nint32_t lsm6dsl_sh_sync_sens_frame_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_sync_sens_frame_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_RES_RATIO_2_11  = 0,
N  LSM6DSL_RES_RATIO_2_12  = 1,
N  LSM6DSL_RES_RATIO_2_13  = 2,
N  LSM6DSL_RES_RATIO_2_14  = 3,
N  LSM6DSL_RES_RATIO_ND    = 4,    /* ERROR CODE */
N} lsm6dsl_rr_t;
Nint32_t lsm6dsl_sh_sync_sens_ratio_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t val);
Nint32_t lsm6dsl_sh_sync_sens_ratio_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t *val);
N
Nint32_t lsm6dsl_sh_master_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_master_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_sh_pass_through_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_pass_through_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_EXT_PULL_UP       = 0,
N  LSM6DSL_INTERNAL_PULL_UP  = 1,
N  LSM6DSL_SH_PIN_MODE       = 2,    /* ERROR CODE */
N} lsm6dsl_pull_up_en_t;
Nint32_t lsm6dsl_sh_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t val);
Nint32_t lsm6dsl_sh_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_GY_DRDY        = 0,
N  LSM6DSL_EXT_ON_INT2_PIN   = 1,
N  LSM6DSL_SH_SYNCRO_ND      = 2,    /* ERROR CODE */
N} lsm6dsl_start_config_t;
Nint32_t lsm6dsl_sh_syncro_mode_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_start_config_t val);
Nint32_t lsm6dsl_sh_syncro_mode_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_start_config_t *val);
N
Nint32_t lsm6dsl_sh_drdy_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_drdy_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef struct {
N    lsm6dsl_sensorhub1_reg_t   sh_byte_1;
N    lsm6dsl_sensorhub2_reg_t   sh_byte_2;
N    lsm6dsl_sensorhub3_reg_t   sh_byte_3;
N    lsm6dsl_sensorhub4_reg_t   sh_byte_4;
N    lsm6dsl_sensorhub5_reg_t   sh_byte_5;
N    lsm6dsl_sensorhub6_reg_t   sh_byte_6;
N    lsm6dsl_sensorhub7_reg_t   sh_byte_7;
N    lsm6dsl_sensorhub8_reg_t   sh_byte_8;
N    lsm6dsl_sensorhub9_reg_t   sh_byte_9;
N    lsm6dsl_sensorhub10_reg_t  sh_byte_10;
N    lsm6dsl_sensorhub11_reg_t  sh_byte_11;
N    lsm6dsl_sensorhub12_reg_t  sh_byte_12;
N    lsm6dsl_sensorhub13_reg_t  sh_byte_13;
N    lsm6dsl_sensorhub14_reg_t  sh_byte_14;
N    lsm6dsl_sensorhub15_reg_t  sh_byte_15;
N    lsm6dsl_sensorhub16_reg_t  sh_byte_16;
N    lsm6dsl_sensorhub17_reg_t  sh_byte_17;
N    lsm6dsl_sensorhub18_reg_t  sh_byte_18;
N} lsm6dsl_emb_sh_read_t;
Nint32_t lsm6dsl_sh_read_data_raw_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_emb_sh_read_t *val);
N
Nint32_t lsm6dsl_sh_cmd_sens_sync_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_cmd_sens_sync_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_sh_spi_sync_error_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_spi_sync_error_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_SLV_0        = 0,
N  LSM6DSL_SLV_0_1      = 1,
N  LSM6DSL_SLV_0_1_2    = 2,
N  LSM6DSL_SLV_0_1_2_3  = 3,
N  LSM6DSL_SLV_EN_ND    = 4,    /* ERROR CODE */
N} lsm6dsl_aux_sens_on_t;
Nint32_t lsm6dsl_sh_num_of_dev_connected_set(lsm6dsl_ctx_t *ctx,
N                                            lsm6dsl_aux_sens_on_t val);
Nint32_t lsm6dsl_sh_num_of_dev_connected_get(lsm6dsl_ctx_t *ctx,
N                                            lsm6dsl_aux_sens_on_t *val);
N
Ntypedef struct{
N  uint8_t   slv0_add;
N  uint8_t   slv0_subadd;
N  uint8_t   slv0_data;
N} lsm6dsl_sh_cfg_write_t;
Nint32_t lsm6dsl_sh_cfg_write(lsm6dsl_ctx_t *ctx, lsm6dsl_sh_cfg_write_t *val);
N
Ntypedef struct{
N  uint8_t   slv_add;
N  uint8_t   slv_subadd;
N  uint8_t   slv_len;
N} lsm6dsl_sh_cfg_read_t;
Nint32_t lsm6dsl_sh_slv0_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val);
Nint32_t lsm6dsl_sh_slv1_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val);
Nint32_t lsm6dsl_sh_slv2_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val);
Nint32_t lsm6dsl_sh_slv3_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val);
N
Ntypedef enum {
N  LSM6DSL_SL0_NO_DEC   = 0,
N  LSM6DSL_SL0_DEC_2    = 1,
N  LSM6DSL_SL0_DEC_4    = 2,
N  LSM6DSL_SL0_DEC_8    = 3,
N  LSM6DSL_SL0_DEC_ND   = 4,    /* ERROR CODE */
N} lsm6dsl_slave0_rate_t;
Nint32_t lsm6dsl_sh_slave_0_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave0_rate_t val);
Nint32_t lsm6dsl_sh_slave_0_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave0_rate_t *val);
N
Ntypedef enum {
N  LSM6DSL_EACH_SH_CYCLE     = 0,
N  LSM6DSL_ONLY_FIRST_CYCLE  = 1,
N  LSM6DSL_SH_WR_MODE_ND     = 2,    /* ERROR CODE */
N} lsm6dsl_write_once_t;
Nint32_t lsm6dsl_sh_write_mode_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_write_once_t val);
Nint32_t lsm6dsl_sh_write_mode_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_write_once_t *val);
N
Ntypedef enum {
N  LSM6DSL_SL1_NO_DEC   = 0,
N  LSM6DSL_SL1_DEC_2    = 1,
N  LSM6DSL_SL1_DEC_4    = 2,
N  LSM6DSL_SL1_DEC_8    = 3,
N  LSM6DSL_SL1_DEC_ND   = 4,    /* ERROR CODE */
N} lsm6dsl_slave1_rate_t;
Nint32_t lsm6dsl_sh_slave_1_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave1_rate_t val);
Nint32_t lsm6dsl_sh_slave_1_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave1_rate_t *val);
N
Ntypedef enum {
N  LSM6DSL_SL2_NO_DEC  = 0,
N  LSM6DSL_SL2_DEC_2   = 1,
N  LSM6DSL_SL2_DEC_4   = 2,
N  LSM6DSL_SL2_DEC_8   = 3,
N  LSM6DSL_SL2_DEC_ND  = 4,    /* ERROR CODE */
N} lsm6dsl_slave2_rate_t;
Nint32_t lsm6dsl_sh_slave_2_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave2_rate_t val);
Nint32_t lsm6dsl_sh_slave_2_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave2_rate_t *val);
N
Ntypedef enum {
N  LSM6DSL_SL3_NO_DEC  = 0,
N  LSM6DSL_SL3_DEC_2   = 1,
N  LSM6DSL_SL3_DEC_4   = 2,
N  LSM6DSL_SL3_DEC_8   = 3,
N  LSM6DSL_SL3_DEC_ND  = 4,    /* ERROR CODE */
N} lsm6dsl_slave3_rate_t;
Nint32_t lsm6dsl_sh_slave_3_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave3_rate_t val);
Nint32_t lsm6dsl_sh_slave_3_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave3_rate_t *val);
N
N/**
N  * @}
N  *
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LSM6DSL_DRIVER_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl\lsm6dsl.h" 2
N#include <string.h>
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup Component Component
N * @{
N */
N
N/** @addtogroup LSM6DSL LSM6DSL
N * @{
N */
N
N/** @defgroup LSM6DSL_Exported_Types LSM6DSL Exported Types
N * @{
N */
N
Ntypedef int32_t (*LSM6DSL_Init_Func)(void);
Ntypedef int32_t (*LSM6DSL_DeInit_Func)(void);
Ntypedef int32_t (*LSM6DSL_GetTick_Func)(void);
Ntypedef int32_t (*LSM6DSL_WriteReg_Func)(uint16_t, uint16_t, uint8_t *, uint16_t);
Ntypedef int32_t (*LSM6DSL_ReadReg_Func)(uint16_t, uint16_t, uint8_t *, uint16_t);
N
Ntypedef enum
N{
N  LSM6DSL_INT1_PIN,
N  LSM6DSL_INT2_PIN,
N} LSM6DSL_SensorIntPin_t;
N
Ntypedef struct
N{
N  LSM6DSL_Init_Func          Init;
N  LSM6DSL_DeInit_Func        DeInit;
N  uint32_t                   BusType; /*0 means I2C, 1 means SPI 4-Wires, 2 means SPI-3-Wires */
N  uint8_t                    Address;
N  LSM6DSL_WriteReg_Func      WriteReg;
N  LSM6DSL_ReadReg_Func       ReadReg;
N  LSM6DSL_GetTick_Func       GetTick;
N} LSM6DSL_IO_t;
N
N
Ntypedef struct
N{
N  int16_t x;
N  int16_t y;
N  int16_t z;
N} LSM6DSL_AxesRaw_t;
N
Ntypedef struct
N{
N  int32_t x;
N  int32_t y;
N  int32_t z;
N} LSM6DSL_Axes_t;
N
Ntypedef struct
N{
N  unsigned int FreeFallStatus : 1;
N  unsigned int TapStatus : 1;
N  unsigned int DoubleTapStatus : 1;
N  unsigned int WakeUpStatus : 1;
N  unsigned int StepStatus : 1;
N  unsigned int TiltStatus : 1;
N  unsigned int D6DOrientationStatus : 1;
N  unsigned int SleepStatus : 1;
N} LSM6DSL_Event_Status_t;
N
Ntypedef struct
N{
N  LSM6DSL_IO_t        IO;
N  lsm6dsl_ctx_t       Ctx;
N  uint8_t             is_initialized;
N  uint8_t             acc_is_enabled;
N  uint8_t             gyro_is_enabled;
N  lsm6dsl_odr_xl_t    acc_odr;
N  lsm6dsl_odr_g_t     gyro_odr;
N} LSM6DSL_Object_t;
N
Ntypedef struct
N{
N  uint8_t   Acc;
N  uint8_t   Gyro;
N  uint8_t   Magneto;
N  uint8_t   LowPower;
N  uint32_t  GyroMaxFS;
N  uint32_t  AccMaxFS;
N  uint32_t  MagMaxFS;
N  float     GyroMaxOdr;
N  float     AccMaxOdr;
N  float     MagMaxOdr;
N} LSM6DSL_Capabilities_t;
N
Ntypedef struct
N{
N  int32_t (*Init)(LSM6DSL_Object_t *);
N  int32_t (*DeInit)(LSM6DSL_Object_t *);
N  int32_t (*ReadID)(LSM6DSL_Object_t *, uint8_t *);
N  int32_t (*GetCapabilities)(LSM6DSL_Object_t *, LSM6DSL_Capabilities_t *);
N} LSM6DSL_CommonDrv_t;
N
Ntypedef struct
N{
N  int32_t (*Enable)(LSM6DSL_Object_t *);
N  int32_t (*Disable)(LSM6DSL_Object_t *);
N  int32_t (*GetSensitivity)(LSM6DSL_Object_t *, float *);
N  int32_t (*GetOutputDataRate)(LSM6DSL_Object_t *, float *);
N  int32_t (*SetOutputDataRate)(LSM6DSL_Object_t *, float);
N  int32_t (*GetFullScale)(LSM6DSL_Object_t *, int32_t *);
N  int32_t (*SetFullScale)(LSM6DSL_Object_t *, int32_t);
N  int32_t (*GetAxes)(LSM6DSL_Object_t *, LSM6DSL_Axes_t *);
N  int32_t (*GetAxesRaw)(LSM6DSL_Object_t *, LSM6DSL_AxesRaw_t *);
N} LSM6DSL_ACC_Drv_t;
N
Ntypedef struct
N{
N  int32_t (*Enable)(LSM6DSL_Object_t *);
N  int32_t (*Disable)(LSM6DSL_Object_t *);
N  int32_t (*GetSensitivity)(LSM6DSL_Object_t *, float *);
N  int32_t (*GetOutputDataRate)(LSM6DSL_Object_t *, float *);
N  int32_t (*SetOutputDataRate)(LSM6DSL_Object_t *, float);
N  int32_t (*GetFullScale)(LSM6DSL_Object_t *, int32_t *);
N  int32_t (*SetFullScale)(LSM6DSL_Object_t *, int32_t);
N  int32_t (*GetAxes)(LSM6DSL_Object_t *, LSM6DSL_Axes_t *);
N  int32_t (*GetAxesRaw)(LSM6DSL_Object_t *, LSM6DSL_AxesRaw_t *);
N} LSM6DSL_GYRO_Drv_t;
N
N/**
N * @}
N */
N
N/** @defgroup LSM6DSL_Exported_Constants LSM6DSL Exported Constants
N * @{
N */
N
N#define LSM6DSL_OK                       0
N#define LSM6DSL_ERROR                   -1
N
N#define LSM6DSL_I2C_BUS                 0U
N#define LSM6DSL_SPI_4WIRES_BUS          1U
N#define LSM6DSL_SPI_3WIRES_BUS          2U
N
N#define LSM6DSL_ACC_SENSITIVITY_FS_2G   0.061f
N#define LSM6DSL_ACC_SENSITIVITY_FS_4G   0.122f
N#define LSM6DSL_ACC_SENSITIVITY_FS_8G   0.244f
N#define LSM6DSL_ACC_SENSITIVITY_FS_16G  0.488f
N
N#define LSM6DSL_GYRO_SENSITIVITY_FS_125DPS    4.375f
N#define LSM6DSL_GYRO_SENSITIVITY_FS_250DPS    8.750f
N#define LSM6DSL_GYRO_SENSITIVITY_FS_500DPS   17.500f
N#define LSM6DSL_GYRO_SENSITIVITY_FS_1000DPS  35.000f
N#define LSM6DSL_GYRO_SENSITIVITY_FS_2000DPS  70.000f
N
N/**
N * @}
N */
N
N/** @addtogroup LSM6DSL_Exported_Functions LSM6DSL Exported Functions
N * @{
N */
N
Nint32_t LSM6DSL_RegisterBusIO(LSM6DSL_Object_t *pObj, LSM6DSL_IO_t *pIO);
Nint32_t LSM6DSL_Init(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_DeInit(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ReadID(LSM6DSL_Object_t *pObj, uint8_t *Id);
Nint32_t LSM6DSL_GetCapabilities(LSM6DSL_Object_t *pObj, LSM6DSL_Capabilities_t *Capabilities);
N
Nint32_t LSM6DSL_ACC_Enable(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Disable(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_GetSensitivity(LSM6DSL_Object_t *pObj, float *Sensitivity);
Nint32_t LSM6DSL_ACC_GetOutputDataRate(LSM6DSL_Object_t *pObj, float *Odr);
Nint32_t LSM6DSL_ACC_SetOutputDataRate(LSM6DSL_Object_t *pObj, float Odr);
Nint32_t LSM6DSL_ACC_GetFullScale(LSM6DSL_Object_t *pObj, int32_t *FullScale);
Nint32_t LSM6DSL_ACC_SetFullScale(LSM6DSL_Object_t *pObj, int32_t FullScale);
Nint32_t LSM6DSL_ACC_GetAxesRaw(LSM6DSL_Object_t *pObj, LSM6DSL_AxesRaw_t *Value);
Nint32_t LSM6DSL_ACC_GetAxes(LSM6DSL_Object_t *pObj, LSM6DSL_Axes_t *Acceleration);
N
Nint32_t LSM6DSL_GYRO_Enable(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_GYRO_Disable(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_GYRO_GetSensitivity(LSM6DSL_Object_t *pObj, float *Sensitivity);
Nint32_t LSM6DSL_GYRO_GetOutputDataRate(LSM6DSL_Object_t *pObj, float *Odr);
Nint32_t LSM6DSL_GYRO_SetOutputDataRate(LSM6DSL_Object_t *pObj, float Odr);
Nint32_t LSM6DSL_GYRO_GetFullScale(LSM6DSL_Object_t *pObj, int32_t *FullScale);
Nint32_t LSM6DSL_GYRO_SetFullScale(LSM6DSL_Object_t *pObj, int32_t FullScale);
Nint32_t LSM6DSL_GYRO_GetAxesRaw(LSM6DSL_Object_t *pObj, LSM6DSL_AxesRaw_t *Value);
Nint32_t LSM6DSL_GYRO_GetAxes(LSM6DSL_Object_t *pObj, LSM6DSL_Axes_t *AngularRate);
N
Nint32_t LSM6DSL_Read_Reg(LSM6DSL_Object_t *pObj, uint8_t reg, uint8_t *Data);
Nint32_t LSM6DSL_Write_Reg(LSM6DSL_Object_t *pObj, uint8_t reg, uint8_t Data);
Nint32_t LSM6DSL_Set_Interrupt_Latch(LSM6DSL_Object_t *pObj, uint8_t Status);
N
Nint32_t LSM6DSL_ACC_Enable_Free_Fall_Detection(LSM6DSL_Object_t *pObj, LSM6DSL_SensorIntPin_t IntPin);
Nint32_t LSM6DSL_ACC_Disable_Free_Fall_Detection(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Set_Free_Fall_Threshold(LSM6DSL_Object_t *pObj, uint8_t Threshold);
Nint32_t LSM6DSL_ACC_Set_Free_Fall_Duration(LSM6DSL_Object_t *pObj, uint8_t Duration);
N
Nint32_t LSM6DSL_ACC_Enable_Pedometer(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Disable_Pedometer(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Get_Step_Count(LSM6DSL_Object_t *pObj, uint16_t *StepCount);
Nint32_t LSM6DSL_ACC_Enable_Step_Counter_Reset(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Disable_Step_Counter_Reset(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Set_Pedometer_Threshold(LSM6DSL_Object_t *pObj, uint8_t Threshold);
N
Nint32_t LSM6DSL_ACC_Enable_Tilt_Detection(LSM6DSL_Object_t *pObj, LSM6DSL_SensorIntPin_t IntPin);
Nint32_t LSM6DSL_ACC_Disable_Tilt_Detection(LSM6DSL_Object_t *pObj);
N
Nint32_t LSM6DSL_ACC_Enable_Wake_Up_Detection(LSM6DSL_Object_t *pObj, LSM6DSL_SensorIntPin_t IntPin);
Nint32_t LSM6DSL_ACC_Disable_Wake_Up_Detection(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Set_Wake_Up_Threshold(LSM6DSL_Object_t *pObj, uint8_t Threshold);
Nint32_t LSM6DSL_ACC_Set_Wake_Up_Duration(LSM6DSL_Object_t *pObj, uint8_t Duration);
N
Nint32_t LSM6DSL_ACC_Enable_Inactivity_Detection(LSM6DSL_Object_t *pObj, LSM6DSL_SensorIntPin_t IntPin);
Nint32_t LSM6DSL_ACC_Disable_Inactivity_Detection(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Set_Sleep_Duration(LSM6DSL_Object_t *pObj, uint8_t Duration);
N
Nint32_t LSM6DSL_ACC_Enable_Single_Tap_Detection(LSM6DSL_Object_t *pObj, LSM6DSL_SensorIntPin_t IntPin);
Nint32_t LSM6DSL_ACC_Disable_Single_Tap_Detection(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Enable_Double_Tap_Detection(LSM6DSL_Object_t *pObj, LSM6DSL_SensorIntPin_t IntPin);
Nint32_t LSM6DSL_ACC_Disable_Double_Tap_Detection(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Set_Tap_Threshold(LSM6DSL_Object_t *pObj, uint8_t Threshold);
Nint32_t LSM6DSL_ACC_Set_Tap_Shock_Time(LSM6DSL_Object_t *pObj, uint8_t Time);
Nint32_t LSM6DSL_ACC_Set_Tap_Quiet_Time(LSM6DSL_Object_t *pObj, uint8_t Time);
Nint32_t LSM6DSL_ACC_Set_Tap_Duration_Time(LSM6DSL_Object_t *pObj, uint8_t Time);
N
Nint32_t LSM6DSL_ACC_Enable_6D_Orientation(LSM6DSL_Object_t *pObj, LSM6DSL_SensorIntPin_t IntPin);
Nint32_t LSM6DSL_ACC_Disable_6D_Orientation(LSM6DSL_Object_t *pObj);
Nint32_t LSM6DSL_ACC_Set_6D_Orientation_Threshold(LSM6DSL_Object_t *pObj, uint8_t Threshold);
Nint32_t LSM6DSL_ACC_Get_6D_Orientation_XL(LSM6DSL_Object_t *pObj, uint8_t *XLow);
Nint32_t LSM6DSL_ACC_Get_6D_Orientation_XH(LSM6DSL_Object_t *pObj, uint8_t *XHigh);
Nint32_t LSM6DSL_ACC_Get_6D_Orientation_YL(LSM6DSL_Object_t *pObj, uint8_t *YLow);
Nint32_t LSM6DSL_ACC_Get_6D_Orientation_YH(LSM6DSL_Object_t *pObj, uint8_t *YHigh);
Nint32_t LSM6DSL_ACC_Get_6D_Orientation_ZL(LSM6DSL_Object_t *pObj, uint8_t *ZLow);
Nint32_t LSM6DSL_ACC_Get_6D_Orientation_ZH(LSM6DSL_Object_t *pObj, uint8_t *ZHigh);
N
Nint32_t LSM6DSL_ACC_Get_Event_Status(LSM6DSL_Object_t *pObj, LSM6DSL_Event_Status_t *Status);
Nint32_t LSM6DSL_ACC_Set_SelfTest(LSM6DSL_Object_t *pObj, uint8_t Val);
Nint32_t LSM6DSL_ACC_Get_DRDY_Status(LSM6DSL_Object_t *pObj, uint8_t *Status);
Nint32_t LSM6DSL_ACC_Get_Init_Status(LSM6DSL_Object_t *pObj, uint8_t *Status);
Nint32_t LSM6DSL_ACC_Set_INT1_DRDY(LSM6DSL_Object_t *pObj, uint8_t Val);
N
Nint32_t LSM6DSL_GYRO_Set_SelfTest(LSM6DSL_Object_t *pObj, uint8_t Val);
Nint32_t LSM6DSL_GYRO_Get_DRDY_Status(LSM6DSL_Object_t *pObj, uint8_t *Status);
Nint32_t LSM6DSL_GYRO_Get_Init_Status(LSM6DSL_Object_t *pObj, uint8_t *Status);
Nint32_t LSM6DSL_GYRO_Set_INT1_DRDY(LSM6DSL_Object_t *pObj, uint8_t Val);
N
Nint32_t LSM6DSL_Set_DRDY_Mode(LSM6DSL_Object_t *pObj, uint8_t Val);
N
Nint32_t LSM6DSL_FIFO_Get_Num_Samples(LSM6DSL_Object_t *pObj, uint16_t *NumSamples);
Nint32_t LSM6DSL_FIFO_Get_Full_Status(LSM6DSL_Object_t *pObj, uint8_t *Status);
Nint32_t LSM6DSL_FIFO_Set_ODR_Value(LSM6DSL_Object_t *pObj, float Odr);
Nint32_t LSM6DSL_FIFO_Set_INT1_FIFO_Full(LSM6DSL_Object_t *pObj, uint8_t Status);
Nint32_t LSM6DSL_FIFO_Set_Watermark_Level(LSM6DSL_Object_t *pObj, uint16_t Watermark);
Nint32_t LSM6DSL_FIFO_Set_Stop_On_Fth(LSM6DSL_Object_t *pObj, uint8_t Status);
Nint32_t LSM6DSL_FIFO_Set_Mode(LSM6DSL_Object_t *pObj, uint8_t Mode);
Nint32_t LSM6DSL_FIFO_Get_Pattern(LSM6DSL_Object_t *pObj, uint16_t *Pattern);
Nint32_t LSM6DSL_FIFO_Get_Data(LSM6DSL_Object_t *pObj, uint8_t *Data);
Nint32_t LSM6DSL_FIFO_Get_Empty_Status(LSM6DSL_Object_t *pObj, uint8_t *Status);
Nint32_t LSM6DSL_FIFO_Get_Overrun_Status(LSM6DSL_Object_t *pObj, uint8_t *Status);
Nint32_t LSM6DSL_FIFO_ACC_Set_Decimation(LSM6DSL_Object_t *pObj, uint8_t Decimation);
Nint32_t LSM6DSL_FIFO_ACC_Get_Axis(LSM6DSL_Object_t *pObj, int32_t *Acceleration);
Nint32_t LSM6DSL_FIFO_GYRO_Set_Decimation(LSM6DSL_Object_t *pObj, uint8_t Decimation);
Nint32_t LSM6DSL_FIFO_GYRO_Get_Axis(LSM6DSL_Object_t *pObj, int32_t *AngularVelocity);
N
N/**
N * @}
N */
N
N/** @addtogroup LSM6DSL_Exported_Variables LSM6DSL Exported Variables
N * @{
N */
N
Nextern LSM6DSL_CommonDrv_t LSM6DSL_COMMON_Driver;
Nextern LSM6DSL_ACC_Drv_t LSM6DSL_ACC_Driver;
Nextern LSM6DSL_GYRO_Drv_t LSM6DSL_GYRO_Driver;
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 116 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_motion_sensors.h" 2
N#endif
N
N#if ((USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 == 1) || (USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 == 1))
X#if ((1U == 1) || (1U == 1))
N#include "lsm303agr.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr\lsm303agr.h" 1
N/**
N ******************************************************************************
N * @file    lsm303agr.h
N * @author  MEMS Software Solutions Team
N * @brief   LSM303AGR header driver file
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef LSM303AGR_H
N#define LSM303AGR_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "lsm303agr_reg.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr\lsm303agr_reg.h" 1
N/*
N ******************************************************************************
N * @file    lsm303agr_reg.h
N * @author  Sensors Software Solution Team
N * @brief   This file contains all the functions prototypes for the
N *          lsm303agr_reg.c driver.
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright
N *      notice, this list of conditions and the following disclaimer in the
N *      documentation and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its
N *      contributors may be used to endorse or promote products derived from
N *      this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef LSM303AGR_REGS_H
N#define LSM303AGR_REGS_H
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N#include <math.h>
N
N/** @addtogroup LSM303AGR
N  * @{
N  *
N  */
N
N/** @defgroup LSM303AGR_sensors_common_types
N  * @{
N  *
N  */
N
N#ifndef MEMS_SHARED_TYPES
S#define MEMS_SHARED_TYPES
S
S/**
S  * @defgroup axisXbitXX_t
S  * @brief    These unions are useful to represent different sensors data type.
S  *           These unions are not need by the driver.
S  *
S  *           REMOVING the unions you are compliant with:
S  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
S  *
S  * @{
S  *
S  */
S
Stypedef union{
S  int16_t i16bit[3];
S  uint8_t u8bit[6];
S} axis3bit16_t;
S
Stypedef union{
S  int16_t i16bit;
S  uint8_t u8bit[2];
S} axis1bit16_t;
S
Stypedef union{
S  int32_t i32bit[3];
S  uint8_t u8bit[12];
S} axis3bit32_t;
S
Stypedef union{
S  int32_t i32bit;
S  uint8_t u8bit[4];
S} axis1bit32_t;
S
S/**
S  * @}
S  *
S  */
S
Stypedef struct{
S  uint8_t bit0       : 1;
S  uint8_t bit1       : 1;
S  uint8_t bit2       : 1;
S  uint8_t bit3       : 1;
S  uint8_t bit4       : 1;
S  uint8_t bit5       : 1;
S  uint8_t bit6       : 1;
S  uint8_t bit7       : 1;
S} bitwise_t;
S
S#define PROPERTY_DISABLE                (0U)
S#define PROPERTY_ENABLE                 (1U)
S
N#endif /* MEMS_SHARED_TYPES */
N
N/**
N  * @}
N  *
N  */
N
N  /** @addtogroup  LSM303AGR_Interfaces_Functions
N  * @brief       This section provide a set of functions used to read and
N  *              write a generic register of the device.
N  *              MANDATORY: return 0 -> no Error.
N  * @{
N  *
N  */
N
Ntypedef int32_t (*lsm303agr_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);
Ntypedef int32_t (*lsm303agr_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);
N
Ntypedef struct {
N  /** Component mandatory fields **/
N  lsm303agr_write_ptr  write_reg;
N  lsm303agr_read_ptr   read_reg;
N  /** Customizable optional pointer **/
N  void *handle;
N} lsm303agr_ctx_t;
N
N/**
N  * @}
N  *
N  */
N
N/** @defgroup lsm303agr_Infos
N  * @{
N  *
N  */
N
N  /** I2C Device Address 8 bit format**/
N#define LSM303AGR_I2C_ADD_XL       0x33U
N#define LSM303AGR_I2C_ADD_MG       0x3DU
N
N/** Device Identification (Who am I) **/
N#define LSM303AGR_ID_XL            0x33U
N#define LSM303AGR_ID_MG            0x40U
N
N/**
N  * @}
N  *
N  */
N
N#define LSM303AGR_STATUS_REG_AUX_A           0x07U
Ntypedef struct {
N  uint8_t not_used_01            : 2;
N  uint8_t tda                    : 1;
N  uint8_t not_used_02            : 3;
N  uint8_t tor                    : 1;
N  uint8_t not_used_03            : 1;
N} lsm303agr_status_reg_aux_a_t;
N
N#define LSM303AGR_OUT_TEMP_L_A               0x0CU
N#define LSM303AGR_OUT_TEMP_H_A               0x0DU
N#define LSM303AGR_INT_COUNTER_REG_A          0x0EU
N#define LSM303AGR_WHO_AM_I_A                 0x0FU
N
N#define LSM303AGR_TEMP_CFG_REG_A             0x1FU
Ntypedef struct {
N  uint8_t not_used_01            : 6;
N  uint8_t temp_en                : 2;
N} lsm303agr_temp_cfg_reg_a_t;
N
N#define LSM303AGR_CTRL_REG1_A                0x20U
Ntypedef struct {
N  uint8_t xen                    : 1;
N  uint8_t yen                    : 1;
N  uint8_t zen                    : 1;
N  uint8_t lpen                   : 1;
N  uint8_t odr                    : 4;
N} lsm303agr_ctrl_reg1_a_t;
N
N#define LSM303AGR_CTRL_REG2_A                0x21U
Ntypedef struct {
N  uint8_t hp                     : 3; /* HPCLICK + HPIS2 + HPIS1 -> HP */
N  uint8_t fds                    : 1;
N  uint8_t hpcf                   : 2;
N  uint8_t hpm                    : 2;
N} lsm303agr_ctrl_reg2_a_t;
N
N#define LSM303AGR_CTRL_REG3_A                0x22U
Ntypedef struct {
N  uint8_t not_used_01            : 1;
N  uint8_t i1_overrun             : 1;
N  uint8_t i1_wtm                 : 1;
N  uint8_t i1_drdy2               : 1;
N  uint8_t i1_drdy1               : 1;
N  uint8_t i1_aoi2                : 1;
N  uint8_t i1_aoi1                : 1;
N  uint8_t i1_click               : 1;
N} lsm303agr_ctrl_reg3_a_t;
N
N#define LSM303AGR_CTRL_REG4_A                0x23U
Ntypedef struct {
N  uint8_t spi_enable             : 1;
N  uint8_t st                     : 2;
N  uint8_t hr                     : 1;
N  uint8_t fs                     : 2;
N  uint8_t ble                    : 1;
N  uint8_t bdu                    : 1;
N} lsm303agr_ctrl_reg4_a_t;
N
N#define LSM303AGR_CTRL_REG5_A                0x24U
Ntypedef struct {
N  uint8_t d4d_int2               : 1;
N  uint8_t lir_int2               : 1;
N  uint8_t d4d_int1               : 1;
N  uint8_t lir_int1               : 1;
N  uint8_t not_used_01            : 2;
N  uint8_t fifo_en                : 1;
N  uint8_t boot                   : 1;
N} lsm303agr_ctrl_reg5_a_t;
N
N#define LSM303AGR_CTRL_REG6_A               0x25U
Ntypedef struct {
N  uint8_t not_used_01            : 1;
N  uint8_t h_lactive              : 1;
N  uint8_t not_used_02            : 1;
N  uint8_t p2_act                 : 1;
N  uint8_t boot_i2                : 1;
N  uint8_t i2_int2                : 1;
N  uint8_t i2_int1                : 1;
N  uint8_t i2_clicken             : 1;
N} lsm303agr_ctrl_reg6_a_t;
N
N#define LSM303AGR_REFERENCE_A               0x26U
N#define LSM303AGR_STATUS_REG_A              0x27U
Ntypedef struct {
N  uint8_t xda                    : 1;
N  uint8_t yda                    : 1;
N  uint8_t zda                    : 1;
N  uint8_t zyxda                  : 1;
N  uint8_t _xor                   : 1;
N  uint8_t yor                    : 1;
N  uint8_t zor                    : 1;
N  uint8_t zyxor                  : 1;
N} lsm303agr_status_reg_a_t;
N
N#define LSM303AGR_OUT_X_L_A                 0x28U
N#define LSM303AGR_OUT_X_H_A                 0x29U
N#define LSM303AGR_OUT_Y_L_A                 0x2AU
N#define LSM303AGR_OUT_Y_H_A                 0x2BU
N#define LSM303AGR_OUT_Z_L_A                 0x2CU
N#define LSM303AGR_OUT_Z_H_A                 0x2DU
N#define LSM303AGR_FIFO_CTRL_REG_A           0x2EU
Ntypedef struct {
N  uint8_t fth                    : 5;
N  uint8_t tr                     : 1;
N  uint8_t fm                     : 2;
N} lsm303agr_fifo_ctrl_reg_a_t;
N
N#define LSM303AGR_FIFO_SRC_REG_A            0x2FU
Ntypedef struct {
N  uint8_t fss                    : 5;
N  uint8_t empty                  : 1;
N  uint8_t ovrn_fifo              : 1;
N  uint8_t wtm                    : 1;
N} lsm303agr_fifo_src_reg_a_t;
N
N#define LSM303AGR_INT1_CFG_A                0x30U
Ntypedef struct {
N  uint8_t xlie                   : 1; /* or XDOWNE */
N  uint8_t xhie                   : 1; /* or XUPE */
N  uint8_t ylie                   : 1; /* or YDOWNE */
N  uint8_t yhie                   : 1; /* or YUPE */
N  uint8_t zlie                   : 1; /* or ZDOWNE */
N  uint8_t zhie                   : 1; /* or ZUPE */
N  uint8_t _6d                    : 1;
N  uint8_t aoi                    : 1;
N} lsm303agr_int1_cfg_a_t;
N
N#define LSM303AGR_INT1_SRC_A                0x31U
Ntypedef struct {
N  uint8_t xl                     : 1;
N  uint8_t xh                     : 1;
N  uint8_t yl                     : 1;
N  uint8_t yh                     : 1;
N  uint8_t zl                     : 1;
N  uint8_t zh                     : 1;
N  uint8_t ia                     : 1;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int1_src_a_t;
N
N#define LSM303AGR_INT1_THS_A                0x32U
Ntypedef struct {
N  uint8_t ths                    : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int1_ths_a_t;
N
N#define LSM303AGR_INT1_DURATION_A           0x33U
Ntypedef struct {
N  uint8_t d                      : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int1_duration_a_t;
N
N#define LSM303AGR_INT2_CFG_A                0x34U
Ntypedef struct {
N  uint8_t xlie                   : 1;
N  uint8_t xhie                   : 1;
N  uint8_t ylie                   : 1;
N  uint8_t yhie                   : 1;
N  uint8_t zlie                   : 1;
N  uint8_t zhie                   : 1;
N  uint8_t _6d                    : 1;
N  uint8_t aoi                    : 1;
N} lsm303agr_int2_cfg_a_t;
N
N#define LSM303AGR_INT2_SRC_A                0x35U
Ntypedef struct {
N  uint8_t xl                     : 1;
N  uint8_t xh                     : 1;
N  uint8_t yl                     : 1;
N  uint8_t yh                     : 1;
N  uint8_t zl                     : 1;
N  uint8_t zh                     : 1;
N  uint8_t ia                     : 1;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int2_src_a_t;
N
N#define LSM303AGR_INT2_THS_A                0x36U
Ntypedef struct {
N  uint8_t ths                    : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int2_ths_a_t;
N
N#define LSM303AGR_INT2_DURATION_A           0x37U
Ntypedef struct {
N  uint8_t d                      : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_int2_duration_a_t;
N
N#define LSM303AGR_CLICK_CFG_A               0x38U
Ntypedef struct {
N  uint8_t xs                     : 1;
N  uint8_t xd                     : 1;
N  uint8_t ys                     : 1;
N  uint8_t yd                     : 1;
N  uint8_t zs                     : 1;
N  uint8_t zd                     : 1;
N  uint8_t not_used_01            : 2;
N} lsm303agr_click_cfg_a_t;
N
N#define LSM303AGR_CLICK_SRC_A               0x39U
Ntypedef struct {
N  uint8_t x                      : 1;
N  uint8_t y                      : 1;
N  uint8_t z                      : 1;
N  uint8_t sign                   : 1;
N  uint8_t sclick                 : 1;
N  uint8_t dclick                 : 1;
N  uint8_t ia                     : 1;
N  uint8_t not_used_01            : 1;
N} lsm303agr_click_src_a_t;
N
N#define LSM303AGR_CLICK_THS_A               0x3AU
Ntypedef struct {
N  uint8_t ths                    : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_click_ths_a_t;
N
N#define LSM303AGR_TIME_LIMIT_A              0x3BU
Ntypedef struct {
N  uint8_t tli                    : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_time_limit_a_t;
N
N#define LSM303AGR_TIME_LATENCY_A            0x3CU
Ntypedef struct {
N  uint8_t tla                    : 8;
N} lsm303agr_time_latency_a_t;
N
N#define LSM303AGR_TIME_WINDOW_A             0x3DU
Ntypedef struct {
N  uint8_t tw                     : 8;
N} lsm303agr_time_window_a_t;
N
N#define LSM303AGR_ACT_THS_A                 0x3EU
Ntypedef struct {
N  uint8_t acth                   : 7;
N  uint8_t not_used_01            : 1;
N} lsm303agr_act_ths_a_t;
N
N#define LSM303AGR_ACT_DUR_A                 0x3FU
Ntypedef struct {
N  uint8_t actd                   : 8;
N} lsm303agr_act_dur_a_t;
N
N#define LSM303AGR_OFFSET_X_REG_L_M          0x45U
N#define LSM303AGR_OFFSET_X_REG_H_M          0x46U
N#define LSM303AGR_OFFSET_Y_REG_L_M          0x47U
N#define LSM303AGR_OFFSET_Y_REG_H_M          0x48U
N#define LSM303AGR_OFFSET_Z_REG_L_M          0x49U
N#define LSM303AGR_OFFSET_Z_REG_H_M          0x4AU
N#define LSM303AGR_WHO_AM_I_M                0x4FU
N#define LSM303AGR_CFG_REG_A_M               0x60U
Ntypedef struct {
N  uint8_t md                     : 2;
N  uint8_t odr                    : 2;
N  uint8_t lp                     : 1;
N  uint8_t soft_rst               : 1;
N  uint8_t reboot                 : 1;
N  uint8_t comp_temp_en           : 1;
N} lsm303agr_cfg_reg_a_m_t;
N
N#define LSM303AGR_CFG_REG_B_M               0x61U
Ntypedef struct {
N  uint8_t lpf                    : 1;
N  uint8_t set_rst                : 2; /* OFF_CANC + Set_FREQ */
N  uint8_t int_on_dataoff         : 1;
N  uint8_t off_canc_one_shot      : 1;
N  uint8_t not_used_01            : 3;
N} lsm303agr_cfg_reg_b_m_t;
N
N#define LSM303AGR_CFG_REG_C_M               0x62U
Ntypedef struct {
N  uint8_t int_mag                : 1;
N  uint8_t self_test              : 1;
N  uint8_t not_used_01            : 1;
N  uint8_t ble                    : 1;
N  uint8_t bdu                    : 1;
N  uint8_t i2c_dis                : 1;
N  uint8_t int_mag_pin            : 1;
N  uint8_t not_used_02            : 1;
N} lsm303agr_cfg_reg_c_m_t;
N
N#define LSM303AGR_INT_CRTL_REG_M            0x63U
Ntypedef struct {
N  uint8_t ien                    : 1;
N  uint8_t iel                    : 1;
N  uint8_t iea                    : 1;
N  uint8_t not_used_01            : 2;
N  uint8_t zien                   : 1;
N  uint8_t yien                   : 1;
N  uint8_t xien                   : 1;
N} lsm303agr_int_crtl_reg_m_t;
N
N#define LSM303AGR_INT_SOURCE_REG_M          0x64U
Ntypedef struct {
N  uint8_t _int                    : 1;
N  uint8_t mroi                   : 1;
N  uint8_t n_th_s_z               : 1;
N  uint8_t n_th_s_y               : 1;
N  uint8_t n_th_s_x               : 1;
N  uint8_t p_th_s_z               : 1;
N  uint8_t p_th_s_y               : 1;
N  uint8_t p_th_s_x               : 1;
N} lsm303agr_int_source_reg_m_t;
N
N#define LSM303AGR_INT_THS_L_REG_M           0x65U
N#define LSM303AGR_INT_THS_H_REG_M           0x66U
N#define LSM303AGR_STATUS_REG_M              0x67U
Ntypedef struct {
N  uint8_t xda                    : 1;
N  uint8_t yda                    : 1;
N  uint8_t zda                    : 1;
N  uint8_t zyxda                  : 1;
N  uint8_t _xor                   : 1;
N  uint8_t yor                    : 1;
N  uint8_t zor                    : 1;
N  uint8_t zyxor                  : 1;
N} lsm303agr_status_reg_m_t;
N
N#define LSM303AGR_OUTX_L_REG_M              0x68U
N#define LSM303AGR_OUTX_H_REG_M              0x69U
N#define LSM303AGR_OUTY_L_REG_M              0x6AU
N#define LSM303AGR_OUTY_H_REG_M              0x6BU
N#define LSM303AGR_OUTZ_L_REG_M              0x6CU
N#define LSM303AGR_OUTZ_H_REG_M              0x6DU
N
N/**
N  * @defgroup LSM303AGR_Register_Union
N  * @brief    This union group all the registers that has a bit-field
N  *           description.
N  *           This union is useful but not need by the driver.
N  *
N  *           REMOVING this union you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
Ntypedef union{
N  lsm303agr_status_reg_aux_a_t       status_reg_aux_a;
N  lsm303agr_temp_cfg_reg_a_t         temp_cfg_reg_a;
N  lsm303agr_ctrl_reg1_a_t            ctrl_reg1_a;
N  lsm303agr_ctrl_reg2_a_t            ctrl_reg2_a;
N  lsm303agr_ctrl_reg3_a_t            ctrl_reg3_a;
N  lsm303agr_ctrl_reg4_a_t            ctrl_reg4_a;
N  lsm303agr_ctrl_reg5_a_t            ctrl_reg5_a;
N  lsm303agr_ctrl_reg6_a_t            ctrl_reg6_a;
N  lsm303agr_status_reg_a_t           status_reg_a;
N  lsm303agr_fifo_ctrl_reg_a_t        fifo_ctrl_reg_a;
N  lsm303agr_fifo_src_reg_a_t         fifo_src_reg_a;
N  lsm303agr_int1_cfg_a_t             int1_cfg_a;
N  lsm303agr_int1_src_a_t             int1_src_a;
N  lsm303agr_int1_ths_a_t             int1_ths_a;
N  lsm303agr_int1_duration_a_t        int1_duration_a;
N  lsm303agr_int2_cfg_a_t             int2_cfg_a;
N  lsm303agr_int2_src_a_t             int2_src_a;
N  lsm303agr_int2_ths_a_t             int2_ths_a;
N  lsm303agr_int2_duration_a_t        int2_duration_a;
N  lsm303agr_click_cfg_a_t            click_cfg_a;
N  lsm303agr_click_src_a_t            click_src_a;
N  lsm303agr_click_ths_a_t            click_ths_a;
N  lsm303agr_time_limit_a_t           time_limit_a;
N  lsm303agr_time_latency_a_t         time_latency_a;
N  lsm303agr_time_window_a_t          time_window_a;
N  lsm303agr_act_ths_a_t              act_ths_a;
N  lsm303agr_act_dur_a_t              act_dur_a;
N  lsm303agr_cfg_reg_a_m_t            cfg_reg_a_m;
N  lsm303agr_cfg_reg_b_m_t            cfg_reg_b_m;
N  lsm303agr_cfg_reg_c_m_t            cfg_reg_c_m;
N  lsm303agr_int_crtl_reg_m_t         int_crtl_reg_m;
N  lsm303agr_int_source_reg_m_t       int_source_reg_m;
N  lsm303agr_status_reg_m_t           status_reg_m;
N  bitwise_t                          bitwise;
N  uint8_t                            byte;
N} lsm303agr_reg_t;
N
N/**
N  * @}
N  *
N  */
N
Nint32_t lsm303agr_read_reg(lsm303agr_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                           uint16_t len);
Nint32_t lsm303agr_write_reg(lsm303agr_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                           uint16_t len);
N
Nextern float_t lsm303agr_from_fs_2g_hr_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_4g_hr_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_8g_hr_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_16g_hr_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_lsb_hr_to_celsius(int16_t lsb);
N
Nextern float_t lsm303agr_from_fs_2g_nm_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_4g_nm_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_8g_nm_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_16g_nm_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_lsb_nm_to_celsius(int16_t lsb);
N
Nextern float_t lsm303agr_from_fs_2g_lp_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_4g_lp_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_8g_lp_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_fs_16g_lp_to_mg(int16_t lsb);
Nextern float_t lsm303agr_from_lsb_lp_to_celsius(int16_t lsb);
N
Nextern float_t lsm303agr_from_lsb_to_mgauss(int16_t lsb);
N
Nint32_t lsm303agr_temp_status_reg_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm303agr_temp_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_temp_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_temperature_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Ntypedef enum {
N  LSM303AGR_TEMP_DISABLE  = 0,
N  LSM303AGR_TEMP_ENABLE   = 3,
N} lsm303agr_temp_en_a_t;
Nint32_t lsm303agr_temperature_meas_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_temp_en_a_t val);
Nint32_t lsm303agr_temperature_meas_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_temp_en_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_HR_12bit   = 0,
N  LSM303AGR_NM_10bit   = 1,
N  LSM303AGR_LP_8bit    = 2,
N} lsm303agr_op_md_a_t;
Nint32_t lsm303agr_xl_operating_mode_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_op_md_a_t val);
Nint32_t lsm303agr_xl_operating_mode_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_op_md_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_XL_POWER_DOWN                      = 0,
N  LSM303AGR_XL_ODR_1Hz                         = 1,
N  LSM303AGR_XL_ODR_10Hz                        = 2,
N  LSM303AGR_XL_ODR_25Hz                        = 3,
N  LSM303AGR_XL_ODR_50Hz                        = 4,
N  LSM303AGR_XL_ODR_100Hz                       = 5,
N  LSM303AGR_XL_ODR_200Hz                       = 6,
N  LSM303AGR_XL_ODR_400Hz                       = 7,
N  LSM303AGR_XL_ODR_1kHz620_LP                  = 8,
N  LSM303AGR_XL_ODR_1kHz344_NM_HP_5kHz376_LP    = 9,
N} lsm303agr_odr_a_t;
Nint32_t lsm303agr_xl_data_rate_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_odr_a_t val);
Nint32_t lsm303agr_xl_data_rate_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_odr_a_t *val);
N
Nint32_t lsm303agr_xl_high_pass_on_outputs_set(lsm303agr_ctx_t *ctx,
N                                              uint8_t val);
Nint32_t lsm303agr_xl_high_pass_on_outputs_get(lsm303agr_ctx_t *ctx,
N                                              uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_AGGRESSIVE  = 0,
N  LSM303AGR_STRONG      = 1,
N  LSM303AGR_MEDIUM      = 2,
N  LSM303AGR_LIGHT       = 3,
N} lsm303agr_hpcf_a_t;
Nint32_t lsm303agr_xl_high_pass_bandwidth_set(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_hpcf_a_t val);
Nint32_t lsm303agr_xl_high_pass_bandwidth_get(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_hpcf_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_NORMAL_WITH_RST  = 0,
N  LSM303AGR_REFERENCE_MODE   = 1,
N  LSM303AGR_NORMAL           = 2,
N  LSM303AGR_AUTORST_ON_INT   = 3,
N} lsm303agr_hpm_a_t;
Nint32_t lsm303agr_xl_high_pass_mode_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_hpm_a_t val);
Nint32_t lsm303agr_xl_high_pass_mode_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_hpm_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_2g   = 0,
N  LSM303AGR_4g   = 1,
N  LSM303AGR_8g   = 2,
N  LSM303AGR_16g  = 3,
N} lsm303agr_fs_a_t;
Nint32_t lsm303agr_xl_full_scale_set(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_fs_a_t val);
Nint32_t lsm303agr_xl_full_scale_get(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_fs_a_t *val);
N
Nint32_t lsm303agr_xl_block_data_update_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val);
Nint32_t lsm303agr_xl_block_data_update_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val);
N
Nint32_t lsm303agr_xl_filter_reference_set(lsm303agr_ctx_t *ctx,
N                                          uint8_t *buff);
Nint32_t lsm303agr_xl_filter_reference_get(lsm303agr_ctx_t *ctx,
N                                          uint8_t *buff);
N
Nint32_t lsm303agr_xl_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_acceleration_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm303agr_xl_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Ntypedef enum {
N  LSM303AGR_ST_DISABLE   = 0,
N  LSM303AGR_ST_POSITIVE  = 1,
N  LSM303AGR_ST_NEGATIVE  = 2,
N} lsm303agr_st_a_t;
Nint32_t lsm303agr_xl_self_test_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_st_a_t val);
Nint32_t lsm303agr_xl_self_test_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_st_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_XL_LSB_AT_LOW_ADD = 0,
N  LSM303AGR_XL_MSB_AT_LOW_ADD = 1,
N} lsm303agr_ble_a_t;
Nint32_t lsm303agr_xl_data_format_set(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_ble_a_t val);
Nint32_t lsm303agr_xl_data_format_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_ble_a_t *val);
N
Nint32_t lsm303agr_xl_boot_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_xl_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_status_get(lsm303agr_ctx_t *ctx,
N                                lsm303agr_status_reg_a_t *val);
N
Nint32_t lsm303agr_xl_int1_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int1_cfg_a_t *val);
Nint32_t lsm303agr_xl_int1_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int1_cfg_a_t *val);
N
Nint32_t lsm303agr_xl_int1_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int1_src_a_t *val);
N
Nint32_t lsm303agr_xl_int1_gen_threshold_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_xl_int1_gen_threshold_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Nint32_t lsm303agr_xl_int1_gen_duration_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val);
Nint32_t lsm303agr_xl_int1_gen_duration_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val);
N
Nint32_t lsm303agr_xl_int2_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int2_cfg_a_t *val);
Nint32_t lsm303agr_xl_int2_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int2_cfg_a_t *val);
N
Nint32_t lsm303agr_xl_int2_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int2_src_a_t *val);
N
Nint32_t lsm303agr_xl_int2_gen_threshold_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_xl_int2_gen_threshold_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Nint32_t lsm303agr_xl_int2_gen_duration_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val);
Nint32_t lsm303agr_xl_int2_gen_duration_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_DISC_FROM_INT_GENERATOR  = 0,
N  LSM303AGR_ON_INT1_GEN              = 1,
N  LSM303AGR_ON_INT2_GEN              = 2,
N  LSM303AGR_ON_TAP_GEN               = 4,
N  LSM303AGR_ON_INT1_INT2_GEN         = 3,
N  LSM303AGR_ON_INT1_TAP_GEN          = 5,
N  LSM303AGR_ON_INT2_TAP_GEN          = 6,
N  LSM303AGR_ON_INT1_INT2_TAP_GEN     = 7,
N} lsm303agr_hp_a_t;
Nint32_t lsm303agr_xl_high_pass_int_conf_set(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_hp_a_t val);
Nint32_t lsm303agr_xl_high_pass_int_conf_get(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_hp_a_t *val);
N
Nint32_t lsm303agr_xl_pin_int1_config_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg3_a_t *val);
Nint32_t lsm303agr_xl_pin_int1_config_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg3_a_t *val);
N
Nint32_t lsm303agr_xl_int2_pin_detect_4d_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_xl_int2_pin_detect_4d_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_INT2_PULSED   = 0,
N  LSM303AGR_INT2_LATCHED  = 1,
N} lsm303agr_lir_int2_a_t;
Nint32_t lsm303agr_xl_int2pin_notification_mode_set(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int2_a_t val);
Nint32_t lsm303agr_xl_int2pin_notification_mode_get(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int2_a_t *val);
N
Nint32_t lsm303agr_xl_int1_pin_detect_4d_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_xl_int1_pin_detect_4d_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_INT1_PULSED   = 0,
N  LSM303AGR_INT1_LATCHED  = 1,
N} lsm303agr_lir_int1_a_t;
Nint32_t lsm303agr_xl_int1pin_notification_mode_set(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int1_a_t val);
Nint32_t lsm303agr_xl_int1pin_notification_mode_get(lsm303agr_ctx_t *ctx,
N                                                   lsm303agr_lir_int1_a_t *val);
N
Nint32_t lsm303agr_xl_pin_int2_config_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg6_a_t *val);
Nint32_t lsm303agr_xl_pin_int2_config_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_ctrl_reg6_a_t *val);
N
Nint32_t lsm303agr_xl_fifo_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_xl_fifo_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_fifo_watermark_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_xl_fifo_watermark_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_INT1_GEN = 0,
N  LSM303AGR_INT2_GEN = 1,
N} lsm303agr_tr_a_t;
Nint32_t lsm303agr_xl_fifo_trigger_event_set(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_tr_a_t val);
Nint32_t lsm303agr_xl_fifo_trigger_event_get(lsm303agr_ctx_t *ctx,
N                                            lsm303agr_tr_a_t *val);
N
Ntypedef enum {
N  LSM303AGR_BYPASS_MODE           = 0,
N  LSM303AGR_FIFO_MODE             = 1,
N  LSM303AGR_DYNAMIC_STREAM_MODE   = 2,
N  LSM303AGR_STREAM_TO_FIFO_MODE   = 3,
N} lsm303agr_fm_a_t;
Nint32_t lsm303agr_xl_fifo_mode_set(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_fm_a_t val);
Nint32_t lsm303agr_xl_fifo_mode_get(lsm303agr_ctx_t *ctx,
N                                   lsm303agr_fm_a_t *val);
N
Nint32_t lsm303agr_xl_fifo_status_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_fifo_src_reg_a_t *val);
N
Nint32_t lsm303agr_xl_fifo_data_level_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_fifo_empty_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_fifo_ovr_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_xl_fifo_fth_flag_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_tap_conf_set(lsm303agr_ctx_t *ctx,
N                               lsm303agr_click_cfg_a_t *val);
Nint32_t lsm303agr_tap_conf_get(lsm303agr_ctx_t *ctx,
N                               lsm303agr_click_cfg_a_t *val);
N
Nint32_t lsm303agr_tap_source_get(lsm303agr_ctx_t *ctx,
N                                lsm303agr_click_src_a_t *val);
N
Nint32_t lsm303agr_tap_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_tap_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_shock_dur_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_shock_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_quiet_dur_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_quiet_dur_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_double_tap_timeout_set(lsm303agr_ctx_t *ctx,
N                                         uint8_t val);
Nint32_t lsm303agr_double_tap_timeout_get(lsm303agr_ctx_t *ctx,
N                                         uint8_t *val);
N
Nint32_t lsm303agr_act_threshold_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_act_threshold_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_act_timeout_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_act_timeout_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_SPI_4_WIRE = 0,
N  LSM303AGR_SPI_3_WIRE = 1,
N} lsm303agr_sim_a_t;
Nint32_t lsm303agr_xl_spi_mode_set(lsm303agr_ctx_t *ctx,
N                                  lsm303agr_sim_a_t val);
Nint32_t lsm303agr_xl_spi_mode_get(lsm303agr_ctx_t *ctx,
N                                  lsm303agr_sim_a_t *val);
N
Nint32_t lsm303agr_mag_user_offset_set(lsm303agr_ctx_t *ctx,
N                                      uint8_t *buff);
Nint32_t lsm303agr_mag_user_offset_get(lsm303agr_ctx_t *ctx,
N                                      uint8_t *buff);
N
Ntypedef enum {
N  LSM303AGR_CONTINUOUS_MODE  = 0,
N  LSM303AGR_SINGLE_TRIGGER   = 1,
N  LSM303AGR_POWER_DOWN       = 2,
N} lsm303agr_md_m_t;
Nint32_t lsm303agr_mag_operating_mode_set(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_md_m_t val);
Nint32_t lsm303agr_mag_operating_mode_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_md_m_t *val);
N
Ntypedef enum {
N  LSM303AGR_MG_ODR_10Hz   = 0,
N  LSM303AGR_MG_ODR_20Hz   = 1,
N  LSM303AGR_MG_ODR_50Hz   = 2,
N  LSM303AGR_MG_ODR_100Hz  = 3,
N} lsm303agr_mg_odr_m_t;
Nint32_t lsm303agr_mag_data_rate_set(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_mg_odr_m_t val);
Nint32_t lsm303agr_mag_data_rate_get(lsm303agr_ctx_t *ctx,
N                                    lsm303agr_mg_odr_m_t *val);
N
Ntypedef enum {
N  LSM303AGR_HIGH_RESOLUTION  = 0,
N  LSM303AGR_LOW_POWER        = 1,
N} lsm303agr_lp_m_t;
Nint32_t lsm303agr_mag_power_mode_set(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_lp_m_t val);
Nint32_t lsm303agr_mag_power_mode_get(lsm303agr_ctx_t *ctx,
N                                     lsm303agr_lp_m_t *val);
N
Nint32_t lsm303agr_mag_offset_temp_comp_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t val);
Nint32_t lsm303agr_mag_offset_temp_comp_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_ODR_DIV_2  = 0,
N  LSM303AGR_ODR_DIV_4  = 1,
N} lsm303agr_lpf_m_t;
Nint32_t lsm303agr_mag_low_pass_bandwidth_set(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_lpf_m_t val);
Nint32_t lsm303agr_mag_low_pass_bandwidth_get(lsm303agr_ctx_t *ctx,
N                                             lsm303agr_lpf_m_t *val);
N
Ntypedef enum {
N  LSM303AGR_SET_SENS_ODR_DIV_63        = 0,
N  LSM303AGR_SENS_OFF_CANC_EVERY_ODR    = 1,
N  LSM303AGR_SET_SENS_ONLY_AT_POWER_ON  = 2,
N} lsm303agr_set_rst_m_t;
Nint32_t lsm303agr_mag_set_rst_mode_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_set_rst_m_t val);
Nint32_t lsm303agr_mag_set_rst_mode_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_set_rst_m_t *val);
N
Nint32_t lsm303agr_mag_set_rst_sensor_single_set(lsm303agr_ctx_t *ctx,
N                                                uint8_t val);
Nint32_t lsm303agr_mag_set_rst_sensor_single_get(lsm303agr_ctx_t *ctx,
N                                                uint8_t *val);
N
Nint32_t lsm303agr_mag_block_data_update_set(lsm303agr_ctx_t *ctx,
N                                            uint8_t val);
Nint32_t lsm303agr_mag_block_data_update_get(lsm303agr_ctx_t *ctx,
N                                            uint8_t *val);
N
Nint32_t lsm303agr_mag_data_ready_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_data_ovr_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_magnetic_raw_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm303agr_mag_device_id_get(lsm303agr_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm303agr_mag_reset_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_mag_reset_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_boot_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_mag_boot_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_self_test_set(lsm303agr_ctx_t *ctx,
N                                    uint8_t val);
Nint32_t lsm303agr_mag_self_test_get(lsm303agr_ctx_t *ctx,
N                                    uint8_t *val);
N
Ntypedef enum {
N  LSM303AGR_MG_LSB_AT_LOW_ADD  = 0,
N  LSM303AGR_MG_MSB_AT_LOW_ADD  = 1,
N} lsm303agr_ble_m_t;
Nint32_t lsm303agr_mag_data_format_set(lsm303agr_ctx_t *ctx,
N                                      lsm303agr_ble_m_t val);
Nint32_t lsm303agr_mag_data_format_get(lsm303agr_ctx_t *ctx,
N                                      lsm303agr_ble_m_t *val);
N
Nint32_t lsm303agr_mag_status_get(lsm303agr_ctx_t *ctx,
N                                 lsm303agr_status_reg_m_t *val);
N
Ntypedef enum {
N  LSM303AGR_CHECK_BEFORE  = 0,
N  LSM303AGR_CHECK_AFTER   = 1,
N} lsm303agr_int_on_dataoff_m_t;
Nint32_t lsm303agr_mag_offset_int_conf_set(lsm303agr_ctx_t *ctx,
N                                          lsm303agr_int_on_dataoff_m_t val);
Nint32_t lsm303agr_mag_offset_int_conf_get(lsm303agr_ctx_t *ctx,
N                                          lsm303agr_int_on_dataoff_m_t *val);
N
Nint32_t lsm303agr_mag_drdy_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_mag_drdy_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_int_on_pin_set(lsm303agr_ctx_t *ctx, uint8_t val);
Nint32_t lsm303agr_mag_int_on_pin_get(lsm303agr_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm303agr_mag_int_gen_conf_set(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int_crtl_reg_m_t *val);
Nint32_t lsm303agr_mag_int_gen_conf_get(lsm303agr_ctx_t *ctx,
N                                       lsm303agr_int_crtl_reg_m_t *val);
N
Nint32_t lsm303agr_mag_int_gen_source_get(lsm303agr_ctx_t *ctx,
N                                         lsm303agr_int_source_reg_m_t *val);
N
Nint32_t lsm303agr_mag_int_gen_treshold_set(lsm303agr_ctx_t *ctx,
N                                           uint8_t *buff);
Nint32_t lsm303agr_mag_int_gen_treshold_get(lsm303agr_ctx_t *ctx,
N                                           uint8_t *buff);
Ntypedef enum {
N  LSM303AGR_I2C_ENABLE   = 0,
N  LSM303AGR_I2C_DISABLE  = 1,
N} lsm303agr_i2c_dis_m_t;
Nint32_t lsm303agr_mag_i2c_interface_set(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_i2c_dis_m_t val);
Nint32_t lsm303agr_mag_i2c_interface_get(lsm303agr_ctx_t *ctx,
N                                        lsm303agr_i2c_dis_m_t *val);
N
N/**
N  * @}
N  *
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LSM303AGR_REGS_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr\lsm303agr.h" 2
N#include <string.h>
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup Component Component
N * @{
N */
N
N/** @addtogroup LSM303AGR LSM303AGR
N * @{
N */
N
N/** @defgroup LSM303AGR_Exported_Types LSM303AGR Exported Types
N * @{
N */
N
Ntypedef int32_t (*LSM303AGR_Init_Func)(void);
Ntypedef int32_t (*LSM303AGR_DeInit_Func)(void);
Ntypedef int32_t (*LSM303AGR_GetTick_Func)(void);
Ntypedef int32_t (*LSM303AGR_WriteReg_Func)(uint16_t, uint16_t, uint8_t *, uint16_t);
Ntypedef int32_t (*LSM303AGR_ReadReg_Func)(uint16_t, uint16_t, uint8_t *, uint16_t);
N
Ntypedef struct
N{
N  LSM303AGR_Init_Func          Init;
N  LSM303AGR_DeInit_Func        DeInit;
N  uint32_t                     BusType; /*0 means I2C, 1 means SPI-3-Wires */
N  uint8_t                      Address;
N  LSM303AGR_WriteReg_Func      WriteReg;
N  LSM303AGR_ReadReg_Func       ReadReg;
N  LSM303AGR_GetTick_Func       GetTick;
N} LSM303AGR_IO_t;
N
N
Ntypedef struct
N{
N  int16_t x;
N  int16_t y;
N  int16_t z;
N} LSM303AGR_AxesRaw_t;
N
Ntypedef struct
N{
N  int32_t x;
N  int32_t y;
N  int32_t z;
N} LSM303AGR_Axes_t;
N
Ntypedef struct
N{
N  LSM303AGR_IO_t        IO;
N  lsm303agr_ctx_t       Ctx;
N  uint8_t               is_initialized;
N  uint8_t               acc_is_enabled;
N  lsm303agr_odr_a_t     acc_odr;
N} LSM303AGR_ACC_Object_t;
N
Ntypedef struct
N{
N  LSM303AGR_IO_t        IO;
N  lsm303agr_ctx_t       Ctx;
N  uint8_t               is_initialized;
N  uint8_t               mag_is_enabled;
N} LSM303AGR_MAG_Object_t;
N
Ntypedef struct
N{
N  uint8_t   Acc;
N  uint8_t   Gyro;
N  uint8_t   Magneto;
N  uint8_t   LowPower;
N  uint32_t  GyroMaxFS;
N  uint32_t  AccMaxFS;
N  uint32_t  MagMaxFS;
N  float     GyroMaxOdr;
N  float     AccMaxOdr;
N  float     MagMaxOdr;
N} LSM303AGR_Capabilities_t;
N
Ntypedef struct
N{
N  int32_t (*Init)(LSM303AGR_ACC_Object_t *);
N  int32_t (*DeInit)(LSM303AGR_ACC_Object_t *);
N  int32_t (*ReadID)(LSM303AGR_ACC_Object_t *, uint8_t *);
N  int32_t (*GetCapabilities)(LSM303AGR_ACC_Object_t *, LSM303AGR_Capabilities_t *);
N} LSM303AGR_ACC_CommonDrv_t;
N
Ntypedef struct
N{
N  int32_t (*Enable)(LSM303AGR_ACC_Object_t *);
N  int32_t (*Disable)(LSM303AGR_ACC_Object_t *);
N  int32_t (*GetSensitivity)(LSM303AGR_ACC_Object_t *, float *);
N  int32_t (*GetOutputDataRate)(LSM303AGR_ACC_Object_t *, float *);
N  int32_t (*SetOutputDataRate)(LSM303AGR_ACC_Object_t *, float);
N  int32_t (*GetFullScale)(LSM303AGR_ACC_Object_t *, int32_t *);
N  int32_t (*SetFullScale)(LSM303AGR_ACC_Object_t *, int32_t);
N  int32_t (*GetAxes)(LSM303AGR_ACC_Object_t *, LSM303AGR_Axes_t *);
N  int32_t (*GetAxesRaw)(LSM303AGR_ACC_Object_t *, LSM303AGR_AxesRaw_t *);
N} LSM303AGR_ACC_Drv_t;
N
Ntypedef struct
N{
N  int32_t (*Init)(LSM303AGR_MAG_Object_t *);
N  int32_t (*DeInit)(LSM303AGR_MAG_Object_t *);
N  int32_t (*ReadID)(LSM303AGR_MAG_Object_t *, uint8_t *);
N  int32_t (*GetCapabilities)(LSM303AGR_MAG_Object_t *, LSM303AGR_Capabilities_t *);
N} LSM303AGR_MAG_CommonDrv_t;
N
Ntypedef struct
N{
N  int32_t (*Enable)(LSM303AGR_MAG_Object_t *);
N  int32_t (*Disable)(LSM303AGR_MAG_Object_t *);
N  int32_t (*GetSensitivity)(LSM303AGR_MAG_Object_t *, float *);
N  int32_t (*GetOutputDataRate)(LSM303AGR_MAG_Object_t *, float *);
N  int32_t (*SetOutputDataRate)(LSM303AGR_MAG_Object_t *, float);
N  int32_t (*GetFullScale)(LSM303AGR_MAG_Object_t *, int32_t *);
N  int32_t (*SetFullScale)(LSM303AGR_MAG_Object_t *, int32_t);
N  int32_t (*GetAxes)(LSM303AGR_MAG_Object_t *, LSM303AGR_Axes_t *);
N  int32_t (*GetAxesRaw)(LSM303AGR_MAG_Object_t *, LSM303AGR_AxesRaw_t *);
N} LSM303AGR_MAG_Drv_t;
N
N/**
N * @}
N */
N
N/** @defgroup LSM303AGR_Exported_Constants LSM303AGR Exported Constants
N * @{
N */
N
N#define LSM303AGR_OK                     0
N#define LSM303AGR_ERROR                 -1
N
N#define LSM303AGR_I2C_BUS               0U
N#define LSM303AGR_SPI_3WIRES_BUS        1U
N
N#define LSM303AGR_ACC_SENSITIVITY_FS_2G_NORMAL_MODE               3.900f  /**< Sensitivity value for 2 g full scale and normal mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_2G_HIGH_RESOLUTION_MODE      0.980f  /**< Sensitivity value for 2 g full scale and high resolution mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_2G_LOW_POWER_MODE           15.630f  /**< Sensitivity value for 2 g full scale and low power mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_4G_NORMAL_MODE               7.820f  /**< Sensitivity value for 4 g full scale and normal mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_4G_HIGH_RESOLUTION_MODE      1.950f  /**< Sensitivity value for 4 g full scale and high resolution mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_4G_LOW_POWER_MODE           31.260f  /**< Sensitivity value for 4 g full scale and low power mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_8G_NORMAL_MODE              15.630f  /**< Sensitivity value for 8 g full scale and normal mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_8G_HIGH_RESOLUTION_MODE      3.900f  /**< Sensitivity value for 8 g full scale and high resolution mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_8G_LOW_POWER_MODE           62.520f  /**< Sensitivity value for 8 g full scale and low power mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_16G_NORMAL_MODE             46.900f  /**< Sensitivity value for 16 g full scale and normal mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_16G_HIGH_RESOLUTION_MODE    11.720f  /**< Sensitivity value for 16 g full scale and high resolution mode [mg/LSB] */
N#define LSM303AGR_ACC_SENSITIVITY_FS_16G_LOW_POWER_MODE         187.580f  /**< Sensitivity value for 16 g full scale and low power mode [mg/LSB] */
N
N#define LSM303AGR_MAG_SENSITIVITY_FS_50GAUSS  1.500f  /**< Sensitivity value for 50 gauss full scale [mgauss/LSB] */
N
N/**
N * @}
N */
N
N/** @defgroup LSM303AGR_Exported_Functions LSM303AGR Exported Functions
N * @{
N */
N
Nint32_t LSM303AGR_ACC_RegisterBusIO(LSM303AGR_ACC_Object_t *pObj, LSM303AGR_IO_t *pIO);
Nint32_t LSM303AGR_ACC_Init(LSM303AGR_ACC_Object_t *pObj);
Nint32_t LSM303AGR_ACC_DeInit(LSM303AGR_ACC_Object_t *pObj);
Nint32_t LSM303AGR_ACC_ReadID(LSM303AGR_ACC_Object_t *pObj, uint8_t *Id);
Nint32_t LSM303AGR_ACC_GetCapabilities(LSM303AGR_ACC_Object_t *pObj, LSM303AGR_Capabilities_t *Capabilities);
N
Nint32_t LSM303AGR_ACC_Enable(LSM303AGR_ACC_Object_t *pObj);
Nint32_t LSM303AGR_ACC_Disable(LSM303AGR_ACC_Object_t *pObj);
Nint32_t LSM303AGR_ACC_GetSensitivity(LSM303AGR_ACC_Object_t *pObj, float *sensitivity);
Nint32_t LSM303AGR_ACC_GetOutputDataRate(LSM303AGR_ACC_Object_t *pObj, float *odr);
Nint32_t LSM303AGR_ACC_SetOutputDataRate(LSM303AGR_ACC_Object_t *pObj, float odr);
Nint32_t LSM303AGR_ACC_GetFullScale(LSM303AGR_ACC_Object_t *pObj, int32_t *fullscale);
Nint32_t LSM303AGR_ACC_SetFullScale(LSM303AGR_ACC_Object_t *pObj, int32_t fullscale);
Nint32_t LSM303AGR_ACC_GetAxes(LSM303AGR_ACC_Object_t *pObj, LSM303AGR_Axes_t *acceleration);
Nint32_t LSM303AGR_ACC_GetAxesRaw(LSM303AGR_ACC_Object_t *pObj, LSM303AGR_AxesRaw_t *value);
N
Nint32_t LSM303AGR_ACC_Read_Reg(LSM303AGR_ACC_Object_t *pObj, uint8_t reg, uint8_t *data);
Nint32_t LSM303AGR_ACC_Write_Reg(LSM303AGR_ACC_Object_t *pObj, uint8_t reg, uint8_t data);
N
Nint32_t LSM303AGR_ACC_Get_DRDY_Status(LSM303AGR_ACC_Object_t *pObj, uint8_t *status);
Nint32_t LSM303AGR_ACC_Get_Init_Status(LSM303AGR_ACC_Object_t *pObj, uint8_t *status);
N
Nint32_t LSM303AGR_MAG_RegisterBusIO(LSM303AGR_MAG_Object_t *pObj, LSM303AGR_IO_t *pIO);
Nint32_t LSM303AGR_MAG_Init(LSM303AGR_MAG_Object_t *pObj);
Nint32_t LSM303AGR_MAG_DeInit(LSM303AGR_MAG_Object_t *pObj);
Nint32_t LSM303AGR_MAG_ReadID(LSM303AGR_MAG_Object_t *pObj, uint8_t *id);
Nint32_t LSM303AGR_MAG_GetCapabilities(LSM303AGR_MAG_Object_t *pObj, LSM303AGR_Capabilities_t *Capabilities);
N
Nint32_t LSM303AGR_MAG_Enable(LSM303AGR_MAG_Object_t *pObj);
Nint32_t LSM303AGR_MAG_Disable(LSM303AGR_MAG_Object_t *pObj);
Nint32_t LSM303AGR_MAG_GetSensitivity(LSM303AGR_MAG_Object_t *pObj, float *sensitivity);
Nint32_t LSM303AGR_MAG_GetOutputDataRate(LSM303AGR_MAG_Object_t *pObj, float *odr);
Nint32_t LSM303AGR_MAG_SetOutputDataRate(LSM303AGR_MAG_Object_t *pObj, float odr);
Nint32_t LSM303AGR_MAG_GetFullScale(LSM303AGR_MAG_Object_t *pObj, int32_t *fullscale);
Nint32_t LSM303AGR_MAG_SetFullScale(LSM303AGR_MAG_Object_t *pObj, int32_t fullscale);
Nint32_t LSM303AGR_MAG_GetAxes(LSM303AGR_MAG_Object_t *pObj, LSM303AGR_Axes_t *magnetic_field);
Nint32_t LSM303AGR_MAG_GetAxesRaw(LSM303AGR_MAG_Object_t *pObj, LSM303AGR_AxesRaw_t *value);
N
Nint32_t LSM303AGR_MAG_Read_Reg(LSM303AGR_MAG_Object_t *pObj, uint8_t reg, uint8_t *data);
Nint32_t LSM303AGR_MAG_Write_Reg(LSM303AGR_MAG_Object_t *pObj, uint8_t reg, uint8_t data);
N
Nint32_t LSM303AGR_MAG_Get_DRDY_Status(LSM303AGR_MAG_Object_t *pObj, uint8_t *status);
Nint32_t LSM303AGR_MAG_Get_Init_Status(LSM303AGR_MAG_Object_t *pObj, uint8_t *status);
N
N/**
N * @}
N */
N
N/** @addtogroup LSM303AGR_Exported_Variables LSM303AGR Exported Variables
N * @{
N */
N
Nextern LSM303AGR_ACC_CommonDrv_t LSM303AGR_ACC_COMMON_Driver;
Nextern LSM303AGR_ACC_Drv_t LSM303AGR_ACC_Driver;
Nextern LSM303AGR_MAG_CommonDrv_t LSM303AGR_MAG_COMMON_Driver;
Nextern LSM303AGR_MAG_Drv_t LSM303AGR_MAG_Driver;
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 120 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_motion_sensors.h" 2
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 == 1)
X#if (0 == 1)
S#include "asm330lhh.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 == 1)
X#if (0 == 1)
S#include "iis2dlpc.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 == 1)
X#if (0 == 1)
S#include "iis2mdc.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 == 1)
X#if (0 == 1)
S#include "ism303dac.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 == 1)
X#if (0 == 1)
S#include "ism303dac.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 == 1)
X#if (0 == 1)
S#include "ism330dlc.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 == 1)
X#if (0 == 1)
S#include "lis2dh12.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 == 1)
X#if (0 == 1)
S#include "lis2dw12.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0 == 1)
X#if (0 == 1)
S#include "lis2mdl.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0 == 1)
X#if (0 == 1)
S#include "lsm6dso.h"
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LSM6DSOX_0 == 1)
X#if (0 == 1)
S#include "lsm6dsox.h"
N#endif
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup IKS01A2 IKS01A2
N * @{
N */
N
N/** @addtogroup IKS01A2_MOTION_SENSOR IKS01A2 MOTION SENSOR
N * @{
N */
N
N/** @defgroup IKS01A2_MOTION_SENSOR_Exported_Types IKS01A2 MOTION SENSOR Exported Types
N * @{
N */
N
Ntypedef struct
N{
N  int32_t x;
N  int32_t y;
N  int32_t z;
N} IKS01A2_MOTION_SENSOR_Axes_t;
N
Ntypedef struct
N{
N  int16_t x;
N  int16_t y;
N  int16_t z;
N} IKS01A2_MOTION_SENSOR_AxesRaw_t;
N
N/* Motion Sensor instance Info */
Ntypedef struct
N{
N  uint8_t  Acc;
N  uint8_t  Gyro;
N  uint8_t  Magneto;
N  uint8_t  LowPower;
N  uint32_t GyroMaxFS;
N  uint32_t AccMaxFS;
N  uint32_t MagMaxFS;
N  float    GyroMaxOdr;
N  float    AccMaxOdr;
N  float    MagMaxOdr;
N} IKS01A2_MOTION_SENSOR_Capabilities_t;
N
Ntypedef struct
N{
N  uint32_t Functions;
N} IKS01A2_MOTION_SENSOR_Ctx_t;
N
N/**
N * @}
N */
N
N/** @defgroup IKS01A2_MOTION_SENSOR_Exported_Constants IKS01A2 MOTION SENSOR Exported Constants
N * @{
N */
N
N#if (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 == 1)
X#if (1U == 1)
N#define IKS01A2_LSM6DSL_0 0
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 == 1)
X#if (1U == 1)
N#define IKS01A2_LSM303AGR_ACC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 == 1)
X#if (1U == 1)
N#define IKS01A2_LSM303AGR_MAG_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
N                                 USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0)
X#define IKS01A2_LSM303AGR_MAG_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                                  USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 == 1)
X#if (0 == 1)
S#define IKS01A2_ASM330LHH_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0)
X#define IKS01A2_ASM330LHH_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                              USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                              USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 == 1)
X#if (0 == 1)
S#define IKS01A2_IIS2DLPC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0)
X#define IKS01A2_IIS2DLPC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                             USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 == 1)
X#if (0 == 1)
S#define IKS01A2_IIS2MDC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0)
X#define IKS01A2_IIS2MDC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                            USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                            USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 == 1)
X#if (0 == 1)
S#define IKS01A2_ISM303DAC_ACC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0)
X#define IKS01A2_ISM303DAC_ACC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                                  USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                                  USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                                  USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                                  USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                                  USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 == 1)
X#if (0 == 1)
S#define IKS01A2_ISM303DAC_MAG_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 + \
S                                 USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0)
X#define IKS01A2_ISM303DAC_MAG_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                                  USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                                  USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                                  USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                                  USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                                  USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 +                                  USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 == 1)
X#if (0 == 1)
S#define IKS01A2_ISM330DLC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 + \
S                             USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0)
X#define IKS01A2_ISM330DLC_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                              USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                              USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                              USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                              USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                              USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 +                              USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 +                              USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 == 1)
X#if (0 == 1)
S#define IKS01A2_LIS2DH12_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0)
X#define IKS01A2_LIS2DH12_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                             USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                             USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                             USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 == 1)
X#if (0 == 1)
S#define IKS01A2_LIS2DW12_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0)
X#define IKS01A2_LIS2DW12_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                             USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                             USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                             USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 +                             USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0 == 1)
X#if (0 == 1)
S#define IKS01A2_LIS2MDL_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0)
X#define IKS01A2_LIS2MDL_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                            USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                            USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                            USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 +                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 +                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 +                            USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 +                            USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 +                            USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0 == 1)
X#if (0 == 1)
S#define IKS01A2_LSM6DSO_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 + \
S                           USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0)
X#define IKS01A2_LSM6DSO_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                            USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                            USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                            USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 +                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 +                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 +                            USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 +                            USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 +                            USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 +                            USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0)
N#endif
N
N#if (USE_IKS01A2_MOTION_SENSOR_LSM6DSOX_0 == 1)
X#if (0 == 1)
S#define IKS01A2_LSM6DSOX_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0 + \
S                            USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0)
X#define IKS01A2_LSM6DSOX_0 (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                             USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                             USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                             USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 +                             USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 +                             USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 +                             USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 +                             USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0 +                             USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0)
N#endif
N
N#ifndef MOTION_GYRO
N#define MOTION_GYRO             1U
N#endif
N#ifndef MOTION_ACCELERO
N#define MOTION_ACCELERO         2U
N#endif
N#ifndef MOTION_MAGNETO
N#define MOTION_MAGNETO          4U
N#endif
N
N#define IKS01A2_MOTION_FUNCTIONS_NBR    3U
N#define IKS01A2_MOTION_INSTANCES_NBR    (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0 + \
N                                         USE_IKS01A2_MOTION_SENSOR_LSM6DSOX_0)
X#define IKS01A2_MOTION_INSTANCES_NBR    (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 +                                          USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 +                                          USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 +                                          USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 +                                          USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 +                                          USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 +                                          USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 +                                          USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 +                                          USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 +                                          USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 +                                          USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 +                                          USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0 +                                          USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0 +                                          USE_IKS01A2_MOTION_SENSOR_LSM6DSOX_0)
N
N#if (IKS01A2_MOTION_INSTANCES_NBR == 0)
X#if ((1U + 1U + 1U + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0) == 0)
S#error "No motion sensor instance has been selected"
N#endif
N
N/**
N * @}
N */
N
N/** @addtogroup IKS01A2_MOTION_SENSOR_Exported_Functions IKS01A2_MOTION_SENSOR Exported Functions
N * @{
N */
N
Nint32_t IKS01A2_MOTION_SENSOR_Init(uint32_t Instance, uint32_t Functions);
Nint32_t IKS01A2_MOTION_SENSOR_DeInit(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_GetCapabilities(uint32_t Instance, IKS01A2_MOTION_SENSOR_Capabilities_t *Capabilities);
Nint32_t IKS01A2_MOTION_SENSOR_ReadID(uint32_t Instance, uint8_t *Id);
Nint32_t IKS01A2_MOTION_SENSOR_Enable(uint32_t Instance, uint32_t Function);
Nint32_t IKS01A2_MOTION_SENSOR_Disable(uint32_t Instance, uint32_t Function);
Nint32_t IKS01A2_MOTION_SENSOR_GetAxes(uint32_t Instance, uint32_t Function, IKS01A2_MOTION_SENSOR_Axes_t *Axes);
Nint32_t IKS01A2_MOTION_SENSOR_GetAxesRaw(uint32_t Instance, uint32_t Function, IKS01A2_MOTION_SENSOR_AxesRaw_t *Axes);
Nint32_t IKS01A2_MOTION_SENSOR_GetSensitivity(uint32_t Instance, uint32_t Function, float *Sensitivity);
Nint32_t IKS01A2_MOTION_SENSOR_GetOutputDataRate(uint32_t Instance, uint32_t Function, float *Odr);
Nint32_t IKS01A2_MOTION_SENSOR_SetOutputDataRate(uint32_t Instance, uint32_t Function, float Odr);
Nint32_t IKS01A2_MOTION_SENSOR_GetFullScale(uint32_t Instance, uint32_t Function, int32_t *Fullscale);
Nint32_t IKS01A2_MOTION_SENSOR_SetFullScale(uint32_t Instance, uint32_t Function, int32_t Fullscale);
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* IKS01A2_MOTION_SENSOR_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 71 "..\Inc\main.h" 2
N#include "iks01a2_motion_sensors_ex.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_motion_sensors_ex.h" 1
N/**
N ******************************************************************************
N * @file    iks01a2_motion_sensors_ex.h
N * @author  MEMS Software Solutions Team
N * @brief   This file provides a set of extended functions needed to manage the motion sensors
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics International N.V.
N * All rights reserved.</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted, provided that the following conditions are met:
N *
N * 1. Redistribution of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. Neither the name of STMicroelectronics nor the names of other
N *    contributors to this software may be used to endorse or promote products
N *    derived from this software without specific written permission.
N * 4. This software, including modifications and/or derivative works of this
N *    software, must execute solely and exclusively on microcontroller or
N *    microprocessor devices manufactured by or for STMicroelectronics.
N * 5. Redistribution and use of this software other than as permitted under
N *    this license is void and will automatically terminate your rights under
N *    this license.
N *
N * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
N * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
N * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
N * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
N * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef IKS01A2_MOTION_SENSOR_EX_H
N#define IKS01A2_MOTION_SENSOR_EX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "iks01a2_motion_sensors.h"
N
N/** @addtogroup BSP BSP
N * @{
N */
N
N/** @addtogroup IKS01A2 IKS01A2
N * @{
N */
N
N/** @addtogroup IKS01A2_MOTION_SENSOR_EX IKS01A2 MOTION SENSOR EX
N * @{
N */
N
N/** @defgroup IKS01A2_MOTION_SENSOR_EX_Exported_Types IKS01A2 MOTION SENSOR EX Exported Types
N * @{
N */
N
Ntypedef enum
N{
N  IKS01A2_MOTION_SENSOR_INT1_PIN = 0,
N  IKS01A2_MOTION_SENSOR_INT2_PIN
N} IKS01A2_MOTION_SENSOR_IntPin_t;
N
Ntypedef struct
N{
N  unsigned int FreeFallStatus : 1;
N  unsigned int TapStatus : 1;
N  unsigned int DoubleTapStatus : 1;
N  unsigned int WakeUpStatus : 1;
N  unsigned int StepStatus : 1;
N  unsigned int TiltStatus : 1;
N  unsigned int D6DOrientationStatus : 1;
N  unsigned int SleepStatus : 1;
N} IKS01A2_MOTION_SENSOR_Event_Status_t;
N
N/**
N * @}
N */
N
N/** @addtogroup IKS01A2_MOTION_SENSOR_EX_Exported_Functions IKS01A2 MOTION SENSOR EX Exported Functions
N * @{
N */
N
Nint32_t IKS01A2_MOTION_SENSOR_Enable_HP_Filter(uint32_t Instance, uint8_t CutOff);
Nint32_t IKS01A2_MOTION_SENSOR_Set_INT1_DRDY(uint32_t Instance,uint8_t Status);
Nint32_t IKS01A2_MOTION_SENSOR_Set_INT2_DRDY(uint32_t Instance,uint8_t Status);
Nint32_t IKS01A2_MOTION_SENSOR_DRDY_Set_Mode(uint32_t Instance,uint8_t Status);
Nint32_t IKS01A2_MOTION_SENSOR_Clear_DRDY(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Enable_6D_Orientation(uint32_t Instance, IKS01A2_MOTION_SENSOR_IntPin_t IntPin);
Nint32_t IKS01A2_MOTION_SENSOR_Disable_6D_Orientation(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Set_6D_Orientation_Threshold(uint32_t Instance, uint8_t Threshold);
Nint32_t IKS01A2_MOTION_SENSOR_Enable_Free_Fall_Detection(uint32_t Instance, IKS01A2_MOTION_SENSOR_IntPin_t IntPin);
Nint32_t IKS01A2_MOTION_SENSOR_Disable_Free_Fall_Detection(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Free_Fall_Threshold(uint32_t Instance, uint8_t Threshold);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Free_Fall_Duration(uint32_t Instance, uint8_t Duration);
Nint32_t IKS01A2_MOTION_SENSOR_Enable_Pedometer(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Disable_Pedometer(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Pedometer_Threshold(uint32_t Instance, uint8_t Threshold);
Nint32_t IKS01A2_MOTION_SENSOR_Reset_Step_Counter(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Enable_Single_Tap_Detection(uint32_t Instance, IKS01A2_MOTION_SENSOR_IntPin_t IntPin);
Nint32_t IKS01A2_MOTION_SENSOR_Disable_Single_Tap_Detection(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Enable_Double_Tap_Detection(uint32_t Instance, IKS01A2_MOTION_SENSOR_IntPin_t IntPin);
Nint32_t IKS01A2_MOTION_SENSOR_Disable_Double_Tap_Detection(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Tap_Threshold(uint32_t Instance, uint8_t Threshold);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Tap_Shock_Time(uint32_t Instance, uint8_t Time);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Tap_Quiet_Time(uint32_t Instance, uint8_t Time);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Tap_Duration_Time(uint32_t Instance, uint8_t Time);
Nint32_t IKS01A2_MOTION_SENSOR_Enable_Tilt_Detection(uint32_t Instance, IKS01A2_MOTION_SENSOR_IntPin_t IntPin);
Nint32_t IKS01A2_MOTION_SENSOR_Disable_Tilt_Detection(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Enable_Wake_Up_Detection(uint32_t Instance, IKS01A2_MOTION_SENSOR_IntPin_t IntPin);
Nint32_t IKS01A2_MOTION_SENSOR_Disable_Wake_Up_Detection(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Wake_Up_Threshold(uint32_t Instance, uint8_t Threshold);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Wake_Up_Duration(uint32_t Instance, uint8_t Duration);
Nint32_t IKS01A2_MOTION_SENSOR_Enable_Inactivity_Detection(uint32_t Instance, IKS01A2_MOTION_SENSOR_IntPin_t IntPin);
Nint32_t IKS01A2_MOTION_SENSOR_Disable_Inactivity_Detection(uint32_t Instance);
Nint32_t IKS01A2_MOTION_SENSOR_Set_Sleep_Duration(uint32_t Instance, uint8_t Duration);
Nint32_t IKS01A2_MOTION_SENSOR_Get_Event_Status(uint32_t Instance, IKS01A2_MOTION_SENSOR_Event_Status_t *Status);
Nint32_t IKS01A2_MOTION_SENSOR_Get_DRDY_Status(uint32_t Instance, uint32_t Function, uint8_t *Status);
Nint32_t IKS01A2_MOTION_SENSOR_Get_6D_Orientation_XL(uint32_t Instance, uint8_t *xl);
Nint32_t IKS01A2_MOTION_SENSOR_Get_6D_Orientation_XH(uint32_t Instance, uint8_t *xh);
Nint32_t IKS01A2_MOTION_SENSOR_Get_6D_Orientation_YL(uint32_t Instance, uint8_t *yl);
Nint32_t IKS01A2_MOTION_SENSOR_Get_6D_Orientation_YH(uint32_t Instance, uint8_t *yh);
Nint32_t IKS01A2_MOTION_SENSOR_Get_6D_Orientation_ZL(uint32_t Instance, uint8_t *zl);
Nint32_t IKS01A2_MOTION_SENSOR_Get_6D_Orientation_ZH(uint32_t Instance, uint8_t *zh);
Nint32_t IKS01A2_MOTION_SENSOR_Get_Step_Count(uint32_t Instance, uint16_t *StepCount);
Nint32_t IKS01A2_MOTION_SENSOR_Read_Register(uint32_t Instance, uint8_t Reg, uint8_t *Data);
Nint32_t IKS01A2_MOTION_SENSOR_Write_Register(uint32_t Instance, uint8_t Reg, uint8_t Data);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Get_Num_Samples(uint32_t Instance, uint16_t *NumSamples);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Get_Full_Status(uint32_t Instance, uint8_t *Status);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Set_Decimation(uint32_t Instance, uint32_t Function, uint8_t Decimation);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Set_ODR_Value(uint32_t Instance, float Odr);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Set_INT1_FIFO_Full(uint32_t Instance, uint8_t Status);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Set_INT2_FIFO_Full(uint32_t Instance, uint8_t Status);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Set_Watermark_Level(uint32_t Instance, uint16_t Watermark);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Set_Stop_On_Fth(uint32_t Instance, uint8_t Status);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Set_Mode(uint32_t Instance, uint8_t Mode);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Get_Pattern(uint32_t Instance, uint16_t *Pattern);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Get_Axis(uint32_t Instance, uint32_t Function, int32_t *Data);
Nint32_t IKS01A2_MOTION_SENSOR_FIFO_Get_Data_Word(uint32_t Instance,uint32_t Function,int16_t *Data);
Nint32_t IKS01A2_MOTION_SENSOR_Set_SelfTest(uint32_t Instance, uint32_t Function, uint8_t Status);
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* IKS01A2_MOTION_SENSOR_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 72 "..\Inc\main.h" 2
N#endif
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N#define ALGO_FREQ       50U               /* Algorithm frequency [Hz] */
N#define ALGO_PERIOD  (1000U / ALGO_FREQ)  /* Algorithm period [ms] */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported defines ----------------------------------------------------------*/
N#if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
X#if ((1L) || (0L) || (0L))
N
N/* Definition for TIMx clock resources : Timer used for algorithm */
N#define TIM_ALGO                          TIM3
N#define TIM_ALGO_CLK_ENABLE               __TIM3_CLK_ENABLE
N#define TIM_ALGO_CLK_DISABLE              __TIM3_CLK_DISABLE
N
N/* Definition for TIMx's NVIC */
N#define TIM_ALGO_IRQn                     TIM3_IRQn
N#define TIM_ALGO_IRQHandler               TIM3_IRQHandler
N
N#elif (defined (USE_STM32L0XX_NUCLEO))
S
S/* Definition for TIMx clock resources : Timer used for algorithm */
S#define TIM_ALGO                          TIM2
S#define TIM_ALGO_CLK_ENABLE               __TIM2_CLK_ENABLE
S#define TIM_ALGO_CLK_DISABLE              __TIM2_CLK_DISABLE
S
S/* Definition for TIMx's NVIC */
S#define TIM_ALGO_IRQn                     TIM2_IRQn
S#define TIM_ALGO_IRQHandler               TIM2_IRQHandler
S
S#else
S#error Not supported platform
N#endif
N
N/* Enable sensor masks */
N#define PRESSURE_SENSOR                         0x00000001U
N#define TEMPERATURE_SENSOR                      0x00000002U
N#define HUMIDITY_SENSOR                         0x00000004U
N#define UV_SENSOR                               0x00000008U /* for future use */
N#define ACCELEROMETER_SENSOR                    0x00000010U
N#define GYROSCOPE_SENSOR                        0x00000020U
N#define MAGNETIC_SENSOR                         0x00000040U
N
N/* Extern variables ----------------------------------------------------------*/
Nextern uint32_t SensorsEnabled;
Nextern TIM_HandleTypeDef AlgoTimHandle;
N
Nextern IKS01A2_MOTION_SENSOR_Axes_t AccValue;
Nextern IKS01A2_MOTION_SENSOR_Axes_t MagValue;
Nextern IKS01A2_MOTION_SENSOR_Axes_t MagValueComp;
N
Nextern int UseLSI;
N
N/* Exported functions --------------------------------------------------------*/
Nvoid Error_Handler(void);
Nvoid RTC_DateRegulate(uint8_t y, uint8_t m, uint8_t d, uint8_t dw);
Nvoid RTC_TimeRegulate(uint8_t hh, uint8_t mm, uint8_t ss);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* MAIN_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 53 "..\Src\main.c" 2
N#include "com.h"
L 1 "..\Inc\com.h" 1
N/**
N *******************************************************************************
N * @file    com.h
N * @author  MEMS Software Solutions Team
N * @brief   header for com.c
N *******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N *******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef COM_H
N#define COM_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "serial_protocol.h"
L 1 "..\Inc\serial_protocol.h" 1
N/**
N *******************************************************************************
N * @file    serial_protocol.h
N * @author  MEMS Software Solutions Team
N * @brief   header for serial_protocol.c
N *******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N *******************************************************************************
N */
N
N/* Define to prevent recursive inclusion ------------------------------------ */
N#ifndef SERIAL_PROTOCOL_H
N#define SERIAL_PROTOCOL_H
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N
N/* Exported defines --------------------------------------------------------*/
N#define TMsg_EOF                0xF0
N#define TMsg_BS                 0xF1
N#define TMsg_BS_EOF             0xF2
N
N#ifdef USE_USB_OTG_HS
S#define TMsg_MaxLen             512
N#else
N#define TMsg_MaxLen             256
N#endif
N
N/* Exported types ------------------------------------------------------------*/
N/**
N * @brief  Serial message structure definition
N */
Ntypedef struct
N{
N  uint32_t Len;
N  uint8_t Data[TMsg_MaxLen];
X  uint8_t Data[256];
N} TMsg;
N
N/* Exported macro ------------------------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nint ByteStuffCopyByte(uint8_t *Dest, uint8_t Source);
Nint ReverseByteStuffCopyByte2(uint8_t Source0, uint8_t Source1, uint8_t *Dest);
Nint ByteStuffCopy(uint8_t *Dest, TMsg *Source);
Nint ReverseByteStuffCopyByte(uint8_t *Source, uint8_t *Dest);
Nint ReverseByteStuffCopy(TMsg *Dest, uint8_t *Source);
Nvoid CHK_ComputeAndAdd(TMsg *Msg);
Nint CHK_CheckAndRemove(TMsg *Msg);
Nuint32_t Deserialize(uint8_t *Source, uint32_t Len);
Nint32_t Deserialize_s32(uint8_t *Source, uint32_t Len);
Nvoid Serialize(uint8_t *Dest, uint32_t Source, uint32_t Len);
Nvoid Serialize_s32(uint8_t *Dest, int32_t Source, uint32_t Len);
Nvoid FloatToArray(uint8_t *Dest, float Data);
N
N#endif /* SERIAL_PROTOCOL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 46 "..\Inc\com.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/**
N * @brief  Serial message engine structure definition
N */
Ntypedef struct
N{
N  uint8_t *pDMA_Buffer;
N  uint16_t StartOfMsg;
N} TUart_Engine;
N
N/* Exported defines ----------------------------------------------------------*/
N#define UART_RxBufferSize (2 * TMsg_MaxLen)
N#define UART_TxBufferSize (2 * TMsg_MaxLen)
N
N/* User can use this section to tailor USARTx/UARTx instance used and associated resources */
N/* Definition for USARTx clock resources */
N#define USARTx                           USART2
N#define USARTx_CLK_ENABLE()              __USART2_CLK_ENABLE();
N#define DMAx_CLK_ENABLE()                __DMA1_CLK_ENABLE()
N#define USARTx_RX_GPIO_CLK_ENABLE()      __GPIOA_CLK_ENABLE()
N#define USARTx_TX_GPIO_CLK_ENABLE()      __GPIOA_CLK_ENABLE()
N
N#define USARTx_FORCE_RESET()             __USART2_FORCE_RESET()
N#define USARTx_RELEASE_RESET()           __USART2_RELEASE_RESET()
N
N/* Definition for USARTx Pins */
N#define USARTx_TX_PIN                    GPIO_PIN_2
N#define USARTx_TX_GPIO_PORT              GPIOA
N#define USARTx_RX_PIN                    GPIO_PIN_3
N#define USARTx_RX_GPIO_PORT              GPIOA
N
N/* Exported variables --------------------------------------------------------*/
Nextern volatile uint8_t UartRxBuffer[UART_RxBufferSize];
Xextern volatile uint8_t UartRxBuffer[(2 * 256)];
Nextern volatile uint32_t UsartBaudRate;
Nextern TUart_Engine UartEngine;
N
N/* Exported macro ------------------------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
Nvoid USARTConfig(void);
Nint UART_ReceivedMSG(TMsg *Msg);
Nvoid UART_SendMsg(TMsg *Msg);
Nvoid USART_DMA_Configuration(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* COM_H */
L 54 "..\Src\main.c" 2
N#include "DemoSerial.h"
L 1 "..\Inc\DemoSerial.h" 1
N/**
N *******************************************************************************
N * @file    DemoSerial.h
N * @author  MEMS Software Solutions Team
N * @brief   Header for DemoSerial.c
N *******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N *******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef DEMO_SERIAL_H
N#define DEMO_SERIAL_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "cube_hal.h"
N#include "serial_protocol.h"
N#include "Serial_CMD.h"
L 1 "..\Inc\Serial_CMD.h" 1
N/**
N *******************************************************************************
N * @file    Serial_CMD.h
N * @author  MEMS Software Solutions Team
N * @brief   This file contains serial commands code
N *******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N *******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef SERIAL_CMD_H
N#define SERIAL_CMD_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Exported constants --------------------------------------------------------*/
N
N/* GENERIC  CMD  (0x00 - 0x0F) -------------------*/
N#define CMD_Ping                       0x01
N#define CMD_Read_PresString            0x02
N#define CMD_NACK                       0x03
N#define CMD_CheckModeSupport           0x04
N#define CMD_UploadXX                   0x05
N#define CMD_Start_Data_Streaming       0x08
N#define CMD_Stop_Data_Streaming        0x09
N
N#define CMD_Set_DateTime               0x0C
N#define CMD_Enter_DFU_Mode             0x0E
N#define CMD_Reset                      0x0F
N#define CMD_Reply_Add                  0x80U
N
N/* ENVIRONMENTAL  CMD  (0x60 - 0x6F) -------------*/
N#define CMD_PRESSURE_Init              0x60
N#define CMD_HUMIDITY_TEMPERATURE_Init  0x62
N
N/* INERTIAL  CMD  (0x70 - 0x7F) ------------------*/
N#define CMD_ACCELERO_GYRO_Init         0x76
N#define CMD_MAGNETO_Init               0x7A
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SERIAL_CMD_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 48 "..\Inc\DemoSerial.h" 2
N
N/* Private defines -----------------------------------------------------------*/
N#define SENDER_UART  0x01
N#define SENDER_USB   0x02
N#define SENDER_SPI   0x03
N
N#define DEV_ADDR                        50U
N#define I2C_DATA_MAX_LENGTH_BYTES       16
N#define STREAMING_MSG_LENGTH           125
N#define MIN(A,B) ((A)<(B)?(A):(B))
N
N/* Exported variables --------------------------------------------------------*/
Nextern volatile uint8_t DataLoggerActive;
N
N/* Exported functions ------------------------------------------------------- */
Nint HandleMSG(TMsg *Msg);
N
N/* Private functions ------------------------------------------------------- */
Nvoid BUILD_REPLY_HEADER(TMsg *Msg);
Nvoid INIT_STREAMING_MSG(TMsg *Msg);
Nvoid BUILD_NACK_HEADER(TMsg *Msg);
Nvoid INIT_STREAMING_HEADER(TMsg *Msg);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* DEMO_SERIAL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 55 "..\Src\main.c" 2
N#include "MotionMC_Manager.h"
L 1 "..\Inc\MotionMC_Manager.h" 1
N/**
N ******************************************************************************
N * @file    MotionMC_Manager.h
N * @author  MEMS Software Solutions Team
N * @brief   This file contains definitions for the MotionMC_Manager.c file
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef MOTIONMC_MANAGER_H
N#define MOTIONMC_MANAGER_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <string.h>
N
N#if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
X#if ((1L) || (0L) || (0L))
N#include "motion_mc.h"
L 1 "..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc\motion_mc.h" 1
N/**
N  ******************************************************************************
N  * @file    motion_mc.h
N  * @author  MEMS Application Team
N  * @version V2.0.1
N  * @date    15-February-2019
N  * @brief   Header for motion_mc module
N  ******************************************************************************
N  * @attention
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef _MOTION_MC_H_
N#define _MOTION_MC_H_
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
N
N/** @addtogroup MIDDLEWARES
N  * @{
N  */
N
N/** @defgroup MOTION_MC MOTION_MC
N  * @{
N  */
N
N/** @defgroup MOTION_MC_Exported_Types MOTION_MC_Exported_Types
N  * @{
N  */
N/* Exported types ------------------------------------------------------------*/
N
Ntypedef enum
N{
N  MMC_CALQSTATUSUNKNOWN = 0,
N  MMC_CALQSTATUSPOOR,
N  MMC_CALQSTATUSOK,
N  MMC_CALQSTATUSGOOD
N} MMC_CalQuality_t;
N
Ntypedef struct {
N  float Mag[3];  /* Magnetometer sensor output [uT] */
N  int TimeStamp; /* Timestamp [ms] */
N} MMC_Input_t;
N
Ntypedef struct {
N  float HI_Bias[3];            /* Hard iron offset array [uT] */
N  float SF_Matrix[3][3];       /* Scale factor correction matrix [-] */
N  MMC_CalQuality_t CalQuality; /* Calibration quality factor */
N} MMC_Output_t;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported variables --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup MOTION_MC_Exported_Functions MOTION_MC_Exported_Functions
N * @{
N */
N
N/* Exported functions ------------------------------------------------------- */
N
N/**
N  * @brief  Initialize the MotionMC engine
N  * @param  sampletime  period in milliseconds [ms] between the update function call
N  * @param  enable  Enable (1) or disable (0) library
N  * @retval none
N  */
Nvoid MotionMC_Initialize(int sampletime, unsigned short int enable);
N
N/**
N  * @brief  Run Magnetic Calibration algorithm
N  * @param  data_in  Structure containing input data
N  * @retval none
N  */
Nvoid MotionMC_Update(MMC_Input_t *data_in);
N
N/**
N  * @brief  Get the magnetic compensation for hard/soft iron
N  * @param  data_out  Structure containing output data
N  * @retval none
N  */
Nvoid MotionMC_GetCalParams(MMC_Output_t *data_out);
N
N/**
N  * @brief  Get the library version
N  * @param  version  pointer to an array of 35 char
N  * @retval Number of characters in the version string
N  */
Nuint8_t MotionMC_GetLibVersion(char *version);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _MOTION_MC_H_ */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 49 "..\Inc\MotionMC_Manager.h" 2
N
N#elif (defined (USE_STM32L0XX_NUCLEO))
S#include "motion_mc_cm0p.h"
S
S#else
S#error Not supported platform
N#endif
N
N#include "iks01a2_motion_sensors.h"
N#include "serial_protocol.h"
N
N/* Extern variables ----------------------------------------------------------*/
Nextern volatile uint32_t TimeStamp;
N
N/* Exported Functions Prototypes ---------------------------------------------*/
N#if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
X#if ((1L) || (0L) || (0L))
Nvoid MotionMC_manager_init(int sampletime, unsigned short int enable);
Nvoid MotionMC_manager_update(MMC_Input_t *data_in);
Nvoid MotionMC_manager_get_params(MMC_Output_t *data_out);
N
N#elif (defined (USE_STM32L0XX_NUCLEO))
Svoid MotionMC_manager_init(int sampletime, MMC_CM0P_Mode_t mode, unsigned short int enable);
Svoid MotionMC_manager_update(MMC_CM0P_Input_t *data_in);
Svoid MotionMC_manager_get_params(MMC_CM0P_Output_t *data_out);
S
S#else
S#error Not supported platform
N#endif
N
Nvoid MotionMC_manager_run(TMsg *Msg);
Nvoid MotionMC_manager_get_version(char *version, int *length);
Nvoid MotionMC_manager_compensate(IKS01A2_MOTION_SENSOR_Axes_t *data_raw, IKS01A2_MOTION_SENSOR_Axes_t *data_comp);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* MOTIONMC_MANAGER_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 56 "..\Src\main.c" 2
N#include "MotionEC_Manager.h"
L 1 "..\Inc\MotionEC_Manager.h" 1
N/**
N ******************************************************************************
N * @file    MotionEC_Manager.h
N * @author  MEMS Software Solutions Team
N * @brief   This file contains definitions for the MotionEC_Manager.c file
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright notice,
N *      this list of conditions and the following disclaimer in the documentation
N *      and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its contributors
N *      may be used to endorse or promote products derived from this software
N *      without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N ******************************************************************************
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef MOTIONEC_MANAGER_H
N#define MOTIONEC_MANAGER_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <string.h>
N#include "serial_protocol.h"
N
N/* Extern variables ----------------------------------------------------------*/
N/* Exported Macros -----------------------------------------------------------*/
N/* Exported Types ------------------------------------------------------------*/
N/* Imported Variables --------------------------------------------------------*/
N/* Exported Functions Prototypes ---------------------------------------------*/
Nvoid MotionEC_manager_init(float freq);
Nvoid MotionEC_manager_run(TMsg *Msg);
Nvoid MotionEC_manager_get_version(char *version, int *length);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* MOTIONEC_MANAGER_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 57 "..\Src\main.c" 2
N#include "LSM9DS1.h"
L 1 ".\LSM9DS1\LSM9DS1.h" 1
N#ifndef LSM9DS1_H
N#define LSM9DS1_H
N
W ".\LSM9DS1\LSM9DS1.h" 4 6 Deprecated declaration init_LSM9DS1_I2C - give arg types
Nvoid init_LSM9DS1_I2C ();
N
N#endif
N
L 58 "..\Src\main.c" 2
N#include "i2c.h"
L 1 ".\LSM9DS1\i2c.h" 1
N/**
N  ******************************************************************************
N  * File Name          : I2C.h
N  * Description        : This file provides code for the configuration
N  *                      of the I2C instances.
N  ******************************************************************************
N  ** This notice applies to any and all portions of this file
N  * that are not between comment pairs USER CODE BEGIN and
N  * USER CODE END. Other portions of this file, whether 
N  * inserted by the user or by software development tools
N  * are owned by their respective copyright owners.
N  *
N  * COPYRIGHT(c) 2019 STMicroelectronics
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __i2c_H
N#define __i2c_H
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "main.h"
N
N/* USER CODE BEGIN Includes */
N
N/* USER CODE END Includes */
N
Nextern I2C_HandleTypeDef hi2c2;
N
N/* USER CODE BEGIN Private defines */
N
N/* USER CODE END Private defines */
N
Nvoid MX_I2C2_Init(void);
N
N/* USER CODE BEGIN Prototypes */
N
N/* USER CODE END Prototypes */
N
N#ifdef __cplusplus
S}
N#endif
N#endif /*__ i2c_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 59 "..\Src\main.c" 2
N/** @addtogroup MOTION_APPLICATIONS MOTION APPLICATIONS
N * @{
N */
N
N/** @addtogroup E_COMPASS E_COMPASS
N * @{
N */
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N/* Extern variables ----------------------------------------------------------*/
Nuint32_t SensorsEnabled = 0;
NTIM_HandleTypeDef AlgoTimHandle;
N
NIKS01A2_MOTION_SENSOR_Axes_t AccValue;     /* Raw accelerometer data [mg] */
NIKS01A2_MOTION_SENSOR_Axes_t MagValue;     /* Raw magnetometer data [mGauss] */
NIKS01A2_MOTION_SENSOR_Axes_t MagValueComp; /* Compensated magnetometer data [mGauss] */
N
Nint UseLSI = 0;
N
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
Nstatic volatile uint8_t SensorReadRequest = 0;
N
Nstatic int RtcSynchPrediv;
Nstatic RTC_HandleTypeDef RtcHandle;
N#define ADDR 0x3D
N/* Private function prototypes -----------------------------------------------*/
Nstatic void RTC_Config(void);
Nstatic void RTC_TimeStampConfig(void);
Nstatic void Init_Sensors(void);
Nstatic void MX_GPIO_Init(void);
Nstatic void MX_CRC_Init(void);
Nstatic void MX_TIM_ALGO_Init(void);
Nstatic void RTC_Handler(TMsg *Msg);
Nstatic void Accelero_Sensor_Handler(TMsg *Msg, uint32_t Instance);
Nstatic void Gyro_Sensor_Handler(TMsg *Msg, uint32_t Instance);
Nstatic void Magneto_Sensor_Handler(TMsg *Msg, uint32_t Instance);
Nstatic void Pressure_Sensor_Handler(TMsg *Msg, uint32_t Instance);
Nstatic void Humidity_Sensor_Handler(TMsg *Msg, uint32_t Instance);
Nstatic void Temperature_Sensor_Handler(TMsg *Msg, uint32_t Instance);
W "..\Src\main.c" 100 6 Deprecated declaration sensors_enable - give arg types
Nvoid sensors_enable();
Nextern I2C_HandleTypeDef hi2c3;
N HAL_StatusTypeDef status;
N/* Public functions ----------------------------------------------------------*/
N/**
N * @brief  Main function is to show how to use X_NUCLEO_IKS01A2
N *         expansion board to perform E-Compass functionality and send it from a Nucleo
N *         board to a connected PC, using UART, displaying it on Unicleo-GUI
N *         application, developed by STMicroelectronics.
N *         After connection has been established with GUI, the user can visualize
N *         the data and save datalog for offline analysis.
N *         See User Manual for details.
N * @param  None
N * @retval None
N */
Nint main(void); /* This "redundant" line is here to fulfil MISRA C-2012 rule 8.4 */
Nint main(void)
N{
N  char lib_version[35];
N  int lib_version_len;
N  TMsg msg_dat;
N  TMsg msg_cmd;
N
N  /* STM32xxxx HAL library initialization:
N   *   - Configure the Flash prefetch, instruction and Data caches
N   *   - Configure the Systick to generate an interrupt each 1 msec
N   *   - Set NVIC Group Priority to 4
N   *   - Global MSP (MCU Support Package) initialization
N   */
N  (void)HAL_Init();
N
N  /* Configure the system clock */
N  SystemClock_Config();
N
N  /* Configure the SysTick IRQ priority - set the second lowest priority */
N  HAL_NVIC_SetPriority(SysTick_IRQn, 0x0E, 0);
N
N  /* Initialize GPIOs */
N  MX_GPIO_Init();
N
N  /* Initialize CRC */
N  MX_CRC_Init();
N
N  /* Initialize (disabled) Sensors */
N	 MX_I2C2_Init();
N	 // while(1)
N //{
N	 init_LSM9DS1_I2C ();
N	 //status = HAL_I2C_IsDeviceReady(&hi2c3, ADDR, (uint32_t)3, (uint32_t)1000);
N/*	 if(status != HAL_OK)
N	 {
N		 I2C3->CR1 |= I2C_CR1_SWRST;
N		 MX_I2C2_Init();
N	 HAL_Delay(10);
N	 }*/
N	// HAL_Delay(10);
N //}
N  Init_Sensors();
N
N  /* Magnetometer Calibration API initialization function */
N#if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
X#if ((1L) || (0L) || (0L))
N  MotionMC_manager_init((int)ALGO_PERIOD, 1);
X  MotionMC_manager_init((int)(1000U / 50U), 1);
N
N#elif (defined (USE_STM32L0XX_NUCLEO))
S  MotionMC_manager_init((int)ALGO_PERIOD, MMC_CM0P_HI_AND_SI, 1);
S
S#else
S#error Not supported platform
N#endif
N
N  /* E-Compass API initialization function */
N  MotionEC_manager_init((float)ALGO_FREQ);
X  MotionEC_manager_init((float)50U);
N
N  /* OPTIONAL */
N  /* Get library version */
N  MotionEC_manager_get_version(lib_version, &lib_version_len);
N
N  /* Initialize Communication Peripheral for data log */
N  USARTConfig();
N
N  /* RTC Initialization */
N  RTC_Config();
N  RTC_TimeStampConfig();
N
N  /* Timer for algorithm synchronization initialization */
N  MX_TIM_ALGO_Init();
N
N  /* LED Blink */
N  BSP_LED_On(LED2);
N  HAL_Delay(500);
N  BSP_LED_Off(LED2);
N	
N 
N
N init_LSM9DS1_I2C ();
N //sensors_enable();
N  for (;;)
N  {
N    if (UART_ReceivedMSG((TMsg *)&msg_cmd) != 1)
N    {
N      if (msg_cmd.Data[0] == DEV_ADDR)
X      if (msg_cmd.Data[0] == 50U)
N      {
N        (void)HandleMSG((TMsg *)&msg_cmd);
N      }
N    }
N
N    if (SensorReadRequest == 1U)
N    {
N      if (DataLoggerActive == 1U)
N      {
N        SensorReadRequest = 0;
N
N        /* Acquire data from enabled sensors and fill Msg stream */
N        RTC_Handler(&msg_dat);
N        Accelero_Sensor_Handler(&msg_dat, IKS01A2_LSM303AGR_ACC_0);
X        Accelero_Sensor_Handler(&msg_dat, (1U));
N        Gyro_Sensor_Handler(&msg_dat, IKS01A2_LSM6DSL_0);
X        Gyro_Sensor_Handler(&msg_dat, 0);
N        Magneto_Sensor_Handler(&msg_dat, IKS01A2_LSM303AGR_MAG_0);
X        Magneto_Sensor_Handler(&msg_dat, (1U + 1U));
N        Humidity_Sensor_Handler(&msg_dat, IKS01A2_HTS221_0);
X        Humidity_Sensor_Handler(&msg_dat, 0);
N        Temperature_Sensor_Handler(&msg_dat, IKS01A2_HTS221_0);
X        Temperature_Sensor_Handler(&msg_dat, 0);
N        Pressure_Sensor_Handler(&msg_dat, IKS01A2_LPS22HB_0);
X        Pressure_Sensor_Handler(&msg_dat, (1U));
N
N        /* E-Compass specific part */
N        MotionEC_manager_run(&msg_dat);
N
N        /* Send data stream */
N        INIT_STREAMING_HEADER(&msg_dat);
N        msg_dat.Len = STREAMING_MSG_LENGTH;
X        msg_dat.Len = 125;
N        UART_SendMsg(&msg_dat);
N      }
N    }
N  }
N}
N
N/* Private functions ---------------------------------------------------------*/
N/**
N * @brief  Initialize all sensors
N * @param  None
N * @retval None
N */
Nstatic void Init_Sensors(void)
N{
N  (void)IKS01A2_MOTION_SENSOR_Init(IKS01A2_LSM303AGR_ACC_0, MOTION_ACCELERO);
X  (void)IKS01A2_MOTION_SENSOR_Init((1U), 2U);
N  (void)IKS01A2_MOTION_SENSOR_Init(IKS01A2_LSM6DSL_0, MOTION_GYRO);
X  (void)IKS01A2_MOTION_SENSOR_Init(0, 1U);
N  (void)IKS01A2_MOTION_SENSOR_Init(IKS01A2_LSM303AGR_MAG_0, MOTION_MAGNETO);
X  (void)IKS01A2_MOTION_SENSOR_Init((1U + 1U), 4U);
N  (void)IKS01A2_ENV_SENSOR_Init(IKS01A2_HTS221_0, ENV_TEMPERATURE | ENV_HUMIDITY);
X  (void)IKS01A2_ENV_SENSOR_Init(0, 1U | 4U);
N  (void)IKS01A2_ENV_SENSOR_Init(IKS01A2_LPS22HB_0, ENV_PRESSURE);
X  (void)IKS01A2_ENV_SENSOR_Init((1U), 2U);
N
N  /* Set accelerometer:
N   *   - ODR >= 100Hz
N   *   - FS   = <-2g, 2g>
N   */
N  (void)IKS01A2_MOTION_SENSOR_SetOutputDataRate(IKS01A2_LSM303AGR_ACC_0, MOTION_ACCELERO, 100.0f);
X  (void)IKS01A2_MOTION_SENSOR_SetOutputDataRate((1U), 2U, 100.0f);
N  (void)IKS01A2_MOTION_SENSOR_SetFullScale(IKS01A2_LSM303AGR_ACC_0, MOTION_ACCELERO, 2);
X  (void)IKS01A2_MOTION_SENSOR_SetFullScale((1U), 2U, 2);
N
N  /* Set magnetometer:
N   *   - ODR >= 100Hz
N   *   - FS   = 50Gauss (always)
N   */
N  (void)IKS01A2_MOTION_SENSOR_SetOutputDataRate(IKS01A2_LSM303AGR_MAG_0, MOTION_MAGNETO, 100.0f);
X  (void)IKS01A2_MOTION_SENSOR_SetOutputDataRate((1U + 1U), 4U, 100.0f);
N}
N
N/**
N * @brief  GPIO init function.
N * @param  None
N * @retval None
N * @details GPIOs initialized are User LED(PA5) and User Push Button(PC1)
N */
Nstatic void MX_GPIO_Init(void)
N{
N  /* Initialize LED */
N  BSP_LED_Init(LED2);
N
N  /* Initialize push button */
N  BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
N}
N
N/**
N * @brief  CRC init function.
N * @param  None
N * @retval None
N */
Nstatic void MX_CRC_Init(void)
N{
N  __CRC_CLK_ENABLE();
X  do { volatile uint32_t tmpreg = 0x00U; ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->AHB1ENR) |= ((0x1UL << (12U)))); tmpreg = ((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->AHB1ENR) & ((0x1UL << (12U)))); (void)tmpreg; } while(0U);
N}
N
N/**
N * @brief  TIM_ALGO init function.
N * @param  None
N * @retval None
N * @details This function intializes the Timer used to synchronize the algorithm.
N */
Nstatic void MX_TIM_ALGO_Init(void)
N{
N#if (defined (USE_STM32F4XX_NUCLEO))
X#if (1L)
N#define CPU_CLOCK  84000000U
N
N#elif (defined (USE_STM32L0XX_NUCLEO))
S#define CPU_CLOCK  32000000U
S
S#elif (defined (USE_STM32L1XX_NUCLEO))
S#define CPU_CLOCK  32000000U
S
S#elif (defined (USE_STM32L4XX_NUCLEO))
S#define CPU_CLOCK  80000000U
S
S#else
S#error Not supported platform
N#endif
N
N#define TIM_CLOCK  2000U
N
N  const uint32_t prescaler = CPU_CLOCK / TIM_CLOCK - 1U;
X  const uint32_t prescaler = 84000000U / 2000U - 1U;
N  const uint32_t tim_period = TIM_CLOCK / ALGO_FREQ - 1U;
X  const uint32_t tim_period = 2000U / 50U - 1U;
N
N  TIM_ClockConfigTypeDef s_clock_source_config;
N  TIM_MasterConfigTypeDef s_master_config;
N
N  AlgoTimHandle.Instance           = TIM_ALGO;
X  AlgoTimHandle.Instance           = ((TIM_TypeDef *) (0x40000000UL + 0x0400UL));
N  AlgoTimHandle.Init.Prescaler     = prescaler;
N  AlgoTimHandle.Init.CounterMode   = TIM_COUNTERMODE_UP;
X  AlgoTimHandle.Init.CounterMode   = 0x00000000U;
N  AlgoTimHandle.Init.Period        = tim_period;
N  AlgoTimHandle.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
X  AlgoTimHandle.Init.ClockDivision = 0x00000000U;
N  (void)HAL_TIM_Base_Init(&AlgoTimHandle);
N
N  s_clock_source_config.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
X  s_clock_source_config.ClockSource = (0x1UL << (12U));
N  (void)HAL_TIM_ConfigClockSource(&AlgoTimHandle, &s_clock_source_config);
N
N  s_master_config.MasterOutputTrigger = TIM_TRGO_RESET;
X  s_master_config.MasterOutputTrigger = 0x00000000U;
N  s_master_config.MasterSlaveMode     = TIM_MASTERSLAVEMODE_DISABLE;
X  s_master_config.MasterSlaveMode     = 0x00000000U;
N  (void)HAL_TIMEx_MasterConfigSynchronization(&AlgoTimHandle, &s_master_config);
N}
N
N/**
N * @brief  Handles the time+date getting/sending
N * @param  Msg the time+date part of the stream
N * @retval None
N */
Nstatic void RTC_Handler(TMsg *Msg)
N{
N  uint8_t sub_sec;
N  uint32_t ans_uint32;
N  int32_t ans_int32;
N  RTC_DateTypeDef sdatestructureget;
N  RTC_TimeTypeDef stimestructure;
N
N  (void)HAL_RTC_GetTime(&RtcHandle, &stimestructure, FORMAT_BIN);
X  (void)HAL_RTC_GetTime(&RtcHandle, &stimestructure, 0x00000000U);
N  (void)HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, FORMAT_BIN);
X  (void)HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, 0x00000000U);
N
N  /* To be MISRA C-2012 compliant the original calculation:
N     sub_sec = ((((((int)RtcSynchPrediv) - ((int)stimestructure.SubSeconds)) * 100) / (RtcSynchPrediv + 1)) & 0xFF);
N     has been split to separate expressions */
N  ans_int32 = (RtcSynchPrediv - (int32_t)stimestructure.SubSeconds) * 100;
N  ans_int32 /= RtcSynchPrediv + 1;
N  ans_uint32 = (uint32_t)ans_int32 & 0xFFU;
N  sub_sec = (uint8_t)ans_uint32;
N
N  Msg->Data[3] = (uint8_t)stimestructure.Hours;
N  Msg->Data[4] = (uint8_t)stimestructure.Minutes;
N  Msg->Data[5] = (uint8_t)stimestructure.Seconds;
N  Msg->Data[6] = sub_sec;
N}
N
N/**
N * @brief  Handles the ACC axes data getting/sending
N * @param  Msg the ACC part of the stream
N * @param  Instance the device instance
N * @retval None
N */
Nstatic void Accelero_Sensor_Handler(TMsg *Msg, uint32_t Instance)
N{
N  if ((SensorsEnabled & ACCELEROMETER_SENSOR) == ACCELEROMETER_SENSOR)
X  if ((SensorsEnabled & 0x00000010U) == 0x00000010U)
N  {
N    (void)IKS01A2_MOTION_SENSOR_GetAxes(Instance, MOTION_ACCELERO, &AccValue);
X    (void)IKS01A2_MOTION_SENSOR_GetAxes(Instance, 2U, &AccValue);
N    Serialize_s32(&Msg->Data[19], (int32_t)AccValue.x, 4);
N    Serialize_s32(&Msg->Data[23], (int32_t)AccValue.y, 4);
N    Serialize_s32(&Msg->Data[27], (int32_t)AccValue.z, 4);
N  }
N}
N
N/**
N * @brief  Handles the GYR axes data getting/sending
N * @param  Msg the GYR part of the stream
N * @param  Instance the device instance
N * @retval None
N */
Nstatic void Gyro_Sensor_Handler(TMsg *Msg, uint32_t Instance)
N{
N  IKS01A2_MOTION_SENSOR_Axes_t gyr_value;
N
N  if ((SensorsEnabled & GYROSCOPE_SENSOR) == GYROSCOPE_SENSOR)
X  if ((SensorsEnabled & 0x00000020U) == 0x00000020U)
N  {
N    (void)IKS01A2_MOTION_SENSOR_GetAxes(Instance, MOTION_GYRO, &gyr_value);
X    (void)IKS01A2_MOTION_SENSOR_GetAxes(Instance, 1U, &gyr_value);
N    Serialize_s32(&Msg->Data[31], gyr_value.x, 4);
N    Serialize_s32(&Msg->Data[35], gyr_value.y, 4);
N    Serialize_s32(&Msg->Data[39], gyr_value.z, 4);
N  }
N}
N
N/**
N * @brief  Handles the MAG axes data getting/sending
N * @param  Msg the MAG part of the stream
N * @param  Instance the device instance
N * @retval None
N */
Nstatic void Magneto_Sensor_Handler(TMsg *Msg, uint32_t Instance)
N{
N	uint8_t data[2] = {0};
N  //if ((SensorsEnabled & MAGNETIC_SENSOR) == MAGNETIC_SENSOR)
N  //{
N    //(void)IKS01A2_MOTION_SENSOR_GetAxes(Instance, MOTION_MAGNETO, &MagValue);
N		
N     status = HAL_I2C_Mem_Read(&hi2c3, ADDR, 0x28, I2C_MEMADD_SIZE_8BIT , data, 0x02, 100); 
X     status = HAL_I2C_Mem_Read(&hi2c3, 0x3D, 0x28, 0x00000001U , data, 0x02, 100); 
N	
N	int16_t a;
N	//a= data[0];
N	//a= a |(data[1] << 8);
N	a=(data[1] << 8)|data[0];
N		MagValue.x = a;//(int16_t)data[1] << 8 | data[0];							
N		HAL_Delay(10);
N		data[0] = 0; data[1] = 0;
N	
N	
N		 status = HAL_I2C_Mem_Read(&hi2c3, ADDR, 0x2A, I2C_MEMADD_SIZE_8BIT , data, 0x02, 100);
X		 status = HAL_I2C_Mem_Read(&hi2c3, 0x3D, 0x2A, 0x00000001U , data, 0x02, 100);
Na=(data[1] << 8)|data[0];	
N		MagValue.y = a;//(int16_t)data[1] << 8 | data[0];	
N		data[0] = 0; data[1] = 0;
N		HAL_Delay(10);
N		status = HAL_I2C_Mem_Read(&hi2c3, ADDR, 0x2C, I2C_MEMADD_SIZE_8BIT , data, 0x02, 100); 
X		status = HAL_I2C_Mem_Read(&hi2c3, 0x3D, 0x2C, 0x00000001U , data, 0x02, 100); 
N		a=(data[1] << 8)|data[0];
N		MagValue.z = a;//(int16_t)data[1] << 8 | data[0];	
N		HAL_Delay(10);
N    /* Magnetometer calibration */
N    MotionMC_manager_run(Msg);
N //}
N}
N
N/**
N * @brief  Handles the PRESS sensor data getting/sending.
N * @param  Msg the PRESS part of the stream
N * @param  Instance the device instance
N * @retval None
N */
Nstatic void Pressure_Sensor_Handler(TMsg *Msg, uint32_t Instance)
N{
N  float pres_value;
N
N  if ((SensorsEnabled & PRESSURE_SENSOR) == PRESSURE_SENSOR)
X  if ((SensorsEnabled & 0x00000001U) == 0x00000001U)
N  {
N    (void)IKS01A2_ENV_SENSOR_GetValue(Instance, ENV_PRESSURE, &pres_value);
X    (void)IKS01A2_ENV_SENSOR_GetValue(Instance, 2U, &pres_value);
N    (void)memcpy(&Msg->Data[7], (void *)&pres_value, sizeof(float));
N  }
N}
N
N/**
N * @brief  Handles the TEMP axes data getting/sending
N * @param  Msg the TEMP part of the stream
N * @param  Instance the device instance
N * @retval None
N */
Nstatic void Temperature_Sensor_Handler(TMsg *Msg, uint32_t Instance)
N{
N  float temp_value;
N
N  if ((SensorsEnabled & TEMPERATURE_SENSOR) == TEMPERATURE_SENSOR)
X  if ((SensorsEnabled & 0x00000002U) == 0x00000002U)
N  {
N    (void)IKS01A2_ENV_SENSOR_GetValue(Instance, ENV_TEMPERATURE, &temp_value);
X    (void)IKS01A2_ENV_SENSOR_GetValue(Instance, 1U, &temp_value);
N    (void)memcpy(&Msg->Data[11], (void *)&temp_value, sizeof(float));
N  }
N}
N
N/**
N * @brief  Handles the HUM axes data getting/sending
N * @param  Msg the HUM part of the stream
N * @param  Instance the device instance
N * @retval None
N */
Nstatic void Humidity_Sensor_Handler(TMsg *Msg, uint32_t Instance)
N{
N  float hum_value;
N
N  if ((SensorsEnabled & HUMIDITY_SENSOR) == HUMIDITY_SENSOR)
X  if ((SensorsEnabled & 0x00000004U) == 0x00000004U)
N  {
N    (void)IKS01A2_ENV_SENSOR_GetValue(Instance, ENV_HUMIDITY, &hum_value);
X    (void)IKS01A2_ENV_SENSOR_GetValue(Instance, 4U, &hum_value);
N    (void)memcpy(&Msg->Data[15], (void *)&hum_value, sizeof(float));;
N  }
N}
N
N/**
N * @brief  Configures the RTC
N * @param  None
N * @retval None
N */
Nstatic void RTC_Config(void)
N{
N  /*##-1- Configure the RTC peripheral #######################################*/
N  /* Check if LSE can be used */
N  RCC_OscInitTypeDef rcc_osc_init_struct;
N
N  /*##-2- Configure LSE as RTC clock soucre ###################################*/
N  rcc_osc_init_struct.OscillatorType = RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
X  rcc_osc_init_struct.OscillatorType = 0x00000008U | 0x00000004U;
N  rcc_osc_init_struct.PLL.PLLState   = RCC_PLL_NONE;
X  rcc_osc_init_struct.PLL.PLLState   = ((uint8_t)0x00);
N  rcc_osc_init_struct.LSEState       = RCC_LSE_ON;
X  rcc_osc_init_struct.LSEState       = (0x1UL << (0U));
N  rcc_osc_init_struct.LSIState       = RCC_LSI_OFF;
X  rcc_osc_init_struct.LSIState       = ((uint8_t)0x00);
N
N  if (HAL_RCC_OscConfig(&rcc_osc_init_struct) != HAL_OK)
N  {
N    /* LSE not available, we use LSI */
N    UseLSI = 1;
N    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSI;
X    RtcHandle.Init.AsynchPrediv = 0x7F;
N    RtcHandle.Init.SynchPrediv  = RTC_SYNCH_PREDIV_LSI;
X    RtcHandle.Init.SynchPrediv  = 0xF9;
N    RtcSynchPrediv = RTC_SYNCH_PREDIV_LSI;
X    RtcSynchPrediv = 0xF9;
N  }
N  else
N  {
N    /* We use LSE */
N    UseLSI = 0;
N    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSE;
X    RtcHandle.Init.AsynchPrediv = 0x7F;
N    RtcHandle.Init.SynchPrediv  = RTC_SYNCH_PREDIV_LSE;
X    RtcHandle.Init.SynchPrediv  = 0x00FF;
N    RtcSynchPrediv = RTC_SYNCH_PREDIV_LSE;
X    RtcSynchPrediv = 0x00FF;
N  }
N
N  RtcHandle.Instance = RTC;
X  RtcHandle.Instance = ((RTC_TypeDef *) (0x40000000UL + 0x2800UL));
N
N  /* Configure RTC prescaler and RTC data registers */
N  /* RTC configured as follow:
N       - Hour Format    = Format 12
N       - Asynch Prediv  = Value according to source clock
N       - Synch Prediv   = Value according to source clock
N       - OutPut         = Output Disable
N       - OutPutPolarity = High Polarity
N       - OutPutType     = Open Drain
N   */
N  RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_12;
X  RtcHandle.Init.HourFormat     = 0x00000040U;
N  RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
X  RtcHandle.Init.OutPut         = 0x00000000U;
N  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
X  RtcHandle.Init.OutPutPolarity = 0x00000000U;
N  RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
X  RtcHandle.Init.OutPutType     = 0x00000000U;
N
N  if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
N  {
N    /* Initialization Error */
N    Error_Handler();
N  }
N}
N
N/**
N * @brief  Configures the current time and date
N * @param  None
N * @retval None
N */
Nstatic void RTC_TimeStampConfig(void)
N{
N  RTC_DateTypeDef sdatestructure;
N  RTC_TimeTypeDef stimestructure;
N
N  /* Configure the Date */
N  /* Set Date: Monday January 1st 2001 */
N  sdatestructure.Year    = 0x01;
N  sdatestructure.Month   = RTC_MONTH_JANUARY;
X  sdatestructure.Month   = ((uint8_t)0x01);
N  sdatestructure.Date    = 0x01;
N  sdatestructure.WeekDay = RTC_WEEKDAY_MONDAY;
X  sdatestructure.WeekDay = ((uint8_t)0x01);
N
N  if (HAL_RTC_SetDate(&RtcHandle, &sdatestructure, FORMAT_BCD) != HAL_OK)
X  if (HAL_RTC_SetDate(&RtcHandle, &sdatestructure, 0x00000001U) != HAL_OK)
N  {
N    /* Initialization Error */
N    Error_Handler();
N  }
N
N  /* Configure the Time */
N  /* Set Time: 00:00:00 */
N  stimestructure.Hours          = 0x00;
N  stimestructure.Minutes        = 0x00;
N  stimestructure.Seconds        = 0x00;
N  stimestructure.TimeFormat     = RTC_HOURFORMAT12_AM;
X  stimestructure.TimeFormat     = ((uint8_t)0x00);
N  stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
X  stimestructure.DayLightSaving = 0x00000000U ;
N  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
X  stimestructure.StoreOperation = 0x00000000U;
N
N  if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BCD) != HAL_OK)
X  if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, 0x00000001U) != HAL_OK)
N  {
N    /* Initialization Error */
N    Error_Handler();
N  }
N}
N
N/**
N * @brief  Configures the current date
N * @param  y the year value to be set
N * @param  m the month value to be set
N * @param  d the day value to be set
N * @param  dw the day-week value to be set
N * @retval None
N */
Nvoid RTC_DateRegulate(uint8_t y, uint8_t m, uint8_t d, uint8_t dw)
N{
N  RTC_DateTypeDef sdatestructure;
N
N  sdatestructure.Year    = y;
N  sdatestructure.Month   = m;
N  sdatestructure.Date    = d;
N  sdatestructure.WeekDay = dw;
N
N  if (HAL_RTC_SetDate(&RtcHandle, &sdatestructure, FORMAT_BIN) != HAL_OK)
X  if (HAL_RTC_SetDate(&RtcHandle, &sdatestructure, 0x00000000U) != HAL_OK)
N  {
N    /* Initialization Error */
N    Error_Handler();
N  }
N}
N
N/**
N * @brief  Configures the current time
N * @param  hh the hour value to be set
N * @param  mm the minute value to be set
N * @param  ss the second value to be set
N * @retval None
N */
Nvoid RTC_TimeRegulate(uint8_t hh, uint8_t mm, uint8_t ss)
N{
N  RTC_TimeTypeDef stimestructure;
N
N  stimestructure.TimeFormat     = RTC_HOURFORMAT12_AM;
X  stimestructure.TimeFormat     = ((uint8_t)0x00);
N  stimestructure.Hours          = hh;
N  stimestructure.Minutes        = mm;
N  stimestructure.Seconds        = ss;
N  stimestructure.SubSeconds     = 0;
N  stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
X  stimestructure.DayLightSaving = 0x00000000U;
N  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
X  stimestructure.StoreOperation = 0x00000000U;
N
N  if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BIN) != HAL_OK)
X  if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, 0x00000000U) != HAL_OK)
N  {
N    /* Initialization Error */
N    Error_Handler();
N  }
N}
N
N/**
N * @brief  This function is executed in case of error occurrence
N * @param  None
N * @retval None
N */
Nvoid Error_Handler(void)
N{
N  for (;;)
N  {
N    BSP_LED_On(LED2);
N    HAL_Delay(100);
N    BSP_LED_Off(LED2);
N    HAL_Delay(100);
N  }
N}
N
N/**
N * @brief  EXTI line detection callbacks
N * @param  GpioPin the pin connected to EXTI line
N * @retval None
N */
Nvoid HAL_GPIO_EXTI_Callback(uint16_t GpioPin)
N{
N}
N
N/**
N * @brief  Period elapsed callback
N * @param  htim pointer to a TIM_HandleTypeDef structure that contains
N *              the configuration information for TIM module.
N * @retval None
N */
Nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
N{
N  if (htim->Instance == TIM_ALGO)
X  if (htim->Instance == ((TIM_TypeDef *) (0x40000000UL + 0x0400UL)))
N  {
N    SensorReadRequest = 1;
N    TimeStamp += ALGO_PERIOD;
X    TimeStamp += (1000U / 50U);
N  }
N}
N
Nvoid sensors_enable()
N{
N	  /* Start enabled sensors */
N     // if ((SensorsEnabled & PRESSURE_SENSOR) == PRESSURE_SENSOR)
N     // {
N        (void)IKS01A2_ENV_SENSOR_Enable(IKS01A2_LPS22HB_0, ENV_PRESSURE);
X        (void)IKS01A2_ENV_SENSOR_Enable((1U), 2U);
N     // }
N
N     // if ((SensorsEnabled & TEMPERATURE_SENSOR) == TEMPERATURE_SENSOR)
N     // {
N        (void)IKS01A2_ENV_SENSOR_Enable(IKS01A2_HTS221_0, ENV_TEMPERATURE);
X        (void)IKS01A2_ENV_SENSOR_Enable(0, 1U);
N     // }
N
N     // if ((SensorsEnabled & HUMIDITY_SENSOR) == HUMIDITY_SENSOR)
N     // {
N        (void)IKS01A2_ENV_SENSOR_Enable(IKS01A2_HTS221_0, ENV_HUMIDITY);
X        (void)IKS01A2_ENV_SENSOR_Enable(0, 4U);
N     // }
N
N     // if ((SensorsEnabled & ACCELEROMETER_SENSOR) == ACCELEROMETER_SENSOR)
N      //{
N        (void)IKS01A2_MOTION_SENSOR_Enable(IKS01A2_LSM303AGR_ACC_0, MOTION_ACCELERO);
X        (void)IKS01A2_MOTION_SENSOR_Enable((1U), 2U);
N     // }
N
N     // if ((SensorsEnabled & GYROSCOPE_SENSOR) == GYROSCOPE_SENSOR)
N     // {
N        (void)IKS01A2_MOTION_SENSOR_Enable(IKS01A2_LSM6DSL_0, MOTION_GYRO);
X        (void)IKS01A2_MOTION_SENSOR_Enable(0, 1U);
N     // }
N
N     // if ((SensorsEnabled & MAGNETIC_SENSOR) == MAGNETIC_SENSOR)
N     // {
N        (void)IKS01A2_MOTION_SENSOR_Enable(IKS01A2_LSM303AGR_MAG_0, MOTION_MAGNETO);
X        (void)IKS01A2_MOTION_SENSOR_Enable((1U + 1U), 4U);
N     // }
N
N      (void)HAL_TIM_Base_Start_IT(&AlgoTimHandle);
N      DataLoggerActive = 1;
N		}
N#ifdef  USE_FULL_ASSERT
S/**
S * @brief  Reports the name of the source file and the source line number
S *         where the assert_param error has occurred
S * @param  file pointer to the source file name
S * @param  line assert_param error line source number
S * @retval None
S */
Svoid assert_failed(uint8_t *file, uint32_t line)
S{
S  /* User can add his own implementation to report the file name and line number,
S     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
S  for (;;)
S  {}
S}
N#endif
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
