; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\iks01a2_motion_sensors.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\iks01a2_motion_sensors.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\BSP\IKS01A2\iks01a2_motion_sensors.c]
                          THUMB

                          AREA ||i.IKS01A2_MOTION_SENSOR_DeInit||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_DeInit PROC
;;;553     */
;;;554    int32_t IKS01A2_MOTION_SENSOR_DeInit(uint32_t Instance)
000000  b570              PUSH     {r4-r6,lr}
;;;555    {
000002  4604              MOV      r4,r0
;;;556      int32_t ret;
;;;557    
;;;558      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
000004  2c03              CMP      r4,#3
000006  d302              BCC      |L1.14|
;;;559      {
;;;560        ret = BSP_ERROR_WRONG_PARAM;
000008  f06f0501          MVN      r5,#1
00000c  e00c              B        |L1.40|
                  |L1.14|
;;;561      }
;;;562      else if (MotionDrv[Instance]->DeInit(MotionCompObj[Instance]) != BSP_ERROR_NONE)
00000e  4a07              LDR      r2,|L1.44|
000010  f8520024          LDR      r0,[r2,r4,LSL #2]
000014  4a06              LDR      r2,|L1.48|
000016  f8522024          LDR      r2,[r2,r4,LSL #2]
00001a  6851              LDR      r1,[r2,#4]
00001c  4788              BLX      r1
00001e  b110              CBZ      r0,|L1.38|
;;;563      {
;;;564        ret = BSP_ERROR_COMPONENT_FAILURE;
000020  f06f0504          MVN      r5,#4
000024  e000              B        |L1.40|
                  |L1.38|
;;;565      }
;;;566      else
;;;567      {
;;;568        ret = BSP_ERROR_NONE;
000026  2500              MOVS     r5,#0
                  |L1.40|
;;;569      }
;;;570    
;;;571      return ret;
000028  4628              MOV      r0,r5
;;;572    }
00002a  bd70              POP      {r4-r6,pc}
;;;573    
                          ENDP

                  |L1.44|
                          DCD      MotionCompObj
                  |L1.48|
                          DCD      MotionDrv

                          AREA ||i.IKS01A2_MOTION_SENSOR_Disable||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_Disable PROC
;;;673     */
;;;674    int32_t IKS01A2_MOTION_SENSOR_Disable(uint32_t Instance, uint32_t Function)
000000  b570              PUSH     {r4-r6,lr}
;;;675    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;676      int32_t ret;
;;;677    
;;;678      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
000006  2c03              CMP      r4,#3
000008  d302              BCC      |L2.16|
;;;679      {
;;;680        ret = BSP_ERROR_WRONG_PARAM;
00000a  f06f0501          MVN      r5,#1
00000e  e01c              B        |L2.74|
                  |L2.16|
;;;681      }
;;;682      else
;;;683      {
;;;684        if ((MotionCtx[Instance].Functions & Function) == Function)
000010  480f              LDR      r0,|L2.80|
000012  f8500024          LDR      r0,[r0,r4,LSL #2]
000016  4030              ANDS     r0,r0,r6
000018  42b0              CMP      r0,r6
00001a  d114              BNE      |L2.70|
;;;685        {
;;;686          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->Disable(MotionCompObj[Instance]) != BSP_ERROR_NONE)
00001c  eb040244          ADD      r2,r4,r4,LSL #1
000020  4b0c              LDR      r3,|L2.84|
000022  eb030282          ADD      r2,r3,r2,LSL #2
000026  4b0c              LDR      r3,|L2.88|
000028  f8533026          LDR      r3,[r3,r6,LSL #2]
00002c  f8522023          LDR      r2,[r2,r3,LSL #2]
000030  6851              LDR      r1,[r2,#4]
000032  4a0a              LDR      r2,|L2.92|
000034  f8520024          LDR      r0,[r2,r4,LSL #2]
000038  4788              BLX      r1
00003a  b110              CBZ      r0,|L2.66|
;;;687          {
;;;688            ret = BSP_ERROR_COMPONENT_FAILURE;
00003c  f06f0504          MVN      r5,#4
000040  e003              B        |L2.74|
                  |L2.66|
;;;689          }
;;;690          else
;;;691          {
;;;692            ret = BSP_ERROR_NONE;
000042  2500              MOVS     r5,#0
000044  e001              B        |L2.74|
                  |L2.70|
;;;693          }
;;;694        }
;;;695        else
;;;696        {
;;;697          ret = BSP_ERROR_WRONG_PARAM;
000046  f06f0501          MVN      r5,#1
                  |L2.74|
;;;698        }
;;;699      }
;;;700    
;;;701      return ret;
00004a  4628              MOV      r0,r5
;;;702    }
00004c  bd70              POP      {r4-r6,pc}
;;;703    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      MotionCtx
                  |L2.84|
                          DCD      MotionFuncDrv
                  |L2.88|
                          DCD      FunctionIndex
                  |L2.92|
                          DCD      MotionCompObj

                          AREA ||i.IKS01A2_MOTION_SENSOR_Enable||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_Enable PROC
;;;634     */
;;;635    int32_t IKS01A2_MOTION_SENSOR_Enable(uint32_t Instance, uint32_t Function)
000000  b570              PUSH     {r4-r6,lr}
;;;636    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;637      int32_t ret;
;;;638    
;;;639      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
000006  2c03              CMP      r4,#3
000008  d302              BCC      |L3.16|
;;;640      {
;;;641        ret = BSP_ERROR_WRONG_PARAM;
00000a  f06f0501          MVN      r5,#1
00000e  e01c              B        |L3.74|
                  |L3.16|
;;;642      }
;;;643      else
;;;644      {
;;;645        if ((MotionCtx[Instance].Functions & Function) == Function)
000010  480f              LDR      r0,|L3.80|
000012  f8500024          LDR      r0,[r0,r4,LSL #2]
000016  4030              ANDS     r0,r0,r6
000018  42b0              CMP      r0,r6
00001a  d114              BNE      |L3.70|
;;;646        {
;;;647          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->Enable(MotionCompObj[Instance]) != BSP_ERROR_NONE)
00001c  eb040244          ADD      r2,r4,r4,LSL #1
000020  4b0c              LDR      r3,|L3.84|
000022  eb030282          ADD      r2,r3,r2,LSL #2
000026  4b0c              LDR      r3,|L3.88|
000028  f8533026          LDR      r3,[r3,r6,LSL #2]
00002c  f8522023          LDR      r2,[r2,r3,LSL #2]
000030  6811              LDR      r1,[r2,#0]
000032  4a0a              LDR      r2,|L3.92|
000034  f8520024          LDR      r0,[r2,r4,LSL #2]
000038  4788              BLX      r1
00003a  b110              CBZ      r0,|L3.66|
;;;648          {
;;;649            ret = BSP_ERROR_COMPONENT_FAILURE;
00003c  f06f0504          MVN      r5,#4
000040  e003              B        |L3.74|
                  |L3.66|
;;;650          }
;;;651          else
;;;652          {
;;;653            ret = BSP_ERROR_NONE;
000042  2500              MOVS     r5,#0
000044  e001              B        |L3.74|
                  |L3.70|
;;;654          }
;;;655        }
;;;656        else
;;;657        {
;;;658          ret = BSP_ERROR_WRONG_PARAM;
000046  f06f0501          MVN      r5,#1
                  |L3.74|
;;;659        }
;;;660      }
;;;661    
;;;662      return ret;
00004a  4628              MOV      r0,r5
;;;663    }
00004c  bd70              POP      {r4-r6,pc}
;;;664    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      MotionCtx
                  |L3.84|
                          DCD      MotionFuncDrv
                  |L3.88|
                          DCD      FunctionIndex
                  |L3.92|
                          DCD      MotionCompObj

                          AREA ||i.IKS01A2_MOTION_SENSOR_GetAxes||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_GetAxes PROC
;;;713     */
;;;714    int32_t IKS01A2_MOTION_SENSOR_GetAxes(uint32_t Instance, uint32_t Function, IKS01A2_MOTION_SENSOR_Axes_t *Axes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;715    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;716      int32_t ret;
;;;717    
;;;718      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
00000a  2c03              CMP      r4,#3
00000c  d302              BCC      |L4.20|
;;;719      {
;;;720        ret = BSP_ERROR_WRONG_PARAM;
00000e  f06f0501          MVN      r5,#1
000012  e01d              B        |L4.80|
                  |L4.20|
;;;721      }
;;;722      else
;;;723      {
;;;724        if ((MotionCtx[Instance].Functions & Function) == Function)
000014  4810              LDR      r0,|L4.88|
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  4030              ANDS     r0,r0,r6
00001c  42b0              CMP      r0,r6
00001e  d115              BNE      |L4.76|
;;;725        {
;;;726          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->GetAxes(MotionCompObj[Instance], Axes) != BSP_ERROR_NONE)
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  4b0d              LDR      r3,|L4.92|
000026  eb030181          ADD      r1,r3,r1,LSL #2
00002a  4b0d              LDR      r3,|L4.96|
00002c  f8533026          LDR      r3,[r3,r6,LSL #2]
000030  f8511023          LDR      r1,[r1,r3,LSL #2]
000034  69ca              LDR      r2,[r1,#0x1c]
000036  490b              LDR      r1,|L4.100|
000038  f8510024          LDR      r0,[r1,r4,LSL #2]
00003c  4639              MOV      r1,r7
00003e  4790              BLX      r2
000040  b110              CBZ      r0,|L4.72|
;;;727          {
;;;728            ret = BSP_ERROR_COMPONENT_FAILURE;
000042  f06f0504          MVN      r5,#4
000046  e003              B        |L4.80|
                  |L4.72|
;;;729          }
;;;730          else
;;;731          {
;;;732            ret = BSP_ERROR_NONE;
000048  2500              MOVS     r5,#0
00004a  e001              B        |L4.80|
                  |L4.76|
;;;733          }
;;;734        }
;;;735        else
;;;736        {
;;;737          ret = BSP_ERROR_WRONG_PARAM;
00004c  f06f0501          MVN      r5,#1
                  |L4.80|
;;;738        }
;;;739      }
;;;740    
;;;741      return ret;
000050  4628              MOV      r0,r5
;;;742    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;743    
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      MotionCtx
                  |L4.92|
                          DCD      MotionFuncDrv
                  |L4.96|
                          DCD      FunctionIndex
                  |L4.100|
                          DCD      MotionCompObj

                          AREA ||i.IKS01A2_MOTION_SENSOR_GetAxesRaw||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_GetAxesRaw PROC
;;;753     */
;;;754    int32_t IKS01A2_MOTION_SENSOR_GetAxesRaw(uint32_t Instance, uint32_t Function, IKS01A2_MOTION_SENSOR_AxesRaw_t *Axes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;755    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;756      int32_t ret;
;;;757    
;;;758      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
00000a  2c03              CMP      r4,#3
00000c  d302              BCC      |L5.20|
;;;759      {
;;;760        ret = BSP_ERROR_WRONG_PARAM;
00000e  f06f0501          MVN      r5,#1
000012  e01d              B        |L5.80|
                  |L5.20|
;;;761      }
;;;762      else
;;;763      {
;;;764        if ((MotionCtx[Instance].Functions & Function) == Function)
000014  4810              LDR      r0,|L5.88|
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  4030              ANDS     r0,r0,r6
00001c  42b0              CMP      r0,r6
00001e  d115              BNE      |L5.76|
;;;765        {
;;;766          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->GetAxesRaw(MotionCompObj[Instance], Axes) != BSP_ERROR_NONE)
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  4b0d              LDR      r3,|L5.92|
000026  eb030181          ADD      r1,r3,r1,LSL #2
00002a  4b0d              LDR      r3,|L5.96|
00002c  f8533026          LDR      r3,[r3,r6,LSL #2]
000030  f8511023          LDR      r1,[r1,r3,LSL #2]
000034  6a0a              LDR      r2,[r1,#0x20]
000036  490b              LDR      r1,|L5.100|
000038  f8510024          LDR      r0,[r1,r4,LSL #2]
00003c  4639              MOV      r1,r7
00003e  4790              BLX      r2
000040  b110              CBZ      r0,|L5.72|
;;;767          {
;;;768            ret = BSP_ERROR_COMPONENT_FAILURE;
000042  f06f0504          MVN      r5,#4
000046  e003              B        |L5.80|
                  |L5.72|
;;;769          }
;;;770          else
;;;771          {
;;;772            ret = BSP_ERROR_NONE;
000048  2500              MOVS     r5,#0
00004a  e001              B        |L5.80|
                  |L5.76|
;;;773          }
;;;774        }
;;;775        else
;;;776        {
;;;777          ret = BSP_ERROR_WRONG_PARAM;
00004c  f06f0501          MVN      r5,#1
                  |L5.80|
;;;778        }
;;;779      }
;;;780    
;;;781      return ret;
000050  4628              MOV      r0,r5
;;;782    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;783    
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      MotionCtx
                  |L5.92|
                          DCD      MotionFuncDrv
                  |L5.96|
                          DCD      FunctionIndex
                  |L5.100|
                          DCD      MotionCompObj

                          AREA ||i.IKS01A2_MOTION_SENSOR_GetCapabilities||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_GetCapabilities PROC
;;;579     */
;;;580    int32_t IKS01A2_MOTION_SENSOR_GetCapabilities(uint32_t Instance, IKS01A2_MOTION_SENSOR_Capabilities_t *Capabilities)
000000  b570              PUSH     {r4-r6,lr}
;;;581    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;582      int32_t ret;
;;;583    
;;;584      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
000006  2c03              CMP      r4,#3
000008  d302              BCC      |L6.16|
;;;585      {
;;;586        ret = BSP_ERROR_WRONG_PARAM;
00000a  f06f0501          MVN      r5,#1
00000e  e00d              B        |L6.44|
                  |L6.16|
;;;587      }
;;;588      else if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], Capabilities) != BSP_ERROR_NONE)
000010  4907              LDR      r1,|L6.48|
000012  f8510024          LDR      r0,[r1,r4,LSL #2]
000016  4907              LDR      r1,|L6.52|
000018  f8511024          LDR      r1,[r1,r4,LSL #2]
00001c  68ca              LDR      r2,[r1,#0xc]
00001e  4631              MOV      r1,r6
000020  4790              BLX      r2
000022  b110              CBZ      r0,|L6.42|
;;;589      {
;;;590        ret = BSP_ERROR_UNKNOWN_COMPONENT;
000024  f06f0506          MVN      r5,#6
000028  e000              B        |L6.44|
                  |L6.42|
;;;591      }
;;;592      else
;;;593      {
;;;594        ret = BSP_ERROR_NONE;
00002a  2500              MOVS     r5,#0
                  |L6.44|
;;;595      }
;;;596    
;;;597      return ret;
00002c  4628              MOV      r0,r5
;;;598    }
00002e  bd70              POP      {r4-r6,pc}
;;;599    
                          ENDP

                  |L6.48|
                          DCD      MotionCompObj
                  |L6.52|
                          DCD      MotionDrv

                          AREA ||i.IKS01A2_MOTION_SENSOR_GetFullScale||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_GetFullScale PROC
;;;874     */
;;;875    int32_t IKS01A2_MOTION_SENSOR_GetFullScale(uint32_t Instance, uint32_t Function, int32_t *Fullscale)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;876    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;877      int32_t ret;
;;;878    
;;;879      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
00000a  2c03              CMP      r4,#3
00000c  d302              BCC      |L7.20|
;;;880      {
;;;881        ret = BSP_ERROR_WRONG_PARAM;
00000e  f06f0501          MVN      r5,#1
000012  e01d              B        |L7.80|
                  |L7.20|
;;;882      }
;;;883      else
;;;884      {
;;;885        if ((MotionCtx[Instance].Functions & Function) == Function)
000014  4810              LDR      r0,|L7.88|
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  4030              ANDS     r0,r0,r6
00001c  42b0              CMP      r0,r6
00001e  d115              BNE      |L7.76|
;;;886        {
;;;887          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->GetFullScale(MotionCompObj[Instance],
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  4b0d              LDR      r3,|L7.92|
000026  eb030181          ADD      r1,r3,r1,LSL #2
00002a  4b0d              LDR      r3,|L7.96|
00002c  f8533026          LDR      r3,[r3,r6,LSL #2]
000030  f8511023          LDR      r1,[r1,r3,LSL #2]
000034  694a              LDR      r2,[r1,#0x14]
000036  490b              LDR      r1,|L7.100|
000038  f8510024          LDR      r0,[r1,r4,LSL #2]
00003c  4639              MOV      r1,r7
00003e  4790              BLX      r2
000040  b110              CBZ      r0,|L7.72|
;;;888              Fullscale) != BSP_ERROR_NONE)
;;;889          {
;;;890            ret = BSP_ERROR_COMPONENT_FAILURE;
000042  f06f0504          MVN      r5,#4
000046  e003              B        |L7.80|
                  |L7.72|
;;;891          }
;;;892          else
;;;893          {
;;;894            ret = BSP_ERROR_NONE;
000048  2500              MOVS     r5,#0
00004a  e001              B        |L7.80|
                  |L7.76|
;;;895          }
;;;896        }
;;;897        else
;;;898        {
;;;899          ret = BSP_ERROR_WRONG_PARAM;
00004c  f06f0501          MVN      r5,#1
                  |L7.80|
;;;900        }
;;;901      }
;;;902    
;;;903      return ret;
000050  4628              MOV      r0,r5
;;;904    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;905    
                          ENDP

000056  0000              DCW      0x0000
                  |L7.88|
                          DCD      MotionCtx
                  |L7.92|
                          DCD      MotionFuncDrv
                  |L7.96|
                          DCD      FunctionIndex
                  |L7.100|
                          DCD      MotionCompObj

                          AREA ||i.IKS01A2_MOTION_SENSOR_GetOutputDataRate||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_GetOutputDataRate PROC
;;;834     */
;;;835    int32_t IKS01A2_MOTION_SENSOR_GetOutputDataRate(uint32_t Instance, uint32_t Function, float *Odr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;836    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;837      int32_t ret;
;;;838    
;;;839      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
00000a  2c03              CMP      r4,#3
00000c  d302              BCC      |L8.20|
;;;840      {
;;;841        ret = BSP_ERROR_WRONG_PARAM;
00000e  f06f0501          MVN      r5,#1
000012  e01d              B        |L8.80|
                  |L8.20|
;;;842      }
;;;843      else
;;;844      {
;;;845        if ((MotionCtx[Instance].Functions & Function) == Function)
000014  4810              LDR      r0,|L8.88|
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  4030              ANDS     r0,r0,r6
00001c  42b0              CMP      r0,r6
00001e  d115              BNE      |L8.76|
;;;846        {
;;;847          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->GetOutputDataRate(MotionCompObj[Instance], Odr) != BSP_ERROR_NONE)
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  4b0d              LDR      r3,|L8.92|
000026  eb030181          ADD      r1,r3,r1,LSL #2
00002a  4b0d              LDR      r3,|L8.96|
00002c  f8533026          LDR      r3,[r3,r6,LSL #2]
000030  f8511023          LDR      r1,[r1,r3,LSL #2]
000034  68ca              LDR      r2,[r1,#0xc]
000036  490b              LDR      r1,|L8.100|
000038  f8510024          LDR      r0,[r1,r4,LSL #2]
00003c  4639              MOV      r1,r7
00003e  4790              BLX      r2
000040  b110              CBZ      r0,|L8.72|
;;;848          {
;;;849            ret = BSP_ERROR_COMPONENT_FAILURE;
000042  f06f0504          MVN      r5,#4
000046  e003              B        |L8.80|
                  |L8.72|
;;;850          }
;;;851          else
;;;852          {
;;;853            ret = BSP_ERROR_NONE;
000048  2500              MOVS     r5,#0
00004a  e001              B        |L8.80|
                  |L8.76|
;;;854          }
;;;855        }
;;;856        else
;;;857        {
;;;858          ret = BSP_ERROR_WRONG_PARAM;
00004c  f06f0501          MVN      r5,#1
                  |L8.80|
;;;859        }
;;;860      }
;;;861    
;;;862      return ret;
000050  4628              MOV      r0,r5
;;;863    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;864    
                          ENDP

000056  0000              DCW      0x0000
                  |L8.88|
                          DCD      MotionCtx
                  |L8.92|
                          DCD      MotionFuncDrv
                  |L8.96|
                          DCD      FunctionIndex
                  |L8.100|
                          DCD      MotionCompObj

                          AREA ||i.IKS01A2_MOTION_SENSOR_GetSensitivity||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_GetSensitivity PROC
;;;793     */
;;;794    int32_t IKS01A2_MOTION_SENSOR_GetSensitivity(uint32_t Instance, uint32_t Function, float *Sensitivity)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;795    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;796      int32_t ret;
;;;797    
;;;798      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
00000a  2c03              CMP      r4,#3
00000c  d302              BCC      |L9.20|
;;;799      {
;;;800        ret = BSP_ERROR_WRONG_PARAM;
00000e  f06f0501          MVN      r5,#1
000012  e01d              B        |L9.80|
                  |L9.20|
;;;801      }
;;;802      else
;;;803      {
;;;804        if ((MotionCtx[Instance].Functions & Function) == Function)
000014  4810              LDR      r0,|L9.88|
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  4030              ANDS     r0,r0,r6
00001c  42b0              CMP      r0,r6
00001e  d115              BNE      |L9.76|
;;;805        {
;;;806          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->GetSensitivity(MotionCompObj[Instance],
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  4b0d              LDR      r3,|L9.92|
000026  eb030181          ADD      r1,r3,r1,LSL #2
00002a  4b0d              LDR      r3,|L9.96|
00002c  f8533026          LDR      r3,[r3,r6,LSL #2]
000030  f8511023          LDR      r1,[r1,r3,LSL #2]
000034  688a              LDR      r2,[r1,#8]
000036  490b              LDR      r1,|L9.100|
000038  f8510024          LDR      r0,[r1,r4,LSL #2]
00003c  4639              MOV      r1,r7
00003e  4790              BLX      r2
000040  b110              CBZ      r0,|L9.72|
;;;807              Sensitivity) != BSP_ERROR_NONE)
;;;808          {
;;;809            ret = BSP_ERROR_COMPONENT_FAILURE;
000042  f06f0504          MVN      r5,#4
000046  e003              B        |L9.80|
                  |L9.72|
;;;810          }
;;;811          else
;;;812          {
;;;813            ret = BSP_ERROR_NONE;
000048  2500              MOVS     r5,#0
00004a  e001              B        |L9.80|
                  |L9.76|
;;;814          }
;;;815        }
;;;816        else
;;;817        {
;;;818          ret = BSP_ERROR_WRONG_PARAM;
00004c  f06f0501          MVN      r5,#1
                  |L9.80|
;;;819        }
;;;820      }
;;;821    
;;;822      return ret;
000050  4628              MOV      r0,r5
;;;823    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;824    
                          ENDP

000056  0000              DCW      0x0000
                  |L9.88|
                          DCD      MotionCtx
                  |L9.92|
                          DCD      MotionFuncDrv
                  |L9.96|
                          DCD      FunctionIndex
                  |L9.100|
                          DCD      MotionCompObj

                          AREA ||i.IKS01A2_MOTION_SENSOR_Init||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_Init PROC
;;;163     */
;;;164    int32_t IKS01A2_MOTION_SENSOR_Init(uint32_t Instance, uint32_t Functions)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;165    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
;;;166      int32_t ret = BSP_ERROR_NONE;
00000a  f04f0900          MOV      r9,#0
;;;167      uint32_t function = MOTION_GYRO;
00000e  2601              MOVS     r6,#1
;;;168      uint32_t i;
;;;169      uint32_t component_functions = 0;
000010  2500              MOVS     r5,#0
;;;170      IKS01A2_MOTION_SENSOR_Capabilities_t cap;
;;;171    
;;;172      switch (Instance)
000012  b124              CBZ      r4,|L10.30|
000014  2c01              CMP      r4,#1
000016  d02b              BEQ      |L10.112|
000018  2c02              CMP      r4,#2
00001a  d178              BNE      |L10.270|
00001c  e04f              B        |L10.190|
                  |L10.30|
;;;173      {
;;;174    #if (USE_IKS01A2_MOTION_SENSOR_LSM6DSL_0 == 1)
;;;175        case IKS01A2_LSM6DSL_0:
;;;176          if (LSM6DSL_0_Probe(Functions) != BSP_ERROR_NONE)
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       LSM6DSL_0_Probe
000024  b120              CBZ      r0,|L10.48|
;;;177          {
;;;178            return BSP_ERROR_NO_INIT;
000026  f04f30ff          MOV      r0,#0xffffffff
                  |L10.42|
;;;179          }
;;;180          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;181          {
;;;182            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;183          }
;;;184          if (cap.Acc == 1U)
;;;185          {
;;;186            component_functions |= MOTION_ACCELERO;
;;;187          }
;;;188          if (cap.Gyro == 1U)
;;;189          {
;;;190            component_functions |= MOTION_GYRO;
;;;191          }
;;;192          if (cap.Magneto == 1U)
;;;193          {
;;;194            component_functions |= MOTION_MAGNETO;
;;;195          }
;;;196          break;
;;;197    #endif
;;;198    
;;;199    #if (USE_IKS01A2_MOTION_SENSOR_LSM303AGR_ACC_0 == 1)
;;;200        case IKS01A2_LSM303AGR_ACC_0:
;;;201          if (LSM303AGR_ACC_0_Probe(Functions) != BSP_ERROR_NONE)
;;;202          {
;;;203            return BSP_ERROR_NO_INIT;
;;;204          }
;;;205          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;206          {
;;;207            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;208          }
;;;209          if (cap.Acc == 1U)
;;;210          {
;;;211            component_functions |= MOTION_ACCELERO;
;;;212          }
;;;213          if (cap.Gyro == 1U)
;;;214          {
;;;215            component_functions |= MOTION_GYRO;
;;;216          }
;;;217          if (cap.Magneto == 1U)
;;;218          {
;;;219            component_functions |= MOTION_MAGNETO;
;;;220          }
;;;221          break;
;;;222    #endif
;;;223    
;;;224    #if (USE_IKS01A2_MOTION_SENSOR_LSM303AGR_MAG_0 == 1)
;;;225        case IKS01A2_LSM303AGR_MAG_0:
;;;226          if (LSM303AGR_MAG_0_Probe(Functions) != BSP_ERROR_NONE)
;;;227          {
;;;228            return BSP_ERROR_NO_INIT;
;;;229          }
;;;230          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;231          {
;;;232            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;233          }
;;;234          if (cap.Acc == 1U)
;;;235          {
;;;236            component_functions |= MOTION_ACCELERO;
;;;237          }
;;;238          if (cap.Gyro == 1U)
;;;239          {
;;;240            component_functions |= MOTION_GYRO;
;;;241          }
;;;242          if (cap.Magneto == 1U)
;;;243          {
;;;244            component_functions |= MOTION_MAGNETO;
;;;245          }
;;;246          break;
;;;247    #endif
;;;248    
;;;249    #if (USE_IKS01A2_MOTION_SENSOR_ASM330LHH_0 == 1)
;;;250        case IKS01A2_ASM330LHH_0:
;;;251          if (ASM330LHH_0_Probe(Functions) != BSP_ERROR_NONE)
;;;252          {
;;;253            return BSP_ERROR_NO_INIT;
;;;254          }
;;;255          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;256          {
;;;257            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;258          }
;;;259          if (cap.Acc == 1U)
;;;260          {
;;;261            component_functions |= MOTION_ACCELERO;
;;;262          }
;;;263          if (cap.Gyro == 1U)
;;;264          {
;;;265            component_functions |= MOTION_GYRO;
;;;266          }
;;;267          if (cap.Magneto == 1U)
;;;268          {
;;;269            component_functions |= MOTION_MAGNETO;
;;;270          }
;;;271          break;
;;;272    #endif
;;;273    
;;;274    #if (USE_IKS01A2_MOTION_SENSOR_IIS2DLPC_0 == 1)
;;;275        case IKS01A2_IIS2DLPC_0:
;;;276          if (IIS2DLPC_0_Probe(Functions) != BSP_ERROR_NONE)
;;;277          {
;;;278            return BSP_ERROR_NO_INIT;
;;;279          }
;;;280          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;281          {
;;;282            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;283          }
;;;284          if (cap.Acc == 1U)
;;;285          {
;;;286            component_functions |= MOTION_ACCELERO;
;;;287          }
;;;288          if (cap.Gyro == 1U)
;;;289          {
;;;290            component_functions |= MOTION_GYRO;
;;;291          }
;;;292          if (cap.Magneto == 1U)
;;;293          {
;;;294            component_functions |= MOTION_MAGNETO;
;;;295          }
;;;296          break;
;;;297    #endif
;;;298    
;;;299    #if (USE_IKS01A2_MOTION_SENSOR_IIS2MDC_0 == 1)
;;;300        case IKS01A2_IIS2MDC_0:
;;;301          if (IIS2MDC_0_Probe(Functions) != BSP_ERROR_NONE)
;;;302          {
;;;303            return BSP_ERROR_NO_INIT;
;;;304          }
;;;305          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;306          {
;;;307            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;308          }
;;;309          if (cap.Acc == 1U)
;;;310          {
;;;311            component_functions |= MOTION_ACCELERO;
;;;312          }
;;;313          if (cap.Gyro == 1U)
;;;314          {
;;;315            component_functions |= MOTION_GYRO;
;;;316          }
;;;317          if (cap.Magneto == 1U)
;;;318          {
;;;319            component_functions |= MOTION_MAGNETO;
;;;320          }
;;;321          break;
;;;322    #endif
;;;323    
;;;324    #if (USE_IKS01A2_MOTION_SENSOR_ISM303DAC_ACC_0 == 1)
;;;325        case IKS01A2_ISM303DAC_ACC_0:
;;;326          if (ISM303DAC_ACC_0_Probe(Functions) != BSP_ERROR_NONE)
;;;327          {
;;;328            return BSP_ERROR_NO_INIT;
;;;329          }
;;;330          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;331          {
;;;332            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;333          }
;;;334          if (cap.Acc == 1U)
;;;335          {
;;;336            component_functions |= MOTION_ACCELERO;
;;;337          }
;;;338          if (cap.Gyro == 1U)
;;;339          {
;;;340            component_functions |= MOTION_GYRO;
;;;341          }
;;;342          if (cap.Magneto == 1U)
;;;343          {
;;;344            component_functions |= MOTION_MAGNETO;
;;;345          }
;;;346          break;
;;;347    #endif
;;;348    
;;;349    #if (USE_IKS01A2_MOTION_SENSOR_ISM303DAC_MAG_0 == 1)
;;;350        case IKS01A2_ISM303DAC_MAG_0:
;;;351          if (ISM303DAC_MAG_0_Probe(Functions) != BSP_ERROR_NONE)
;;;352          {
;;;353            return BSP_ERROR_NO_INIT;
;;;354          }
;;;355          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;356          {
;;;357            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;358          }
;;;359          if (cap.Acc == 1U)
;;;360          {
;;;361            component_functions |= MOTION_ACCELERO;
;;;362          }
;;;363          if (cap.Gyro == 1U)
;;;364          {
;;;365            component_functions |= MOTION_GYRO;
;;;366          }
;;;367          if (cap.Magneto == 1U)
;;;368          {
;;;369            component_functions |= MOTION_MAGNETO;
;;;370          }
;;;371          break;
;;;372    #endif
;;;373    
;;;374    #if (USE_IKS01A2_MOTION_SENSOR_ISM330DLC_0 == 1)
;;;375        case IKS01A2_ISM330DLC_0:
;;;376          if (ISM330DLC_0_Probe(Functions) != BSP_ERROR_NONE)
;;;377          {
;;;378            return BSP_ERROR_NO_INIT;
;;;379          }
;;;380          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;381          {
;;;382            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;383          }
;;;384          if (cap.Acc == 1U)
;;;385          {
;;;386            component_functions |= MOTION_ACCELERO;
;;;387          }
;;;388          if (cap.Gyro == 1U)
;;;389          {
;;;390            component_functions |= MOTION_GYRO;
;;;391          }
;;;392          if (cap.Magneto == 1U)
;;;393          {
;;;394            component_functions |= MOTION_MAGNETO;
;;;395          }
;;;396          break;
;;;397    #endif
;;;398    
;;;399    #if (USE_IKS01A2_MOTION_SENSOR_LIS2DH12_0 == 1)
;;;400        case IKS01A2_LIS2DH12_0:
;;;401          if (LIS2DH12_0_Probe(Functions) != BSP_ERROR_NONE)
;;;402          {
;;;403            return BSP_ERROR_NO_INIT;
;;;404          }
;;;405          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;406          {
;;;407            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;408          }
;;;409          if (cap.Acc == 1U)
;;;410          {
;;;411            component_functions |= MOTION_ACCELERO;
;;;412          }
;;;413          if (cap.Gyro == 1U)
;;;414          {
;;;415            component_functions |= MOTION_GYRO;
;;;416          }
;;;417          if (cap.Magneto == 1U)
;;;418          {
;;;419            component_functions |= MOTION_MAGNETO;
;;;420          }
;;;421          break;
;;;422    #endif
;;;423    
;;;424    #if (USE_IKS01A2_MOTION_SENSOR_LIS2DW12_0 == 1)
;;;425        case IKS01A2_LIS2DW12_0:
;;;426          if (LIS2DW12_0_Probe(Functions) != BSP_ERROR_NONE)
;;;427          {
;;;428            return BSP_ERROR_NO_INIT;
;;;429          }
;;;430          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;431          {
;;;432            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;433          }
;;;434          if (cap.Acc == 1U)
;;;435          {
;;;436            component_functions |= MOTION_ACCELERO;
;;;437          }
;;;438          if (cap.Gyro == 1U)
;;;439          {
;;;440            component_functions |= MOTION_GYRO;
;;;441          }
;;;442          if (cap.Magneto == 1U)
;;;443          {
;;;444            component_functions |= MOTION_MAGNETO;
;;;445          }
;;;446          break;
;;;447    #endif
;;;448    
;;;449    #if (USE_IKS01A2_MOTION_SENSOR_LIS2MDL_0 == 1)
;;;450        case IKS01A2_LIS2MDL_0:
;;;451          if (LIS2MDL_0_Probe(Functions) != BSP_ERROR_NONE)
;;;452          {
;;;453            return BSP_ERROR_NO_INIT;
;;;454          }
;;;455          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;456          {
;;;457            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;458          }
;;;459          if (cap.Acc == 1U)
;;;460          {
;;;461            component_functions |= MOTION_ACCELERO;
;;;462          }
;;;463          if (cap.Gyro == 1U)
;;;464          {
;;;465            component_functions |= MOTION_GYRO;
;;;466          }
;;;467          if (cap.Magneto == 1U)
;;;468          {
;;;469            component_functions |= MOTION_MAGNETO;
;;;470          }
;;;471          break;
;;;472    #endif
;;;473    
;;;474    #if (USE_IKS01A2_MOTION_SENSOR_LSM6DSO_0 == 1)
;;;475        case IKS01A2_LSM6DSO_0:
;;;476          if (LSM6DSO_0_Probe(Functions) != BSP_ERROR_NONE)
;;;477          {
;;;478            return BSP_ERROR_NO_INIT;
;;;479          }
;;;480          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;481          {
;;;482            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;483          }
;;;484          if (cap.Acc == 1U)
;;;485          {
;;;486            component_functions |= MOTION_ACCELERO;
;;;487          }
;;;488          if (cap.Gyro == 1U)
;;;489          {
;;;490            component_functions |= MOTION_GYRO;
;;;491          }
;;;492          if (cap.Magneto == 1U)
;;;493          {
;;;494            component_functions |= MOTION_MAGNETO;
;;;495          }
;;;496          break;
;;;497    #endif
;;;498    
;;;499    #if (USE_IKS01A2_MOTION_SENSOR_LSM6DSOX_0 == 1)
;;;500        case IKS01A2_LSM6DSOX_0:
;;;501          if (LSM6DSOX_0_Probe(Functions) != BSP_ERROR_NONE)
;;;502          {
;;;503            return BSP_ERROR_NO_INIT;
;;;504          }
;;;505          if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
;;;506          {
;;;507            return BSP_ERROR_UNKNOWN_COMPONENT;
;;;508          }
;;;509          if (cap.Acc == 1U)
;;;510          {
;;;511            component_functions |= MOTION_ACCELERO;
;;;512          }
;;;513          if (cap.Gyro == 1U)
;;;514          {
;;;515            component_functions |= MOTION_GYRO;
;;;516          }
;;;517          if (cap.Magneto == 1U)
;;;518          {
;;;519            component_functions |= MOTION_MAGNETO;
;;;520          }
;;;521          break;
;;;522    #endif
;;;523    
;;;524        default:
;;;525          ret = BSP_ERROR_WRONG_PARAM;
;;;526          break;
;;;527      }
;;;528    
;;;529      if (ret != BSP_ERROR_NONE)
;;;530      {
;;;531        return ret;
;;;532      }
;;;533    
;;;534      for (i = 0; i < IKS01A2_MOTION_FUNCTIONS_NBR; i++)
;;;535      {
;;;536        if (((Functions & function) == function) && ((component_functions & function) == function))
;;;537        {
;;;538          if (MotionFuncDrv[Instance][FunctionIndex[function]]->Enable(MotionCompObj[Instance]) != BSP_ERROR_NONE)
;;;539          {
;;;540            return BSP_ERROR_COMPONENT_FAILURE;
;;;541          }
;;;542        }
;;;543        function = function << 1;
;;;544      }
;;;545    
;;;546      return ret;
;;;547    }
00002a  b007              ADD      sp,sp,#0x1c
00002c  e8bd83f0          POP      {r4-r9,pc}
                  |L10.48|
000030  494e              LDR      r1,|L10.364|
000032  f8510024          LDR      r0,[r1,r4,LSL #2]     ;180
000036  494e              LDR      r1,|L10.368|
000038  f8511024          LDR      r1,[r1,r4,LSL #2]     ;180
00003c  68ca              LDR      r2,[r1,#0xc]          ;180
00003e  4669              MOV      r1,sp                 ;180
000040  4790              BLX      r2                    ;180
000042  b110              CBZ      r0,|L10.74|
000044  f06f0006          MVN      r0,#6                 ;182
000048  e7ef              B        |L10.42|
                  |L10.74|
00004a  f89d0000          LDRB     r0,[sp,#0]            ;184
00004e  2801              CMP      r0,#1                 ;184
000050  d101              BNE      |L10.86|
000052  f0450502          ORR      r5,r5,#2              ;186
                  |L10.86|
000056  f89d0001          LDRB     r0,[sp,#1]            ;188
00005a  2801              CMP      r0,#1                 ;188
00005c  d101              BNE      |L10.98|
00005e  f0450501          ORR      r5,r5,#1              ;190
                  |L10.98|
000062  f89d0002          LDRB     r0,[sp,#2]            ;192
000066  2801              CMP      r0,#1                 ;192
000068  d101              BNE      |L10.110|
00006a  f0450504          ORR      r5,r5,#4              ;194
                  |L10.110|
00006e  e051              B        |L10.276|
                  |L10.112|
000070  4638              MOV      r0,r7                 ;201
000072  f7fffffe          BL       LSM303AGR_ACC_0_Probe
000076  b110              CBZ      r0,|L10.126|
000078  f04f30ff          MOV      r0,#0xffffffff        ;203
00007c  e7d5              B        |L10.42|
                  |L10.126|
00007e  493b              LDR      r1,|L10.364|
000080  f8510024          LDR      r0,[r1,r4,LSL #2]     ;205
000084  493a              LDR      r1,|L10.368|
000086  f8511024          LDR      r1,[r1,r4,LSL #2]     ;205
00008a  68ca              LDR      r2,[r1,#0xc]          ;205
00008c  4669              MOV      r1,sp                 ;205
00008e  4790              BLX      r2                    ;205
000090  b110              CBZ      r0,|L10.152|
000092  f06f0006          MVN      r0,#6                 ;207
000096  e7c8              B        |L10.42|
                  |L10.152|
000098  f89d0000          LDRB     r0,[sp,#0]            ;209
00009c  2801              CMP      r0,#1                 ;209
00009e  d101              BNE      |L10.164|
0000a0  f0450502          ORR      r5,r5,#2              ;211
                  |L10.164|
0000a4  f89d0001          LDRB     r0,[sp,#1]            ;213
0000a8  2801              CMP      r0,#1                 ;213
0000aa  d101              BNE      |L10.176|
0000ac  f0450501          ORR      r5,r5,#1              ;215
                  |L10.176|
0000b0  f89d0002          LDRB     r0,[sp,#2]            ;217
0000b4  2801              CMP      r0,#1                 ;217
0000b6  d101              BNE      |L10.188|
0000b8  f0450504          ORR      r5,r5,#4              ;219
                  |L10.188|
0000bc  e02a              B        |L10.276|
                  |L10.190|
0000be  4638              MOV      r0,r7                 ;226
0000c0  f7fffffe          BL       LSM303AGR_MAG_0_Probe
0000c4  b110              CBZ      r0,|L10.204|
0000c6  f04f30ff          MOV      r0,#0xffffffff        ;228
0000ca  e7ae              B        |L10.42|
                  |L10.204|
0000cc  4927              LDR      r1,|L10.364|
0000ce  f8510024          LDR      r0,[r1,r4,LSL #2]     ;230
0000d2  4927              LDR      r1,|L10.368|
0000d4  f8511024          LDR      r1,[r1,r4,LSL #2]     ;230
0000d8  68ca              LDR      r2,[r1,#0xc]          ;230
0000da  4669              MOV      r1,sp                 ;230
0000dc  4790              BLX      r2                    ;230
0000de  b110              CBZ      r0,|L10.230|
0000e0  f06f0006          MVN      r0,#6                 ;232
0000e4  e7a1              B        |L10.42|
                  |L10.230|
0000e6  f89d0000          LDRB     r0,[sp,#0]            ;234
0000ea  2801              CMP      r0,#1                 ;234
0000ec  d101              BNE      |L10.242|
0000ee  f0450502          ORR      r5,r5,#2              ;236
                  |L10.242|
0000f2  f89d0001          LDRB     r0,[sp,#1]            ;238
0000f6  2801              CMP      r0,#1                 ;238
0000f8  d101              BNE      |L10.254|
0000fa  f0450501          ORR      r5,r5,#1              ;240
                  |L10.254|
0000fe  f89d0002          LDRB     r0,[sp,#2]            ;242
000102  2801              CMP      r0,#1                 ;242
000104  d101              BNE      |L10.266|
000106  f0450504          ORR      r5,r5,#4              ;244
                  |L10.266|
00010a  e003              B        |L10.276|
00010c  e7ff              B        |L10.270|
                  |L10.270|
00010e  f06f0901          MVN      r9,#1                 ;525
000112  bf00              NOP                            ;526
                  |L10.276|
000114  bf00              NOP                            ;196
000116  f1b90f00          CMP      r9,#0                 ;529
00011a  d001              BEQ      |L10.288|
00011c  4648              MOV      r0,r9                 ;531
00011e  e784              B        |L10.42|
                  |L10.288|
000120  f04f0800          MOV      r8,#0                 ;534
000124  e01d              B        |L10.354|
                  |L10.294|
000126  ea070006          AND      r0,r7,r6              ;536
00012a  42b0              CMP      r0,r6                 ;536
00012c  d116              BNE      |L10.348|
00012e  ea050006          AND      r0,r5,r6              ;536
000132  42b0              CMP      r0,r6                 ;536
000134  d112              BNE      |L10.348|
000136  eb040244          ADD      r2,r4,r4,LSL #1       ;538
00013a  4b0e              LDR      r3,|L10.372|
00013c  eb030282          ADD      r2,r3,r2,LSL #2       ;538
000140  4b0d              LDR      r3,|L10.376|
000142  f8533026          LDR      r3,[r3,r6,LSL #2]     ;538
000146  f8522023          LDR      r2,[r2,r3,LSL #2]     ;538
00014a  6811              LDR      r1,[r2,#0]            ;538
00014c  4a07              LDR      r2,|L10.364|
00014e  f8520024          LDR      r0,[r2,r4,LSL #2]     ;538
000152  4788              BLX      r1                    ;538
000154  b110              CBZ      r0,|L10.348|
000156  f06f0004          MVN      r0,#4                 ;540
00015a  e766              B        |L10.42|
                  |L10.348|
00015c  0076              LSLS     r6,r6,#1              ;543
00015e  f1080801          ADD      r8,r8,#1              ;534
                  |L10.354|
000162  f1b80f03          CMP      r8,#3                 ;534
000166  d3de              BCC      |L10.294|
000168  4648              MOV      r0,r9                 ;546
00016a  e75e              B        |L10.42|
;;;548    
                          ENDP

                  |L10.364|
                          DCD      MotionCompObj
                  |L10.368|
                          DCD      MotionDrv
                  |L10.372|
                          DCD      MotionFuncDrv
                  |L10.376|
                          DCD      FunctionIndex

                          AREA ||i.IKS01A2_MOTION_SENSOR_ReadID||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_ReadID PROC
;;;605     */
;;;606    int32_t IKS01A2_MOTION_SENSOR_ReadID(uint32_t Instance, uint8_t *Id)
000000  b570              PUSH     {r4-r6,lr}
;;;607    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;608      int32_t ret;
;;;609    
;;;610      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
000006  2c03              CMP      r4,#3
000008  d302              BCC      |L11.16|
;;;611      {
;;;612        ret = BSP_ERROR_WRONG_PARAM;
00000a  f06f0501          MVN      r5,#1
00000e  e00d              B        |L11.44|
                  |L11.16|
;;;613      }
;;;614      else if (MotionDrv[Instance]->ReadID(MotionCompObj[Instance], Id) != BSP_ERROR_NONE)
000010  4907              LDR      r1,|L11.48|
000012  f8510024          LDR      r0,[r1,r4,LSL #2]
000016  4907              LDR      r1,|L11.52|
000018  f8511024          LDR      r1,[r1,r4,LSL #2]
00001c  688a              LDR      r2,[r1,#8]
00001e  4631              MOV      r1,r6
000020  4790              BLX      r2
000022  b110              CBZ      r0,|L11.42|
;;;615      {
;;;616        ret = BSP_ERROR_UNKNOWN_COMPONENT;
000024  f06f0506          MVN      r5,#6
000028  e000              B        |L11.44|
                  |L11.42|
;;;617      }
;;;618      else
;;;619      {
;;;620        ret = BSP_ERROR_NONE;
00002a  2500              MOVS     r5,#0
                  |L11.44|
;;;621      }
;;;622    
;;;623      return ret;
00002c  4628              MOV      r0,r5
;;;624    }
00002e  bd70              POP      {r4-r6,pc}
;;;625    
                          ENDP

                  |L11.48|
                          DCD      MotionCompObj
                  |L11.52|
                          DCD      MotionDrv

                          AREA ||i.IKS01A2_MOTION_SENSOR_SetFullScale||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_SetFullScale PROC
;;;955     */
;;;956    int32_t IKS01A2_MOTION_SENSOR_SetFullScale(uint32_t Instance, uint32_t Function, int32_t Fullscale)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;957    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;958      int32_t ret;
;;;959    
;;;960      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
00000a  2c03              CMP      r4,#3
00000c  d302              BCC      |L12.20|
;;;961      {
;;;962        ret = BSP_ERROR_WRONG_PARAM;
00000e  f06f0501          MVN      r5,#1
000012  e01d              B        |L12.80|
                  |L12.20|
;;;963      }
;;;964      else
;;;965      {
;;;966        if ((MotionCtx[Instance].Functions & Function) == Function)
000014  4810              LDR      r0,|L12.88|
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  4030              ANDS     r0,r0,r6
00001c  42b0              CMP      r0,r6
00001e  d115              BNE      |L12.76|
;;;967        {
;;;968          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->SetFullScale(MotionCompObj[Instance],
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  4b0d              LDR      r3,|L12.92|
000026  eb030181          ADD      r1,r3,r1,LSL #2
00002a  4b0d              LDR      r3,|L12.96|
00002c  f8533026          LDR      r3,[r3,r6,LSL #2]
000030  f8511023          LDR      r1,[r1,r3,LSL #2]
000034  698a              LDR      r2,[r1,#0x18]
000036  490b              LDR      r1,|L12.100|
000038  f8510024          LDR      r0,[r1,r4,LSL #2]
00003c  4639              MOV      r1,r7
00003e  4790              BLX      r2
000040  b110              CBZ      r0,|L12.72|
;;;969              Fullscale) != BSP_ERROR_NONE)
;;;970          {
;;;971            ret = BSP_ERROR_COMPONENT_FAILURE;
000042  f06f0504          MVN      r5,#4
000046  e003              B        |L12.80|
                  |L12.72|
;;;972          }
;;;973          else
;;;974          {
;;;975            ret = BSP_ERROR_NONE;
000048  2500              MOVS     r5,#0
00004a  e001              B        |L12.80|
                  |L12.76|
;;;976          }
;;;977        }
;;;978        else
;;;979        {
;;;980          ret = BSP_ERROR_WRONG_PARAM;
00004c  f06f0501          MVN      r5,#1
                  |L12.80|
;;;981        }
;;;982      }
;;;983    
;;;984      return ret;
000050  4628              MOV      r0,r5
;;;985    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;986    
                          ENDP

000056  0000              DCW      0x0000
                  |L12.88|
                          DCD      MotionCtx
                  |L12.92|
                          DCD      MotionFuncDrv
                  |L12.96|
                          DCD      FunctionIndex
                  |L12.100|
                          DCD      MotionCompObj

                          AREA ||i.IKS01A2_MOTION_SENSOR_SetOutputDataRate||, CODE, READONLY, ALIGN=2

                  IKS01A2_MOTION_SENSOR_SetOutputDataRate PROC
;;;915     */
;;;916    int32_t IKS01A2_MOTION_SENSOR_SetOutputDataRate(uint32_t Instance, uint32_t Function, float Odr)
000000  b570              PUSH     {r4-r6,lr}
;;;917    {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
00000a  eeb08a40          VMOV.F32 s16,s0
;;;918      int32_t ret;
;;;919    
;;;920      if (Instance >= IKS01A2_MOTION_INSTANCES_NBR)
00000e  2c03              CMP      r4,#3
000010  d302              BCC      |L13.24|
;;;921      {
;;;922        ret = BSP_ERROR_WRONG_PARAM;
000012  f06f0501          MVN      r5,#1
000016  e01e              B        |L13.86|
                  |L13.24|
;;;923      }
;;;924      else
;;;925      {
;;;926        if ((MotionCtx[Instance].Functions & Function) == Function)
000018  4811              LDR      r0,|L13.96|
00001a  f8500024          LDR      r0,[r0,r4,LSL #2]
00001e  4030              ANDS     r0,r0,r6
000020  42b0              CMP      r0,r6
000022  d116              BNE      |L13.82|
;;;927        {
;;;928          if (MotionFuncDrv[Instance][FunctionIndex[Function]]->SetOutputDataRate(MotionCompObj[Instance], Odr) != BSP_ERROR_NONE)
000024  eb040244          ADD      r2,r4,r4,LSL #1
000028  4b0e              LDR      r3,|L13.100|
00002a  eb030282          ADD      r2,r3,r2,LSL #2
00002e  4b0e              LDR      r3,|L13.104|
000030  f8533026          LDR      r3,[r3,r6,LSL #2]
000034  f8522023          LDR      r2,[r2,r3,LSL #2]
000038  6911              LDR      r1,[r2,#0x10]
00003a  4a0c              LDR      r2,|L13.108|
00003c  f8520024          LDR      r0,[r2,r4,LSL #2]
000040  eeb00a48          VMOV.F32 s0,s16
000044  4788              BLX      r1
000046  b110              CBZ      r0,|L13.78|
;;;929          {
;;;930            ret = BSP_ERROR_COMPONENT_FAILURE;
000048  f06f0504          MVN      r5,#4
00004c  e003              B        |L13.86|
                  |L13.78|
;;;931          }
;;;932          else
;;;933          {
;;;934            ret = BSP_ERROR_NONE;
00004e  2500              MOVS     r5,#0
000050  e001              B        |L13.86|
                  |L13.82|
;;;935          }
;;;936        }
;;;937        else
;;;938        {
;;;939          ret = BSP_ERROR_WRONG_PARAM;
000052  f06f0501          MVN      r5,#1
                  |L13.86|
;;;940        }
;;;941      }
;;;942    
;;;943      return ret;
000056  4628              MOV      r0,r5
;;;944    }
000058  ecbd8b02          VPOP     {d8}
00005c  bd70              POP      {r4-r6,pc}
;;;945    
                          ENDP

00005e  0000              DCW      0x0000
                  |L13.96|
                          DCD      MotionCtx
                  |L13.100|
                          DCD      MotionFuncDrv
                  |L13.104|
                          DCD      FunctionIndex
                  |L13.108|
                          DCD      MotionCompObj

                          AREA ||i.LSM303AGR_ACC_0_Probe||, CODE, READONLY, ALIGN=2

                  LSM303AGR_ACC_0_Probe PROC
;;;1081    */
;;;1082   static int32_t LSM303AGR_ACC_0_Probe(uint32_t Functions)
000000  b530              PUSH     {r4,r5,lr}
;;;1083   {
000002  b08f              SUB      sp,sp,#0x3c
000004  4604              MOV      r4,r0
;;;1084     LSM303AGR_IO_t                io_ctx;
;;;1085     uint8_t                       id;
;;;1086     static LSM303AGR_ACC_Object_t lsm303agr_acc_obj_0;
;;;1087     LSM303AGR_Capabilities_t      cap;
;;;1088     int32_t ret = BSP_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;1089   
;;;1090     /* Configure the accelero driver */
;;;1091     io_ctx.BusType     = LSM303AGR_I2C_BUS; /* I2C */
000008  2000              MOVS     r0,#0
00000a  900a              STR      r0,[sp,#0x28]
;;;1092     io_ctx.Address     = LSM303AGR_I2C_ADD_XL;
00000c  2033              MOVS     r0,#0x33
00000e  f88d002c          STRB     r0,[sp,#0x2c]
;;;1093     io_ctx.Init        = IKS01A2_I2C_Init;
000012  482f              LDR      r0,|L14.208|
000014  9008              STR      r0,[sp,#0x20]
;;;1094     io_ctx.DeInit      = IKS01A2_I2C_DeInit;
000016  482f              LDR      r0,|L14.212|
000018  9009              STR      r0,[sp,#0x24]
;;;1095     io_ctx.ReadReg     = IKS01A2_I2C_ReadReg;
00001a  482f              LDR      r0,|L14.216|
00001c  900d              STR      r0,[sp,#0x34]
;;;1096     io_ctx.WriteReg    = IKS01A2_I2C_WriteReg;
00001e  482f              LDR      r0,|L14.220|
000020  900c              STR      r0,[sp,#0x30]
;;;1097     io_ctx.GetTick     = IKS01A2_GetTick;
000022  482f              LDR      r0,|L14.224|
000024  900e              STR      r0,[sp,#0x38]
;;;1098   
;;;1099     if (LSM303AGR_ACC_RegisterBusIO(&lsm303agr_acc_obj_0, &io_ctx) != LSM303AGR_OK)
000026  a908              ADD      r1,sp,#0x20
000028  482e              LDR      r0,|L14.228|
00002a  f7fffffe          BL       LSM303AGR_ACC_RegisterBusIO
00002e  b108              CBZ      r0,|L14.52|
;;;1100     {
;;;1101       ret = BSP_ERROR_UNKNOWN_COMPONENT;
000030  1fed              SUBS     r5,r5,#7
000032  e04a              B        |L14.202|
                  |L14.52|
;;;1102     }
;;;1103     else if (LSM303AGR_ACC_ReadID(&lsm303agr_acc_obj_0, &id) != LSM303AGR_OK)
000034  a907              ADD      r1,sp,#0x1c
000036  482b              LDR      r0,|L14.228|
000038  f7fffffe          BL       LSM303AGR_ACC_ReadID
00003c  b110              CBZ      r0,|L14.68|
;;;1104     {
;;;1105       ret = BSP_ERROR_UNKNOWN_COMPONENT;
00003e  f06f0506          MVN      r5,#6
000042  e042              B        |L14.202|
                  |L14.68|
;;;1106     }
;;;1107     else if (id != (uint8_t)LSM303AGR_ID_XL)
000044  f89d001c          LDRB     r0,[sp,#0x1c]
000048  2833              CMP      r0,#0x33
00004a  d002              BEQ      |L14.82|
;;;1108     {
;;;1109       ret = BSP_ERROR_UNKNOWN_COMPONENT;
00004c  f06f0506          MVN      r5,#6
000050  e03b              B        |L14.202|
                  |L14.82|
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       (void)LSM303AGR_ACC_GetCapabilities(&lsm303agr_acc_obj_0, &cap);
000052  4669              MOV      r1,sp
000054  4823              LDR      r0,|L14.228|
000056  f7fffffe          BL       LSM303AGR_ACC_GetCapabilities
;;;1114       MotionCtx[IKS01A2_LSM303AGR_ACC_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((
00005a  f89d0001          LDRB     r0,[sp,#1]
00005e  f89d1000          LDRB     r1,[sp,#0]
000062  ea400041          ORR      r0,r0,r1,LSL #1
000066  f89d1002          LDRB     r1,[sp,#2]
00006a  ea400081          ORR      r0,r0,r1,LSL #2
00006e  491e              LDR      r1,|L14.232|
000070  6048              STR      r0,[r1,#4]  ; MotionCtx
;;;1115                                                        uint32_t)cap.Magneto << 2);
;;;1116   
;;;1117       MotionCompObj[IKS01A2_LSM303AGR_ACC_0] = &lsm303agr_acc_obj_0;
000072  481c              LDR      r0,|L14.228|
000074  491d              LDR      r1,|L14.236|
000076  6048              STR      r0,[r1,#4]  ; MotionCompObj
;;;1118       /* The second cast (void *) is added to bypass Misra R11.3 rule */
;;;1119       MotionDrv[IKS01A2_LSM303AGR_ACC_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LSM303AGR_ACC_COMMON_Driver;
000078  481d              LDR      r0,|L14.240|
00007a  491e              LDR      r1,|L14.244|
00007c  6048              STR      r0,[r1,#4]  ; MotionDrv
;;;1120   
;;;1121       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO) && (cap.Acc == 1U))
00007e  b9c5              CBNZ     r5,|L14.178|
000080  f0040002          AND      r0,r4,#2
000084  2802              CMP      r0,#2
000086  d114              BNE      |L14.178|
000088  f89d0000          LDRB     r0,[sp,#0]
00008c  2801              CMP      r0,#1
00008e  d110              BNE      |L14.178|
;;;1122       {
;;;1123         /* The second cast (void *) is added to bypass Misra R11.3 rule */
;;;1124         MotionFuncDrv[IKS01A2_LSM303AGR_ACC_0][FunctionIndex[MOTION_ACCELERO]] = (MOTION_SENSOR_FuncDrv_t *)(
000090  4919              LDR      r1,|L14.248|
000092  481a              LDR      r0,|L14.252|
000094  6882              LDR      r2,[r0,#8]  ; FunctionIndex
000096  481a              LDR      r0,|L14.256|
000098  f8401022          STR      r1,[r0,r2,LSL #2]
;;;1125               void *)&LSM303AGR_ACC_Driver;
;;;1126   
;;;1127         if (MotionDrv[IKS01A2_LSM303AGR_ACC_0]->Init(MotionCompObj[IKS01A2_LSM303AGR_ACC_0]) != LSM303AGR_OK)
00009c  4a13              LDR      r2,|L14.236|
00009e  6850              LDR      r0,[r2,#4]  ; MotionCompObj
0000a0  4a14              LDR      r2,|L14.244|
0000a2  6852              LDR      r2,[r2,#4]  ; MotionDrv
0000a4  6811              LDR      r1,[r2,#0]
0000a6  4788              BLX      r1
0000a8  b110              CBZ      r0,|L14.176|
;;;1128         {
;;;1129           ret = BSP_ERROR_COMPONENT_FAILURE;
0000aa  f06f0504          MVN      r5,#4
0000ae  e000              B        |L14.178|
                  |L14.176|
;;;1130         }
;;;1131         else
;;;1132         {
;;;1133           ret = BSP_ERROR_NONE;
0000b0  2500              MOVS     r5,#0
                  |L14.178|
;;;1134         }
;;;1135       }
;;;1136       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO))
0000b2  b925              CBNZ     r5,|L14.190|
0000b4  f0040001          AND      r0,r4,#1
0000b8  b108              CBZ      r0,|L14.190|
;;;1137       {
;;;1138         /* Return an error if the application try to initialize a function not supported by the component */
;;;1139         ret = BSP_ERROR_COMPONENT_FAILURE;
0000ba  f06f0504          MVN      r5,#4
                  |L14.190|
;;;1140       }
;;;1141       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO))
0000be  b925              CBNZ     r5,|L14.202|
0000c0  f0040004          AND      r0,r4,#4
0000c4  2804              CMP      r0,#4
0000c6  d100              BNE      |L14.202|
;;;1142       {
;;;1143         /* Return an error if the application try to initialize a function not supported by the component */
;;;1144         ret = BSP_ERROR_COMPONENT_FAILURE;
0000c8  43c5              MVNS     r5,r0
                  |L14.202|
;;;1145       }
;;;1146     }
;;;1147   
;;;1148     return ret;
0000ca  4628              MOV      r0,r5
;;;1149   }
0000cc  b00f              ADD      sp,sp,#0x3c
0000ce  bd30              POP      {r4,r5,pc}
;;;1150   #endif
                          ENDP

                  |L14.208|
                          DCD      BSP_I2C1_Init
                  |L14.212|
                          DCD      BSP_I2C1_DeInit
                  |L14.216|
                          DCD      BSP_I2C1_ReadReg
                  |L14.220|
                          DCD      BSP_I2C1_WriteReg
                  |L14.224|
                          DCD      BSP_GetTick
                  |L14.228|
                          DCD      lsm303agr_acc_obj_0
                  |L14.232|
                          DCD      MotionCtx
                  |L14.236|
                          DCD      MotionCompObj
                  |L14.240|
                          DCD      LSM303AGR_ACC_COMMON_Driver
                  |L14.244|
                          DCD      MotionDrv
                  |L14.248|
                          DCD      LSM303AGR_ACC_Driver
                  |L14.252|
                          DCD      FunctionIndex
                  |L14.256|
                          DCD      MotionFuncDrv+0xc

                          AREA ||i.LSM303AGR_MAG_0_Probe||, CODE, READONLY, ALIGN=2

                  LSM303AGR_MAG_0_Probe PROC
;;;1156    */
;;;1157   static int32_t LSM303AGR_MAG_0_Probe(uint32_t Functions)
000000  b530              PUSH     {r4,r5,lr}
;;;1158   {
000002  b08f              SUB      sp,sp,#0x3c
000004  4604              MOV      r4,r0
;;;1159     LSM303AGR_IO_t                io_ctx;
;;;1160     uint8_t                       id;
;;;1161     static LSM303AGR_MAG_Object_t lsm303agr_mag_obj_0;
;;;1162     LSM303AGR_Capabilities_t      cap;
;;;1163     int32_t ret = BSP_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;1164   
;;;1165     /* Configure the magneto driver */
;;;1166     io_ctx.BusType     = LSM303AGR_I2C_BUS; /* I2C */
000008  2000              MOVS     r0,#0
00000a  900a              STR      r0,[sp,#0x28]
;;;1167     io_ctx.Address     = LSM303AGR_I2C_ADD_MG;
00000c  203d              MOVS     r0,#0x3d
00000e  f88d002c          STRB     r0,[sp,#0x2c]
;;;1168     io_ctx.Init        = IKS01A2_I2C_Init;
000012  482f              LDR      r0,|L15.208|
000014  9008              STR      r0,[sp,#0x20]
;;;1169     io_ctx.DeInit      = IKS01A2_I2C_DeInit;
000016  482f              LDR      r0,|L15.212|
000018  9009              STR      r0,[sp,#0x24]
;;;1170     io_ctx.ReadReg     = IKS01A2_I2C_ReadReg;
00001a  482f              LDR      r0,|L15.216|
00001c  900d              STR      r0,[sp,#0x34]
;;;1171     io_ctx.WriteReg    = IKS01A2_I2C_WriteReg;
00001e  482f              LDR      r0,|L15.220|
000020  900c              STR      r0,[sp,#0x30]
;;;1172     io_ctx.GetTick     = IKS01A2_GetTick;
000022  482f              LDR      r0,|L15.224|
000024  900e              STR      r0,[sp,#0x38]
;;;1173   
;;;1174     if (LSM303AGR_MAG_RegisterBusIO(&lsm303agr_mag_obj_0, &io_ctx) != LSM303AGR_OK)
000026  a908              ADD      r1,sp,#0x20
000028  482e              LDR      r0,|L15.228|
00002a  f7fffffe          BL       LSM303AGR_MAG_RegisterBusIO
00002e  b108              CBZ      r0,|L15.52|
;;;1175     {
;;;1176       ret = BSP_ERROR_UNKNOWN_COMPONENT;
000030  1fed              SUBS     r5,r5,#7
000032  e04a              B        |L15.202|
                  |L15.52|
;;;1177     }
;;;1178     else if (LSM303AGR_MAG_ReadID(&lsm303agr_mag_obj_0, &id) != LSM303AGR_OK)
000034  a907              ADD      r1,sp,#0x1c
000036  482b              LDR      r0,|L15.228|
000038  f7fffffe          BL       LSM303AGR_MAG_ReadID
00003c  b110              CBZ      r0,|L15.68|
;;;1179     {
;;;1180       ret = BSP_ERROR_UNKNOWN_COMPONENT;
00003e  f06f0506          MVN      r5,#6
000042  e042              B        |L15.202|
                  |L15.68|
;;;1181     }
;;;1182     else if (id != (uint8_t)LSM303AGR_ID_MG)
000044  f89d001c          LDRB     r0,[sp,#0x1c]
000048  2840              CMP      r0,#0x40
00004a  d002              BEQ      |L15.82|
;;;1183     {
;;;1184       ret = BSP_ERROR_UNKNOWN_COMPONENT;
00004c  f06f0506          MVN      r5,#6
000050  e03b              B        |L15.202|
                  |L15.82|
;;;1185     }
;;;1186     else
;;;1187     {
;;;1188       (void)LSM303AGR_MAG_GetCapabilities(&lsm303agr_mag_obj_0, &cap);
000052  4669              MOV      r1,sp
000054  4823              LDR      r0,|L15.228|
000056  f7fffffe          BL       LSM303AGR_MAG_GetCapabilities
;;;1189       MotionCtx[IKS01A2_LSM303AGR_MAG_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((
00005a  f89d0001          LDRB     r0,[sp,#1]
00005e  f89d1000          LDRB     r1,[sp,#0]
000062  ea400041          ORR      r0,r0,r1,LSL #1
000066  f89d1002          LDRB     r1,[sp,#2]
00006a  ea400081          ORR      r0,r0,r1,LSL #2
00006e  491e              LDR      r1,|L15.232|
000070  6088              STR      r0,[r1,#8]  ; MotionCtx
;;;1190                                                        uint32_t)cap.Magneto << 2);
;;;1191   
;;;1192       MotionCompObj[IKS01A2_LSM303AGR_MAG_0] = &lsm303agr_mag_obj_0;
000072  481c              LDR      r0,|L15.228|
000074  491d              LDR      r1,|L15.236|
000076  6088              STR      r0,[r1,#8]  ; MotionCompObj
;;;1193       /* The second cast (void *) is added to bypass Misra R11.3 rule */
;;;1194       MotionDrv[IKS01A2_LSM303AGR_MAG_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LSM303AGR_MAG_COMMON_Driver;
000078  481d              LDR      r0,|L15.240|
00007a  491e              LDR      r1,|L15.244|
00007c  6088              STR      r0,[r1,#8]  ; MotionDrv
;;;1195   
;;;1196       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO) && (cap.Magneto == 1U))
00007e  b9c5              CBNZ     r5,|L15.178|
000080  f0040004          AND      r0,r4,#4
000084  2804              CMP      r0,#4
000086  d114              BNE      |L15.178|
000088  f89d0002          LDRB     r0,[sp,#2]
00008c  2801              CMP      r0,#1
00008e  d110              BNE      |L15.178|
;;;1197       {
;;;1198         /* The second cast (void *) is added to bypass Misra R11.3 rule */
;;;1199         MotionFuncDrv[IKS01A2_LSM303AGR_MAG_0][FunctionIndex[MOTION_MAGNETO]] = (MOTION_SENSOR_FuncDrv_t *)(
000090  4919              LDR      r1,|L15.248|
000092  481a              LDR      r0,|L15.252|
000094  6902              LDR      r2,[r0,#0x10]  ; FunctionIndex
000096  481a              LDR      r0,|L15.256|
000098  f8401022          STR      r1,[r0,r2,LSL #2]
;;;1200               void *)&LSM303AGR_MAG_Driver;
;;;1201   
;;;1202         if (MotionDrv[IKS01A2_LSM303AGR_MAG_0]->Init(MotionCompObj[IKS01A2_LSM303AGR_MAG_0]) != LSM303AGR_OK)
00009c  4a13              LDR      r2,|L15.236|
00009e  6890              LDR      r0,[r2,#8]  ; MotionCompObj
0000a0  4a14              LDR      r2,|L15.244|
0000a2  6892              LDR      r2,[r2,#8]  ; MotionDrv
0000a4  6811              LDR      r1,[r2,#0]
0000a6  4788              BLX      r1
0000a8  b110              CBZ      r0,|L15.176|
;;;1203         {
;;;1204           ret = BSP_ERROR_COMPONENT_FAILURE;
0000aa  f06f0504          MVN      r5,#4
0000ae  e000              B        |L15.178|
                  |L15.176|
;;;1205         }
;;;1206         else
;;;1207         {
;;;1208           ret = BSP_ERROR_NONE;
0000b0  2500              MOVS     r5,#0
                  |L15.178|
;;;1209         }
;;;1210       }
;;;1211       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO))
0000b2  b925              CBNZ     r5,|L15.190|
0000b4  f0040002          AND      r0,r4,#2
0000b8  2802              CMP      r0,#2
0000ba  d100              BNE      |L15.190|
;;;1212       {
;;;1213         /* Return an error if the application try to initialize a function not supported by the component */
;;;1214         ret = BSP_ERROR_COMPONENT_FAILURE;
0000bc  1fc5              SUBS     r5,r0,#7
                  |L15.190|
;;;1215       }
;;;1216       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO))
0000be  b925              CBNZ     r5,|L15.202|
0000c0  f0040001          AND      r0,r4,#1
0000c4  b108              CBZ      r0,|L15.202|
;;;1217       {
;;;1218         /* Return an error if the application try to initialize a function not supported by the component */
;;;1219         ret = BSP_ERROR_COMPONENT_FAILURE;
0000c6  f06f0504          MVN      r5,#4
                  |L15.202|
;;;1220       }
;;;1221     }
;;;1222   
;;;1223     return ret;
0000ca  4628              MOV      r0,r5
;;;1224   }
0000cc  b00f              ADD      sp,sp,#0x3c
0000ce  bd30              POP      {r4,r5,pc}
;;;1225   #endif
                          ENDP

                  |L15.208|
                          DCD      BSP_I2C1_Init
                  |L15.212|
                          DCD      BSP_I2C1_DeInit
                  |L15.216|
                          DCD      BSP_I2C1_ReadReg
                  |L15.220|
                          DCD      BSP_I2C1_WriteReg
                  |L15.224|
                          DCD      BSP_GetTick
                  |L15.228|
                          DCD      lsm303agr_mag_obj_0
                  |L15.232|
                          DCD      MotionCtx
                  |L15.236|
                          DCD      MotionCompObj
                  |L15.240|
                          DCD      LSM303AGR_MAG_COMMON_Driver
                  |L15.244|
                          DCD      MotionDrv
                  |L15.248|
                          DCD      LSM303AGR_MAG_Driver
                  |L15.252|
                          DCD      FunctionIndex
                  |L15.256|
                          DCD      MotionFuncDrv+0x18

                          AREA ||i.LSM6DSL_0_Probe||, CODE, READONLY, ALIGN=2

                  LSM6DSL_0_Probe PROC
;;;999     */
;;;1000   static int32_t LSM6DSL_0_Probe(uint32_t Functions)
000000  b530              PUSH     {r4,r5,lr}
;;;1001   {
000002  b08f              SUB      sp,sp,#0x3c
000004  4604              MOV      r4,r0
;;;1002     LSM6DSL_IO_t            io_ctx;
;;;1003     uint8_t                 id;
;;;1004     static LSM6DSL_Object_t lsm6dsl_obj_0;
;;;1005     LSM6DSL_Capabilities_t  cap;
;;;1006     int32_t ret = BSP_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;1007   
;;;1008     /* Configure the accelero driver */
;;;1009     io_ctx.BusType     = LSM6DSL_I2C_BUS; /* I2C */
000008  2000              MOVS     r0,#0
00000a  900a              STR      r0,[sp,#0x28]
;;;1010     io_ctx.Address     = LSM6DSL_I2C_ADD_H;
00000c  20d7              MOVS     r0,#0xd7
00000e  f88d002c          STRB     r0,[sp,#0x2c]
;;;1011     io_ctx.Init        = IKS01A2_I2C_Init;
000012  4839              LDR      r0,|L16.248|
000014  9008              STR      r0,[sp,#0x20]
;;;1012     io_ctx.DeInit      = IKS01A2_I2C_DeInit;
000016  4839              LDR      r0,|L16.252|
000018  9009              STR      r0,[sp,#0x24]
;;;1013     io_ctx.ReadReg     = IKS01A2_I2C_ReadReg;
00001a  4839              LDR      r0,|L16.256|
00001c  900d              STR      r0,[sp,#0x34]
;;;1014     io_ctx.WriteReg    = IKS01A2_I2C_WriteReg;
00001e  4839              LDR      r0,|L16.260|
000020  900c              STR      r0,[sp,#0x30]
;;;1015     io_ctx.GetTick     = IKS01A2_GetTick;
000022  4839              LDR      r0,|L16.264|
000024  900e              STR      r0,[sp,#0x38]
;;;1016   
;;;1017     if (LSM6DSL_RegisterBusIO(&lsm6dsl_obj_0, &io_ctx) != LSM6DSL_OK)
000026  a908              ADD      r1,sp,#0x20
000028  4838              LDR      r0,|L16.268|
00002a  f7fffffe          BL       LSM6DSL_RegisterBusIO
00002e  b108              CBZ      r0,|L16.52|
;;;1018     {
;;;1019       ret = BSP_ERROR_UNKNOWN_COMPONENT;
000030  1fed              SUBS     r5,r5,#7
000032  e05d              B        |L16.240|
                  |L16.52|
;;;1020     }
;;;1021     else if (LSM6DSL_ReadID(&lsm6dsl_obj_0, &id) != LSM6DSL_OK)
000034  a907              ADD      r1,sp,#0x1c
000036  4835              LDR      r0,|L16.268|
000038  f7fffffe          BL       LSM6DSL_ReadID
00003c  b110              CBZ      r0,|L16.68|
;;;1022     {
;;;1023       ret = BSP_ERROR_UNKNOWN_COMPONENT;
00003e  f06f0506          MVN      r5,#6
000042  e055              B        |L16.240|
                  |L16.68|
;;;1024     }
;;;1025     else if (id != LSM6DSL_ID)
000044  f89d001c          LDRB     r0,[sp,#0x1c]
000048  286a              CMP      r0,#0x6a
00004a  d002              BEQ      |L16.82|
;;;1026     {
;;;1027       ret = BSP_ERROR_UNKNOWN_COMPONENT;
00004c  f06f0506          MVN      r5,#6
000050  e04e              B        |L16.240|
                  |L16.82|
;;;1028     }
;;;1029     else
;;;1030     {
;;;1031       (void)LSM6DSL_GetCapabilities(&lsm6dsl_obj_0, &cap);
000052  4669              MOV      r1,sp
000054  482d              LDR      r0,|L16.268|
000056  f7fffffe          BL       LSM6DSL_GetCapabilities
;;;1032       MotionCtx[IKS01A2_LSM6DSL_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((uint32_t)cap.Magneto << 2);
00005a  f89d0001          LDRB     r0,[sp,#1]
00005e  f89d1000          LDRB     r1,[sp,#0]
000062  ea400041          ORR      r0,r0,r1,LSL #1
000066  f89d1002          LDRB     r1,[sp,#2]
00006a  ea400081          ORR      r0,r0,r1,LSL #2
00006e  4928              LDR      r1,|L16.272|
000070  6008              STR      r0,[r1,#0]  ; MotionCtx
;;;1033   
;;;1034       MotionCompObj[IKS01A2_LSM6DSL_0] = &lsm6dsl_obj_0;
000072  4826              LDR      r0,|L16.268|
000074  4927              LDR      r1,|L16.276|
000076  6008              STR      r0,[r1,#0]  ; MotionCompObj
;;;1035       /* The second cast (void *) is added to bypass Misra R11.3 rule */
;;;1036       MotionDrv[IKS01A2_LSM6DSL_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LSM6DSL_COMMON_Driver;
000078  4827              LDR      r0,|L16.280|
00007a  4928              LDR      r1,|L16.284|
00007c  6008              STR      r0,[r1,#0]  ; MotionDrv
;;;1037   
;;;1038       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO) && (cap.Gyro == 1U))
00007e  b9bd              CBNZ     r5,|L16.176|
000080  f0040001          AND      r0,r4,#1
000084  b1a0              CBZ      r0,|L16.176|
000086  f89d0001          LDRB     r0,[sp,#1]
00008a  2801              CMP      r0,#1
00008c  d110              BNE      |L16.176|
;;;1039       {
;;;1040         /* The second cast (void *) is added to bypass Misra R11.3 rule */
;;;1041         MotionFuncDrv[IKS01A2_LSM6DSL_0][FunctionIndex[MOTION_GYRO]] = (MOTION_SENSOR_FuncDrv_t *)(void *)&LSM6DSL_GYRO_Driver;
00008e  4824              LDR      r0,|L16.288|
000090  4924              LDR      r1,|L16.292|
000092  6849              LDR      r1,[r1,#4]  ; FunctionIndex
000094  4a24              LDR      r2,|L16.296|
000096  f8420021          STR      r0,[r2,r1,LSL #2]
;;;1042   
;;;1043         if (MotionDrv[IKS01A2_LSM6DSL_0]->Init(MotionCompObj[IKS01A2_LSM6DSL_0]) != LSM6DSL_OK)
00009a  4a1e              LDR      r2,|L16.276|
00009c  6810              LDR      r0,[r2,#0]  ; MotionCompObj
00009e  4a1f              LDR      r2,|L16.284|
0000a0  6812              LDR      r2,[r2,#0]  ; MotionDrv
0000a2  6811              LDR      r1,[r2,#0]
0000a4  4788              BLX      r1
0000a6  b110              CBZ      r0,|L16.174|
;;;1044         {
;;;1045           ret = BSP_ERROR_COMPONENT_FAILURE;
0000a8  f06f0504          MVN      r5,#4
0000ac  e000              B        |L16.176|
                  |L16.174|
;;;1046         }
;;;1047         else
;;;1048         {
;;;1049           ret = BSP_ERROR_NONE;
0000ae  2500              MOVS     r5,#0
                  |L16.176|
;;;1050         }
;;;1051       }
;;;1052       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO) && (cap.Acc == 1U))
0000b0  b9c5              CBNZ     r5,|L16.228|
0000b2  f0040002          AND      r0,r4,#2
0000b6  2802              CMP      r0,#2
0000b8  d114              BNE      |L16.228|
0000ba  f89d0000          LDRB     r0,[sp,#0]
0000be  2801              CMP      r0,#1
0000c0  d110              BNE      |L16.228|
;;;1053       {
;;;1054         /* The second cast (void *) is added to bypass Misra R11.3 rule */
;;;1055         MotionFuncDrv[IKS01A2_LSM6DSL_0][FunctionIndex[MOTION_ACCELERO]] = (MOTION_SENSOR_FuncDrv_t *)(
0000c2  481a              LDR      r0,|L16.300|
0000c4  4917              LDR      r1,|L16.292|
0000c6  6889              LDR      r1,[r1,#8]  ; FunctionIndex
0000c8  4a17              LDR      r2,|L16.296|
0000ca  f8420021          STR      r0,[r2,r1,LSL #2]
;;;1056               void *)&LSM6DSL_ACC_Driver;
;;;1057   
;;;1058         if (MotionDrv[IKS01A2_LSM6DSL_0]->Init(MotionCompObj[IKS01A2_LSM6DSL_0]) != LSM6DSL_OK)
0000ce  4a11              LDR      r2,|L16.276|
0000d0  6810              LDR      r0,[r2,#0]  ; MotionCompObj
0000d2  4a12              LDR      r2,|L16.284|
0000d4  6812              LDR      r2,[r2,#0]  ; MotionDrv
0000d6  6811              LDR      r1,[r2,#0]
0000d8  4788              BLX      r1
0000da  b110              CBZ      r0,|L16.226|
;;;1059         {
;;;1060           ret = BSP_ERROR_COMPONENT_FAILURE;
0000dc  f06f0504          MVN      r5,#4
0000e0  e000              B        |L16.228|
                  |L16.226|
;;;1061         }
;;;1062         else
;;;1063         {
;;;1064           ret = BSP_ERROR_NONE;
0000e2  2500              MOVS     r5,#0
                  |L16.228|
;;;1065         }
;;;1066       }
;;;1067       if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO))
0000e4  b925              CBNZ     r5,|L16.240|
0000e6  f0040004          AND      r0,r4,#4
0000ea  2804              CMP      r0,#4
0000ec  d100              BNE      |L16.240|
;;;1068       {
;;;1069         /* Return an error if the application try to initialize a function not supported by the component */
;;;1070         ret = BSP_ERROR_COMPONENT_FAILURE;
0000ee  43c5              MVNS     r5,r0
                  |L16.240|
;;;1071       }
;;;1072     }
;;;1073     return ret;
0000f0  4628              MOV      r0,r5
;;;1074   }
0000f2  b00f              ADD      sp,sp,#0x3c
0000f4  bd30              POP      {r4,r5,pc}
;;;1075   #endif
                          ENDP

0000f6  0000              DCW      0x0000
                  |L16.248|
                          DCD      BSP_I2C1_Init
                  |L16.252|
                          DCD      BSP_I2C1_DeInit
                  |L16.256|
                          DCD      BSP_I2C1_ReadReg
                  |L16.260|
                          DCD      BSP_I2C1_WriteReg
                  |L16.264|
                          DCD      BSP_GetTick
                  |L16.268|
                          DCD      lsm6dsl_obj_0
                  |L16.272|
                          DCD      MotionCtx
                  |L16.276|
                          DCD      MotionCompObj
                  |L16.280|
                          DCD      LSM6DSL_COMMON_Driver
                  |L16.284|
                          DCD      MotionDrv
                  |L16.288|
                          DCD      LSM6DSL_GYRO_Driver
                  |L16.292|
                          DCD      FunctionIndex
                  |L16.296|
                          DCD      MotionFuncDrv
                  |L16.300|
                          DCD      LSM6DSL_ACC_Driver

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  MotionCompObj
                          %        12
                  MotionFuncDrv
                          %        36
                  MotionDrv
                          %        12
                  MotionCtx
                          %        12
                  lsm6dsl_obj_0
                          %        48
                  lsm303agr_acc_obj_0
                          %        44
                  lsm303agr_mag_obj_0
                          %        44

                          AREA ||.data||, DATA, ALIGN=2

                  FunctionIndex
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000002

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\BSP\\IKS01A2\\iks01a2_motion_sensors.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_iks01a2_motion_sensors_c_3f75d55b____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___24_iks01a2_motion_sensors_c_3f75d55b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_iks01a2_motion_sensors_c_3f75d55b____REVSH|
#line 402
|__asm___24_iks01a2_motion_sensors_c_3f75d55b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_iks01a2_motion_sensors_c_3f75d55b____RRX|
#line 587
|__asm___24_iks01a2_motion_sensors_c_3f75d55b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
