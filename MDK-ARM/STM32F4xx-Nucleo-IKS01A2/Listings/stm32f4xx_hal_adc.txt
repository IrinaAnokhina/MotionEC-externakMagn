; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_adc.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_adc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc.c]
                          THUMB

                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAConvCplt PROC
;;;1944     */
;;;1945   static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;1946   {
000002  4605              MOV      r5,r0
;;;1947     /* Retrieve ADC handle corresponding to current DMA handle */
;;;1948     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1949     
;;;1950     /* Update state machine on conversion status if not in error state */
;;;1951     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
000006  6c20              LDR      r0,[r4,#0x40]
000008  f0000050          AND      r0,r0,#0x50
00000c  bb50              CBNZ     r0,|L1.100|
;;;1952     {
;;;1953       /* Update ADC state machine */
;;;1954       SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
00000e  6c20              LDR      r0,[r4,#0x40]
000010  f4407000          ORR      r0,r0,#0x200
000014  6420              STR      r0,[r4,#0x40]
;;;1955       
;;;1956       /* Determine whether any further conversion upcoming on group regular   */
;;;1957       /* by external trigger, continuous mode or scan sequence on going.      */
;;;1958       /* Note: On STM32F4, there is no independent flag of end of sequence.   */
;;;1959       /*       The test of scan sequence on going is done either with scan    */
;;;1960       /*       sequence disabled or with end of conversion flag set to        */
;;;1961       /*       of end of sequence.                                            */
;;;1962       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
000016  6820              LDR      r0,[r4,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f0005040          AND      r0,r0,#0x30000000
00001e  b9e8              CBNZ     r0,|L1.92|
;;;1963          (hadc->Init.ContinuousConvMode == DISABLE)            &&
000020  7e20              LDRB     r0,[r4,#0x18]
000022  b9d8              CBNZ     r0,|L1.92|
;;;1964          (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
000024  6820              LDR      r0,[r4,#0]
000026  6ac0              LDR      r0,[r0,#0x2c]
000028  f4000070          AND      r0,r0,#0xf00000
00002c  b120              CBZ      r0,|L1.56|
;;;1965           HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
00002e  6820              LDR      r0,[r4,#0]
000030  6880              LDR      r0,[r0,#8]
000032  f4006080          AND      r0,r0,#0x400
000036  b988              CBNZ     r0,|L1.92|
                  |L1.56|
;;;1966       {
;;;1967         /* Disable ADC end of single conversion interrupt on group regular */
;;;1968         /* Note: Overrun interrupt was enabled with EOC interrupt in          */
;;;1969         /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
;;;1970         /* by overrun IRQ process below.                                      */
;;;1971         __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
000038  6820              LDR      r0,[r4,#0]
00003a  6840              LDR      r0,[r0,#4]
00003c  f0200020          BIC      r0,r0,#0x20
000040  6821              LDR      r1,[r4,#0]
000042  6048              STR      r0,[r1,#4]
;;;1972         
;;;1973         /* Set ADC state */
;;;1974         CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
000044  6c20              LDR      r0,[r4,#0x40]
000046  f4207080          BIC      r0,r0,#0x100
00004a  6420              STR      r0,[r4,#0x40]
;;;1975         
;;;1976         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
00004c  6c20              LDR      r0,[r4,#0x40]
00004e  f4005080          AND      r0,r0,#0x1000
000052  b918              CBNZ     r0,|L1.92|
;;;1977         {
;;;1978           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
000054  6c20              LDR      r0,[r4,#0x40]
000056  f0400001          ORR      r0,r0,#1
00005a  6420              STR      r0,[r4,#0x40]
                  |L1.92|
;;;1979         }
;;;1980       }
;;;1981       
;;;1982       /* Conversion complete callback */
;;;1983   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1984       hadc->ConvCpltCallback(hadc);
;;;1985   #else
;;;1986       HAL_ADC_ConvCpltCallback(hadc);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_ADC_ConvCpltCallback
000062  e00b              B        |L1.124|
                  |L1.100|
;;;1987   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1988     }
;;;1989     else /* DMA and-or internal error occurred */
;;;1990     {
;;;1991       if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
000064  6c20              LDR      r0,[r4,#0x40]
000066  f0000010          AND      r0,r0,#0x10
00006a  b118              CBZ      r0,|L1.116|
;;;1992       {
;;;1993         /* Call HAL ADC Error Callback function */
;;;1994   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1995         hadc->ErrorCallback(hadc);
;;;1996   #else
;;;1997         HAL_ADC_ErrorCallback(hadc);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       HAL_ADC_ErrorCallback
000072  e003              B        |L1.124|
                  |L1.116|
;;;1998   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1999       }
;;;2000   	else
;;;2001   	{
;;;2002         /* Call DMA error callback */
;;;2003         hadc->DMA_Handle->XferErrorCallback(hdma);
000074  6ba0              LDR      r0,[r4,#0x38]
000076  6cc1              LDR      r1,[r0,#0x4c]
000078  4628              MOV      r0,r5
00007a  4788              BLX      r1
                  |L1.124|
;;;2004       }
;;;2005     }
;;;2006   }
00007c  bd70              POP      {r4-r6,pc}
;;;2007   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;2030     */
;;;2031   static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2032   {
000002  4605              MOV      r5,r0
;;;2033     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2034     hadc->State= HAL_ADC_STATE_ERROR_DMA;
000006  2040              MOVS     r0,#0x40
000008  6420              STR      r0,[r4,#0x40]
;;;2035     /* Set ADC error code to DMA error */
;;;2036     hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
00000a  6c60              LDR      r0,[r4,#0x44]
00000c  f0400004          ORR      r0,r0,#4
000010  6460              STR      r0,[r4,#0x44]
;;;2037      /* Error callback */
;;;2038   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2039     hadc->ErrorCallback(hadc);
;;;2040   #else
;;;2041     HAL_ADC_ErrorCallback(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;2042   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2043   }
000018  bd70              POP      {r4-r6,pc}
;;;2044   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;2013     */
;;;2014   static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2015   {
000002  4604              MOV      r4,r0
;;;2016     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2017      /* Half conversion callback */
;;;2018   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2019     hadc->ConvHalfCpltCallback(hadc);
;;;2020   #else
;;;2021     HAL_ADC_ConvHalfCpltCallback(hadc);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;2022   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2023   }
00000c  bd70              POP      {r4-r6,pc}
;;;2024   
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;1856     */
;;;1857   static void ADC_Init(ADC_HandleTypeDef* hadc)
000000  4955              LDR      r1,|L4.344|
;;;1858   {
;;;1859     ADC_Common_TypeDef *tmpADC_Common;
;;;1860     
;;;1861     /* Set ADC parameters */
;;;1862     /* Pointer to the common control register to which is belonging hadc    */
;;;1863     /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;1864     /* control register)                                                    */
;;;1865     tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;1866     
;;;1867     /* Set the ADC clock prescaler */
;;;1868     tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
000002  684a              LDR      r2,[r1,#4]
000004  f4223240          BIC      r2,r2,#0x30000
000008  604a              STR      r2,[r1,#4]
;;;1869     tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
00000a  684a              LDR      r2,[r1,#4]
00000c  6843              LDR      r3,[r0,#4]
00000e  431a              ORRS     r2,r2,r3
000010  604a              STR      r2,[r1,#4]
;;;1870     
;;;1871     /* Set ADC scan mode */
;;;1872     hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
000012  6802              LDR      r2,[r0,#0]
000014  6852              LDR      r2,[r2,#4]
000016  f4227280          BIC      r2,r2,#0x100
00001a  6803              LDR      r3,[r0,#0]
00001c  605a              STR      r2,[r3,#4]
;;;1873     hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
00001e  6802              LDR      r2,[r0,#0]
000020  6853              LDR      r3,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
000024  ea432202          ORR      r2,r3,r2,LSL #8
000028  6803              LDR      r3,[r0,#0]
00002a  605a              STR      r2,[r3,#4]
;;;1874     
;;;1875     /* Set ADC resolution */
;;;1876     hadc->Instance->CR1 &= ~(ADC_CR1_RES);
00002c  6802              LDR      r2,[r0,#0]
00002e  6852              LDR      r2,[r2,#4]
000030  f0227240          BIC      r2,r2,#0x3000000
000034  6803              LDR      r3,[r0,#0]
000036  605a              STR      r2,[r3,#4]
;;;1877     hadc->Instance->CR1 |=  hadc->Init.Resolution;
000038  6802              LDR      r2,[r0,#0]
00003a  6852              LDR      r2,[r2,#4]
00003c  6883              LDR      r3,[r0,#8]
00003e  431a              ORRS     r2,r2,r3
000040  6803              LDR      r3,[r0,#0]
000042  605a              STR      r2,[r3,#4]
;;;1878     
;;;1879     /* Set ADC data alignment */
;;;1880     hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
000044  6802              LDR      r2,[r0,#0]
000046  6892              LDR      r2,[r2,#8]
000048  f4226200          BIC      r2,r2,#0x800
00004c  6803              LDR      r3,[r0,#0]
00004e  609a              STR      r2,[r3,#8]
;;;1881     hadc->Instance->CR2 |= hadc->Init.DataAlign;
000050  6802              LDR      r2,[r0,#0]
000052  6892              LDR      r2,[r2,#8]
000054  68c3              LDR      r3,[r0,#0xc]
000056  431a              ORRS     r2,r2,r3
000058  6803              LDR      r3,[r0,#0]
00005a  609a              STR      r2,[r3,#8]
;;;1882     
;;;1883     /* Enable external trigger if trigger selection is different of software  */
;;;1884     /* start.                                                                 */
;;;1885     /* Note: This configuration keeps the hardware feature of parameter       */
;;;1886     /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
;;;1887     /*       software start.                                                  */
;;;1888     if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
00005c  4b3f              LDR      r3,|L4.348|
00005e  6a82              LDR      r2,[r0,#0x28]
000060  429a              CMP      r2,r3
000062  d018              BEQ      |L4.150|
;;;1889     {
;;;1890       /* Select external trigger to start conversion */
;;;1891       hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
000064  6802              LDR      r2,[r0,#0]
000066  6892              LDR      r2,[r2,#8]
000068  f0226270          BIC      r2,r2,#0xf000000
00006c  6803              LDR      r3,[r0,#0]
00006e  609a              STR      r2,[r3,#8]
;;;1892       hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
000070  6802              LDR      r2,[r0,#0]
000072  6892              LDR      r2,[r2,#8]
000074  6a83              LDR      r3,[r0,#0x28]
000076  431a              ORRS     r2,r2,r3
000078  6803              LDR      r3,[r0,#0]
00007a  609a              STR      r2,[r3,#8]
;;;1893       
;;;1894       /* Select external trigger polarity */
;;;1895       hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
00007c  6802              LDR      r2,[r0,#0]
00007e  6892              LDR      r2,[r2,#8]
000080  f0225240          BIC      r2,r2,#0x30000000
000084  6803              LDR      r3,[r0,#0]
000086  609a              STR      r2,[r3,#8]
;;;1896       hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
000088  6802              LDR      r2,[r0,#0]
00008a  6892              LDR      r2,[r2,#8]
00008c  6ac3              LDR      r3,[r0,#0x2c]
00008e  431a              ORRS     r2,r2,r3
000090  6803              LDR      r3,[r0,#0]
000092  609a              STR      r2,[r3,#8]
000094  e00b              B        |L4.174|
                  |L4.150|
;;;1897     }
;;;1898     else
;;;1899     {
;;;1900       /* Reset the external trigger */
;;;1901       hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
000096  6802              LDR      r2,[r0,#0]
000098  6892              LDR      r2,[r2,#8]
00009a  f0226270          BIC      r2,r2,#0xf000000
00009e  6803              LDR      r3,[r0,#0]
0000a0  609a              STR      r2,[r3,#8]
;;;1902       hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
0000a2  6802              LDR      r2,[r0,#0]
0000a4  6892              LDR      r2,[r2,#8]
0000a6  f0225240          BIC      r2,r2,#0x30000000
0000aa  6803              LDR      r3,[r0,#0]
0000ac  609a              STR      r2,[r3,#8]
                  |L4.174|
;;;1903     }
;;;1904     
;;;1905     /* Enable or disable ADC continuous conversion mode */
;;;1906     hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
0000ae  6802              LDR      r2,[r0,#0]
0000b0  6892              LDR      r2,[r2,#8]
0000b2  f0220202          BIC      r2,r2,#2
0000b6  6803              LDR      r3,[r0,#0]
0000b8  609a              STR      r2,[r3,#8]
;;;1907     hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
0000ba  6802              LDR      r2,[r0,#0]
0000bc  6893              LDR      r3,[r2,#8]
0000be  7e02              LDRB     r2,[r0,#0x18]
0000c0  ea430242          ORR      r2,r3,r2,LSL #1
0000c4  6803              LDR      r3,[r0,#0]
0000c6  609a              STR      r2,[r3,#8]
;;;1908     
;;;1909     if(hadc->Init.DiscontinuousConvMode != DISABLE)
0000c8  2220              MOVS     r2,#0x20
0000ca  5c12              LDRB     r2,[r2,r0]
0000cc  b1a2              CBZ      r2,|L4.248|
;;;1910     {
;;;1911       assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
;;;1912     
;;;1913       /* Enable the selected ADC regular discontinuous mode */
;;;1914       hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
0000ce  6802              LDR      r2,[r0,#0]
0000d0  6852              LDR      r2,[r2,#4]
0000d2  f4426200          ORR      r2,r2,#0x800
0000d6  6803              LDR      r3,[r0,#0]
0000d8  605a              STR      r2,[r3,#4]
;;;1915       
;;;1916       /* Set the number of channels to be converted in discontinuous mode */
;;;1917       hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
0000da  6802              LDR      r2,[r0,#0]
0000dc  6852              LDR      r2,[r2,#4]
0000de  f4224260          BIC      r2,r2,#0xe000
0000e2  6803              LDR      r3,[r0,#0]
0000e4  605a              STR      r2,[r3,#4]
;;;1918       hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
0000e6  6802              LDR      r2,[r0,#0]
0000e8  6853              LDR      r3,[r2,#4]
0000ea  6a42              LDR      r2,[r0,#0x24]
0000ec  1e52              SUBS     r2,r2,#1
0000ee  ea433242          ORR      r2,r3,r2,LSL #13
0000f2  6803              LDR      r3,[r0,#0]
0000f4  605a              STR      r2,[r3,#4]
0000f6  e005              B        |L4.260|
                  |L4.248|
;;;1919     }
;;;1920     else
;;;1921     {
;;;1922       /* Disable the selected ADC regular discontinuous mode */
;;;1923       hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
0000f8  6802              LDR      r2,[r0,#0]
0000fa  6852              LDR      r2,[r2,#4]
0000fc  f4226200          BIC      r2,r2,#0x800
000100  6803              LDR      r3,[r0,#0]
000102  605a              STR      r2,[r3,#4]
                  |L4.260|
;;;1924     }
;;;1925     
;;;1926     /* Set ADC number of conversion */
;;;1927     hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
000104  6802              LDR      r2,[r0,#0]
000106  6ad2              LDR      r2,[r2,#0x2c]
000108  f4220270          BIC      r2,r2,#0xf00000
00010c  6803              LDR      r3,[r0,#0]
00010e  62da              STR      r2,[r3,#0x2c]
;;;1928     hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
000110  6802              LDR      r2,[r0,#0]
000112  6ad3              LDR      r3,[r2,#0x2c]
000114  8b82              LDRH     r2,[r0,#0x1c]
000116  1e52              SUBS     r2,r2,#1
000118  ea435202          ORR      r2,r3,r2,LSL #20
00011c  6803              LDR      r3,[r0,#0]
00011e  62da              STR      r2,[r3,#0x2c]
;;;1929     
;;;1930     /* Enable or disable ADC DMA continuous request */
;;;1931     hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
000120  6802              LDR      r2,[r0,#0]
000122  6892              LDR      r2,[r2,#8]
000124  f4227200          BIC      r2,r2,#0x200
000128  6803              LDR      r3,[r0,#0]
00012a  609a              STR      r2,[r3,#8]
;;;1932     hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
00012c  6802              LDR      r2,[r0,#0]
00012e  6893              LDR      r3,[r2,#8]
000130  f8902030          LDRB     r2,[r0,#0x30]
000134  ea432242          ORR      r2,r3,r2,LSL #9
000138  6803              LDR      r3,[r0,#0]
00013a  609a              STR      r2,[r3,#8]
;;;1933     
;;;1934     /* Enable or disable ADC end of conversion selection */
;;;1935     hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
00013c  6802              LDR      r2,[r0,#0]
00013e  6892              LDR      r2,[r2,#8]
000140  f4226280          BIC      r2,r2,#0x400
000144  6803              LDR      r3,[r0,#0]
000146  609a              STR      r2,[r3,#8]
;;;1936     hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
000148  6802              LDR      r2,[r0,#0]
00014a  6893              LDR      r3,[r2,#8]
00014c  6942              LDR      r2,[r0,#0x14]
00014e  ea432282          ORR      r2,r3,r2,LSL #10
000152  6803              LDR      r3,[r0,#0]
000154  609a              STR      r2,[r3,#8]
;;;1937   }
000156  4770              BX       lr
;;;1938   
                          ENDP

                  |L4.344|
                          DCD      0x40012300
                  |L4.348|
                          DCD      0x0f000001

                          AREA ||i.HAL_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=2

                  HAL_ADC_AnalogWDGConfig PROC
;;;1742     */
;;;1743   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000000  4602              MOV      r2,r0
;;;1744   {
;;;1745   #ifdef USE_FULL_ASSERT  
;;;1746     uint32_t tmp = 0U;
;;;1747   #endif /* USE_FULL_ASSERT  */  
;;;1748     
;;;1749     /* Check the parameters */
;;;1750     assert_param(IS_ADC_ANALOG_WATCHDOG(AnalogWDGConfig->WatchdogMode));
;;;1751     assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
;;;1752     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;1753   
;;;1754   #ifdef USE_FULL_ASSERT  
;;;1755     tmp = ADC_GET_RESOLUTION(hadc);
;;;1756     assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->HighThreshold));
;;;1757     assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->LowThreshold));
;;;1758   #endif /* USE_FULL_ASSERT  */
;;;1759     
;;;1760     /* Process locked */
;;;1761     __HAL_LOCK(hadc);
000002  bf00              NOP      
000004  f892003c          LDRB     r0,[r2,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;1762     
;;;1763     if(AnalogWDGConfig->ITMode == ENABLE)
;;;1764     {
;;;1765       /* Enable the ADC Analog watchdog interrupt */
;;;1766       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
;;;1767     }
;;;1768     else
;;;1769     {
;;;1770       /* Disable the ADC Analog watchdog interrupt */
;;;1771       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
;;;1772     }
;;;1773     
;;;1774     /* Clear AWDEN, JAWDEN and AWDSGL bits */
;;;1775     hadc->Instance->CR1 &=  ~(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN | ADC_CR1_AWDEN);
;;;1776     
;;;1777     /* Set the analog watchdog enable mode */
;;;1778     hadc->Instance->CR1 |= AnalogWDGConfig->WatchdogMode;
;;;1779     
;;;1780     /* Set the high threshold */
;;;1781     hadc->Instance->HTR = AnalogWDGConfig->HighThreshold;
;;;1782     
;;;1783     /* Set the low threshold */
;;;1784     hadc->Instance->LTR = AnalogWDGConfig->LowThreshold;
;;;1785     
;;;1786     /* Clear the Analog watchdog channel select bits */
;;;1787     hadc->Instance->CR1 &= ~ADC_CR1_AWDCH;
;;;1788     
;;;1789     /* Set the Analog watchdog channel */
;;;1790     hadc->Instance->CR1 |= (uint32_t)((uint16_t)(AnalogWDGConfig->Channel));
;;;1791     
;;;1792     /* Process unlocked */
;;;1793     __HAL_UNLOCK(hadc);
;;;1794     
;;;1795     /* Return function status */
;;;1796     return HAL_OK;
;;;1797   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;1761
000012  f882003c          STRB     r0,[r2,#0x3c]         ;1761
000016  bf00              NOP                            ;1761
000018  7c08              LDRB     r0,[r1,#0x10]         ;1763
00001a  2801              CMP      r0,#1                 ;1763
00001c  d106              BNE      |L5.44|
00001e  6810              LDR      r0,[r2,#0]            ;1766
000020  6840              LDR      r0,[r0,#4]            ;1766
000022  f0400040          ORR      r0,r0,#0x40           ;1766
000026  6813              LDR      r3,[r2,#0]            ;1766
000028  6058              STR      r0,[r3,#4]            ;1766
00002a  e005              B        |L5.56|
                  |L5.44|
00002c  6810              LDR      r0,[r2,#0]            ;1771
00002e  6840              LDR      r0,[r0,#4]            ;1771
000030  f0200040          BIC      r0,r0,#0x40           ;1771
000034  6813              LDR      r3,[r2,#0]            ;1771
000036  6058              STR      r0,[r3,#4]            ;1771
                  |L5.56|
000038  6810              LDR      r0,[r2,#0]            ;1775
00003a  6840              LDR      r0,[r0,#4]            ;1775
00003c  4b11              LDR      r3,|L5.132|
00003e  4018              ANDS     r0,r0,r3              ;1775
000040  6813              LDR      r3,[r2,#0]            ;1775
000042  6058              STR      r0,[r3,#4]            ;1775
000044  6810              LDR      r0,[r2,#0]            ;1778
000046  6840              LDR      r0,[r0,#4]            ;1778
000048  680b              LDR      r3,[r1,#0]            ;1778
00004a  4318              ORRS     r0,r0,r3              ;1778
00004c  6813              LDR      r3,[r2,#0]            ;1778
00004e  6058              STR      r0,[r3,#4]            ;1778
000050  6848              LDR      r0,[r1,#4]            ;1781
000052  6813              LDR      r3,[r2,#0]            ;1781
000054  6258              STR      r0,[r3,#0x24]         ;1781
000056  6888              LDR      r0,[r1,#8]            ;1784
000058  6813              LDR      r3,[r2,#0]            ;1784
00005a  6298              STR      r0,[r3,#0x28]         ;1784
00005c  6810              LDR      r0,[r2,#0]            ;1787
00005e  6840              LDR      r0,[r0,#4]            ;1787
000060  f020001f          BIC      r0,r0,#0x1f           ;1787
000064  6813              LDR      r3,[r2,#0]            ;1787
000066  6058              STR      r0,[r3,#4]            ;1787
000068  6810              LDR      r0,[r2,#0]            ;1790
00006a  6840              LDR      r0,[r0,#4]            ;1790
00006c  898b              LDRH     r3,[r1,#0xc]          ;1790
00006e  b29b              UXTH     r3,r3                 ;1790
000070  4318              ORRS     r0,r0,r3              ;1790
000072  6813              LDR      r3,[r2,#0]            ;1790
000074  6058              STR      r0,[r3,#4]            ;1790
000076  bf00              NOP                            ;1793
000078  2000              MOVS     r0,#0                 ;1793
00007a  f882003c          STRB     r0,[r2,#0x3c]         ;1793
00007e  bf00              NOP                            ;1793
000080  bf00              NOP                            ;1796
000082  e7c4              B        |L5.14|
;;;1798   
                          ENDP

                  |L5.132|
                          DCD      0xff3ffdff

                          AREA ||i.HAL_ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADC_ConfigChannel PROC
;;;1619     */
;;;1620   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
000000  b538              PUSH     {r3-r5,lr}
;;;1621   {
000002  4602              MOV      r2,r0
;;;1622     __IO uint32_t counter = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1623     ADC_Common_TypeDef *tmpADC_Common;
;;;1624     
;;;1625     /* Check the parameters */
;;;1626     assert_param(IS_ADC_CHANNEL(sConfig->Channel));
;;;1627     assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
;;;1628     assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
;;;1629     
;;;1630     /* Process locked */
;;;1631     __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f892003c          LDRB     r0,[r2,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L6.22|
000012  2002              MOVS     r0,#2
                  |L6.20|
;;;1632       
;;;1633     /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;1634     if (sConfig->Channel > ADC_CHANNEL_9)
;;;1635     {
;;;1636       /* Clear the old sample time */
;;;1637       hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
;;;1638       
;;;1639       /* Set the new sample time */
;;;1640       hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
;;;1641     }
;;;1642     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1643     {
;;;1644       /* Clear the old sample time */
;;;1645       hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
;;;1646       
;;;1647       /* Set the new sample time */
;;;1648       hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
;;;1649     }
;;;1650     
;;;1651     /* For Rank 1 to 6 */
;;;1652     if (sConfig->Rank < 7U)
;;;1653     {
;;;1654       /* Clear the old SQx bits for the selected rank */
;;;1655       hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
;;;1656       
;;;1657       /* Set the SQx bits for the selected rank */
;;;1658       hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
;;;1659     }
;;;1660     /* For Rank 7 to 12 */
;;;1661     else if (sConfig->Rank < 13U)
;;;1662     {
;;;1663       /* Clear the old SQx bits for the selected rank */
;;;1664       hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
;;;1665       
;;;1666       /* Set the SQx bits for the selected rank */
;;;1667       hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
;;;1668     }
;;;1669     /* For Rank 13 to 16 */
;;;1670     else
;;;1671     {
;;;1672       /* Clear the old SQx bits for the selected rank */
;;;1673       hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
;;;1674       
;;;1675       /* Set the SQx bits for the selected rank */
;;;1676       hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
;;;1677     }
;;;1678   
;;;1679       /* Pointer to the common control register to which is belonging hadc    */
;;;1680       /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;1681       /* control register)                                                    */
;;;1682       tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;1683   
;;;1684     /* if ADC1 Channel_18 is selected for VBAT Channel ennable VBATE */
;;;1685     if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
;;;1686     {
;;;1687       /* Disable the TEMPSENSOR channel in case of using board with multiplixed ADC_CHANNEL_VBAT & ADC_CHANNEL_TEMPSENSOR*/    
;;;1688       if ((uint16_t)ADC_CHANNEL_TEMPSENSOR == (uint16_t)ADC_CHANNEL_VBAT)
;;;1689       {
;;;1690         tmpADC_Common->CCR &= ~ADC_CCR_TSVREFE;
;;;1691       }
;;;1692       /* Enable the VBAT channel*/
;;;1693       tmpADC_Common->CCR |= ADC_CCR_VBATE;
;;;1694     }
;;;1695     
;;;1696     /* if ADC1 Channel_16 or Channel_18 is selected for Temperature sensor or 
;;;1697        Channel_17 is selected for VREFINT enable TSVREFE */
;;;1698     if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
;;;1699     {
;;;1700       /* Disable the VBAT channel in case of using board with multiplixed ADC_CHANNEL_VBAT & ADC_CHANNEL_TEMPSENSOR*/
;;;1701       if ((uint16_t)ADC_CHANNEL_TEMPSENSOR == (uint16_t)ADC_CHANNEL_VBAT)
;;;1702       {
;;;1703         tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
;;;1704       }
;;;1705       /* Enable the Temperature sensor and VREFINT channel*/
;;;1706       tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
;;;1707       
;;;1708       if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
;;;1709       {
;;;1710         /* Delay for temperature sensor stabilization time */
;;;1711         /* Compute number of CPU cycles to wait for */
;;;1712         counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
;;;1713         while(counter != 0U)
;;;1714         {
;;;1715           counter--;
;;;1716         }
;;;1717       }
;;;1718     }
;;;1719     
;;;1720     /* Process unlocked */
;;;1721     __HAL_UNLOCK(hadc);
;;;1722     
;;;1723     /* Return function status */
;;;1724     return HAL_OK;
;;;1725   }
000014  bd38              POP      {r3-r5,pc}
                  |L6.22|
000016  2001              MOVS     r0,#1                 ;1631
000018  f882003c          STRB     r0,[r2,#0x3c]         ;1631
00001c  bf00              NOP                            ;1631
00001e  6808              LDR      r0,[r1,#0]            ;1634
000020  2809              CMP      r0,#9                 ;1634
000022  d916              BLS      |L6.82|
000024  6810              LDR      r0,[r2,#0]            ;1637
000026  68c0              LDR      r0,[r0,#0xc]          ;1637
000028  780c              LDRB     r4,[r1,#0]            ;1637
00002a  3c0a              SUBS     r4,r4,#0xa            ;1637
00002c  eb040544          ADD      r5,r4,r4,LSL #1       ;1637
000030  2407              MOVS     r4,#7                 ;1637
000032  40ac              LSLS     r4,r4,r5              ;1637
000034  43a0              BICS     r0,r0,r4              ;1637
000036  6814              LDR      r4,[r2,#0]            ;1637
000038  60e0              STR      r0,[r4,#0xc]          ;1637
00003a  780c              LDRB     r4,[r1,#0]            ;1640
00003c  3c0a              SUBS     r4,r4,#0xa            ;1640
00003e  eb040444          ADD      r4,r4,r4,LSL #1       ;1640
000042  6888              LDR      r0,[r1,#8]            ;1640
000044  40a0              LSLS     r0,r0,r4              ;1640
000046  6814              LDR      r4,[r2,#0]            ;1640
000048  68e4              LDR      r4,[r4,#0xc]          ;1640
00004a  4320              ORRS     r0,r0,r4              ;1640
00004c  6814              LDR      r4,[r2,#0]            ;1640
00004e  60e0              STR      r0,[r4,#0xc]          ;1640
000050  e013              B        |L6.122|
                  |L6.82|
000052  6810              LDR      r0,[r2,#0]            ;1645
000054  6900              LDR      r0,[r0,#0x10]         ;1645
000056  780c              LDRB     r4,[r1,#0]            ;1645
000058  eb040544          ADD      r5,r4,r4,LSL #1       ;1645
00005c  2407              MOVS     r4,#7                 ;1645
00005e  40ac              LSLS     r4,r4,r5              ;1645
000060  43a0              BICS     r0,r0,r4              ;1645
000062  6814              LDR      r4,[r2,#0]            ;1645
000064  6120              STR      r0,[r4,#0x10]         ;1645
000066  780c              LDRB     r4,[r1,#0]            ;1648
000068  eb040444          ADD      r4,r4,r4,LSL #1       ;1648
00006c  6888              LDR      r0,[r1,#8]            ;1648
00006e  40a0              LSLS     r0,r0,r4              ;1648
000070  6814              LDR      r4,[r2,#0]            ;1648
000072  6924              LDR      r4,[r4,#0x10]         ;1648
000074  4320              ORRS     r0,r0,r4              ;1648
000076  6814              LDR      r4,[r2,#0]            ;1648
000078  6120              STR      r0,[r4,#0x10]         ;1648
                  |L6.122|
00007a  6848              LDR      r0,[r1,#4]            ;1652
00007c  2807              CMP      r0,#7                 ;1652
00007e  d217              BCS      |L6.176|
000080  6810              LDR      r0,[r2,#0]            ;1655
000082  6b40              LDR      r0,[r0,#0x34]         ;1655
000084  790c              LDRB     r4,[r1,#4]            ;1655
000086  1e64              SUBS     r4,r4,#1              ;1655
000088  eb040584          ADD      r5,r4,r4,LSL #2       ;1655
00008c  241f              MOVS     r4,#0x1f              ;1655
00008e  40ac              LSLS     r4,r4,r5              ;1655
000090  43a0              BICS     r0,r0,r4              ;1655
000092  6814              LDR      r4,[r2,#0]            ;1655
000094  6360              STR      r0,[r4,#0x34]         ;1655
000096  8808              LDRH     r0,[r1,#0]            ;1658
000098  b280              UXTH     r0,r0                 ;1658
00009a  790c              LDRB     r4,[r1,#4]            ;1658
00009c  1e64              SUBS     r4,r4,#1              ;1658
00009e  eb040484          ADD      r4,r4,r4,LSL #2       ;1658
0000a2  40a0              LSLS     r0,r0,r4              ;1658
0000a4  6814              LDR      r4,[r2,#0]            ;1658
0000a6  6b64              LDR      r4,[r4,#0x34]         ;1658
0000a8  4320              ORRS     r0,r0,r4              ;1658
0000aa  6814              LDR      r4,[r2,#0]            ;1658
0000ac  6360              STR      r0,[r4,#0x34]         ;1658
0000ae  e031              B        |L6.276|
                  |L6.176|
0000b0  6848              LDR      r0,[r1,#4]            ;1661
0000b2  280d              CMP      r0,#0xd               ;1661
0000b4  d217              BCS      |L6.230|
0000b6  6810              LDR      r0,[r2,#0]            ;1664
0000b8  6b00              LDR      r0,[r0,#0x30]         ;1664
0000ba  790c              LDRB     r4,[r1,#4]            ;1664
0000bc  1fe4              SUBS     r4,r4,#7              ;1664
0000be  eb040584          ADD      r5,r4,r4,LSL #2       ;1664
0000c2  241f              MOVS     r4,#0x1f              ;1664
0000c4  40ac              LSLS     r4,r4,r5              ;1664
0000c6  43a0              BICS     r0,r0,r4              ;1664
0000c8  6814              LDR      r4,[r2,#0]            ;1664
0000ca  6320              STR      r0,[r4,#0x30]         ;1664
0000cc  8808              LDRH     r0,[r1,#0]            ;1667
0000ce  b280              UXTH     r0,r0                 ;1667
0000d0  790c              LDRB     r4,[r1,#4]            ;1667
0000d2  1fe4              SUBS     r4,r4,#7              ;1667
0000d4  eb040484          ADD      r4,r4,r4,LSL #2       ;1667
0000d8  40a0              LSLS     r0,r0,r4              ;1667
0000da  6814              LDR      r4,[r2,#0]            ;1667
0000dc  6b24              LDR      r4,[r4,#0x30]         ;1667
0000de  4320              ORRS     r0,r0,r4              ;1667
0000e0  6814              LDR      r4,[r2,#0]            ;1667
0000e2  6320              STR      r0,[r4,#0x30]         ;1667
0000e4  e016              B        |L6.276|
                  |L6.230|
0000e6  6810              LDR      r0,[r2,#0]            ;1673
0000e8  6ac0              LDR      r0,[r0,#0x2c]         ;1673
0000ea  790c              LDRB     r4,[r1,#4]            ;1673
0000ec  3c0d              SUBS     r4,r4,#0xd            ;1673
0000ee  eb040584          ADD      r5,r4,r4,LSL #2       ;1673
0000f2  241f              MOVS     r4,#0x1f              ;1673
0000f4  40ac              LSLS     r4,r4,r5              ;1673
0000f6  43a0              BICS     r0,r0,r4              ;1673
0000f8  6814              LDR      r4,[r2,#0]            ;1673
0000fa  62e0              STR      r0,[r4,#0x2c]         ;1673
0000fc  8808              LDRH     r0,[r1,#0]            ;1676
0000fe  b280              UXTH     r0,r0                 ;1676
000100  790c              LDRB     r4,[r1,#4]            ;1676
000102  3c0d              SUBS     r4,r4,#0xd            ;1676
000104  eb040484          ADD      r4,r4,r4,LSL #2       ;1676
000108  40a0              LSLS     r0,r0,r4              ;1676
00010a  6814              LDR      r4,[r2,#0]            ;1676
00010c  6ae4              LDR      r4,[r4,#0x2c]         ;1676
00010e  4320              ORRS     r0,r0,r4              ;1676
000110  6814              LDR      r4,[r2,#0]            ;1676
000112  62e0              STR      r0,[r4,#0x2c]         ;1676
                  |L6.276|
000114  4b19              LDR      r3,|L6.380|
000116  4c1a              LDR      r4,|L6.384|
000118  6810              LDR      r0,[r2,#0]            ;1685
00011a  42a0              CMP      r0,r4                 ;1685
00011c  d106              BNE      |L6.300|
00011e  6808              LDR      r0,[r1,#0]            ;1685
000120  2812              CMP      r0,#0x12              ;1685
000122  d103              BNE      |L6.300|
000124  6858              LDR      r0,[r3,#4]            ;1693
000126  f4400080          ORR      r0,r0,#0x400000       ;1693
00012a  6058              STR      r0,[r3,#4]            ;1693
                  |L6.300|
00012c  4c14              LDR      r4,|L6.384|
00012e  6810              LDR      r0,[r2,#0]            ;1698
000130  42a0              CMP      r0,r4                 ;1698
000132  d11c              BNE      |L6.366|
000134  6808              LDR      r0,[r1,#0]            ;1698
000136  2810              CMP      r0,#0x10              ;1698
000138  d002              BEQ      |L6.320|
00013a  6808              LDR      r0,[r1,#0]            ;1698
00013c  2811              CMP      r0,#0x11              ;1698
00013e  d116              BNE      |L6.366|
                  |L6.320|
000140  6858              LDR      r0,[r3,#4]            ;1706
000142  f4400000          ORR      r0,r0,#0x800000       ;1706
000146  6058              STR      r0,[r3,#4]            ;1706
000148  6808              LDR      r0,[r1,#0]            ;1708
00014a  2810              CMP      r0,#0x10              ;1708
00014c  d10f              BNE      |L6.366|
00014e  480d              LDR      r0,|L6.388|
000150  6800              LDR      r0,[r0,#0]            ;1712  ; SystemCoreClock
000152  4c0d              LDR      r4,|L6.392|
000154  fbb0f0f4          UDIV     r0,r0,r4              ;1712
000158  eb000080          ADD      r0,r0,r0,LSL #2       ;1712
00015c  0040              LSLS     r0,r0,#1              ;1712
00015e  9000              STR      r0,[sp,#0]            ;1712
000160  e002              B        |L6.360|
                  |L6.354|
000162  9800              LDR      r0,[sp,#0]            ;1715
000164  1e40              SUBS     r0,r0,#1              ;1715
000166  9000              STR      r0,[sp,#0]            ;1715
                  |L6.360|
000168  9800              LDR      r0,[sp,#0]            ;1713
00016a  2800              CMP      r0,#0                 ;1713
00016c  d1f9              BNE      |L6.354|
                  |L6.366|
00016e  bf00              NOP                            ;1721
000170  2000              MOVS     r0,#0                 ;1721
000172  f882003c          STRB     r0,[r2,#0x3c]         ;1721
000176  bf00              NOP                            ;1721
000178  bf00              NOP                            ;1724
00017a  e74b              B        |L6.20|
;;;1726   
                          ENDP

                  |L6.380|
                          DCD      0x40012300
                  |L6.384|
                          DCD      0x40012000
                  |L6.388|
                          DCD      SystemCoreClock
                  |L6.392|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvCpltCallback PROC
;;;1530     */
;;;1531   __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1532   {
;;;1533     /* Prevent unused argument(s) compilation warning */
;;;1534     UNUSED(hadc);
;;;1535     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1536               the HAL_ADC_ConvCpltCallback could be implemented in the user file
;;;1537      */
;;;1538   }
;;;1539   
                          ENDP


                          AREA ||i.HAL_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;1545     */
;;;1546   __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1547   {
;;;1548     /* Prevent unused argument(s) compilation warning */
;;;1549     UNUSED(hadc);
;;;1550     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1551               the HAL_ADC_ConvHalfCpltCallback could be implemented in the user file
;;;1552      */
;;;1553   }
;;;1554   
                          ENDP


                          AREA ||i.HAL_ADC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_DeInit PROC
;;;405      */
;;;406    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;407    {
000002  4604              MOV      r4,r0
;;;408      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;409      
;;;410      /* Check ADC handle */
;;;411      if(hadc == NULL)
000006  b90c              CBNZ     r4,|L9.12|
;;;412      {
;;;413        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L9.10|
;;;414      }
;;;415      
;;;416      /* Check the parameters */
;;;417      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;418      
;;;419      /* Set ADC state */
;;;420      SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
;;;421      
;;;422      /* Stop potential conversion on going, on regular and injected groups */
;;;423      /* Disable ADC peripheral */
;;;424      __HAL_ADC_DISABLE(hadc);
;;;425      
;;;426      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;427      /* correctly completed.                                                     */
;;;428      if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
;;;429      {
;;;430    #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;431      if (hadc->MspDeInitCallback == NULL)
;;;432      {
;;;433        hadc->MspDeInitCallback = HAL_ADC_MspDeInit; /* Legacy weak MspDeInit  */
;;;434      }
;;;435    
;;;436      /* DeInit the low level hardware: RCC clock, NVIC */
;;;437      hadc->MspDeInitCallback(hadc);
;;;438    #else
;;;439      /* DeInit the low level hardware: RCC clock, NVIC */
;;;440      HAL_ADC_MspDeInit(hadc);
;;;441    #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;442        
;;;443        /* Set ADC error code to none */
;;;444        ADC_CLEAR_ERRORCODE(hadc);
;;;445        
;;;446        /* Set ADC state */
;;;447        hadc->State = HAL_ADC_STATE_RESET;
;;;448      }
;;;449      
;;;450      /* Process unlocked */
;;;451      __HAL_UNLOCK(hadc);
;;;452      
;;;453      /* Return function status */
;;;454      return tmp_hal_status;
;;;455    }
00000a  bd70              POP      {r4-r6,pc}
                  |L9.12|
00000c  6c20              LDR      r0,[r4,#0x40]         ;420
00000e  f0400002          ORR      r0,r0,#2              ;420
000012  6420              STR      r0,[r4,#0x40]         ;420
000014  6820              LDR      r0,[r4,#0]            ;424
000016  6880              LDR      r0,[r0,#8]            ;424
000018  f0200001          BIC      r0,r0,#1              ;424
00001c  6821              LDR      r1,[r4,#0]            ;424
00001e  6088              STR      r0,[r1,#8]            ;424
000020  6820              LDR      r0,[r4,#0]            ;428
000022  6880              LDR      r0,[r0,#8]            ;428
000024  f0000001          AND      r0,r0,#1              ;428
000028  b928              CBNZ     r0,|L9.54|
00002a  4620              MOV      r0,r4                 ;440
00002c  f7fffffe          BL       HAL_ADC_MspDeInit
000030  2000              MOVS     r0,#0                 ;444
000032  6460              STR      r0,[r4,#0x44]         ;444
000034  6420              STR      r0,[r4,#0x40]         ;447
                  |L9.54|
000036  bf00              NOP                            ;451
000038  2000              MOVS     r0,#0                 ;451
00003a  f884003c          STRB     r0,[r4,#0x3c]         ;451
00003e  bf00              NOP                            ;451
000040  4628              MOV      r0,r5                 ;454
000042  e7e2              B        |L9.10|
;;;456    
                          ENDP


                          AREA ||i.HAL_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ErrorCallback PROC
;;;1581     */
;;;1582   __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1583   {
;;;1584     /* Prevent unused argument(s) compilation warning */
;;;1585     UNUSED(hadc);
;;;1586     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1587               the HAL_ADC_ErrorCallback could be implemented in the user file
;;;1588      */
;;;1589   }
;;;1590   
                          ENDP


                          AREA ||i.HAL_ADC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetError PROC
;;;1836     */
;;;1837   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000000  4601              MOV      r1,r0
;;;1838   {
;;;1839     return hadc->ErrorCode;
000002  6c48              LDR      r0,[r1,#0x44]
;;;1840   }
000004  4770              BX       lr
;;;1841   
                          ENDP


                          AREA ||i.HAL_ADC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetState PROC
;;;1824     */
;;;1825   uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1826   {
;;;1827     /* Return ADC state */
;;;1828     return hadc->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;1829   }
000004  4770              BX       lr
;;;1830   
                          ENDP


                          AREA ||i.HAL_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetValue PROC
;;;1518     */
;;;1519   uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1520   {       
;;;1521     /* Return the selected ADC converted value */ 
;;;1522     return hadc->Instance->DR;
000002  6808              LDR      r0,[r1,#0]
000004  6cc0              LDR      r0,[r0,#0x4c]
;;;1523   }
000006  4770              BX       lr
;;;1524   
                          ENDP


                          AREA ||i.HAL_ADC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_ADC_IRQHandler PROC
;;;1177     */
;;;1178   void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1179   {
000002  4604              MOV      r4,r0
;;;1180     uint32_t tmp1 = 0U, tmp2 = 0U;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;1181     
;;;1182     /* Check the parameters */
;;;1183     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1184     assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
;;;1185     assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
;;;1186     
;;;1187     tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
000008  6820              LDR      r0,[r4,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  f3c00540          UBFX     r5,r0,#1,#1
;;;1188     tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
000010  6820              LDR      r0,[r4,#0]
000012  6840              LDR      r0,[r0,#4]
000014  f3c01640          UBFX     r6,r0,#5,#1
;;;1189     /* Check End of conversion flag for regular channels */
;;;1190     if(tmp1 && tmp2)
000018  b395              CBZ      r5,|L14.128|
00001a  b38e              CBZ      r6,|L14.128|
;;;1191     {
;;;1192       /* Update state machine on conversion status if not in error state */
;;;1193       if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
00001c  6c20              LDR      r0,[r4,#0x40]
00001e  f0000010          AND      r0,r0,#0x10
000022  b918              CBNZ     r0,|L14.44|
;;;1194       {
;;;1195         /* Set ADC state */
;;;1196         SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
000024  6c20              LDR      r0,[r4,#0x40]
000026  f4407000          ORR      r0,r0,#0x200
00002a  6420              STR      r0,[r4,#0x40]
                  |L14.44|
;;;1197       }
;;;1198       
;;;1199       /* Determine whether any further conversion upcoming on group regular   */
;;;1200       /* by external trigger, continuous mode or scan sequence on going.      */
;;;1201       /* Note: On STM32F4, there is no independent flag of end of sequence.   */
;;;1202       /*       The test of scan sequence on going is done either with scan    */
;;;1203       /*       sequence disabled or with end of conversion flag set to        */
;;;1204       /*       of end of sequence.                                            */
;;;1205       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  f0005040          AND      r0,r0,#0x30000000
000034  b9e8              CBNZ     r0,|L14.114|
;;;1206          (hadc->Init.ContinuousConvMode == DISABLE)            &&
000036  7e20              LDRB     r0,[r4,#0x18]
000038  b9d8              CBNZ     r0,|L14.114|
;;;1207          (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
00003a  6820              LDR      r0,[r4,#0]
00003c  6ac0              LDR      r0,[r0,#0x2c]
00003e  f4000070          AND      r0,r0,#0xf00000
000042  b120              CBZ      r0,|L14.78|
;;;1208           HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
000044  6820              LDR      r0,[r4,#0]
000046  6880              LDR      r0,[r0,#8]
000048  f4006080          AND      r0,r0,#0x400
00004c  b988              CBNZ     r0,|L14.114|
                  |L14.78|
;;;1209       {
;;;1210         /* Disable ADC end of single conversion interrupt on group regular */
;;;1211         /* Note: Overrun interrupt was enabled with EOC interrupt in          */
;;;1212         /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
;;;1213         /* by overrun IRQ process below.                                      */
;;;1214         __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
00004e  6820              LDR      r0,[r4,#0]
000050  6840              LDR      r0,[r0,#4]
000052  f0200020          BIC      r0,r0,#0x20
000056  6821              LDR      r1,[r4,#0]
000058  6048              STR      r0,[r1,#4]
;;;1215         
;;;1216         /* Set ADC state */
;;;1217         CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
00005a  6c20              LDR      r0,[r4,#0x40]
00005c  f4207080          BIC      r0,r0,#0x100
000060  6420              STR      r0,[r4,#0x40]
;;;1218         
;;;1219         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
000062  6c20              LDR      r0,[r4,#0x40]
000064  f4005080          AND      r0,r0,#0x1000
000068  b918              CBNZ     r0,|L14.114|
;;;1220         {
;;;1221           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
00006a  6c20              LDR      r0,[r4,#0x40]
00006c  f0400001          ORR      r0,r0,#1
000070  6420              STR      r0,[r4,#0x40]
                  |L14.114|
;;;1222         }
;;;1223       }
;;;1224       
;;;1225       /* Conversion complete callback */
;;;1226   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1227       hadc->ConvCpltCallback(hadc);
;;;1228   #else
;;;1229       HAL_ADC_ConvCpltCallback(hadc);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;1230   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1231       
;;;1232       /* Clear regular group conversion flag */
;;;1233       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
000078  f06f0012          MVN      r0,#0x12
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L14.128|
;;;1234     }
;;;1235     
;;;1236     tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f3c00580          UBFX     r5,r0,#2,#1
;;;1237     tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
000088  6820              LDR      r0,[r4,#0]
00008a  6840              LDR      r0,[r0,#4]
00008c  f3c016c0          UBFX     r6,r0,#7,#1
;;;1238     /* Check End of conversion flag for injected channels */
;;;1239     if(tmp1 && tmp2)
000090  b3e5              CBZ      r5,|L14.268|
000092  b3de              CBZ      r6,|L14.268|
;;;1240     {
;;;1241       /* Update state machine on conversion status if not in error state */
;;;1242       if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
000094  6c20              LDR      r0,[r4,#0x40]
000096  f0000010          AND      r0,r0,#0x10
00009a  b918              CBNZ     r0,|L14.164|
;;;1243       {
;;;1244         /* Set ADC state */
;;;1245         SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
00009c  6c20              LDR      r0,[r4,#0x40]
00009e  f4405000          ORR      r0,r0,#0x2000
0000a2  6420              STR      r0,[r4,#0x40]
                  |L14.164|
;;;1246       }
;;;1247   
;;;1248       /* Determine whether any further conversion upcoming on group injected  */
;;;1249       /* by external trigger, scan sequence on going or by automatic injected */
;;;1250       /* conversion from group regular (same conditions as group regular      */
;;;1251       /* interruption disabling above).                                       */
;;;1252       if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
0000a4  6820              LDR      r0,[r4,#0]
0000a6  6880              LDR      r0,[r0,#8]
0000a8  f4001040          AND      r0,r0,#0x300000
0000ac  bb38              CBNZ     r0,|L14.254|
;;;1253          (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
0000ae  6820              LDR      r0,[r4,#0]
0000b0  6b80              LDR      r0,[r0,#0x38]
0000b2  f4001040          AND      r0,r0,#0x300000
0000b6  b120              CBZ      r0,|L14.194|
;;;1254           HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6880              LDR      r0,[r0,#8]
0000bc  f4006080          AND      r0,r0,#0x400
0000c0  b9e8              CBNZ     r0,|L14.254|
                  |L14.194|
;;;1255          (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
0000c2  6820              LDR      r0,[r4,#0]
0000c4  6840              LDR      r0,[r0,#4]
0000c6  f4006080          AND      r0,r0,#0x400
0000ca  b9c0              CBNZ     r0,|L14.254|
;;;1256           (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
0000cc  6820              LDR      r0,[r4,#0]
0000ce  6880              LDR      r0,[r0,#8]
0000d0  f0005040          AND      r0,r0,#0x30000000
0000d4  b998              CBNZ     r0,|L14.254|
;;;1257           (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
0000d6  7e20              LDRB     r0,[r4,#0x18]
0000d8  b988              CBNZ     r0,|L14.254|
;;;1258       {
;;;1259         /* Disable ADC end of single conversion interrupt on group injected */
;;;1260         __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
0000da  6820              LDR      r0,[r4,#0]
0000dc  6840              LDR      r0,[r0,#4]
0000de  f0200080          BIC      r0,r0,#0x80
0000e2  6821              LDR      r1,[r4,#0]
0000e4  6048              STR      r0,[r1,#4]
;;;1261         
;;;1262         /* Set ADC state */
;;;1263         CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
0000e6  6c20              LDR      r0,[r4,#0x40]
0000e8  f4205080          BIC      r0,r0,#0x1000
0000ec  6420              STR      r0,[r4,#0x40]
;;;1264   
;;;1265         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
0000ee  6c20              LDR      r0,[r4,#0x40]
0000f0  f4007080          AND      r0,r0,#0x100
0000f4  b918              CBNZ     r0,|L14.254|
;;;1266         { 
;;;1267           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
0000f6  6c20              LDR      r0,[r4,#0x40]
0000f8  f0400001          ORR      r0,r0,#1
0000fc  6420              STR      r0,[r4,#0x40]
                  |L14.254|
;;;1268         }
;;;1269       }
;;;1270   
;;;1271       /* Conversion complete callback */ 
;;;1272       /* Conversion complete callback */ 
;;;1273   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1274         hadc->InjectedConvCpltCallback(hadc);
;;;1275   #else
;;;1276         HAL_ADCEx_InjectedConvCpltCallback(hadc);
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       HAL_ADCEx_InjectedConvCpltCallback
;;;1277   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1278       
;;;1279       /* Clear injected group conversion flag */
;;;1280       __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
000104  f06f000c          MVN      r0,#0xc
000108  6821              LDR      r1,[r4,#0]
00010a  6008              STR      r0,[r1,#0]
                  |L14.268|
;;;1281     }
;;;1282     
;;;1283     tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
00010c  6820              LDR      r0,[r4,#0]
00010e  6800              LDR      r0,[r0,#0]
000110  f0000501          AND      r5,r0,#1
;;;1284     tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
000114  6820              LDR      r0,[r4,#0]
000116  6840              LDR      r0,[r0,#4]
000118  f3c01680          UBFX     r6,r0,#6,#1
;;;1285     /* Check Analog watchdog flag */
;;;1286     if(tmp1 && tmp2)
00011c  b185              CBZ      r5,|L14.320|
00011e  b17e              CBZ      r6,|L14.320|
;;;1287     {
;;;1288       if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
000120  6820              LDR      r0,[r4,#0]
000122  6800              LDR      r0,[r0,#0]
000124  f0000001          AND      r0,r0,#1
000128  b150              CBZ      r0,|L14.320|
;;;1289       {
;;;1290         /* Set ADC state */
;;;1291         SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
00012a  6c20              LDR      r0,[r4,#0x40]
00012c  f4403080          ORR      r0,r0,#0x10000
000130  6420              STR      r0,[r4,#0x40]
;;;1292         
;;;1293         /* Level out of window callback */
;;;1294   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1295         hadc->LevelOutOfWindowCallback(hadc);
;;;1296   #else
;;;1297         HAL_ADC_LevelOutOfWindowCallback(hadc);
000132  4620              MOV      r0,r4
000134  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
;;;1298   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1299         
;;;1300         /* Clear the ADC analog watchdog flag */
;;;1301         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
000138  f06f0001          MVN      r0,#1
00013c  6821              LDR      r1,[r4,#0]
00013e  6008              STR      r0,[r1,#0]
                  |L14.320|
;;;1302       }
;;;1303     }
;;;1304     
;;;1305     tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
000140  6820              LDR      r0,[r4,#0]
000142  6800              LDR      r0,[r0,#0]
000144  f3c01540          UBFX     r5,r0,#5,#1
;;;1306     tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
000148  6820              LDR      r0,[r4,#0]
00014a  6840              LDR      r0,[r0,#4]
00014c  f3c06680          UBFX     r6,r0,#26,#1
;;;1307     /* Check Overrun flag */
;;;1308     if(tmp1 && tmp2)
000150  b17d              CBZ      r5,|L14.370|
000152  b176              CBZ      r6,|L14.370|
;;;1309     {
;;;1310       /* Note: On STM32F4, ADC overrun can be set through other parameters    */
;;;1311       /*       refer to description of parameter "EOCSelection" for more      */
;;;1312       /*       details.                                                       */
;;;1313       
;;;1314       /* Set ADC error code to overrun */
;;;1315       SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
000154  6c60              LDR      r0,[r4,#0x44]
000156  f0400002          ORR      r0,r0,#2
00015a  6460              STR      r0,[r4,#0x44]
;;;1316       
;;;1317       /* Clear ADC overrun flag */
;;;1318       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
00015c  f06f0020          MVN      r0,#0x20
000160  6821              LDR      r1,[r4,#0]
000162  6008              STR      r0,[r1,#0]
;;;1319       
;;;1320       /* Error callback */ 
;;;1321   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1322         hadc->ErrorCallback(hadc);
;;;1323   #else
;;;1324         HAL_ADC_ErrorCallback(hadc);
000164  4620              MOV      r0,r4
000166  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;1325   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1326       
;;;1327       /* Clear the Overrun flag */
;;;1328       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
00016a  f06f0020          MVN      r0,#0x20
00016e  6821              LDR      r1,[r4,#0]
000170  6008              STR      r0,[r1,#0]
                  |L14.370|
;;;1329     }
;;;1330   }
000172  bd70              POP      {r4-r6,pc}
;;;1331   
                          ENDP


                          AREA ||i.HAL_ADC_Init||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Init PROC
;;;311      */
;;;312    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;313    {
000002  4604              MOV      r4,r0
;;;314      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;315      
;;;316      /* Check ADC handle */
;;;317      if(hadc == NULL)
000006  b90c              CBNZ     r4,|L15.12|
;;;318      {
;;;319        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L15.10|
;;;320      }
;;;321      
;;;322      /* Check the parameters */
;;;323      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;324      assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
;;;325      assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
;;;326      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ScanConvMode));
;;;327      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;328      assert_param(IS_ADC_EXT_TRIG(hadc->Init.ExternalTrigConv));
;;;329      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
;;;330      assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
;;;331      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
;;;332      assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
;;;333      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;334      
;;;335      if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
;;;336      {
;;;337        assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;338      }
;;;339      
;;;340      if(hadc->State == HAL_ADC_STATE_RESET)
;;;341      {
;;;342    #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;343        /* Init the ADC Callback settings */
;;;344        hadc->ConvCpltCallback              = HAL_ADC_ConvCpltCallback;                 /* Legacy weak callback */
;;;345        hadc->ConvHalfCpltCallback          = HAL_ADC_ConvHalfCpltCallback;             /* Legacy weak callback */
;;;346        hadc->LevelOutOfWindowCallback      = HAL_ADC_LevelOutOfWindowCallback;         /* Legacy weak callback */
;;;347        hadc->ErrorCallback                 = HAL_ADC_ErrorCallback;                    /* Legacy weak callback */
;;;348        hadc->InjectedConvCpltCallback      = HAL_ADCEx_InjectedConvCpltCallback;       /* Legacy weak callback */
;;;349        if (hadc->MspInitCallback == NULL)
;;;350        {
;;;351          hadc->MspInitCallback = HAL_ADC_MspInit; /* Legacy weak MspInit  */
;;;352        }
;;;353    
;;;354        /* Init the low level hardware */
;;;355        hadc->MspInitCallback(hadc);
;;;356    #else
;;;357        /* Init the low level hardware */
;;;358        HAL_ADC_MspInit(hadc);
;;;359    #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;360    
;;;361        /* Initialize ADC error code */
;;;362        ADC_CLEAR_ERRORCODE(hadc);
;;;363        
;;;364        /* Allocate lock resource and initialize it */
;;;365        hadc->Lock = HAL_UNLOCKED;
;;;366      }
;;;367      
;;;368      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;369      /* correctly completed.                                                     */
;;;370      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
;;;371      {
;;;372        /* Set ADC state */
;;;373        ADC_STATE_CLR_SET(hadc->State,
;;;374                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;375                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;376        
;;;377        /* Set ADC parameters */
;;;378        ADC_Init(hadc);
;;;379        
;;;380        /* Set ADC error code to none */
;;;381        ADC_CLEAR_ERRORCODE(hadc);
;;;382        
;;;383        /* Set the ADC state */
;;;384        ADC_STATE_CLR_SET(hadc->State,
;;;385                          HAL_ADC_STATE_BUSY_INTERNAL,
;;;386                          HAL_ADC_STATE_READY);
;;;387      }
;;;388      else
;;;389      {
;;;390        tmp_hal_status = HAL_ERROR;
;;;391      }
;;;392      
;;;393      /* Release Lock */
;;;394      __HAL_UNLOCK(hadc);
;;;395    
;;;396      /* Return function status */
;;;397      return tmp_hal_status;
;;;398    }
00000a  bd70              POP      {r4-r6,pc}
                  |L15.12|
00000c  4915              LDR      r1,|L15.100|
00000e  6aa0              LDR      r0,[r4,#0x28]         ;335
000010  4288              CMP      r0,r1                 ;335
000012  d000              BEQ      |L15.22|
000014  bf00              NOP                            ;337
                  |L15.22|
000016  6c20              LDR      r0,[r4,#0x40]         ;340
000018  b930              CBNZ     r0,|L15.40|
00001a  4620              MOV      r0,r4                 ;358
00001c  f7fffffe          BL       HAL_ADC_MspInit
000020  2000              MOVS     r0,#0                 ;362
000022  6460              STR      r0,[r4,#0x44]         ;362
000024  f884003c          STRB     r0,[r4,#0x3c]         ;365
                  |L15.40|
000028  6c20              LDR      r0,[r4,#0x40]         ;370
00002a  f0000010          AND      r0,r0,#0x10           ;370
00002e  b988              CBNZ     r0,|L15.84|
000030  6c20              LDR      r0,[r4,#0x40]         ;373
000032  f4205088          BIC      r0,r0,#0x1100         ;373
000036  f0400002          ORR      r0,r0,#2              ;373
00003a  6420              STR      r0,[r4,#0x40]         ;373
00003c  4620              MOV      r0,r4                 ;378
00003e  f7fffffe          BL       ADC_Init
000042  2000              MOVS     r0,#0                 ;381
000044  6460              STR      r0,[r4,#0x44]         ;381
000046  6c20              LDR      r0,[r4,#0x40]         ;384
000048  f0200002          BIC      r0,r0,#2              ;384
00004c  f0400001          ORR      r0,r0,#1              ;384
000050  6420              STR      r0,[r4,#0x40]         ;384
000052  e000              B        |L15.86|
                  |L15.84|
000054  2501              MOVS     r5,#1                 ;390
                  |L15.86|
000056  bf00              NOP                            ;394
000058  2000              MOVS     r0,#0                 ;394
00005a  f884003c          STRB     r0,[r4,#0x3c]         ;394
00005e  bf00              NOP                            ;394
000060  4628              MOV      r0,r5                 ;397
000062  e7d2              B        |L15.10|
;;;399    
                          ENDP

                  |L15.100|
                          DCD      0x0f000001

                          AREA ||i.HAL_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;1560     */
;;;1561   __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1562   {
;;;1563     /* Prevent unused argument(s) compilation warning */
;;;1564     UNUSED(hadc);
;;;1565     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1566               the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
;;;1567      */
;;;1568   }
;;;1569   
                          ENDP


                          AREA ||i.HAL_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspDeInit PROC
;;;679      */
;;;680    __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;681    {
;;;682      /* Prevent unused argument(s) compilation warning */
;;;683      UNUSED(hadc);
;;;684      /* NOTE : This function Should not be modified, when the callback is needed,
;;;685                the HAL_ADC_MspDeInit could be implemented in the user file
;;;686       */ 
;;;687    }
;;;688    
                          ENDP


                          AREA ||i.HAL_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspInit PROC
;;;664      */
;;;665    __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;666    {
;;;667      /* Prevent unused argument(s) compilation warning */
;;;668      UNUSED(hadc);
;;;669      /* NOTE : This function Should not be modified, when the callback is needed,
;;;670                the HAL_ADC_MspInit could be implemented in the user file
;;;671       */ 
;;;672    }
;;;673    
                          ENDP


                          AREA ||i.HAL_ADC_PollForConversion||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForConversion PROC
;;;876      */
;;;877    HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;878    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;879      uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;880     
;;;881      /* Verification that ADC configuration is compliant with polling for      */
;;;882      /* each conversion:                                                       */
;;;883      /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
;;;884      /* several ranks and polling for end of each conversion.                  */
;;;885      /* For code simplicity sake, this particular case is generalized to       */
;;;886      /* ADC configured in DMA mode and polling for end of each conversion.     */
;;;887      if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
000008  6820              LDR      r0,[r4,#0]
00000a  6880              LDR      r0,[r0,#8]
00000c  f4006080          AND      r0,r0,#0x400
000010  f5b06f80          CMP      r0,#0x400
000014  d111              BNE      |L19.58|
;;;888          HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
000016  6820              LDR      r0,[r4,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f4007080          AND      r0,r0,#0x100
00001e  f5b07f80          CMP      r0,#0x100
000022  d10a              BNE      |L19.58|
;;;889      {
;;;890        /* Update ADC state machine to error */
;;;891        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
000024  6c20              LDR      r0,[r4,#0x40]
000026  f0400020          ORR      r0,r0,#0x20
00002a  6420              STR      r0,[r4,#0x40]
;;;892        
;;;893        /* Process unlocked */
;;;894        __HAL_UNLOCK(hadc);
00002c  bf00              NOP      
00002e  2000              MOVS     r0,#0
000030  f884003c          STRB     r0,[r4,#0x3c]
000034  bf00              NOP      
;;;895        
;;;896        return HAL_ERROR;
000036  2001              MOVS     r0,#1
                  |L19.56|
;;;897      }
;;;898    
;;;899      /* Get tick */ 
;;;900      tickstart = HAL_GetTick();
;;;901    
;;;902      /* Check End of conversion flag */
;;;903      while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
;;;904      {
;;;905        /* Check if timeout is disabled (set to infinite wait) */
;;;906        if(Timeout != HAL_MAX_DELAY)
;;;907        {
;;;908          if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
;;;909          {
;;;910            /* Update ADC state machine to timeout */
;;;911            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;912            
;;;913            /* Process unlocked */
;;;914            __HAL_UNLOCK(hadc);
;;;915            
;;;916            return HAL_TIMEOUT;
;;;917          }
;;;918        }
;;;919      }
;;;920      
;;;921      /* Clear regular group conversion flag */
;;;922      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
;;;923      
;;;924      /* Update ADC state machine */
;;;925      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;926      
;;;927      /* Determine whether any further conversion upcoming on group regular       */
;;;928      /* by external trigger, continuous mode or scan sequence on going.          */
;;;929      /* Note: On STM32F4, there is no independent flag of end of sequence.       */
;;;930      /*       The test of scan sequence on going is done either with scan        */
;;;931      /*       sequence disabled or with end of conversion flag set to            */
;;;932      /*       of end of sequence.                                                */
;;;933      if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
;;;934         (hadc->Init.ContinuousConvMode == DISABLE)            &&
;;;935         (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) ||
;;;936          HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
;;;937      {
;;;938        /* Set ADC state */
;;;939        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
;;;940        
;;;941        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;942        { 
;;;943          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;944        }
;;;945      }
;;;946      
;;;947      /* Return ADC state */
;;;948      return HAL_OK;
;;;949    }
000038  bd70              POP      {r4-r6,pc}
                  |L19.58|
00003a  f7fffffe          BL       HAL_GetTick
00003e  4606              MOV      r6,r0                 ;900
000040  e012              B        |L19.104|
                  |L19.66|
000042  1c68              ADDS     r0,r5,#1              ;906
000044  b180              CBZ      r0,|L19.104|
000046  b125              CBZ      r5,|L19.82|
000048  f7fffffe          BL       HAL_GetTick
00004c  1b80              SUBS     r0,r0,r6              ;908
00004e  42a8              CMP      r0,r5                 ;908
000050  d90a              BLS      |L19.104|
                  |L19.82|
000052  6c20              LDR      r0,[r4,#0x40]         ;911
000054  f0400004          ORR      r0,r0,#4              ;911
000058  6420              STR      r0,[r4,#0x40]         ;911
00005a  bf00              NOP                            ;914
00005c  2000              MOVS     r0,#0                 ;914
00005e  f884003c          STRB     r0,[r4,#0x3c]         ;914
000062  bf00              NOP                            ;914
000064  2003              MOVS     r0,#3                 ;916
000066  e7e7              B        |L19.56|
                  |L19.104|
000068  6820              LDR      r0,[r4,#0]            ;903
00006a  6800              LDR      r0,[r0,#0]            ;903
00006c  f0000002          AND      r0,r0,#2              ;903
000070  2802              CMP      r0,#2                 ;903
000072  d1e6              BNE      |L19.66|
000074  f06f0012          MVN      r0,#0x12              ;922
000078  6821              LDR      r1,[r4,#0]            ;922
00007a  6008              STR      r0,[r1,#0]            ;922
00007c  6c20              LDR      r0,[r4,#0x40]         ;925
00007e  f4407000          ORR      r0,r0,#0x200          ;925
000082  6420              STR      r0,[r4,#0x40]         ;925
000084  6820              LDR      r0,[r4,#0]            ;933
000086  6880              LDR      r0,[r0,#8]            ;933
000088  f0005040          AND      r0,r0,#0x30000000     ;933
00008c  b9b8              CBNZ     r0,|L19.190|
00008e  7e20              LDRB     r0,[r4,#0x18]         ;934
000090  b9a8              CBNZ     r0,|L19.190|
000092  6820              LDR      r0,[r4,#0]            ;935
000094  6ac0              LDR      r0,[r0,#0x2c]         ;935
000096  f4000070          AND      r0,r0,#0xf00000       ;935
00009a  b120              CBZ      r0,|L19.166|
00009c  6820              LDR      r0,[r4,#0]            ;936
00009e  6880              LDR      r0,[r0,#8]            ;936
0000a0  f4006080          AND      r0,r0,#0x400          ;936
0000a4  b958              CBNZ     r0,|L19.190|
                  |L19.166|
0000a6  6c20              LDR      r0,[r4,#0x40]         ;939
0000a8  f4207080          BIC      r0,r0,#0x100          ;939
0000ac  6420              STR      r0,[r4,#0x40]         ;939
0000ae  6c20              LDR      r0,[r4,#0x40]         ;941
0000b0  f4005080          AND      r0,r0,#0x1000         ;941
0000b4  b918              CBNZ     r0,|L19.190|
0000b6  6c20              LDR      r0,[r4,#0x40]         ;943
0000b8  f0400001          ORR      r0,r0,#1              ;943
0000bc  6420              STR      r0,[r4,#0x40]         ;943
                  |L19.190|
0000be  2000              MOVS     r0,#0                 ;948
0000c0  e7ba              B        |L19.56|
;;;950    
                          ENDP


                          AREA ||i.HAL_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForEvent PROC
;;;961      */
;;;962    HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;963    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;964      uint32_t tickstart = 0U;
00000a  2700              MOVS     r7,#0
;;;965      
;;;966      /* Check the parameters */
;;;967      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;968      assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;969    
;;;970      /* Get tick */
;;;971      tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4607              MOV      r7,r0
;;;972    
;;;973      /* Check selected event flag */
;;;974      while(!(__HAL_ADC_GET_FLAG(hadc,EventType)))
000012  e013              B        |L20.60|
                  |L20.20|
;;;975      {
;;;976        /* Check for the Timeout */
;;;977        if(Timeout != HAL_MAX_DELAY)
000014  1c70              ADDS     r0,r6,#1
000016  b188              CBZ      r0,|L20.60|
;;;978        {
;;;979          if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
000018  b126              CBZ      r6,|L20.36|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1bc0              SUBS     r0,r0,r7
000020  42b0              CMP      r0,r6
000022  d90b              BLS      |L20.60|
                  |L20.36|
;;;980          {
;;;981            /* Update ADC state machine to timeout */
;;;982            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
000024  6c20              LDR      r0,[r4,#0x40]
000026  f0400004          ORR      r0,r0,#4
00002a  6420              STR      r0,[r4,#0x40]
;;;983            
;;;984            /* Process unlocked */
;;;985            __HAL_UNLOCK(hadc);
00002c  bf00              NOP      
00002e  2000              MOVS     r0,#0
000030  f884003c          STRB     r0,[r4,#0x3c]
000034  bf00              NOP      
;;;986            
;;;987            return HAL_TIMEOUT;
000036  2003              MOVS     r0,#3
                  |L20.56|
;;;988          }
;;;989        }
;;;990      }
;;;991      
;;;992      /* Analog watchdog (level out of window) event */
;;;993      if(EventType == ADC_AWD_EVENT)
;;;994      {
;;;995        /* Set ADC state */
;;;996        SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
;;;997          
;;;998        /* Clear ADC analog watchdog flag */
;;;999        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
;;;1000     }
;;;1001     /* Overrun event */
;;;1002     else
;;;1003     {
;;;1004       /* Set ADC state */
;;;1005       SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
;;;1006       /* Set ADC error code to overrun */
;;;1007       SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
;;;1008       
;;;1009       /* Clear ADC overrun flag */
;;;1010       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
;;;1011     }
;;;1012     
;;;1013     /* Return ADC state */
;;;1014     return HAL_OK;
;;;1015   }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L20.60|
00003c  6820              LDR      r0,[r4,#0]            ;974
00003e  6800              LDR      r0,[r0,#0]            ;974
000040  4028              ANDS     r0,r0,r5              ;974
000042  42a8              CMP      r0,r5                 ;974
000044  d1e6              BNE      |L20.20|
000046  2d01              CMP      r5,#1                 ;993
000048  d107              BNE      |L20.90|
00004a  6c20              LDR      r0,[r4,#0x40]         ;996
00004c  f4403080          ORR      r0,r0,#0x10000        ;996
000050  6420              STR      r0,[r4,#0x40]         ;996
000052  1ee8              SUBS     r0,r5,#3              ;999
000054  6821              LDR      r1,[r4,#0]            ;999
000056  6008              STR      r0,[r1,#0]            ;999
000058  e00b              B        |L20.114|
                  |L20.90|
00005a  6c20              LDR      r0,[r4,#0x40]         ;1005
00005c  f4406080          ORR      r0,r0,#0x400          ;1005
000060  6420              STR      r0,[r4,#0x40]         ;1005
000062  6c60              LDR      r0,[r4,#0x44]         ;1007
000064  f0400002          ORR      r0,r0,#2              ;1007
000068  6460              STR      r0,[r4,#0x44]         ;1007
00006a  f06f0020          MVN      r0,#0x20              ;1010
00006e  6821              LDR      r1,[r4,#0]            ;1010
000070  6008              STR      r0,[r1,#0]            ;1010
                  |L20.114|
000072  2000              MOVS     r0,#0                 ;1014
000074  e7e0              B        |L20.56|
;;;1016   
                          ENDP


                          AREA ||i.HAL_ADC_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start PROC
;;;718      */
;;;719    HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
000000  b508              PUSH     {r3,lr}
;;;720    {
000002  4601              MOV      r1,r0
;;;721      __IO uint32_t counter = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;722      ADC_Common_TypeDef *tmpADC_Common;
;;;723      
;;;724      /* Check the parameters */
;;;725      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;726      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;727      
;;;728      /* Process locked */
;;;729      __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f891003c          LDRB     r0,[r1,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L21.22|
000012  2002              MOVS     r0,#2
                  |L21.20|
;;;730      
;;;731      /* Enable the ADC peripheral */
;;;732      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;733      Tstab time the ADC's stabilization */
;;;734      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;735      {  
;;;736        /* Enable the Peripheral */
;;;737        __HAL_ADC_ENABLE(hadc);
;;;738        
;;;739        /* Delay for ADC stabilization time */
;;;740        /* Compute number of CPU cycles to wait for */
;;;741        counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
;;;742        while(counter != 0U)
;;;743        {
;;;744          counter--;
;;;745        }
;;;746      }
;;;747      
;;;748      /* Start conversion if ADC is effectively enabled */
;;;749      if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
;;;750      {
;;;751        /* Set ADC state                                                          */
;;;752        /* - Clear state bitfield related to regular group conversion results     */
;;;753        /* - Set state bitfield related to regular group operation                */
;;;754        ADC_STATE_CLR_SET(hadc->State,
;;;755                          HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
;;;756                          HAL_ADC_STATE_REG_BUSY);
;;;757        
;;;758        /* If conversions on group regular are also triggering group injected,    */
;;;759        /* update ADC state.                                                      */
;;;760        if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;761        {
;;;762          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;763        }
;;;764        
;;;765        /* State machine update: Check if an injected conversion is ongoing */
;;;766        if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;767        {
;;;768          /* Reset ADC error code fields related to conversions on group regular */
;;;769          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;770        }
;;;771        else
;;;772        {
;;;773          /* Reset ADC all error code fields */
;;;774          ADC_CLEAR_ERRORCODE(hadc);
;;;775        } 
;;;776    
;;;777        /* Process unlocked */
;;;778        /* Unlock before starting ADC conversions: in case of potential           */
;;;779        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;780        __HAL_UNLOCK(hadc);
;;;781    
;;;782        /* Pointer to the common control register to which is belonging hadc    */
;;;783        /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;784        /* control register)                                                    */
;;;785        tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;786    
;;;787        /* Clear regular group conversion flag and overrun flag */
;;;788        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;789        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
;;;790        
;;;791        /* Check if Multimode enabled */
;;;792        if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
;;;793        {
;;;794    #if defined(ADC2) && defined(ADC3)
;;;795          if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
;;;796                                      || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
;;;797          {
;;;798    #endif /* ADC2 || ADC3 */
;;;799            /* if no external trigger present enable software conversion of regular channels */
;;;800            if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;801            {
;;;802              /* Enable the selected ADC software conversion for regular group */
;;;803              hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;804            }
;;;805    #if defined(ADC2) && defined(ADC3)
;;;806          }
;;;807    #endif /* ADC2 || ADC3 */
;;;808        }
;;;809        else
;;;810        {
;;;811          /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;812          if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
;;;813          {
;;;814            /* Enable the selected ADC software conversion for regular group */
;;;815              hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;816          }
;;;817        }
;;;818      }
;;;819      
;;;820      /* Return function status */
;;;821      return HAL_OK;
;;;822    }
000014  bd08              POP      {r3,pc}
                  |L21.22|
000016  2001              MOVS     r0,#1                 ;729
000018  f881003c          STRB     r0,[r1,#0x3c]         ;729
00001c  bf00              NOP                            ;729
00001e  6808              LDR      r0,[r1,#0]            ;734
000020  6880              LDR      r0,[r0,#8]            ;734
000022  f0000001          AND      r0,r0,#1              ;734
000026  b9a0              CBNZ     r0,|L21.82|
000028  6808              LDR      r0,[r1,#0]            ;737
00002a  6880              LDR      r0,[r0,#8]            ;737
00002c  f0400001          ORR      r0,r0,#1              ;737
000030  680b              LDR      r3,[r1,#0]            ;737
000032  6098              STR      r0,[r3,#8]            ;737
000034  482f              LDR      r0,|L21.244|
000036  6800              LDR      r0,[r0,#0]            ;741  ; SystemCoreClock
000038  4b2f              LDR      r3,|L21.248|
00003a  fbb0f0f3          UDIV     r0,r0,r3              ;741
00003e  eb000040          ADD      r0,r0,r0,LSL #1       ;741
000042  9000              STR      r0,[sp,#0]            ;741
000044  e002              B        |L21.76|
                  |L21.70|
000046  9800              LDR      r0,[sp,#0]            ;744
000048  1e40              SUBS     r0,r0,#1              ;744
00004a  9000              STR      r0,[sp,#0]            ;744
                  |L21.76|
00004c  9800              LDR      r0,[sp,#0]            ;742
00004e  2800              CMP      r0,#0                 ;742
000050  d1f9              BNE      |L21.70|
                  |L21.82|
000052  6808              LDR      r0,[r1,#0]            ;749
000054  6880              LDR      r0,[r0,#8]            ;749
000056  f0000001          AND      r0,r0,#1              ;749
00005a  2800              CMP      r0,#0                 ;749
00005c  d047              BEQ      |L21.238|
00005e  6c08              LDR      r0,[r1,#0x40]         ;754
000060  f2406301          MOV      r3,#0x601             ;754
000064  4398              BICS     r0,r0,r3              ;754
000066  f4407080          ORR      r0,r0,#0x100          ;754
00006a  6408              STR      r0,[r1,#0x40]         ;754
00006c  6808              LDR      r0,[r1,#0]            ;760
00006e  6840              LDR      r0,[r0,#4]            ;760
000070  f4006080          AND      r0,r0,#0x400          ;760
000074  b128              CBZ      r0,|L21.130|
000076  6c08              LDR      r0,[r1,#0x40]         ;762
000078  f4205000          BIC      r0,r0,#0x2000         ;762
00007c  f4405080          ORR      r0,r0,#0x1000         ;762
000080  6408              STR      r0,[r1,#0x40]         ;762
                  |L21.130|
000082  6c08              LDR      r0,[r1,#0x40]         ;766
000084  f4005080          AND      r0,r0,#0x1000         ;766
000088  f5b05f80          CMP      r0,#0x1000            ;766
00008c  d104              BNE      |L21.152|
00008e  6c48              LDR      r0,[r1,#0x44]         ;769
000090  f0200006          BIC      r0,r0,#6              ;769
000094  6448              STR      r0,[r1,#0x44]         ;769
000096  e001              B        |L21.156|
                  |L21.152|
000098  2000              MOVS     r0,#0                 ;774
00009a  6448              STR      r0,[r1,#0x44]         ;774
                  |L21.156|
00009c  bf00              NOP                            ;780
00009e  2000              MOVS     r0,#0                 ;780
0000a0  f881003c          STRB     r0,[r1,#0x3c]         ;780
0000a4  bf00              NOP                            ;780
0000a6  4a15              LDR      r2,|L21.252|
0000a8  f06f0022          MVN      r0,#0x22              ;789
0000ac  680b              LDR      r3,[r1,#0]            ;789
0000ae  6018              STR      r0,[r3,#0]            ;789
0000b0  6850              LDR      r0,[r2,#4]            ;792
0000b2  f000001f          AND      r0,r0,#0x1f           ;792
0000b6  b958              CBNZ     r0,|L21.208|
0000b8  6808              LDR      r0,[r1,#0]            ;800
0000ba  6880              LDR      r0,[r0,#8]            ;800
0000bc  f0005040          AND      r0,r0,#0x30000000     ;800
0000c0  b9a8              CBNZ     r0,|L21.238|
0000c2  6808              LDR      r0,[r1,#0]            ;803
0000c4  6880              LDR      r0,[r0,#8]            ;803
0000c6  f0404080          ORR      r0,r0,#0x40000000     ;803
0000ca  680b              LDR      r3,[r1,#0]            ;803
0000cc  6098              STR      r0,[r3,#8]            ;803
0000ce  e00e              B        |L21.238|
                  |L21.208|
0000d0  4b0b              LDR      r3,|L21.256|
0000d2  6808              LDR      r0,[r1,#0]            ;812
0000d4  4298              CMP      r0,r3                 ;812
0000d6  d10a              BNE      |L21.238|
0000d8  6808              LDR      r0,[r1,#0]            ;812
0000da  6880              LDR      r0,[r0,#8]            ;812
0000dc  f0005040          AND      r0,r0,#0x30000000     ;812
0000e0  b928              CBNZ     r0,|L21.238|
0000e2  6808              LDR      r0,[r1,#0]            ;815
0000e4  6880              LDR      r0,[r0,#8]            ;815
0000e6  f0404080          ORR      r0,r0,#0x40000000     ;815
0000ea  680b              LDR      r3,[r1,#0]            ;815
0000ec  6098              STR      r0,[r3,#8]            ;815
                  |L21.238|
0000ee  2000              MOVS     r0,#0                 ;821
0000f0  e790              B        |L21.20|
;;;823    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L21.244|
                          DCD      SystemCoreClock
                  |L21.248|
                          DCD      0x000f4240
                  |L21.252|
                          DCD      0x40012300
                  |L21.256|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_DMA PROC
;;;1339     */
;;;1340   HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1341   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1342     __IO uint32_t counter = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1343     ADC_Common_TypeDef *tmpADC_Common;
;;;1344     
;;;1345     /* Check the parameters */
;;;1346     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1347     assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;1348     
;;;1349     /* Process locked */
;;;1350     __HAL_LOCK(hadc);
00000c  bf00              NOP      
00000e  f894003c          LDRB     r0,[r4,#0x3c]
000012  2801              CMP      r0,#1
000014  d101              BNE      |L22.26|
000016  2002              MOVS     r0,#2
                  |L22.24|
;;;1351     
;;;1352     /* Enable the ADC peripheral */
;;;1353     /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;1354     Tstab time the ADC's stabilization */
;;;1355     if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;1356     {  
;;;1357       /* Enable the Peripheral */
;;;1358       __HAL_ADC_ENABLE(hadc);
;;;1359       
;;;1360       /* Delay for ADC stabilization time */
;;;1361       /* Compute number of CPU cycles to wait for */
;;;1362       counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
;;;1363       while(counter != 0U)
;;;1364       {
;;;1365         counter--;
;;;1366       }
;;;1367     }
;;;1368     
;;;1369     /* Start conversion if ADC is effectively enabled */
;;;1370     if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
;;;1371     {
;;;1372       /* Set ADC state                                                          */
;;;1373       /* - Clear state bitfield related to regular group conversion results     */
;;;1374       /* - Set state bitfield related to regular group operation                */
;;;1375       ADC_STATE_CLR_SET(hadc->State,
;;;1376                         HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
;;;1377                         HAL_ADC_STATE_REG_BUSY);
;;;1378       
;;;1379       /* If conversions on group regular are also triggering group injected,    */
;;;1380       /* update ADC state.                                                      */
;;;1381       if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1382       {
;;;1383         ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1384       }
;;;1385       
;;;1386       /* State machine update: Check if an injected conversion is ongoing */
;;;1387       if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1388       {
;;;1389         /* Reset ADC error code fields related to conversions on group regular */
;;;1390         CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1391       }
;;;1392       else
;;;1393       {
;;;1394         /* Reset ADC all error code fields */
;;;1395         ADC_CLEAR_ERRORCODE(hadc);
;;;1396       }
;;;1397   
;;;1398       /* Process unlocked */
;;;1399       /* Unlock before starting ADC conversions: in case of potential           */
;;;1400       /* interruption, to let the process to ADC IRQ Handler.                   */
;;;1401       __HAL_UNLOCK(hadc);   
;;;1402   
;;;1403       /* Pointer to the common control register to which is belonging hadc    */
;;;1404       /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;1405       /* control register)                                                    */
;;;1406       tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;1407   
;;;1408       /* Set the DMA transfer complete callback */
;;;1409       hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;1410   
;;;1411       /* Set the DMA half transfer complete callback */
;;;1412       hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;1413       
;;;1414       /* Set the DMA error callback */
;;;1415       hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;1416   
;;;1417       
;;;1418       /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
;;;1419       /* start (in case of SW start):                                           */
;;;1420       
;;;1421       /* Clear regular group conversion flag and overrun flag */
;;;1422       /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1423       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
;;;1424   
;;;1425       /* Enable ADC overrun interrupt */
;;;1426       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;1427       
;;;1428       /* Enable ADC DMA mode */
;;;1429       hadc->Instance->CR2 |= ADC_CR2_DMA;
;;;1430       
;;;1431       /* Start the DMA channel */
;;;1432       HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;1433       
;;;1434       /* Check if Multimode enabled */
;;;1435       if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
;;;1436       {
;;;1437   #if defined(ADC2) && defined(ADC3)
;;;1438         if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
;;;1439                                     || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
;;;1440         {
;;;1441   #endif /* ADC2 || ADC3 */
;;;1442           /* if no external trigger present enable software conversion of regular channels */
;;;1443           if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;1444           {
;;;1445             /* Enable the selected ADC software conversion for regular group */
;;;1446             hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;1447           }
;;;1448   #if defined(ADC2) && defined(ADC3)
;;;1449         }
;;;1450   #endif /* ADC2 || ADC3 */
;;;1451       }
;;;1452       else
;;;1453       {
;;;1454         /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;1455         if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
;;;1456         {
;;;1457           /* Enable the selected ADC software conversion for regular group */
;;;1458             hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;1459         }
;;;1460       }
;;;1461     }
;;;1462     
;;;1463     /* Return function status */
;;;1464     return HAL_OK;
;;;1465   }
000018  bdf8              POP      {r3-r7,pc}
                  |L22.26|
00001a  2001              MOVS     r0,#1                 ;1350
00001c  f884003c          STRB     r0,[r4,#0x3c]         ;1350
000020  bf00              NOP                            ;1350
000022  6820              LDR      r0,[r4,#0]            ;1355
000024  6880              LDR      r0,[r0,#8]            ;1355
000026  f0000001          AND      r0,r0,#1              ;1355
00002a  b9a0              CBNZ     r0,|L22.86|
00002c  6820              LDR      r0,[r4,#0]            ;1358
00002e  6880              LDR      r0,[r0,#8]            ;1358
000030  f0400001          ORR      r0,r0,#1              ;1358
000034  6821              LDR      r1,[r4,#0]            ;1358
000036  6088              STR      r0,[r1,#8]            ;1358
000038  483d              LDR      r0,|L22.304|
00003a  6800              LDR      r0,[r0,#0]            ;1362  ; SystemCoreClock
00003c  493d              LDR      r1,|L22.308|
00003e  fbb0f0f1          UDIV     r0,r0,r1              ;1362
000042  eb000040          ADD      r0,r0,r0,LSL #1       ;1362
000046  9000              STR      r0,[sp,#0]            ;1362
000048  e002              B        |L22.80|
                  |L22.74|
00004a  9800              LDR      r0,[sp,#0]            ;1365
00004c  1e40              SUBS     r0,r0,#1              ;1365
00004e  9000              STR      r0,[sp,#0]            ;1365
                  |L22.80|
000050  9800              LDR      r0,[sp,#0]            ;1363
000052  2800              CMP      r0,#0                 ;1363
000054  d1f9              BNE      |L22.74|
                  |L22.86|
000056  6820              LDR      r0,[r4,#0]            ;1370
000058  6880              LDR      r0,[r0,#8]            ;1370
00005a  f0000001          AND      r0,r0,#1              ;1370
00005e  2800              CMP      r0,#0                 ;1370
000060  d064              BEQ      |L22.300|
000062  6c20              LDR      r0,[r4,#0x40]         ;1375
000064  f2406101          MOV      r1,#0x601             ;1375
000068  4388              BICS     r0,r0,r1              ;1375
00006a  f4407080          ORR      r0,r0,#0x100          ;1375
00006e  6420              STR      r0,[r4,#0x40]         ;1375
000070  6820              LDR      r0,[r4,#0]            ;1381
000072  6840              LDR      r0,[r0,#4]            ;1381
000074  f4006080          AND      r0,r0,#0x400          ;1381
000078  b128              CBZ      r0,|L22.134|
00007a  6c20              LDR      r0,[r4,#0x40]         ;1383
00007c  f4205000          BIC      r0,r0,#0x2000         ;1383
000080  f4405080          ORR      r0,r0,#0x1000         ;1383
000084  6420              STR      r0,[r4,#0x40]         ;1383
                  |L22.134|
000086  6c20              LDR      r0,[r4,#0x40]         ;1387
000088  f4005080          AND      r0,r0,#0x1000         ;1387
00008c  f5b05f80          CMP      r0,#0x1000            ;1387
000090  d104              BNE      |L22.156|
000092  6c60              LDR      r0,[r4,#0x44]         ;1390
000094  f0200006          BIC      r0,r0,#6              ;1390
000098  6460              STR      r0,[r4,#0x44]         ;1390
00009a  e001              B        |L22.160|
                  |L22.156|
00009c  2000              MOVS     r0,#0                 ;1395
00009e  6460              STR      r0,[r4,#0x44]         ;1395
                  |L22.160|
0000a0  bf00              NOP                            ;1401
0000a2  2000              MOVS     r0,#0                 ;1401
0000a4  f884003c          STRB     r0,[r4,#0x3c]         ;1401
0000a8  bf00              NOP                            ;1401
0000aa  4f23              LDR      r7,|L22.312|
0000ac  4823              LDR      r0,|L22.316|
0000ae  6ba1              LDR      r1,[r4,#0x38]         ;1409
0000b0  63c8              STR      r0,[r1,#0x3c]         ;1409
0000b2  4823              LDR      r0,|L22.320|
0000b4  6ba1              LDR      r1,[r4,#0x38]         ;1412
0000b6  6408              STR      r0,[r1,#0x40]         ;1412
0000b8  4822              LDR      r0,|L22.324|
0000ba  6ba1              LDR      r1,[r4,#0x38]         ;1415
0000bc  64c8              STR      r0,[r1,#0x4c]         ;1415
0000be  f06f0022          MVN      r0,#0x22              ;1423
0000c2  6821              LDR      r1,[r4,#0]            ;1423
0000c4  6008              STR      r0,[r1,#0]            ;1423
0000c6  6820              LDR      r0,[r4,#0]            ;1426
0000c8  6840              LDR      r0,[r0,#4]            ;1426
0000ca  f0406080          ORR      r0,r0,#0x4000000      ;1426
0000ce  6821              LDR      r1,[r4,#0]            ;1426
0000d0  6048              STR      r0,[r1,#4]            ;1426
0000d2  6820              LDR      r0,[r4,#0]            ;1429
0000d4  6880              LDR      r0,[r0,#8]            ;1429
0000d6  f4407080          ORR      r0,r0,#0x100          ;1429
0000da  6821              LDR      r1,[r4,#0]            ;1429
0000dc  6088              STR      r0,[r1,#8]            ;1429
0000de  6822              LDR      r2,[r4,#0]            ;1432
0000e0  f102014c          ADD      r1,r2,#0x4c           ;1432
0000e4  4633              MOV      r3,r6                 ;1432
0000e6  462a              MOV      r2,r5                 ;1432
0000e8  6ba0              LDR      r0,[r4,#0x38]         ;1432
0000ea  f7fffffe          BL       HAL_DMA_Start_IT
0000ee  6878              LDR      r0,[r7,#4]            ;1435
0000f0  f000001f          AND      r0,r0,#0x1f           ;1435
0000f4  b958              CBNZ     r0,|L22.270|
0000f6  6820              LDR      r0,[r4,#0]            ;1443
0000f8  6880              LDR      r0,[r0,#8]            ;1443
0000fa  f0005040          AND      r0,r0,#0x30000000     ;1443
0000fe  b928              CBNZ     r0,|L22.268|
000100  6820              LDR      r0,[r4,#0]            ;1446
000102  6880              LDR      r0,[r0,#8]            ;1446
000104  f0404080          ORR      r0,r0,#0x40000000     ;1446
000108  6821              LDR      r1,[r4,#0]            ;1446
00010a  6088              STR      r0,[r1,#8]            ;1446
                  |L22.268|
00010c  e00e              B        |L22.300|
                  |L22.270|
00010e  490e              LDR      r1,|L22.328|
000110  6820              LDR      r0,[r4,#0]            ;1455
000112  4288              CMP      r0,r1                 ;1455
000114  d10a              BNE      |L22.300|
000116  6820              LDR      r0,[r4,#0]            ;1455
000118  6880              LDR      r0,[r0,#8]            ;1455
00011a  f0005040          AND      r0,r0,#0x30000000     ;1455
00011e  b928              CBNZ     r0,|L22.300|
000120  6820              LDR      r0,[r4,#0]            ;1458
000122  6880              LDR      r0,[r0,#8]            ;1458
000124  f0404080          ORR      r0,r0,#0x40000000     ;1458
000128  6821              LDR      r1,[r4,#0]            ;1458
00012a  6088              STR      r0,[r1,#8]            ;1458
                  |L22.300|
00012c  2000              MOVS     r0,#0                 ;1464
00012e  e773              B        |L22.24|
;;;1466   
                          ENDP

                  |L22.304|
                          DCD      SystemCoreClock
                  |L22.308|
                          DCD      0x000f4240
                  |L22.312|
                          DCD      0x40012300
                  |L22.316|
                          DCD      ADC_DMAConvCplt
                  |L22.320|
                          DCD      ADC_DMAHalfConvCplt
                  |L22.324|
                          DCD      ADC_DMAError
                  |L22.328|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_IT PROC
;;;1023     */
;;;1024   HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
000000  b508              PUSH     {r3,lr}
;;;1025   {
000002  4601              MOV      r1,r0
;;;1026     __IO uint32_t counter = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1027     ADC_Common_TypeDef *tmpADC_Common;
;;;1028     
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1031     assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;1032     
;;;1033     /* Process locked */
;;;1034     __HAL_LOCK(hadc);
000008  bf00              NOP      
00000a  f891003c          LDRB     r0,[r1,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L23.22|
000012  2002              MOVS     r0,#2
                  |L23.20|
;;;1035     
;;;1036     /* Enable the ADC peripheral */
;;;1037     /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;1038     Tstab time the ADC's stabilization */
;;;1039     if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;1040     {  
;;;1041       /* Enable the Peripheral */
;;;1042       __HAL_ADC_ENABLE(hadc);
;;;1043       
;;;1044       /* Delay for ADC stabilization time */
;;;1045       /* Compute number of CPU cycles to wait for */
;;;1046       counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
;;;1047       while(counter != 0U)
;;;1048       {
;;;1049         counter--;
;;;1050       }
;;;1051     }
;;;1052     
;;;1053     /* Start conversion if ADC is effectively enabled */
;;;1054     if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
;;;1055     {
;;;1056       /* Set ADC state                                                          */
;;;1057       /* - Clear state bitfield related to regular group conversion results     */
;;;1058       /* - Set state bitfield related to regular group operation                */
;;;1059       ADC_STATE_CLR_SET(hadc->State,
;;;1060                         HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
;;;1061                         HAL_ADC_STATE_REG_BUSY);
;;;1062       
;;;1063       /* If conversions on group regular are also triggering group injected,    */
;;;1064       /* update ADC state.                                                      */
;;;1065       if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1066       {
;;;1067         ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1068       }
;;;1069       
;;;1070       /* State machine update: Check if an injected conversion is ongoing */
;;;1071       if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1072       {
;;;1073         /* Reset ADC error code fields related to conversions on group regular */
;;;1074         CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1075       }
;;;1076       else
;;;1077       {
;;;1078         /* Reset ADC all error code fields */
;;;1079         ADC_CLEAR_ERRORCODE(hadc);
;;;1080       }
;;;1081   
;;;1082       /* Process unlocked */
;;;1083       /* Unlock before starting ADC conversions: in case of potential           */
;;;1084       /* interruption, to let the process to ADC IRQ Handler.                   */
;;;1085       __HAL_UNLOCK(hadc);
;;;1086   
;;;1087       /* Pointer to the common control register to which is belonging hadc    */
;;;1088       /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
;;;1089       /* control register)                                                    */
;;;1090       tmpADC_Common = ADC_COMMON_REGISTER(hadc);
;;;1091   
;;;1092       /* Clear regular group conversion flag and overrun flag */
;;;1093       /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1094       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
;;;1095       
;;;1096       /* Enable end of conversion interrupt for regular group */
;;;1097       __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
;;;1098       
;;;1099       /* Check if Multimode enabled */
;;;1100       if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
;;;1101       {
;;;1102   #if defined(ADC2) && defined(ADC3)
;;;1103         if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
;;;1104                                     || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
;;;1105         {
;;;1106   #endif /* ADC2 || ADC3 */
;;;1107           /* if no external trigger present enable software conversion of regular channels */
;;;1108           if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;1109           {
;;;1110             /* Enable the selected ADC software conversion for regular group */
;;;1111             hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;1112           }
;;;1113   #if defined(ADC2) && defined(ADC3)
;;;1114         }
;;;1115   #endif /* ADC2 || ADC3 */
;;;1116       }
;;;1117       else
;;;1118       {
;;;1119         /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;1120         if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
;;;1121         {
;;;1122           /* Enable the selected ADC software conversion for regular group */
;;;1123             hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;1124         }
;;;1125       }
;;;1126     }
;;;1127     
;;;1128     /* Return function status */
;;;1129     return HAL_OK;
;;;1130   }
000014  bd08              POP      {r3,pc}
                  |L23.22|
000016  2001              MOVS     r0,#1                 ;1034
000018  f881003c          STRB     r0,[r1,#0x3c]         ;1034
00001c  bf00              NOP                            ;1034
00001e  6808              LDR      r0,[r1,#0]            ;1039
000020  6880              LDR      r0,[r0,#8]            ;1039
000022  f0000001          AND      r0,r0,#1              ;1039
000026  b9a0              CBNZ     r0,|L23.82|
000028  6808              LDR      r0,[r1,#0]            ;1042
00002a  6880              LDR      r0,[r0,#8]            ;1042
00002c  f0400001          ORR      r0,r0,#1              ;1042
000030  680b              LDR      r3,[r1,#0]            ;1042
000032  6098              STR      r0,[r3,#8]            ;1042
000034  4832              LDR      r0,|L23.256|
000036  6800              LDR      r0,[r0,#0]            ;1046  ; SystemCoreClock
000038  4b32              LDR      r3,|L23.260|
00003a  fbb0f0f3          UDIV     r0,r0,r3              ;1046
00003e  eb000040          ADD      r0,r0,r0,LSL #1       ;1046
000042  9000              STR      r0,[sp,#0]            ;1046
000044  e002              B        |L23.76|
                  |L23.70|
000046  9800              LDR      r0,[sp,#0]            ;1049
000048  1e40              SUBS     r0,r0,#1              ;1049
00004a  9000              STR      r0,[sp,#0]            ;1049
                  |L23.76|
00004c  9800              LDR      r0,[sp,#0]            ;1047
00004e  2800              CMP      r0,#0                 ;1047
000050  d1f9              BNE      |L23.70|
                  |L23.82|
000052  6808              LDR      r0,[r1,#0]            ;1054
000054  6880              LDR      r0,[r0,#8]            ;1054
000056  f0000001          AND      r0,r0,#1              ;1054
00005a  2800              CMP      r0,#0                 ;1054
00005c  d04d              BEQ      |L23.250|
00005e  6c08              LDR      r0,[r1,#0x40]         ;1059
000060  f2406301          MOV      r3,#0x601             ;1059
000064  4398              BICS     r0,r0,r3              ;1059
000066  f4407080          ORR      r0,r0,#0x100          ;1059
00006a  6408              STR      r0,[r1,#0x40]         ;1059
00006c  6808              LDR      r0,[r1,#0]            ;1065
00006e  6840              LDR      r0,[r0,#4]            ;1065
000070  f4006080          AND      r0,r0,#0x400          ;1065
000074  b128              CBZ      r0,|L23.130|
000076  6c08              LDR      r0,[r1,#0x40]         ;1067
000078  f4205000          BIC      r0,r0,#0x2000         ;1067
00007c  f4405080          ORR      r0,r0,#0x1000         ;1067
000080  6408              STR      r0,[r1,#0x40]         ;1067
                  |L23.130|
000082  6c08              LDR      r0,[r1,#0x40]         ;1071
000084  f4005080          AND      r0,r0,#0x1000         ;1071
000088  f5b05f80          CMP      r0,#0x1000            ;1071
00008c  d104              BNE      |L23.152|
00008e  6c48              LDR      r0,[r1,#0x44]         ;1074
000090  f0200006          BIC      r0,r0,#6              ;1074
000094  6448              STR      r0,[r1,#0x44]         ;1074
000096  e001              B        |L23.156|
                  |L23.152|
000098  2000              MOVS     r0,#0                 ;1079
00009a  6448              STR      r0,[r1,#0x44]         ;1079
                  |L23.156|
00009c  bf00              NOP                            ;1085
00009e  2000              MOVS     r0,#0                 ;1085
0000a0  f881003c          STRB     r0,[r1,#0x3c]         ;1085
0000a4  bf00              NOP                            ;1085
0000a6  4a18              LDR      r2,|L23.264|
0000a8  f06f0022          MVN      r0,#0x22              ;1094
0000ac  680b              LDR      r3,[r1,#0]            ;1094
0000ae  6018              STR      r0,[r3,#0]            ;1094
0000b0  6808              LDR      r0,[r1,#0]            ;1097
0000b2  6840              LDR      r0,[r0,#4]            ;1097
0000b4  4b15              LDR      r3,|L23.268|
0000b6  4318              ORRS     r0,r0,r3              ;1097
0000b8  680b              LDR      r3,[r1,#0]            ;1097
0000ba  6058              STR      r0,[r3,#4]            ;1097
0000bc  6850              LDR      r0,[r2,#4]            ;1100
0000be  f000001f          AND      r0,r0,#0x1f           ;1100
0000c2  b958              CBNZ     r0,|L23.220|
0000c4  6808              LDR      r0,[r1,#0]            ;1108
0000c6  6880              LDR      r0,[r0,#8]            ;1108
0000c8  f0005040          AND      r0,r0,#0x30000000     ;1108
0000cc  b9a8              CBNZ     r0,|L23.250|
0000ce  6808              LDR      r0,[r1,#0]            ;1111
0000d0  6880              LDR      r0,[r0,#8]            ;1111
0000d2  f0404080          ORR      r0,r0,#0x40000000     ;1111
0000d6  680b              LDR      r3,[r1,#0]            ;1111
0000d8  6098              STR      r0,[r3,#8]            ;1111
0000da  e00e              B        |L23.250|
                  |L23.220|
0000dc  4b0c              LDR      r3,|L23.272|
0000de  6808              LDR      r0,[r1,#0]            ;1120
0000e0  4298              CMP      r0,r3                 ;1120
0000e2  d10a              BNE      |L23.250|
0000e4  6808              LDR      r0,[r1,#0]            ;1120
0000e6  6880              LDR      r0,[r0,#8]            ;1120
0000e8  f0005040          AND      r0,r0,#0x30000000     ;1120
0000ec  b928              CBNZ     r0,|L23.250|
0000ee  6808              LDR      r0,[r1,#0]            ;1123
0000f0  6880              LDR      r0,[r0,#8]            ;1123
0000f2  f0404080          ORR      r0,r0,#0x40000000     ;1123
0000f6  680b              LDR      r3,[r1,#0]            ;1123
0000f8  6098              STR      r0,[r3,#8]            ;1123
                  |L23.250|
0000fa  2000              MOVS     r0,#0                 ;1129
0000fc  e78a              B        |L23.20|
;;;1131   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L23.256|
                          DCD      SystemCoreClock
                  |L23.260|
                          DCD      0x000f4240
                  |L23.264|
                          DCD      0x40012300
                  |L23.268|
                          DCD      0x04000020
                  |L23.272|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop PROC
;;;833      */
;;;834    HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;835    {
;;;836      /* Check the parameters */
;;;837      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;838      
;;;839      /* Process locked */
;;;840      __HAL_LOCK(hadc);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L24.16|
00000c  2002              MOVS     r0,#2
                  |L24.14|
;;;841      
;;;842      /* Stop potential conversion on going, on regular and injected groups */
;;;843      /* Disable ADC peripheral */
;;;844      __HAL_ADC_DISABLE(hadc);
;;;845      
;;;846      /* Check if ADC is effectively disabled */
;;;847      if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
;;;848      {
;;;849        /* Set ADC state */
;;;850        ADC_STATE_CLR_SET(hadc->State,
;;;851                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;852                          HAL_ADC_STATE_READY);
;;;853      }
;;;854      
;;;855      /* Process unlocked */
;;;856      __HAL_UNLOCK(hadc);
;;;857      
;;;858      /* Return function status */
;;;859      return HAL_OK;
;;;860    }
00000e  4770              BX       lr
                  |L24.16|
000010  2001              MOVS     r0,#1                 ;840
000012  f881003c          STRB     r0,[r1,#0x3c]         ;840
000016  bf00              NOP                            ;840
000018  6808              LDR      r0,[r1,#0]            ;844
00001a  6880              LDR      r0,[r0,#8]            ;844
00001c  f0200001          BIC      r0,r0,#1              ;844
000020  680a              LDR      r2,[r1,#0]            ;844
000022  6090              STR      r0,[r2,#8]            ;844
000024  6808              LDR      r0,[r1,#0]            ;847
000026  6880              LDR      r0,[r0,#8]            ;847
000028  f0000001          AND      r0,r0,#1              ;847
00002c  b928              CBNZ     r0,|L24.58|
00002e  6c08              LDR      r0,[r1,#0x40]         ;850
000030  f4205088          BIC      r0,r0,#0x1100         ;850
000034  f0400001          ORR      r0,r0,#1              ;850
000038  6408              STR      r0,[r1,#0x40]         ;850
                  |L24.58|
00003a  bf00              NOP                            ;856
00003c  2000              MOVS     r0,#0                 ;856
00003e  f881003c          STRB     r0,[r1,#0x3c]         ;856
000042  bf00              NOP                            ;856
000044  bf00              NOP                            ;859
000046  e7e2              B        |L24.14|
;;;861    
                          ENDP


                          AREA ||i.HAL_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_DMA PROC
;;;1472     */
;;;1473   HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1474   {
000002  4604              MOV      r4,r0
;;;1475     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1476     
;;;1477     /* Check the parameters */
;;;1478     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1479     
;;;1480     /* Process locked */
;;;1481     __HAL_LOCK(hadc);
000006  bf00              NOP      
000008  f894003c          LDRB     r0,[r4,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L25.20|
000010  2002              MOVS     r0,#2
                  |L25.18|
;;;1482     
;;;1483     /* Stop potential conversion on going, on regular and injected groups */
;;;1484     /* Disable ADC peripheral */
;;;1485     __HAL_ADC_DISABLE(hadc);
;;;1486     
;;;1487     /* Check if ADC is effectively disabled */
;;;1488     if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
;;;1489     {
;;;1490       /* Disable the selected ADC DMA mode */
;;;1491       hadc->Instance->CR2 &= ~ADC_CR2_DMA;
;;;1492       
;;;1493       /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;1494       /* DMA transfer is on going)                                              */
;;;1495       tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;1496       
;;;1497       /* Disable ADC overrun interrupt */
;;;1498       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
;;;1499       
;;;1500       /* Set ADC state */
;;;1501       ADC_STATE_CLR_SET(hadc->State,
;;;1502                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1503                         HAL_ADC_STATE_READY);
;;;1504     }
;;;1505     
;;;1506     /* Process unlocked */
;;;1507     __HAL_UNLOCK(hadc);
;;;1508     
;;;1509     /* Return function status */
;;;1510     return tmp_hal_status;
;;;1511   }
000012  bd70              POP      {r4-r6,pc}
                  |L25.20|
000014  2001              MOVS     r0,#1                 ;1481
000016  f884003c          STRB     r0,[r4,#0x3c]         ;1481
00001a  bf00              NOP                            ;1481
00001c  6820              LDR      r0,[r4,#0]            ;1485
00001e  6880              LDR      r0,[r0,#8]            ;1485
000020  f0200001          BIC      r0,r0,#1              ;1485
000024  6821              LDR      r1,[r4,#0]            ;1485
000026  6088              STR      r0,[r1,#8]            ;1485
000028  6820              LDR      r0,[r4,#0]            ;1488
00002a  6880              LDR      r0,[r0,#8]            ;1488
00002c  f0000001          AND      r0,r0,#1              ;1488
000030  b9a8              CBNZ     r0,|L25.94|
000032  6820              LDR      r0,[r4,#0]            ;1491
000034  6880              LDR      r0,[r0,#8]            ;1491
000036  f4207080          BIC      r0,r0,#0x100          ;1491
00003a  6821              LDR      r1,[r4,#0]            ;1491
00003c  6088              STR      r0,[r1,#8]            ;1491
00003e  6ba0              LDR      r0,[r4,#0x38]         ;1495
000040  f7fffffe          BL       HAL_DMA_Abort
000044  4605              MOV      r5,r0                 ;1495
000046  6820              LDR      r0,[r4,#0]            ;1498
000048  6840              LDR      r0,[r0,#4]            ;1498
00004a  f0206080          BIC      r0,r0,#0x4000000      ;1498
00004e  6821              LDR      r1,[r4,#0]            ;1498
000050  6048              STR      r0,[r1,#4]            ;1498
000052  6c20              LDR      r0,[r4,#0x40]         ;1501
000054  f4205088          BIC      r0,r0,#0x1100         ;1501
000058  f0400001          ORR      r0,r0,#1              ;1501
00005c  6420              STR      r0,[r4,#0x40]         ;1501
                  |L25.94|
00005e  bf00              NOP                            ;1507
000060  2000              MOVS     r0,#0                 ;1507
000062  f884003c          STRB     r0,[r4,#0x3c]         ;1507
000066  bf00              NOP                            ;1507
000068  4628              MOV      r0,r5                 ;1510
00006a  e7d2              B        |L25.18|
;;;1512   
                          ENDP


                          AREA ||i.HAL_ADC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Stop_IT PROC
;;;1140     */
;;;1141   HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1142   {
;;;1143     /* Check the parameters */
;;;1144     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1145     
;;;1146     /* Process locked */
;;;1147     __HAL_LOCK(hadc);
000002  bf00              NOP      
000004  f891003c          LDRB     r0,[r1,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L26.16|
00000c  2002              MOVS     r0,#2
                  |L26.14|
;;;1148     
;;;1149     /* Stop potential conversion on going, on regular and injected groups */
;;;1150     /* Disable ADC peripheral */
;;;1151     __HAL_ADC_DISABLE(hadc);
;;;1152     
;;;1153     /* Check if ADC is effectively disabled */
;;;1154     if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
;;;1155     {
;;;1156     	/* Disable ADC end of conversion interrupt for regular group */
;;;1157       __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
;;;1158   
;;;1159       /* Set ADC state */
;;;1160       ADC_STATE_CLR_SET(hadc->State,
;;;1161                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1162                         HAL_ADC_STATE_READY);
;;;1163     }
;;;1164     
;;;1165     /* Process unlocked */
;;;1166     __HAL_UNLOCK(hadc);
;;;1167     
;;;1168     /* Return function status */
;;;1169     return HAL_OK;
;;;1170   }
00000e  4770              BX       lr
                  |L26.16|
000010  2001              MOVS     r0,#1                 ;1147
000012  f881003c          STRB     r0,[r1,#0x3c]         ;1147
000016  bf00              NOP                            ;1147
000018  6808              LDR      r0,[r1,#0]            ;1151
00001a  6880              LDR      r0,[r0,#8]            ;1151
00001c  f0200001          BIC      r0,r0,#1              ;1151
000020  680a              LDR      r2,[r1,#0]            ;1151
000022  6090              STR      r0,[r2,#8]            ;1151
000024  6808              LDR      r0,[r1,#0]            ;1154
000026  6880              LDR      r0,[r0,#8]            ;1154
000028  f0000001          AND      r0,r0,#1              ;1154
00002c  b958              CBNZ     r0,|L26.70|
00002e  6808              LDR      r0,[r1,#0]            ;1157
000030  6840              LDR      r0,[r0,#4]            ;1157
000032  4a08              LDR      r2,|L26.84|
000034  4010              ANDS     r0,r0,r2              ;1157
000036  680a              LDR      r2,[r1,#0]            ;1157
000038  6050              STR      r0,[r2,#4]            ;1157
00003a  6c08              LDR      r0,[r1,#0x40]         ;1160
00003c  f4205088          BIC      r0,r0,#0x1100         ;1160
000040  f0400001          ORR      r0,r0,#1              ;1160
000044  6408              STR      r0,[r1,#0x40]         ;1160
                  |L26.70|
000046  bf00              NOP                            ;1166
000048  2000              MOVS     r0,#0                 ;1166
00004a  f881003c          STRB     r0,[r1,#0x3c]         ;1166
00004e  bf00              NOP                            ;1166
000050  bf00              NOP                            ;1169
000052  e7dc              B        |L26.14|
;;;1171   
                          ENDP

                  |L26.84|
                          DCD      0xfbffffdf

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_adc_c_52ef8f50____RRX|
#line 587
|__asm___19_stm32f4xx_hal_adc_c_52ef8f50____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
