; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_nucleo.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_nucleo.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo\stm32f4xx_nucleo.c]
                          THUMB

                          AREA ||i.ADCx_DeInit||, CODE, READONLY, ALIGN=2

                  ADCx_DeInit PROC
;;;738      */
;;;739    static void ADCx_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;740    {
;;;741        hnucleo_Adc.Instance   = NUCLEO_ADCx;
000002  4805              LDR      r0,|L1.24|
000004  4905              LDR      r1,|L1.28|
000006  6008              STR      r0,[r1,#0]  ; hnucleo_Adc
;;;742        
;;;743        HAL_ADC_DeInit(&hnucleo_Adc);
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       HAL_ADC_DeInit
;;;744        ADCx_MspDeInit(&hnucleo_Adc);
00000e  4803              LDR      r0,|L1.28|
000010  f7fffffe          BL       ADCx_MspDeInit
;;;745    }
000014  bd10              POP      {r4,pc}
;;;746    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x40012000
                  |L1.28|
                          DCD      hnucleo_Adc

                          AREA ||i.ADCx_Init||, CODE, READONLY, ALIGN=2

                  ADCx_Init PROC
;;;714      */
;;;715    static void ADCx_Init(void)
000000  b510              PUSH     {r4,lr}
;;;716    {
;;;717      if(HAL_ADC_GetState(&hnucleo_Adc) == HAL_ADC_STATE_RESET)
000002  480f              LDR      r0,|L2.64|
000004  f7fffffe          BL       HAL_ADC_GetState
000008  b9c0              CBNZ     r0,|L2.60|
;;;718      {
;;;719        /* ADC Config */
;;;720        hnucleo_Adc.Instance                   = NUCLEO_ADCx;
00000a  480e              LDR      r0,|L2.68|
00000c  490c              LDR      r1,|L2.64|
00000e  6008              STR      r0,[r1,#0]  ; hnucleo_Adc
;;;721        hnucleo_Adc.Init.ClockPrescaler        = ADC_CLOCKPRESCALER_PCLK_DIV4; /* (must not exceed 36MHz) */
000010  f44f3080          MOV      r0,#0x10000
000014  6048              STR      r0,[r1,#4]  ; hnucleo_Adc
;;;722        hnucleo_Adc.Init.Resolution            = ADC_RESOLUTION12b;
000016  2100              MOVS     r1,#0
000018  4809              LDR      r0,|L2.64|
00001a  6081              STR      r1,[r0,#8]
;;;723        hnucleo_Adc.Init.DataAlign             = ADC_DATAALIGN_RIGHT;
00001c  60c1              STR      r1,[r0,#0xc]
;;;724        hnucleo_Adc.Init.ContinuousConvMode    = DISABLE;
00001e  7601              STRB     r1,[r0,#0x18]
;;;725        hnucleo_Adc.Init.DiscontinuousConvMode = DISABLE;
000020  f8801020          STRB     r1,[r0,#0x20]
;;;726        hnucleo_Adc.Init.ExternalTrigConvEdge  = ADC_EXTERNALTRIGCONVEDGE_NONE;
000024  62c1              STR      r1,[r0,#0x2c]
;;;727        hnucleo_Adc.Init.EOCSelection          = EOC_SINGLE_CONV;
000026  2101              MOVS     r1,#1
000028  6141              STR      r1,[r0,#0x14]
;;;728        hnucleo_Adc.Init.NbrOfConversion       = 1;
00002a  61c1              STR      r1,[r0,#0x1c]
;;;729        hnucleo_Adc.Init.DMAContinuousRequests = DISABLE;    
00002c  2100              MOVS     r1,#0
00002e  f8801030          STRB     r1,[r0,#0x30]
;;;730        
;;;731        ADCx_MspInit(&hnucleo_Adc);
000032  f7fffffe          BL       ADCx_MspInit
;;;732        HAL_ADC_Init(&hnucleo_Adc);
000036  4802              LDR      r0,|L2.64|
000038  f7fffffe          BL       HAL_ADC_Init
                  |L2.60|
;;;733      }
;;;734    }
00003c  bd10              POP      {r4,pc}
;;;735    
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      hnucleo_Adc
                  |L2.68|
                          DCD      0x40012000

                          AREA ||i.ADCx_MspDeInit||, CODE, READONLY, ALIGN=2

                  ADCx_MspDeInit PROC
;;;695      */
;;;696    static void ADCx_MspDeInit(ADC_HandleTypeDef *hadc)
000000  b510              PUSH     {r4,lr}
;;;697    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;698      GPIO_InitTypeDef  GPIO_InitStruct;
;;;699    
;;;700      /*** DeInit the ADC peripheral ***/ 
;;;701      /* Disable ADC clock */
;;;702      NUCLEO_ADCx_CLK_DISABLE(); 
000006  4807              LDR      r0,|L3.36|
000008  6800              LDR      r0,[r0,#0]
00000a  f4207080          BIC      r0,r0,#0x100
00000e  4905              LDR      r1,|L3.36|
000010  6008              STR      r0,[r1,#0]
;;;703    
;;;704      /* Configure the selected ADC Channel as analog input */
;;;705      GPIO_InitStruct.Pin = NUCLEO_ADCx_GPIO_PIN ;
000012  2001              MOVS     r0,#1
000014  9001              STR      r0,[sp,#4]
;;;706      HAL_GPIO_DeInit(NUCLEO_ADCx_GPIO_PORT, GPIO_InitStruct.Pin);
000016  4804              LDR      r0,|L3.40|
000018  9901              LDR      r1,[sp,#4]
00001a  f7fffffe          BL       HAL_GPIO_DeInit
;;;707    
;;;708      /* Disable GPIO clock has to be done by the application*/
;;;709      /* NUCLEO_ADCx_GPIO_CLK_DISABLE(); */
;;;710    }
00001e  b006              ADD      sp,sp,#0x18
000020  bd10              POP      {r4,pc}
;;;711    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x40023844
                  |L3.40|
                          DCD      0x40020400

                          AREA ||i.ADCx_MspInit||, CODE, READONLY, ALIGN=2

                  ADCx_MspInit PROC
;;;672      */
;;;673    static void ADCx_MspInit(ADC_HandleTypeDef *hadc)
000000  b510              PUSH     {r4,lr}
;;;674    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;675      GPIO_InitTypeDef  GPIO_InitStruct;
;;;676      
;;;677      /*** Configure the GPIOs ***/  
;;;678      /* Enable GPIO clock */
;;;679      NUCLEO_ADCx_GPIO_CLK_ENABLE();
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4815              LDR      r0,|L4.100|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400002          ORR      r0,r0,#2
000014  4913              LDR      r1,|L4.100|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000002          AND      r0,r0,#2
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;680      
;;;681      /* Configure the selected ADC Channel as analog input */
;;;682      GPIO_InitStruct.Pin = NUCLEO_ADCx_GPIO_PIN ;
000026  2001              MOVS     r0,#1
000028  9001              STR      r0,[sp,#4]
;;;683      GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
00002a  2003              MOVS     r0,#3
00002c  9002              STR      r0,[sp,#8]
;;;684      GPIO_InitStruct.Pull = GPIO_NOPULL;
00002e  2000              MOVS     r0,#0
000030  9003              STR      r0,[sp,#0xc]
;;;685      HAL_GPIO_Init(NUCLEO_ADCx_GPIO_PORT, &GPIO_InitStruct);
000032  a901              ADD      r1,sp,#4
000034  480c              LDR      r0,|L4.104|
000036  f7fffffe          BL       HAL_GPIO_Init
;;;686      
;;;687      /*** Configure the ADC peripheral ***/ 
;;;688      /* Enable ADC clock */
;;;689      NUCLEO_ADCx_CLK_ENABLE(); 
00003a  bf00              NOP      
00003c  2000              MOVS     r0,#0
00003e  9000              STR      r0,[sp,#0]
000040  4808              LDR      r0,|L4.100|
000042  3014              ADDS     r0,r0,#0x14
000044  6800              LDR      r0,[r0,#0]
000046  f4407080          ORR      r0,r0,#0x100
00004a  4906              LDR      r1,|L4.100|
00004c  3114              ADDS     r1,r1,#0x14
00004e  6008              STR      r0,[r1,#0]
000050  4608              MOV      r0,r1
000052  6800              LDR      r0,[r0,#0]
000054  f4007080          AND      r0,r0,#0x100
000058  9000              STR      r0,[sp,#0]
00005a  bf00              NOP      
00005c  bf00              NOP      
;;;690    }
00005e  b006              ADD      sp,sp,#0x18
000060  bd10              POP      {r4,pc}
;;;691    
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
                          DCD      0x40023830
                  |L4.104|
                          DCD      0x40020400

                          AREA ||i.BSP_GetVersion||, CODE, READONLY, ALIGN=2

                  BSP_GetVersion PROC
;;;176      */
;;;177    uint32_t BSP_GetVersion(void)
000000  4800              LDR      r0,|L5.4|
;;;178    {
;;;179      return __STM32F4xx_NUCLEO_BSP_VERSION;
;;;180    }
000002  4770              BX       lr
;;;181    
                          ENDP

                  |L5.4|
                          DCD      0x01020700

                          AREA ||i.BSP_JOY_DeInit||, CODE, READONLY, ALIGN=1

                  BSP_JOY_DeInit PROC
;;;773      */
;;;774    void BSP_JOY_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;775    {
;;;776      ADCx_DeInit();
000002  f7fffffe          BL       ADCx_DeInit
;;;777    }
000006  bd10              POP      {r4,pc}
;;;778    
                          ENDP


                          AREA ||i.BSP_JOY_GetState||, CODE, READONLY, ALIGN=2

                  BSP_JOY_GetState PROC
;;;790      */
;;;791    JOYState_TypeDef BSP_JOY_GetState(void)
000000  b570              PUSH     {r4-r6,lr}
;;;792    {
;;;793      JOYState_TypeDef state;
;;;794      uint16_t  keyconvertedvalue = 0;
000002  2400              MOVS     r4,#0
;;;795      
;;;796      /* Start the conversion process */
;;;797      HAL_ADC_Start(&hnucleo_Adc);
000004  4822              LDR      r0,|L7.144|
000006  f7fffffe          BL       HAL_ADC_Start
;;;798      
;;;799      /* Wait for the end of conversion */
;;;800      HAL_ADC_PollForConversion(&hnucleo_Adc, 10);
00000a  210a              MOVS     r1,#0xa
00000c  4820              LDR      r0,|L7.144|
00000e  f7fffffe          BL       HAL_ADC_PollForConversion
;;;801      
;;;802      /* Check if the continuous conversion of regular channel is finished */
;;;803      if(((HAL_ADC_GetState(&hnucleo_Adc) & HAL_ADC_STATE_EOC_REG) == HAL_ADC_STATE_EOC_REG))
000012  481f              LDR      r0,|L7.144|
000014  f7fffffe          BL       HAL_ADC_GetState
000018  f4007000          AND      r0,r0,#0x200
00001c  f5b07f00          CMP      r0,#0x200
000020  d103              BNE      |L7.42|
;;;804      {
;;;805        /* Get the converted value of regular channel */
;;;806        keyconvertedvalue = HAL_ADC_GetValue(&hnucleo_Adc);
000022  481b              LDR      r0,|L7.144|
000024  f7fffffe          BL       HAL_ADC_GetValue
000028  b284              UXTH     r4,r0
                  |L7.42|
;;;807      }
;;;808      
;;;809      if((keyconvertedvalue > 2010) && (keyconvertedvalue < 2090))
00002a  f24070da          MOV      r0,#0x7da
00002e  4284              CMP      r4,r0
000030  dd05              BLE      |L7.62|
000032  f640002a          MOV      r0,#0x82a
000036  4284              CMP      r4,r0
000038  da01              BGE      |L7.62|
;;;810      {
;;;811        state = JOY_UP;
00003a  2505              MOVS     r5,#5
00003c  e020              B        |L7.128|
                  |L7.62|
;;;812      }
;;;813      else if((keyconvertedvalue > 680) && (keyconvertedvalue < 780))
00003e  f5b47f2a          CMP      r4,#0x2a8
000042  dd04              BLE      |L7.78|
000044  f5b47f43          CMP      r4,#0x30c
000048  da01              BGE      |L7.78|
;;;814      {
;;;815        state = JOY_RIGHT;
00004a  2504              MOVS     r5,#4
00004c  e018              B        |L7.128|
                  |L7.78|
;;;816      }
;;;817      else if((keyconvertedvalue > 1270) && (keyconvertedvalue < 1350))
00004e  f24040f6          MOV      r0,#0x4f6
000052  4284              CMP      r4,r0
000054  dd05              BLE      |L7.98|
000056  f2405046          MOV      r0,#0x546
00005a  4284              CMP      r4,r0
00005c  da01              BGE      |L7.98|
;;;818      {
;;;819        state = JOY_SEL;
00005e  2501              MOVS     r5,#1
000060  e00e              B        |L7.128|
                  |L7.98|
;;;820      }
;;;821      else if((keyconvertedvalue > 50) && (keyconvertedvalue < 130))
000062  2c32              CMP      r4,#0x32
000064  dd03              BLE      |L7.110|
000066  2c82              CMP      r4,#0x82
000068  da01              BGE      |L7.110|
;;;822      {
;;;823        state = JOY_DOWN;
00006a  2502              MOVS     r5,#2
00006c  e008              B        |L7.128|
                  |L7.110|
;;;824      }
;;;825      else if((keyconvertedvalue > 3680) && (keyconvertedvalue < 3760))
00006e  f5b46f66          CMP      r4,#0xe60
000072  dd04              BLE      |L7.126|
000074  f5b46f6b          CMP      r4,#0xeb0
000078  da01              BGE      |L7.126|
;;;826      {
;;;827        state = JOY_LEFT;
00007a  2503              MOVS     r5,#3
00007c  e000              B        |L7.128|
                  |L7.126|
;;;828      }
;;;829      else
;;;830      {
;;;831        state = JOY_NONE;
00007e  2500              MOVS     r5,#0
                  |L7.128|
;;;832      }
;;;833      
;;;834      /* Loop while a key is pressed */
;;;835      if(state != JOY_NONE)
000080  b11d              CBZ      r5,|L7.138|
;;;836      { 
;;;837        keyconvertedvalue = HAL_ADC_GetValue(&hnucleo_Adc);  
000082  4803              LDR      r0,|L7.144|
000084  f7fffffe          BL       HAL_ADC_GetValue
000088  b284              UXTH     r4,r0
                  |L7.138|
;;;838      }
;;;839      /* Return the code of the Joystick key pressed */
;;;840      return state;
00008a  4628              MOV      r0,r5
;;;841    }
00008c  bd70              POP      {r4-r6,pc}
;;;842    #endif /* HAL_ADC_MODULE_ENABLED */
                          ENDP

00008e  0000              DCW      0x0000
                  |L7.144|
                          DCD      hnucleo_Adc

                          AREA ||i.BSP_JOY_Init||, CODE, READONLY, ALIGN=2

                  BSP_JOY_Init PROC
;;;753      */
;;;754    uint8_t BSP_JOY_Init(void)
000000  b510              PUSH     {r4,lr}
;;;755    {
;;;756      uint8_t status = HAL_ERROR;
000002  2401              MOVS     r4,#1
;;;757       
;;;758      ADCx_Init();
000004  f7fffffe          BL       ADCx_Init
;;;759       
;;;760      /* Select the ADC Channel to be converted */
;;;761      sConfig.Channel = NUCLEO_ADCx_CHANNEL;
000008  2008              MOVS     r0,#8
00000a  4906              LDR      r1,|L8.36|
00000c  6008              STR      r0,[r1,#0]  ; sConfig
;;;762      sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
00000e  2000              MOVS     r0,#0
000010  6088              STR      r0,[r1,#8]  ; sConfig
;;;763      sConfig.Rank = 1;
000012  2001              MOVS     r0,#1
000014  6048              STR      r0,[r1,#4]  ; sConfig
;;;764      status = HAL_ADC_ConfigChannel(&hnucleo_Adc, &sConfig);
000016  4804              LDR      r0,|L8.40|
000018  f7fffffe          BL       HAL_ADC_ConfigChannel
00001c  4604              MOV      r4,r0
;;;765      
;;;766      /* Return Joystick initialization status */
;;;767      return status;
00001e  4620              MOV      r0,r4
;;;768    }
000020  bd10              POP      {r4,pc}
;;;769    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      sConfig
                  |L8.40|
                          DCD      hnucleo_Adc

                          AREA ||i.BSP_LED_DeInit||, CODE, READONLY, ALIGN=2

                  BSP_LED_DeInit PROC
;;;212      */
;;;213    void BSP_LED_DeInit(Led_TypeDef Led)
000000  b510              PUSH     {r4,lr}
;;;214    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;215      GPIO_InitTypeDef  gpio_init_structure;
;;;216    
;;;217      /* Turn off LED */
;;;218      HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
000006  4a0a              LDR      r2,|L9.48|
000008  f8321014          LDRH     r1,[r2,r4,LSL #1]
00000c  4a09              LDR      r2,|L9.52|
00000e  f8520024          LDR      r0,[r2,r4,LSL #2]
000012  2200              MOVS     r2,#0
000014  f7fffffe          BL       HAL_GPIO_WritePin
;;;219      /* DeInit the GPIO_LED pin */
;;;220      gpio_init_structure.Pin = GPIO_PIN[Led];
000018  4805              LDR      r0,|L9.48|
00001a  f8300014          LDRH     r0,[r0,r4,LSL #1]
00001e  9001              STR      r0,[sp,#4]
;;;221      HAL_GPIO_DeInit(GPIO_PORT[Led], gpio_init_structure.Pin);
000020  4a04              LDR      r2,|L9.52|
000022  f8520024          LDR      r0,[r2,r4,LSL #2]
000026  9901              LDR      r1,[sp,#4]
000028  f7fffffe          BL       HAL_GPIO_DeInit
;;;222    }
00002c  b006              ADD      sp,sp,#0x18
00002e  bd10              POP      {r4,pc}
;;;223    
                          ENDP

                  |L9.48|
                          DCD      GPIO_PIN
                  |L9.52|
                          DCD      GPIO_PORT

                          AREA ||i.BSP_LED_Init||, CODE, READONLY, ALIGN=2

                  BSP_LED_Init PROC
;;;187      */
;;;188    void BSP_LED_Init(Led_TypeDef Led)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;190      GPIO_InitTypeDef  GPIO_InitStruct;
;;;191      
;;;192      /* Enable the GPIO_LED Clock */
;;;193      LEDx_GPIO_CLK_ENABLE(Led);
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4813              LDR      r0,|L10.92|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400001          ORR      r0,r0,#1
000014  4911              LDR      r1,|L10.92|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000001          AND      r0,r0,#1
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;194      
;;;195      /* Configure the GPIO_LED pin */
;;;196      GPIO_InitStruct.Pin = GPIO_PIN[Led];
000026  480e              LDR      r0,|L10.96|
000028  f8300014          LDRH     r0,[r0,r4,LSL #1]
00002c  9001              STR      r0,[sp,#4]
;;;197      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
00002e  2001              MOVS     r0,#1
000030  9002              STR      r0,[sp,#8]
;;;198      GPIO_InitStruct.Pull = GPIO_NOPULL;
000032  2000              MOVS     r0,#0
000034  9003              STR      r0,[sp,#0xc]
;;;199      GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
000036  2002              MOVS     r0,#2
000038  9004              STR      r0,[sp,#0x10]
;;;200      
;;;201      HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
00003a  490a              LDR      r1,|L10.100|
00003c  f8510024          LDR      r0,[r1,r4,LSL #2]
000040  a901              ADD      r1,sp,#4
000042  f7fffffe          BL       HAL_GPIO_Init
;;;202      
;;;203      HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
000046  4a06              LDR      r2,|L10.96|
000048  f8321014          LDRH     r1,[r2,r4,LSL #1]
00004c  4a05              LDR      r2,|L10.100|
00004e  f8520024          LDR      r0,[r2,r4,LSL #2]
000052  2200              MOVS     r2,#0
000054  f7fffffe          BL       HAL_GPIO_WritePin
;;;204    }
000058  b006              ADD      sp,sp,#0x18
00005a  bd10              POP      {r4,pc}
;;;205    
                          ENDP

                  |L10.92|
                          DCD      0x40023830
                  |L10.96|
                          DCD      GPIO_PIN
                  |L10.100|
                          DCD      GPIO_PORT

                          AREA ||i.BSP_LED_Off||, CODE, READONLY, ALIGN=2

                  BSP_LED_Off PROC
;;;240      */
;;;241    void BSP_LED_Off(Led_TypeDef Led)
000000  b510              PUSH     {r4,lr}
;;;242    {
000002  4604              MOV      r4,r0
;;;243      HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
000004  4a04              LDR      r2,|L11.24|
000006  f8321014          LDRH     r1,[r2,r4,LSL #1]
00000a  4a04              LDR      r2,|L11.28|
00000c  f8520024          LDR      r0,[r2,r4,LSL #2]
000010  2200              MOVS     r2,#0
000012  f7fffffe          BL       HAL_GPIO_WritePin
;;;244    }
000016  bd10              POP      {r4,pc}
;;;245    
                          ENDP

                  |L11.24|
                          DCD      GPIO_PIN
                  |L11.28|
                          DCD      GPIO_PORT

                          AREA ||i.BSP_LED_On||, CODE, READONLY, ALIGN=2

                  BSP_LED_On PROC
;;;229      */
;;;230    void BSP_LED_On(Led_TypeDef Led)
000000  b510              PUSH     {r4,lr}
;;;231    {
000002  4604              MOV      r4,r0
;;;232      HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET); 
000004  4a04              LDR      r2,|L12.24|
000006  f8321014          LDRH     r1,[r2,r4,LSL #1]
00000a  4a04              LDR      r2,|L12.28|
00000c  f8520024          LDR      r0,[r2,r4,LSL #2]
000010  2201              MOVS     r2,#1
000012  f7fffffe          BL       HAL_GPIO_WritePin
;;;233    }
000016  bd10              POP      {r4,pc}
;;;234    
                          ENDP

                  |L12.24|
                          DCD      GPIO_PIN
                  |L12.28|
                          DCD      GPIO_PORT

                          AREA ||i.BSP_LED_Toggle||, CODE, READONLY, ALIGN=2

                  BSP_LED_Toggle PROC
;;;251      */
;;;252    void BSP_LED_Toggle(Led_TypeDef Led)
000000  b510              PUSH     {r4,lr}
;;;253    {
000002  4604              MOV      r4,r0
;;;254      HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
000004  4a04              LDR      r2,|L13.24|
000006  f8321014          LDRH     r1,[r2,r4,LSL #1]
00000a  4a04              LDR      r2,|L13.28|
00000c  f8520024          LDR      r0,[r2,r4,LSL #2]
000010  f7fffffe          BL       HAL_GPIO_TogglePin
;;;255    }
000014  bd10              POP      {r4,pc}
;;;256    
                          ENDP

000016  0000              DCW      0x0000
                  |L13.24|
                          DCD      GPIO_PIN
                  |L13.28|
                          DCD      GPIO_PORT

                          AREA ||i.BSP_PB_DeInit||, CODE, READONLY, ALIGN=2

                  BSP_PB_DeInit PROC
;;;303      */
;;;304    void BSP_PB_DeInit(Button_TypeDef Button)
000000  b510              PUSH     {r4,lr}
;;;305    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;306        GPIO_InitTypeDef gpio_init_structure;
;;;307    
;;;308        gpio_init_structure.Pin = BUTTON_PIN[Button];
000006  4808              LDR      r0,|L14.40|
000008  f8300014          LDRH     r0,[r0,r4,LSL #1]
00000c  9001              STR      r0,[sp,#4]
;;;309        HAL_NVIC_DisableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
00000e  4907              LDR      r1,|L14.44|
000010  5d09              LDRB     r1,[r1,r4]
000012  b248              SXTB     r0,r1
000014  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;310        HAL_GPIO_DeInit(BUTTON_PORT[Button], gpio_init_structure.Pin);
000018  4a05              LDR      r2,|L14.48|
00001a  f8520024          LDR      r0,[r2,r4,LSL #2]
00001e  9901              LDR      r1,[sp,#4]
000020  f7fffffe          BL       HAL_GPIO_DeInit
;;;311    }
000024  b006              ADD      sp,sp,#0x18
000026  bd10              POP      {r4,pc}
;;;312    
                          ENDP

                  |L14.40|
                          DCD      BUTTON_PIN
                  |L14.44|
                          DCD      BUTTON_IRQn
                  |L14.48|
                          DCD      BUTTON_PORT

                          AREA ||i.BSP_PB_GetState||, CODE, READONLY, ALIGN=2

                  BSP_PB_GetState PROC
;;;318      */
;;;319    uint32_t BSP_PB_GetState(Button_TypeDef Button)
000000  b510              PUSH     {r4,lr}
;;;320    {
000002  4604              MOV      r4,r0
;;;321      return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
000004  4a04              LDR      r2,|L15.24|
000006  f8321014          LDRH     r1,[r2,r4,LSL #1]
00000a  4a04              LDR      r2,|L15.28|
00000c  f8520024          LDR      r0,[r2,r4,LSL #2]
000010  f7fffffe          BL       HAL_GPIO_ReadPin
;;;322    }
000014  bd10              POP      {r4,pc}
;;;323    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      BUTTON_PIN
                  |L15.28|
                          DCD      BUTTON_PORT

                          AREA ||i.BSP_PB_Init||, CODE, READONLY, ALIGN=2

                  BSP_PB_Init PROC
;;;266      */
;;;267    void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
000000  b530              PUSH     {r4,r5,lr}
;;;268    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;269      GPIO_InitTypeDef GPIO_InitStruct;
;;;270      
;;;271      /* Enable the BUTTON Clock */
;;;272      BUTTONx_GPIO_CLK_ENABLE(Button);
000008  bf00              NOP      
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
00000e  481d              LDR      r0,|L16.132|
000010  6800              LDR      r0,[r0,#0]
000012  f0400004          ORR      r0,r0,#4
000016  491b              LDR      r1,|L16.132|
000018  6008              STR      r0,[r1,#0]
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]
00001e  f0000004          AND      r0,r0,#4
000022  9001              STR      r0,[sp,#4]
000024  bf00              NOP      
000026  bf00              NOP      
;;;273      
;;;274      if(ButtonMode == BUTTON_MODE_GPIO)
000028  b975              CBNZ     r5,|L16.72|
;;;275      {
;;;276        /* Configure Button pin as input */
;;;277        GPIO_InitStruct.Pin = BUTTON_PIN[Button];
00002a  4817              LDR      r0,|L16.136|
00002c  f8300014          LDRH     r0,[r0,r4,LSL #1]
000030  9002              STR      r0,[sp,#8]
;;;278        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
000032  2000              MOVS     r0,#0
000034  9003              STR      r0,[sp,#0xc]
;;;279        GPIO_InitStruct.Pull = GPIO_PULLDOWN;
000036  2002              MOVS     r0,#2
000038  9004              STR      r0,[sp,#0x10]
;;;280        GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
00003a  9005              STR      r0,[sp,#0x14]
;;;281        HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
00003c  4913              LDR      r1,|L16.140|
00003e  f8510024          LDR      r0,[r1,r4,LSL #2]
000042  a902              ADD      r1,sp,#8
000044  f7fffffe          BL       HAL_GPIO_Init
                  |L16.72|
;;;282      }
;;;283      
;;;284      if(ButtonMode == BUTTON_MODE_EXTI)
000048  2d01              CMP      r5,#1
00004a  d119              BNE      |L16.128|
;;;285      {
;;;286        /* Configure Button pin as input with External interrupt */
;;;287        GPIO_InitStruct.Pin = BUTTON_PIN[Button];
00004c  480e              LDR      r0,|L16.136|
00004e  f8300014          LDRH     r0,[r0,r4,LSL #1]
000052  9002              STR      r0,[sp,#8]
;;;288        GPIO_InitStruct.Pull = GPIO_NOPULL;
000054  2000              MOVS     r0,#0
000056  9004              STR      r0,[sp,#0x10]
;;;289        GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; 
000058  480d              LDR      r0,|L16.144|
00005a  9003              STR      r0,[sp,#0xc]
;;;290        HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
00005c  490b              LDR      r1,|L16.140|
00005e  f8510024          LDR      r0,[r1,r4,LSL #2]
000062  a902              ADD      r1,sp,#8
000064  f7fffffe          BL       HAL_GPIO_Init
;;;291        
;;;292        /* Enable and set Button EXTI Interrupt to the lowest priority */
;;;293        HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
000068  490a              LDR      r1,|L16.148|
00006a  5d09              LDRB     r1,[r1,r4]
00006c  b248              SXTB     r0,r1
00006e  2200              MOVS     r2,#0
000070  210f              MOVS     r1,#0xf
000072  f7fffffe          BL       HAL_NVIC_SetPriority
;;;294        HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
000076  4907              LDR      r1,|L16.148|
000078  5d09              LDRB     r1,[r1,r4]
00007a  b248              SXTB     r0,r1
00007c  f7fffffe          BL       HAL_NVIC_EnableIRQ
                  |L16.128|
;;;295      }
;;;296    }
000080  b007              ADD      sp,sp,#0x1c
000082  bd30              POP      {r4,r5,pc}
;;;297    
                          ENDP

                  |L16.132|
                          DCD      0x40023830
                  |L16.136|
                          DCD      BUTTON_PIN
                  |L16.140|
                          DCD      BUTTON_PORT
                  |L16.144|
                          DCD      0x10210000
                  |L16.148|
                          DCD      BUTTON_IRQn

                          AREA ||i.LCD_Delay||, CODE, READONLY, ALIGN=1

                  LCD_Delay PROC
;;;660      */
;;;661    void LCD_Delay(uint32_t Delay)
000000  b510              PUSH     {r4,lr}
;;;662    {
000002  4604              MOV      r4,r0
;;;663      HAL_Delay(Delay);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       HAL_Delay
;;;664    }
00000a  bd10              POP      {r4,pc}
;;;665    #endif /* HAL_SPI_MODULE_ENABLED */
                          ENDP


                          AREA ||i.LCD_IO_Init||, CODE, READONLY, ALIGN=2

                  LCD_IO_Init PROC
;;;535      */
;;;536    void LCD_IO_Init(void)
000000  b500              PUSH     {lr}
;;;537    {
000002  b087              SUB      sp,sp,#0x1c
;;;538      GPIO_InitTypeDef  GPIO_InitStruct;
;;;539       
;;;540      /* LCD_CS_GPIO and LCD_DC_GPIO Periph clock enable */
;;;541      LCD_CS_GPIO_CLK_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
00000a  481c              LDR      r0,|L18.124|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0400002          ORR      r0,r0,#2
000012  491a              LDR      r1,|L18.124|
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  f0000002          AND      r0,r0,#2
00001e  9001              STR      r0,[sp,#4]
000020  bf00              NOP      
000022  bf00              NOP      
;;;542      LCD_DC_GPIO_CLK_ENABLE();
000024  bf00              NOP      
000026  2000              MOVS     r0,#0
000028  9001              STR      r0,[sp,#4]
00002a  4608              MOV      r0,r1
00002c  6800              LDR      r0,[r0,#0]
00002e  f0400001          ORR      r0,r0,#1
000032  6008              STR      r0,[r1,#0]
000034  4608              MOV      r0,r1
000036  6800              LDR      r0,[r0,#0]
000038  f0000001          AND      r0,r0,#1
00003c  9001              STR      r0,[sp,#4]
00003e  bf00              NOP      
000040  bf00              NOP      
;;;543      
;;;544      /* Configure LCD_CS_PIN pin: LCD Card CS pin */
;;;545      GPIO_InitStruct.Pin = LCD_CS_PIN;
000042  2040              MOVS     r0,#0x40
000044  9002              STR      r0,[sp,#8]
;;;546      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
000046  2001              MOVS     r0,#1
000048  9003              STR      r0,[sp,#0xc]
;;;547      GPIO_InitStruct.Pull = GPIO_NOPULL;
00004a  2000              MOVS     r0,#0
00004c  9004              STR      r0,[sp,#0x10]
;;;548      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
00004e  2003              MOVS     r0,#3
000050  9005              STR      r0,[sp,#0x14]
;;;549      HAL_GPIO_Init(LCD_CS_GPIO_PORT, &GPIO_InitStruct);
000052  a902              ADD      r1,sp,#8
000054  480a              LDR      r0,|L18.128|
000056  f7fffffe          BL       HAL_GPIO_Init
;;;550    
;;;551      /* Configure LCD_DC_PIN pin: LCD Card DC pin */
;;;552      GPIO_InitStruct.Pin = LCD_DC_PIN;
00005a  f44f7000          MOV      r0,#0x200
00005e  9002              STR      r0,[sp,#8]
;;;553      HAL_GPIO_Init(LCD_DC_GPIO_PORT, &GPIO_InitStruct);
000060  a902              ADD      r1,sp,#8
000062  4808              LDR      r0,|L18.132|
000064  f7fffffe          BL       HAL_GPIO_Init
;;;554      
;;;555      /* LCD chip select high */
;;;556      LCD_CS_HIGH();
000068  2201              MOVS     r2,#1
00006a  2140              MOVS     r1,#0x40
00006c  4804              LDR      r0,|L18.128|
00006e  f7fffffe          BL       HAL_GPIO_WritePin
;;;557      
;;;558      /* LCD SPI Config */
;;;559      SPIx_Init();
000072  f7fffffe          BL       SPIx_Init
;;;560    }
000076  b007              ADD      sp,sp,#0x1c
000078  bd00              POP      {pc}
;;;561    
                          ENDP

00007a  0000              DCW      0x0000
                  |L18.124|
                          DCD      0x40023830
                  |L18.128|
                          DCD      0x40020400
                  |L18.132|
                          DCD      0x40020000

                          AREA ||i.LCD_IO_WriteData||, CODE, READONLY, ALIGN=2

                  LCD_IO_WriteData PROC
;;;585      */
;;;586    void LCD_IO_WriteData(uint8_t Data)
000000  b510              PUSH     {r4,lr}
;;;587    {
000002  4604              MOV      r4,r0
;;;588      /* Reset LCD control line CS */
;;;589      LCD_CS_LOW();
000004  2200              MOVS     r2,#0
000006  2140              MOVS     r1,#0x40
000008  4808              LDR      r0,|L19.44|
00000a  f7fffffe          BL       HAL_GPIO_WritePin
;;;590      
;;;591      /* Set LCD data/command line DC to High */
;;;592      LCD_DC_HIGH();
00000e  2201              MOVS     r2,#1
000010  0251              LSLS     r1,r2,#9
000012  4807              LDR      r0,|L19.48|
000014  f7fffffe          BL       HAL_GPIO_WritePin
;;;593    
;;;594      /* Send Data */
;;;595      SPIx_Write(Data);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       SPIx_Write
;;;596      
;;;597      /* Deselect : Chip Select high */
;;;598      LCD_CS_HIGH();
00001e  2201              MOVS     r2,#1
000020  2140              MOVS     r1,#0x40
000022  4802              LDR      r0,|L19.44|
000024  f7fffffe          BL       HAL_GPIO_WritePin
;;;599    }
000028  bd10              POP      {r4,pc}
;;;600    
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      0x40020400
                  |L19.48|
                          DCD      0x40020000

                          AREA ||i.LCD_IO_WriteMultipleData||, CODE, READONLY, ALIGN=2

                  LCD_IO_WriteMultipleData PROC
;;;605      */
;;;606    void LCD_IO_WriteMultipleData(uint8_t *pData, uint32_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;607    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;608      uint32_t counter = 0;
000006  2600              MOVS     r6,#0
;;;609      __IO uint32_t data = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;610      
;;;611      /* Reset LCD control line CS */
;;;612      LCD_CS_LOW();
00000c  2200              MOVS     r2,#0
00000e  2140              MOVS     r1,#0x40
000010  481f              LDR      r0,|L20.144|
000012  f7fffffe          BL       HAL_GPIO_WritePin
;;;613      
;;;614      /* Set LCD data/command line DC to High */
;;;615      LCD_DC_HIGH();
000016  2201              MOVS     r2,#1
000018  0251              LSLS     r1,r2,#9
00001a  481e              LDR      r0,|L20.148|
00001c  f7fffffe          BL       HAL_GPIO_WritePin
;;;616    
;;;617      if (Size == 1)
000020  2d01              CMP      r5,#1
000022  d103              BNE      |L20.44|
;;;618      {
;;;619        /* Only 1 byte to be sent to LCD - general interface can be used */
;;;620        /* Send Data */
;;;621        SPIx_Write(*pData);
000024  7820              LDRB     r0,[r4,#0]
000026  f7fffffe          BL       SPIx_Write
00002a  e026              B        |L20.122|
                  |L20.44|
;;;622      }
;;;623      else
;;;624      {
;;;625        /* Several data should be sent in a raw */
;;;626        /* Direct SPI accesses for optimization */
;;;627        for (counter = Size; counter != 0; counter--)
00002c  462e              MOV      r6,r5
00002e  e01a              B        |L20.102|
                  |L20.48|
;;;628        {
;;;629          while(((hnucleo_Spi.Instance->SR) & SPI_FLAG_TXE) != SPI_FLAG_TXE)
000030  bf00              NOP      
                  |L20.50|
000032  4819              LDR      r0,|L20.152|
000034  6800              LDR      r0,[r0,#0]  ; hnucleo_Spi
000036  6880              LDR      r0,[r0,#8]
000038  f0000002          AND      r0,r0,#2
00003c  2802              CMP      r0,#2
00003e  d1f8              BNE      |L20.50|
;;;630          {
;;;631          }
;;;632          /* Need to invert bytes for LCD*/
;;;633          *((__IO uint8_t*)&hnucleo_Spi.Instance->DR) = *(pData+1);
000040  7860              LDRB     r0,[r4,#1]
000042  4915              LDR      r1,|L20.152|
000044  6809              LDR      r1,[r1,#0]  ; hnucleo_Spi
000046  7308              STRB     r0,[r1,#0xc]
;;;634          
;;;635          while(((hnucleo_Spi.Instance->SR) & SPI_FLAG_TXE) != SPI_FLAG_TXE)
000048  bf00              NOP      
                  |L20.74|
00004a  4813              LDR      r0,|L20.152|
00004c  6800              LDR      r0,[r0,#0]  ; hnucleo_Spi
00004e  6880              LDR      r0,[r0,#8]
000050  f0000002          AND      r0,r0,#2
000054  2802              CMP      r0,#2
000056  d1f8              BNE      |L20.74|
;;;636          {
;;;637          }
;;;638          *((__IO uint8_t*)&hnucleo_Spi.Instance->DR) = *pData;
000058  7820              LDRB     r0,[r4,#0]
00005a  490f              LDR      r1,|L20.152|
00005c  6809              LDR      r1,[r1,#0]  ; hnucleo_Spi
00005e  7308              STRB     r0,[r1,#0xc]
;;;639          counter--;
000060  1e76              SUBS     r6,r6,#1
;;;640          pData += 2;
000062  1ca4              ADDS     r4,r4,#2
000064  1e76              SUBS     r6,r6,#1              ;627
                  |L20.102|
000066  2e00              CMP      r6,#0                 ;627
000068  d1e2              BNE      |L20.48|
;;;641          }
;;;642      
;;;643        /* Wait until the bus is ready before releasing Chip select */ 
;;;644        while(((hnucleo_Spi.Instance->SR) & SPI_FLAG_BSY) != RESET)
00006a  bf00              NOP      
                  |L20.108|
00006c  480a              LDR      r0,|L20.152|
00006e  6800              LDR      r0,[r0,#0]  ; hnucleo_Spi
000070  6880              LDR      r0,[r0,#8]
000072  f0000080          AND      r0,r0,#0x80
000076  2800              CMP      r0,#0
000078  d1f8              BNE      |L20.108|
                  |L20.122|
;;;645        {
;;;646        } 
;;;647      } 
;;;648    
;;;649      /* Empty the Rx fifo */
;;;650      data = *(&hnucleo_Spi.Instance->DR);
00007a  4807              LDR      r0,|L20.152|
00007c  6800              LDR      r0,[r0,#0]  ; hnucleo_Spi
00007e  68c0              LDR      r0,[r0,#0xc]
000080  9000              STR      r0,[sp,#0]
;;;651      UNUSED(data);
000082  bf00              NOP      
;;;652    
;;;653      /* Deselect : Chip Select high */
;;;654      LCD_CS_HIGH();
000084  2201              MOVS     r2,#1
000086  2140              MOVS     r1,#0x40
000088  4801              LDR      r0,|L20.144|
00008a  f7fffffe          BL       HAL_GPIO_WritePin
;;;655    }
00008e  bdf8              POP      {r3-r7,pc}
;;;656    
                          ENDP

                  |L20.144|
                          DCD      0x40020400
                  |L20.148|
                          DCD      0x40020000
                  |L20.152|
                          DCD      hnucleo_Spi

                          AREA ||i.LCD_IO_WriteReg||, CODE, READONLY, ALIGN=2

                  LCD_IO_WriteReg PROC
;;;565      */
;;;566    void LCD_IO_WriteReg(uint8_t LCDReg)
000000  b510              PUSH     {r4,lr}
;;;567    {
000002  4604              MOV      r4,r0
;;;568      /* Reset LCD control line CS */
;;;569      LCD_CS_LOW();
000004  2200              MOVS     r2,#0
000006  2140              MOVS     r1,#0x40
000008  4808              LDR      r0,|L21.44|
00000a  f7fffffe          BL       HAL_GPIO_WritePin
;;;570      
;;;571      /* Set LCD data/command line DC to Low */
;;;572      LCD_DC_LOW();
00000e  2200              MOVS     r2,#0
000010  f44f7100          MOV      r1,#0x200
000014  4806              LDR      r0,|L21.48|
000016  f7fffffe          BL       HAL_GPIO_WritePin
;;;573        
;;;574      /* Send Command */
;;;575      SPIx_Write(LCDReg);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPIx_Write
;;;576      
;;;577      /* Deselect : Chip Select high */
;;;578      LCD_CS_HIGH();
000020  2201              MOVS     r2,#1
000022  2140              MOVS     r1,#0x40
000024  4801              LDR      r0,|L21.44|
000026  f7fffffe          BL       HAL_GPIO_WritePin
;;;579    }
00002a  bd10              POP      {r4,pc}
;;;580    
                          ENDP

                  |L21.44|
                          DCD      0x40020400
                  |L21.48|
                          DCD      0x40020000

                          AREA ||i.SD_IO_CSState||, CODE, READONLY, ALIGN=2

                  SD_IO_CSState PROC
;;;495      */
;;;496    void SD_IO_CSState(uint8_t val)
000000  b510              PUSH     {r4,lr}
;;;497    {
000002  4604              MOV      r4,r0
;;;498      if(val == 1) 
000004  2c01              CMP      r4,#1
000006  d105              BNE      |L22.20|
;;;499      {
;;;500        SD_CS_HIGH();
000008  2201              MOVS     r2,#1
00000a  2120              MOVS     r1,#0x20
00000c  4804              LDR      r0,|L22.32|
00000e  f7fffffe          BL       HAL_GPIO_WritePin
000012  e004              B        |L22.30|
                  |L22.20|
;;;501      }
;;;502      else
;;;503      {
;;;504        SD_CS_LOW();
000014  2200              MOVS     r2,#0
000016  2120              MOVS     r1,#0x20
000018  4801              LDR      r0,|L22.32|
00001a  f7fffffe          BL       HAL_GPIO_WritePin
                  |L22.30|
;;;505      }
;;;506    }
00001e  bd10              POP      {r4,pc}
;;;507    
                          ENDP

                  |L22.32|
                          DCD      0x40020400

                          AREA ||i.SD_IO_Init||, CODE, READONLY, ALIGN=2

                  SD_IO_Init PROC
;;;460      */
;;;461    void SD_IO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;462    {
000002  b086              SUB      sp,sp,#0x18
;;;463      GPIO_InitTypeDef  GPIO_InitStruct;
;;;464      uint8_t counter;
;;;465    
;;;466      /* SD_CS_GPIO Periph clock enable */
;;;467      SD_CS_GPIO_CLK_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  4815              LDR      r0,|L23.96|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0400002          ORR      r0,r0,#2
000012  4913              LDR      r1,|L23.96|
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  f0000002          AND      r0,r0,#2
00001e  9000              STR      r0,[sp,#0]
000020  bf00              NOP      
000022  bf00              NOP      
;;;468    
;;;469      /* Configure SD_CS_PIN pin: SD Card CS pin */
;;;470      GPIO_InitStruct.Pin = SD_CS_PIN;
000024  2020              MOVS     r0,#0x20
000026  9001              STR      r0,[sp,#4]
;;;471      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
000028  2001              MOVS     r0,#1
00002a  9002              STR      r0,[sp,#8]
;;;472      GPIO_InitStruct.Pull = GPIO_PULLUP;
00002c  9003              STR      r0,[sp,#0xc]
;;;473      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
00002e  2003              MOVS     r0,#3
000030  9004              STR      r0,[sp,#0x10]
;;;474      HAL_GPIO_Init(SD_CS_GPIO_PORT, &GPIO_InitStruct);
000032  a901              ADD      r1,sp,#4
000034  480b              LDR      r0,|L23.100|
000036  f7fffffe          BL       HAL_GPIO_Init
;;;475    
;;;476      /*------------Put SD in SPI mode--------------*/
;;;477      /* SD SPI Config */
;;;478      SPIx_Init();
00003a  f7fffffe          BL       SPIx_Init
;;;479      
;;;480      /* SD chip select high */
;;;481      SD_CS_HIGH();
00003e  2201              MOVS     r2,#1
000040  2120              MOVS     r1,#0x20
000042  4808              LDR      r0,|L23.100|
000044  f7fffffe          BL       HAL_GPIO_WritePin
;;;482      
;;;483      /* Send dummy byte 0xFF, 10 times with CS high */
;;;484      /* Rise CS and MOSI for 80 clocks cycles */
;;;485      for (counter = 0; counter <= 9; counter++)
000048  2400              MOVS     r4,#0
00004a  e004              B        |L23.86|
                  |L23.76|
;;;486      {
;;;487        /* Send dummy byte 0xFF */
;;;488        SD_IO_WriteByte(SD_DUMMY_BYTE);
00004c  20ff              MOVS     r0,#0xff
00004e  f7fffffe          BL       SD_IO_WriteByte
000052  1c60              ADDS     r0,r4,#1              ;485
000054  b2c4              UXTB     r4,r0                 ;485
                  |L23.86|
000056  2c09              CMP      r4,#9                 ;485
000058  ddf8              BLE      |L23.76|
;;;489      }
;;;490    }
00005a  b006              ADD      sp,sp,#0x18
00005c  bd10              POP      {r4,pc}
;;;491    
                          ENDP

00005e  0000              DCW      0x0000
                  |L23.96|
                          DCD      0x40023830
                  |L23.100|
                          DCD      0x40020400

                          AREA ||i.SD_IO_WriteByte||, CODE, READONLY, ALIGN=1

                  SD_IO_WriteByte PROC
;;;523      */
;;;524    uint8_t SD_IO_WriteByte(uint8_t Data)
000000  b501              PUSH     {r0,lr}
;;;525    {
000002  b082              SUB      sp,sp,#8
;;;526      uint8_t tmp;
;;;527      /* Send the byte */
;;;528      SPIx_WriteReadData(&Data,&tmp,1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  a802              ADD      r0,sp,#8
00000a  f7fffffe          BL       SPIx_WriteReadData
;;;529      return tmp;
00000e  f89d0004          LDRB     r0,[sp,#4]
;;;530    }
000012  bd0e              POP      {r1-r3,pc}
;;;531    
                          ENDP


                          AREA ||i.SD_IO_WriteReadData||, CODE, READONLY, ALIGN=1

                  SD_IO_WriteReadData PROC
;;;513      */
;;;514    void SD_IO_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLength)
000000  b570              PUSH     {r4-r6,lr}
;;;515    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;516      /* Send the byte */
;;;517      SPIx_WriteReadData(DataIn, DataOut, DataLength);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       SPIx_WriteReadData
;;;518    }
000012  bd70              POP      {r4-r6,pc}
;;;519    
                          ENDP


                          AREA ||i.SPIx_Error||, CODE, READONLY, ALIGN=2

                  SPIx_Error PROC
;;;442      */
;;;443    static void SPIx_Error (void)
000000  b510              PUSH     {r4,lr}
;;;444    {
;;;445      /* De-initialize the SPI communication BUS */
;;;446      HAL_SPI_DeInit(&hnucleo_Spi);
000002  4803              LDR      r0,|L26.16|
000004  f7fffffe          BL       HAL_SPI_DeInit
;;;447      
;;;448      /* Re-Initiaize the SPI communication BUS */
;;;449      SPIx_Init();
000008  f7fffffe          BL       SPIx_Init
;;;450    }
00000c  bd10              POP      {r4,pc}
;;;451    
                          ENDP

00000e  0000              DCW      0x0000
                  |L26.16|
                          DCD      hnucleo_Spi

                          AREA ||i.SPIx_Init||, CODE, READONLY, ALIGN=2

                  SPIx_Init PROC
;;;369      */
;;;370    static void SPIx_Init(void)
000000  b510              PUSH     {r4,lr}
;;;371    {
;;;372      if(HAL_SPI_GetState(&hnucleo_Spi) == HAL_SPI_STATE_RESET)
000002  4813              LDR      r0,|L27.80|
000004  f7fffffe          BL       HAL_SPI_GetState
000008  bb08              CBNZ     r0,|L27.78|
;;;373      {
;;;374        /* SPI Config */
;;;375        hnucleo_Spi.Instance = NUCLEO_SPIx;
00000a  4812              LDR      r0,|L27.84|
00000c  4910              LDR      r1,|L27.80|
00000e  6008              STR      r0,[r1,#0]  ; hnucleo_Spi
;;;376          /* SPI baudrate is set to 12,5 MHz maximum (APB1/SPI_BaudRatePrescaler = 100/8 = 12,5 MHz) 
;;;377           to verify these constraints:
;;;378              - ST7735 LCD SPI interface max baudrate is 15MHz for write and 6.66MHz for read
;;;379                Since the provided driver doesn't use read capability from LCD, only constraint 
;;;380                on write baudrate is considered.
;;;381              - SD card SPI interface max baudrate is 25MHz for write/read
;;;382              - PCLK2 max frequency is 100 MHz 
;;;383           */ 
;;;384        hnucleo_Spi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
000010  2110              MOVS     r1,#0x10
000012  480f              LDR      r0,|L27.80|
000014  61c1              STR      r1,[r0,#0x1c]
;;;385        hnucleo_Spi.Init.Direction = SPI_DIRECTION_2LINES;
000016  2100              MOVS     r1,#0
000018  6081              STR      r1,[r0,#8]
;;;386        hnucleo_Spi.Init.CLKPhase = SPI_PHASE_2EDGE;
00001a  2101              MOVS     r1,#1
00001c  6141              STR      r1,[r0,#0x14]
;;;387        hnucleo_Spi.Init.CLKPolarity = SPI_POLARITY_HIGH;
00001e  2102              MOVS     r1,#2
000020  6101              STR      r1,[r0,#0x10]
;;;388        hnucleo_Spi.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
000022  2100              MOVS     r1,#0
000024  6281              STR      r1,[r0,#0x28]
;;;389        hnucleo_Spi.Init.CRCPolynomial = 7;
000026  2107              MOVS     r1,#7
000028  62c1              STR      r1,[r0,#0x2c]
;;;390        hnucleo_Spi.Init.DataSize = SPI_DATASIZE_8BIT;
00002a  2100              MOVS     r1,#0
00002c  60c1              STR      r1,[r0,#0xc]
;;;391        hnucleo_Spi.Init.FirstBit = SPI_FIRSTBIT_MSB;
00002e  6201              STR      r1,[r0,#0x20]
;;;392        hnucleo_Spi.Init.NSS = SPI_NSS_SOFT;
000030  f44f7100          MOV      r1,#0x200
000034  6181              STR      r1,[r0,#0x18]
;;;393        hnucleo_Spi.Init.TIMode = SPI_TIMODE_DISABLED;
000036  2100              MOVS     r1,#0
000038  6241              STR      r1,[r0,#0x24]
;;;394        hnucleo_Spi.Init.Mode = SPI_MODE_MASTER;
00003a  f44f7082          MOV      r0,#0x104
00003e  4904              LDR      r1,|L27.80|
000040  6048              STR      r0,[r1,#4]  ; hnucleo_Spi
;;;395    
;;;396        SPIx_MspInit(&hnucleo_Spi);
000042  4608              MOV      r0,r1
000044  f7fffffe          BL       SPIx_MspInit
;;;397        HAL_SPI_Init(&hnucleo_Spi);
000048  4801              LDR      r0,|L27.80|
00004a  f7fffffe          BL       HAL_SPI_Init
                  |L27.78|
;;;398      }
;;;399    }
00004e  bd10              POP      {r4,pc}
;;;400    
                          ENDP

                  |L27.80|
                          DCD      hnucleo_Spi
                  |L27.84|
                          DCD      0x40013000

                          AREA ||i.SPIx_MspInit||, CODE, READONLY, ALIGN=2

                  SPIx_MspInit PROC
;;;334      */
;;;335    static void SPIx_MspInit(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;336    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;337      GPIO_InitTypeDef  GPIO_InitStruct;  
;;;338      
;;;339      /*** Configure the GPIOs ***/  
;;;340      /* Enable GPIO clock */
;;;341      NUCLEO_SPIx_SCK_GPIO_CLK_ENABLE();
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4827              LDR      r0,|L28.172|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400001          ORR      r0,r0,#1
000014  4925              LDR      r1,|L28.172|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000001          AND      r0,r0,#1
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;342      NUCLEO_SPIx_MISO_MOSI_GPIO_CLK_ENABLE();
000026  bf00              NOP      
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
00002c  4608              MOV      r0,r1
00002e  6800              LDR      r0,[r0,#0]
000030  f0400001          ORR      r0,r0,#1
000034  6008              STR      r0,[r1,#0]
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]
00003a  f0000001          AND      r0,r0,#1
00003e  9000              STR      r0,[sp,#0]
000040  bf00              NOP      
000042  bf00              NOP      
;;;343      
;;;344      /* Configure SPI SCK */
;;;345      GPIO_InitStruct.Pin = NUCLEO_SPIx_SCK_PIN;
000044  2020              MOVS     r0,#0x20
000046  9001              STR      r0,[sp,#4]
;;;346      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
000048  2002              MOVS     r0,#2
00004a  9002              STR      r0,[sp,#8]
;;;347      GPIO_InitStruct.Pull  = GPIO_PULLUP;
00004c  2001              MOVS     r0,#1
00004e  9003              STR      r0,[sp,#0xc]
;;;348      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
000050  2003              MOVS     r0,#3
000052  9004              STR      r0,[sp,#0x10]
;;;349      GPIO_InitStruct.Alternate = NUCLEO_SPIx_SCK_AF;
000054  2005              MOVS     r0,#5
000056  9005              STR      r0,[sp,#0x14]
;;;350      HAL_GPIO_Init(NUCLEO_SPIx_SCK_GPIO_PORT, &GPIO_InitStruct);
000058  a901              ADD      r1,sp,#4
00005a  4815              LDR      r0,|L28.176|
00005c  f7fffffe          BL       HAL_GPIO_Init
;;;351    
;;;352      /* Configure SPI MISO and MOSI */ 
;;;353      GPIO_InitStruct.Pin = NUCLEO_SPIx_MOSI_PIN;
000060  2080              MOVS     r0,#0x80
000062  9001              STR      r0,[sp,#4]
;;;354      GPIO_InitStruct.Alternate = NUCLEO_SPIx_MISO_MOSI_AF;
000064  2005              MOVS     r0,#5
000066  9005              STR      r0,[sp,#0x14]
;;;355      GPIO_InitStruct.Pull  = GPIO_PULLDOWN;
000068  2002              MOVS     r0,#2
00006a  9003              STR      r0,[sp,#0xc]
;;;356      HAL_GPIO_Init(NUCLEO_SPIx_MISO_MOSI_GPIO_PORT, &GPIO_InitStruct);
00006c  a901              ADD      r1,sp,#4
00006e  4810              LDR      r0,|L28.176|
000070  f7fffffe          BL       HAL_GPIO_Init
;;;357      
;;;358      GPIO_InitStruct.Pin = NUCLEO_SPIx_MISO_PIN;
000074  2040              MOVS     r0,#0x40
000076  9001              STR      r0,[sp,#4]
;;;359      GPIO_InitStruct.Pull  = GPIO_PULLDOWN;
000078  2002              MOVS     r0,#2
00007a  9003              STR      r0,[sp,#0xc]
;;;360      HAL_GPIO_Init(NUCLEO_SPIx_MISO_MOSI_GPIO_PORT, &GPIO_InitStruct);
00007c  a901              ADD      r1,sp,#4
00007e  480c              LDR      r0,|L28.176|
000080  f7fffffe          BL       HAL_GPIO_Init
;;;361    
;;;362      /*** Configure the SPI peripheral ***/ 
;;;363      /* Enable SPI clock */
;;;364      NUCLEO_SPIx_CLK_ENABLE();
000084  bf00              NOP      
000086  2000              MOVS     r0,#0
000088  9000              STR      r0,[sp,#0]
00008a  4808              LDR      r0,|L28.172|
00008c  3014              ADDS     r0,r0,#0x14
00008e  6800              LDR      r0,[r0,#0]
000090  f4405080          ORR      r0,r0,#0x1000
000094  4905              LDR      r1,|L28.172|
000096  3114              ADDS     r1,r1,#0x14
000098  6008              STR      r0,[r1,#0]
00009a  4608              MOV      r0,r1
00009c  6800              LDR      r0,[r0,#0]
00009e  f4005080          AND      r0,r0,#0x1000
0000a2  9000              STR      r0,[sp,#0]
0000a4  bf00              NOP      
0000a6  bf00              NOP      
;;;365    }
0000a8  b006              ADD      sp,sp,#0x18
0000aa  bd10              POP      {r4,pc}
;;;366    
                          ENDP

                  |L28.172|
                          DCD      0x40023830
                  |L28.176|
                          DCD      0x40020000

                          AREA ||i.SPIx_Write||, CODE, READONLY, ALIGN=2

                  SPIx_Write PROC
;;;424      */
;;;425    static void SPIx_Write(uint8_t Value)
000000  b511              PUSH     {r0,r4,lr}
;;;426    {
000002  b083              SUB      sp,sp,#0xc
;;;427      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;428      uint8_t data;
;;;429    
;;;430      status = HAL_SPI_TransmitReceive(&hnucleo_Spi, (uint8_t*) &Value, &data, 1, SpixTimeout);
000006  4807              LDR      r0,|L29.36|
000008  6800              LDR      r0,[r0,#0]  ; SpixTimeout
00000a  2301              MOVS     r3,#1
00000c  aa02              ADD      r2,sp,#8
00000e  a903              ADD      r1,sp,#0xc
000010  9000              STR      r0,[sp,#0]
000012  4805              LDR      r0,|L29.40|
000014  f7fffffe          BL       HAL_SPI_TransmitReceive
000018  4604              MOV      r4,r0
;;;431        
;;;432      /* Check the communication status */
;;;433      if(status != HAL_OK)
00001a  b10c              CBZ      r4,|L29.32|
;;;434      {
;;;435        /* Execute user timeout callback */
;;;436        SPIx_Error();
00001c  f7fffffe          BL       SPIx_Error
                  |L29.32|
;;;437      }
;;;438    }
000020  bd1f              POP      {r0-r4,pc}
;;;439    
                          ENDP

000022  0000              DCW      0x0000
                  |L29.36|
                          DCD      SpixTimeout
                  |L29.40|
                          DCD      hnucleo_Spi

                          AREA ||i.SPIx_WriteReadData||, CODE, READONLY, ALIGN=2

                  SPIx_WriteReadData PROC
;;;406      */
;;;407    static void SPIx_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLegnth)
000000  b5f8              PUSH     {r3-r7,lr}
;;;408    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;409      HAL_StatusTypeDef status = HAL_OK;
000008  2700              MOVS     r7,#0
;;;410    
;;;411      status = HAL_SPI_TransmitReceive(&hnucleo_Spi, (uint8_t*) DataIn, DataOut, DataLegnth, SpixTimeout);
00000a  4807              LDR      r0,|L30.40|
00000c  6800              LDR      r0,[r0,#0]  ; SpixTimeout
00000e  4633              MOV      r3,r6
000010  462a              MOV      r2,r5
000012  4621              MOV      r1,r4
000014  9000              STR      r0,[sp,#0]
000016  4805              LDR      r0,|L30.44|
000018  f7fffffe          BL       HAL_SPI_TransmitReceive
00001c  4607              MOV      r7,r0
;;;412    
;;;413      /* Check the communication status */
;;;414      if(status != HAL_OK)
00001e  b10f              CBZ      r7,|L30.36|
;;;415      {
;;;416        /* Execute user timeout callback */
;;;417        SPIx_Error();
000020  f7fffffe          BL       SPIx_Error
                  |L30.36|
;;;418      }
;;;419    }
000024  bdf8              POP      {r3-r7,pc}
;;;420    
                          ENDP

000026  0000              DCW      0x0000
                  |L30.40|
                          DCD      SpixTimeout
                  |L30.44|
                          DCD      hnucleo_Spi

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  hnucleo_Spi
                          %        88
                  hnucleo_Adc
                          %        72
                  sConfig
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  GPIO_PIN
000000  0020              DCW      0x0020
                  BUTTON_PIN
000002  2000              DCW      0x2000
                  BUTTON_IRQn
000004  28                DCB      0x28

                          AREA ||.data||, DATA, ALIGN=2

                  GPIO_PORT
                          DCD      0x40020000
                  BUTTON_PORT
                          DCD      0x40020800
                  SpixTimeout
                          DCD      0x000003e8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\BSP\\STM32F4xx-Nucleo\\stm32f4xx_nucleo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_nucleo_c_c84236cb____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___18_stm32f4xx_nucleo_c_c84236cb____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_nucleo_c_c84236cb____REVSH|
#line 402
|__asm___18_stm32f4xx_nucleo_c_c84236cb____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_nucleo_c_c84236cb____RRX|
#line 587
|__asm___18_stm32f4xx_nucleo_c_c84236cb____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
