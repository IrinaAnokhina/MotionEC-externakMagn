; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_i2c.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_i2c.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c]
                          THUMB

                          AREA ||i.HAL_I2C_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AbortCpltCallback PROC
;;;4913     */
;;;4914   __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4915   {
;;;4916     /* Prevent unused argument(s) compilation warning */
;;;4917     UNUSED(hi2c);
;;;4918   
;;;4919     /* NOTE : This function should not be modified, when the callback is needed,
;;;4920               the HAL_I2C_AbortCpltCallback could be implemented in the user file
;;;4921      */
;;;4922   }
;;;4923   
                          ENDP


                          AREA ||i.HAL_I2C_AddrCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AddrCallback PROC
;;;4831     */
;;;4832   __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
000000  4770              BX       lr
;;;4833   {
;;;4834     /* Prevent unused argument(s) compilation warning */
;;;4835     UNUSED(hi2c);
;;;4836     UNUSED(TransferDirection);
;;;4837     UNUSED(AddrMatchCode);
;;;4838   
;;;4839     /* NOTE : This function should not be modified, when the callback is needed,
;;;4840               the HAL_I2C_AddrCallback() could be implemented in the user file
;;;4841      */
;;;4842   }
;;;4843   
                          ENDP


                          AREA ||i.HAL_I2C_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DeInit PROC
;;;541      */
;;;542    HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;543    {
000002  4604              MOV      r4,r0
;;;544      /* Check the I2C handle allocation */
;;;545      if (hi2c == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;546      {
;;;547        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;548      }
;;;549    
;;;550      /* Check the parameters */
;;;551      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;552    
;;;553      hi2c->State = HAL_I2C_STATE_BUSY;
;;;554    
;;;555      /* Disable the I2C Peripheral Clock */
;;;556      __HAL_I2C_DISABLE(hi2c);
;;;557    
;;;558    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;559      if (hi2c->MspDeInitCallback == NULL)
;;;560      {
;;;561        hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */
;;;562      }
;;;563    
;;;564      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;565      hi2c->MspDeInitCallback(hi2c);
;;;566    #else
;;;567      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;568      HAL_I2C_MspDeInit(hi2c);
;;;569    #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;570    
;;;571      hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
;;;572      hi2c->State         = HAL_I2C_STATE_RESET;
;;;573      hi2c->PreviousState = I2C_STATE_NONE;
;;;574      hi2c->Mode          = HAL_I2C_MODE_NONE;
;;;575    
;;;576      /* Release Lock */
;;;577      __HAL_UNLOCK(hi2c);
;;;578    
;;;579      return HAL_OK;
;;;580    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  2024              MOVS     r0,#0x24              ;553
00000c  f884003d          STRB     r0,[r4,#0x3d]         ;553
000010  6820              LDR      r0,[r4,#0]            ;556
000012  6800              LDR      r0,[r0,#0]            ;556
000014  f0200001          BIC      r0,r0,#1              ;556
000018  6821              LDR      r1,[r4,#0]            ;556
00001a  6008              STR      r0,[r1,#0]            ;556
00001c  4620              MOV      r0,r4                 ;568
00001e  f7fffffe          BL       HAL_I2C_MspDeInit
000022  2000              MOVS     r0,#0                 ;571
000024  6420              STR      r0,[r4,#0x40]         ;571
000026  f884003d          STRB     r0,[r4,#0x3d]         ;572
00002a  6320              STR      r0,[r4,#0x30]         ;573
00002c  f884003e          STRB     r0,[r4,#0x3e]         ;574
000030  bf00              NOP                            ;577
000032  f884003c          STRB     r0,[r4,#0x3c]         ;577
000036  bf00              NOP                            ;577
000038  bf00              NOP                            ;579
00003a  e7e5              B        |L3.8|
;;;581    
                          ENDP


                          AREA ||i.HAL_I2C_DisableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DisableListen_IT PROC
;;;4438     */
;;;4439   HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4440   {
;;;4441     /* Declaration of tmp to prevent undefined behavior of volatile usage */
;;;4442     uint32_t tmp;
;;;4443   
;;;4444     /* Disable Address listen mode only if a transfer is not ongoing */
;;;4445     if (hi2c->State == HAL_I2C_STATE_LISTEN)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2828              CMP      r0,#0x28
000008  d11b              BNE      |L4.66|
;;;4446     {
;;;4447       tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
00000a  f891003d          LDRB     r0,[r1,#0x3d]
00000e  f0000203          AND      r2,r0,#3
;;;4448       hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
000012  f891003e          LDRB     r0,[r1,#0x3e]
000016  4310              ORRS     r0,r0,r2
000018  6308              STR      r0,[r1,#0x30]
;;;4449       hi2c->State = HAL_I2C_STATE_READY;
00001a  2020              MOVS     r0,#0x20
00001c  f881003d          STRB     r0,[r1,#0x3d]
;;;4450       hi2c->Mode = HAL_I2C_MODE_NONE;
000020  2000              MOVS     r0,#0
000022  f881003e          STRB     r0,[r1,#0x3e]
;;;4451   
;;;4452       /* Disable Address Acknowledge */
;;;4453       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4206080          BIC      r0,r0,#0x400
00002e  680b              LDR      r3,[r1,#0]
000030  6018              STR      r0,[r3,#0]
;;;4454   
;;;4455       /* Disable EVT and ERR interrupt */
;;;4456       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000032  6808              LDR      r0,[r1,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f4207040          BIC      r0,r0,#0x300
00003a  680b              LDR      r3,[r1,#0]
00003c  6058              STR      r0,[r3,#4]
;;;4457   
;;;4458       return HAL_OK;
00003e  2000              MOVS     r0,#0
                  |L4.64|
;;;4459     }
;;;4460     else
;;;4461     {
;;;4462       return HAL_BUSY;
;;;4463     }
;;;4464   }
000040  4770              BX       lr
                  |L4.66|
000042  2002              MOVS     r0,#2                 ;4462
000044  e7fc              B        |L4.64|
;;;4465   
                          ENDP


                          AREA ||i.HAL_I2C_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ER_IRQHandler PROC
;;;4687     */
;;;4688   void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;4689   {
000004  4604              MOV      r4,r0
;;;4690     HAL_I2C_ModeTypeDef tmp1;
;;;4691     uint32_t tmp2;
;;;4692     HAL_I2C_StateTypeDef tmp3;
;;;4693     uint32_t tmp4;
;;;4694     uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
000006  6820              LDR      r0,[r4,#0]
000008  6947              LDR      r7,[r0,#0x14]
;;;4695     uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
00000a  6820              LDR      r0,[r4,#0]
00000c  f8d08004          LDR      r8,[r0,#4]
;;;4696     uint32_t error      = HAL_I2C_ERROR_NONE;
000010  2500              MOVS     r5,#0
;;;4697   
;;;4698     /* I2C Bus error interrupt occurred ----------------------------------------*/
;;;4699     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
000012  f3c72000          UBFX     r0,r7,#8,#1
000016  b140              CBZ      r0,|L5.42|
000018  f3c82000          UBFX     r0,r8,#8,#1
00001c  b128              CBZ      r0,|L5.42|
;;;4700     {
;;;4701       error |= HAL_I2C_ERROR_BERR;
00001e  f0450501          ORR      r5,r5,#1
;;;4702   
;;;4703       /* Clear BERR flag */
;;;4704       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
000022  f46f7080          MVN      r0,#0x100
000026  6821              LDR      r1,[r4,#0]
000028  6148              STR      r0,[r1,#0x14]
                  |L5.42|
;;;4705     }
;;;4706   
;;;4707     /* I2C Arbitration Lost error interrupt occurred ---------------------------*/
;;;4708     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
00002a  f3c72040          UBFX     r0,r7,#9,#1
00002e  b140              CBZ      r0,|L5.66|
000030  f3c82000          UBFX     r0,r8,#8,#1
000034  b128              CBZ      r0,|L5.66|
;;;4709     {
;;;4710       error |= HAL_I2C_ERROR_ARLO;
000036  f0450502          ORR      r5,r5,#2
;;;4711   
;;;4712       /* Clear ARLO flag */
;;;4713       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
00003a  f46f7000          MVN      r0,#0x200
00003e  6821              LDR      r1,[r4,#0]
000040  6148              STR      r0,[r1,#0x14]
                  |L5.66|
;;;4714     }
;;;4715   
;;;4716     /* I2C Acknowledge failure error interrupt occurred ------------------------*/
;;;4717     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
000042  f3c72080          UBFX     r0,r7,#10,#1
000046  b368              CBZ      r0,|L5.164|
000048  f3c82000          UBFX     r0,r8,#8,#1
00004c  b350              CBZ      r0,|L5.164|
;;;4718     {
;;;4719       tmp1 = hi2c->Mode;
00004e  f894903e          LDRB     r9,[r4,#0x3e]
;;;4720       tmp2 = hi2c->XferCount;
000052  f8b4a02a          LDRH     r10,[r4,#0x2a]
;;;4721       tmp3 = hi2c->State;
000056  f894603d          LDRB     r6,[r4,#0x3d]
;;;4722       tmp4 = hi2c->PreviousState;
00005a  f8d4b030          LDR      r11,[r4,#0x30]
;;;4723       if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
00005e  f1b90f20          CMP      r9,#0x20
000062  d10f              BNE      |L5.132|
000064  f1ba0f00          CMP      r10,#0
000068  d10c              BNE      |L5.132|
;;;4724           ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
00006a  2e21              CMP      r6,#0x21
00006c  d006              BEQ      |L5.124|
00006e  2e29              CMP      r6,#0x29
000070  d004              BEQ      |L5.124|
;;;4725            ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
000072  2e28              CMP      r6,#0x28
000074  d106              BNE      |L5.132|
000076  f1bb0f21          CMP      r11,#0x21
00007a  d103              BNE      |L5.132|
                  |L5.124|
;;;4726       {
;;;4727         I2C_Slave_AF(hi2c);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       I2C_Slave_AF
000082  e00f              B        |L5.164|
                  |L5.132|
;;;4728       }
;;;4729       else
;;;4730       {
;;;4731         /* Clear AF flag */
;;;4732         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000084  f46f6080          MVN      r0,#0x400
000088  6821              LDR      r1,[r4,#0]
00008a  6148              STR      r0,[r1,#0x14]
;;;4733   
;;;4734         error |= HAL_I2C_ERROR_AF;
00008c  f0450504          ORR      r5,r5,#4
;;;4735   
;;;4736         /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
;;;4737         if (hi2c->Mode == HAL_I2C_MODE_MASTER)
000090  f894003e          LDRB     r0,[r4,#0x3e]
000094  2810              CMP      r0,#0x10
000096  d105              BNE      |L5.164|
;;;4738         {
;;;4739           /* Generate Stop */
;;;4740           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000098  6820              LDR      r0,[r4,#0]
00009a  6800              LDR      r0,[r0,#0]
00009c  f4407000          ORR      r0,r0,#0x200
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6008              STR      r0,[r1,#0]
                  |L5.164|
;;;4741         }
;;;4742       }
;;;4743     }
;;;4744   
;;;4745     /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
;;;4746     if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
0000a4  f3c720c0          UBFX     r0,r7,#11,#1
0000a8  b140              CBZ      r0,|L5.188|
0000aa  f3c82000          UBFX     r0,r8,#8,#1
0000ae  b128              CBZ      r0,|L5.188|
;;;4747     {
;;;4748       error |= HAL_I2C_ERROR_OVR;
0000b0  f0450508          ORR      r5,r5,#8
;;;4749       /* Clear OVR flag */
;;;4750       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
0000b4  f46f6000          MVN      r0,#0x800
0000b8  6821              LDR      r1,[r4,#0]
0000ba  6148              STR      r0,[r1,#0x14]
                  |L5.188|
;;;4751     }
;;;4752   
;;;4753     /* Call the Error Callback in case of Error detected -----------------------*/
;;;4754     if (error != HAL_I2C_ERROR_NONE)
0000bc  b12d              CBZ      r5,|L5.202|
;;;4755     {
;;;4756       hi2c->ErrorCode |= error;
0000be  6c20              LDR      r0,[r4,#0x40]
0000c0  4328              ORRS     r0,r0,r5
0000c2  6420              STR      r0,[r4,#0x40]
;;;4757       I2C_ITError(hi2c);
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       I2C_ITError
                  |L5.202|
;;;4758     }
;;;4759   }
0000ca  e8bd9ff0          POP      {r4-r12,pc}
;;;4760   
                          ENDP


                          AREA ||i.HAL_I2C_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EV_IRQHandler PROC
;;;4528     */
;;;4529   void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4530   {
000004  4605              MOV      r5,r0
;;;4531     uint32_t sr1itflags;
;;;4532     uint32_t sr2itflags               = 0U;
000006  2700              MOVS     r7,#0
;;;4533     uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
000008  6828              LDR      r0,[r5,#0]
00000a  6846              LDR      r6,[r0,#4]
;;;4534     uint32_t CurrentXferOptions       = hi2c->XferOptions;
00000c  f8d5802c          LDR      r8,[r5,#0x2c]
;;;4535     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
000010  f895903e          LDRB     r9,[r5,#0x3e]
;;;4536     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000014  f895a03d          LDRB     r10,[r5,#0x3d]
;;;4537   
;;;4538     /* Master or Memory mode selected */
;;;4539     if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
000018  f1b90f10          CMP      r9,#0x10
00001c  d002              BEQ      |L6.36|
00001e  f1b90f40          CMP      r9,#0x40
000022  d178              BNE      |L6.278|
                  |L6.36|
;;;4540     {
;;;4541       sr2itflags   = READ_REG(hi2c->Instance->SR2);
000024  6828              LDR      r0,[r5,#0]
000026  6987              LDR      r7,[r0,#0x18]
;;;4542       sr1itflags   = READ_REG(hi2c->Instance->SR1);
000028  6828              LDR      r0,[r5,#0]
00002a  6944              LDR      r4,[r0,#0x14]
;;;4543   
;;;4544       /* Exit IRQ event until Start Bit detected in case of Other frame requested */
;;;4545       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
00002c  f0040001          AND      r0,r4,#1
000030  b960              CBNZ     r0,|L6.76|
000032  f5b80f2a          CMP      r8,#0xaa0000
000036  d002              BEQ      |L6.62|
000038  f1b84f2a          CMP      r8,#0xaa000000
00003c  d101              BNE      |L6.66|
                  |L6.62|
00003e  2001              MOVS     r0,#1
000040  e000              B        |L6.68|
                  |L6.66|
000042  2000              MOVS     r0,#0
                  |L6.68|
000044  2801              CMP      r0,#1
000046  d101              BNE      |L6.76|
                  |L6.72|
;;;4546       {
;;;4547         return;
;;;4548       }
;;;4549   
;;;4550       /* SB Set ----------------------------------------------------------------*/
;;;4551       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4552       {
;;;4553         /* Convert OTHER_xxx XferOptions if any */
;;;4554         I2C_ConvertOtherXferOptions(hi2c);
;;;4555   
;;;4556         I2C_Master_SB(hi2c);
;;;4557       }
;;;4558       /* ADD10 Set -------------------------------------------------------------*/
;;;4559       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4560       {
;;;4561         I2C_Master_ADD10(hi2c);
;;;4562       }
;;;4563       /* ADDR Set --------------------------------------------------------------*/
;;;4564       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4565       {
;;;4566         I2C_Master_ADDR(hi2c);
;;;4567       }
;;;4568       /* I2C in mode Transmitter -----------------------------------------------*/
;;;4569       else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
;;;4570       {
;;;4571         /* Do not check buffer and BTF flag if a Xfer DMA is on going */
;;;4572         if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
;;;4573         {
;;;4574           /* TXE set and BTF reset -----------------------------------------------*/
;;;4575           if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4576           {
;;;4577             I2C_MasterTransmit_TXE(hi2c);
;;;4578           }
;;;4579           /* BTF set -------------------------------------------------------------*/
;;;4580           else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4581           {
;;;4582             I2C_MasterTransmit_BTF(hi2c);
;;;4583           }
;;;4584           else
;;;4585           {
;;;4586             /* Do nothing */
;;;4587           }
;;;4588         }
;;;4589       }
;;;4590       /* I2C in mode Receiver --------------------------------------------------*/
;;;4591       else
;;;4592       {
;;;4593         /* Do not check buffer and BTF flag if a Xfer DMA is on going */
;;;4594         if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
;;;4595         {
;;;4596           /* RXNE set and BTF reset -----------------------------------------------*/
;;;4597           if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4598           {
;;;4599             I2C_MasterReceive_RXNE(hi2c);
;;;4600           }
;;;4601           /* BTF set -------------------------------------------------------------*/
;;;4602           else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4603           {
;;;4604             I2C_MasterReceive_BTF(hi2c);
;;;4605           }
;;;4606           else
;;;4607           {
;;;4608             /* Do nothing */
;;;4609           }
;;;4610         }
;;;4611       }
;;;4612     }
;;;4613     /* Slave mode selected */
;;;4614     else
;;;4615     {
;;;4616       /* If an error is detected, read only SR1 register to prevent */
;;;4617       /* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */
;;;4618       if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
;;;4619       {
;;;4620         sr1itflags   = READ_REG(hi2c->Instance->SR1);
;;;4621       }
;;;4622       else
;;;4623       {
;;;4624         sr2itflags   = READ_REG(hi2c->Instance->SR2);
;;;4625         sr1itflags   = READ_REG(hi2c->Instance->SR1);
;;;4626       }
;;;4627   
;;;4628       /* ADDR set --------------------------------------------------------------*/
;;;4629       if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4630       {
;;;4631         /* Now time to read SR2, this will clear ADDR flag automatically */
;;;4632         if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
;;;4633         {
;;;4634           sr2itflags   = READ_REG(hi2c->Instance->SR2);
;;;4635         }
;;;4636         I2C_Slave_ADDR(hi2c, sr2itflags);
;;;4637       }
;;;4638       /* STOPF set --------------------------------------------------------------*/
;;;4639       else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4640       {
;;;4641         I2C_Slave_STOPF(hi2c);
;;;4642       }
;;;4643       /* I2C in mode Transmitter -----------------------------------------------*/
;;;4644       else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
;;;4645       {
;;;4646         /* TXE set and BTF reset -----------------------------------------------*/
;;;4647         if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4648         {
;;;4649           I2C_SlaveTransmit_TXE(hi2c);
;;;4650         }
;;;4651         /* BTF set -------------------------------------------------------------*/
;;;4652         else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4653         {
;;;4654           I2C_SlaveTransmit_BTF(hi2c);
;;;4655         }
;;;4656         else
;;;4657         {
;;;4658           /* Do nothing */
;;;4659         }
;;;4660       }
;;;4661       /* I2C in mode Receiver --------------------------------------------------*/
;;;4662       else
;;;4663       {
;;;4664         /* RXNE set and BTF reset ----------------------------------------------*/
;;;4665         if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
;;;4666         {
;;;4667           I2C_SlaveReceive_RXNE(hi2c);
;;;4668         }
;;;4669         /* BTF set -------------------------------------------------------------*/
;;;4670         else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
;;;4671         {
;;;4672           I2C_SlaveReceive_BTF(hi2c);
;;;4673         }
;;;4674         else
;;;4675         {
;;;4676           /* Do nothing */
;;;4677         }
;;;4678       }
;;;4679     }
;;;4680   }
000048  e8bd87f0          POP      {r4-r10,pc}
                  |L6.76|
00004c  f0040001          AND      r0,r4,#1              ;4551
000050  b148              CBZ      r0,|L6.102|
000052  f3c62040          UBFX     r0,r6,#9,#1           ;4551
000056  b130              CBZ      r0,|L6.102|
000058  4628              MOV      r0,r5                 ;4554
00005a  f7fffffe          BL       I2C_ConvertOtherXferOptions
00005e  4628              MOV      r0,r5                 ;4556
000060  f7fffffe          BL       I2C_Master_SB
                  |L6.100|
000064  e0ac              B        |L6.448|
                  |L6.102|
000066  f3c400c0          UBFX     r0,r4,#3,#1           ;4559
00006a  b130              CBZ      r0,|L6.122|
00006c  f3c62040          UBFX     r0,r6,#9,#1           ;4559
000070  b118              CBZ      r0,|L6.122|
000072  4628              MOV      r0,r5                 ;4561
000074  f7fffffe          BL       I2C_Master_ADD10
000078  e0a2              B        |L6.448|
                  |L6.122|
00007a  f3c40040          UBFX     r0,r4,#1,#1           ;4564
00007e  b130              CBZ      r0,|L6.142|
000080  f3c62040          UBFX     r0,r6,#9,#1           ;4564
000084  b118              CBZ      r0,|L6.142|
000086  4628              MOV      r0,r5                 ;4566
000088  f7fffffe          BL       I2C_Master_ADDR
00008c  e098              B        |L6.448|
                  |L6.142|
00008e  f3c70080          UBFX     r0,r7,#2,#1           ;4569
000092  b1f8              CBZ      r0,|L6.212|
000094  6828              LDR      r0,[r5,#0]            ;4572
000096  6840              LDR      r0,[r0,#4]            ;4572
000098  f4006000          AND      r0,r0,#0x800          ;4572
00009c  f5b06f00          CMP      r0,#0x800             ;4572
0000a0  d0e0              BEQ      |L6.100|
0000a2  f3c410c0          UBFX     r0,r4,#7,#1           ;4575
0000a6  b148              CBZ      r0,|L6.188|
0000a8  f3c62080          UBFX     r0,r6,#10,#1          ;4575
0000ac  b130              CBZ      r0,|L6.188|
0000ae  f3c40080          UBFX     r0,r4,#2,#1           ;4575
0000b2  b918              CBNZ     r0,|L6.188|
0000b4  4628              MOV      r0,r5                 ;4577
0000b6  f7fffffe          BL       I2C_MasterTransmit_TXE
0000ba  e081              B        |L6.448|
                  |L6.188|
0000bc  f3c40080          UBFX     r0,r4,#2,#1           ;4580
0000c0  2800              CMP      r0,#0                 ;4580
0000c2  d07d              BEQ      |L6.448|
0000c4  f3c62040          UBFX     r0,r6,#9,#1           ;4580
0000c8  2800              CMP      r0,#0                 ;4580
0000ca  d079              BEQ      |L6.448|
0000cc  4628              MOV      r0,r5                 ;4582
0000ce  f7fffffe          BL       I2C_MasterTransmit_BTF
0000d2  e075              B        |L6.448|
                  |L6.212|
0000d4  6828              LDR      r0,[r5,#0]            ;4594
0000d6  6840              LDR      r0,[r0,#4]            ;4594
0000d8  f4006000          AND      r0,r0,#0x800          ;4594
0000dc  f5b06f00          CMP      r0,#0x800             ;4594
0000e0  d06e              BEQ      |L6.448|
0000e2  f3c41080          UBFX     r0,r4,#6,#1           ;4597
0000e6  b148              CBZ      r0,|L6.252|
0000e8  f3c62080          UBFX     r0,r6,#10,#1          ;4597
0000ec  b130              CBZ      r0,|L6.252|
0000ee  f3c40080          UBFX     r0,r4,#2,#1           ;4597
0000f2  b918              CBNZ     r0,|L6.252|
0000f4  4628              MOV      r0,r5                 ;4599
0000f6  f7fffffe          BL       I2C_MasterReceive_RXNE
0000fa  e061              B        |L6.448|
                  |L6.252|
0000fc  f3c40080          UBFX     r0,r4,#2,#1           ;4602
000100  2800              CMP      r0,#0                 ;4602
000102  d05d              BEQ      |L6.448|
000104  f3c62040          UBFX     r0,r6,#9,#1           ;4602
000108  2800              CMP      r0,#0                 ;4602
00010a  d059              BEQ      |L6.448|
00010c  4628              MOV      r0,r5                 ;4604
00010e  f7fffffe          BL       I2C_MasterReceive_BTF
000112  e055              B        |L6.448|
000114  e7ff              B        |L6.278|
                  |L6.278|
000116  6c28              LDR      r0,[r5,#0x40]         ;4618
000118  b110              CBZ      r0,|L6.288|
00011a  6828              LDR      r0,[r5,#0]            ;4620
00011c  6944              LDR      r4,[r0,#0x14]         ;4620
00011e  e003              B        |L6.296|
                  |L6.288|
000120  6828              LDR      r0,[r5,#0]            ;4624
000122  6987              LDR      r7,[r0,#0x18]         ;4624
000124  6828              LDR      r0,[r5,#0]            ;4625
000126  6944              LDR      r4,[r0,#0x14]         ;4625
                  |L6.296|
000128  f3c40040          UBFX     r0,r4,#1,#1           ;4629
00012c  b158              CBZ      r0,|L6.326|
00012e  f3c62040          UBFX     r0,r6,#9,#1           ;4629
000132  b140              CBZ      r0,|L6.326|
000134  6c28              LDR      r0,[r5,#0x40]         ;4632
000136  b108              CBZ      r0,|L6.316|
000138  6828              LDR      r0,[r5,#0]            ;4634
00013a  6987              LDR      r7,[r0,#0x18]         ;4634
                  |L6.316|
00013c  4639              MOV      r1,r7                 ;4636
00013e  4628              MOV      r0,r5                 ;4636
000140  f7fffffe          BL       I2C_Slave_ADDR
000144  e03c              B        |L6.448|
                  |L6.326|
000146  f3c41000          UBFX     r0,r4,#4,#1           ;4639
00014a  b130              CBZ      r0,|L6.346|
00014c  f3c62040          UBFX     r0,r6,#9,#1           ;4639
000150  b118              CBZ      r0,|L6.346|
000152  4628              MOV      r0,r5                 ;4641
000154  f7fffffe          BL       I2C_Slave_STOPF
000158  e032              B        |L6.448|
                  |L6.346|
00015a  f1ba0f21          CMP      r10,#0x21             ;4644
00015e  d002              BEQ      |L6.358|
000160  f1ba0f29          CMP      r10,#0x29             ;4644
000164  d116              BNE      |L6.404|
                  |L6.358|
000166  f3c410c0          UBFX     r0,r4,#7,#1           ;4647
00016a  b148              CBZ      r0,|L6.384|
00016c  f3c62080          UBFX     r0,r6,#10,#1          ;4647
000170  b130              CBZ      r0,|L6.384|
000172  f3c40080          UBFX     r0,r4,#2,#1           ;4647
000176  b918              CBNZ     r0,|L6.384|
000178  4628              MOV      r0,r5                 ;4649
00017a  f7fffffe          BL       I2C_SlaveTransmit_TXE
00017e  e01f              B        |L6.448|
                  |L6.384|
000180  f3c40080          UBFX     r0,r4,#2,#1           ;4652
000184  b1e0              CBZ      r0,|L6.448|
000186  f3c62040          UBFX     r0,r6,#9,#1           ;4652
00018a  b1c8              CBZ      r0,|L6.448|
00018c  4628              MOV      r0,r5                 ;4654
00018e  f7fffffe          BL       I2C_SlaveTransmit_BTF
000192  e015              B        |L6.448|
                  |L6.404|
000194  f3c41080          UBFX     r0,r4,#6,#1           ;4665
000198  b148              CBZ      r0,|L6.430|
00019a  f3c62080          UBFX     r0,r6,#10,#1          ;4665
00019e  b130              CBZ      r0,|L6.430|
0001a0  f3c40080          UBFX     r0,r4,#2,#1           ;4665
0001a4  b918              CBNZ     r0,|L6.430|
0001a6  4628              MOV      r0,r5                 ;4667
0001a8  f7fffffe          BL       I2C_SlaveReceive_RXNE
0001ac  e008              B        |L6.448|
                  |L6.430|
0001ae  f3c40080          UBFX     r0,r4,#2,#1           ;4670
0001b2  b128              CBZ      r0,|L6.448|
0001b4  f3c62040          UBFX     r0,r6,#9,#1           ;4670
0001b8  b110              CBZ      r0,|L6.448|
0001ba  4628              MOV      r0,r5                 ;4672
0001bc  f7fffffe          BL       I2C_SlaveReceive_BTF
                  |L6.448|
0001c0  bf00              NOP      
0001c2  e741              B        |L6.72|
;;;4681   
                          ENDP


                          AREA ||i.HAL_I2C_EnableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EnableListen_IT PROC
;;;4405     */
;;;4406   HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4407   {
;;;4408     if (hi2c->State == HAL_I2C_STATE_READY)
000002  f891003d          LDRB     r0,[r1,#0x3d]
000006  2820              CMP      r0,#0x20
000008  d11b              BNE      |L7.66|
;;;4409     {
;;;4410       hi2c->State = HAL_I2C_STATE_LISTEN;
00000a  2028              MOVS     r0,#0x28
00000c  f881003d          STRB     r0,[r1,#0x3d]
;;;4411   
;;;4412       /* Check if the I2C is already enabled */
;;;4413       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
000010  6808              LDR      r0,[r1,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0000001          AND      r0,r0,#1
000018  b928              CBNZ     r0,|L7.38|
;;;4414       {
;;;4415         /* Enable I2C peripheral */
;;;4416         __HAL_I2C_ENABLE(hi2c);
00001a  6808              LDR      r0,[r1,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400001          ORR      r0,r0,#1
000022  680a              LDR      r2,[r1,#0]
000024  6010              STR      r0,[r2,#0]
                  |L7.38|
;;;4417       }
;;;4418   
;;;4419       /* Enable Address Acknowledge */
;;;4420       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4406080          ORR      r0,r0,#0x400
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
;;;4421   
;;;4422       /* Enable EVT and ERR interrupt */
;;;4423       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000032  6808              LDR      r0,[r1,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f4407040          ORR      r0,r0,#0x300
00003a  680a              LDR      r2,[r1,#0]
00003c  6050              STR      r0,[r2,#4]
;;;4424   
;;;4425       return HAL_OK;
00003e  2000              MOVS     r0,#0
                  |L7.64|
;;;4426     }
;;;4427     else
;;;4428     {
;;;4429       return HAL_BUSY;
;;;4430     }
;;;4431   }
000040  4770              BX       lr
                  |L7.66|
000042  2002              MOVS     r0,#2                 ;4429
000044  e7fc              B        |L7.64|
;;;4432   
                          ENDP


                          AREA ||i.HAL_I2C_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ErrorCallback PROC
;;;4897     */
;;;4898   __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4899   {
;;;4900     /* Prevent unused argument(s) compilation warning */
;;;4901     UNUSED(hi2c);
;;;4902   
;;;4903     /* NOTE : This function should not be modified, when the callback is needed,
;;;4904               the HAL_I2C_ErrorCallback could be implemented in the user file
;;;4905      */
;;;4906   }
;;;4907   
                          ENDP


                          AREA ||i.HAL_I2C_GetError||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetError PROC
;;;4971     */
;;;4972   uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4973   {
;;;4974     return hi2c->ErrorCode;
000002  6c08              LDR      r0,[r1,#0x40]
;;;4975   }
000004  4770              BX       lr
;;;4976   
                          ENDP


                          AREA ||i.HAL_I2C_GetMode||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetMode PROC
;;;4960     */
;;;4961   HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4962   {
;;;4963     return hi2c->Mode;
000002  f891003e          LDRB     r0,[r1,#0x3e]
;;;4964   }
000006  4770              BX       lr
;;;4965   
                          ENDP


                          AREA ||i.HAL_I2C_GetState||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetState PROC
;;;4948     */
;;;4949   HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;4950   {
;;;4951     /* Return I2C handle state */
;;;4952     return hi2c->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;4953   }
000006  4770              BX       lr
;;;4954   
                          ENDP


                          AREA ||i.HAL_I2C_Init||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Init PROC
;;;430      */
;;;431    HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;432    {
000002  4604              MOV      r4,r0
;;;433      uint32_t freqrange;
;;;434      uint32_t pclk1;
;;;435    
;;;436      /* Check the I2C handle allocation */
;;;437      if (hi2c == NULL)
000004  b90c              CBNZ     r4,|L12.10|
;;;438      {
;;;439        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L12.8|
;;;440      }
;;;441    
;;;442      /* Check the parameters */
;;;443      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;444      assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
;;;445      assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
;;;446      assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
;;;447      assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
;;;448      assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
;;;449      assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
;;;450      assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
;;;451      assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
;;;452    
;;;453      if (hi2c->State == HAL_I2C_STATE_RESET)
;;;454      {
;;;455        /* Allocate lock resource and initialize it */
;;;456        hi2c->Lock = HAL_UNLOCKED;
;;;457    
;;;458    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;459        /* Init the I2C Callback settings */
;;;460        hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
;;;461        hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
;;;462        hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */
;;;463        hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */
;;;464        hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */
;;;465        hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */
;;;466        hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */
;;;467        hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;468        hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;469        hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */
;;;470    
;;;471        if (hi2c->MspInitCallback == NULL)
;;;472        {
;;;473          hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */
;;;474        }
;;;475    
;;;476        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;477        hi2c->MspInitCallback(hi2c);
;;;478    #else
;;;479        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;480        HAL_I2C_MspInit(hi2c);
;;;481    #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;482      }
;;;483    
;;;484      hi2c->State = HAL_I2C_STATE_BUSY;
;;;485    
;;;486      /* Disable the selected I2C peripheral */
;;;487      __HAL_I2C_DISABLE(hi2c);
;;;488    
;;;489      /* Get PCLK1 frequency */
;;;490      pclk1 = HAL_RCC_GetPCLK1Freq();
;;;491    
;;;492      /* Check the minimum allowed PCLK1 frequency */
;;;493      if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
;;;494      {
;;;495        return HAL_ERROR;
;;;496      }
;;;497    
;;;498      /* Calculate frequency range */
;;;499      freqrange = I2C_FREQRANGE(pclk1);
;;;500    
;;;501      /*---------------------------- I2Cx CR2 Configuration ----------------------*/
;;;502      /* Configure I2Cx: Frequency range */
;;;503      MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
;;;504    
;;;505      /*---------------------------- I2Cx TRISE Configuration --------------------*/
;;;506      /* Configure I2Cx: Rise Time */
;;;507      MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
;;;508    
;;;509      /*---------------------------- I2Cx CCR Configuration ----------------------*/
;;;510      /* Configure I2Cx: Speed */
;;;511      MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
;;;512    
;;;513      /*---------------------------- I2Cx CR1 Configuration ----------------------*/
;;;514      /* Configure I2Cx: Generalcall and NoStretch mode */
;;;515      MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
;;;516    
;;;517      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;518      /* Configure I2Cx: Own Address1 and addressing mode */
;;;519      MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
;;;520    
;;;521      /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
;;;522      /* Configure I2Cx: Dual mode and Own Address2 */
;;;523      MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
;;;524    
;;;525      /* Enable the selected I2C peripheral */
;;;526      __HAL_I2C_ENABLE(hi2c);
;;;527    
;;;528      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;529      hi2c->State = HAL_I2C_STATE_READY;
;;;530      hi2c->PreviousState = I2C_STATE_NONE;
;;;531      hi2c->Mode = HAL_I2C_MODE_NONE;
;;;532    
;;;533      return HAL_OK;
;;;534    }
000008  bd70              POP      {r4-r6,pc}
                  |L12.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;453
00000e  b928              CBNZ     r0,|L12.28|
000010  2000              MOVS     r0,#0                 ;456
000012  f884003c          STRB     r0,[r4,#0x3c]         ;456
000016  4620              MOV      r0,r4                 ;480
000018  f7fffffe          BL       HAL_I2C_MspInit
                  |L12.28|
00001c  2024              MOVS     r0,#0x24              ;484
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;484
000022  6820              LDR      r0,[r4,#0]            ;487
000024  6800              LDR      r0,[r0,#0]            ;487
000026  f0200001          BIC      r0,r0,#1              ;487
00002a  6821              LDR      r1,[r4,#0]            ;487
00002c  6008              STR      r0,[r1,#0]            ;487
00002e  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000032  4605              MOV      r5,r0                 ;490
000034  495c              LDR      r1,|L12.424|
000036  6860              LDR      r0,[r4,#4]            ;493
000038  4288              CMP      r0,r1                 ;493
00003a  d806              BHI      |L12.74|
00003c  485b              LDR      r0,|L12.428|
00003e  4285              CMP      r5,r0                 ;493
000040  d201              BCS      |L12.70|
000042  2001              MOVS     r0,#1                 ;493
000044  e007              B        |L12.86|
                  |L12.70|
000046  2000              MOVS     r0,#0                 ;493
000048  e005              B        |L12.86|
                  |L12.74|
00004a  4859              LDR      r0,|L12.432|
00004c  4285              CMP      r5,r0                 ;493
00004e  d201              BCS      |L12.84|
000050  2001              MOVS     r0,#1                 ;493
000052  e000              B        |L12.86|
                  |L12.84|
000054  2000              MOVS     r0,#0                 ;493
                  |L12.86|
000056  2801              CMP      r0,#1                 ;493
000058  d100              BNE      |L12.92|
00005a  e7d5              B        |L12.8|
                  |L12.92|
00005c  4855              LDR      r0,|L12.436|
00005e  fbb5f6f0          UDIV     r6,r5,r0              ;499
000062  6820              LDR      r0,[r4,#0]            ;503
000064  6840              LDR      r0,[r0,#4]            ;503
000066  f020003f          BIC      r0,r0,#0x3f           ;503
00006a  4330              ORRS     r0,r0,r6              ;503
00006c  6821              LDR      r1,[r4,#0]            ;503
00006e  6048              STR      r0,[r1,#4]            ;503
000070  494d              LDR      r1,|L12.424|
000072  6860              LDR      r0,[r4,#4]            ;507
000074  4288              CMP      r0,r1                 ;507
000076  d801              BHI      |L12.124|
000078  1c70              ADDS     r0,r6,#1              ;507
00007a  e007              B        |L12.140|
                  |L12.124|
00007c  f44f7096          MOV      r0,#0x12c             ;507
000080  4370              MULS     r0,r6,r0              ;507
000082  f44f717a          MOV      r1,#0x3e8             ;507
000086  fbb0f0f1          UDIV     r0,r0,r1              ;507
00008a  1c40              ADDS     r0,r0,#1              ;507
                  |L12.140|
00008c  6821              LDR      r1,[r4,#0]            ;507
00008e  6a09              LDR      r1,[r1,#0x20]         ;507
000090  f021013f          BIC      r1,r1,#0x3f           ;507
000094  4308              ORRS     r0,r0,r1              ;507
000096  6821              LDR      r1,[r4,#0]            ;507
000098  6208              STR      r0,[r1,#0x20]         ;507
00009a  4943              LDR      r1,|L12.424|
00009c  6860              LDR      r0,[r4,#4]            ;511
00009e  4288              CMP      r0,r1                 ;511
0000a0  d814              BHI      |L12.204|
0000a2  1e68              SUBS     r0,r5,#1              ;511
0000a4  6861              LDR      r1,[r4,#4]            ;511
0000a6  0049              LSLS     r1,r1,#1              ;511
0000a8  fbb0f0f1          UDIV     r0,r0,r1              ;511
0000ac  1c40              ADDS     r0,r0,#1              ;511
0000ae  f3c0000b          UBFX     r0,r0,#0,#12          ;511
0000b2  2804              CMP      r0,#4                 ;511
0000b4  d201              BCS      |L12.186|
0000b6  2004              MOVS     r0,#4                 ;511
0000b8  e03d              B        |L12.310|
                  |L12.186|
0000ba  1e68              SUBS     r0,r5,#1              ;511
0000bc  6861              LDR      r1,[r4,#4]            ;511
0000be  0049              LSLS     r1,r1,#1              ;511
0000c0  fbb0f0f1          UDIV     r0,r0,r1              ;511
0000c4  1c40              ADDS     r0,r0,#1              ;511
0000c6  f3c0000b          UBFX     r0,r0,#0,#12          ;511
0000ca  e034              B        |L12.310|
                  |L12.204|
0000cc  68a0              LDR      r0,[r4,#8]            ;511
0000ce  b938              CBNZ     r0,|L12.224|
0000d0  1e68              SUBS     r0,r5,#1              ;511
0000d2  6861              LDR      r1,[r4,#4]            ;511
0000d4  eb010141          ADD      r1,r1,r1,LSL #1       ;511
0000d8  fbb0f0f1          UDIV     r0,r0,r1              ;511
0000dc  1c40              ADDS     r0,r0,#1              ;511
0000de  e00a              B        |L12.246|
                  |L12.224|
0000e0  1e68              SUBS     r0,r5,#1              ;511
0000e2  6861              LDR      r1,[r4,#4]            ;511
0000e4  eb0102c1          ADD      r2,r1,r1,LSL #3       ;511
0000e8  eb021101          ADD      r1,r2,r1,LSL #4       ;511
0000ec  fbb0f0f1          UDIV     r0,r0,r1              ;511
0000f0  1c40              ADDS     r0,r0,#1              ;511
0000f2  f4404080          ORR      r0,r0,#0x4000         ;511
                  |L12.246|
0000f6  f3c0000b          UBFX     r0,r0,#0,#12          ;511
0000fa  b908              CBNZ     r0,|L12.256|
0000fc  2001              MOVS     r0,#1                 ;511
0000fe  e01a              B        |L12.310|
                  |L12.256|
000100  68a0              LDR      r0,[r4,#8]            ;511
000102  b948              CBNZ     r0,|L12.280|
000104  1e68              SUBS     r0,r5,#1              ;511
000106  6861              LDR      r1,[r4,#4]            ;511
000108  eb010141          ADD      r1,r1,r1,LSL #1       ;511
00010c  fbb0f0f1          UDIV     r0,r0,r1              ;511
000110  1c40              ADDS     r0,r0,#1              ;511
000112  f3c0000b          UBFX     r0,r0,#0,#12          ;511
000116  e00c              B        |L12.306|
                  |L12.280|
000118  1e68              SUBS     r0,r5,#1              ;511
00011a  6861              LDR      r1,[r4,#4]            ;511
00011c  eb0102c1          ADD      r2,r1,r1,LSL #3       ;511
000120  eb021101          ADD      r1,r2,r1,LSL #4       ;511
000124  fbb0f0f1          UDIV     r0,r0,r1              ;511
000128  1c40              ADDS     r0,r0,#1              ;511
00012a  f3c0000b          UBFX     r0,r0,#0,#12          ;511
00012e  f4404080          ORR      r0,r0,#0x4000         ;511
                  |L12.306|
000132  f4404000          ORR      r0,r0,#0x8000         ;511
                  |L12.310|
000136  6821              LDR      r1,[r4,#0]            ;511
000138  69c9              LDR      r1,[r1,#0x1c]         ;511
00013a  f64c72ff          MOV      r2,#0xcfff            ;511
00013e  4391              BICS     r1,r1,r2              ;511
000140  4308              ORRS     r0,r0,r1              ;511
000142  6821              LDR      r1,[r4,#0]            ;511
000144  61c8              STR      r0,[r1,#0x1c]         ;511
000146  e9d40107          LDRD     r0,r1,[r4,#0x1c]      ;515
00014a  4308              ORRS     r0,r0,r1              ;515
00014c  6821              LDR      r1,[r4,#0]            ;515
00014e  6809              LDR      r1,[r1,#0]            ;515
000150  f02101c0          BIC      r1,r1,#0xc0           ;515
000154  4308              ORRS     r0,r0,r1              ;515
000156  6821              LDR      r1,[r4,#0]            ;515
000158  6008              STR      r0,[r1,#0]            ;515
00015a  e9d41003          LDRD     r1,r0,[r4,#0xc]       ;519
00015e  4308              ORRS     r0,r0,r1              ;519
000160  6821              LDR      r1,[r4,#0]            ;519
000162  6889              LDR      r1,[r1,#8]            ;519
000164  f24832ff          MOV      r2,#0x83ff            ;519
000168  4391              BICS     r1,r1,r2              ;519
00016a  4308              ORRS     r0,r0,r1              ;519
00016c  6821              LDR      r1,[r4,#0]            ;519
00016e  6088              STR      r0,[r1,#8]            ;519
000170  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;523
000174  4308              ORRS     r0,r0,r1              ;523
000176  6821              LDR      r1,[r4,#0]            ;523
000178  68c9              LDR      r1,[r1,#0xc]          ;523
00017a  f02101ff          BIC      r1,r1,#0xff           ;523
00017e  4308              ORRS     r0,r0,r1              ;523
000180  6821              LDR      r1,[r4,#0]            ;523
000182  60c8              STR      r0,[r1,#0xc]          ;523
000184  6820              LDR      r0,[r4,#0]            ;526
000186  6800              LDR      r0,[r0,#0]            ;526
000188  f0400001          ORR      r0,r0,#1              ;526
00018c  6821              LDR      r1,[r4,#0]            ;526
00018e  6008              STR      r0,[r1,#0]            ;526
000190  2000              MOVS     r0,#0                 ;528
000192  6420              STR      r0,[r4,#0x40]         ;528
000194  2020              MOVS     r0,#0x20              ;529
000196  f884003d          STRB     r0,[r4,#0x3d]         ;529
00019a  2000              MOVS     r0,#0                 ;530
00019c  6320              STR      r0,[r4,#0x30]         ;530
00019e  f884003e          STRB     r0,[r4,#0x3e]         ;531
0001a2  bf00              NOP                            ;533
0001a4  e730              B        |L12.8|
;;;535    
                          ENDP

0001a6  0000              DCW      0x0000
                  |L12.424|
                          DCD      0x000186a0
                  |L12.428|
                          DCD      0x001e8480
                  |L12.432|
                          DCD      0x003d0900
                  |L12.436|
                          DCD      0x000f4240

                          AREA ||i.HAL_I2C_IsDeviceReady||, CODE, READONLY, ALIGN=2

                  HAL_I2C_IsDeviceReady PROC
;;;3264     */
;;;3265   HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3266   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;3267     /* Get tick */
;;;3268     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;3269     uint32_t I2C_Trials = 1U;
000012  f04f0901          MOV      r9,#1
;;;3270     FlagStatus tmp1;
;;;3271     FlagStatus tmp2;
;;;3272   
;;;3273     if (hi2c->State == HAL_I2C_STATE_READY)
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2820              CMP      r0,#0x20
00001c  d17e              BNE      |L13.284|
;;;3274     {
;;;3275       /* Wait until BUSY flag is reset */
;;;3276       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001e  2319              MOVS     r3,#0x19
000020  2201              MOVS     r2,#1
000022  495e              LDR      r1,|L13.412|
000024  4620              MOV      r0,r4
000026  9500              STR      r5,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b110              CBZ      r0,|L13.52|
;;;3277       {
;;;3278         return HAL_BUSY;
00002e  2002              MOVS     r0,#2
                  |L13.48|
;;;3279       }
;;;3280   
;;;3281       /* Process Locked */
;;;3282       __HAL_LOCK(hi2c);
;;;3283   
;;;3284       /* Check if the I2C is already enabled */
;;;3285       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3286       {
;;;3287         /* Enable I2C peripheral */
;;;3288         __HAL_I2C_ENABLE(hi2c);
;;;3289       }
;;;3290   
;;;3291       /* Disable Pos */
;;;3292       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3293   
;;;3294       hi2c->State = HAL_I2C_STATE_BUSY;
;;;3295       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3296       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3297   
;;;3298       do
;;;3299       {
;;;3300         /* Generate Start */
;;;3301         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3302   
;;;3303         /* Wait until SB flag is set */
;;;3304         if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
;;;3305         {
;;;3306           return HAL_ERROR;
;;;3307         }
;;;3308   
;;;3309         /* Send slave address */
;;;3310         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;3311   
;;;3312         /* Wait until ADDR or AF flag are set */
;;;3313         /* Get tick */
;;;3314         tickstart = HAL_GetTick();
;;;3315   
;;;3316         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3317         tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3318         while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
;;;3319         {
;;;3320           if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;3321           {
;;;3322             hi2c->State = HAL_I2C_STATE_TIMEOUT;
;;;3323           }
;;;3324           tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3325           tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3326         }
;;;3327   
;;;3328         hi2c->State = HAL_I2C_STATE_READY;
;;;3329   
;;;3330         /* Check if the ADDR flag has been set */
;;;3331         if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
;;;3332         {
;;;3333           /* Generate Stop */
;;;3334           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3335   
;;;3336           /* Clear ADDR Flag */
;;;3337           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3338   
;;;3339           /* Wait until BUSY flag is reset */
;;;3340           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3341           {
;;;3342             return HAL_ERROR;
;;;3343           }
;;;3344   
;;;3345           hi2c->State = HAL_I2C_STATE_READY;
;;;3346   
;;;3347           /* Process Unlocked */
;;;3348           __HAL_UNLOCK(hi2c);
;;;3349   
;;;3350           return HAL_OK;
;;;3351         }
;;;3352         else
;;;3353         {
;;;3354           /* Generate Stop */
;;;3355           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3356   
;;;3357           /* Clear AF Flag */
;;;3358           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3359   
;;;3360           /* Wait until BUSY flag is reset */
;;;3361           if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3362           {
;;;3363             return HAL_ERROR;
;;;3364           }
;;;3365         }
;;;3366   
;;;3367         /* Increment Trials */
;;;3368         I2C_Trials++;
;;;3369       }
;;;3370       while (I2C_Trials < Trials);
;;;3371   
;;;3372       hi2c->State = HAL_I2C_STATE_READY;
;;;3373   
;;;3374       /* Process Unlocked */
;;;3375       __HAL_UNLOCK(hi2c);
;;;3376   
;;;3377       return HAL_ERROR;
;;;3378     }
;;;3379     else
;;;3380     {
;;;3381       return HAL_BUSY;
;;;3382     }
;;;3383   }
000030  e8bd8ff8          POP      {r3-r11,pc}
                  |L13.52|
000034  bf00              NOP                            ;3282
000036  f894003c          LDRB     r0,[r4,#0x3c]         ;3282
00003a  2801              CMP      r0,#1                 ;3282
00003c  d101              BNE      |L13.66|
00003e  2002              MOVS     r0,#2                 ;3282
000040  e7f6              B        |L13.48|
                  |L13.66|
000042  2001              MOVS     r0,#1                 ;3282
000044  f884003c          STRB     r0,[r4,#0x3c]         ;3282
000048  bf00              NOP                            ;3282
00004a  6820              LDR      r0,[r4,#0]            ;3285
00004c  6800              LDR      r0,[r0,#0]            ;3285
00004e  f0000001          AND      r0,r0,#1              ;3285
000052  b928              CBNZ     r0,|L13.96|
000054  6820              LDR      r0,[r4,#0]            ;3288
000056  6800              LDR      r0,[r0,#0]            ;3288
000058  f0400001          ORR      r0,r0,#1              ;3288
00005c  6821              LDR      r1,[r4,#0]            ;3288
00005e  6008              STR      r0,[r1,#0]            ;3288
                  |L13.96|
000060  6820              LDR      r0,[r4,#0]            ;3292
000062  6800              LDR      r0,[r0,#0]            ;3292
000064  f4206000          BIC      r0,r0,#0x800          ;3292
000068  6821              LDR      r1,[r4,#0]            ;3292
00006a  6008              STR      r0,[r1,#0]            ;3292
00006c  2024              MOVS     r0,#0x24              ;3294
00006e  f884003d          STRB     r0,[r4,#0x3d]         ;3294
000072  2000              MOVS     r0,#0                 ;3295
000074  6420              STR      r0,[r4,#0x40]         ;3295
000076  484a              LDR      r0,|L13.416|
000078  62e0              STR      r0,[r4,#0x2c]         ;3296
00007a  bf00              NOP                            ;3298
                  |L13.124|
00007c  6820              LDR      r0,[r4,#0]            ;3301
00007e  6800              LDR      r0,[r0,#0]            ;3301
000080  f4407080          ORR      r0,r0,#0x100          ;3301
000084  6821              LDR      r1,[r4,#0]            ;3301
000086  6008              STR      r0,[r1,#0]            ;3301
000088  4633              MOV      r3,r6                 ;3304
00008a  2200              MOVS     r2,#0                 ;3304
00008c  f04f1101          MOV      r1,#0x10001           ;3304
000090  4620              MOV      r0,r4                 ;3304
000092  9500              STR      r5,[sp,#0]            ;3304
000094  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000098  b108              CBZ      r0,|L13.158|
00009a  2001              MOVS     r0,#1                 ;3306
00009c  e7c8              B        |L13.48|
                  |L13.158|
00009e  f00700fe          AND      r0,r7,#0xfe           ;3310
0000a2  6821              LDR      r1,[r4,#0]            ;3310
0000a4  6108              STR      r0,[r1,#0x10]         ;3310
0000a6  f7fffffe          BL       HAL_GetTick
0000aa  4605              MOV      r5,r0                 ;3314
0000ac  6820              LDR      r0,[r4,#0]            ;3316
0000ae  6940              LDR      r0,[r0,#0x14]         ;3316
0000b0  f3c00a40          UBFX     r10,r0,#1,#1          ;3316
0000b4  6820              LDR      r0,[r4,#0]            ;3317
0000b6  6940              LDR      r0,[r0,#0x14]         ;3317
0000b8  f3c02b80          UBFX     r11,r0,#10,#1         ;3317
0000bc  e010              B        |L13.224|
                  |L13.190|
0000be  f7fffffe          BL       HAL_GetTick
0000c2  1b40              SUBS     r0,r0,r5              ;3320
0000c4  42b0              CMP      r0,r6                 ;3320
0000c6  d800              BHI      |L13.202|
0000c8  b916              CBNZ     r6,|L13.208|
                  |L13.202|
0000ca  20a0              MOVS     r0,#0xa0              ;3322
0000cc  f884003d          STRB     r0,[r4,#0x3d]         ;3322
                  |L13.208|
0000d0  6820              LDR      r0,[r4,#0]            ;3324
0000d2  6940              LDR      r0,[r0,#0x14]         ;3324
0000d4  f3c00a40          UBFX     r10,r0,#1,#1          ;3324
0000d8  6820              LDR      r0,[r4,#0]            ;3325
0000da  6940              LDR      r0,[r0,#0x14]         ;3325
0000dc  f3c02b80          UBFX     r11,r0,#10,#1         ;3325
                  |L13.224|
0000e0  f894003d          LDRB     r0,[r4,#0x3d]         ;3318
0000e4  28a0              CMP      r0,#0xa0              ;3318
0000e6  d005              BEQ      |L13.244|
0000e8  f1ba0f00          CMP      r10,#0                ;3318
0000ec  d102              BNE      |L13.244|
0000ee  f1bb0f00          CMP      r11,#0                ;3318
0000f2  d0e4              BEQ      |L13.190|
                  |L13.244|
0000f4  2020              MOVS     r0,#0x20              ;3328
0000f6  f884003d          STRB     r0,[r4,#0x3d]         ;3328
0000fa  6820              LDR      r0,[r4,#0]            ;3331
0000fc  6940              LDR      r0,[r0,#0x14]         ;3331
0000fe  f3c00040          UBFX     r0,r0,#1,#1           ;3331
000102  b328              CBZ      r0,|L13.336|
000104  6820              LDR      r0,[r4,#0]            ;3334
000106  6800              LDR      r0,[r0,#0]            ;3334
000108  f4407000          ORR      r0,r0,#0x200          ;3334
00010c  6821              LDR      r1,[r4,#0]            ;3334
00010e  6008              STR      r0,[r1,#0]            ;3334
000110  bf00              NOP                            ;3337
000112  2000              MOVS     r0,#0                 ;3337
000114  9000              STR      r0,[sp,#0]            ;3337
000116  6820              LDR      r0,[r4,#0]            ;3337
000118  6940              LDR      r0,[r0,#0x14]         ;3337
00011a  e000              B        |L13.286|
                  |L13.284|
00011c  e03b              B        |L13.406|
                  |L13.286|
00011e  9000              STR      r0,[sp,#0]            ;3337
000120  6820              LDR      r0,[r4,#0]            ;3337
000122  6980              LDR      r0,[r0,#0x18]         ;3337
000124  9000              STR      r0,[sp,#0]            ;3337
000126  bf00              NOP                            ;3337
000128  bf00              NOP                            ;3337
00012a  2319              MOVS     r3,#0x19              ;3340
00012c  2201              MOVS     r2,#1                 ;3340
00012e  491b              LDR      r1,|L13.412|
000130  4620              MOV      r0,r4                 ;3340
000132  9500              STR      r5,[sp,#0]            ;3340
000134  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000138  b108              CBZ      r0,|L13.318|
00013a  2001              MOVS     r0,#1                 ;3342
00013c  e778              B        |L13.48|
                  |L13.318|
00013e  2020              MOVS     r0,#0x20              ;3345
000140  f884003d          STRB     r0,[r4,#0x3d]         ;3345
000144  bf00              NOP                            ;3348
000146  2000              MOVS     r0,#0                 ;3348
000148  f884003c          STRB     r0,[r4,#0x3c]         ;3348
00014c  bf00              NOP                            ;3348
00014e  e76f              B        |L13.48|
                  |L13.336|
000150  6820              LDR      r0,[r4,#0]            ;3355
000152  6800              LDR      r0,[r0,#0]            ;3355
000154  f4407000          ORR      r0,r0,#0x200          ;3355
000158  6821              LDR      r1,[r4,#0]            ;3355
00015a  6008              STR      r0,[r1,#0]            ;3355
00015c  f46f6080          MVN      r0,#0x400             ;3358
000160  6821              LDR      r1,[r4,#0]            ;3358
000162  6148              STR      r0,[r1,#0x14]         ;3358
000164  2319              MOVS     r3,#0x19              ;3361
000166  2201              MOVS     r2,#1                 ;3361
000168  490c              LDR      r1,|L13.412|
00016a  4620              MOV      r0,r4                 ;3361
00016c  9500              STR      r5,[sp,#0]            ;3361
00016e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000172  b108              CBZ      r0,|L13.376|
000174  2001              MOVS     r0,#1                 ;3363
000176  e75b              B        |L13.48|
                  |L13.376|
000178  f1090901          ADD      r9,r9,#1              ;3368
00017c  45c1              CMP      r9,r8                 ;3370
00017e  f4ffaf7d          BCC      |L13.124|
000182  2020              MOVS     r0,#0x20              ;3372
000184  f884003d          STRB     r0,[r4,#0x3d]         ;3372
000188  bf00              NOP                            ;3375
00018a  2000              MOVS     r0,#0                 ;3375
00018c  f884003c          STRB     r0,[r4,#0x3c]         ;3375
000190  bf00              NOP                            ;3375
000192  2001              MOVS     r0,#1                 ;3377
000194  e74c              B        |L13.48|
                  |L13.406|
000196  2002              MOVS     r0,#2                 ;3381
000198  e74a              B        |L13.48|
;;;3384   
                          ENDP

00019a  0000              DCW      0x0000
                  |L13.412|
                          DCD      0x00100002
                  |L13.416|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_ListenCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ListenCpltCallback PROC
;;;4849     */
;;;4850   __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4851   {
;;;4852     /* Prevent unused argument(s) compilation warning */
;;;4853     UNUSED(hi2c);
;;;4854   
;;;4855     /* NOTE : This function should not be modified, when the callback is needed,
;;;4856               the HAL_I2C_ListenCpltCallback() could be implemented in the user file
;;;4857     */
;;;4858   }
;;;4859   
                          ENDP


                          AREA ||i.HAL_I2C_MasterRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterRxCpltCallback PROC
;;;4782     */
;;;4783   __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4784   {
;;;4785     /* Prevent unused argument(s) compilation warning */
;;;4786     UNUSED(hi2c);
;;;4787   
;;;4788     /* NOTE : This function should not be modified, when the callback is needed,
;;;4789               the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
;;;4790      */
;;;4791   }
;;;4792   
                          ENDP


                          AREA ||i.HAL_I2C_MasterTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterTxCpltCallback PROC
;;;4766     */
;;;4767   __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4768   {
;;;4769     /* Prevent unused argument(s) compilation warning */
;;;4770     UNUSED(hi2c);
;;;4771   
;;;4772     /* NOTE : This function should not be modified, when the callback is needed,
;;;4773               the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
;;;4774      */
;;;4775   }
;;;4776   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Master_Abort_IT PROC
;;;4473     */
;;;4474   HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
000000  b570              PUSH     {r4-r6,lr}
;;;4475   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4476     /* Prevent unused argument(s) compilation warning */
;;;4477     UNUSED(DevAddress);
;;;4478   
;;;4479     /* Abort Master transfer during Receive or Transmit process    */
;;;4480     if (hi2c->Mode == HAL_I2C_MODE_MASTER)
000006  f894003e          LDRB     r0,[r4,#0x3e]
00000a  2810              CMP      r0,#0x10
00000c  d12d              BNE      |L17.106|
;;;4481     {
;;;4482       /* Process Locked */
;;;4483       __HAL_LOCK(hi2c);
00000e  bf00              NOP      
000010  f894003c          LDRB     r0,[r4,#0x3c]
000014  2801              CMP      r0,#1
000016  d101              BNE      |L17.28|
000018  2002              MOVS     r0,#2
                  |L17.26|
;;;4484   
;;;4485       hi2c->PreviousState = I2C_STATE_NONE;
;;;4486       hi2c->State = HAL_I2C_STATE_ABORT;
;;;4487   
;;;4488       /* Disable Acknowledge */
;;;4489       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4490   
;;;4491       /* Generate Stop */
;;;4492       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;4493   
;;;4494       hi2c->XferCount = 0U;
;;;4495   
;;;4496       /* Disable EVT, BUF and ERR interrupt */
;;;4497       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4498   
;;;4499       /* Process Unlocked */
;;;4500       __HAL_UNLOCK(hi2c);
;;;4501   
;;;4502       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4503       I2C_ITError(hi2c);
;;;4504   
;;;4505       return HAL_OK;
;;;4506     }
;;;4507     else
;;;4508     {
;;;4509       /* Wrong usage of abort function */
;;;4510       /* This function should be used only in case of abort monitored by master device */
;;;4511       return HAL_ERROR;
;;;4512     }
;;;4513   }
00001a  bd70              POP      {r4-r6,pc}
                  |L17.28|
00001c  2001              MOVS     r0,#1                 ;4483
00001e  f884003c          STRB     r0,[r4,#0x3c]         ;4483
000022  bf00              NOP                            ;4483
000024  2000              MOVS     r0,#0                 ;4485
000026  6320              STR      r0,[r4,#0x30]         ;4485
000028  2060              MOVS     r0,#0x60              ;4486
00002a  f884003d          STRB     r0,[r4,#0x3d]         ;4486
00002e  6820              LDR      r0,[r4,#0]            ;4489
000030  6800              LDR      r0,[r0,#0]            ;4489
000032  f4206080          BIC      r0,r0,#0x400          ;4489
000036  6821              LDR      r1,[r4,#0]            ;4489
000038  6008              STR      r0,[r1,#0]            ;4489
00003a  6820              LDR      r0,[r4,#0]            ;4492
00003c  6800              LDR      r0,[r0,#0]            ;4492
00003e  f4407000          ORR      r0,r0,#0x200          ;4492
000042  6821              LDR      r1,[r4,#0]            ;4492
000044  6008              STR      r0,[r1,#0]            ;4492
000046  2000              MOVS     r0,#0                 ;4494
000048  8560              STRH     r0,[r4,#0x2a]         ;4494
00004a  6820              LDR      r0,[r4,#0]            ;4497
00004c  6840              LDR      r0,[r0,#4]            ;4497
00004e  f42060e0          BIC      r0,r0,#0x700          ;4497
000052  6821              LDR      r1,[r4,#0]            ;4497
000054  6048              STR      r0,[r1,#4]            ;4497
000056  bf00              NOP                            ;4500
000058  2000              MOVS     r0,#0                 ;4500
00005a  f884003c          STRB     r0,[r4,#0x3c]         ;4500
00005e  bf00              NOP                            ;4500
000060  4620              MOV      r0,r4                 ;4503
000062  f7fffffe          BL       I2C_ITError
000066  2000              MOVS     r0,#0                 ;4505
000068  e7d7              B        |L17.26|
                  |L17.106|
00006a  2001              MOVS     r0,#1                 ;4511
00006c  e7d5              B        |L17.26|
;;;4514   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive PROC
;;;1144     */
;;;1145   HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1146   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e08              LDR      r6,[sp,#0x20]
;;;1147     /* Init tickstart for timeout management*/
;;;1148     uint32_t tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;1149   
;;;1150     if (hi2c->State == HAL_I2C_STATE_READY)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2820              CMP      r0,#0x20
00001a  d17d              BNE      |L18.280|
;;;1151     {
;;;1152       /* Wait until BUSY flag is reset */
;;;1153       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001c  2319              MOVS     r3,#0x19
00001e  2201              MOVS     r2,#1
000020  49b2              LDR      r1,|L18.748|
000022  4620              MOV      r0,r4
000024  9500              STR      r5,[sp,#0]
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  b110              CBZ      r0,|L18.50|
;;;1154       {
;;;1155         return HAL_BUSY;
00002c  2002              MOVS     r0,#2
                  |L18.46|
;;;1156       }
;;;1157   
;;;1158       /* Process Locked */
;;;1159       __HAL_LOCK(hi2c);
;;;1160   
;;;1161       /* Check if the I2C is already enabled */
;;;1162       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1163       {
;;;1164         /* Enable I2C peripheral */
;;;1165         __HAL_I2C_ENABLE(hi2c);
;;;1166       }
;;;1167   
;;;1168       /* Disable Pos */
;;;1169       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1170   
;;;1171       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1172       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1173       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1174   
;;;1175       /* Prepare transfer parameters */
;;;1176       hi2c->pBuffPtr    = pData;
;;;1177       hi2c->XferCount   = Size;
;;;1178       hi2c->XferSize    = hi2c->XferCount;
;;;1179       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1180   
;;;1181       /* Send Slave Address */
;;;1182       if (I2C_MasterRequestRead(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
;;;1183       {
;;;1184         return HAL_ERROR;
;;;1185       }
;;;1186   
;;;1187       if (hi2c->XferSize == 0U)
;;;1188       {
;;;1189         /* Clear ADDR flag */
;;;1190         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1191   
;;;1192         /* Generate Stop */
;;;1193         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1194       }
;;;1195       else if (hi2c->XferSize == 1U)
;;;1196       {
;;;1197         /* Disable Acknowledge */
;;;1198         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1199   
;;;1200         /* Clear ADDR flag */
;;;1201         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1202   
;;;1203         /* Generate Stop */
;;;1204         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1205       }
;;;1206       else if (hi2c->XferSize == 2U)
;;;1207       {
;;;1208         /* Disable Acknowledge */
;;;1209         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1210   
;;;1211         /* Enable Pos */
;;;1212         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1213   
;;;1214         /* Clear ADDR flag */
;;;1215         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1216       }
;;;1217       else
;;;1218       {
;;;1219         /* Enable Acknowledge */
;;;1220         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1221   
;;;1222         /* Clear ADDR flag */
;;;1223         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1224       }
;;;1225   
;;;1226       while (hi2c->XferSize > 0U)
;;;1227       {
;;;1228         if (hi2c->XferSize <= 3U)
;;;1229         {
;;;1230           /* One byte */
;;;1231           if (hi2c->XferSize == 1U)
;;;1232           {
;;;1233             /* Wait until RXNE flag is set */
;;;1234             if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1235             {
;;;1236               return HAL_ERROR;
;;;1237             }
;;;1238   
;;;1239             /* Read data from DR */
;;;1240             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1241   
;;;1242             /* Increment Buffer pointer */
;;;1243             hi2c->pBuffPtr++;
;;;1244   
;;;1245             /* Update counter */
;;;1246             hi2c->XferSize--;
;;;1247             hi2c->XferCount--;
;;;1248           }
;;;1249           /* Two bytes */
;;;1250           else if (hi2c->XferSize == 2U)
;;;1251           {
;;;1252             /* Wait until BTF flag is set */
;;;1253             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1254             {
;;;1255               return HAL_ERROR;
;;;1256             }
;;;1257   
;;;1258             /* Generate Stop */
;;;1259             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1260   
;;;1261             /* Read data from DR */
;;;1262             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1263   
;;;1264             /* Increment Buffer pointer */
;;;1265             hi2c->pBuffPtr++;
;;;1266   
;;;1267             /* Update counter */
;;;1268             hi2c->XferSize--;
;;;1269             hi2c->XferCount--;
;;;1270   
;;;1271             /* Read data from DR */
;;;1272             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1273   
;;;1274             /* Increment Buffer pointer */
;;;1275             hi2c->pBuffPtr++;
;;;1276   
;;;1277             /* Update counter */
;;;1278             hi2c->XferSize--;
;;;1279             hi2c->XferCount--;
;;;1280           }
;;;1281           /* 3 Last bytes */
;;;1282           else
;;;1283           {
;;;1284             /* Wait until BTF flag is set */
;;;1285             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1286             {
;;;1287               return HAL_ERROR;
;;;1288             }
;;;1289   
;;;1290             /* Disable Acknowledge */
;;;1291             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1292   
;;;1293             /* Read data from DR */
;;;1294             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1295   
;;;1296             /* Increment Buffer pointer */
;;;1297             hi2c->pBuffPtr++;
;;;1298   
;;;1299             /* Update counter */
;;;1300             hi2c->XferSize--;
;;;1301             hi2c->XferCount--;
;;;1302   
;;;1303             /* Wait until BTF flag is set */
;;;1304             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;1305             {
;;;1306               return HAL_ERROR;
;;;1307             }
;;;1308   
;;;1309             /* Generate Stop */
;;;1310             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1311   
;;;1312             /* Read data from DR */
;;;1313             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1314   
;;;1315             /* Increment Buffer pointer */
;;;1316             hi2c->pBuffPtr++;
;;;1317   
;;;1318             /* Update counter */
;;;1319             hi2c->XferSize--;
;;;1320             hi2c->XferCount--;
;;;1321   
;;;1322             /* Read data from DR */
;;;1323             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1324   
;;;1325             /* Increment Buffer pointer */
;;;1326             hi2c->pBuffPtr++;
;;;1327   
;;;1328             /* Update counter */
;;;1329             hi2c->XferSize--;
;;;1330             hi2c->XferCount--;
;;;1331           }
;;;1332         }
;;;1333         else
;;;1334         {
;;;1335           /* Wait until RXNE flag is set */
;;;1336           if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1337           {
;;;1338             return HAL_ERROR;
;;;1339           }
;;;1340   
;;;1341           /* Read data from DR */
;;;1342           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1343   
;;;1344           /* Increment Buffer pointer */
;;;1345           hi2c->pBuffPtr++;
;;;1346   
;;;1347           /* Update counter */
;;;1348           hi2c->XferSize--;
;;;1349           hi2c->XferCount--;
;;;1350   
;;;1351           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;1352           {
;;;1353             /* Read data from DR */
;;;1354             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1355   
;;;1356             /* Increment Buffer pointer */
;;;1357             hi2c->pBuffPtr++;
;;;1358   
;;;1359             /* Update counter */
;;;1360             hi2c->XferSize--;
;;;1361             hi2c->XferCount--;
;;;1362           }
;;;1363         }
;;;1364       }
;;;1365   
;;;1366       hi2c->State = HAL_I2C_STATE_READY;
;;;1367       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1368   
;;;1369       /* Process Unlocked */
;;;1370       __HAL_UNLOCK(hi2c);
;;;1371   
;;;1372       return HAL_OK;
;;;1373     }
;;;1374     else
;;;1375     {
;;;1376       return HAL_BUSY;
;;;1377     }
;;;1378   }
00002e  e8bd83f8          POP      {r3-r9,pc}
                  |L18.50|
000032  bf00              NOP                            ;1159
000034  f894003c          LDRB     r0,[r4,#0x3c]         ;1159
000038  2801              CMP      r0,#1                 ;1159
00003a  d101              BNE      |L18.64|
00003c  2002              MOVS     r0,#2                 ;1159
00003e  e7f6              B        |L18.46|
                  |L18.64|
000040  2001              MOVS     r0,#1                 ;1159
000042  f884003c          STRB     r0,[r4,#0x3c]         ;1159
000046  bf00              NOP                            ;1159
000048  6820              LDR      r0,[r4,#0]            ;1162
00004a  6800              LDR      r0,[r0,#0]            ;1162
00004c  f0000001          AND      r0,r0,#1              ;1162
000050  b928              CBNZ     r0,|L18.94|
000052  6820              LDR      r0,[r4,#0]            ;1165
000054  6800              LDR      r0,[r0,#0]            ;1165
000056  f0400001          ORR      r0,r0,#1              ;1165
00005a  6821              LDR      r1,[r4,#0]            ;1165
00005c  6008              STR      r0,[r1,#0]            ;1165
                  |L18.94|
00005e  6820              LDR      r0,[r4,#0]            ;1169
000060  6800              LDR      r0,[r0,#0]            ;1169
000062  f4206000          BIC      r0,r0,#0x800          ;1169
000066  6821              LDR      r1,[r4,#0]            ;1169
000068  6008              STR      r0,[r1,#0]            ;1169
00006a  2022              MOVS     r0,#0x22              ;1171
00006c  f884003d          STRB     r0,[r4,#0x3d]         ;1171
000070  2010              MOVS     r0,#0x10              ;1172
000072  f884003e          STRB     r0,[r4,#0x3e]         ;1172
000076  2000              MOVS     r0,#0                 ;1173
000078  6420              STR      r0,[r4,#0x40]         ;1173
00007a  6267              STR      r7,[r4,#0x24]         ;1176
00007c  f8a4802a          STRH     r8,[r4,#0x2a]         ;1177
000080  8d60              LDRH     r0,[r4,#0x2a]         ;1178
000082  8520              STRH     r0,[r4,#0x28]         ;1178
000084  489a              LDR      r0,|L18.752|
000086  62e0              STR      r0,[r4,#0x2c]         ;1179
000088  462b              MOV      r3,r5                 ;1182
00008a  4632              MOV      r2,r6                 ;1182
00008c  4649              MOV      r1,r9                 ;1182
00008e  4620              MOV      r0,r4                 ;1182
000090  f7fffffe          BL       I2C_MasterRequestRead
000094  b108              CBZ      r0,|L18.154|
000096  2001              MOVS     r0,#1                 ;1184
000098  e7c9              B        |L18.46|
                  |L18.154|
00009a  8d20              LDRH     r0,[r4,#0x28]         ;1187
00009c  b988              CBNZ     r0,|L18.194|
00009e  bf00              NOP                            ;1190
0000a0  2000              MOVS     r0,#0                 ;1190
0000a2  9000              STR      r0,[sp,#0]            ;1190
0000a4  6820              LDR      r0,[r4,#0]            ;1190
0000a6  6940              LDR      r0,[r0,#0x14]         ;1190
0000a8  9000              STR      r0,[sp,#0]            ;1190
0000aa  6820              LDR      r0,[r4,#0]            ;1190
0000ac  6980              LDR      r0,[r0,#0x18]         ;1190
0000ae  9000              STR      r0,[sp,#0]            ;1190
0000b0  bf00              NOP                            ;1190
0000b2  bf00              NOP                            ;1190
0000b4  6820              LDR      r0,[r4,#0]            ;1193
0000b6  6800              LDR      r0,[r0,#0]            ;1193
0000b8  f4407000          ORR      r0,r0,#0x200          ;1193
0000bc  6821              LDR      r1,[r4,#0]            ;1193
0000be  6008              STR      r0,[r1,#0]            ;1193
0000c0  e047              B        |L18.338|
                  |L18.194|
0000c2  8d20              LDRH     r0,[r4,#0x28]         ;1195
0000c4  2801              CMP      r0,#1                 ;1195
0000c6  d117              BNE      |L18.248|
0000c8  6820              LDR      r0,[r4,#0]            ;1198
0000ca  6800              LDR      r0,[r0,#0]            ;1198
0000cc  f4206080          BIC      r0,r0,#0x400          ;1198
0000d0  6821              LDR      r1,[r4,#0]            ;1198
0000d2  6008              STR      r0,[r1,#0]            ;1198
0000d4  bf00              NOP                            ;1201
0000d6  2000              MOVS     r0,#0                 ;1201
0000d8  9000              STR      r0,[sp,#0]            ;1201
0000da  6820              LDR      r0,[r4,#0]            ;1201
0000dc  6940              LDR      r0,[r0,#0x14]         ;1201
0000de  9000              STR      r0,[sp,#0]            ;1201
0000e0  6820              LDR      r0,[r4,#0]            ;1201
0000e2  6980              LDR      r0,[r0,#0x18]         ;1201
0000e4  9000              STR      r0,[sp,#0]            ;1201
0000e6  bf00              NOP                            ;1201
0000e8  bf00              NOP                            ;1201
0000ea  6820              LDR      r0,[r4,#0]            ;1204
0000ec  6800              LDR      r0,[r0,#0]            ;1204
0000ee  f4407000          ORR      r0,r0,#0x200          ;1204
0000f2  6821              LDR      r1,[r4,#0]            ;1204
0000f4  6008              STR      r0,[r1,#0]            ;1204
0000f6  e02c              B        |L18.338|
                  |L18.248|
0000f8  8d20              LDRH     r0,[r4,#0x28]         ;1206
0000fa  2802              CMP      r0,#2                 ;1206
0000fc  d118              BNE      |L18.304|
0000fe  6820              LDR      r0,[r4,#0]            ;1209
000100  6800              LDR      r0,[r0,#0]            ;1209
000102  f4206080          BIC      r0,r0,#0x400          ;1209
000106  6821              LDR      r1,[r4,#0]            ;1209
000108  6008              STR      r0,[r1,#0]            ;1209
00010a  6820              LDR      r0,[r4,#0]            ;1212
00010c  6800              LDR      r0,[r0,#0]            ;1212
00010e  f4406000          ORR      r0,r0,#0x800          ;1212
000112  6821              LDR      r1,[r4,#0]            ;1212
000114  6008              STR      r0,[r1,#0]            ;1212
000116  e000              B        |L18.282|
                  |L18.280|
000118  e0e6              B        |L18.744|
                  |L18.282|
00011a  bf00              NOP                            ;1215
00011c  2000              MOVS     r0,#0                 ;1215
00011e  9000              STR      r0,[sp,#0]            ;1215
000120  6820              LDR      r0,[r4,#0]            ;1215
000122  6940              LDR      r0,[r0,#0x14]         ;1215
000124  9000              STR      r0,[sp,#0]            ;1215
000126  6820              LDR      r0,[r4,#0]            ;1215
000128  6980              LDR      r0,[r0,#0x18]         ;1215
00012a  9000              STR      r0,[sp,#0]            ;1215
00012c  bf00              NOP                            ;1215
00012e  e010              B        |L18.338|
                  |L18.304|
000130  6820              LDR      r0,[r4,#0]            ;1220
000132  6800              LDR      r0,[r0,#0]            ;1220
000134  f4406080          ORR      r0,r0,#0x400          ;1220
000138  6821              LDR      r1,[r4,#0]            ;1220
00013a  6008              STR      r0,[r1,#0]            ;1220
00013c  bf00              NOP                            ;1223
00013e  2000              MOVS     r0,#0                 ;1223
000140  9000              STR      r0,[sp,#0]            ;1223
000142  6820              LDR      r0,[r4,#0]            ;1223
000144  6940              LDR      r0,[r0,#0x14]         ;1223
000146  9000              STR      r0,[sp,#0]            ;1223
000148  6820              LDR      r0,[r4,#0]            ;1223
00014a  6980              LDR      r0,[r0,#0x18]         ;1223
00014c  9000              STR      r0,[sp,#0]            ;1223
00014e  bf00              NOP                            ;1223
000150  bf00              NOP                            ;1223
                  |L18.338|
000152  e0ba              B        |L18.714|
                  |L18.340|
000154  8d20              LDRH     r0,[r4,#0x28]         ;1228
000156  2803              CMP      r0,#3                 ;1228
000158  d87e              BHI      |L18.600|
00015a  8d20              LDRH     r0,[r4,#0x28]         ;1231
00015c  2801              CMP      r0,#1                 ;1231
00015e  d115              BNE      |L18.396|
000160  462a              MOV      r2,r5                 ;1234
000162  4631              MOV      r1,r6                 ;1234
000164  4620              MOV      r0,r4                 ;1234
000166  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
00016a  b108              CBZ      r0,|L18.368|
00016c  2001              MOVS     r0,#1                 ;1236
00016e  e75e              B        |L18.46|
                  |L18.368|
000170  6820              LDR      r0,[r4,#0]            ;1240
000172  6900              LDR      r0,[r0,#0x10]         ;1240
000174  6a61              LDR      r1,[r4,#0x24]         ;1240
000176  7008              STRB     r0,[r1,#0]            ;1240
000178  6a60              LDR      r0,[r4,#0x24]         ;1243
00017a  1c40              ADDS     r0,r0,#1              ;1243
00017c  6260              STR      r0,[r4,#0x24]         ;1243
00017e  8d20              LDRH     r0,[r4,#0x28]         ;1246
000180  1e40              SUBS     r0,r0,#1              ;1246
000182  8520              STRH     r0,[r4,#0x28]         ;1246
000184  8d60              LDRH     r0,[r4,#0x2a]         ;1247
000186  1e40              SUBS     r0,r0,#1              ;1247
000188  8560              STRH     r0,[r4,#0x2a]         ;1247
00018a  e09e              B        |L18.714|
                  |L18.396|
00018c  8d20              LDRH     r0,[r4,#0x28]         ;1250
00018e  2802              CMP      r0,#2                 ;1250
000190  d12a              BNE      |L18.488|
000192  4633              MOV      r3,r6                 ;1253
000194  2200              MOVS     r2,#0                 ;1253
000196  4957              LDR      r1,|L18.756|
000198  4620              MOV      r0,r4                 ;1253
00019a  9500              STR      r5,[sp,#0]            ;1253
00019c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001a0  b108              CBZ      r0,|L18.422|
0001a2  2001              MOVS     r0,#1                 ;1255
0001a4  e743              B        |L18.46|
                  |L18.422|
0001a6  6820              LDR      r0,[r4,#0]            ;1259
0001a8  6800              LDR      r0,[r0,#0]            ;1259
0001aa  f4407000          ORR      r0,r0,#0x200          ;1259
0001ae  6821              LDR      r1,[r4,#0]            ;1259
0001b0  6008              STR      r0,[r1,#0]            ;1259
0001b2  6820              LDR      r0,[r4,#0]            ;1262
0001b4  6900              LDR      r0,[r0,#0x10]         ;1262
0001b6  6a61              LDR      r1,[r4,#0x24]         ;1262
0001b8  7008              STRB     r0,[r1,#0]            ;1262
0001ba  6a60              LDR      r0,[r4,#0x24]         ;1265
0001bc  1c40              ADDS     r0,r0,#1              ;1265
0001be  6260              STR      r0,[r4,#0x24]         ;1265
0001c0  8d20              LDRH     r0,[r4,#0x28]         ;1268
0001c2  1e40              SUBS     r0,r0,#1              ;1268
0001c4  8520              STRH     r0,[r4,#0x28]         ;1268
0001c6  8d60              LDRH     r0,[r4,#0x2a]         ;1269
0001c8  1e40              SUBS     r0,r0,#1              ;1269
0001ca  8560              STRH     r0,[r4,#0x2a]         ;1269
0001cc  6820              LDR      r0,[r4,#0]            ;1272
0001ce  6900              LDR      r0,[r0,#0x10]         ;1272
0001d0  6a61              LDR      r1,[r4,#0x24]         ;1272
0001d2  7008              STRB     r0,[r1,#0]            ;1272
0001d4  6a60              LDR      r0,[r4,#0x24]         ;1275
0001d6  1c40              ADDS     r0,r0,#1              ;1275
0001d8  6260              STR      r0,[r4,#0x24]         ;1275
0001da  8d20              LDRH     r0,[r4,#0x28]         ;1278
0001dc  1e40              SUBS     r0,r0,#1              ;1278
0001de  8520              STRH     r0,[r4,#0x28]         ;1278
0001e0  8d60              LDRH     r0,[r4,#0x2a]         ;1279
0001e2  1e40              SUBS     r0,r0,#1              ;1279
0001e4  8560              STRH     r0,[r4,#0x2a]         ;1279
0001e6  e070              B        |L18.714|
                  |L18.488|
0001e8  4633              MOV      r3,r6                 ;1285
0001ea  2200              MOVS     r2,#0                 ;1285
0001ec  4941              LDR      r1,|L18.756|
0001ee  4620              MOV      r0,r4                 ;1285
0001f0  9500              STR      r5,[sp,#0]            ;1285
0001f2  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001f6  b108              CBZ      r0,|L18.508|
0001f8  2001              MOVS     r0,#1                 ;1287
0001fa  e718              B        |L18.46|
                  |L18.508|
0001fc  6820              LDR      r0,[r4,#0]            ;1291
0001fe  6800              LDR      r0,[r0,#0]            ;1291
000200  f4206080          BIC      r0,r0,#0x400          ;1291
000204  6821              LDR      r1,[r4,#0]            ;1291
000206  6008              STR      r0,[r1,#0]            ;1291
000208  6820              LDR      r0,[r4,#0]            ;1294
00020a  6900              LDR      r0,[r0,#0x10]         ;1294
00020c  6a61              LDR      r1,[r4,#0x24]         ;1294
00020e  7008              STRB     r0,[r1,#0]            ;1294
000210  6a60              LDR      r0,[r4,#0x24]         ;1297
000212  1c40              ADDS     r0,r0,#1              ;1297
000214  6260              STR      r0,[r4,#0x24]         ;1297
000216  8d20              LDRH     r0,[r4,#0x28]         ;1300
000218  1e40              SUBS     r0,r0,#1              ;1300
00021a  8520              STRH     r0,[r4,#0x28]         ;1300
00021c  8d60              LDRH     r0,[r4,#0x2a]         ;1301
00021e  1e40              SUBS     r0,r0,#1              ;1301
000220  8560              STRH     r0,[r4,#0x2a]         ;1301
000222  4633              MOV      r3,r6                 ;1304
000224  2200              MOVS     r2,#0                 ;1304
000226  4933              LDR      r1,|L18.756|
000228  4620              MOV      r0,r4                 ;1304
00022a  9500              STR      r5,[sp,#0]            ;1304
00022c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000230  b108              CBZ      r0,|L18.566|
000232  2001              MOVS     r0,#1                 ;1306
000234  e6fb              B        |L18.46|
                  |L18.566|
000236  6820              LDR      r0,[r4,#0]            ;1310
000238  6800              LDR      r0,[r0,#0]            ;1310
00023a  f4407000          ORR      r0,r0,#0x200          ;1310
00023e  6821              LDR      r1,[r4,#0]            ;1310
000240  6008              STR      r0,[r1,#0]            ;1310
000242  6820              LDR      r0,[r4,#0]            ;1313
000244  6900              LDR      r0,[r0,#0x10]         ;1313
000246  6a61              LDR      r1,[r4,#0x24]         ;1313
000248  7008              STRB     r0,[r1,#0]            ;1313
00024a  6a60              LDR      r0,[r4,#0x24]         ;1316
00024c  1c40              ADDS     r0,r0,#1              ;1316
00024e  6260              STR      r0,[r4,#0x24]         ;1316
000250  8d20              LDRH     r0,[r4,#0x28]         ;1319
000252  1e40              SUBS     r0,r0,#1              ;1319
000254  8520              STRH     r0,[r4,#0x28]         ;1319
000256  e000              B        |L18.602|
                  |L18.600|
000258  e010              B        |L18.636|
                  |L18.602|
00025a  8d60              LDRH     r0,[r4,#0x2a]         ;1320
00025c  1e40              SUBS     r0,r0,#1              ;1320
00025e  8560              STRH     r0,[r4,#0x2a]         ;1320
000260  6820              LDR      r0,[r4,#0]            ;1323
000262  6900              LDR      r0,[r0,#0x10]         ;1323
000264  6a61              LDR      r1,[r4,#0x24]         ;1323
000266  7008              STRB     r0,[r1,#0]            ;1323
000268  6a60              LDR      r0,[r4,#0x24]         ;1326
00026a  1c40              ADDS     r0,r0,#1              ;1326
00026c  6260              STR      r0,[r4,#0x24]         ;1326
00026e  8d20              LDRH     r0,[r4,#0x28]         ;1329
000270  1e40              SUBS     r0,r0,#1              ;1329
000272  8520              STRH     r0,[r4,#0x28]         ;1329
000274  8d60              LDRH     r0,[r4,#0x2a]         ;1330
000276  1e40              SUBS     r0,r0,#1              ;1330
000278  8560              STRH     r0,[r4,#0x2a]         ;1330
00027a  e026              B        |L18.714|
                  |L18.636|
00027c  462a              MOV      r2,r5                 ;1336
00027e  4631              MOV      r1,r6                 ;1336
000280  4620              MOV      r0,r4                 ;1336
000282  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000286  b108              CBZ      r0,|L18.652|
000288  2001              MOVS     r0,#1                 ;1338
00028a  e6d0              B        |L18.46|
                  |L18.652|
00028c  6820              LDR      r0,[r4,#0]            ;1342
00028e  6900              LDR      r0,[r0,#0x10]         ;1342
000290  6a61              LDR      r1,[r4,#0x24]         ;1342
000292  7008              STRB     r0,[r1,#0]            ;1342
000294  6a60              LDR      r0,[r4,#0x24]         ;1345
000296  1c40              ADDS     r0,r0,#1              ;1345
000298  6260              STR      r0,[r4,#0x24]         ;1345
00029a  8d20              LDRH     r0,[r4,#0x28]         ;1348
00029c  1e40              SUBS     r0,r0,#1              ;1348
00029e  8520              STRH     r0,[r4,#0x28]         ;1348
0002a0  8d60              LDRH     r0,[r4,#0x2a]         ;1349
0002a2  1e40              SUBS     r0,r0,#1              ;1349
0002a4  8560              STRH     r0,[r4,#0x2a]         ;1349
0002a6  6820              LDR      r0,[r4,#0]            ;1351
0002a8  6940              LDR      r0,[r0,#0x14]         ;1351
0002aa  f3c00080          UBFX     r0,r0,#2,#1           ;1351
0002ae  b160              CBZ      r0,|L18.714|
0002b0  6820              LDR      r0,[r4,#0]            ;1354
0002b2  6900              LDR      r0,[r0,#0x10]         ;1354
0002b4  6a61              LDR      r1,[r4,#0x24]         ;1354
0002b6  7008              STRB     r0,[r1,#0]            ;1354
0002b8  6a60              LDR      r0,[r4,#0x24]         ;1357
0002ba  1c40              ADDS     r0,r0,#1              ;1357
0002bc  6260              STR      r0,[r4,#0x24]         ;1357
0002be  8d20              LDRH     r0,[r4,#0x28]         ;1360
0002c0  1e40              SUBS     r0,r0,#1              ;1360
0002c2  8520              STRH     r0,[r4,#0x28]         ;1360
0002c4  8d60              LDRH     r0,[r4,#0x2a]         ;1361
0002c6  1e40              SUBS     r0,r0,#1              ;1361
0002c8  8560              STRH     r0,[r4,#0x2a]         ;1361
                  |L18.714|
0002ca  8d20              LDRH     r0,[r4,#0x28]         ;1226
0002cc  2800              CMP      r0,#0                 ;1226
0002ce  f47faf41          BNE      |L18.340|
0002d2  2020              MOVS     r0,#0x20              ;1366
0002d4  f884003d          STRB     r0,[r4,#0x3d]         ;1366
0002d8  2000              MOVS     r0,#0                 ;1367
0002da  f884003e          STRB     r0,[r4,#0x3e]         ;1367
0002de  bf00              NOP                            ;1370
0002e0  f884003c          STRB     r0,[r4,#0x3c]         ;1370
0002e4  bf00              NOP                            ;1370
0002e6  e6a2              B        |L18.46|
                  |L18.744|
0002e8  2002              MOVS     r0,#2                 ;1376
0002ea  e6a0              B        |L18.46|
;;;1379   
                          ENDP

                  |L18.748|
                          DCD      0x00100002
                  |L18.752|
                          DCD      0xffff0000
                  |L18.756|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Master_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_DMA PROC
;;;2068     */
;;;2069   HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2070   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;2071     __IO uint32_t count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;2072     HAL_StatusTypeDef dmaxferstatus;
;;;2073   
;;;2074     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d17d              BNE      |L19.276|
;;;2075     {
;;;2076       /* Wait until BUSY flag is reset */
;;;2077       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000018  4861              LDR      r0,|L19.416|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  2119              MOVS     r1,#0x19
00001e  fbb0f0f1          UDIV     r0,r0,r1
000022  f44f717a          MOV      r1,#0x3e8
000026  fbb0f0f1          UDIV     r0,r0,r1
00002a  eb0001c0          ADD      r1,r0,r0,LSL #3
00002e  eb011000          ADD      r0,r1,r0,LSL #4
000032  9000              STR      r0,[sp,#0]
;;;2078       do
000034  bf00              NOP      
                  |L19.54|
;;;2079       {
;;;2080         count--;
000036  9800              LDR      r0,[sp,#0]
000038  1e40              SUBS     r0,r0,#1
00003a  9000              STR      r0,[sp,#0]
;;;2081         if (count == 0U)
00003c  9800              LDR      r0,[sp,#0]
00003e  b998              CBNZ     r0,|L19.104|
;;;2082         {
;;;2083           hi2c->PreviousState       = I2C_STATE_NONE;
000040  2000              MOVS     r0,#0
000042  6320              STR      r0,[r4,#0x30]
;;;2084           hi2c->State               = HAL_I2C_STATE_READY;
000044  2020              MOVS     r0,#0x20
000046  f884003d          STRB     r0,[r4,#0x3d]
;;;2085           hi2c->Mode                = HAL_I2C_MODE_NONE;
00004a  2000              MOVS     r0,#0
00004c  f884003e          STRB     r0,[r4,#0x3e]
;;;2086           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000050  6c20              LDR      r0,[r4,#0x40]
000052  f0400020          ORR      r0,r0,#0x20
000056  6420              STR      r0,[r4,#0x40]
;;;2087   
;;;2088           /* Process Unlocked */
;;;2089           __HAL_UNLOCK(hi2c);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f884003c          STRB     r0,[r4,#0x3c]
000060  bf00              NOP      
;;;2090   
;;;2091           return HAL_ERROR;
000062  2001              MOVS     r0,#1
                  |L19.100|
;;;2092         }
;;;2093       }
;;;2094       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2095   
;;;2096       /* Process Locked */
;;;2097       __HAL_LOCK(hi2c);
;;;2098   
;;;2099       /* Check if the I2C is already enabled */
;;;2100       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2101       {
;;;2102         /* Enable I2C peripheral */
;;;2103         __HAL_I2C_ENABLE(hi2c);
;;;2104       }
;;;2105   
;;;2106       /* Disable Pos */
;;;2107       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2108   
;;;2109       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2110       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;2111       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2112   
;;;2113       /* Prepare transfer parameters */
;;;2114       hi2c->pBuffPtr    = pData;
;;;2115       hi2c->XferCount   = Size;
;;;2116       hi2c->XferSize    = hi2c->XferCount;
;;;2117       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2118       hi2c->Devaddress  = DevAddress;
;;;2119   
;;;2120       if (hi2c->XferSize > 0U)
;;;2121       {
;;;2122         /* Set the I2C DMA transfer complete callback */
;;;2123         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;2124   
;;;2125         /* Set the DMA error callback */
;;;2126         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2127   
;;;2128         /* Set the unused DMA callbacks to NULL */
;;;2129         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2130         hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;2131         hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;2132         hi2c->hdmarx->XferAbortCallback = NULL;
;;;2133   
;;;2134         /* Enable the DMA stream */
;;;2135         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;2136   
;;;2137         if (dmaxferstatus == HAL_OK)
;;;2138         {
;;;2139           /* Enable Acknowledge */
;;;2140           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2141   
;;;2142           /* Generate Start */
;;;2143           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2144   
;;;2145           /* Process Unlocked */
;;;2146           __HAL_UNLOCK(hi2c);
;;;2147   
;;;2148           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2149           to avoid the risk of I2C interrupt handle execution before current
;;;2150           process unlock */
;;;2151   
;;;2152           /* Enable EVT and ERR interrupt */
;;;2153           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2154   
;;;2155           /* Enable DMA Request */
;;;2156           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2157         }
;;;2158         else
;;;2159         {
;;;2160           /* Update I2C state */
;;;2161           hi2c->State     = HAL_I2C_STATE_READY;
;;;2162           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2163   
;;;2164           /* Update I2C error code */
;;;2165           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2166   
;;;2167           /* Process Unlocked */
;;;2168           __HAL_UNLOCK(hi2c);
;;;2169   
;;;2170           return HAL_ERROR;
;;;2171         }
;;;2172       }
;;;2173       else
;;;2174       {
;;;2175         /* Enable Acknowledge */
;;;2176         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2177   
;;;2178         /* Generate Start */
;;;2179         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2180   
;;;2181         /* Process Unlocked */
;;;2182         __HAL_UNLOCK(hi2c);
;;;2183   
;;;2184         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2185         to avoid the risk of I2C interrupt handle execution before current
;;;2186         process unlock */
;;;2187   
;;;2188         /* Enable EVT, BUF and ERR interrupt */
;;;2189         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2190       }
;;;2191   
;;;2192       return HAL_OK;
;;;2193     }
;;;2194     else
;;;2195     {
;;;2196       return HAL_BUSY;
;;;2197     }
;;;2198   }
000064  e8bd83f8          POP      {r3-r9,pc}
                  |L19.104|
000068  6820              LDR      r0,[r4,#0]            ;2094
00006a  6980              LDR      r0,[r0,#0x18]         ;2094
00006c  f3c00040          UBFX     r0,r0,#1,#1           ;2094
000070  2800              CMP      r0,#0                 ;2094
000072  d1e0              BNE      |L19.54|
000074  bf00              NOP                            ;2097
000076  f894003c          LDRB     r0,[r4,#0x3c]         ;2097
00007a  2801              CMP      r0,#1                 ;2097
00007c  d101              BNE      |L19.130|
00007e  2002              MOVS     r0,#2                 ;2097
000080  e7f0              B        |L19.100|
                  |L19.130|
000082  2001              MOVS     r0,#1                 ;2097
000084  f884003c          STRB     r0,[r4,#0x3c]         ;2097
000088  bf00              NOP                            ;2097
00008a  6820              LDR      r0,[r4,#0]            ;2100
00008c  6800              LDR      r0,[r0,#0]            ;2100
00008e  f0000001          AND      r0,r0,#1              ;2100
000092  b928              CBNZ     r0,|L19.160|
000094  6820              LDR      r0,[r4,#0]            ;2103
000096  6800              LDR      r0,[r0,#0]            ;2103
000098  f0400001          ORR      r0,r0,#1              ;2103
00009c  6821              LDR      r1,[r4,#0]            ;2103
00009e  6008              STR      r0,[r1,#0]            ;2103
                  |L19.160|
0000a0  6820              LDR      r0,[r4,#0]            ;2107
0000a2  6800              LDR      r0,[r0,#0]            ;2107
0000a4  f4206000          BIC      r0,r0,#0x800          ;2107
0000a8  6821              LDR      r1,[r4,#0]            ;2107
0000aa  6008              STR      r0,[r1,#0]            ;2107
0000ac  2022              MOVS     r0,#0x22              ;2109
0000ae  f884003d          STRB     r0,[r4,#0x3d]         ;2109
0000b2  2010              MOVS     r0,#0x10              ;2110
0000b4  f884003e          STRB     r0,[r4,#0x3e]         ;2110
0000b8  2000              MOVS     r0,#0                 ;2111
0000ba  6420              STR      r0,[r4,#0x40]         ;2111
0000bc  6267              STR      r7,[r4,#0x24]         ;2114
0000be  f8a4802a          STRH     r8,[r4,#0x2a]         ;2115
0000c2  8d60              LDRH     r0,[r4,#0x2a]         ;2116
0000c4  8520              STRH     r0,[r4,#0x28]         ;2116
0000c6  4837              LDR      r0,|L19.420|
0000c8  62e0              STR      r0,[r4,#0x2c]         ;2117
0000ca  6466              STR      r6,[r4,#0x44]         ;2118
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;2120
0000ce  2800              CMP      r0,#0                 ;2120
0000d0  d04a              BEQ      |L19.360|
0000d2  4835              LDR      r0,|L19.424|
0000d4  6ba1              LDR      r1,[r4,#0x38]         ;2123
0000d6  63c8              STR      r0,[r1,#0x3c]         ;2123
0000d8  4834              LDR      r0,|L19.428|
0000da  6ba1              LDR      r1,[r4,#0x38]         ;2126
0000dc  64c8              STR      r0,[r1,#0x4c]         ;2126
0000de  2000              MOVS     r0,#0                 ;2129
0000e0  6ba1              LDR      r1,[r4,#0x38]         ;2129
0000e2  6408              STR      r0,[r1,#0x40]         ;2129
0000e4  6ba1              LDR      r1,[r4,#0x38]         ;2130
0000e6  6448              STR      r0,[r1,#0x44]         ;2130
0000e8  6ba1              LDR      r1,[r4,#0x38]         ;2131
0000ea  6488              STR      r0,[r1,#0x48]         ;2131
0000ec  6ba1              LDR      r1,[r4,#0x38]         ;2132
0000ee  6508              STR      r0,[r1,#0x50]         ;2132
0000f0  8d23              LDRH     r3,[r4,#0x28]         ;2135
0000f2  f8d4c000          LDR      r12,[r4,#0]           ;2135
0000f6  f10c0110          ADD      r1,r12,#0x10          ;2135
0000fa  6a62              LDR      r2,[r4,#0x24]         ;2135
0000fc  6ba0              LDR      r0,[r4,#0x38]         ;2135
0000fe  f7fffffe          BL       HAL_DMA_Start_IT
000102  4605              MOV      r5,r0                 ;2135
000104  b9fd              CBNZ     r5,|L19.326|
000106  6820              LDR      r0,[r4,#0]            ;2140
000108  6800              LDR      r0,[r0,#0]            ;2140
00010a  f4406080          ORR      r0,r0,#0x400          ;2140
00010e  6821              LDR      r1,[r4,#0]            ;2140
000110  6008              STR      r0,[r1,#0]            ;2140
000112  e000              B        |L19.278|
                  |L19.276|
000114  e041              B        |L19.410|
                  |L19.278|
000116  6820              LDR      r0,[r4,#0]            ;2143
000118  6800              LDR      r0,[r0,#0]            ;2143
00011a  f4407080          ORR      r0,r0,#0x100          ;2143
00011e  6821              LDR      r1,[r4,#0]            ;2143
000120  6008              STR      r0,[r1,#0]            ;2143
000122  bf00              NOP                            ;2146
000124  2000              MOVS     r0,#0                 ;2146
000126  f884003c          STRB     r0,[r4,#0x3c]         ;2146
00012a  bf00              NOP                            ;2146
00012c  6820              LDR      r0,[r4,#0]            ;2153
00012e  6840              LDR      r0,[r0,#4]            ;2153
000130  f4407040          ORR      r0,r0,#0x300          ;2153
000134  6821              LDR      r1,[r4,#0]            ;2153
000136  6048              STR      r0,[r1,#4]            ;2153
000138  6820              LDR      r0,[r4,#0]            ;2156
00013a  6840              LDR      r0,[r0,#4]            ;2156
00013c  f4406000          ORR      r0,r0,#0x800          ;2156
000140  6821              LDR      r1,[r4,#0]            ;2156
000142  6048              STR      r0,[r1,#4]            ;2156
000144  e027              B        |L19.406|
                  |L19.326|
000146  2020              MOVS     r0,#0x20              ;2161
000148  f884003d          STRB     r0,[r4,#0x3d]         ;2161
00014c  2000              MOVS     r0,#0                 ;2162
00014e  f884003e          STRB     r0,[r4,#0x3e]         ;2162
000152  6c20              LDR      r0,[r4,#0x40]         ;2165
000154  f0400010          ORR      r0,r0,#0x10           ;2165
000158  6420              STR      r0,[r4,#0x40]         ;2165
00015a  bf00              NOP                            ;2168
00015c  2000              MOVS     r0,#0                 ;2168
00015e  f884003c          STRB     r0,[r4,#0x3c]         ;2168
000162  bf00              NOP                            ;2168
000164  2001              MOVS     r0,#1                 ;2170
000166  e77d              B        |L19.100|
                  |L19.360|
000168  6820              LDR      r0,[r4,#0]            ;2176
00016a  6800              LDR      r0,[r0,#0]            ;2176
00016c  f4406080          ORR      r0,r0,#0x400          ;2176
000170  6821              LDR      r1,[r4,#0]            ;2176
000172  6008              STR      r0,[r1,#0]            ;2176
000174  6820              LDR      r0,[r4,#0]            ;2179
000176  6800              LDR      r0,[r0,#0]            ;2179
000178  f4407080          ORR      r0,r0,#0x100          ;2179
00017c  6821              LDR      r1,[r4,#0]            ;2179
00017e  6008              STR      r0,[r1,#0]            ;2179
000180  bf00              NOP                            ;2182
000182  2000              MOVS     r0,#0                 ;2182
000184  f884003c          STRB     r0,[r4,#0x3c]         ;2182
000188  bf00              NOP                            ;2182
00018a  6820              LDR      r0,[r4,#0]            ;2189
00018c  6840              LDR      r0,[r0,#4]            ;2189
00018e  f44060e0          ORR      r0,r0,#0x700          ;2189
000192  6821              LDR      r1,[r4,#0]            ;2189
000194  6048              STR      r0,[r1,#4]            ;2189
                  |L19.406|
000196  2000              MOVS     r0,#0                 ;2192
000198  e764              B        |L19.100|
                  |L19.410|
00019a  2002              MOVS     r0,#2                 ;2196
00019c  e762              B        |L19.100|
;;;2199   
                          ENDP

00019e  0000              DCW      0x0000
                  |L19.416|
                          DCD      SystemCoreClock
                  |L19.420|
                          DCD      0xffff0000
                  |L19.424|
                          DCD      I2C_DMAXferCplt
                  |L19.428|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_IT PROC
;;;1719     */
;;;1720   HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;1721   {
000002  4604              MOV      r4,r0
;;;1722     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1723   
;;;1724     if (hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d171              BNE      |L20.244|
;;;1725     {
;;;1726       /* Wait until BUSY flag is reset */
;;;1727       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000010  4839              LDR      r0,|L20.248|
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  2519              MOVS     r5,#0x19
000016  fbb0f0f5          UDIV     r0,r0,r5
00001a  f44f757a          MOV      r5,#0x3e8
00001e  fbb0f0f5          UDIV     r0,r0,r5
000022  eb0005c0          ADD      r5,r0,r0,LSL #3
000026  eb051000          ADD      r0,r5,r0,LSL #4
00002a  9000              STR      r0,[sp,#0]
;;;1728       do
00002c  bf00              NOP      
                  |L20.46|
;;;1729       {
;;;1730         count--;
00002e  9800              LDR      r0,[sp,#0]
000030  1e40              SUBS     r0,r0,#1
000032  9000              STR      r0,[sp,#0]
;;;1731         if (count == 0U)
000034  9800              LDR      r0,[sp,#0]
000036  b990              CBNZ     r0,|L20.94|
;;;1732         {
;;;1733           hi2c->PreviousState       = I2C_STATE_NONE;
000038  2000              MOVS     r0,#0
00003a  6320              STR      r0,[r4,#0x30]
;;;1734           hi2c->State               = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;1735           hi2c->Mode                = HAL_I2C_MODE_NONE;
000042  2000              MOVS     r0,#0
000044  f884003e          STRB     r0,[r4,#0x3e]
;;;1736           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000048  6c20              LDR      r0,[r4,#0x40]
00004a  f0400020          ORR      r0,r0,#0x20
00004e  6420              STR      r0,[r4,#0x40]
;;;1737   
;;;1738           /* Process Unlocked */
;;;1739           __HAL_UNLOCK(hi2c);
000050  bf00              NOP      
000052  2000              MOVS     r0,#0
000054  f884003c          STRB     r0,[r4,#0x3c]
000058  bf00              NOP      
;;;1740   
;;;1741           return HAL_ERROR;
00005a  2001              MOVS     r0,#1
                  |L20.92|
;;;1742         }
;;;1743       }
;;;1744       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1745   
;;;1746       /* Process Locked */
;;;1747       __HAL_LOCK(hi2c);
;;;1748   
;;;1749       /* Check if the I2C is already enabled */
;;;1750       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1751       {
;;;1752         /* Enable I2C peripheral */
;;;1753         __HAL_I2C_ENABLE(hi2c);
;;;1754       }
;;;1755   
;;;1756       /* Disable Pos */
;;;1757       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1758   
;;;1759       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1760       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1761       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1762   
;;;1763       /* Prepare transfer parameters */
;;;1764       hi2c->pBuffPtr    = pData;
;;;1765       hi2c->XferCount   = Size;
;;;1766       hi2c->XferSize    = hi2c->XferCount;
;;;1767       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1768       hi2c->Devaddress  = DevAddress;
;;;1769   
;;;1770       /* Enable Acknowledge */
;;;1771       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1772   
;;;1773       /* Generate Start */
;;;1774       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;1775   
;;;1776       /* Process Unlocked */
;;;1777       __HAL_UNLOCK(hi2c);
;;;1778   
;;;1779       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1780       to avoid the risk of I2C interrupt handle execution before current
;;;1781       process unlock */
;;;1782   
;;;1783       /* Enable EVT, BUF and ERR interrupt */
;;;1784       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1785   
;;;1786       return HAL_OK;
;;;1787     }
;;;1788     else
;;;1789     {
;;;1790       return HAL_BUSY;
;;;1791     }
;;;1792   }
00005c  bd38              POP      {r3-r5,pc}
                  |L20.94|
00005e  6820              LDR      r0,[r4,#0]            ;1744
000060  6980              LDR      r0,[r0,#0x18]         ;1744
000062  f3c00040          UBFX     r0,r0,#1,#1           ;1744
000066  2800              CMP      r0,#0                 ;1744
000068  d1e1              BNE      |L20.46|
00006a  bf00              NOP                            ;1747
00006c  f894003c          LDRB     r0,[r4,#0x3c]         ;1747
000070  2801              CMP      r0,#1                 ;1747
000072  d101              BNE      |L20.120|
000074  2002              MOVS     r0,#2                 ;1747
000076  e7f1              B        |L20.92|
                  |L20.120|
000078  2001              MOVS     r0,#1                 ;1747
00007a  f884003c          STRB     r0,[r4,#0x3c]         ;1747
00007e  bf00              NOP                            ;1747
000080  6820              LDR      r0,[r4,#0]            ;1750
000082  6800              LDR      r0,[r0,#0]            ;1750
000084  f0000001          AND      r0,r0,#1              ;1750
000088  b928              CBNZ     r0,|L20.150|
00008a  6820              LDR      r0,[r4,#0]            ;1753
00008c  6800              LDR      r0,[r0,#0]            ;1753
00008e  f0400001          ORR      r0,r0,#1              ;1753
000092  6825              LDR      r5,[r4,#0]            ;1753
000094  6028              STR      r0,[r5,#0]            ;1753
                  |L20.150|
000096  6820              LDR      r0,[r4,#0]            ;1757
000098  6800              LDR      r0,[r0,#0]            ;1757
00009a  f4206000          BIC      r0,r0,#0x800          ;1757
00009e  6825              LDR      r5,[r4,#0]            ;1757
0000a0  6028              STR      r0,[r5,#0]            ;1757
0000a2  2022              MOVS     r0,#0x22              ;1759
0000a4  f884003d          STRB     r0,[r4,#0x3d]         ;1759
0000a8  2010              MOVS     r0,#0x10              ;1760
0000aa  f884003e          STRB     r0,[r4,#0x3e]         ;1760
0000ae  2000              MOVS     r0,#0                 ;1761
0000b0  6420              STR      r0,[r4,#0x40]         ;1761
0000b2  6262              STR      r2,[r4,#0x24]         ;1764
0000b4  8563              STRH     r3,[r4,#0x2a]         ;1765
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;1766
0000b8  8520              STRH     r0,[r4,#0x28]         ;1766
0000ba  4810              LDR      r0,|L20.252|
0000bc  62e0              STR      r0,[r4,#0x2c]         ;1767
0000be  6461              STR      r1,[r4,#0x44]         ;1768
0000c0  6820              LDR      r0,[r4,#0]            ;1771
0000c2  6800              LDR      r0,[r0,#0]            ;1771
0000c4  f4406080          ORR      r0,r0,#0x400          ;1771
0000c8  6825              LDR      r5,[r4,#0]            ;1771
0000ca  6028              STR      r0,[r5,#0]            ;1771
0000cc  6820              LDR      r0,[r4,#0]            ;1774
0000ce  6800              LDR      r0,[r0,#0]            ;1774
0000d0  f4407080          ORR      r0,r0,#0x100          ;1774
0000d4  6825              LDR      r5,[r4,#0]            ;1774
0000d6  6028              STR      r0,[r5,#0]            ;1774
0000d8  bf00              NOP                            ;1777
0000da  2000              MOVS     r0,#0                 ;1777
0000dc  f884003c          STRB     r0,[r4,#0x3c]         ;1777
0000e0  bf00              NOP                            ;1777
0000e2  6820              LDR      r0,[r4,#0]            ;1784
0000e4  6840              LDR      r0,[r0,#4]            ;1784
0000e6  f44060e0          ORR      r0,r0,#0x700          ;1784
0000ea  6825              LDR      r5,[r4,#0]            ;1784
0000ec  6068              STR      r0,[r5,#4]            ;1784
0000ee  2000              MOVS     r0,#0                 ;1786
0000f0  e7b4              B        |L20.92|
0000f2  e7ff              B        |L20.244|
                  |L20.244|
0000f4  2002              MOVS     r0,#2                 ;1790
0000f6  e7b1              B        |L20.92|
;;;1793   
                          ENDP

                  |L20.248|
                          DCD      SystemCoreClock
                  |L20.252|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Master_Seq_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Receive_DMA PROC
;;;3776     */
;;;3777   HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3778   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;3779     __IO uint32_t Prev_State = 0x00U;
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;3780     __IO uint32_t count = 0U;
000012  9000              STR      r0,[sp,#0]
;;;3781     uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000014  f44f6ae0          MOV      r10,#0x700
;;;3782     HAL_StatusTypeDef dmaxferstatus;
;;;3783   
;;;3784     /* Check the parameters */
;;;3785     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3786   
;;;3787     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d17d              BNE      |L21.284|
;;;3788     {
;;;3789       /* Check Busy Flag only if FIRST call of Master interface */
;;;3790       if ((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000020  2d08              CMP      r5,#8
000022  d001              BEQ      |L21.40|
000024  2d01              CMP      r5,#1
000026  d12d              BNE      |L21.132|
                  |L21.40|
;;;3791       {
;;;3792         /* Wait until BUSY flag is reset */
;;;3793         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000028  488a              LDR      r0,|L21.596|
00002a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00002c  2119              MOVS     r1,#0x19
00002e  fbb0f0f1          UDIV     r0,r0,r1
000032  f44f717a          MOV      r1,#0x3e8
000036  fbb0f0f1          UDIV     r0,r0,r1
00003a  eb0001c0          ADD      r1,r0,r0,LSL #3
00003e  eb011000          ADD      r0,r1,r0,LSL #4
000042  9000              STR      r0,[sp,#0]
;;;3794         do
000044  bf00              NOP      
                  |L21.70|
;;;3795         {
;;;3796           count--;
000046  9800              LDR      r0,[sp,#0]
000048  1e40              SUBS     r0,r0,#1
00004a  9000              STR      r0,[sp,#0]
;;;3797           if (count == 0U)
00004c  9800              LDR      r0,[sp,#0]
00004e  b998              CBNZ     r0,|L21.120|
;;;3798           {
;;;3799             hi2c->PreviousState       = I2C_STATE_NONE;
000050  2000              MOVS     r0,#0
000052  6320              STR      r0,[r4,#0x30]
;;;3800             hi2c->State               = HAL_I2C_STATE_READY;
000054  2020              MOVS     r0,#0x20
000056  f884003d          STRB     r0,[r4,#0x3d]
;;;3801             hi2c->Mode                = HAL_I2C_MODE_NONE;
00005a  2000              MOVS     r0,#0
00005c  f884003e          STRB     r0,[r4,#0x3e]
;;;3802             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000060  6c20              LDR      r0,[r4,#0x40]
000062  f0400020          ORR      r0,r0,#0x20
000066  6420              STR      r0,[r4,#0x40]
;;;3803   
;;;3804             /* Process Unlocked */
;;;3805             __HAL_UNLOCK(hi2c);
000068  bf00              NOP      
00006a  2000              MOVS     r0,#0
00006c  f884003c          STRB     r0,[r4,#0x3c]
000070  bf00              NOP      
;;;3806   
;;;3807             return HAL_ERROR;
000072  2001              MOVS     r0,#1
                  |L21.116|
;;;3808           }
;;;3809         }
;;;3810         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3811       }
;;;3812   
;;;3813       /* Process Locked */
;;;3814       __HAL_LOCK(hi2c);
;;;3815   
;;;3816       /* Check if the I2C is already enabled */
;;;3817       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3818       {
;;;3819         /* Enable I2C peripheral */
;;;3820         __HAL_I2C_ENABLE(hi2c);
;;;3821       }
;;;3822   
;;;3823       /* Disable Pos */
;;;3824       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3825   
;;;3826       /* Clear Last DMA bit */
;;;3827       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3828   
;;;3829       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3830       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3831       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3832   
;;;3833       /* Prepare transfer parameters */
;;;3834       hi2c->pBuffPtr    = pData;
;;;3835       hi2c->XferCount   = Size;
;;;3836       hi2c->XferSize    = hi2c->XferCount;
;;;3837       hi2c->XferOptions = XferOptions;
;;;3838       hi2c->Devaddress  = DevAddress;
;;;3839   
;;;3840       Prev_State = hi2c->PreviousState;
;;;3841   
;;;3842       if (hi2c->XferSize > 0U)
;;;3843       {
;;;3844         if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_OTHER_AND_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
;;;3845         {
;;;3846           /* Disable Acknowledge */
;;;3847           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3848   
;;;3849           /* Enable Pos */
;;;3850           SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3851   
;;;3852           /* Enable Last DMA bit */
;;;3853           SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3854         }
;;;3855         else
;;;3856         {
;;;3857           /* Enable Acknowledge */
;;;3858           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3859   
;;;3860           if ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_OTHER_AND_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;3861           {
;;;3862             /* Enable Last DMA bit */
;;;3863             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3864           }
;;;3865         }
;;;3866   
;;;3867         /* Set the I2C DMA transfer complete callback */
;;;3868         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;3869   
;;;3870         /* Set the DMA error callback */
;;;3871         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;3872   
;;;3873         /* Set the unused DMA callbacks to NULL */
;;;3874         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;3875         hi2c->hdmarx->XferAbortCallback = NULL;
;;;3876   
;;;3877         /* Enable the DMA stream */
;;;3878         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;3879   
;;;3880         if (dmaxferstatus == HAL_OK)
;;;3881         {
;;;3882           /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3883           /* Mean Previous state is same as current state */
;;;3884           if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3885           {
;;;3886             /* Generate Start */
;;;3887             SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3888           }
;;;3889   
;;;3890           /* Process Unlocked */
;;;3891           __HAL_UNLOCK(hi2c);
;;;3892   
;;;3893           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3894           to avoid the risk of I2C interrupt handle execution before current
;;;3895           process unlock */
;;;3896   
;;;3897           /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
;;;3898           /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
;;;3899           if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;3900           {
;;;3901             /* Enable DMA Request */
;;;3902             SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;3903           }
;;;3904   
;;;3905           /* Enable EVT and ERR interrupt */
;;;3906           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;3907         }
;;;3908         else
;;;3909         {
;;;3910           /* Update I2C state */
;;;3911           hi2c->State     = HAL_I2C_STATE_READY;
;;;3912           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3913   
;;;3914           /* Update I2C error code */
;;;3915           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3916   
;;;3917           /* Process Unlocked */
;;;3918           __HAL_UNLOCK(hi2c);
;;;3919   
;;;3920           return HAL_ERROR;
;;;3921         }
;;;3922       }
;;;3923       else
;;;3924       {
;;;3925         /* Enable Acknowledge */
;;;3926         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3927   
;;;3928         /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3929         /* Mean Previous state is same as current state */
;;;3930         if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3931         {
;;;3932           /* Generate Start */
;;;3933           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3934         }
;;;3935   
;;;3936         /* Process Unlocked */
;;;3937         __HAL_UNLOCK(hi2c);
;;;3938   
;;;3939         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3940         to avoid the risk of I2C interrupt handle execution before current
;;;3941         process unlock */
;;;3942   
;;;3943         /* Enable interrupts */
;;;3944         __HAL_I2C_ENABLE_IT(hi2c, enableIT);
;;;3945       }
;;;3946       return HAL_OK;
;;;3947     }
;;;3948     else
;;;3949     {
;;;3950       return HAL_BUSY;
;;;3951     }
;;;3952   }
000074  e8bd87fc          POP      {r2-r10,pc}
                  |L21.120|
000078  6820              LDR      r0,[r4,#0]            ;3810
00007a  6980              LDR      r0,[r0,#0x18]         ;3810
00007c  f3c00040          UBFX     r0,r0,#1,#1           ;3810
000080  2800              CMP      r0,#0                 ;3810
000082  d1e0              BNE      |L21.70|
                  |L21.132|
000084  bf00              NOP                            ;3814
000086  f894003c          LDRB     r0,[r4,#0x3c]         ;3814
00008a  2801              CMP      r0,#1                 ;3814
00008c  d101              BNE      |L21.146|
00008e  2002              MOVS     r0,#2                 ;3814
000090  e7f0              B        |L21.116|
                  |L21.146|
000092  2001              MOVS     r0,#1                 ;3814
000094  f884003c          STRB     r0,[r4,#0x3c]         ;3814
000098  bf00              NOP                            ;3814
00009a  6820              LDR      r0,[r4,#0]            ;3817
00009c  6800              LDR      r0,[r0,#0]            ;3817
00009e  f0000001          AND      r0,r0,#1              ;3817
0000a2  b928              CBNZ     r0,|L21.176|
0000a4  6820              LDR      r0,[r4,#0]            ;3820
0000a6  6800              LDR      r0,[r0,#0]            ;3820
0000a8  f0400001          ORR      r0,r0,#1              ;3820
0000ac  6821              LDR      r1,[r4,#0]            ;3820
0000ae  6008              STR      r0,[r1,#0]            ;3820
                  |L21.176|
0000b0  6820              LDR      r0,[r4,#0]            ;3824
0000b2  6800              LDR      r0,[r0,#0]            ;3824
0000b4  f4206000          BIC      r0,r0,#0x800          ;3824
0000b8  6821              LDR      r1,[r4,#0]            ;3824
0000ba  6008              STR      r0,[r1,#0]            ;3824
0000bc  6820              LDR      r0,[r4,#0]            ;3827
0000be  6840              LDR      r0,[r0,#4]            ;3827
0000c0  f4205080          BIC      r0,r0,#0x1000         ;3827
0000c4  6821              LDR      r1,[r4,#0]            ;3827
0000c6  6048              STR      r0,[r1,#4]            ;3827
0000c8  2022              MOVS     r0,#0x22              ;3829
0000ca  f884003d          STRB     r0,[r4,#0x3d]         ;3829
0000ce  2010              MOVS     r0,#0x10              ;3830
0000d0  f884003e          STRB     r0,[r4,#0x3e]         ;3830
0000d4  2000              MOVS     r0,#0                 ;3831
0000d6  6420              STR      r0,[r4,#0x40]         ;3831
0000d8  f8c48024          STR      r8,[r4,#0x24]         ;3834
0000dc  f8a4902a          STRH     r9,[r4,#0x2a]         ;3835
0000e0  8d60              LDRH     r0,[r4,#0x2a]         ;3836
0000e2  8520              STRH     r0,[r4,#0x28]         ;3836
0000e4  62e5              STR      r5,[r4,#0x2c]         ;3837
0000e6  6467              STR      r7,[r4,#0x44]         ;3838
0000e8  6b20              LDR      r0,[r4,#0x30]         ;3840
0000ea  9001              STR      r0,[sp,#4]            ;3840
0000ec  8d20              LDRH     r0,[r4,#0x28]         ;3842
0000ee  2800              CMP      r0,#0                 ;3842
0000f0  d073              BEQ      |L21.474|
0000f2  8d60              LDRH     r0,[r4,#0x2a]         ;3844
0000f4  2802              CMP      r0,#2                 ;3844
0000f6  d11b              BNE      |L21.304|
0000f8  2d20              CMP      r5,#0x20              ;3844
0000fa  d004              BEQ      |L21.262|
0000fc  f1b54f2a          CMP      r5,#0xaa000000        ;3844
000100  d001              BEQ      |L21.262|
000102  2d10              CMP      r5,#0x10              ;3844
000104  d114              BNE      |L21.304|
                  |L21.262|
000106  6820              LDR      r0,[r4,#0]            ;3847
000108  6800              LDR      r0,[r0,#0]            ;3847
00010a  f4206080          BIC      r0,r0,#0x400          ;3847
00010e  6821              LDR      r1,[r4,#0]            ;3847
000110  6008              STR      r0,[r1,#0]            ;3847
000112  6820              LDR      r0,[r4,#0]            ;3850
000114  6800              LDR      r0,[r0,#0]            ;3850
000116  f4406000          ORR      r0,r0,#0x800          ;3850
00011a  e000              B        |L21.286|
                  |L21.284|
00011c  e097              B        |L21.590|
                  |L21.286|
00011e  6821              LDR      r1,[r4,#0]            ;3850
000120  6008              STR      r0,[r1,#0]            ;3850
000122  6820              LDR      r0,[r4,#0]            ;3853
000124  6840              LDR      r0,[r0,#4]            ;3853
000126  f4405080          ORR      r0,r0,#0x1000         ;3853
00012a  6821              LDR      r1,[r4,#0]            ;3853
00012c  6048              STR      r0,[r1,#4]            ;3853
00012e  e012              B        |L21.342|
                  |L21.304|
000130  6820              LDR      r0,[r4,#0]            ;3858
000132  6800              LDR      r0,[r0,#0]            ;3858
000134  f4406080          ORR      r0,r0,#0x400          ;3858
000138  6821              LDR      r1,[r4,#0]            ;3858
00013a  6008              STR      r0,[r1,#0]            ;3858
00013c  2d20              CMP      r5,#0x20              ;3860
00013e  d004              BEQ      |L21.330|
000140  f1b54f2a          CMP      r5,#0xaa000000        ;3860
000144  d001              BEQ      |L21.330|
000146  2d10              CMP      r5,#0x10              ;3860
000148  d105              BNE      |L21.342|
                  |L21.330|
00014a  6820              LDR      r0,[r4,#0]            ;3863
00014c  6840              LDR      r0,[r0,#4]            ;3863
00014e  f4405080          ORR      r0,r0,#0x1000         ;3863
000152  6821              LDR      r1,[r4,#0]            ;3863
000154  6048              STR      r0,[r1,#4]            ;3863
                  |L21.342|
000156  4840              LDR      r0,|L21.600|
000158  6ba1              LDR      r1,[r4,#0x38]         ;3868
00015a  63c8              STR      r0,[r1,#0x3c]         ;3868
00015c  483f              LDR      r0,|L21.604|
00015e  6ba1              LDR      r1,[r4,#0x38]         ;3871
000160  64c8              STR      r0,[r1,#0x4c]         ;3871
000162  2000              MOVS     r0,#0                 ;3874
000164  6ba1              LDR      r1,[r4,#0x38]         ;3874
000166  6408              STR      r0,[r1,#0x40]         ;3874
000168  6ba1              LDR      r1,[r4,#0x38]         ;3875
00016a  6508              STR      r0,[r1,#0x50]         ;3875
00016c  8d23              LDRH     r3,[r4,#0x28]         ;3878
00016e  f8d4c000          LDR      r12,[r4,#0]           ;3878
000172  f10c0110          ADD      r1,r12,#0x10          ;3878
000176  6a62              LDR      r2,[r4,#0x24]         ;3878
000178  6ba0              LDR      r0,[r4,#0x38]         ;3878
00017a  f7fffffe          BL       HAL_DMA_Start_IT
00017e  4606              MOV      r6,r0                 ;3878
000180  bb66              CBNZ     r6,|L21.476|
000182  9801              LDR      r0,[sp,#4]            ;3884
000184  2812              CMP      r0,#0x12              ;3884
000186  d10a              BNE      |L21.414|
000188  f5b50f2a          CMP      r5,#0xaa0000          ;3884
00018c  d002              BEQ      |L21.404|
00018e  f1b54f2a          CMP      r5,#0xaa000000        ;3884
000192  d101              BNE      |L21.408|
                  |L21.404|
000194  2001              MOVS     r0,#1                 ;3884
000196  e000              B        |L21.410|
                  |L21.408|
000198  2000              MOVS     r0,#0                 ;3884
                  |L21.410|
00019a  2801              CMP      r0,#1                 ;3884
00019c  d105              BNE      |L21.426|
                  |L21.414|
00019e  6820              LDR      r0,[r4,#0]            ;3887
0001a0  6800              LDR      r0,[r0,#0]            ;3887
0001a2  f4407080          ORR      r0,r0,#0x100          ;3887
0001a6  6821              LDR      r1,[r4,#0]            ;3887
0001a8  6008              STR      r0,[r1,#0]            ;3887
                  |L21.426|
0001aa  bf00              NOP                            ;3891
0001ac  2000              MOVS     r0,#0                 ;3891
0001ae  f884003c          STRB     r0,[r4,#0x3c]         ;3891
0001b2  bf00              NOP                            ;3891
0001b4  2d04              CMP      r5,#4                 ;3899
0001b6  d003              BEQ      |L21.448|
0001b8  2d20              CMP      r5,#0x20              ;3899
0001ba  d001              BEQ      |L21.448|
0001bc  2d10              CMP      r5,#0x10              ;3899
0001be  d105              BNE      |L21.460|
                  |L21.448|
0001c0  6820              LDR      r0,[r4,#0]            ;3902
0001c2  6840              LDR      r0,[r0,#4]            ;3902
0001c4  f4406000          ORR      r0,r0,#0x800          ;3902
0001c8  6821              LDR      r1,[r4,#0]            ;3902
0001ca  6048              STR      r0,[r1,#4]            ;3902
                  |L21.460|
0001cc  6820              LDR      r0,[r4,#0]            ;3906
0001ce  6840              LDR      r0,[r0,#4]            ;3906
0001d0  f4407040          ORR      r0,r0,#0x300          ;3906
0001d4  6821              LDR      r1,[r4,#0]            ;3906
0001d6  6048              STR      r0,[r1,#4]            ;3906
0001d8  e037              B        |L21.586|
                  |L21.474|
0001da  e011              B        |L21.512|
                  |L21.476|
0001dc  e7ff              B        |L21.478|
                  |L21.478|
0001de  2020              MOVS     r0,#0x20              ;3911
0001e0  f884003d          STRB     r0,[r4,#0x3d]         ;3911
0001e4  2000              MOVS     r0,#0                 ;3912
0001e6  f884003e          STRB     r0,[r4,#0x3e]         ;3912
0001ea  6c20              LDR      r0,[r4,#0x40]         ;3915
0001ec  f0400010          ORR      r0,r0,#0x10           ;3915
0001f0  6420              STR      r0,[r4,#0x40]         ;3915
0001f2  bf00              NOP                            ;3918
0001f4  2000              MOVS     r0,#0                 ;3918
0001f6  f884003c          STRB     r0,[r4,#0x3c]         ;3918
0001fa  bf00              NOP                            ;3918
0001fc  2001              MOVS     r0,#1                 ;3920
0001fe  e739              B        |L21.116|
                  |L21.512|
000200  6820              LDR      r0,[r4,#0]            ;3926
000202  6800              LDR      r0,[r0,#0]            ;3926
000204  f4406080          ORR      r0,r0,#0x400          ;3926
000208  6821              LDR      r1,[r4,#0]            ;3926
00020a  6008              STR      r0,[r1,#0]            ;3926
00020c  9801              LDR      r0,[sp,#4]            ;3930
00020e  2812              CMP      r0,#0x12              ;3930
000210  d10a              BNE      |L21.552|
000212  f5b50f2a          CMP      r5,#0xaa0000          ;3930
000216  d002              BEQ      |L21.542|
000218  f1b54f2a          CMP      r5,#0xaa000000        ;3930
00021c  d101              BNE      |L21.546|
                  |L21.542|
00021e  2001              MOVS     r0,#1                 ;3930
000220  e000              B        |L21.548|
                  |L21.546|
000222  2000              MOVS     r0,#0                 ;3930
                  |L21.548|
000224  2801              CMP      r0,#1                 ;3930
000226  d105              BNE      |L21.564|
                  |L21.552|
000228  6820              LDR      r0,[r4,#0]            ;3933
00022a  6800              LDR      r0,[r0,#0]            ;3933
00022c  f4407080          ORR      r0,r0,#0x100          ;3933
000230  6821              LDR      r1,[r4,#0]            ;3933
000232  6008              STR      r0,[r1,#0]            ;3933
                  |L21.564|
000234  bf00              NOP                            ;3937
000236  2000              MOVS     r0,#0                 ;3937
000238  f884003c          STRB     r0,[r4,#0x3c]         ;3937
00023c  bf00              NOP                            ;3937
00023e  6820              LDR      r0,[r4,#0]            ;3944
000240  6840              LDR      r0,[r0,#4]            ;3944
000242  ea40000a          ORR      r0,r0,r10             ;3944
000246  6821              LDR      r1,[r4,#0]            ;3944
000248  6048              STR      r0,[r1,#4]            ;3944
                  |L21.586|
00024a  2000              MOVS     r0,#0                 ;3946
00024c  e712              B        |L21.116|
                  |L21.590|
00024e  2002              MOVS     r0,#2                 ;3950
000250  e710              B        |L21.116|
;;;3953   
                          ENDP

000252  0000              DCW      0x0000
                  |L21.596|
                          DCD      SystemCoreClock
                  |L21.600|
                          DCD      I2C_DMAXferCplt
                  |L21.604|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Seq_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Receive_IT PROC
;;;3660     */
;;;3661   HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5fc              PUSH     {r2-r7,lr}
;;;3662   {
000002  4604              MOV      r4,r0
000004  9d07              LDR      r5,[sp,#0x1c]
;;;3663     __IO uint32_t Prev_State = 0x00U;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;3664     __IO uint32_t count = 0U;
00000a  9000              STR      r0,[sp,#0]
;;;3665     uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00000c  f44f66e0          MOV      r6,#0x700
;;;3666   
;;;3667     /* Check the parameters */
;;;3668     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3669   
;;;3670     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d175              BNE      |L22.260|
;;;3671     {
;;;3672       /* Check Busy Flag only if FIRST call of Master interface */
;;;3673       if ((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000018  2d08              CMP      r5,#8
00001a  d001              BEQ      |L22.32|
00001c  2d01              CMP      r5,#1
00001e  d12c              BNE      |L22.122|
                  |L22.32|
;;;3674       {
;;;3675         /* Wait until BUSY flag is reset */
;;;3676         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000020  484d              LDR      r0,|L22.344|
000022  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000024  2719              MOVS     r7,#0x19
000026  fbb0f0f7          UDIV     r0,r0,r7
00002a  f44f777a          MOV      r7,#0x3e8
00002e  fbb0f0f7          UDIV     r0,r0,r7
000032  eb0007c0          ADD      r7,r0,r0,LSL #3
000036  eb071000          ADD      r0,r7,r0,LSL #4
00003a  9000              STR      r0,[sp,#0]
;;;3677         do
00003c  bf00              NOP      
                  |L22.62|
;;;3678         {
;;;3679           count--;
00003e  9800              LDR      r0,[sp,#0]
000040  1e40              SUBS     r0,r0,#1
000042  9000              STR      r0,[sp,#0]
;;;3680           if (count == 0U)
000044  9800              LDR      r0,[sp,#0]
000046  b990              CBNZ     r0,|L22.110|
;;;3681           {
;;;3682             hi2c->PreviousState       = I2C_STATE_NONE;
000048  2000              MOVS     r0,#0
00004a  6320              STR      r0,[r4,#0x30]
;;;3683             hi2c->State               = HAL_I2C_STATE_READY;
00004c  2020              MOVS     r0,#0x20
00004e  f884003d          STRB     r0,[r4,#0x3d]
;;;3684             hi2c->Mode                = HAL_I2C_MODE_NONE;
000052  2000              MOVS     r0,#0
000054  f884003e          STRB     r0,[r4,#0x3e]
;;;3685             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000058  6c20              LDR      r0,[r4,#0x40]
00005a  f0400020          ORR      r0,r0,#0x20
00005e  6420              STR      r0,[r4,#0x40]
;;;3686   
;;;3687             /* Process Unlocked */
;;;3688             __HAL_UNLOCK(hi2c);
000060  bf00              NOP      
000062  2000              MOVS     r0,#0
000064  f884003c          STRB     r0,[r4,#0x3c]
000068  bf00              NOP      
;;;3689   
;;;3690             return HAL_ERROR;
00006a  2001              MOVS     r0,#1
                  |L22.108|
;;;3691           }
;;;3692         }
;;;3693         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3694       }
;;;3695   
;;;3696       /* Process Locked */
;;;3697       __HAL_LOCK(hi2c);
;;;3698   
;;;3699       /* Check if the I2C is already enabled */
;;;3700       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3701       {
;;;3702         /* Enable I2C peripheral */
;;;3703         __HAL_I2C_ENABLE(hi2c);
;;;3704       }
;;;3705   
;;;3706       /* Disable Pos */
;;;3707       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3708   
;;;3709       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3710       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3711       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3712   
;;;3713       /* Prepare transfer parameters */
;;;3714       hi2c->pBuffPtr    = pData;
;;;3715       hi2c->XferCount   = Size;
;;;3716       hi2c->XferSize    = hi2c->XferCount;
;;;3717       hi2c->XferOptions = XferOptions;
;;;3718       hi2c->Devaddress  = DevAddress;
;;;3719   
;;;3720       Prev_State = hi2c->PreviousState;
;;;3721   
;;;3722       if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_OTHER_AND_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
;;;3723       {
;;;3724         /* Disable Acknowledge */
;;;3725         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3726   
;;;3727         /* Enable Pos */
;;;3728         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3729   
;;;3730         /* Remove Enabling of IT_BUF, mean RXNE treatment, treat the 2 bytes through BTF */
;;;3731         enableIT &= ~I2C_IT_BUF;
;;;3732       }
;;;3733       else
;;;3734       {
;;;3735         /* Enable Acknowledge */
;;;3736         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3737       }
;;;3738   
;;;3739       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3740       /* Mean Previous state is same as current state */
;;;3741       if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3742       {
;;;3743         /* Generate Start */
;;;3744         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3745       }
;;;3746   
;;;3747       /* Process Unlocked */
;;;3748       __HAL_UNLOCK(hi2c);
;;;3749   
;;;3750       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3751       to avoid the risk of I2C interrupt handle execution before current
;;;3752       process unlock */
;;;3753   
;;;3754       /* Enable interrupts */
;;;3755       __HAL_I2C_ENABLE_IT(hi2c, enableIT);
;;;3756   
;;;3757       return HAL_OK;
;;;3758     }
;;;3759     else
;;;3760     {
;;;3761       return HAL_BUSY;
;;;3762     }
;;;3763   }
00006c  bdfc              POP      {r2-r7,pc}
                  |L22.110|
00006e  6820              LDR      r0,[r4,#0]            ;3693
000070  6980              LDR      r0,[r0,#0x18]         ;3693
000072  f3c00040          UBFX     r0,r0,#1,#1           ;3693
000076  2800              CMP      r0,#0                 ;3693
000078  d1e1              BNE      |L22.62|
                  |L22.122|
00007a  bf00              NOP                            ;3697
00007c  f894003c          LDRB     r0,[r4,#0x3c]         ;3697
000080  2801              CMP      r0,#1                 ;3697
000082  d101              BNE      |L22.136|
000084  2002              MOVS     r0,#2                 ;3697
000086  e7f1              B        |L22.108|
                  |L22.136|
000088  2001              MOVS     r0,#1                 ;3697
00008a  f884003c          STRB     r0,[r4,#0x3c]         ;3697
00008e  bf00              NOP                            ;3697
000090  6820              LDR      r0,[r4,#0]            ;3700
000092  6800              LDR      r0,[r0,#0]            ;3700
000094  f0000001          AND      r0,r0,#1              ;3700
000098  b928              CBNZ     r0,|L22.166|
00009a  6820              LDR      r0,[r4,#0]            ;3703
00009c  6800              LDR      r0,[r0,#0]            ;3703
00009e  f0400001          ORR      r0,r0,#1              ;3703
0000a2  6827              LDR      r7,[r4,#0]            ;3703
0000a4  6038              STR      r0,[r7,#0]            ;3703
                  |L22.166|
0000a6  6820              LDR      r0,[r4,#0]            ;3707
0000a8  6800              LDR      r0,[r0,#0]            ;3707
0000aa  f4206000          BIC      r0,r0,#0x800          ;3707
0000ae  6827              LDR      r7,[r4,#0]            ;3707
0000b0  6038              STR      r0,[r7,#0]            ;3707
0000b2  2022              MOVS     r0,#0x22              ;3709
0000b4  f884003d          STRB     r0,[r4,#0x3d]         ;3709
0000b8  2010              MOVS     r0,#0x10              ;3710
0000ba  f884003e          STRB     r0,[r4,#0x3e]         ;3710
0000be  2000              MOVS     r0,#0                 ;3711
0000c0  6420              STR      r0,[r4,#0x40]         ;3711
0000c2  6262              STR      r2,[r4,#0x24]         ;3714
0000c4  8563              STRH     r3,[r4,#0x2a]         ;3715
0000c6  8d60              LDRH     r0,[r4,#0x2a]         ;3716
0000c8  8520              STRH     r0,[r4,#0x28]         ;3716
0000ca  62e5              STR      r5,[r4,#0x2c]         ;3717
0000cc  6461              STR      r1,[r4,#0x44]         ;3718
0000ce  6b20              LDR      r0,[r4,#0x30]         ;3720
0000d0  9001              STR      r0,[sp,#4]            ;3720
0000d2  8d60              LDRH     r0,[r4,#0x2a]         ;3722
0000d4  2802              CMP      r0,#2                 ;3722
0000d6  d116              BNE      |L22.262|
0000d8  2d20              CMP      r5,#0x20              ;3722
0000da  d004              BEQ      |L22.230|
0000dc  f1b54f2a          CMP      r5,#0xaa000000        ;3722
0000e0  d001              BEQ      |L22.230|
0000e2  2d10              CMP      r5,#0x10              ;3722
0000e4  d10f              BNE      |L22.262|
                  |L22.230|
0000e6  6820              LDR      r0,[r4,#0]            ;3725
0000e8  6800              LDR      r0,[r0,#0]            ;3725
0000ea  f4206080          BIC      r0,r0,#0x400          ;3725
0000ee  6827              LDR      r7,[r4,#0]            ;3725
0000f0  6038              STR      r0,[r7,#0]            ;3725
0000f2  6820              LDR      r0,[r4,#0]            ;3728
0000f4  6800              LDR      r0,[r0,#0]            ;3728
0000f6  f4406000          ORR      r0,r0,#0x800          ;3728
0000fa  6827              LDR      r7,[r4,#0]            ;3728
0000fc  6038              STR      r0,[r7,#0]            ;3728
0000fe  f4266680          BIC      r6,r6,#0x400          ;3731
000102  e006              B        |L22.274|
                  |L22.260|
000104  e025              B        |L22.338|
                  |L22.262|
000106  6820              LDR      r0,[r4,#0]            ;3736
000108  6800              LDR      r0,[r0,#0]            ;3736
00010a  f4406080          ORR      r0,r0,#0x400          ;3736
00010e  6827              LDR      r7,[r4,#0]            ;3736
000110  6038              STR      r0,[r7,#0]            ;3736
                  |L22.274|
000112  9801              LDR      r0,[sp,#4]            ;3741
000114  2812              CMP      r0,#0x12              ;3741
000116  d10a              BNE      |L22.302|
000118  f5b50f2a          CMP      r5,#0xaa0000          ;3741
00011c  d002              BEQ      |L22.292|
00011e  f1b54f2a          CMP      r5,#0xaa000000        ;3741
000122  d101              BNE      |L22.296|
                  |L22.292|
000124  2001              MOVS     r0,#1                 ;3741
000126  e000              B        |L22.298|
                  |L22.296|
000128  2000              MOVS     r0,#0                 ;3741
                  |L22.298|
00012a  2801              CMP      r0,#1                 ;3741
00012c  d105              BNE      |L22.314|
                  |L22.302|
00012e  6820              LDR      r0,[r4,#0]            ;3744
000130  6800              LDR      r0,[r0,#0]            ;3744
000132  f4407080          ORR      r0,r0,#0x100          ;3744
000136  6827              LDR      r7,[r4,#0]            ;3744
000138  6038              STR      r0,[r7,#0]            ;3744
                  |L22.314|
00013a  bf00              NOP                            ;3748
00013c  2000              MOVS     r0,#0                 ;3748
00013e  f884003c          STRB     r0,[r4,#0x3c]         ;3748
000142  bf00              NOP                            ;3748
000144  6820              LDR      r0,[r4,#0]            ;3755
000146  6840              LDR      r0,[r0,#4]            ;3755
000148  4330              ORRS     r0,r0,r6              ;3755
00014a  6827              LDR      r7,[r4,#0]            ;3755
00014c  6078              STR      r0,[r7,#4]            ;3755
00014e  2000              MOVS     r0,#0                 ;3757
000150  e78c              B        |L22.108|
                  |L22.338|
000152  2002              MOVS     r0,#2                 ;3761
000154  e78a              B        |L22.108|
;;;3764   
                          ENDP

000156  0000              DCW      0x0000
                  |L22.344|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_I2C_Master_Seq_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Transmit_DMA PROC
;;;3494     */
;;;3495   HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3496   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;3497     __IO uint32_t Prev_State = 0x00U;
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;3498     __IO uint32_t count      = 0x00U;
000012  9000              STR      r0,[sp,#0]
;;;3499     HAL_StatusTypeDef dmaxferstatus;
;;;3500   
;;;3501     /* Check the parameters */
;;;3502     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3503   
;;;3504     if (hi2c->State == HAL_I2C_STATE_READY)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2820              CMP      r0,#0x20
00001a  d17d              BNE      |L23.280|
;;;3505     {
;;;3506       /* Check Busy Flag only if FIRST call of Master interface */
;;;3507       if ((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
00001c  2d08              CMP      r5,#8
00001e  d001              BEQ      |L23.36|
000020  2d01              CMP      r5,#1
000022  d12d              BNE      |L23.128|
                  |L23.36|
;;;3508       {
;;;3509         /* Wait until BUSY flag is reset */
;;;3510         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000024  4871              LDR      r0,|L23.492|
000026  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000028  2119              MOVS     r1,#0x19
00002a  fbb0f0f1          UDIV     r0,r0,r1
00002e  f44f717a          MOV      r1,#0x3e8
000032  fbb0f0f1          UDIV     r0,r0,r1
000036  eb0001c0          ADD      r1,r0,r0,LSL #3
00003a  eb011000          ADD      r0,r1,r0,LSL #4
00003e  9000              STR      r0,[sp,#0]
;;;3511         do
000040  bf00              NOP      
                  |L23.66|
;;;3512         {
;;;3513           count--;
000042  9800              LDR      r0,[sp,#0]
000044  1e40              SUBS     r0,r0,#1
000046  9000              STR      r0,[sp,#0]
;;;3514           if (count == 0U)
000048  9800              LDR      r0,[sp,#0]
00004a  b998              CBNZ     r0,|L23.116|
;;;3515           {
;;;3516             hi2c->PreviousState       = I2C_STATE_NONE;
00004c  2000              MOVS     r0,#0
00004e  6320              STR      r0,[r4,#0x30]
;;;3517             hi2c->State               = HAL_I2C_STATE_READY;
000050  2020              MOVS     r0,#0x20
000052  f884003d          STRB     r0,[r4,#0x3d]
;;;3518             hi2c->Mode                = HAL_I2C_MODE_NONE;
000056  2000              MOVS     r0,#0
000058  f884003e          STRB     r0,[r4,#0x3e]
;;;3519             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00005c  6c20              LDR      r0,[r4,#0x40]
00005e  f0400020          ORR      r0,r0,#0x20
000062  6420              STR      r0,[r4,#0x40]
;;;3520   
;;;3521             /* Process Unlocked */
;;;3522             __HAL_UNLOCK(hi2c);
000064  bf00              NOP      
000066  2000              MOVS     r0,#0
000068  f884003c          STRB     r0,[r4,#0x3c]
00006c  bf00              NOP      
;;;3523   
;;;3524             return HAL_ERROR;
00006e  2001              MOVS     r0,#1
                  |L23.112|
;;;3525           }
;;;3526         }
;;;3527         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3528       }
;;;3529   
;;;3530       /* Process Locked */
;;;3531       __HAL_LOCK(hi2c);
;;;3532   
;;;3533       /* Check if the I2C is already enabled */
;;;3534       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3535       {
;;;3536         /* Enable I2C peripheral */
;;;3537         __HAL_I2C_ENABLE(hi2c);
;;;3538       }
;;;3539   
;;;3540       /* Disable Pos */
;;;3541       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3542   
;;;3543       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3544       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3545       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3546   
;;;3547       /* Prepare transfer parameters */
;;;3548       hi2c->pBuffPtr    = pData;
;;;3549       hi2c->XferCount   = Size;
;;;3550       hi2c->XferSize    = hi2c->XferCount;
;;;3551       hi2c->XferOptions = XferOptions;
;;;3552       hi2c->Devaddress  = DevAddress;
;;;3553   
;;;3554       Prev_State = hi2c->PreviousState;
;;;3555   
;;;3556       if (hi2c->XferSize > 0U)
;;;3557       {
;;;3558         /* Set the I2C DMA transfer complete callback */
;;;3559         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;3560   
;;;3561         /* Set the DMA error callback */
;;;3562         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3563   
;;;3564         /* Set the unused DMA callbacks to NULL */
;;;3565         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3566         hi2c->hdmatx->XferAbortCallback = NULL;
;;;3567   
;;;3568         /* Enable the DMA stream */
;;;3569         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;3570   
;;;3571         if (dmaxferstatus == HAL_OK)
;;;3572         {
;;;3573           /* Enable Acknowledge */
;;;3574           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3575   
;;;3576           /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3577           /* Mean Previous state is same as current state */
;;;3578           if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3579           {
;;;3580             /* Generate Start */
;;;3581             SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3582           }
;;;3583   
;;;3584           /* Process Unlocked */
;;;3585           __HAL_UNLOCK(hi2c);
;;;3586   
;;;3587           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3588           to avoid the risk of I2C interrupt handle execution before current
;;;3589           process unlock */
;;;3590   
;;;3591           /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
;;;3592           /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
;;;3593           if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
;;;3594           {
;;;3595             /* Enable DMA Request */
;;;3596             SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;3597           }
;;;3598   
;;;3599           /* Enable EVT and ERR interrupt */
;;;3600           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;3601         }
;;;3602         else
;;;3603         {
;;;3604           /* Update I2C state */
;;;3605           hi2c->State     = HAL_I2C_STATE_READY;
;;;3606           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3607   
;;;3608           /* Update I2C error code */
;;;3609           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3610   
;;;3611           /* Process Unlocked */
;;;3612           __HAL_UNLOCK(hi2c);
;;;3613   
;;;3614           return HAL_ERROR;
;;;3615         }
;;;3616       }
;;;3617       else
;;;3618       {
;;;3619         /* Enable Acknowledge */
;;;3620         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3621   
;;;3622         /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3623         /* Mean Previous state is same as current state */
;;;3624         if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3625         {
;;;3626           /* Generate Start */
;;;3627           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3628         }
;;;3629   
;;;3630         /* Process Unlocked */
;;;3631         __HAL_UNLOCK(hi2c);
;;;3632   
;;;3633         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3634         to avoid the risk of I2C interrupt handle execution before current
;;;3635         process unlock */
;;;3636   
;;;3637         /* Enable EVT, BUF and ERR interrupt */
;;;3638         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3639       }
;;;3640   
;;;3641       return HAL_OK;
;;;3642     }
;;;3643     else
;;;3644     {
;;;3645       return HAL_BUSY;
;;;3646     }
;;;3647   }
000070  e8bd87fc          POP      {r2-r10,pc}
                  |L23.116|
000074  6820              LDR      r0,[r4,#0]            ;3527
000076  6980              LDR      r0,[r0,#0x18]         ;3527
000078  f3c00040          UBFX     r0,r0,#1,#1           ;3527
00007c  2800              CMP      r0,#0                 ;3527
00007e  d1e0              BNE      |L23.66|
                  |L23.128|
000080  bf00              NOP                            ;3531
000082  f894003c          LDRB     r0,[r4,#0x3c]         ;3531
000086  2801              CMP      r0,#1                 ;3531
000088  d101              BNE      |L23.142|
00008a  2002              MOVS     r0,#2                 ;3531
00008c  e7f0              B        |L23.112|
                  |L23.142|
00008e  2001              MOVS     r0,#1                 ;3531
000090  f884003c          STRB     r0,[r4,#0x3c]         ;3531
000094  bf00              NOP                            ;3531
000096  6820              LDR      r0,[r4,#0]            ;3534
000098  6800              LDR      r0,[r0,#0]            ;3534
00009a  f0000001          AND      r0,r0,#1              ;3534
00009e  b928              CBNZ     r0,|L23.172|
0000a0  6820              LDR      r0,[r4,#0]            ;3537
0000a2  6800              LDR      r0,[r0,#0]            ;3537
0000a4  f0400001          ORR      r0,r0,#1              ;3537
0000a8  6821              LDR      r1,[r4,#0]            ;3537
0000aa  6008              STR      r0,[r1,#0]            ;3537
                  |L23.172|
0000ac  6820              LDR      r0,[r4,#0]            ;3541
0000ae  6800              LDR      r0,[r0,#0]            ;3541
0000b0  f4206000          BIC      r0,r0,#0x800          ;3541
0000b4  6821              LDR      r1,[r4,#0]            ;3541
0000b6  6008              STR      r0,[r1,#0]            ;3541
0000b8  2021              MOVS     r0,#0x21              ;3543
0000ba  f884003d          STRB     r0,[r4,#0x3d]         ;3543
0000be  2010              MOVS     r0,#0x10              ;3544
0000c0  f884003e          STRB     r0,[r4,#0x3e]         ;3544
0000c4  2000              MOVS     r0,#0                 ;3545
0000c6  6420              STR      r0,[r4,#0x40]         ;3545
0000c8  f8c48024          STR      r8,[r4,#0x24]         ;3548
0000cc  f8a4902a          STRH     r9,[r4,#0x2a]         ;3549
0000d0  8d60              LDRH     r0,[r4,#0x2a]         ;3550
0000d2  8520              STRH     r0,[r4,#0x28]         ;3550
0000d4  62e5              STR      r5,[r4,#0x2c]         ;3551
0000d6  6467              STR      r7,[r4,#0x44]         ;3552
0000d8  6b20              LDR      r0,[r4,#0x30]         ;3554
0000da  9001              STR      r0,[sp,#4]            ;3554
0000dc  8d20              LDRH     r0,[r4,#0x28]         ;3556
0000de  2800              CMP      r0,#0                 ;3556
0000e0  d05b              BEQ      |L23.410|
0000e2  4843              LDR      r0,|L23.496|
0000e4  6b61              LDR      r1,[r4,#0x34]         ;3559
0000e6  63c8              STR      r0,[r1,#0x3c]         ;3559
0000e8  4842              LDR      r0,|L23.500|
0000ea  6b61              LDR      r1,[r4,#0x34]         ;3562
0000ec  64c8              STR      r0,[r1,#0x4c]         ;3562
0000ee  2000              MOVS     r0,#0                 ;3565
0000f0  6b61              LDR      r1,[r4,#0x34]         ;3565
0000f2  6408              STR      r0,[r1,#0x40]         ;3565
0000f4  6b61              LDR      r1,[r4,#0x34]         ;3566
0000f6  6508              STR      r0,[r1,#0x50]         ;3566
0000f8  8d23              LDRH     r3,[r4,#0x28]         ;3569
0000fa  f8d4c000          LDR      r12,[r4,#0]           ;3569
0000fe  f10c0210          ADD      r2,r12,#0x10          ;3569
000102  6a61              LDR      r1,[r4,#0x24]         ;3569
000104  6b60              LDR      r0,[r4,#0x34]         ;3569
000106  f7fffffe          BL       HAL_DMA_Start_IT
00010a  4606              MOV      r6,r0                 ;3569
00010c  bb9e              CBNZ     r6,|L23.374|
00010e  6820              LDR      r0,[r4,#0]            ;3574
000110  6800              LDR      r0,[r0,#0]            ;3574
000112  f4406080          ORR      r0,r0,#0x400          ;3574
000116  e000              B        |L23.282|
                  |L23.280|
000118  e066              B        |L23.488|
                  |L23.282|
00011a  6821              LDR      r1,[r4,#0]            ;3574
00011c  6008              STR      r0,[r1,#0]            ;3574
00011e  9801              LDR      r0,[sp,#4]            ;3578
000120  2811              CMP      r0,#0x11              ;3578
000122  d10a              BNE      |L23.314|
000124  f5b50f2a          CMP      r5,#0xaa0000          ;3578
000128  d002              BEQ      |L23.304|
00012a  f1b54f2a          CMP      r5,#0xaa000000        ;3578
00012e  d101              BNE      |L23.308|
                  |L23.304|
000130  2001              MOVS     r0,#1                 ;3578
000132  e000              B        |L23.310|
                  |L23.308|
000134  2000              MOVS     r0,#0                 ;3578
                  |L23.310|
000136  2801              CMP      r0,#1                 ;3578
000138  d105              BNE      |L23.326|
                  |L23.314|
00013a  6820              LDR      r0,[r4,#0]            ;3581
00013c  6800              LDR      r0,[r0,#0]            ;3581
00013e  f4407080          ORR      r0,r0,#0x100          ;3581
000142  6821              LDR      r1,[r4,#0]            ;3581
000144  6008              STR      r0,[r1,#0]            ;3581
                  |L23.326|
000146  bf00              NOP                            ;3585
000148  2000              MOVS     r0,#0                 ;3585
00014a  f884003c          STRB     r0,[r4,#0x3c]         ;3585
00014e  bf00              NOP                            ;3585
000150  2d04              CMP      r5,#4                 ;3593
000152  d003              BEQ      |L23.348|
000154  2d20              CMP      r5,#0x20              ;3593
000156  d001              BEQ      |L23.348|
000158  2d10              CMP      r5,#0x10              ;3593
00015a  d105              BNE      |L23.360|
                  |L23.348|
00015c  6820              LDR      r0,[r4,#0]            ;3596
00015e  6840              LDR      r0,[r0,#4]            ;3596
000160  f4406000          ORR      r0,r0,#0x800          ;3596
000164  6821              LDR      r1,[r4,#0]            ;3596
000166  6048              STR      r0,[r1,#4]            ;3596
                  |L23.360|
000168  6820              LDR      r0,[r4,#0]            ;3600
00016a  6840              LDR      r0,[r0,#4]            ;3600
00016c  f4407040          ORR      r0,r0,#0x300          ;3600
000170  6821              LDR      r1,[r4,#0]            ;3600
000172  6048              STR      r0,[r1,#4]            ;3600
000174  e036              B        |L23.484|
                  |L23.374|
000176  e7ff              B        |L23.376|
                  |L23.376|
000178  2020              MOVS     r0,#0x20              ;3605
00017a  f884003d          STRB     r0,[r4,#0x3d]         ;3605
00017e  2000              MOVS     r0,#0                 ;3606
000180  f884003e          STRB     r0,[r4,#0x3e]         ;3606
000184  6c20              LDR      r0,[r4,#0x40]         ;3609
000186  f0400010          ORR      r0,r0,#0x10           ;3609
00018a  6420              STR      r0,[r4,#0x40]         ;3609
00018c  bf00              NOP                            ;3612
00018e  2000              MOVS     r0,#0                 ;3612
000190  f884003c          STRB     r0,[r4,#0x3c]         ;3612
000194  bf00              NOP                            ;3612
000196  2001              MOVS     r0,#1                 ;3614
000198  e76a              B        |L23.112|
                  |L23.410|
00019a  6820              LDR      r0,[r4,#0]            ;3620
00019c  6800              LDR      r0,[r0,#0]            ;3620
00019e  f4406080          ORR      r0,r0,#0x400          ;3620
0001a2  6821              LDR      r1,[r4,#0]            ;3620
0001a4  6008              STR      r0,[r1,#0]            ;3620
0001a6  9801              LDR      r0,[sp,#4]            ;3624
0001a8  2811              CMP      r0,#0x11              ;3624
0001aa  d10a              BNE      |L23.450|
0001ac  f5b50f2a          CMP      r5,#0xaa0000          ;3624
0001b0  d002              BEQ      |L23.440|
0001b2  f1b54f2a          CMP      r5,#0xaa000000        ;3624
0001b6  d101              BNE      |L23.444|
                  |L23.440|
0001b8  2001              MOVS     r0,#1                 ;3624
0001ba  e000              B        |L23.446|
                  |L23.444|
0001bc  2000              MOVS     r0,#0                 ;3624
                  |L23.446|
0001be  2801              CMP      r0,#1                 ;3624
0001c0  d105              BNE      |L23.462|
                  |L23.450|
0001c2  6820              LDR      r0,[r4,#0]            ;3627
0001c4  6800              LDR      r0,[r0,#0]            ;3627
0001c6  f4407080          ORR      r0,r0,#0x100          ;3627
0001ca  6821              LDR      r1,[r4,#0]            ;3627
0001cc  6008              STR      r0,[r1,#0]            ;3627
                  |L23.462|
0001ce  bf00              NOP                            ;3631
0001d0  2000              MOVS     r0,#0                 ;3631
0001d2  f884003c          STRB     r0,[r4,#0x3c]         ;3631
0001d6  bf00              NOP                            ;3631
0001d8  6820              LDR      r0,[r4,#0]            ;3638
0001da  6840              LDR      r0,[r0,#4]            ;3638
0001dc  f44060e0          ORR      r0,r0,#0x700          ;3638
0001e0  6821              LDR      r1,[r4,#0]            ;3638
0001e2  6048              STR      r0,[r1,#4]            ;3638
                  |L23.484|
0001e4  2000              MOVS     r0,#0                 ;3641
0001e6  e743              B        |L23.112|
                  |L23.488|
0001e8  2002              MOVS     r0,#2                 ;3645
0001ea  e741              B        |L23.112|
;;;3648   
                          ENDP

                  |L23.492|
                          DCD      SystemCoreClock
                  |L23.496|
                          DCD      I2C_DMAXferCplt
                  |L23.500|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Seq_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Seq_Transmit_IT PROC
;;;3396     */
;;;3397   HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b57c              PUSH     {r2-r6,lr}
;;;3398   {
000002  4604              MOV      r4,r0
000004  9d06              LDR      r5,[sp,#0x18]
;;;3399     __IO uint32_t Prev_State = 0x00U;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;3400     __IO uint32_t count      = 0x00U;
00000a  9000              STR      r0,[sp,#0]
;;;3401   
;;;3402     /* Check the parameters */
;;;3403     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3404   
;;;3405     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d17e              BNE      |L24.274|
;;;3406     {
;;;3407       /* Check Busy Flag only if FIRST call of Master interface */
;;;3408       if ((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
000014  2d08              CMP      r5,#8
000016  d001              BEQ      |L24.28|
000018  2d01              CMP      r5,#1
00001a  d12c              BNE      |L24.118|
                  |L24.28|
;;;3409       {
;;;3410         /* Wait until BUSY flag is reset */
;;;3411         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
00001c  483e              LDR      r0,|L24.280|
00001e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000020  2619              MOVS     r6,#0x19
000022  fbb0f0f6          UDIV     r0,r0,r6
000026  f44f767a          MOV      r6,#0x3e8
00002a  fbb0f0f6          UDIV     r0,r0,r6
00002e  eb0006c0          ADD      r6,r0,r0,LSL #3
000032  eb061000          ADD      r0,r6,r0,LSL #4
000036  9000              STR      r0,[sp,#0]
;;;3412         do
000038  bf00              NOP      
                  |L24.58|
;;;3413         {
;;;3414           count--;
00003a  9800              LDR      r0,[sp,#0]
00003c  1e40              SUBS     r0,r0,#1
00003e  9000              STR      r0,[sp,#0]
;;;3415           if (count == 0U)
000040  9800              LDR      r0,[sp,#0]
000042  b990              CBNZ     r0,|L24.106|
;;;3416           {
;;;3417             hi2c->PreviousState       = I2C_STATE_NONE;
000044  2000              MOVS     r0,#0
000046  6320              STR      r0,[r4,#0x30]
;;;3418             hi2c->State               = HAL_I2C_STATE_READY;
000048  2020              MOVS     r0,#0x20
00004a  f884003d          STRB     r0,[r4,#0x3d]
;;;3419             hi2c->Mode                = HAL_I2C_MODE_NONE;
00004e  2000              MOVS     r0,#0
000050  f884003e          STRB     r0,[r4,#0x3e]
;;;3420             hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000054  6c20              LDR      r0,[r4,#0x40]
000056  f0400020          ORR      r0,r0,#0x20
00005a  6420              STR      r0,[r4,#0x40]
;;;3421   
;;;3422             /* Process Unlocked */
;;;3423             __HAL_UNLOCK(hi2c);
00005c  bf00              NOP      
00005e  2000              MOVS     r0,#0
000060  f884003c          STRB     r0,[r4,#0x3c]
000064  bf00              NOP      
;;;3424   
;;;3425             return HAL_ERROR;
000066  2001              MOVS     r0,#1
                  |L24.104|
;;;3426           }
;;;3427         }
;;;3428         while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3429       }
;;;3430   
;;;3431       /* Process Locked */
;;;3432       __HAL_LOCK(hi2c);
;;;3433   
;;;3434       /* Check if the I2C is already enabled */
;;;3435       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3436       {
;;;3437         /* Enable I2C peripheral */
;;;3438         __HAL_I2C_ENABLE(hi2c);
;;;3439       }
;;;3440   
;;;3441       /* Disable Pos */
;;;3442       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3443   
;;;3444       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3445       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;3446       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3447   
;;;3448       /* Prepare transfer parameters */
;;;3449       hi2c->pBuffPtr    = pData;
;;;3450       hi2c->XferCount   = Size;
;;;3451       hi2c->XferSize    = hi2c->XferCount;
;;;3452       hi2c->XferOptions = XferOptions;
;;;3453       hi2c->Devaddress  = DevAddress;
;;;3454   
;;;3455       Prev_State = hi2c->PreviousState;
;;;3456   
;;;3457       /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
;;;3458       /* Mean Previous state is same as current state */
;;;3459       if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
;;;3460       {
;;;3461         /* Generate Start */
;;;3462         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3463       }
;;;3464   
;;;3465       /* Process Unlocked */
;;;3466       __HAL_UNLOCK(hi2c);
;;;3467   
;;;3468       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3469       to avoid the risk of I2C interrupt handle execution before current
;;;3470       process unlock */
;;;3471   
;;;3472       /* Enable EVT, BUF and ERR interrupt */
;;;3473       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3474   
;;;3475       return HAL_OK;
;;;3476     }
;;;3477     else
;;;3478     {
;;;3479       return HAL_BUSY;
;;;3480     }
;;;3481   }
000068  bd7c              POP      {r2-r6,pc}
                  |L24.106|
00006a  6820              LDR      r0,[r4,#0]            ;3428
00006c  6980              LDR      r0,[r0,#0x18]         ;3428
00006e  f3c00040          UBFX     r0,r0,#1,#1           ;3428
000072  2800              CMP      r0,#0                 ;3428
000074  d1e1              BNE      |L24.58|
                  |L24.118|
000076  bf00              NOP                            ;3432
000078  f894003c          LDRB     r0,[r4,#0x3c]         ;3432
00007c  2801              CMP      r0,#1                 ;3432
00007e  d101              BNE      |L24.132|
000080  2002              MOVS     r0,#2                 ;3432
000082  e7f1              B        |L24.104|
                  |L24.132|
000084  2001              MOVS     r0,#1                 ;3432
000086  f884003c          STRB     r0,[r4,#0x3c]         ;3432
00008a  bf00              NOP                            ;3432
00008c  6820              LDR      r0,[r4,#0]            ;3435
00008e  6800              LDR      r0,[r0,#0]            ;3435
000090  f0000001          AND      r0,r0,#1              ;3435
000094  b928              CBNZ     r0,|L24.162|
000096  6820              LDR      r0,[r4,#0]            ;3438
000098  6800              LDR      r0,[r0,#0]            ;3438
00009a  f0400001          ORR      r0,r0,#1              ;3438
00009e  6826              LDR      r6,[r4,#0]            ;3438
0000a0  6030              STR      r0,[r6,#0]            ;3438
                  |L24.162|
0000a2  6820              LDR      r0,[r4,#0]            ;3442
0000a4  6800              LDR      r0,[r0,#0]            ;3442
0000a6  f4206000          BIC      r0,r0,#0x800          ;3442
0000aa  6826              LDR      r6,[r4,#0]            ;3442
0000ac  6030              STR      r0,[r6,#0]            ;3442
0000ae  2021              MOVS     r0,#0x21              ;3444
0000b0  f884003d          STRB     r0,[r4,#0x3d]         ;3444
0000b4  2010              MOVS     r0,#0x10              ;3445
0000b6  f884003e          STRB     r0,[r4,#0x3e]         ;3445
0000ba  2000              MOVS     r0,#0                 ;3446
0000bc  6420              STR      r0,[r4,#0x40]         ;3446
0000be  6262              STR      r2,[r4,#0x24]         ;3449
0000c0  8563              STRH     r3,[r4,#0x2a]         ;3450
0000c2  8d60              LDRH     r0,[r4,#0x2a]         ;3451
0000c4  8520              STRH     r0,[r4,#0x28]         ;3451
0000c6  62e5              STR      r5,[r4,#0x2c]         ;3452
0000c8  6461              STR      r1,[r4,#0x44]         ;3453
0000ca  6b20              LDR      r0,[r4,#0x30]         ;3455
0000cc  9001              STR      r0,[sp,#4]            ;3455
0000ce  9801              LDR      r0,[sp,#4]            ;3459
0000d0  2811              CMP      r0,#0x11              ;3459
0000d2  d10a              BNE      |L24.234|
0000d4  f5b50f2a          CMP      r5,#0xaa0000          ;3459
0000d8  d002              BEQ      |L24.224|
0000da  f1b54f2a          CMP      r5,#0xaa000000        ;3459
0000de  d101              BNE      |L24.228|
                  |L24.224|
0000e0  2001              MOVS     r0,#1                 ;3459
0000e2  e000              B        |L24.230|
                  |L24.228|
0000e4  2000              MOVS     r0,#0                 ;3459
                  |L24.230|
0000e6  2801              CMP      r0,#1                 ;3459
0000e8  d105              BNE      |L24.246|
                  |L24.234|
0000ea  6820              LDR      r0,[r4,#0]            ;3462
0000ec  6800              LDR      r0,[r0,#0]            ;3462
0000ee  f4407080          ORR      r0,r0,#0x100          ;3462
0000f2  6826              LDR      r6,[r4,#0]            ;3462
0000f4  6030              STR      r0,[r6,#0]            ;3462
                  |L24.246|
0000f6  bf00              NOP                            ;3466
0000f8  2000              MOVS     r0,#0                 ;3466
0000fa  f884003c          STRB     r0,[r4,#0x3c]         ;3466
0000fe  bf00              NOP                            ;3466
000100  6820              LDR      r0,[r4,#0]            ;3473
000102  6840              LDR      r0,[r0,#4]            ;3473
000104  f44060e0          ORR      r0,r0,#0x700          ;3473
000108  6826              LDR      r6,[r4,#0]            ;3473
00010a  6070              STR      r0,[r6,#4]            ;3473
00010c  2000              MOVS     r0,#0                 ;3475
00010e  e7ab              B        |L24.104|
000110  e7ff              B        |L24.274|
                  |L24.274|
000112  2002              MOVS     r0,#2                 ;3479
000114  e7a8              B        |L24.104|
;;;3482   
                          ENDP

000116  0000              DCW      0x0000
                  |L24.280|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_I2C_Master_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit PROC
;;;1023     */
;;;1024   HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1025   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;1026     /* Init tickstart for timeout management*/
;;;1027     uint32_t tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4605              MOV      r5,r0
;;;1028   
;;;1029     if (hi2c->State == HAL_I2C_STATE_READY)
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2820              CMP      r0,#0x20
00001c  d17e              BNE      |L25.284|
;;;1030     {
;;;1031       /* Wait until BUSY flag is reset */
;;;1032       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
00001e  2319              MOVS     r3,#0x19
000020  2201              MOVS     r2,#1
000022  4951              LDR      r1,|L25.360|
000024  4620              MOV      r0,r4
000026  9500              STR      r5,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b110              CBZ      r0,|L25.52|
;;;1033       {
;;;1034         return HAL_BUSY;
00002e  2002              MOVS     r0,#2
                  |L25.48|
;;;1035       }
;;;1036   
;;;1037       /* Process Locked */
;;;1038       __HAL_LOCK(hi2c);
;;;1039   
;;;1040       /* Check if the I2C is already enabled */
;;;1041       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1042       {
;;;1043         /* Enable I2C peripheral */
;;;1044         __HAL_I2C_ENABLE(hi2c);
;;;1045       }
;;;1046   
;;;1047       /* Disable Pos */
;;;1048       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1049   
;;;1050       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1051       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1052       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1053   
;;;1054       /* Prepare transfer parameters */
;;;1055       hi2c->pBuffPtr    = pData;
;;;1056       hi2c->XferCount   = Size;
;;;1057       hi2c->XferSize    = hi2c->XferCount;
;;;1058       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1059   
;;;1060       /* Send Slave Address */
;;;1061       if (I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
;;;1062       {
;;;1063         return HAL_ERROR;
;;;1064       }
;;;1065   
;;;1066       /* Clear ADDR flag */
;;;1067       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1068   
;;;1069       while (hi2c->XferSize > 0U)
;;;1070       {
;;;1071         /* Wait until TXE flag is set */
;;;1072         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1073         {
;;;1074           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1075           {
;;;1076             /* Generate Stop */
;;;1077             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1078           }
;;;1079           return HAL_ERROR;
;;;1080         }
;;;1081   
;;;1082         /* Write data to DR */
;;;1083         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1084   
;;;1085         /* Increment Buffer pointer */
;;;1086         hi2c->pBuffPtr++;
;;;1087   
;;;1088         /* Update counter */
;;;1089         hi2c->XferCount--;
;;;1090         hi2c->XferSize--;
;;;1091   
;;;1092         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1093         {
;;;1094           /* Write data to DR */
;;;1095           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1096   
;;;1097           /* Increment Buffer pointer */
;;;1098           hi2c->pBuffPtr++;
;;;1099   
;;;1100           /* Update counter */
;;;1101           hi2c->XferCount--;
;;;1102           hi2c->XferSize--;
;;;1103         }
;;;1104   
;;;1105         /* Wait until BTF flag is set */
;;;1106         if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1107         {
;;;1108           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1109           {
;;;1110             /* Generate Stop */
;;;1111             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1112           }
;;;1113           return HAL_ERROR;
;;;1114         }
;;;1115       }
;;;1116   
;;;1117       /* Generate Stop */
;;;1118       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1119   
;;;1120       hi2c->State = HAL_I2C_STATE_READY;
;;;1121       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1122   
;;;1123       /* Process Unlocked */
;;;1124       __HAL_UNLOCK(hi2c);
;;;1125   
;;;1126       return HAL_OK;
;;;1127     }
;;;1128     else
;;;1129     {
;;;1130       return HAL_BUSY;
;;;1131     }
;;;1132   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L25.52|
000034  bf00              NOP                            ;1038
000036  f894003c          LDRB     r0,[r4,#0x3c]         ;1038
00003a  2801              CMP      r0,#1                 ;1038
00003c  d101              BNE      |L25.66|
00003e  2002              MOVS     r0,#2                 ;1038
000040  e7f6              B        |L25.48|
                  |L25.66|
000042  2001              MOVS     r0,#1                 ;1038
000044  f884003c          STRB     r0,[r4,#0x3c]         ;1038
000048  bf00              NOP                            ;1038
00004a  6820              LDR      r0,[r4,#0]            ;1041
00004c  6800              LDR      r0,[r0,#0]            ;1041
00004e  f0000001          AND      r0,r0,#1              ;1041
000052  b928              CBNZ     r0,|L25.96|
000054  6820              LDR      r0,[r4,#0]            ;1044
000056  6800              LDR      r0,[r0,#0]            ;1044
000058  f0400001          ORR      r0,r0,#1              ;1044
00005c  6821              LDR      r1,[r4,#0]            ;1044
00005e  6008              STR      r0,[r1,#0]            ;1044
                  |L25.96|
000060  6820              LDR      r0,[r4,#0]            ;1048
000062  6800              LDR      r0,[r0,#0]            ;1048
000064  f4206000          BIC      r0,r0,#0x800          ;1048
000068  6821              LDR      r1,[r4,#0]            ;1048
00006a  6008              STR      r0,[r1,#0]            ;1048
00006c  2021              MOVS     r0,#0x21              ;1050
00006e  f884003d          STRB     r0,[r4,#0x3d]         ;1050
000072  2010              MOVS     r0,#0x10              ;1051
000074  f884003e          STRB     r0,[r4,#0x3e]         ;1051
000078  2000              MOVS     r0,#0                 ;1052
00007a  6420              STR      r0,[r4,#0x40]         ;1052
00007c  6266              STR      r6,[r4,#0x24]         ;1055
00007e  8567              STRH     r7,[r4,#0x2a]         ;1056
000080  8d60              LDRH     r0,[r4,#0x2a]         ;1057
000082  8520              STRH     r0,[r4,#0x28]         ;1057
000084  4839              LDR      r0,|L25.364|
000086  62e0              STR      r0,[r4,#0x2c]         ;1058
000088  462b              MOV      r3,r5                 ;1061
00008a  4642              MOV      r2,r8                 ;1061
00008c  4649              MOV      r1,r9                 ;1061
00008e  4620              MOV      r0,r4                 ;1061
000090  f7fffffe          BL       I2C_MasterRequestWrite
000094  b108              CBZ      r0,|L25.154|
000096  2001              MOVS     r0,#1                 ;1063
000098  e7ca              B        |L25.48|
                  |L25.154|
00009a  bf00              NOP                            ;1067
00009c  2000              MOVS     r0,#0                 ;1067
00009e  9000              STR      r0,[sp,#0]            ;1067
0000a0  6820              LDR      r0,[r4,#0]            ;1067
0000a2  6940              LDR      r0,[r0,#0x14]         ;1067
0000a4  9000              STR      r0,[sp,#0]            ;1067
0000a6  6820              LDR      r0,[r4,#0]            ;1067
0000a8  6980              LDR      r0,[r0,#0x18]         ;1067
0000aa  9000              STR      r0,[sp,#0]            ;1067
0000ac  bf00              NOP                            ;1067
0000ae  bf00              NOP                            ;1067
0000b0  e044              B        |L25.316|
                  |L25.178|
0000b2  462a              MOV      r2,r5                 ;1072
0000b4  4641              MOV      r1,r8                 ;1072
0000b6  4620              MOV      r0,r4                 ;1072
0000b8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000bc  b150              CBZ      r0,|L25.212|
0000be  6c20              LDR      r0,[r4,#0x40]         ;1074
0000c0  2804              CMP      r0,#4                 ;1074
0000c2  d105              BNE      |L25.208|
0000c4  6820              LDR      r0,[r4,#0]            ;1077
0000c6  6800              LDR      r0,[r0,#0]            ;1077
0000c8  f4407000          ORR      r0,r0,#0x200          ;1077
0000cc  6821              LDR      r1,[r4,#0]            ;1077
0000ce  6008              STR      r0,[r1,#0]            ;1077
                  |L25.208|
0000d0  2001              MOVS     r0,#1                 ;1079
0000d2  e7ad              B        |L25.48|
                  |L25.212|
0000d4  6a60              LDR      r0,[r4,#0x24]         ;1083
0000d6  7800              LDRB     r0,[r0,#0]            ;1083
0000d8  6821              LDR      r1,[r4,#0]            ;1083
0000da  6108              STR      r0,[r1,#0x10]         ;1083
0000dc  6a60              LDR      r0,[r4,#0x24]         ;1086
0000de  1c40              ADDS     r0,r0,#1              ;1086
0000e0  6260              STR      r0,[r4,#0x24]         ;1086
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;1089
0000e4  1e40              SUBS     r0,r0,#1              ;1089
0000e6  8560              STRH     r0,[r4,#0x2a]         ;1089
0000e8  8d20              LDRH     r0,[r4,#0x28]         ;1090
0000ea  1e40              SUBS     r0,r0,#1              ;1090
0000ec  8520              STRH     r0,[r4,#0x28]         ;1090
0000ee  6820              LDR      r0,[r4,#0]            ;1092
0000f0  6940              LDR      r0,[r0,#0x14]         ;1092
0000f2  f3c00080          UBFX     r0,r0,#2,#1           ;1092
0000f6  b170              CBZ      r0,|L25.278|
0000f8  8d20              LDRH     r0,[r4,#0x28]         ;1092
0000fa  b160              CBZ      r0,|L25.278|
0000fc  6a60              LDR      r0,[r4,#0x24]         ;1095
0000fe  7800              LDRB     r0,[r0,#0]            ;1095
000100  6821              LDR      r1,[r4,#0]            ;1095
000102  6108              STR      r0,[r1,#0x10]         ;1095
000104  6a60              LDR      r0,[r4,#0x24]         ;1098
000106  1c40              ADDS     r0,r0,#1              ;1098
000108  6260              STR      r0,[r4,#0x24]         ;1098
00010a  8d60              LDRH     r0,[r4,#0x2a]         ;1101
00010c  1e40              SUBS     r0,r0,#1              ;1101
00010e  8560              STRH     r0,[r4,#0x2a]         ;1101
000110  8d20              LDRH     r0,[r4,#0x28]         ;1102
000112  1e40              SUBS     r0,r0,#1              ;1102
000114  8520              STRH     r0,[r4,#0x28]         ;1102
                  |L25.278|
000116  462a              MOV      r2,r5                 ;1106
000118  4641              MOV      r1,r8                 ;1106
00011a  e000              B        |L25.286|
                  |L25.284|
00011c  e022              B        |L25.356|
                  |L25.286|
00011e  4620              MOV      r0,r4                 ;1106
000120  f7fffffe          BL       I2C_WaitOnBTFFlagUntilTimeout
000124  b150              CBZ      r0,|L25.316|
000126  6c20              LDR      r0,[r4,#0x40]         ;1108
000128  2804              CMP      r0,#4                 ;1108
00012a  d105              BNE      |L25.312|
00012c  6820              LDR      r0,[r4,#0]            ;1111
00012e  6800              LDR      r0,[r0,#0]            ;1111
000130  f4407000          ORR      r0,r0,#0x200          ;1111
000134  6821              LDR      r1,[r4,#0]            ;1111
000136  6008              STR      r0,[r1,#0]            ;1111
                  |L25.312|
000138  2001              MOVS     r0,#1                 ;1113
00013a  e779              B        |L25.48|
                  |L25.316|
00013c  8d20              LDRH     r0,[r4,#0x28]         ;1069
00013e  2800              CMP      r0,#0                 ;1069
000140  d1b7              BNE      |L25.178|
000142  6820              LDR      r0,[r4,#0]            ;1118
000144  6800              LDR      r0,[r0,#0]            ;1118
000146  f4407000          ORR      r0,r0,#0x200          ;1118
00014a  6821              LDR      r1,[r4,#0]            ;1118
00014c  6008              STR      r0,[r1,#0]            ;1118
00014e  2020              MOVS     r0,#0x20              ;1120
000150  f884003d          STRB     r0,[r4,#0x3d]         ;1120
000154  2000              MOVS     r0,#0                 ;1121
000156  f884003e          STRB     r0,[r4,#0x3e]         ;1121
00015a  bf00              NOP                            ;1124
00015c  f884003c          STRB     r0,[r4,#0x3c]         ;1124
000160  bf00              NOP                            ;1124
000162  e765              B        |L25.48|
                  |L25.356|
000164  2002              MOVS     r0,#2                 ;1130
000166  e763              B        |L25.48|
;;;1133   
                          ENDP

                  |L25.360|
                          DCD      0x00100002
                  |L25.364|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Master_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_DMA PROC
;;;1927     */
;;;1928   HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1929   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1930     __IO uint32_t count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;1931     HAL_StatusTypeDef dmaxferstatus;
;;;1932   
;;;1933     if (hi2c->State == HAL_I2C_STATE_READY)
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2820              CMP      r0,#0x20
000016  d17d              BNE      |L26.276|
;;;1934     {
;;;1935       /* Wait until BUSY flag is reset */
;;;1936       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000018  4861              LDR      r0,|L26.416|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  2119              MOVS     r1,#0x19
00001e  fbb0f0f1          UDIV     r0,r0,r1
000022  f44f717a          MOV      r1,#0x3e8
000026  fbb0f0f1          UDIV     r0,r0,r1
00002a  eb0001c0          ADD      r1,r0,r0,LSL #3
00002e  eb011000          ADD      r0,r1,r0,LSL #4
000032  9000              STR      r0,[sp,#0]
;;;1937       do
000034  bf00              NOP      
                  |L26.54|
;;;1938       {
;;;1939         count--;
000036  9800              LDR      r0,[sp,#0]
000038  1e40              SUBS     r0,r0,#1
00003a  9000              STR      r0,[sp,#0]
;;;1940         if (count == 0U)
00003c  9800              LDR      r0,[sp,#0]
00003e  b998              CBNZ     r0,|L26.104|
;;;1941         {
;;;1942           hi2c->PreviousState       = I2C_STATE_NONE;
000040  2000              MOVS     r0,#0
000042  6320              STR      r0,[r4,#0x30]
;;;1943           hi2c->State               = HAL_I2C_STATE_READY;
000044  2020              MOVS     r0,#0x20
000046  f884003d          STRB     r0,[r4,#0x3d]
;;;1944           hi2c->Mode                = HAL_I2C_MODE_NONE;
00004a  2000              MOVS     r0,#0
00004c  f884003e          STRB     r0,[r4,#0x3e]
;;;1945           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000050  6c20              LDR      r0,[r4,#0x40]
000052  f0400020          ORR      r0,r0,#0x20
000056  6420              STR      r0,[r4,#0x40]
;;;1946   
;;;1947           /* Process Unlocked */
;;;1948           __HAL_UNLOCK(hi2c);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f884003c          STRB     r0,[r4,#0x3c]
000060  bf00              NOP      
;;;1949   
;;;1950           return HAL_ERROR;
000062  2001              MOVS     r0,#1
                  |L26.100|
;;;1951         }
;;;1952       }
;;;1953       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1954   
;;;1955       /* Process Locked */
;;;1956       __HAL_LOCK(hi2c);
;;;1957   
;;;1958       /* Check if the I2C is already enabled */
;;;1959       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1960       {
;;;1961         /* Enable I2C peripheral */
;;;1962         __HAL_I2C_ENABLE(hi2c);
;;;1963       }
;;;1964   
;;;1965       /* Disable Pos */
;;;1966       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1967   
;;;1968       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1969       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1970       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1971   
;;;1972       /* Prepare transfer parameters */
;;;1973       hi2c->pBuffPtr    = pData;
;;;1974       hi2c->XferCount   = Size;
;;;1975       hi2c->XferSize    = hi2c->XferCount;
;;;1976       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1977       hi2c->Devaddress  = DevAddress;
;;;1978   
;;;1979       if (hi2c->XferSize > 0U)
;;;1980       {
;;;1981         /* Set the I2C DMA transfer complete callback */
;;;1982         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;1983   
;;;1984         /* Set the DMA error callback */
;;;1985         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;1986   
;;;1987         /* Set the unused DMA callbacks to NULL */
;;;1988         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;1989         hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;1990         hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;1991         hi2c->hdmatx->XferAbortCallback = NULL;
;;;1992   
;;;1993         /* Enable the DMA stream */
;;;1994         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;1995   
;;;1996         if (dmaxferstatus == HAL_OK)
;;;1997         {
;;;1998           /* Enable Acknowledge */
;;;1999           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2000   
;;;2001           /* Generate Start */
;;;2002           SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2003   
;;;2004           /* Process Unlocked */
;;;2005           __HAL_UNLOCK(hi2c);
;;;2006   
;;;2007           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2008           to avoid the risk of I2C interrupt handle execution before current
;;;2009           process unlock */
;;;2010   
;;;2011           /* Enable EVT and ERR interrupt */
;;;2012           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2013   
;;;2014           /* Enable DMA Request */
;;;2015           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2016         }
;;;2017         else
;;;2018         {
;;;2019           /* Update I2C state */
;;;2020           hi2c->State     = HAL_I2C_STATE_READY;
;;;2021           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2022   
;;;2023           /* Update I2C error code */
;;;2024           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2025   
;;;2026           /* Process Unlocked */
;;;2027           __HAL_UNLOCK(hi2c);
;;;2028   
;;;2029           return HAL_ERROR;
;;;2030         }
;;;2031       }
;;;2032       else
;;;2033       {
;;;2034         /* Enable Acknowledge */
;;;2035         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2036   
;;;2037         /* Generate Start */
;;;2038         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2039   
;;;2040         /* Process Unlocked */
;;;2041         __HAL_UNLOCK(hi2c);
;;;2042   
;;;2043         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2044         to avoid the risk of I2C interrupt handle execution before current
;;;2045         process unlock */
;;;2046   
;;;2047         /* Enable EVT, BUF and ERR interrupt */
;;;2048         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2049       }
;;;2050   
;;;2051       return HAL_OK;
;;;2052     }
;;;2053     else
;;;2054     {
;;;2055       return HAL_BUSY;
;;;2056     }
;;;2057   }
000064  e8bd83f8          POP      {r3-r9,pc}
                  |L26.104|
000068  6820              LDR      r0,[r4,#0]            ;1953
00006a  6980              LDR      r0,[r0,#0x18]         ;1953
00006c  f3c00040          UBFX     r0,r0,#1,#1           ;1953
000070  2800              CMP      r0,#0                 ;1953
000072  d1e0              BNE      |L26.54|
000074  bf00              NOP                            ;1956
000076  f894003c          LDRB     r0,[r4,#0x3c]         ;1956
00007a  2801              CMP      r0,#1                 ;1956
00007c  d101              BNE      |L26.130|
00007e  2002              MOVS     r0,#2                 ;1956
000080  e7f0              B        |L26.100|
                  |L26.130|
000082  2001              MOVS     r0,#1                 ;1956
000084  f884003c          STRB     r0,[r4,#0x3c]         ;1956
000088  bf00              NOP                            ;1956
00008a  6820              LDR      r0,[r4,#0]            ;1959
00008c  6800              LDR      r0,[r0,#0]            ;1959
00008e  f0000001          AND      r0,r0,#1              ;1959
000092  b928              CBNZ     r0,|L26.160|
000094  6820              LDR      r0,[r4,#0]            ;1962
000096  6800              LDR      r0,[r0,#0]            ;1962
000098  f0400001          ORR      r0,r0,#1              ;1962
00009c  6821              LDR      r1,[r4,#0]            ;1962
00009e  6008              STR      r0,[r1,#0]            ;1962
                  |L26.160|
0000a0  6820              LDR      r0,[r4,#0]            ;1966
0000a2  6800              LDR      r0,[r0,#0]            ;1966
0000a4  f4206000          BIC      r0,r0,#0x800          ;1966
0000a8  6821              LDR      r1,[r4,#0]            ;1966
0000aa  6008              STR      r0,[r1,#0]            ;1966
0000ac  2021              MOVS     r0,#0x21              ;1968
0000ae  f884003d          STRB     r0,[r4,#0x3d]         ;1968
0000b2  2010              MOVS     r0,#0x10              ;1969
0000b4  f884003e          STRB     r0,[r4,#0x3e]         ;1969
0000b8  2000              MOVS     r0,#0                 ;1970
0000ba  6420              STR      r0,[r4,#0x40]         ;1970
0000bc  6267              STR      r7,[r4,#0x24]         ;1973
0000be  f8a4802a          STRH     r8,[r4,#0x2a]         ;1974
0000c2  8d60              LDRH     r0,[r4,#0x2a]         ;1975
0000c4  8520              STRH     r0,[r4,#0x28]         ;1975
0000c6  4837              LDR      r0,|L26.420|
0000c8  62e0              STR      r0,[r4,#0x2c]         ;1976
0000ca  6466              STR      r6,[r4,#0x44]         ;1977
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;1979
0000ce  2800              CMP      r0,#0                 ;1979
0000d0  d04a              BEQ      |L26.360|
0000d2  4835              LDR      r0,|L26.424|
0000d4  6b61              LDR      r1,[r4,#0x34]         ;1982
0000d6  63c8              STR      r0,[r1,#0x3c]         ;1982
0000d8  4834              LDR      r0,|L26.428|
0000da  6b61              LDR      r1,[r4,#0x34]         ;1985
0000dc  64c8              STR      r0,[r1,#0x4c]         ;1985
0000de  2000              MOVS     r0,#0                 ;1988
0000e0  6b61              LDR      r1,[r4,#0x34]         ;1988
0000e2  6408              STR      r0,[r1,#0x40]         ;1988
0000e4  6b61              LDR      r1,[r4,#0x34]         ;1989
0000e6  6448              STR      r0,[r1,#0x44]         ;1989
0000e8  6b61              LDR      r1,[r4,#0x34]         ;1990
0000ea  6488              STR      r0,[r1,#0x48]         ;1990
0000ec  6b61              LDR      r1,[r4,#0x34]         ;1991
0000ee  6508              STR      r0,[r1,#0x50]         ;1991
0000f0  8d23              LDRH     r3,[r4,#0x28]         ;1994
0000f2  f8d4c000          LDR      r12,[r4,#0]           ;1994
0000f6  f10c0210          ADD      r2,r12,#0x10          ;1994
0000fa  6a61              LDR      r1,[r4,#0x24]         ;1994
0000fc  6b60              LDR      r0,[r4,#0x34]         ;1994
0000fe  f7fffffe          BL       HAL_DMA_Start_IT
000102  4605              MOV      r5,r0                 ;1994
000104  b9fd              CBNZ     r5,|L26.326|
000106  6820              LDR      r0,[r4,#0]            ;1999
000108  6800              LDR      r0,[r0,#0]            ;1999
00010a  f4406080          ORR      r0,r0,#0x400          ;1999
00010e  6821              LDR      r1,[r4,#0]            ;1999
000110  6008              STR      r0,[r1,#0]            ;1999
000112  e000              B        |L26.278|
                  |L26.276|
000114  e041              B        |L26.410|
                  |L26.278|
000116  6820              LDR      r0,[r4,#0]            ;2002
000118  6800              LDR      r0,[r0,#0]            ;2002
00011a  f4407080          ORR      r0,r0,#0x100          ;2002
00011e  6821              LDR      r1,[r4,#0]            ;2002
000120  6008              STR      r0,[r1,#0]            ;2002
000122  bf00              NOP                            ;2005
000124  2000              MOVS     r0,#0                 ;2005
000126  f884003c          STRB     r0,[r4,#0x3c]         ;2005
00012a  bf00              NOP                            ;2005
00012c  6820              LDR      r0,[r4,#0]            ;2012
00012e  6840              LDR      r0,[r0,#4]            ;2012
000130  f4407040          ORR      r0,r0,#0x300          ;2012
000134  6821              LDR      r1,[r4,#0]            ;2012
000136  6048              STR      r0,[r1,#4]            ;2012
000138  6820              LDR      r0,[r4,#0]            ;2015
00013a  6840              LDR      r0,[r0,#4]            ;2015
00013c  f4406000          ORR      r0,r0,#0x800          ;2015
000140  6821              LDR      r1,[r4,#0]            ;2015
000142  6048              STR      r0,[r1,#4]            ;2015
000144  e027              B        |L26.406|
                  |L26.326|
000146  2020              MOVS     r0,#0x20              ;2020
000148  f884003d          STRB     r0,[r4,#0x3d]         ;2020
00014c  2000              MOVS     r0,#0                 ;2021
00014e  f884003e          STRB     r0,[r4,#0x3e]         ;2021
000152  6c20              LDR      r0,[r4,#0x40]         ;2024
000154  f0400010          ORR      r0,r0,#0x10           ;2024
000158  6420              STR      r0,[r4,#0x40]         ;2024
00015a  bf00              NOP                            ;2027
00015c  2000              MOVS     r0,#0                 ;2027
00015e  f884003c          STRB     r0,[r4,#0x3c]         ;2027
000162  bf00              NOP                            ;2027
000164  2001              MOVS     r0,#1                 ;2029
000166  e77d              B        |L26.100|
                  |L26.360|
000168  6820              LDR      r0,[r4,#0]            ;2035
00016a  6800              LDR      r0,[r0,#0]            ;2035
00016c  f4406080          ORR      r0,r0,#0x400          ;2035
000170  6821              LDR      r1,[r4,#0]            ;2035
000172  6008              STR      r0,[r1,#0]            ;2035
000174  6820              LDR      r0,[r4,#0]            ;2038
000176  6800              LDR      r0,[r0,#0]            ;2038
000178  f4407080          ORR      r0,r0,#0x100          ;2038
00017c  6821              LDR      r1,[r4,#0]            ;2038
00017e  6008              STR      r0,[r1,#0]            ;2038
000180  bf00              NOP                            ;2041
000182  2000              MOVS     r0,#0                 ;2041
000184  f884003c          STRB     r0,[r4,#0x3c]         ;2041
000188  bf00              NOP                            ;2041
00018a  6820              LDR      r0,[r4,#0]            ;2048
00018c  6840              LDR      r0,[r0,#4]            ;2048
00018e  f44060e0          ORR      r0,r0,#0x700          ;2048
000192  6821              LDR      r1,[r4,#0]            ;2048
000194  6048              STR      r0,[r1,#4]            ;2048
                  |L26.406|
000196  2000              MOVS     r0,#0                 ;2051
000198  e764              B        |L26.100|
                  |L26.410|
00019a  2002              MOVS     r0,#2                 ;2055
00019c  e762              B        |L26.100|
;;;2058   
                          ENDP

00019e  0000              DCW      0x0000
                  |L26.416|
                          DCD      SystemCoreClock
                  |L26.420|
                          DCD      0xffff0000
                  |L26.424|
                          DCD      I2C_DMAXferCplt
                  |L26.428|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_IT PROC
;;;1639     */
;;;1640   HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;1641   {
000002  4604              MOV      r4,r0
;;;1642     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1643   
;;;1644     if (hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d16a              BNE      |L27.230|
;;;1645     {
;;;1646       /* Wait until BUSY flag is reset */
;;;1647       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000010  4836              LDR      r0,|L27.236|
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  2519              MOVS     r5,#0x19
000016  fbb0f0f5          UDIV     r0,r0,r5
00001a  f44f757a          MOV      r5,#0x3e8
00001e  fbb0f0f5          UDIV     r0,r0,r5
000022  eb0005c0          ADD      r5,r0,r0,LSL #3
000026  eb051000          ADD      r0,r5,r0,LSL #4
00002a  9000              STR      r0,[sp,#0]
;;;1648       do
00002c  bf00              NOP      
                  |L27.46|
;;;1649       {
;;;1650         count--;
00002e  9800              LDR      r0,[sp,#0]
000030  1e40              SUBS     r0,r0,#1
000032  9000              STR      r0,[sp,#0]
;;;1651         if (count == 0U)
000034  9800              LDR      r0,[sp,#0]
000036  b990              CBNZ     r0,|L27.94|
;;;1652         {
;;;1653           hi2c->PreviousState       = I2C_STATE_NONE;
000038  2000              MOVS     r0,#0
00003a  6320              STR      r0,[r4,#0x30]
;;;1654           hi2c->State               = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;1655           hi2c->Mode                = HAL_I2C_MODE_NONE;
000042  2000              MOVS     r0,#0
000044  f884003e          STRB     r0,[r4,#0x3e]
;;;1656           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
000048  6c20              LDR      r0,[r4,#0x40]
00004a  f0400020          ORR      r0,r0,#0x20
00004e  6420              STR      r0,[r4,#0x40]
;;;1657   
;;;1658           /* Process Unlocked */
;;;1659           __HAL_UNLOCK(hi2c);
000050  bf00              NOP      
000052  2000              MOVS     r0,#0
000054  f884003c          STRB     r0,[r4,#0x3c]
000058  bf00              NOP      
;;;1660   
;;;1661           return HAL_ERROR;
00005a  2001              MOVS     r0,#1
                  |L27.92|
;;;1662         }
;;;1663       }
;;;1664       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1665   
;;;1666       /* Process Locked */
;;;1667       __HAL_LOCK(hi2c);
;;;1668   
;;;1669       /* Check if the I2C is already enabled */
;;;1670       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1671       {
;;;1672         /* Enable I2C peripheral */
;;;1673         __HAL_I2C_ENABLE(hi2c);
;;;1674       }
;;;1675   
;;;1676       /* Disable Pos */
;;;1677       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1678   
;;;1679       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1680       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1681       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1682   
;;;1683       /* Prepare transfer parameters */
;;;1684       hi2c->pBuffPtr    = pData;
;;;1685       hi2c->XferCount   = Size;
;;;1686       hi2c->XferSize    = hi2c->XferCount;
;;;1687       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1688       hi2c->Devaddress  = DevAddress;
;;;1689   
;;;1690       /* Generate Start */
;;;1691       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;1692   
;;;1693       /* Process Unlocked */
;;;1694       __HAL_UNLOCK(hi2c);
;;;1695   
;;;1696       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1697                 to avoid the risk of I2C interrupt handle execution before current
;;;1698                 process unlock */
;;;1699       /* Enable EVT, BUF and ERR interrupt */
;;;1700       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1701   
;;;1702       return HAL_OK;
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       return HAL_BUSY;
;;;1707     }
;;;1708   }
00005c  bd38              POP      {r3-r5,pc}
                  |L27.94|
00005e  6820              LDR      r0,[r4,#0]            ;1664
000060  6980              LDR      r0,[r0,#0x18]         ;1664
000062  f3c00040          UBFX     r0,r0,#1,#1           ;1664
000066  2800              CMP      r0,#0                 ;1664
000068  d1e1              BNE      |L27.46|
00006a  bf00              NOP                            ;1667
00006c  f894003c          LDRB     r0,[r4,#0x3c]         ;1667
000070  2801              CMP      r0,#1                 ;1667
000072  d101              BNE      |L27.120|
000074  2002              MOVS     r0,#2                 ;1667
000076  e7f1              B        |L27.92|
                  |L27.120|
000078  2001              MOVS     r0,#1                 ;1667
00007a  f884003c          STRB     r0,[r4,#0x3c]         ;1667
00007e  bf00              NOP                            ;1667
000080  6820              LDR      r0,[r4,#0]            ;1670
000082  6800              LDR      r0,[r0,#0]            ;1670
000084  f0000001          AND      r0,r0,#1              ;1670
000088  b928              CBNZ     r0,|L27.150|
00008a  6820              LDR      r0,[r4,#0]            ;1673
00008c  6800              LDR      r0,[r0,#0]            ;1673
00008e  f0400001          ORR      r0,r0,#1              ;1673
000092  6825              LDR      r5,[r4,#0]            ;1673
000094  6028              STR      r0,[r5,#0]            ;1673
                  |L27.150|
000096  6820              LDR      r0,[r4,#0]            ;1677
000098  6800              LDR      r0,[r0,#0]            ;1677
00009a  f4206000          BIC      r0,r0,#0x800          ;1677
00009e  6825              LDR      r5,[r4,#0]            ;1677
0000a0  6028              STR      r0,[r5,#0]            ;1677
0000a2  2021              MOVS     r0,#0x21              ;1679
0000a4  f884003d          STRB     r0,[r4,#0x3d]         ;1679
0000a8  2010              MOVS     r0,#0x10              ;1680
0000aa  f884003e          STRB     r0,[r4,#0x3e]         ;1680
0000ae  2000              MOVS     r0,#0                 ;1681
0000b0  6420              STR      r0,[r4,#0x40]         ;1681
0000b2  6262              STR      r2,[r4,#0x24]         ;1684
0000b4  8563              STRH     r3,[r4,#0x2a]         ;1685
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;1686
0000b8  8520              STRH     r0,[r4,#0x28]         ;1686
0000ba  480d              LDR      r0,|L27.240|
0000bc  62e0              STR      r0,[r4,#0x2c]         ;1687
0000be  6461              STR      r1,[r4,#0x44]         ;1688
0000c0  6820              LDR      r0,[r4,#0]            ;1691
0000c2  6800              LDR      r0,[r0,#0]            ;1691
0000c4  f4407080          ORR      r0,r0,#0x100          ;1691
0000c8  6825              LDR      r5,[r4,#0]            ;1691
0000ca  6028              STR      r0,[r5,#0]            ;1691
0000cc  bf00              NOP                            ;1694
0000ce  2000              MOVS     r0,#0                 ;1694
0000d0  f884003c          STRB     r0,[r4,#0x3c]         ;1694
0000d4  bf00              NOP                            ;1694
0000d6  6820              LDR      r0,[r4,#0]            ;1700
0000d8  6840              LDR      r0,[r0,#4]            ;1700
0000da  f44060e0          ORR      r0,r0,#0x700          ;1700
0000de  6825              LDR      r5,[r4,#0]            ;1700
0000e0  6068              STR      r0,[r5,#4]            ;1700
0000e2  2000              MOVS     r0,#0                 ;1702
0000e4  e7ba              B        |L27.92|
                  |L27.230|
0000e6  2002              MOVS     r0,#2                 ;1706
0000e8  e7b8              B        |L27.92|
;;;1709   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L27.236|
                          DCD      SystemCoreClock
                  |L27.240|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_MemRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemRxCpltCallback PROC
;;;4881     */
;;;4882   __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4883   {
;;;4884     /* Prevent unused argument(s) compilation warning */
;;;4885     UNUSED(hi2c);
;;;4886   
;;;4887     /* NOTE : This function should not be modified, when the callback is needed,
;;;4888               the HAL_I2C_MemRxCpltCallback could be implemented in the user file
;;;4889      */
;;;4890   }
;;;4891   
                          ENDP


                          AREA ||i.HAL_I2C_MemTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemTxCpltCallback PROC
;;;4865     */
;;;4866   __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4867   {
;;;4868     /* Prevent unused argument(s) compilation warning */
;;;4869     UNUSED(hi2c);
;;;4870   
;;;4871     /* NOTE : This function should not be modified, when the callback is needed,
;;;4872               the HAL_I2C_MemTxCpltCallback could be implemented in the user file
;;;4873      */
;;;4874   }
;;;4875   
                          ENDP


                          AREA ||i.HAL_I2C_Mem_Read||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read PROC
;;;2529     */
;;;2530   HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2531   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000010  9e0e              LDR      r6,[sp,#0x38]
;;;2532     /* Init tickstart for timeout management*/
;;;2533     uint32_t tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;2534   
;;;2535     /* Check the parameters */
;;;2536     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2537   
;;;2538     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d170              BNE      |L30.258|
;;;2539     {
;;;2540       /* Wait until BUSY flag is reset */
;;;2541       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
000020  2319              MOVS     r3,#0x19
000022  2201              MOVS     r2,#1
000024  49b0              LDR      r1,|L30.744|
000026  4620              MOV      r0,r4
000028  9500              STR      r5,[sp,#0]
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  b110              CBZ      r0,|L30.54|
;;;2542       {
;;;2543         return HAL_BUSY;
000030  2002              MOVS     r0,#2
                  |L30.50|
;;;2544       }
;;;2545   
;;;2546       /* Process Locked */
;;;2547       __HAL_LOCK(hi2c);
;;;2548   
;;;2549       /* Check if the I2C is already enabled */
;;;2550       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2551       {
;;;2552         /* Enable I2C peripheral */
;;;2553         __HAL_I2C_ENABLE(hi2c);
;;;2554       }
;;;2555   
;;;2556       /* Disable Pos */
;;;2557       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2558   
;;;2559       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2560       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2561       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2562   
;;;2563       /* Prepare transfer parameters */
;;;2564       hi2c->pBuffPtr    = pData;
;;;2565       hi2c->XferCount   = Size;
;;;2566       hi2c->XferSize    = hi2c->XferCount;
;;;2567       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2568   
;;;2569       /* Send Slave Address and Memory Address */
;;;2570       if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2571       {
;;;2572         return HAL_ERROR;
;;;2573       }
;;;2574   
;;;2575       if (hi2c->XferSize == 0U)
;;;2576       {
;;;2577         /* Clear ADDR flag */
;;;2578         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2579   
;;;2580         /* Generate Stop */
;;;2581         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2582       }
;;;2583       else if (hi2c->XferSize == 1U)
;;;2584       {
;;;2585         /* Disable Acknowledge */
;;;2586         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2587   
;;;2588         /* Clear ADDR flag */
;;;2589         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2590   
;;;2591         /* Generate Stop */
;;;2592         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2593       }
;;;2594       else if (hi2c->XferSize == 2U)
;;;2595       {
;;;2596         /* Disable Acknowledge */
;;;2597         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2598   
;;;2599         /* Enable Pos */
;;;2600         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2601   
;;;2602         /* Clear ADDR flag */
;;;2603         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2604       }
;;;2605       else
;;;2606       {
;;;2607         /* Clear ADDR flag */
;;;2608         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2609       }
;;;2610   
;;;2611       while (hi2c->XferSize > 0U)
;;;2612       {
;;;2613         if (hi2c->XferSize <= 3U)
;;;2614         {
;;;2615           /* One byte */
;;;2616           if (hi2c->XferSize == 1U)
;;;2617           {
;;;2618             /* Wait until RXNE flag is set */
;;;2619             if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2620             {
;;;2621               return HAL_ERROR;
;;;2622             }
;;;2623   
;;;2624             /* Read data from DR */
;;;2625             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2626   
;;;2627             /* Increment Buffer pointer */
;;;2628             hi2c->pBuffPtr++;
;;;2629   
;;;2630             /* Update counter */
;;;2631             hi2c->XferSize--;
;;;2632             hi2c->XferCount--;
;;;2633           }
;;;2634           /* Two bytes */
;;;2635           else if (hi2c->XferSize == 2U)
;;;2636           {
;;;2637             /* Wait until BTF flag is set */
;;;2638             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2639             {
;;;2640               return HAL_ERROR;
;;;2641             }
;;;2642   
;;;2643             /* Generate Stop */
;;;2644             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2645   
;;;2646             /* Read data from DR */
;;;2647             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2648   
;;;2649             /* Increment Buffer pointer */
;;;2650             hi2c->pBuffPtr++;
;;;2651   
;;;2652             /* Update counter */
;;;2653             hi2c->XferSize--;
;;;2654             hi2c->XferCount--;
;;;2655   
;;;2656             /* Read data from DR */
;;;2657             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2658   
;;;2659             /* Increment Buffer pointer */
;;;2660             hi2c->pBuffPtr++;
;;;2661   
;;;2662             /* Update counter */
;;;2663             hi2c->XferSize--;
;;;2664             hi2c->XferCount--;
;;;2665           }
;;;2666           /* 3 Last bytes */
;;;2667           else
;;;2668           {
;;;2669             /* Wait until BTF flag is set */
;;;2670             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2671             {
;;;2672               return HAL_ERROR;
;;;2673             }
;;;2674   
;;;2675             /* Disable Acknowledge */
;;;2676             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2677   
;;;2678             /* Read data from DR */
;;;2679             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2680   
;;;2681             /* Increment Buffer pointer */
;;;2682             hi2c->pBuffPtr++;
;;;2683   
;;;2684             /* Update counter */
;;;2685             hi2c->XferSize--;
;;;2686             hi2c->XferCount--;
;;;2687   
;;;2688             /* Wait until BTF flag is set */
;;;2689             if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2690             {
;;;2691               return HAL_ERROR;
;;;2692             }
;;;2693   
;;;2694             /* Generate Stop */
;;;2695             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2696   
;;;2697             /* Read data from DR */
;;;2698             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2699   
;;;2700             /* Increment Buffer pointer */
;;;2701             hi2c->pBuffPtr++;
;;;2702   
;;;2703             /* Update counter */
;;;2704             hi2c->XferSize--;
;;;2705             hi2c->XferCount--;
;;;2706   
;;;2707             /* Read data from DR */
;;;2708             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2709   
;;;2710             /* Increment Buffer pointer */
;;;2711             hi2c->pBuffPtr++;
;;;2712   
;;;2713             /* Update counter */
;;;2714             hi2c->XferSize--;
;;;2715             hi2c->XferCount--;
;;;2716           }
;;;2717         }
;;;2718         else
;;;2719         {
;;;2720           /* Wait until RXNE flag is set */
;;;2721           if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2722           {
;;;2723             return HAL_ERROR;
;;;2724           }
;;;2725   
;;;2726           /* Read data from DR */
;;;2727           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2728   
;;;2729           /* Increment Buffer pointer */
;;;2730           hi2c->pBuffPtr++;
;;;2731   
;;;2732           /* Update counter */
;;;2733           hi2c->XferSize--;
;;;2734           hi2c->XferCount--;
;;;2735   
;;;2736           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;2737           {
;;;2738             /* Read data from DR */
;;;2739             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;2740   
;;;2741             /* Increment Buffer pointer */
;;;2742             hi2c->pBuffPtr++;
;;;2743   
;;;2744             /* Update counter */
;;;2745             hi2c->XferSize--;
;;;2746             hi2c->XferCount--;
;;;2747           }
;;;2748         }
;;;2749       }
;;;2750   
;;;2751       hi2c->State = HAL_I2C_STATE_READY;
;;;2752       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2753   
;;;2754       /* Process Unlocked */
;;;2755       __HAL_UNLOCK(hi2c);
;;;2756   
;;;2757       return HAL_OK;
;;;2758     }
;;;2759     else
;;;2760     {
;;;2761       return HAL_BUSY;
;;;2762     }
;;;2763   }
000032  e8bd9ffc          POP      {r2-r12,pc}
                  |L30.54|
000036  bf00              NOP                            ;2547
000038  f894003c          LDRB     r0,[r4,#0x3c]         ;2547
00003c  2801              CMP      r0,#1                 ;2547
00003e  d101              BNE      |L30.68|
000040  2002              MOVS     r0,#2                 ;2547
000042  e7f6              B        |L30.50|
                  |L30.68|
000044  2001              MOVS     r0,#1                 ;2547
000046  f884003c          STRB     r0,[r4,#0x3c]         ;2547
00004a  bf00              NOP                            ;2547
00004c  6820              LDR      r0,[r4,#0]            ;2550
00004e  6800              LDR      r0,[r0,#0]            ;2550
000050  f0000001          AND      r0,r0,#1              ;2550
000054  b928              CBNZ     r0,|L30.98|
000056  6820              LDR      r0,[r4,#0]            ;2553
000058  6800              LDR      r0,[r0,#0]            ;2553
00005a  f0400001          ORR      r0,r0,#1              ;2553
00005e  6821              LDR      r1,[r4,#0]            ;2553
000060  6008              STR      r0,[r1,#0]            ;2553
                  |L30.98|
000062  6820              LDR      r0,[r4,#0]            ;2557
000064  6800              LDR      r0,[r0,#0]            ;2557
000066  f4206000          BIC      r0,r0,#0x800          ;2557
00006a  6821              LDR      r1,[r4,#0]            ;2557
00006c  6008              STR      r0,[r1,#0]            ;2557
00006e  2022              MOVS     r0,#0x22              ;2559
000070  f884003d          STRB     r0,[r4,#0x3d]         ;2559
000074  2040              MOVS     r0,#0x40              ;2560
000076  f884003e          STRB     r0,[r4,#0x3e]         ;2560
00007a  2000              MOVS     r0,#0                 ;2561
00007c  6420              STR      r0,[r4,#0x40]         ;2561
00007e  f8c4a024          STR      r10,[r4,#0x24]        ;2564
000082  f8a4b02a          STRH     r11,[r4,#0x2a]        ;2565
000086  8d60              LDRH     r0,[r4,#0x2a]         ;2566
000088  8520              STRH     r0,[r4,#0x28]         ;2566
00008a  4898              LDR      r0,|L30.748|
00008c  62e0              STR      r0,[r4,#0x2c]         ;2567
00008e  464b              MOV      r3,r9                 ;2570
000090  4642              MOV      r2,r8                 ;2570
000092  4639              MOV      r1,r7                 ;2570
000094  4620              MOV      r0,r4                 ;2570
000096  e9cd6500          STRD     r6,r5,[sp,#0]         ;2570
00009a  f7fffffe          BL       I2C_RequestMemoryRead
00009e  b108              CBZ      r0,|L30.164|
0000a0  2001              MOVS     r0,#1                 ;2572
0000a2  e7c6              B        |L30.50|
                  |L30.164|
0000a4  8d20              LDRH     r0,[r4,#0x28]         ;2575
0000a6  b988              CBNZ     r0,|L30.204|
0000a8  bf00              NOP                            ;2578
0000aa  2000              MOVS     r0,#0                 ;2578
0000ac  9001              STR      r0,[sp,#4]            ;2578
0000ae  6820              LDR      r0,[r4,#0]            ;2578
0000b0  6940              LDR      r0,[r0,#0x14]         ;2578
0000b2  9001              STR      r0,[sp,#4]            ;2578
0000b4  6820              LDR      r0,[r4,#0]            ;2578
0000b6  6980              LDR      r0,[r0,#0x18]         ;2578
0000b8  9001              STR      r0,[sp,#4]            ;2578
0000ba  bf00              NOP                            ;2578
0000bc  bf00              NOP                            ;2578
0000be  6820              LDR      r0,[r4,#0]            ;2581
0000c0  6800              LDR      r0,[r0,#0]            ;2581
0000c2  f4407000          ORR      r0,r0,#0x200          ;2581
0000c6  6821              LDR      r1,[r4,#0]            ;2581
0000c8  6008              STR      r0,[r1,#0]            ;2581
0000ca  e040              B        |L30.334|
                  |L30.204|
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;2583
0000ce  2801              CMP      r0,#1                 ;2583
0000d0  d118              BNE      |L30.260|
0000d2  6820              LDR      r0,[r4,#0]            ;2586
0000d4  6800              LDR      r0,[r0,#0]            ;2586
0000d6  f4206080          BIC      r0,r0,#0x400          ;2586
0000da  6821              LDR      r1,[r4,#0]            ;2586
0000dc  6008              STR      r0,[r1,#0]            ;2586
0000de  bf00              NOP                            ;2589
0000e0  2000              MOVS     r0,#0                 ;2589
0000e2  9001              STR      r0,[sp,#4]            ;2589
0000e4  6820              LDR      r0,[r4,#0]            ;2589
0000e6  6940              LDR      r0,[r0,#0x14]         ;2589
0000e8  9001              STR      r0,[sp,#4]            ;2589
0000ea  6820              LDR      r0,[r4,#0]            ;2589
0000ec  6980              LDR      r0,[r0,#0x18]         ;2589
0000ee  9001              STR      r0,[sp,#4]            ;2589
0000f0  bf00              NOP                            ;2589
0000f2  bf00              NOP                            ;2589
0000f4  6820              LDR      r0,[r4,#0]            ;2592
0000f6  6800              LDR      r0,[r0,#0]            ;2592
0000f8  f4407000          ORR      r0,r0,#0x200          ;2592
0000fc  6821              LDR      r1,[r4,#0]            ;2592
0000fe  6008              STR      r0,[r1,#0]            ;2592
000100  e025              B        |L30.334|
                  |L30.258|
000102  e0ef              B        |L30.740|
                  |L30.260|
000104  8d20              LDRH     r0,[r4,#0x28]         ;2594
000106  2802              CMP      r0,#2                 ;2594
000108  d116              BNE      |L30.312|
00010a  6820              LDR      r0,[r4,#0]            ;2597
00010c  6800              LDR      r0,[r0,#0]            ;2597
00010e  f4206080          BIC      r0,r0,#0x400          ;2597
000112  6821              LDR      r1,[r4,#0]            ;2597
000114  6008              STR      r0,[r1,#0]            ;2597
000116  6820              LDR      r0,[r4,#0]            ;2600
000118  6800              LDR      r0,[r0,#0]            ;2600
00011a  f4406000          ORR      r0,r0,#0x800          ;2600
00011e  6821              LDR      r1,[r4,#0]            ;2600
000120  6008              STR      r0,[r1,#0]            ;2600
000122  bf00              NOP                            ;2603
000124  2000              MOVS     r0,#0                 ;2603
000126  9001              STR      r0,[sp,#4]            ;2603
000128  6820              LDR      r0,[r4,#0]            ;2603
00012a  6940              LDR      r0,[r0,#0x14]         ;2603
00012c  9001              STR      r0,[sp,#4]            ;2603
00012e  6820              LDR      r0,[r4,#0]            ;2603
000130  6980              LDR      r0,[r0,#0x18]         ;2603
000132  9001              STR      r0,[sp,#4]            ;2603
000134  bf00              NOP                            ;2603
000136  e00a              B        |L30.334|
                  |L30.312|
000138  bf00              NOP                            ;2608
00013a  2000              MOVS     r0,#0                 ;2608
00013c  9001              STR      r0,[sp,#4]            ;2608
00013e  6820              LDR      r0,[r4,#0]            ;2608
000140  6940              LDR      r0,[r0,#0x14]         ;2608
000142  9001              STR      r0,[sp,#4]            ;2608
000144  6820              LDR      r0,[r4,#0]            ;2608
000146  6980              LDR      r0,[r0,#0x18]         ;2608
000148  9001              STR      r0,[sp,#4]            ;2608
00014a  bf00              NOP                            ;2608
00014c  bf00              NOP                            ;2608
                  |L30.334|
00014e  e0ba              B        |L30.710|
                  |L30.336|
000150  8d20              LDRH     r0,[r4,#0x28]         ;2613
000152  2803              CMP      r0,#3                 ;2613
000154  d87e              BHI      |L30.596|
000156  8d20              LDRH     r0,[r4,#0x28]         ;2616
000158  2801              CMP      r0,#1                 ;2616
00015a  d115              BNE      |L30.392|
00015c  462a              MOV      r2,r5                 ;2619
00015e  4631              MOV      r1,r6                 ;2619
000160  4620              MOV      r0,r4                 ;2619
000162  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000166  b108              CBZ      r0,|L30.364|
000168  2001              MOVS     r0,#1                 ;2621
00016a  e762              B        |L30.50|
                  |L30.364|
00016c  6820              LDR      r0,[r4,#0]            ;2625
00016e  6900              LDR      r0,[r0,#0x10]         ;2625
000170  6a61              LDR      r1,[r4,#0x24]         ;2625
000172  7008              STRB     r0,[r1,#0]            ;2625
000174  6a60              LDR      r0,[r4,#0x24]         ;2628
000176  1c40              ADDS     r0,r0,#1              ;2628
000178  6260              STR      r0,[r4,#0x24]         ;2628
00017a  8d20              LDRH     r0,[r4,#0x28]         ;2631
00017c  1e40              SUBS     r0,r0,#1              ;2631
00017e  8520              STRH     r0,[r4,#0x28]         ;2631
000180  8d60              LDRH     r0,[r4,#0x2a]         ;2632
000182  1e40              SUBS     r0,r0,#1              ;2632
000184  8560              STRH     r0,[r4,#0x2a]         ;2632
000186  e09e              B        |L30.710|
                  |L30.392|
000188  8d20              LDRH     r0,[r4,#0x28]         ;2635
00018a  2802              CMP      r0,#2                 ;2635
00018c  d12a              BNE      |L30.484|
00018e  4633              MOV      r3,r6                 ;2638
000190  2200              MOVS     r2,#0                 ;2638
000192  4957              LDR      r1,|L30.752|
000194  4620              MOV      r0,r4                 ;2638
000196  9500              STR      r5,[sp,#0]            ;2638
000198  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00019c  b108              CBZ      r0,|L30.418|
00019e  2001              MOVS     r0,#1                 ;2640
0001a0  e747              B        |L30.50|
                  |L30.418|
0001a2  6820              LDR      r0,[r4,#0]            ;2644
0001a4  6800              LDR      r0,[r0,#0]            ;2644
0001a6  f4407000          ORR      r0,r0,#0x200          ;2644
0001aa  6821              LDR      r1,[r4,#0]            ;2644
0001ac  6008              STR      r0,[r1,#0]            ;2644
0001ae  6820              LDR      r0,[r4,#0]            ;2647
0001b0  6900              LDR      r0,[r0,#0x10]         ;2647
0001b2  6a61              LDR      r1,[r4,#0x24]         ;2647
0001b4  7008              STRB     r0,[r1,#0]            ;2647
0001b6  6a60              LDR      r0,[r4,#0x24]         ;2650
0001b8  1c40              ADDS     r0,r0,#1              ;2650
0001ba  6260              STR      r0,[r4,#0x24]         ;2650
0001bc  8d20              LDRH     r0,[r4,#0x28]         ;2653
0001be  1e40              SUBS     r0,r0,#1              ;2653
0001c0  8520              STRH     r0,[r4,#0x28]         ;2653
0001c2  8d60              LDRH     r0,[r4,#0x2a]         ;2654
0001c4  1e40              SUBS     r0,r0,#1              ;2654
0001c6  8560              STRH     r0,[r4,#0x2a]         ;2654
0001c8  6820              LDR      r0,[r4,#0]            ;2657
0001ca  6900              LDR      r0,[r0,#0x10]         ;2657
0001cc  6a61              LDR      r1,[r4,#0x24]         ;2657
0001ce  7008              STRB     r0,[r1,#0]            ;2657
0001d0  6a60              LDR      r0,[r4,#0x24]         ;2660
0001d2  1c40              ADDS     r0,r0,#1              ;2660
0001d4  6260              STR      r0,[r4,#0x24]         ;2660
0001d6  8d20              LDRH     r0,[r4,#0x28]         ;2663
0001d8  1e40              SUBS     r0,r0,#1              ;2663
0001da  8520              STRH     r0,[r4,#0x28]         ;2663
0001dc  8d60              LDRH     r0,[r4,#0x2a]         ;2664
0001de  1e40              SUBS     r0,r0,#1              ;2664
0001e0  8560              STRH     r0,[r4,#0x2a]         ;2664
0001e2  e070              B        |L30.710|
                  |L30.484|
0001e4  4633              MOV      r3,r6                 ;2670
0001e6  2200              MOVS     r2,#0                 ;2670
0001e8  4941              LDR      r1,|L30.752|
0001ea  4620              MOV      r0,r4                 ;2670
0001ec  9500              STR      r5,[sp,#0]            ;2670
0001ee  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001f2  b108              CBZ      r0,|L30.504|
0001f4  2001              MOVS     r0,#1                 ;2672
0001f6  e71c              B        |L30.50|
                  |L30.504|
0001f8  6820              LDR      r0,[r4,#0]            ;2676
0001fa  6800              LDR      r0,[r0,#0]            ;2676
0001fc  f4206080          BIC      r0,r0,#0x400          ;2676
000200  6821              LDR      r1,[r4,#0]            ;2676
000202  6008              STR      r0,[r1,#0]            ;2676
000204  6820              LDR      r0,[r4,#0]            ;2679
000206  6900              LDR      r0,[r0,#0x10]         ;2679
000208  6a61              LDR      r1,[r4,#0x24]         ;2679
00020a  7008              STRB     r0,[r1,#0]            ;2679
00020c  6a60              LDR      r0,[r4,#0x24]         ;2682
00020e  1c40              ADDS     r0,r0,#1              ;2682
000210  6260              STR      r0,[r4,#0x24]         ;2682
000212  8d20              LDRH     r0,[r4,#0x28]         ;2685
000214  1e40              SUBS     r0,r0,#1              ;2685
000216  8520              STRH     r0,[r4,#0x28]         ;2685
000218  8d60              LDRH     r0,[r4,#0x2a]         ;2686
00021a  1e40              SUBS     r0,r0,#1              ;2686
00021c  8560              STRH     r0,[r4,#0x2a]         ;2686
00021e  4633              MOV      r3,r6                 ;2689
000220  2200              MOVS     r2,#0                 ;2689
000222  4933              LDR      r1,|L30.752|
000224  4620              MOV      r0,r4                 ;2689
000226  9500              STR      r5,[sp,#0]            ;2689
000228  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00022c  b108              CBZ      r0,|L30.562|
00022e  2001              MOVS     r0,#1                 ;2691
000230  e6ff              B        |L30.50|
                  |L30.562|
000232  6820              LDR      r0,[r4,#0]            ;2695
000234  6800              LDR      r0,[r0,#0]            ;2695
000236  f4407000          ORR      r0,r0,#0x200          ;2695
00023a  6821              LDR      r1,[r4,#0]            ;2695
00023c  6008              STR      r0,[r1,#0]            ;2695
00023e  6820              LDR      r0,[r4,#0]            ;2698
000240  6900              LDR      r0,[r0,#0x10]         ;2698
000242  6a61              LDR      r1,[r4,#0x24]         ;2698
000244  7008              STRB     r0,[r1,#0]            ;2698
000246  6a60              LDR      r0,[r4,#0x24]         ;2701
000248  1c40              ADDS     r0,r0,#1              ;2701
00024a  6260              STR      r0,[r4,#0x24]         ;2701
00024c  8d20              LDRH     r0,[r4,#0x28]         ;2704
00024e  1e40              SUBS     r0,r0,#1              ;2704
000250  8520              STRH     r0,[r4,#0x28]         ;2704
000252  e000              B        |L30.598|
                  |L30.596|
000254  e010              B        |L30.632|
                  |L30.598|
000256  8d60              LDRH     r0,[r4,#0x2a]         ;2705
000258  1e40              SUBS     r0,r0,#1              ;2705
00025a  8560              STRH     r0,[r4,#0x2a]         ;2705
00025c  6820              LDR      r0,[r4,#0]            ;2708
00025e  6900              LDR      r0,[r0,#0x10]         ;2708
000260  6a61              LDR      r1,[r4,#0x24]         ;2708
000262  7008              STRB     r0,[r1,#0]            ;2708
000264  6a60              LDR      r0,[r4,#0x24]         ;2711
000266  1c40              ADDS     r0,r0,#1              ;2711
000268  6260              STR      r0,[r4,#0x24]         ;2711
00026a  8d20              LDRH     r0,[r4,#0x28]         ;2714
00026c  1e40              SUBS     r0,r0,#1              ;2714
00026e  8520              STRH     r0,[r4,#0x28]         ;2714
000270  8d60              LDRH     r0,[r4,#0x2a]         ;2715
000272  1e40              SUBS     r0,r0,#1              ;2715
000274  8560              STRH     r0,[r4,#0x2a]         ;2715
000276  e026              B        |L30.710|
                  |L30.632|
000278  462a              MOV      r2,r5                 ;2721
00027a  4631              MOV      r1,r6                 ;2721
00027c  4620              MOV      r0,r4                 ;2721
00027e  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000282  b108              CBZ      r0,|L30.648|
000284  2001              MOVS     r0,#1                 ;2723
000286  e6d4              B        |L30.50|
                  |L30.648|
000288  6820              LDR      r0,[r4,#0]            ;2727
00028a  6900              LDR      r0,[r0,#0x10]         ;2727
00028c  6a61              LDR      r1,[r4,#0x24]         ;2727
00028e  7008              STRB     r0,[r1,#0]            ;2727
000290  6a60              LDR      r0,[r4,#0x24]         ;2730
000292  1c40              ADDS     r0,r0,#1              ;2730
000294  6260              STR      r0,[r4,#0x24]         ;2730
000296  8d20              LDRH     r0,[r4,#0x28]         ;2733
000298  1e40              SUBS     r0,r0,#1              ;2733
00029a  8520              STRH     r0,[r4,#0x28]         ;2733
00029c  8d60              LDRH     r0,[r4,#0x2a]         ;2734
00029e  1e40              SUBS     r0,r0,#1              ;2734
0002a0  8560              STRH     r0,[r4,#0x2a]         ;2734
0002a2  6820              LDR      r0,[r4,#0]            ;2736
0002a4  6940              LDR      r0,[r0,#0x14]         ;2736
0002a6  f3c00080          UBFX     r0,r0,#2,#1           ;2736
0002aa  b160              CBZ      r0,|L30.710|
0002ac  6820              LDR      r0,[r4,#0]            ;2739
0002ae  6900              LDR      r0,[r0,#0x10]         ;2739
0002b0  6a61              LDR      r1,[r4,#0x24]         ;2739
0002b2  7008              STRB     r0,[r1,#0]            ;2739
0002b4  6a60              LDR      r0,[r4,#0x24]         ;2742
0002b6  1c40              ADDS     r0,r0,#1              ;2742
0002b8  6260              STR      r0,[r4,#0x24]         ;2742
0002ba  8d20              LDRH     r0,[r4,#0x28]         ;2745
0002bc  1e40              SUBS     r0,r0,#1              ;2745
0002be  8520              STRH     r0,[r4,#0x28]         ;2745
0002c0  8d60              LDRH     r0,[r4,#0x2a]         ;2746
0002c2  1e40              SUBS     r0,r0,#1              ;2746
0002c4  8560              STRH     r0,[r4,#0x2a]         ;2746
                  |L30.710|
0002c6  8d20              LDRH     r0,[r4,#0x28]         ;2611
0002c8  2800              CMP      r0,#0                 ;2611
0002ca  f47faf41          BNE      |L30.336|
0002ce  2020              MOVS     r0,#0x20              ;2751
0002d0  f884003d          STRB     r0,[r4,#0x3d]         ;2751
0002d4  2000              MOVS     r0,#0                 ;2752
0002d6  f884003e          STRB     r0,[r4,#0x3e]         ;2752
0002da  bf00              NOP                            ;2755
0002dc  f884003c          STRB     r0,[r4,#0x3c]         ;2755
0002e0  bf00              NOP                            ;2755
0002e2  e6a6              B        |L30.50|
                  |L30.740|
0002e4  2002              MOVS     r0,#2                 ;2761
0002e6  e6a4              B        |L30.50|
;;;2764   
                          ENDP

                  |L30.744|
                          DCD      0x00100002
                  |L30.748|
                          DCD      0xffff0000
                  |L30.752|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Mem_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_DMA PROC
;;;3104     */
;;;3105   HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;3106   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;3107     /* Init tickstart for timeout management*/
;;;3108     uint32_t tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4606              MOV      r6,r0
;;;3109     __IO uint32_t count = 0U;
000016  2000              MOVS     r0,#0
000018  9002              STR      r0,[sp,#8]
;;;3110     HAL_StatusTypeDef dmaxferstatus;
;;;3111   
;;;3112     /* Check the parameters */
;;;3113     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;3114   
;;;3115     if (hi2c->State == HAL_I2C_STATE_READY)
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  2820              CMP      r0,#0x20
000020  d17e              BNE      |L31.288|
;;;3116     {
;;;3117       /* Wait until BUSY flag is reset */
;;;3118       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000022  4876              LDR      r0,|L31.508|
000024  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000026  2119              MOVS     r1,#0x19
000028  fbb0f0f1          UDIV     r0,r0,r1
00002c  f44f717a          MOV      r1,#0x3e8
000030  fbb0f0f1          UDIV     r0,r0,r1
000034  eb0001c0          ADD      r1,r0,r0,LSL #3
000038  eb011000          ADD      r0,r1,r0,LSL #4
00003c  9002              STR      r0,[sp,#8]
;;;3119       do
00003e  bf00              NOP      
                  |L31.64|
;;;3120       {
;;;3121         count--;
000040  9802              LDR      r0,[sp,#8]
000042  1e40              SUBS     r0,r0,#1
000044  9002              STR      r0,[sp,#8]
;;;3122         if (count == 0U)
000046  9802              LDR      r0,[sp,#8]
000048  b998              CBNZ     r0,|L31.114|
;;;3123         {
;;;3124           hi2c->PreviousState       = I2C_STATE_NONE;
00004a  2000              MOVS     r0,#0
00004c  6320              STR      r0,[r4,#0x30]
;;;3125           hi2c->State               = HAL_I2C_STATE_READY;
00004e  2020              MOVS     r0,#0x20
000050  f884003d          STRB     r0,[r4,#0x3d]
;;;3126           hi2c->Mode                = HAL_I2C_MODE_NONE;
000054  2000              MOVS     r0,#0
000056  f884003e          STRB     r0,[r4,#0x3e]
;;;3127           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00005a  6c20              LDR      r0,[r4,#0x40]
00005c  f0400020          ORR      r0,r0,#0x20
000060  6420              STR      r0,[r4,#0x40]
;;;3128   
;;;3129           /* Process Unlocked */
;;;3130           __HAL_UNLOCK(hi2c);
000062  bf00              NOP      
000064  2000              MOVS     r0,#0
000066  f884003c          STRB     r0,[r4,#0x3c]
00006a  bf00              NOP      
;;;3131   
;;;3132           return HAL_ERROR;
00006c  2001              MOVS     r0,#1
                  |L31.110|
;;;3133         }
;;;3134       }
;;;3135       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3136   
;;;3137       /* Process Locked */
;;;3138       __HAL_LOCK(hi2c);
;;;3139   
;;;3140       /* Check if the I2C is already enabled */
;;;3141       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3142       {
;;;3143         /* Enable I2C peripheral */
;;;3144         __HAL_I2C_ENABLE(hi2c);
;;;3145       }
;;;3146   
;;;3147       /* Disable Pos */
;;;3148       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3149   
;;;3150       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3151       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;3152       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3153   
;;;3154       /* Prepare transfer parameters */
;;;3155       hi2c->pBuffPtr    = pData;
;;;3156       hi2c->XferCount   = Size;
;;;3157       hi2c->XferSize    = hi2c->XferCount;
;;;3158       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3159   
;;;3160       if (hi2c->XferSize > 0U)
;;;3161       {
;;;3162         /* Set the I2C DMA transfer complete callback */
;;;3163         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;3164   
;;;3165         /* Set the DMA error callback */
;;;3166         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;3167   
;;;3168         /* Set the unused DMA callbacks to NULL */
;;;3169         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;3170         hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;3171         hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;3172         hi2c->hdmarx->XferAbortCallback = NULL;
;;;3173   
;;;3174         /* Enable the DMA stream */
;;;3175         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;3176   
;;;3177         if (dmaxferstatus == HAL_OK)
;;;3178         {
;;;3179           /* Send Slave Address and Memory Address */
;;;3180           if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3181           {
;;;3182             return HAL_ERROR;
;;;3183           }
;;;3184   
;;;3185           if (hi2c->XferSize == 1U)
;;;3186           {
;;;3187             /* Disable Acknowledge */
;;;3188             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3189           }
;;;3190           else
;;;3191           {
;;;3192             /* Enable Last DMA bit */
;;;3193             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;3194           }
;;;3195   
;;;3196           /* Clear ADDR flag */
;;;3197           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3198   
;;;3199           /* Process Unlocked */
;;;3200           __HAL_UNLOCK(hi2c);
;;;3201   
;;;3202           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3203           to avoid the risk of I2C interrupt handle execution before current
;;;3204           process unlock */
;;;3205           /* Enable ERR interrupt */
;;;3206           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
;;;3207   
;;;3208           /* Enable DMA Request */
;;;3209           hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;3210         }
;;;3211         else
;;;3212         {
;;;3213           /* Update I2C state */
;;;3214           hi2c->State     = HAL_I2C_STATE_READY;
;;;3215           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3216   
;;;3217           /* Update I2C error code */
;;;3218           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3219   
;;;3220           /* Process Unlocked */
;;;3221           __HAL_UNLOCK(hi2c);
;;;3222   
;;;3223           return HAL_ERROR;
;;;3224         }
;;;3225       }
;;;3226       else
;;;3227       {
;;;3228         /* Send Slave Address and Memory Address */
;;;3229         if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3230         {
;;;3231           return HAL_ERROR;
;;;3232         }
;;;3233   
;;;3234         /* Clear ADDR flag */
;;;3235         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3236   
;;;3237         /* Generate Stop */
;;;3238         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3239   
;;;3240         hi2c->State = HAL_I2C_STATE_READY;
;;;3241   
;;;3242         /* Process Unlocked */
;;;3243         __HAL_UNLOCK(hi2c);
;;;3244       }
;;;3245   
;;;3246       return HAL_OK;
;;;3247     }
;;;3248     else
;;;3249     {
;;;3250       return HAL_BUSY;
;;;3251     }
;;;3252   }
00006e  e8bd8ffe          POP      {r1-r11,pc}
                  |L31.114|
000072  6820              LDR      r0,[r4,#0]            ;3135
000074  6980              LDR      r0,[r0,#0x18]         ;3135
000076  f3c00040          UBFX     r0,r0,#1,#1           ;3135
00007a  2800              CMP      r0,#0                 ;3135
00007c  d1e0              BNE      |L31.64|
00007e  bf00              NOP                            ;3138
000080  f894003c          LDRB     r0,[r4,#0x3c]         ;3138
000084  2801              CMP      r0,#1                 ;3138
000086  d101              BNE      |L31.140|
000088  2002              MOVS     r0,#2                 ;3138
00008a  e7f0              B        |L31.110|
                  |L31.140|
00008c  2001              MOVS     r0,#1                 ;3138
00008e  f884003c          STRB     r0,[r4,#0x3c]         ;3138
000092  bf00              NOP                            ;3138
000094  6820              LDR      r0,[r4,#0]            ;3141
000096  6800              LDR      r0,[r0,#0]            ;3141
000098  f0000001          AND      r0,r0,#1              ;3141
00009c  b928              CBNZ     r0,|L31.170|
00009e  6820              LDR      r0,[r4,#0]            ;3144
0000a0  6800              LDR      r0,[r0,#0]            ;3144
0000a2  f0400001          ORR      r0,r0,#1              ;3144
0000a6  6821              LDR      r1,[r4,#0]            ;3144
0000a8  6008              STR      r0,[r1,#0]            ;3144
                  |L31.170|
0000aa  6820              LDR      r0,[r4,#0]            ;3148
0000ac  6800              LDR      r0,[r0,#0]            ;3148
0000ae  f4206000          BIC      r0,r0,#0x800          ;3148
0000b2  6821              LDR      r1,[r4,#0]            ;3148
0000b4  6008              STR      r0,[r1,#0]            ;3148
0000b6  2022              MOVS     r0,#0x22              ;3150
0000b8  f884003d          STRB     r0,[r4,#0x3d]         ;3150
0000bc  2040              MOVS     r0,#0x40              ;3151
0000be  f884003e          STRB     r0,[r4,#0x3e]         ;3151
0000c2  2000              MOVS     r0,#0                 ;3152
0000c4  6420              STR      r0,[r4,#0x40]         ;3152
0000c6  f8c49024          STR      r9,[r4,#0x24]         ;3155
0000ca  f8a4a02a          STRH     r10,[r4,#0x2a]        ;3156
0000ce  8d60              LDRH     r0,[r4,#0x2a]         ;3157
0000d0  8520              STRH     r0,[r4,#0x28]         ;3157
0000d2  484b              LDR      r0,|L31.512|
0000d4  62e0              STR      r0,[r4,#0x2c]         ;3158
0000d6  8d20              LDRH     r0,[r4,#0x28]         ;3160
0000d8  2800              CMP      r0,#0                 ;3160
0000da  d066              BEQ      |L31.426|
0000dc  4849              LDR      r0,|L31.516|
0000de  6ba1              LDR      r1,[r4,#0x38]         ;3163
0000e0  63c8              STR      r0,[r1,#0x3c]         ;3163
0000e2  4849              LDR      r0,|L31.520|
0000e4  6ba1              LDR      r1,[r4,#0x38]         ;3166
0000e6  64c8              STR      r0,[r1,#0x4c]         ;3166
0000e8  2000              MOVS     r0,#0                 ;3169
0000ea  6ba1              LDR      r1,[r4,#0x38]         ;3169
0000ec  6408              STR      r0,[r1,#0x40]         ;3169
0000ee  6ba1              LDR      r1,[r4,#0x38]         ;3170
0000f0  6448              STR      r0,[r1,#0x44]         ;3170
0000f2  6ba1              LDR      r1,[r4,#0x38]         ;3171
0000f4  6488              STR      r0,[r1,#0x48]         ;3171
0000f6  6ba1              LDR      r1,[r4,#0x38]         ;3172
0000f8  6508              STR      r0,[r1,#0x50]         ;3172
0000fa  8d23              LDRH     r3,[r4,#0x28]         ;3175
0000fc  f8d4c000          LDR      r12,[r4,#0]           ;3175
000100  f10c0110          ADD      r1,r12,#0x10          ;3175
000104  6a62              LDR      r2,[r4,#0x24]         ;3175
000106  6ba0              LDR      r0,[r4,#0x38]         ;3175
000108  f7fffffe          BL       HAL_DMA_Start_IT
00010c  4605              MOV      r5,r0                 ;3175
00010e  bbd5              CBNZ     r5,|L31.390|
000110  2023              MOVS     r0,#0x23              ;3180
000112  465b              MOV      r3,r11                ;3180
000114  4642              MOV      r2,r8                 ;3180
000116  4639              MOV      r1,r7                 ;3180
000118  e9cd0600          STRD     r0,r6,[sp,#0]         ;3180
00011c  4620              MOV      r0,r4                 ;3180
00011e  e000              B        |L31.290|
                  |L31.288|
000120  e06a              B        |L31.504|
                  |L31.290|
000122  f7fffffe          BL       I2C_RequestMemoryRead
000126  b108              CBZ      r0,|L31.300|
000128  2001              MOVS     r0,#1                 ;3182
00012a  e7a0              B        |L31.110|
                  |L31.300|
00012c  8d20              LDRH     r0,[r4,#0x28]         ;3185
00012e  2801              CMP      r0,#1                 ;3185
000130  d106              BNE      |L31.320|
000132  6820              LDR      r0,[r4,#0]            ;3188
000134  6800              LDR      r0,[r0,#0]            ;3188
000136  f4206080          BIC      r0,r0,#0x400          ;3188
00013a  6821              LDR      r1,[r4,#0]            ;3188
00013c  6008              STR      r0,[r1,#0]            ;3188
00013e  e005              B        |L31.332|
                  |L31.320|
000140  6820              LDR      r0,[r4,#0]            ;3193
000142  6840              LDR      r0,[r0,#4]            ;3193
000144  f4405080          ORR      r0,r0,#0x1000         ;3193
000148  6821              LDR      r1,[r4,#0]            ;3193
00014a  6048              STR      r0,[r1,#4]            ;3193
                  |L31.332|
00014c  bf00              NOP                            ;3197
00014e  2000              MOVS     r0,#0                 ;3197
000150  9001              STR      r0,[sp,#4]            ;3197
000152  6820              LDR      r0,[r4,#0]            ;3197
000154  6940              LDR      r0,[r0,#0x14]         ;3197
000156  9001              STR      r0,[sp,#4]            ;3197
000158  6820              LDR      r0,[r4,#0]            ;3197
00015a  6980              LDR      r0,[r0,#0x18]         ;3197
00015c  9001              STR      r0,[sp,#4]            ;3197
00015e  bf00              NOP                            ;3197
000160  bf00              NOP                            ;3197
000162  bf00              NOP                            ;3200
000164  2000              MOVS     r0,#0                 ;3200
000166  f884003c          STRB     r0,[r4,#0x3c]         ;3200
00016a  bf00              NOP                            ;3200
00016c  6820              LDR      r0,[r4,#0]            ;3206
00016e  6840              LDR      r0,[r0,#4]            ;3206
000170  f4407080          ORR      r0,r0,#0x100          ;3206
000174  6821              LDR      r1,[r4,#0]            ;3206
000176  6048              STR      r0,[r1,#4]            ;3206
000178  6820              LDR      r0,[r4,#0]            ;3209
00017a  6840              LDR      r0,[r0,#4]            ;3209
00017c  f4406000          ORR      r0,r0,#0x800          ;3209
000180  6821              LDR      r1,[r4,#0]            ;3209
000182  6048              STR      r0,[r1,#4]            ;3209
000184  e036              B        |L31.500|
                  |L31.390|
000186  e7ff              B        |L31.392|
                  |L31.392|
000188  2020              MOVS     r0,#0x20              ;3214
00018a  f884003d          STRB     r0,[r4,#0x3d]         ;3214
00018e  2000              MOVS     r0,#0                 ;3215
000190  f884003e          STRB     r0,[r4,#0x3e]         ;3215
000194  6c20              LDR      r0,[r4,#0x40]         ;3218
000196  f0400010          ORR      r0,r0,#0x10           ;3218
00019a  6420              STR      r0,[r4,#0x40]         ;3218
00019c  bf00              NOP                            ;3221
00019e  2000              MOVS     r0,#0                 ;3221
0001a0  f884003c          STRB     r0,[r4,#0x3c]         ;3221
0001a4  bf00              NOP                            ;3221
0001a6  2001              MOVS     r0,#1                 ;3223
0001a8  e761              B        |L31.110|
                  |L31.426|
0001aa  2023              MOVS     r0,#0x23              ;3229
0001ac  465b              MOV      r3,r11                ;3229
0001ae  4642              MOV      r2,r8                 ;3229
0001b0  4639              MOV      r1,r7                 ;3229
0001b2  e9cd0600          STRD     r0,r6,[sp,#0]         ;3229
0001b6  4620              MOV      r0,r4                 ;3229
0001b8  f7fffffe          BL       I2C_RequestMemoryRead
0001bc  b108              CBZ      r0,|L31.450|
0001be  2001              MOVS     r0,#1                 ;3231
0001c0  e755              B        |L31.110|
                  |L31.450|
0001c2  bf00              NOP                            ;3235
0001c4  2000              MOVS     r0,#0                 ;3235
0001c6  9001              STR      r0,[sp,#4]            ;3235
0001c8  6820              LDR      r0,[r4,#0]            ;3235
0001ca  6940              LDR      r0,[r0,#0x14]         ;3235
0001cc  9001              STR      r0,[sp,#4]            ;3235
0001ce  6820              LDR      r0,[r4,#0]            ;3235
0001d0  6980              LDR      r0,[r0,#0x18]         ;3235
0001d2  9001              STR      r0,[sp,#4]            ;3235
0001d4  bf00              NOP                            ;3235
0001d6  bf00              NOP                            ;3235
0001d8  6820              LDR      r0,[r4,#0]            ;3238
0001da  6800              LDR      r0,[r0,#0]            ;3238
0001dc  f4407000          ORR      r0,r0,#0x200          ;3238
0001e0  6821              LDR      r1,[r4,#0]            ;3238
0001e2  6008              STR      r0,[r1,#0]            ;3238
0001e4  2020              MOVS     r0,#0x20              ;3240
0001e6  f884003d          STRB     r0,[r4,#0x3d]         ;3240
0001ea  bf00              NOP                            ;3243
0001ec  2000              MOVS     r0,#0                 ;3243
0001ee  f884003c          STRB     r0,[r4,#0x3c]         ;3243
0001f2  bf00              NOP                            ;3243
                  |L31.500|
0001f4  2000              MOVS     r0,#0                 ;3246
0001f6  e73a              B        |L31.110|
                  |L31.504|
0001f8  2002              MOVS     r0,#2                 ;3250
0001fa  e738              B        |L31.110|
;;;3253   
                          ENDP

                  |L31.508|
                          DCD      SystemCoreClock
                  |L31.512|
                          DCD      0xffff0000
                  |L31.516|
                          DCD      I2C_DMAXferCplt
                  |L31.520|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Read_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_IT PROC
;;;2864     */
;;;2865   HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2866   {
000002  4604              MOV      r4,r0
000004  e9dd5606          LDRD     r5,r6,[sp,#0x18]
;;;2867     __IO uint32_t count = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2868   
;;;2869     /* Check the parameters */
;;;2870     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2871   
;;;2872     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d177              BNE      |L32.260|
;;;2873     {
;;;2874       /* Wait until BUSY flag is reset */
;;;2875       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000014  483c              LDR      r0,|L32.264|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  2719              MOVS     r7,#0x19
00001a  fbb0f0f7          UDIV     r0,r0,r7
00001e  f44f777a          MOV      r7,#0x3e8
000022  fbb0f0f7          UDIV     r0,r0,r7
000026  eb0007c0          ADD      r7,r0,r0,LSL #3
00002a  eb071000          ADD      r0,r7,r0,LSL #4
00002e  9000              STR      r0,[sp,#0]
;;;2876       do
000030  bf00              NOP      
                  |L32.50|
;;;2877       {
;;;2878         count--;
000032  9800              LDR      r0,[sp,#0]
000034  1e40              SUBS     r0,r0,#1
000036  9000              STR      r0,[sp,#0]
;;;2879         if (count == 0U)
000038  9800              LDR      r0,[sp,#0]
00003a  b990              CBNZ     r0,|L32.98|
;;;2880         {
;;;2881           hi2c->PreviousState       = I2C_STATE_NONE;
00003c  2000              MOVS     r0,#0
00003e  6320              STR      r0,[r4,#0x30]
;;;2882           hi2c->State               = HAL_I2C_STATE_READY;
000040  2020              MOVS     r0,#0x20
000042  f884003d          STRB     r0,[r4,#0x3d]
;;;2883           hi2c->Mode                = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;2884           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00004c  6c20              LDR      r0,[r4,#0x40]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6420              STR      r0,[r4,#0x40]
;;;2885   
;;;2886           /* Process Unlocked */
;;;2887           __HAL_UNLOCK(hi2c);
000054  bf00              NOP      
000056  2000              MOVS     r0,#0
000058  f884003c          STRB     r0,[r4,#0x3c]
00005c  bf00              NOP      
;;;2888   
;;;2889           return HAL_ERROR;
00005e  2001              MOVS     r0,#1
                  |L32.96|
;;;2890         }
;;;2891       }
;;;2892       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2893   
;;;2894       /* Process Locked */
;;;2895       __HAL_LOCK(hi2c);
;;;2896   
;;;2897       /* Check if the I2C is already enabled */
;;;2898       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2899       {
;;;2900         /* Enable I2C peripheral */
;;;2901         __HAL_I2C_ENABLE(hi2c);
;;;2902       }
;;;2903   
;;;2904       /* Disable Pos */
;;;2905       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2906   
;;;2907       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2908       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2909       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2910   
;;;2911       /* Prepare transfer parameters */
;;;2912       hi2c->pBuffPtr    = pData;
;;;2913       hi2c->XferCount   = Size;
;;;2914       hi2c->XferSize    = hi2c->XferCount;
;;;2915       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2916       hi2c->Devaddress  = DevAddress;
;;;2917       hi2c->Memaddress  = MemAddress;
;;;2918       hi2c->MemaddSize  = MemAddSize;
;;;2919       hi2c->EventCount  = 0U;
;;;2920   
;;;2921       /* Enable Acknowledge */
;;;2922       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2923   
;;;2924       /* Generate Start */
;;;2925       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2926   
;;;2927       /* Process Unlocked */
;;;2928       __HAL_UNLOCK(hi2c);
;;;2929   
;;;2930       if (hi2c->XferSize > 0U)
;;;2931       {
;;;2932         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2933         to avoid the risk of I2C interrupt handle execution before current
;;;2934         process unlock */
;;;2935   
;;;2936         /* Enable EVT, BUF and ERR interrupt */
;;;2937         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2938       }
;;;2939       return HAL_OK;
;;;2940     }
;;;2941     else
;;;2942     {
;;;2943       return HAL_BUSY;
;;;2944     }
;;;2945   }
000060  bdf8              POP      {r3-r7,pc}
                  |L32.98|
000062  6820              LDR      r0,[r4,#0]            ;2892
000064  6980              LDR      r0,[r0,#0x18]         ;2892
000066  f3c00040          UBFX     r0,r0,#1,#1           ;2892
00006a  2800              CMP      r0,#0                 ;2892
00006c  d1e1              BNE      |L32.50|
00006e  bf00              NOP                            ;2895
000070  f894003c          LDRB     r0,[r4,#0x3c]         ;2895
000074  2801              CMP      r0,#1                 ;2895
000076  d101              BNE      |L32.124|
000078  2002              MOVS     r0,#2                 ;2895
00007a  e7f1              B        |L32.96|
                  |L32.124|
00007c  2001              MOVS     r0,#1                 ;2895
00007e  f884003c          STRB     r0,[r4,#0x3c]         ;2895
000082  bf00              NOP                            ;2895
000084  6820              LDR      r0,[r4,#0]            ;2898
000086  6800              LDR      r0,[r0,#0]            ;2898
000088  f0000001          AND      r0,r0,#1              ;2898
00008c  b928              CBNZ     r0,|L32.154|
00008e  6820              LDR      r0,[r4,#0]            ;2901
000090  6800              LDR      r0,[r0,#0]            ;2901
000092  f0400001          ORR      r0,r0,#1              ;2901
000096  6827              LDR      r7,[r4,#0]            ;2901
000098  6038              STR      r0,[r7,#0]            ;2901
                  |L32.154|
00009a  6820              LDR      r0,[r4,#0]            ;2905
00009c  6800              LDR      r0,[r0,#0]            ;2905
00009e  f4206000          BIC      r0,r0,#0x800          ;2905
0000a2  6827              LDR      r7,[r4,#0]            ;2905
0000a4  6038              STR      r0,[r7,#0]            ;2905
0000a6  2022              MOVS     r0,#0x22              ;2907
0000a8  f884003d          STRB     r0,[r4,#0x3d]         ;2907
0000ac  2040              MOVS     r0,#0x40              ;2908
0000ae  f884003e          STRB     r0,[r4,#0x3e]         ;2908
0000b2  2000              MOVS     r0,#0                 ;2909
0000b4  6420              STR      r0,[r4,#0x40]         ;2909
0000b6  6265              STR      r5,[r4,#0x24]         ;2912
0000b8  8566              STRH     r6,[r4,#0x2a]         ;2913
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;2914
0000bc  8520              STRH     r0,[r4,#0x28]         ;2914
0000be  4813              LDR      r0,|L32.268|
0000c0  62e0              STR      r0,[r4,#0x2c]         ;2915
0000c2  6461              STR      r1,[r4,#0x44]         ;2916
0000c4  64a2              STR      r2,[r4,#0x48]         ;2917
0000c6  64e3              STR      r3,[r4,#0x4c]         ;2918
0000c8  2000              MOVS     r0,#0                 ;2919
0000ca  6520              STR      r0,[r4,#0x50]         ;2919
0000cc  6820              LDR      r0,[r4,#0]            ;2922
0000ce  6800              LDR      r0,[r0,#0]            ;2922
0000d0  f4406080          ORR      r0,r0,#0x400          ;2922
0000d4  6827              LDR      r7,[r4,#0]            ;2922
0000d6  6038              STR      r0,[r7,#0]            ;2922
0000d8  6820              LDR      r0,[r4,#0]            ;2925
0000da  6800              LDR      r0,[r0,#0]            ;2925
0000dc  f4407080          ORR      r0,r0,#0x100          ;2925
0000e0  6827              LDR      r7,[r4,#0]            ;2925
0000e2  6038              STR      r0,[r7,#0]            ;2925
0000e4  bf00              NOP                            ;2928
0000e6  2000              MOVS     r0,#0                 ;2928
0000e8  f884003c          STRB     r0,[r4,#0x3c]         ;2928
0000ec  bf00              NOP                            ;2928
0000ee  8d20              LDRH     r0,[r4,#0x28]         ;2930
0000f0  b128              CBZ      r0,|L32.254|
0000f2  6820              LDR      r0,[r4,#0]            ;2937
0000f4  6840              LDR      r0,[r0,#4]            ;2937
0000f6  f44060e0          ORR      r0,r0,#0x700          ;2937
0000fa  6827              LDR      r7,[r4,#0]            ;2937
0000fc  6078              STR      r0,[r7,#4]            ;2937
                  |L32.254|
0000fe  2000              MOVS     r0,#0                 ;2939
000100  e7ae              B        |L32.96|
000102  e7ff              B        |L32.260|
                  |L32.260|
000104  2002              MOVS     r0,#2                 ;2943
000106  e7ab              B        |L32.96|
;;;2946   
                          ENDP

                  |L32.264|
                          DCD      SystemCoreClock
                  |L32.268|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Mem_Write||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write PROC
;;;2406     */
;;;2407   HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2408   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000010  9e0e              LDR      r6,[sp,#0x38]
;;;2409     /* Init tickstart for timeout management*/
;;;2410     uint32_t tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;2411   
;;;2412     /* Check the parameters */
;;;2413     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2414   
;;;2415     if (hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d17d              BNE      |L33.284|
;;;2416     {
;;;2417       /* Wait until BUSY flag is reset */
;;;2418       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
000020  2319              MOVS     r3,#0x19
000022  2201              MOVS     r2,#1
000024  494d              LDR      r1,|L33.348|
000026  4620              MOV      r0,r4
000028  9500              STR      r5,[sp,#0]
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  b110              CBZ      r0,|L33.54|
;;;2419       {
;;;2420         return HAL_BUSY;
000030  2002              MOVS     r0,#2
                  |L33.50|
;;;2421       }
;;;2422   
;;;2423       /* Process Locked */
;;;2424       __HAL_LOCK(hi2c);
;;;2425   
;;;2426       /* Check if the I2C is already enabled */
;;;2427       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2428       {
;;;2429         /* Enable I2C peripheral */
;;;2430         __HAL_I2C_ENABLE(hi2c);
;;;2431       }
;;;2432   
;;;2433       /* Disable Pos */
;;;2434       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2435   
;;;2436       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2437       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2438       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2439   
;;;2440       /* Prepare transfer parameters */
;;;2441       hi2c->pBuffPtr    = pData;
;;;2442       hi2c->XferCount   = Size;
;;;2443       hi2c->XferSize    = hi2c->XferCount;
;;;2444       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2445   
;;;2446       /* Send Slave Address and Memory Address */
;;;2447       if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2448       {
;;;2449         return HAL_ERROR;
;;;2450       }
;;;2451   
;;;2452       while (hi2c->XferSize > 0U)
;;;2453       {
;;;2454         /* Wait until TXE flag is set */
;;;2455         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2456         {
;;;2457           if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2458           {
;;;2459             /* Generate Stop */
;;;2460             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2461           }
;;;2462           return HAL_ERROR;
;;;2463         }
;;;2464   
;;;2465         /* Write data to DR */
;;;2466         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;2467   
;;;2468         /* Increment Buffer pointer */
;;;2469         hi2c->pBuffPtr++;
;;;2470   
;;;2471         /* Update counter */
;;;2472         hi2c->XferSize--;
;;;2473         hi2c->XferCount--;
;;;2474   
;;;2475         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;2476         {
;;;2477           /* Write data to DR */
;;;2478           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;2479   
;;;2480           /* Increment Buffer pointer */
;;;2481           hi2c->pBuffPtr++;
;;;2482   
;;;2483           /* Update counter */
;;;2484           hi2c->XferSize--;
;;;2485           hi2c->XferCount--;
;;;2486         }
;;;2487       }
;;;2488   
;;;2489       /* Wait until BTF flag is set */
;;;2490       if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2491       {
;;;2492         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2493         {
;;;2494           /* Generate Stop */
;;;2495           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2496         }
;;;2497         return HAL_ERROR;
;;;2498       }
;;;2499   
;;;2500       /* Generate Stop */
;;;2501       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2502   
;;;2503       hi2c->State = HAL_I2C_STATE_READY;
;;;2504       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2505   
;;;2506       /* Process Unlocked */
;;;2507       __HAL_UNLOCK(hi2c);
;;;2508   
;;;2509       return HAL_OK;
;;;2510     }
;;;2511     else
;;;2512     {
;;;2513       return HAL_BUSY;
;;;2514     }
;;;2515   }
000032  e8bd9ffc          POP      {r2-r12,pc}
                  |L33.54|
000036  bf00              NOP                            ;2424
000038  f894003c          LDRB     r0,[r4,#0x3c]         ;2424
00003c  2801              CMP      r0,#1                 ;2424
00003e  d101              BNE      |L33.68|
000040  2002              MOVS     r0,#2                 ;2424
000042  e7f6              B        |L33.50|
                  |L33.68|
000044  2001              MOVS     r0,#1                 ;2424
000046  f884003c          STRB     r0,[r4,#0x3c]         ;2424
00004a  bf00              NOP                            ;2424
00004c  6820              LDR      r0,[r4,#0]            ;2427
00004e  6800              LDR      r0,[r0,#0]            ;2427
000050  f0000001          AND      r0,r0,#1              ;2427
000054  b928              CBNZ     r0,|L33.98|
000056  6820              LDR      r0,[r4,#0]            ;2430
000058  6800              LDR      r0,[r0,#0]            ;2430
00005a  f0400001          ORR      r0,r0,#1              ;2430
00005e  6821              LDR      r1,[r4,#0]            ;2430
000060  6008              STR      r0,[r1,#0]            ;2430
                  |L33.98|
000062  6820              LDR      r0,[r4,#0]            ;2434
000064  6800              LDR      r0,[r0,#0]            ;2434
000066  f4206000          BIC      r0,r0,#0x800          ;2434
00006a  6821              LDR      r1,[r4,#0]            ;2434
00006c  6008              STR      r0,[r1,#0]            ;2434
00006e  2021              MOVS     r0,#0x21              ;2436
000070  f884003d          STRB     r0,[r4,#0x3d]         ;2436
000074  2040              MOVS     r0,#0x40              ;2437
000076  f884003e          STRB     r0,[r4,#0x3e]         ;2437
00007a  2000              MOVS     r0,#0                 ;2438
00007c  6420              STR      r0,[r4,#0x40]         ;2438
00007e  f8c4a024          STR      r10,[r4,#0x24]        ;2441
000082  f8a4b02a          STRH     r11,[r4,#0x2a]        ;2442
000086  8d60              LDRH     r0,[r4,#0x2a]         ;2443
000088  8520              STRH     r0,[r4,#0x28]         ;2443
00008a  4835              LDR      r0,|L33.352|
00008c  62e0              STR      r0,[r4,#0x2c]         ;2444
00008e  464b              MOV      r3,r9                 ;2447
000090  4642              MOV      r2,r8                 ;2447
000092  4639              MOV      r1,r7                 ;2447
000094  4620              MOV      r0,r4                 ;2447
000096  e9cd6500          STRD     r6,r5,[sp,#0]         ;2447
00009a  f7fffffe          BL       I2C_RequestMemoryWrite
00009e  b108              CBZ      r0,|L33.164|
0000a0  2001              MOVS     r0,#1                 ;2449
0000a2  e7c6              B        |L33.50|
                  |L33.164|
0000a4  e031              B        |L33.266|
                  |L33.166|
0000a6  462a              MOV      r2,r5                 ;2455
0000a8  4631              MOV      r1,r6                 ;2455
0000aa  4620              MOV      r0,r4                 ;2455
0000ac  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000b0  b150              CBZ      r0,|L33.200|
0000b2  6c20              LDR      r0,[r4,#0x40]         ;2457
0000b4  2804              CMP      r0,#4                 ;2457
0000b6  d105              BNE      |L33.196|
0000b8  6820              LDR      r0,[r4,#0]            ;2460
0000ba  6800              LDR      r0,[r0,#0]            ;2460
0000bc  f4407000          ORR      r0,r0,#0x200          ;2460
0000c0  6821              LDR      r1,[r4,#0]            ;2460
0000c2  6008              STR      r0,[r1,#0]            ;2460
                  |L33.196|
0000c4  2001              MOVS     r0,#1                 ;2462
0000c6  e7b4              B        |L33.50|
                  |L33.200|
0000c8  6a60              LDR      r0,[r4,#0x24]         ;2466
0000ca  7800              LDRB     r0,[r0,#0]            ;2466
0000cc  6821              LDR      r1,[r4,#0]            ;2466
0000ce  6108              STR      r0,[r1,#0x10]         ;2466
0000d0  6a60              LDR      r0,[r4,#0x24]         ;2469
0000d2  1c40              ADDS     r0,r0,#1              ;2469
0000d4  6260              STR      r0,[r4,#0x24]         ;2469
0000d6  8d20              LDRH     r0,[r4,#0x28]         ;2472
0000d8  1e40              SUBS     r0,r0,#1              ;2472
0000da  8520              STRH     r0,[r4,#0x28]         ;2472
0000dc  8d60              LDRH     r0,[r4,#0x2a]         ;2473
0000de  1e40              SUBS     r0,r0,#1              ;2473
0000e0  8560              STRH     r0,[r4,#0x2a]         ;2473
0000e2  6820              LDR      r0,[r4,#0]            ;2475
0000e4  6940              LDR      r0,[r0,#0x14]         ;2475
0000e6  f3c00080          UBFX     r0,r0,#2,#1           ;2475
0000ea  b170              CBZ      r0,|L33.266|
0000ec  8d20              LDRH     r0,[r4,#0x28]         ;2475
0000ee  b160              CBZ      r0,|L33.266|
0000f0  6a60              LDR      r0,[r4,#0x24]         ;2478
0000f2  7800              LDRB     r0,[r0,#0]            ;2478
0000f4  6821              LDR      r1,[r4,#0]            ;2478
0000f6  6108              STR      r0,[r1,#0x10]         ;2478
0000f8  6a60              LDR      r0,[r4,#0x24]         ;2481
0000fa  1c40              ADDS     r0,r0,#1              ;2481
0000fc  6260              STR      r0,[r4,#0x24]         ;2481
0000fe  8d20              LDRH     r0,[r4,#0x28]         ;2484
000100  1e40              SUBS     r0,r0,#1              ;2484
000102  8520              STRH     r0,[r4,#0x28]         ;2484
000104  8d60              LDRH     r0,[r4,#0x2a]         ;2485
000106  1e40              SUBS     r0,r0,#1              ;2485
000108  8560              STRH     r0,[r4,#0x2a]         ;2485
                  |L33.266|
00010a  8d20              LDRH     r0,[r4,#0x28]         ;2452
00010c  2800              CMP      r0,#0                 ;2452
00010e  d1ca              BNE      |L33.166|
000110  462a              MOV      r2,r5                 ;2490
000112  4631              MOV      r1,r6                 ;2490
000114  4620              MOV      r0,r4                 ;2490
000116  f7fffffe          BL       I2C_WaitOnBTFFlagUntilTimeout
00011a  e000              B        |L33.286|
                  |L33.284|
00011c  e01c              B        |L33.344|
                  |L33.286|
00011e  b150              CBZ      r0,|L33.310|
000120  6c20              LDR      r0,[r4,#0x40]         ;2492
000122  2804              CMP      r0,#4                 ;2492
000124  d105              BNE      |L33.306|
000126  6820              LDR      r0,[r4,#0]            ;2495
000128  6800              LDR      r0,[r0,#0]            ;2495
00012a  f4407000          ORR      r0,r0,#0x200          ;2495
00012e  6821              LDR      r1,[r4,#0]            ;2495
000130  6008              STR      r0,[r1,#0]            ;2495
                  |L33.306|
000132  2001              MOVS     r0,#1                 ;2497
000134  e77d              B        |L33.50|
                  |L33.310|
000136  6820              LDR      r0,[r4,#0]            ;2501
000138  6800              LDR      r0,[r0,#0]            ;2501
00013a  f4407000          ORR      r0,r0,#0x200          ;2501
00013e  6821              LDR      r1,[r4,#0]            ;2501
000140  6008              STR      r0,[r1,#0]            ;2501
000142  2020              MOVS     r0,#0x20              ;2503
000144  f884003d          STRB     r0,[r4,#0x3d]         ;2503
000148  2000              MOVS     r0,#0                 ;2504
00014a  f884003e          STRB     r0,[r4,#0x3e]         ;2504
00014e  bf00              NOP                            ;2507
000150  f884003c          STRB     r0,[r4,#0x3c]         ;2507
000154  bf00              NOP                            ;2507
000156  e76c              B        |L33.50|
                  |L33.344|
000158  2002              MOVS     r0,#2                 ;2513
00015a  e76a              B        |L33.50|
;;;2516   
                          ENDP

                  |L33.348|
                          DCD      0x00100002
                  |L33.352|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Mem_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_DMA PROC
;;;2958     */
;;;2959   HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;2960   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  469b              MOV      r11,r3
00000c  e9dd890c          LDRD     r8,r9,[sp,#0x30]
;;;2961     __IO uint32_t count = 0U;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;2962     HAL_StatusTypeDef dmaxferstatus;
;;;2963   
;;;2964     /* Init tickstart for timeout management*/
;;;2965     uint32_t tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4682              MOV      r10,r0
;;;2966   
;;;2967     /* Check the parameters */
;;;2968     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2969   
;;;2970     if (hi2c->State == HAL_I2C_STATE_READY)
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  2820              CMP      r0,#0x20
000020  d17e              BNE      |L34.288|
;;;2971     {
;;;2972       /* Wait until BUSY flag is reset */
;;;2973       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000022  4863              LDR      r0,|L34.432|
000024  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000026  2119              MOVS     r1,#0x19
000028  fbb0f0f1          UDIV     r0,r0,r1
00002c  f44f717a          MOV      r1,#0x3e8
000030  fbb0f0f1          UDIV     r0,r0,r1
000034  eb0001c0          ADD      r1,r0,r0,LSL #3
000038  eb011000          ADD      r0,r1,r0,LSL #4
00003c  9002              STR      r0,[sp,#8]
;;;2974       do
00003e  bf00              NOP      
                  |L34.64|
;;;2975       {
;;;2976         count--;
000040  9802              LDR      r0,[sp,#8]
000042  1e40              SUBS     r0,r0,#1
000044  9002              STR      r0,[sp,#8]
;;;2977         if (count == 0U)
000046  9802              LDR      r0,[sp,#8]
000048  b998              CBNZ     r0,|L34.114|
;;;2978         {
;;;2979           hi2c->PreviousState       = I2C_STATE_NONE;
00004a  2000              MOVS     r0,#0
00004c  6320              STR      r0,[r4,#0x30]
;;;2980           hi2c->State               = HAL_I2C_STATE_READY;
00004e  2020              MOVS     r0,#0x20
000050  f884003d          STRB     r0,[r4,#0x3d]
;;;2981           hi2c->Mode                = HAL_I2C_MODE_NONE;
000054  2000              MOVS     r0,#0
000056  f884003e          STRB     r0,[r4,#0x3e]
;;;2982           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00005a  6c20              LDR      r0,[r4,#0x40]
00005c  f0400020          ORR      r0,r0,#0x20
000060  6420              STR      r0,[r4,#0x40]
;;;2983   
;;;2984           /* Process Unlocked */
;;;2985           __HAL_UNLOCK(hi2c);
000062  bf00              NOP      
000064  2000              MOVS     r0,#0
000066  f884003c          STRB     r0,[r4,#0x3c]
00006a  bf00              NOP      
;;;2986   
;;;2987           return HAL_ERROR;
00006c  2001              MOVS     r0,#1
                  |L34.110|
;;;2988         }
;;;2989       }
;;;2990       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2991   
;;;2992       /* Process Locked */
;;;2993       __HAL_LOCK(hi2c);
;;;2994   
;;;2995       /* Check if the I2C is already enabled */
;;;2996       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2997       {
;;;2998         /* Enable I2C peripheral */
;;;2999         __HAL_I2C_ENABLE(hi2c);
;;;3000       }
;;;3001   
;;;3002       /* Disable Pos */
;;;3003       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3004   
;;;3005       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3006       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;3007       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3008   
;;;3009       /* Prepare transfer parameters */
;;;3010       hi2c->pBuffPtr    = pData;
;;;3011       hi2c->XferCount   = Size;
;;;3012       hi2c->XferSize    = hi2c->XferCount;
;;;3013       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3014   
;;;3015       if (hi2c->XferSize > 0U)
;;;3016       {
;;;3017         /* Set the I2C DMA transfer complete callback */
;;;3018         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;3019   
;;;3020         /* Set the DMA error callback */
;;;3021         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3022   
;;;3023         /* Set the unused DMA callbacks to NULL */
;;;3024         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3025         hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;3026         hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;3027         hi2c->hdmatx->XferAbortCallback = NULL;
;;;3028   
;;;3029         /* Enable the DMA stream */
;;;3030         dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;3031   
;;;3032         if (dmaxferstatus == HAL_OK)
;;;3033         {
;;;3034           /* Send Slave Address and Memory Address */
;;;3035           if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3036           {
;;;3037             return HAL_ERROR;
;;;3038           }
;;;3039   
;;;3040           /* Clear ADDR flag */
;;;3041           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3042   
;;;3043           /* Process Unlocked */
;;;3044           __HAL_UNLOCK(hi2c);
;;;3045   
;;;3046           /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3047           to avoid the risk of I2C interrupt handle execution before current
;;;3048           process unlock */
;;;3049           /* Enable ERR interrupt */
;;;3050           __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
;;;3051   
;;;3052           /* Enable DMA Request */
;;;3053           SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;3054   
;;;3055           return HAL_OK;
;;;3056         }
;;;3057         else
;;;3058         {
;;;3059           /* Update I2C state */
;;;3060           hi2c->State     = HAL_I2C_STATE_READY;
;;;3061           hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3062   
;;;3063           /* Update I2C error code */
;;;3064           hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;3065   
;;;3066           /* Process Unlocked */
;;;3067           __HAL_UNLOCK(hi2c);
;;;3068   
;;;3069           return HAL_ERROR;
;;;3070         }
;;;3071       }
;;;3072       else
;;;3073       {
;;;3074         /* Update I2C state */
;;;3075         hi2c->State     = HAL_I2C_STATE_READY;
;;;3076         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;3077   
;;;3078         /* Update I2C error code */
;;;3079         hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
;;;3080   
;;;3081         /* Process Unlocked */
;;;3082         __HAL_UNLOCK(hi2c);
;;;3083   
;;;3084         return HAL_ERROR;
;;;3085       }
;;;3086     }
;;;3087     else
;;;3088     {
;;;3089       return HAL_BUSY;
;;;3090     }
;;;3091   }
00006e  e8bd8ffe          POP      {r1-r11,pc}
                  |L34.114|
000072  6820              LDR      r0,[r4,#0]            ;2990
000074  6980              LDR      r0,[r0,#0x18]         ;2990
000076  f3c00040          UBFX     r0,r0,#1,#1           ;2990
00007a  2800              CMP      r0,#0                 ;2990
00007c  d1e0              BNE      |L34.64|
00007e  bf00              NOP                            ;2993
000080  f894003c          LDRB     r0,[r4,#0x3c]         ;2993
000084  2801              CMP      r0,#1                 ;2993
000086  d101              BNE      |L34.140|
000088  2002              MOVS     r0,#2                 ;2993
00008a  e7f0              B        |L34.110|
                  |L34.140|
00008c  2001              MOVS     r0,#1                 ;2993
00008e  f884003c          STRB     r0,[r4,#0x3c]         ;2993
000092  bf00              NOP                            ;2993
000094  6820              LDR      r0,[r4,#0]            ;2996
000096  6800              LDR      r0,[r0,#0]            ;2996
000098  f0000001          AND      r0,r0,#1              ;2996
00009c  b928              CBNZ     r0,|L34.170|
00009e  6820              LDR      r0,[r4,#0]            ;2999
0000a0  6800              LDR      r0,[r0,#0]            ;2999
0000a2  f0400001          ORR      r0,r0,#1              ;2999
0000a6  6821              LDR      r1,[r4,#0]            ;2999
0000a8  6008              STR      r0,[r1,#0]            ;2999
                  |L34.170|
0000aa  6820              LDR      r0,[r4,#0]            ;3003
0000ac  6800              LDR      r0,[r0,#0]            ;3003
0000ae  f4206000          BIC      r0,r0,#0x800          ;3003
0000b2  6821              LDR      r1,[r4,#0]            ;3003
0000b4  6008              STR      r0,[r1,#0]            ;3003
0000b6  2021              MOVS     r0,#0x21              ;3005
0000b8  f884003d          STRB     r0,[r4,#0x3d]         ;3005
0000bc  2040              MOVS     r0,#0x40              ;3006
0000be  f884003e          STRB     r0,[r4,#0x3e]         ;3006
0000c2  2000              MOVS     r0,#0                 ;3007
0000c4  6420              STR      r0,[r4,#0x40]         ;3007
0000c6  f8c48024          STR      r8,[r4,#0x24]         ;3010
0000ca  f8a4902a          STRH     r9,[r4,#0x2a]         ;3011
0000ce  8d60              LDRH     r0,[r4,#0x2a]         ;3012
0000d0  8520              STRH     r0,[r4,#0x28]         ;3012
0000d2  4838              LDR      r0,|L34.436|
0000d4  62e0              STR      r0,[r4,#0x2c]         ;3013
0000d6  8d20              LDRH     r0,[r4,#0x28]         ;3015
0000d8  2800              CMP      r0,#0                 ;3015
0000da  d056              BEQ      |L34.394|
0000dc  4836              LDR      r0,|L34.440|
0000de  6b61              LDR      r1,[r4,#0x34]         ;3018
0000e0  63c8              STR      r0,[r1,#0x3c]         ;3018
0000e2  4836              LDR      r0,|L34.444|
0000e4  6b61              LDR      r1,[r4,#0x34]         ;3021
0000e6  64c8              STR      r0,[r1,#0x4c]         ;3021
0000e8  2000              MOVS     r0,#0                 ;3024
0000ea  6b61              LDR      r1,[r4,#0x34]         ;3024
0000ec  6408              STR      r0,[r1,#0x40]         ;3024
0000ee  6b61              LDR      r1,[r4,#0x34]         ;3025
0000f0  6448              STR      r0,[r1,#0x44]         ;3025
0000f2  6b61              LDR      r1,[r4,#0x34]         ;3026
0000f4  6488              STR      r0,[r1,#0x48]         ;3026
0000f6  6b61              LDR      r1,[r4,#0x34]         ;3027
0000f8  6508              STR      r0,[r1,#0x50]         ;3027
0000fa  8d23              LDRH     r3,[r4,#0x28]         ;3030
0000fc  f8d4c000          LDR      r12,[r4,#0]           ;3030
000100  f10c0210          ADD      r2,r12,#0x10          ;3030
000104  6a61              LDR      r1,[r4,#0x24]         ;3030
000106  6b60              LDR      r0,[r4,#0x34]         ;3030
000108  f7fffffe          BL       HAL_DMA_Start_IT
00010c  4605              MOV      r5,r0                 ;3030
00010e  bb5d              CBNZ     r5,|L34.360|
000110  2023              MOVS     r0,#0x23              ;3035
000112  465b              MOV      r3,r11                ;3035
000114  463a              MOV      r2,r7                 ;3035
000116  4631              MOV      r1,r6                 ;3035
000118  e9cd0a00          STRD     r0,r10,[sp,#0]        ;3035
00011c  4620              MOV      r0,r4                 ;3035
00011e  e000              B        |L34.290|
                  |L34.288|
000120  e044              B        |L34.428|
                  |L34.290|
000122  f7fffffe          BL       I2C_RequestMemoryWrite
000126  b108              CBZ      r0,|L34.300|
000128  2001              MOVS     r0,#1                 ;3037
00012a  e7a0              B        |L34.110|
                  |L34.300|
00012c  bf00              NOP                            ;3041
00012e  2000              MOVS     r0,#0                 ;3041
000130  9001              STR      r0,[sp,#4]            ;3041
000132  6820              LDR      r0,[r4,#0]            ;3041
000134  6940              LDR      r0,[r0,#0x14]         ;3041
000136  9001              STR      r0,[sp,#4]            ;3041
000138  6820              LDR      r0,[r4,#0]            ;3041
00013a  6980              LDR      r0,[r0,#0x18]         ;3041
00013c  9001              STR      r0,[sp,#4]            ;3041
00013e  bf00              NOP                            ;3041
000140  bf00              NOP                            ;3041
000142  bf00              NOP                            ;3044
000144  2000              MOVS     r0,#0                 ;3044
000146  f884003c          STRB     r0,[r4,#0x3c]         ;3044
00014a  bf00              NOP                            ;3044
00014c  6820              LDR      r0,[r4,#0]            ;3050
00014e  6840              LDR      r0,[r0,#4]            ;3050
000150  f4407080          ORR      r0,r0,#0x100          ;3050
000154  6821              LDR      r1,[r4,#0]            ;3050
000156  6048              STR      r0,[r1,#4]            ;3050
000158  6820              LDR      r0,[r4,#0]            ;3053
00015a  6840              LDR      r0,[r0,#4]            ;3053
00015c  f4406000          ORR      r0,r0,#0x800          ;3053
000160  6821              LDR      r1,[r4,#0]            ;3053
000162  6048              STR      r0,[r1,#4]            ;3053
000164  2000              MOVS     r0,#0                 ;3055
000166  e782              B        |L34.110|
                  |L34.360|
000168  2020              MOVS     r0,#0x20              ;3060
00016a  f884003d          STRB     r0,[r4,#0x3d]         ;3060
00016e  2000              MOVS     r0,#0                 ;3061
000170  f884003e          STRB     r0,[r4,#0x3e]         ;3061
000174  6c20              LDR      r0,[r4,#0x40]         ;3064
000176  f0400010          ORR      r0,r0,#0x10           ;3064
00017a  6420              STR      r0,[r4,#0x40]         ;3064
00017c  bf00              NOP                            ;3067
00017e  2000              MOVS     r0,#0                 ;3067
000180  f884003c          STRB     r0,[r4,#0x3c]         ;3067
000184  bf00              NOP                            ;3067
000186  2001              MOVS     r0,#1                 ;3069
000188  e771              B        |L34.110|
                  |L34.394|
00018a  2020              MOVS     r0,#0x20              ;3075
00018c  f884003d          STRB     r0,[r4,#0x3d]         ;3075
000190  2000              MOVS     r0,#0                 ;3076
000192  f884003e          STRB     r0,[r4,#0x3e]         ;3076
000196  6c20              LDR      r0,[r4,#0x40]         ;3079
000198  f0400040          ORR      r0,r0,#0x40           ;3079
00019c  6420              STR      r0,[r4,#0x40]         ;3079
00019e  bf00              NOP                            ;3082
0001a0  2000              MOVS     r0,#0                 ;3082
0001a2  f884003c          STRB     r0,[r4,#0x3c]         ;3082
0001a6  bf00              NOP                            ;3082
0001a8  2001              MOVS     r0,#1                 ;3084
0001aa  e760              B        |L34.110|
                  |L34.428|
0001ac  2002              MOVS     r0,#2                 ;3089
0001ae  e75e              B        |L34.110|
;;;3092   
                          ENDP

                  |L34.432|
                          DCD      SystemCoreClock
                  |L34.436|
                          DCD      0xffff0000
                  |L34.440|
                          DCD      I2C_DMAXferCplt
                  |L34.444|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Write_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_IT PROC
;;;2776     */
;;;2777   HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2778   {
000002  4604              MOV      r4,r0
000004  e9dd5606          LDRD     r5,r6,[sp,#0x18]
;;;2779     __IO uint32_t count = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2780   
;;;2781     /* Check the parameters */
;;;2782     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2783   
;;;2784     if (hi2c->State == HAL_I2C_STATE_READY)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2820              CMP      r0,#0x20
000012  d16f              BNE      |L35.244|
;;;2785     {
;;;2786       /* Wait until BUSY flag is reset */
;;;2787       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
000014  4838              LDR      r0,|L35.248|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  2719              MOVS     r7,#0x19
00001a  fbb0f0f7          UDIV     r0,r0,r7
00001e  f44f777a          MOV      r7,#0x3e8
000022  fbb0f0f7          UDIV     r0,r0,r7
000026  eb0007c0          ADD      r7,r0,r0,LSL #3
00002a  eb071000          ADD      r0,r7,r0,LSL #4
00002e  9000              STR      r0,[sp,#0]
;;;2788       do
000030  bf00              NOP      
                  |L35.50|
;;;2789       {
;;;2790         count--;
000032  9800              LDR      r0,[sp,#0]
000034  1e40              SUBS     r0,r0,#1
000036  9000              STR      r0,[sp,#0]
;;;2791         if (count == 0U)
000038  9800              LDR      r0,[sp,#0]
00003a  b990              CBNZ     r0,|L35.98|
;;;2792         {
;;;2793           hi2c->PreviousState       = I2C_STATE_NONE;
00003c  2000              MOVS     r0,#0
00003e  6320              STR      r0,[r4,#0x30]
;;;2794           hi2c->State               = HAL_I2C_STATE_READY;
000040  2020              MOVS     r0,#0x20
000042  f884003d          STRB     r0,[r4,#0x3d]
;;;2795           hi2c->Mode                = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;2796           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
00004c  6c20              LDR      r0,[r4,#0x40]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6420              STR      r0,[r4,#0x40]
;;;2797   
;;;2798           /* Process Unlocked */
;;;2799           __HAL_UNLOCK(hi2c);
000054  bf00              NOP      
000056  2000              MOVS     r0,#0
000058  f884003c          STRB     r0,[r4,#0x3c]
00005c  bf00              NOP      
;;;2800   
;;;2801           return HAL_ERROR;
00005e  2001              MOVS     r0,#1
                  |L35.96|
;;;2802         }
;;;2803       }
;;;2804       while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2805   
;;;2806       /* Process Locked */
;;;2807       __HAL_LOCK(hi2c);
;;;2808   
;;;2809       /* Check if the I2C is already enabled */
;;;2810       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2811       {
;;;2812         /* Enable I2C peripheral */
;;;2813         __HAL_I2C_ENABLE(hi2c);
;;;2814       }
;;;2815   
;;;2816       /* Disable Pos */
;;;2817       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2818   
;;;2819       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2820       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2821       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2822   
;;;2823       /* Prepare transfer parameters */
;;;2824       hi2c->pBuffPtr    = pData;
;;;2825       hi2c->XferCount   = Size;
;;;2826       hi2c->XferSize    = hi2c->XferCount;
;;;2827       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2828       hi2c->Devaddress  = DevAddress;
;;;2829       hi2c->Memaddress  = MemAddress;
;;;2830       hi2c->MemaddSize  = MemAddSize;
;;;2831       hi2c->EventCount  = 0U;
;;;2832   
;;;2833       /* Generate Start */
;;;2834       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2835   
;;;2836       /* Process Unlocked */
;;;2837       __HAL_UNLOCK(hi2c);
;;;2838   
;;;2839       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2840       to avoid the risk of I2C interrupt handle execution before current
;;;2841       process unlock */
;;;2842   
;;;2843       /* Enable EVT, BUF and ERR interrupt */
;;;2844       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2845   
;;;2846       return HAL_OK;
;;;2847     }
;;;2848     else
;;;2849     {
;;;2850       return HAL_BUSY;
;;;2851     }
;;;2852   }
000060  bdf8              POP      {r3-r7,pc}
                  |L35.98|
000062  6820              LDR      r0,[r4,#0]            ;2804
000064  6980              LDR      r0,[r0,#0x18]         ;2804
000066  f3c00040          UBFX     r0,r0,#1,#1           ;2804
00006a  2800              CMP      r0,#0                 ;2804
00006c  d1e1              BNE      |L35.50|
00006e  bf00              NOP                            ;2807
000070  f894003c          LDRB     r0,[r4,#0x3c]         ;2807
000074  2801              CMP      r0,#1                 ;2807
000076  d101              BNE      |L35.124|
000078  2002              MOVS     r0,#2                 ;2807
00007a  e7f1              B        |L35.96|
                  |L35.124|
00007c  2001              MOVS     r0,#1                 ;2807
00007e  f884003c          STRB     r0,[r4,#0x3c]         ;2807
000082  bf00              NOP                            ;2807
000084  6820              LDR      r0,[r4,#0]            ;2810
000086  6800              LDR      r0,[r0,#0]            ;2810
000088  f0000001          AND      r0,r0,#1              ;2810
00008c  b928              CBNZ     r0,|L35.154|
00008e  6820              LDR      r0,[r4,#0]            ;2813
000090  6800              LDR      r0,[r0,#0]            ;2813
000092  f0400001          ORR      r0,r0,#1              ;2813
000096  6827              LDR      r7,[r4,#0]            ;2813
000098  6038              STR      r0,[r7,#0]            ;2813
                  |L35.154|
00009a  6820              LDR      r0,[r4,#0]            ;2817
00009c  6800              LDR      r0,[r0,#0]            ;2817
00009e  f4206000          BIC      r0,r0,#0x800          ;2817
0000a2  6827              LDR      r7,[r4,#0]            ;2817
0000a4  6038              STR      r0,[r7,#0]            ;2817
0000a6  2021              MOVS     r0,#0x21              ;2819
0000a8  f884003d          STRB     r0,[r4,#0x3d]         ;2819
0000ac  2040              MOVS     r0,#0x40              ;2820
0000ae  f884003e          STRB     r0,[r4,#0x3e]         ;2820
0000b2  2000              MOVS     r0,#0                 ;2821
0000b4  6420              STR      r0,[r4,#0x40]         ;2821
0000b6  6265              STR      r5,[r4,#0x24]         ;2824
0000b8  8566              STRH     r6,[r4,#0x2a]         ;2825
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;2826
0000bc  8520              STRH     r0,[r4,#0x28]         ;2826
0000be  480f              LDR      r0,|L35.252|
0000c0  62e0              STR      r0,[r4,#0x2c]         ;2827
0000c2  6461              STR      r1,[r4,#0x44]         ;2828
0000c4  64a2              STR      r2,[r4,#0x48]         ;2829
0000c6  64e3              STR      r3,[r4,#0x4c]         ;2830
0000c8  2000              MOVS     r0,#0                 ;2831
0000ca  6520              STR      r0,[r4,#0x50]         ;2831
0000cc  6820              LDR      r0,[r4,#0]            ;2834
0000ce  6800              LDR      r0,[r0,#0]            ;2834
0000d0  f4407080          ORR      r0,r0,#0x100          ;2834
0000d4  6827              LDR      r7,[r4,#0]            ;2834
0000d6  6038              STR      r0,[r7,#0]            ;2834
0000d8  bf00              NOP                            ;2837
0000da  2000              MOVS     r0,#0                 ;2837
0000dc  f884003c          STRB     r0,[r4,#0x3c]         ;2837
0000e0  bf00              NOP                            ;2837
0000e2  6820              LDR      r0,[r4,#0]            ;2844
0000e4  6840              LDR      r0,[r0,#4]            ;2844
0000e6  f44060e0          ORR      r0,r0,#0x700          ;2844
0000ea  6827              LDR      r7,[r4,#0]            ;2844
0000ec  6078              STR      r0,[r7,#4]            ;2844
0000ee  2000              MOVS     r0,#0                 ;2846
0000f0  e7b6              B        |L35.96|
0000f2  e7ff              B        |L35.244|
                  |L35.244|
0000f4  2002              MOVS     r0,#2                 ;2850
0000f6  e7b3              B        |L35.96|
;;;2853   
                          ENDP

                  |L35.248|
                          DCD      SystemCoreClock
                  |L35.252|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspDeInit PROC
;;;603      */
;;;604    __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;605    {
;;;606      /* Prevent unused argument(s) compilation warning */
;;;607      UNUSED(hi2c);
;;;608    
;;;609      /* NOTE : This function should not be modified, when the callback is needed,
;;;610                the HAL_I2C_MspDeInit could be implemented in the user file
;;;611       */
;;;612    }
;;;613    
                          ENDP


                          AREA ||i.HAL_I2C_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspInit PROC
;;;587      */
;;;588    __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;589    {
;;;590      /* Prevent unused argument(s) compilation warning */
;;;591      UNUSED(hi2c);
;;;592    
;;;593      /* NOTE : This function should not be modified, when the callback is needed,
;;;594                the HAL_I2C_MspInit could be implemented in the user file
;;;595       */
;;;596    }
;;;597    
                          ENDP


                          AREA ||i.HAL_I2C_SlaveRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveRxCpltCallback PROC
;;;4813     */
;;;4814   __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4815   {
;;;4816     /* Prevent unused argument(s) compilation warning */
;;;4817     UNUSED(hi2c);
;;;4818   
;;;4819     /* NOTE : This function should not be modified, when the callback is needed,
;;;4820               the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
;;;4821      */
;;;4822   }
;;;4823   
                          ENDP


                          AREA ||i.HAL_I2C_SlaveTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveTxCpltCallback PROC
;;;4797     */
;;;4798   __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;4799   {
;;;4800     /* Prevent unused argument(s) compilation warning */
;;;4801     UNUSED(hi2c);
;;;4802   
;;;4803     /* NOTE : This function should not be modified, when the callback is needed,
;;;4804               the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
;;;4805      */
;;;4806   }
;;;4807   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive PROC
;;;1518     */
;;;1519   HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1520   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1521     /* Init tickstart for timeout management*/
;;;1522     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;1523   
;;;1524     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2820              CMP      r0,#0x20
000018  d17e              BNE      |L40.280|
;;;1525     {
;;;1526       if ((pData == NULL) || (Size == (uint16_t)0))
00001a  b105              CBZ      r5,|L40.30|
00001c  b916              CBNZ     r6,|L40.36|
                  |L40.30|
;;;1527       {
;;;1528         return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L40.32|
;;;1529       }
;;;1530   
;;;1531       /* Process Locked */
;;;1532       __HAL_LOCK(hi2c);
;;;1533   
;;;1534       /* Check if the I2C is already enabled */
;;;1535       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1536       {
;;;1537         /* Enable I2C peripheral */
;;;1538         __HAL_I2C_ENABLE(hi2c);
;;;1539       }
;;;1540   
;;;1541       /* Disable Pos */
;;;1542       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1543   
;;;1544       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1545       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1546       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1547   
;;;1548       /* Prepare transfer parameters */
;;;1549       hi2c->pBuffPtr    = pData;
;;;1550       hi2c->XferCount   = Size;
;;;1551       hi2c->XferSize    = hi2c->XferCount;
;;;1552       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1553   
;;;1554       /* Enable Address Acknowledge */
;;;1555       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1556   
;;;1557       /* Wait until ADDR flag is set */
;;;1558       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1559       {
;;;1560         return HAL_ERROR;
;;;1561       }
;;;1562   
;;;1563       /* Clear ADDR flag */
;;;1564       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1565   
;;;1566       while (hi2c->XferSize > 0U)
;;;1567       {
;;;1568         /* Wait until RXNE flag is set */
;;;1569         if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1570         {
;;;1571           /* Disable Address Acknowledge */
;;;1572           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1573   
;;;1574           return HAL_ERROR;
;;;1575         }
;;;1576   
;;;1577         /* Read data from DR */
;;;1578         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1579   
;;;1580         /* Increment Buffer pointer */
;;;1581         hi2c->pBuffPtr++;
;;;1582   
;;;1583         /* Update counter */
;;;1584         hi2c->XferSize--;
;;;1585         hi2c->XferCount--;
;;;1586   
;;;1587         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1588         {
;;;1589           /* Read data from DR */
;;;1590           *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
;;;1591   
;;;1592           /* Increment Buffer pointer */
;;;1593           hi2c->pBuffPtr++;
;;;1594   
;;;1595           /* Update counter */
;;;1596           hi2c->XferSize--;
;;;1597           hi2c->XferCount--;
;;;1598         }
;;;1599       }
;;;1600   
;;;1601       /* Wait until STOP flag is set */
;;;1602       if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1603       {
;;;1604         /* Disable Address Acknowledge */
;;;1605         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1606   
;;;1607         return HAL_ERROR;
;;;1608       }
;;;1609   
;;;1610       /* Clear STOP flag */
;;;1611       __HAL_I2C_CLEAR_STOPFLAG(hi2c);
;;;1612   
;;;1613       /* Disable Address Acknowledge */
;;;1614       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1615   
;;;1616       hi2c->State = HAL_I2C_STATE_READY;
;;;1617       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1618   
;;;1619       /* Process Unlocked */
;;;1620       __HAL_UNLOCK(hi2c);
;;;1621   
;;;1622       return HAL_OK;
;;;1623     }
;;;1624     else
;;;1625     {
;;;1626       return HAL_BUSY;
;;;1627     }
;;;1628   }
000020  e8bd83f8          POP      {r3-r9,pc}
                  |L40.36|
000024  bf00              NOP                            ;1532
000026  f894003c          LDRB     r0,[r4,#0x3c]         ;1532
00002a  2801              CMP      r0,#1                 ;1532
00002c  d101              BNE      |L40.50|
00002e  2002              MOVS     r0,#2                 ;1532
000030  e7f6              B        |L40.32|
                  |L40.50|
000032  2001              MOVS     r0,#1                 ;1532
000034  f884003c          STRB     r0,[r4,#0x3c]         ;1532
000038  bf00              NOP                            ;1532
00003a  6820              LDR      r0,[r4,#0]            ;1535
00003c  6800              LDR      r0,[r0,#0]            ;1535
00003e  f0000001          AND      r0,r0,#1              ;1535
000042  b928              CBNZ     r0,|L40.80|
000044  6820              LDR      r0,[r4,#0]            ;1538
000046  6800              LDR      r0,[r0,#0]            ;1538
000048  f0400001          ORR      r0,r0,#1              ;1538
00004c  6821              LDR      r1,[r4,#0]            ;1538
00004e  6008              STR      r0,[r1,#0]            ;1538
                  |L40.80|
000050  6820              LDR      r0,[r4,#0]            ;1542
000052  6800              LDR      r0,[r0,#0]            ;1542
000054  f4206000          BIC      r0,r0,#0x800          ;1542
000058  6821              LDR      r1,[r4,#0]            ;1542
00005a  6008              STR      r0,[r1,#0]            ;1542
00005c  2022              MOVS     r0,#0x22              ;1544
00005e  f884003d          STRB     r0,[r4,#0x3d]         ;1544
000062  2020              MOVS     r0,#0x20              ;1545
000064  f884003e          STRB     r0,[r4,#0x3e]         ;1545
000068  2000              MOVS     r0,#0                 ;1546
00006a  6420              STR      r0,[r4,#0x40]         ;1546
00006c  6265              STR      r5,[r4,#0x24]         ;1549
00006e  8566              STRH     r6,[r4,#0x2a]         ;1550
000070  8d60              LDRH     r0,[r4,#0x2a]         ;1551
000072  8520              STRH     r0,[r4,#0x28]         ;1551
000074  4840              LDR      r0,|L40.376|
000076  62e0              STR      r0,[r4,#0x2c]         ;1552
000078  6820              LDR      r0,[r4,#0]            ;1555
00007a  6800              LDR      r0,[r0,#0]            ;1555
00007c  f4406080          ORR      r0,r0,#0x400          ;1555
000080  6821              LDR      r1,[r4,#0]            ;1555
000082  6008              STR      r0,[r1,#0]            ;1555
000084  463b              MOV      r3,r7                 ;1558
000086  2200              MOVS     r2,#0                 ;1558
000088  493c              LDR      r1,|L40.380|
00008a  4620              MOV      r0,r4                 ;1558
00008c  f8cd8000          STR      r8,[sp,#0]            ;1558
000090  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000094  b108              CBZ      r0,|L40.154|
000096  2001              MOVS     r0,#1                 ;1560
000098  e7c2              B        |L40.32|
                  |L40.154|
00009a  bf00              NOP                            ;1564
00009c  2000              MOVS     r0,#0                 ;1564
00009e  9000              STR      r0,[sp,#0]            ;1564
0000a0  6820              LDR      r0,[r4,#0]            ;1564
0000a2  6940              LDR      r0,[r0,#0x14]         ;1564
0000a4  9000              STR      r0,[sp,#0]            ;1564
0000a6  6820              LDR      r0,[r4,#0]            ;1564
0000a8  6980              LDR      r0,[r0,#0x18]         ;1564
0000aa  9000              STR      r0,[sp,#0]            ;1564
0000ac  bf00              NOP                            ;1564
0000ae  bf00              NOP                            ;1564
0000b0  e02e              B        |L40.272|
                  |L40.178|
0000b2  4642              MOV      r2,r8                 ;1569
0000b4  4639              MOV      r1,r7                 ;1569
0000b6  4620              MOV      r0,r4                 ;1569
0000b8  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000bc  b138              CBZ      r0,|L40.206|
0000be  6820              LDR      r0,[r4,#0]            ;1572
0000c0  6800              LDR      r0,[r0,#0]            ;1572
0000c2  f4206080          BIC      r0,r0,#0x400          ;1572
0000c6  6821              LDR      r1,[r4,#0]            ;1572
0000c8  6008              STR      r0,[r1,#0]            ;1572
0000ca  2001              MOVS     r0,#1                 ;1574
0000cc  e7a8              B        |L40.32|
                  |L40.206|
0000ce  6820              LDR      r0,[r4,#0]            ;1578
0000d0  6900              LDR      r0,[r0,#0x10]         ;1578
0000d2  6a61              LDR      r1,[r4,#0x24]         ;1578
0000d4  7008              STRB     r0,[r1,#0]            ;1578
0000d6  6a60              LDR      r0,[r4,#0x24]         ;1581
0000d8  1c40              ADDS     r0,r0,#1              ;1581
0000da  6260              STR      r0,[r4,#0x24]         ;1581
0000dc  8d20              LDRH     r0,[r4,#0x28]         ;1584
0000de  1e40              SUBS     r0,r0,#1              ;1584
0000e0  8520              STRH     r0,[r4,#0x28]         ;1584
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;1585
0000e4  1e40              SUBS     r0,r0,#1              ;1585
0000e6  8560              STRH     r0,[r4,#0x2a]         ;1585
0000e8  6820              LDR      r0,[r4,#0]            ;1587
0000ea  6940              LDR      r0,[r0,#0x14]         ;1587
0000ec  f3c00080          UBFX     r0,r0,#2,#1           ;1587
0000f0  b170              CBZ      r0,|L40.272|
0000f2  8d20              LDRH     r0,[r4,#0x28]         ;1587
0000f4  b160              CBZ      r0,|L40.272|
0000f6  6820              LDR      r0,[r4,#0]            ;1590
0000f8  6900              LDR      r0,[r0,#0x10]         ;1590
0000fa  6a61              LDR      r1,[r4,#0x24]         ;1590
0000fc  7008              STRB     r0,[r1,#0]            ;1590
0000fe  6a60              LDR      r0,[r4,#0x24]         ;1593
000100  1c40              ADDS     r0,r0,#1              ;1593
000102  6260              STR      r0,[r4,#0x24]         ;1593
000104  8d20              LDRH     r0,[r4,#0x28]         ;1596
000106  1e40              SUBS     r0,r0,#1              ;1596
000108  8520              STRH     r0,[r4,#0x28]         ;1596
00010a  8d60              LDRH     r0,[r4,#0x2a]         ;1597
00010c  1e40              SUBS     r0,r0,#1              ;1597
00010e  8560              STRH     r0,[r4,#0x2a]         ;1597
                  |L40.272|
000110  8d20              LDRH     r0,[r4,#0x28]         ;1566
000112  2800              CMP      r0,#0                 ;1566
000114  d1cd              BNE      |L40.178|
000116  e000              B        |L40.282|
                  |L40.280|
000118  e02c              B        |L40.372|
                  |L40.282|
00011a  4642              MOV      r2,r8                 ;1602
00011c  4639              MOV      r1,r7                 ;1602
00011e  4620              MOV      r0,r4                 ;1602
000120  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000124  b138              CBZ      r0,|L40.310|
000126  6820              LDR      r0,[r4,#0]            ;1605
000128  6800              LDR      r0,[r0,#0]            ;1605
00012a  f4206080          BIC      r0,r0,#0x400          ;1605
00012e  6821              LDR      r1,[r4,#0]            ;1605
000130  6008              STR      r0,[r1,#0]            ;1605
000132  2001              MOVS     r0,#1                 ;1607
000134  e774              B        |L40.32|
                  |L40.310|
000136  bf00              NOP                            ;1611
000138  2000              MOVS     r0,#0                 ;1611
00013a  9000              STR      r0,[sp,#0]            ;1611
00013c  6820              LDR      r0,[r4,#0]            ;1611
00013e  6940              LDR      r0,[r0,#0x14]         ;1611
000140  9000              STR      r0,[sp,#0]            ;1611
000142  6820              LDR      r0,[r4,#0]            ;1611
000144  6800              LDR      r0,[r0,#0]            ;1611
000146  f0400001          ORR      r0,r0,#1              ;1611
00014a  6821              LDR      r1,[r4,#0]            ;1611
00014c  6008              STR      r0,[r1,#0]            ;1611
00014e  bf00              NOP                            ;1611
000150  bf00              NOP                            ;1611
000152  6820              LDR      r0,[r4,#0]            ;1614
000154  6800              LDR      r0,[r0,#0]            ;1614
000156  f4206080          BIC      r0,r0,#0x400          ;1614
00015a  6821              LDR      r1,[r4,#0]            ;1614
00015c  6008              STR      r0,[r1,#0]            ;1614
00015e  2020              MOVS     r0,#0x20              ;1616
000160  f884003d          STRB     r0,[r4,#0x3d]         ;1616
000164  2000              MOVS     r0,#0                 ;1617
000166  f884003e          STRB     r0,[r4,#0x3e]         ;1617
00016a  bf00              NOP                            ;1620
00016c  f884003c          STRB     r0,[r4,#0x3c]         ;1620
000170  bf00              NOP                            ;1620
000172  e755              B        |L40.32|
                  |L40.372|
000174  2002              MOVS     r0,#2                 ;1626
000176  e753              B        |L40.32|
;;;1629   
                          ENDP

                  |L40.376|
                          DCD      0xffff0000
                  |L40.380|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_DMA PROC
;;;2304     */
;;;2305   HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2306   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2307     HAL_StatusTypeDef dmaxferstatus;
;;;2308   
;;;2309     if (hi2c->State == HAL_I2C_STATE_READY)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2820              CMP      r0,#0x20
000010  d173              BNE      |L41.250|
;;;2310     {
;;;2311       if ((pData == NULL) || (Size == 0U))
000012  b105              CBZ      r5,|L41.22|
000014  b916              CBNZ     r6,|L41.28|
                  |L41.22|
;;;2312       {
;;;2313         return  HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L41.24|
;;;2314       }
;;;2315   
;;;2316       /* Process Locked */
;;;2317       __HAL_LOCK(hi2c);
;;;2318   
;;;2319       /* Check if the I2C is already enabled */
;;;2320       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2321       {
;;;2322         /* Enable I2C peripheral */
;;;2323         __HAL_I2C_ENABLE(hi2c);
;;;2324       }
;;;2325   
;;;2326       /* Disable Pos */
;;;2327       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2328   
;;;2329       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2330       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2331       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2332   
;;;2333       /* Prepare transfer parameters */
;;;2334       hi2c->pBuffPtr    = pData;
;;;2335       hi2c->XferCount   = Size;
;;;2336       hi2c->XferSize    = hi2c->XferCount;
;;;2337       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2338   
;;;2339       /* Set the I2C DMA transfer complete callback */
;;;2340       hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;2341   
;;;2342       /* Set the DMA error callback */
;;;2343       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2344   
;;;2345       /* Set the unused DMA callbacks to NULL */
;;;2346       hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2347       hi2c->hdmarx->XferM1CpltCallback = NULL;
;;;2348       hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
;;;2349       hi2c->hdmarx->XferAbortCallback = NULL;
;;;2350   
;;;2351       /* Enable the DMA stream */
;;;2352       dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;2353   
;;;2354       if (dmaxferstatus == HAL_OK)
;;;2355       {
;;;2356         /* Enable Address Acknowledge */
;;;2357         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2358   
;;;2359         /* Process Unlocked */
;;;2360         __HAL_UNLOCK(hi2c);
;;;2361   
;;;2362         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2363         to avoid the risk of I2C interrupt handle execution before current
;;;2364         process unlock */
;;;2365         /* Enable EVT and ERR interrupt */
;;;2366         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2367   
;;;2368         /* Enable DMA Request */
;;;2369         SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2370   
;;;2371         return HAL_OK;
;;;2372       }
;;;2373       else
;;;2374       {
;;;2375         /* Update I2C state */
;;;2376         hi2c->State     = HAL_I2C_STATE_READY;
;;;2377         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2378   
;;;2379         /* Update I2C error code */
;;;2380         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2381   
;;;2382         /* Process Unlocked */
;;;2383         __HAL_UNLOCK(hi2c);
;;;2384   
;;;2385         return HAL_ERROR;
;;;2386       }
;;;2387     }
;;;2388     else
;;;2389     {
;;;2390       return HAL_BUSY;
;;;2391     }
;;;2392   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L41.28|
00001c  bf00              NOP                            ;2317
00001e  f894003c          LDRB     r0,[r4,#0x3c]         ;2317
000022  2801              CMP      r0,#1                 ;2317
000024  d101              BNE      |L41.42|
000026  2002              MOVS     r0,#2                 ;2317
000028  e7f6              B        |L41.24|
                  |L41.42|
00002a  2001              MOVS     r0,#1                 ;2317
00002c  f884003c          STRB     r0,[r4,#0x3c]         ;2317
000030  bf00              NOP                            ;2317
000032  6820              LDR      r0,[r4,#0]            ;2320
000034  6800              LDR      r0,[r0,#0]            ;2320
000036  f0000001          AND      r0,r0,#1              ;2320
00003a  b928              CBNZ     r0,|L41.72|
00003c  6820              LDR      r0,[r4,#0]            ;2323
00003e  6800              LDR      r0,[r0,#0]            ;2323
000040  f0400001          ORR      r0,r0,#1              ;2323
000044  6821              LDR      r1,[r4,#0]            ;2323
000046  6008              STR      r0,[r1,#0]            ;2323
                  |L41.72|
000048  6820              LDR      r0,[r4,#0]            ;2327
00004a  6800              LDR      r0,[r0,#0]            ;2327
00004c  f4206000          BIC      r0,r0,#0x800          ;2327
000050  6821              LDR      r1,[r4,#0]            ;2327
000052  6008              STR      r0,[r1,#0]            ;2327
000054  2022              MOVS     r0,#0x22              ;2329
000056  f884003d          STRB     r0,[r4,#0x3d]         ;2329
00005a  2020              MOVS     r0,#0x20              ;2330
00005c  f884003e          STRB     r0,[r4,#0x3e]         ;2330
000060  2000              MOVS     r0,#0                 ;2331
000062  6420              STR      r0,[r4,#0x40]         ;2331
000064  6265              STR      r5,[r4,#0x24]         ;2334
000066  8566              STRH     r6,[r4,#0x2a]         ;2335
000068  8d60              LDRH     r0,[r4,#0x2a]         ;2336
00006a  8520              STRH     r0,[r4,#0x28]         ;2336
00006c  4824              LDR      r0,|L41.256|
00006e  62e0              STR      r0,[r4,#0x2c]         ;2337
000070  4824              LDR      r0,|L41.260|
000072  6ba1              LDR      r1,[r4,#0x38]         ;2340
000074  63c8              STR      r0,[r1,#0x3c]         ;2340
000076  4824              LDR      r0,|L41.264|
000078  6ba1              LDR      r1,[r4,#0x38]         ;2343
00007a  64c8              STR      r0,[r1,#0x4c]         ;2343
00007c  2000              MOVS     r0,#0                 ;2346
00007e  6ba1              LDR      r1,[r4,#0x38]         ;2346
000080  6408              STR      r0,[r1,#0x40]         ;2346
000082  6ba1              LDR      r1,[r4,#0x38]         ;2347
000084  6448              STR      r0,[r1,#0x44]         ;2347
000086  6ba1              LDR      r1,[r4,#0x38]         ;2348
000088  6488              STR      r0,[r1,#0x48]         ;2348
00008a  6ba1              LDR      r1,[r4,#0x38]         ;2349
00008c  6508              STR      r0,[r1,#0x50]         ;2349
00008e  8d23              LDRH     r3,[r4,#0x28]         ;2352
000090  f8d4c000          LDR      r12,[r4,#0]           ;2352
000094  f10c0110          ADD      r1,r12,#0x10          ;2352
000098  6a62              LDR      r2,[r4,#0x24]         ;2352
00009a  6ba0              LDR      r0,[r4,#0x38]         ;2352
00009c  f7fffffe          BL       HAL_DMA_Start_IT
0000a0  4607              MOV      r7,r0                 ;2352
0000a2  b9c7              CBNZ     r7,|L41.214|
0000a4  6820              LDR      r0,[r4,#0]            ;2357
0000a6  6800              LDR      r0,[r0,#0]            ;2357
0000a8  f4406080          ORR      r0,r0,#0x400          ;2357
0000ac  6821              LDR      r1,[r4,#0]            ;2357
0000ae  6008              STR      r0,[r1,#0]            ;2357
0000b0  bf00              NOP                            ;2360
0000b2  2000              MOVS     r0,#0                 ;2360
0000b4  f884003c          STRB     r0,[r4,#0x3c]         ;2360
0000b8  bf00              NOP                            ;2360
0000ba  6820              LDR      r0,[r4,#0]            ;2366
0000bc  6840              LDR      r0,[r0,#4]            ;2366
0000be  f4407040          ORR      r0,r0,#0x300          ;2366
0000c2  6821              LDR      r1,[r4,#0]            ;2366
0000c4  6048              STR      r0,[r1,#4]            ;2366
0000c6  6820              LDR      r0,[r4,#0]            ;2369
0000c8  6840              LDR      r0,[r0,#4]            ;2369
0000ca  f4406000          ORR      r0,r0,#0x800          ;2369
0000ce  6821              LDR      r1,[r4,#0]            ;2369
0000d0  6048              STR      r0,[r1,#4]            ;2369
0000d2  2000              MOVS     r0,#0                 ;2371
0000d4  e7a0              B        |L41.24|
                  |L41.214|
0000d6  2020              MOVS     r0,#0x20              ;2376
0000d8  f884003d          STRB     r0,[r4,#0x3d]         ;2376
0000dc  2000              MOVS     r0,#0                 ;2377
0000de  f884003e          STRB     r0,[r4,#0x3e]         ;2377
0000e2  6c20              LDR      r0,[r4,#0x40]         ;2380
0000e4  f0400010          ORR      r0,r0,#0x10           ;2380
0000e8  6420              STR      r0,[r4,#0x40]         ;2380
0000ea  bf00              NOP                            ;2383
0000ec  2000              MOVS     r0,#0                 ;2383
0000ee  f884003c          STRB     r0,[r4,#0x3c]         ;2383
0000f2  bf00              NOP                            ;2383
0000f4  2001              MOVS     r0,#1                 ;2385
0000f6  e78f              B        |L41.24|
0000f8  e7ff              B        |L41.250|
                  |L41.250|
0000fa  2002              MOVS     r0,#2                 ;2390
0000fc  e78c              B        |L41.24|
;;;2393   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L41.256|
                          DCD      0xffff0000
                  |L41.260|
                          DCD      I2C_DMAXferCplt
                  |L41.264|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_IT PROC
;;;1863     */
;;;1864   HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1865   {
000002  4603              MOV      r3,r0
;;;1866   
;;;1867     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2820              CMP      r0,#0x20
00000a  d140              BNE      |L42.142|
;;;1868     {
;;;1869       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L42.16|
00000e  b90a              CBNZ     r2,|L42.20|
                  |L42.16|
;;;1870       {
;;;1871         return  HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L42.18|
;;;1872       }
;;;1873   
;;;1874       /* Process Locked */
;;;1875       __HAL_LOCK(hi2c);
;;;1876   
;;;1877       /* Check if the I2C is already enabled */
;;;1878       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1879       {
;;;1880         /* Enable I2C peripheral */
;;;1881         __HAL_I2C_ENABLE(hi2c);
;;;1882       }
;;;1883   
;;;1884       /* Disable Pos */
;;;1885       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1886   
;;;1887       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1888       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1889       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1890   
;;;1891       /* Prepare transfer parameters */
;;;1892       hi2c->pBuffPtr    = pData;
;;;1893       hi2c->XferCount   = Size;
;;;1894       hi2c->XferSize    = hi2c->XferCount;
;;;1895       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1896   
;;;1897       /* Enable Address Acknowledge */
;;;1898       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1899   
;;;1900       /* Process Unlocked */
;;;1901       __HAL_UNLOCK(hi2c);
;;;1902   
;;;1903       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1904                 to avoid the risk of I2C interrupt handle execution before current
;;;1905                 process unlock */
;;;1906   
;;;1907       /* Enable EVT, BUF and ERR interrupt */
;;;1908       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1909   
;;;1910       return HAL_OK;
;;;1911     }
;;;1912     else
;;;1913     {
;;;1914       return HAL_BUSY;
;;;1915     }
;;;1916   }
000012  bd10              POP      {r4,pc}
                  |L42.20|
000014  bf00              NOP                            ;1875
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;1875
00001a  2801              CMP      r0,#1                 ;1875
00001c  d101              BNE      |L42.34|
00001e  2002              MOVS     r0,#2                 ;1875
000020  e7f7              B        |L42.18|
                  |L42.34|
000022  2001              MOVS     r0,#1                 ;1875
000024  f883003c          STRB     r0,[r3,#0x3c]         ;1875
000028  bf00              NOP                            ;1875
00002a  6818              LDR      r0,[r3,#0]            ;1878
00002c  6800              LDR      r0,[r0,#0]            ;1878
00002e  f0000001          AND      r0,r0,#1              ;1878
000032  b928              CBNZ     r0,|L42.64|
000034  6818              LDR      r0,[r3,#0]            ;1881
000036  6800              LDR      r0,[r0,#0]            ;1881
000038  f0400001          ORR      r0,r0,#1              ;1881
00003c  681c              LDR      r4,[r3,#0]            ;1881
00003e  6020              STR      r0,[r4,#0]            ;1881
                  |L42.64|
000040  6818              LDR      r0,[r3,#0]            ;1885
000042  6800              LDR      r0,[r0,#0]            ;1885
000044  f4206000          BIC      r0,r0,#0x800          ;1885
000048  681c              LDR      r4,[r3,#0]            ;1885
00004a  6020              STR      r0,[r4,#0]            ;1885
00004c  2022              MOVS     r0,#0x22              ;1887
00004e  f883003d          STRB     r0,[r3,#0x3d]         ;1887
000052  2020              MOVS     r0,#0x20              ;1888
000054  f883003e          STRB     r0,[r3,#0x3e]         ;1888
000058  2000              MOVS     r0,#0                 ;1889
00005a  6418              STR      r0,[r3,#0x40]         ;1889
00005c  6259              STR      r1,[r3,#0x24]         ;1892
00005e  855a              STRH     r2,[r3,#0x2a]         ;1893
000060  8d58              LDRH     r0,[r3,#0x2a]         ;1894
000062  8518              STRH     r0,[r3,#0x28]         ;1894
000064  480b              LDR      r0,|L42.148|
000066  62d8              STR      r0,[r3,#0x2c]         ;1895
000068  6818              LDR      r0,[r3,#0]            ;1898
00006a  6800              LDR      r0,[r0,#0]            ;1898
00006c  f4406080          ORR      r0,r0,#0x400          ;1898
000070  681c              LDR      r4,[r3,#0]            ;1898
000072  6020              STR      r0,[r4,#0]            ;1898
000074  bf00              NOP                            ;1901
000076  2000              MOVS     r0,#0                 ;1901
000078  f883003c          STRB     r0,[r3,#0x3c]         ;1901
00007c  bf00              NOP                            ;1901
00007e  6818              LDR      r0,[r3,#0]            ;1908
000080  6840              LDR      r0,[r0,#4]            ;1908
000082  f44060e0          ORR      r0,r0,#0x700          ;1908
000086  681c              LDR      r4,[r3,#0]            ;1908
000088  6060              STR      r0,[r4,#4]            ;1908
00008a  2000              MOVS     r0,#0                 ;1910
00008c  e7c1              B        |L42.18|
                  |L42.142|
00008e  2002              MOVS     r0,#2                 ;1914
000090  e7bf              B        |L42.18|
;;;1917   
                          ENDP

000092  0000              DCW      0x0000
                  |L42.148|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Slave_Seq_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Receive_DMA PROC
;;;4252     */
;;;4253   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4254   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;4255     HAL_StatusTypeDef dmaxferstatus;
;;;4256   
;;;4257     /* Check the parameters */
;;;4258     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4259   
;;;4260     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  f0000028          AND      r0,r0,#0x28
000014  2828              CMP      r0,#0x28
000016  d17c              BNE      |L43.274|
;;;4261     {
;;;4262       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L43.28|
00001a  b916              CBNZ     r6,|L43.34|
                  |L43.28|
;;;4263       {
;;;4264         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L43.30|
;;;4265       }
;;;4266   
;;;4267       /* Process Locked */
;;;4268       __HAL_LOCK(hi2c);
;;;4269   
;;;4270       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;4271       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4272   
;;;4273       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;4274       /* and then toggle the HAL slave RX state to TX state */
;;;4275       if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;4276       {
;;;4277         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4278         {
;;;4279           /* Abort DMA Xfer if any */
;;;4280           if (hi2c->hdmarx != NULL)
;;;4281           {
;;;4282             CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4283   
;;;4284             /* Set the I2C DMA Abort callback :
;;;4285              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4286             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;4287   
;;;4288             /* Abort DMA RX */
;;;4289             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;4290             {
;;;4291               /* Call Directly XferAbortCallback function in case of error */
;;;4292               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;4293             }
;;;4294           }
;;;4295         }
;;;4296       }
;;;4297       else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;4298       {
;;;4299         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4300         {
;;;4301           CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4302   
;;;4303           /* Abort DMA Xfer if any */
;;;4304           if (hi2c->hdmatx != NULL)
;;;4305           {
;;;4306             /* Set the I2C DMA Abort callback :
;;;4307              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4308             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;4309   
;;;4310             /* Abort DMA TX */
;;;4311             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;4312             {
;;;4313               /* Call Directly XferAbortCallback function in case of error */
;;;4314               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;4315             }
;;;4316           }
;;;4317         }
;;;4318       }
;;;4319       else
;;;4320       {
;;;4321         /* Nothing to do */
;;;4322       }
;;;4323   
;;;4324       /* Check if the I2C is already enabled */
;;;4325       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4326       {
;;;4327         /* Enable I2C peripheral */
;;;4328         __HAL_I2C_ENABLE(hi2c);
;;;4329       }
;;;4330   
;;;4331       /* Disable Pos */
;;;4332       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4333   
;;;4334       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;4335       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4336       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4337   
;;;4338       /* Prepare transfer parameters */
;;;4339       hi2c->pBuffPtr    = pData;
;;;4340       hi2c->XferCount   = Size;
;;;4341       hi2c->XferSize    = hi2c->XferCount;
;;;4342       hi2c->XferOptions = XferOptions;
;;;4343   
;;;4344       /* Set the I2C DMA transfer complete callback */
;;;4345       hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;4346   
;;;4347       /* Set the DMA error callback */
;;;4348       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;4349   
;;;4350       /* Set the unused DMA callbacks to NULL */
;;;4351       hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;4352       hi2c->hdmarx->XferAbortCallback = NULL;
;;;4353   
;;;4354       /* Enable the DMA stream */
;;;4355       dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;4356   
;;;4357       if (dmaxferstatus == HAL_OK)
;;;4358       {
;;;4359         /* Enable Address Acknowledge */
;;;4360         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4361   
;;;4362         /* Clear ADDR flag */
;;;4363         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4364   
;;;4365         /* Process Unlocked */
;;;4366         __HAL_UNLOCK(hi2c);
;;;4367   
;;;4368         /* Enable DMA Request */
;;;4369         SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4370   
;;;4371         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4372         to avoid the risk of I2C interrupt handle execution before current
;;;4373         process unlock */
;;;4374         /* Enable EVT and ERR interrupt */
;;;4375         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4376   
;;;4377         return HAL_OK;
;;;4378       }
;;;4379       else
;;;4380       {
;;;4381         /* Update I2C state */
;;;4382         hi2c->State     = HAL_I2C_STATE_READY;
;;;4383         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4384   
;;;4385         /* Update I2C error code */
;;;4386         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;4387   
;;;4388         /* Process Unlocked */
;;;4389         __HAL_UNLOCK(hi2c);
;;;4390   
;;;4391         return HAL_ERROR;
;;;4392       }
;;;4393     }
;;;4394     else
;;;4395     {
;;;4396       return HAL_BUSY;
;;;4397     }
;;;4398   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L43.34|
000022  bf00              NOP                            ;4268
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;4268
000028  2801              CMP      r0,#1                 ;4268
00002a  d101              BNE      |L43.48|
00002c  2002              MOVS     r0,#2                 ;4268
00002e  e7f6              B        |L43.30|
                  |L43.48|
000030  2001              MOVS     r0,#1                 ;4268
000032  f884003c          STRB     r0,[r4,#0x3c]         ;4268
000036  bf00              NOP                            ;4268
000038  6820              LDR      r0,[r4,#0]            ;4271
00003a  6840              LDR      r0,[r0,#4]            ;4271
00003c  f4207040          BIC      r0,r0,#0x300          ;4271
000040  6821              LDR      r1,[r4,#0]            ;4271
000042  6048              STR      r0,[r1,#4]            ;4271
000044  f894003d          LDRB     r0,[r4,#0x3d]         ;4275
000048  282a              CMP      r0,#0x2a              ;4275
00004a  d119              BNE      |L43.128|
00004c  6820              LDR      r0,[r4,#0]            ;4277
00004e  6840              LDR      r0,[r0,#4]            ;4277
000050  f4006000          AND      r0,r0,#0x800          ;4277
000054  f5b06f00          CMP      r0,#0x800             ;4277
000058  d12f              BNE      |L43.186|
00005a  6ba0              LDR      r0,[r4,#0x38]         ;4280
00005c  b368              CBZ      r0,|L43.186|
00005e  6820              LDR      r0,[r4,#0]            ;4282
000060  6840              LDR      r0,[r0,#4]            ;4282
000062  f4206000          BIC      r0,r0,#0x800          ;4282
000066  6821              LDR      r1,[r4,#0]            ;4282
000068  6048              STR      r0,[r1,#4]            ;4282
00006a  484b              LDR      r0,|L43.408|
00006c  6ba1              LDR      r1,[r4,#0x38]         ;4286
00006e  6508              STR      r0,[r1,#0x50]         ;4286
000070  6ba0              LDR      r0,[r4,#0x38]         ;4289
000072  f7fffffe          BL       HAL_DMA_Abort_IT
000076  b300              CBZ      r0,|L43.186|
000078  6ba0              LDR      r0,[r4,#0x38]         ;4292
00007a  6d01              LDR      r1,[r0,#0x50]         ;4292
00007c  4788              BLX      r1                    ;4292
00007e  e01c              B        |L43.186|
                  |L43.128|
000080  f894003d          LDRB     r0,[r4,#0x3d]         ;4297
000084  2829              CMP      r0,#0x29              ;4297
000086  d118              BNE      |L43.186|
000088  6820              LDR      r0,[r4,#0]            ;4299
00008a  6840              LDR      r0,[r0,#4]            ;4299
00008c  f4006000          AND      r0,r0,#0x800          ;4299
000090  f5b06f00          CMP      r0,#0x800             ;4299
000094  d111              BNE      |L43.186|
000096  6820              LDR      r0,[r4,#0]            ;4301
000098  6840              LDR      r0,[r0,#4]            ;4301
00009a  f4206000          BIC      r0,r0,#0x800          ;4301
00009e  6821              LDR      r1,[r4,#0]            ;4301
0000a0  6048              STR      r0,[r1,#4]            ;4301
0000a2  6b60              LDR      r0,[r4,#0x34]         ;4304
0000a4  b148              CBZ      r0,|L43.186|
0000a6  483c              LDR      r0,|L43.408|
0000a8  6b61              LDR      r1,[r4,#0x34]         ;4308
0000aa  6508              STR      r0,[r1,#0x50]         ;4308
0000ac  6b60              LDR      r0,[r4,#0x34]         ;4311
0000ae  f7fffffe          BL       HAL_DMA_Abort_IT
0000b2  b110              CBZ      r0,|L43.186|
0000b4  6b60              LDR      r0,[r4,#0x34]         ;4314
0000b6  6d01              LDR      r1,[r0,#0x50]         ;4314
0000b8  4788              BLX      r1                    ;4314
                  |L43.186|
0000ba  6820              LDR      r0,[r4,#0]            ;4325
0000bc  6800              LDR      r0,[r0,#0]            ;4325
0000be  f0000001          AND      r0,r0,#1              ;4325
0000c2  b928              CBNZ     r0,|L43.208|
0000c4  6820              LDR      r0,[r4,#0]            ;4328
0000c6  6800              LDR      r0,[r0,#0]            ;4328
0000c8  f0400001          ORR      r0,r0,#1              ;4328
0000cc  6821              LDR      r1,[r4,#0]            ;4328
0000ce  6008              STR      r0,[r1,#0]            ;4328
                  |L43.208|
0000d0  6820              LDR      r0,[r4,#0]            ;4332
0000d2  6800              LDR      r0,[r0,#0]            ;4332
0000d4  f4206000          BIC      r0,r0,#0x800          ;4332
0000d8  6821              LDR      r1,[r4,#0]            ;4332
0000da  6008              STR      r0,[r1,#0]            ;4332
0000dc  202a              MOVS     r0,#0x2a              ;4334
0000de  f884003d          STRB     r0,[r4,#0x3d]         ;4334
0000e2  2020              MOVS     r0,#0x20              ;4335
0000e4  f884003e          STRB     r0,[r4,#0x3e]         ;4335
0000e8  2000              MOVS     r0,#0                 ;4336
0000ea  6420              STR      r0,[r4,#0x40]         ;4336
0000ec  6265              STR      r5,[r4,#0x24]         ;4339
0000ee  8566              STRH     r6,[r4,#0x2a]         ;4340
0000f0  8d60              LDRH     r0,[r4,#0x2a]         ;4341
0000f2  8520              STRH     r0,[r4,#0x28]         ;4341
0000f4  f8c4802c          STR      r8,[r4,#0x2c]         ;4342
0000f8  4828              LDR      r0,|L43.412|
0000fa  6ba1              LDR      r1,[r4,#0x38]         ;4345
0000fc  63c8              STR      r0,[r1,#0x3c]         ;4345
0000fe  4828              LDR      r0,|L43.416|
000100  6ba1              LDR      r1,[r4,#0x38]         ;4348
000102  64c8              STR      r0,[r1,#0x4c]         ;4348
000104  2000              MOVS     r0,#0                 ;4351
000106  6ba1              LDR      r1,[r4,#0x38]         ;4351
000108  6408              STR      r0,[r1,#0x40]         ;4351
00010a  6ba1              LDR      r1,[r4,#0x38]         ;4352
00010c  6508              STR      r0,[r1,#0x50]         ;4352
00010e  8d23              LDRH     r3,[r4,#0x28]         ;4355
000110  e000              B        |L43.276|
                  |L43.274|
000112  e03e              B        |L43.402|
                  |L43.276|
000114  f8d4c000          LDR      r12,[r4,#0]           ;4355
000118  f10c0110          ADD      r1,r12,#0x10          ;4355
00011c  6a62              LDR      r2,[r4,#0x24]         ;4355
00011e  6ba0              LDR      r0,[r4,#0x38]         ;4355
000120  f7fffffe          BL       HAL_DMA_Start_IT
000124  4607              MOV      r7,r0                 ;4355
000126  bb1f              CBNZ     r7,|L43.368|
000128  6820              LDR      r0,[r4,#0]            ;4360
00012a  6800              LDR      r0,[r0,#0]            ;4360
00012c  f4406080          ORR      r0,r0,#0x400          ;4360
000130  6821              LDR      r1,[r4,#0]            ;4360
000132  6008              STR      r0,[r1,#0]            ;4360
000134  bf00              NOP                            ;4363
000136  2000              MOVS     r0,#0                 ;4363
000138  9000              STR      r0,[sp,#0]            ;4363
00013a  6820              LDR      r0,[r4,#0]            ;4363
00013c  6940              LDR      r0,[r0,#0x14]         ;4363
00013e  9000              STR      r0,[sp,#0]            ;4363
000140  6820              LDR      r0,[r4,#0]            ;4363
000142  6980              LDR      r0,[r0,#0x18]         ;4363
000144  9000              STR      r0,[sp,#0]            ;4363
000146  bf00              NOP                            ;4363
000148  bf00              NOP                            ;4363
00014a  bf00              NOP                            ;4366
00014c  2000              MOVS     r0,#0                 ;4366
00014e  f884003c          STRB     r0,[r4,#0x3c]         ;4366
000152  bf00              NOP                            ;4366
000154  6820              LDR      r0,[r4,#0]            ;4369
000156  6840              LDR      r0,[r0,#4]            ;4369
000158  f4406000          ORR      r0,r0,#0x800          ;4369
00015c  6821              LDR      r1,[r4,#0]            ;4369
00015e  6048              STR      r0,[r1,#4]            ;4369
000160  6820              LDR      r0,[r4,#0]            ;4375
000162  6840              LDR      r0,[r0,#4]            ;4375
000164  f4407040          ORR      r0,r0,#0x300          ;4375
000168  6821              LDR      r1,[r4,#0]            ;4375
00016a  6048              STR      r0,[r1,#4]            ;4375
00016c  2000              MOVS     r0,#0                 ;4377
00016e  e756              B        |L43.30|
                  |L43.368|
000170  2020              MOVS     r0,#0x20              ;4382
000172  f884003d          STRB     r0,[r4,#0x3d]         ;4382
000176  2000              MOVS     r0,#0                 ;4383
000178  f884003e          STRB     r0,[r4,#0x3e]         ;4383
00017c  6c20              LDR      r0,[r4,#0x40]         ;4386
00017e  f0400010          ORR      r0,r0,#0x10           ;4386
000182  6420              STR      r0,[r4,#0x40]         ;4386
000184  bf00              NOP                            ;4389
000186  2000              MOVS     r0,#0                 ;4389
000188  f884003c          STRB     r0,[r4,#0x3c]         ;4389
00018c  bf00              NOP                            ;4389
00018e  2001              MOVS     r0,#1                 ;4391
000190  e745              B        |L43.30|
                  |L43.402|
000192  2002              MOVS     r0,#2                 ;4396
000194  e743              B        |L43.30|
;;;4399   
                          ENDP

000196  0000              DCW      0x0000
                  |L43.408|
                          DCD      I2C_DMAAbort
                  |L43.412|
                          DCD      I2C_DMAXferCplt
                  |L43.416|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Seq_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Seq_Receive_IT PROC
;;;4186     */
;;;4187   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b538              PUSH     {r3-r5,lr}
;;;4188   {
000002  4604              MOV      r4,r0
;;;4189     /* Check the parameters */
;;;4190     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4191   
;;;4192     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  f0000028          AND      r0,r0,#0x28
00000c  2828              CMP      r0,#0x28
00000e  d144              BNE      |L44.154|
;;;4193     {
;;;4194       if ((pData == NULL) || (Size == 0U))
000010  b101              CBZ      r1,|L44.20|
000012  b90a              CBNZ     r2,|L44.24|
                  |L44.20|
;;;4195       {
;;;4196         return  HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L44.22|
;;;4197       }
;;;4198   
;;;4199       /* Process Locked */
;;;4200       __HAL_LOCK(hi2c);
;;;4201   
;;;4202       /* Check if the I2C is already enabled */
;;;4203       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4204       {
;;;4205         /* Enable I2C peripheral */
;;;4206         __HAL_I2C_ENABLE(hi2c);
;;;4207       }
;;;4208   
;;;4209       /* Disable Pos */
;;;4210       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4211   
;;;4212       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;4213       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4214       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4215   
;;;4216       /* Prepare transfer parameters */
;;;4217       hi2c->pBuffPtr    = pData;
;;;4218       hi2c->XferCount   = Size;
;;;4219       hi2c->XferSize    = hi2c->XferCount;
;;;4220       hi2c->XferOptions = XferOptions;
;;;4221   
;;;4222       /* Clear ADDR flag */
;;;4223       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4224   
;;;4225       /* Process Unlocked */
;;;4226       __HAL_UNLOCK(hi2c);
;;;4227   
;;;4228       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4229                 to avoid the risk of I2C interrupt handle execution before current
;;;4230                 process unlock */
;;;4231   
;;;4232       /* Enable EVT, BUF and ERR interrupt */
;;;4233       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4234   
;;;4235       return HAL_OK;
;;;4236     }
;;;4237     else
;;;4238     {
;;;4239       return HAL_BUSY;
;;;4240     }
;;;4241   }
000016  bd38              POP      {r3-r5,pc}
                  |L44.24|
000018  bf00              NOP                            ;4200
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;4200
00001e  2801              CMP      r0,#1                 ;4200
000020  d101              BNE      |L44.38|
000022  2002              MOVS     r0,#2                 ;4200
000024  e7f7              B        |L44.22|
                  |L44.38|
000026  2001              MOVS     r0,#1                 ;4200
000028  f884003c          STRB     r0,[r4,#0x3c]         ;4200
00002c  bf00              NOP                            ;4200
00002e  6820              LDR      r0,[r4,#0]            ;4203
000030  6800              LDR      r0,[r0,#0]            ;4203
000032  f0000001          AND      r0,r0,#1              ;4203
000036  b928              CBNZ     r0,|L44.68|
000038  6820              LDR      r0,[r4,#0]            ;4206
00003a  6800              LDR      r0,[r0,#0]            ;4206
00003c  f0400001          ORR      r0,r0,#1              ;4206
000040  6825              LDR      r5,[r4,#0]            ;4206
000042  6028              STR      r0,[r5,#0]            ;4206
                  |L44.68|
000044  6820              LDR      r0,[r4,#0]            ;4210
000046  6800              LDR      r0,[r0,#0]            ;4210
000048  f4206000          BIC      r0,r0,#0x800          ;4210
00004c  6825              LDR      r5,[r4,#0]            ;4210
00004e  6028              STR      r0,[r5,#0]            ;4210
000050  202a              MOVS     r0,#0x2a              ;4212
000052  f884003d          STRB     r0,[r4,#0x3d]         ;4212
000056  2020              MOVS     r0,#0x20              ;4213
000058  f884003e          STRB     r0,[r4,#0x3e]         ;4213
00005c  2000              MOVS     r0,#0                 ;4214
00005e  6420              STR      r0,[r4,#0x40]         ;4214
000060  6261              STR      r1,[r4,#0x24]         ;4217
000062  8562              STRH     r2,[r4,#0x2a]         ;4218
000064  8d60              LDRH     r0,[r4,#0x2a]         ;4219
000066  8520              STRH     r0,[r4,#0x28]         ;4219
000068  62e3              STR      r3,[r4,#0x2c]         ;4220
00006a  bf00              NOP                            ;4223
00006c  2000              MOVS     r0,#0                 ;4223
00006e  9000              STR      r0,[sp,#0]            ;4223
000070  6820              LDR      r0,[r4,#0]            ;4223
000072  6940              LDR      r0,[r0,#0x14]         ;4223
000074  9000              STR      r0,[sp,#0]            ;4223
000076  6820              LDR      r0,[r4,#0]            ;4223
000078  6980              LDR      r0,[r0,#0x18]         ;4223
00007a  9000              STR      r0,[sp,#0]            ;4223
00007c  bf00              NOP                            ;4223
00007e  bf00              NOP                            ;4223
000080  bf00              NOP                            ;4226
000082  2000              MOVS     r0,#0                 ;4226
000084  f884003c          STRB     r0,[r4,#0x3c]         ;4226
000088  bf00              NOP                            ;4226
00008a  6820              LDR      r0,[r4,#0]            ;4233
00008c  6840              LDR      r0,[r0,#4]            ;4233
00008e  f44060e0          ORR      r0,r0,#0x700          ;4233
000092  6825              LDR      r5,[r4,#0]            ;4233
000094  6068              STR      r0,[r5,#4]            ;4233
000096  2000              MOVS     r0,#0                 ;4235
000098  e7bd              B        |L44.22|
                  |L44.154|
00009a  2002              MOVS     r0,#2                 ;4239
00009c  e7bb              B        |L44.22|
;;;4242   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Seq_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Seq_Transmit_DMA PROC
;;;4029     */
;;;4030   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4031   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;4032     HAL_StatusTypeDef dmaxferstatus;
;;;4033   
;;;4034     /* Check the parameters */
;;;4035     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;4036   
;;;4037     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  f0000028          AND      r0,r0,#0x28
000014  2828              CMP      r0,#0x28
000016  d17c              BNE      |L45.274|
;;;4038     {
;;;4039       if ((pData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L45.28|
00001a  b916              CBNZ     r6,|L45.34|
                  |L45.28|
;;;4040       {
;;;4041         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L45.30|
;;;4042       }
;;;4043   
;;;4044       /* Process Locked */
;;;4045       __HAL_LOCK(hi2c);
;;;4046   
;;;4047       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;4048       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4049   
;;;4050       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;4051       /* and then toggle the HAL slave RX state to TX state */
;;;4052       if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;4053       {
;;;4054         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4055         {
;;;4056           /* Abort DMA Xfer if any */
;;;4057           if (hi2c->hdmarx != NULL)
;;;4058           {
;;;4059             CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4060   
;;;4061             /* Set the I2C DMA Abort callback :
;;;4062              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4063             hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
;;;4064   
;;;4065             /* Abort DMA RX */
;;;4066             if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
;;;4067             {
;;;4068               /* Call Directly XferAbortCallback function in case of error */
;;;4069               hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
;;;4070             }
;;;4071           }
;;;4072         }
;;;4073       }
;;;4074       else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;4075       {
;;;4076         if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4077         {
;;;4078           CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;4079   
;;;4080           /* Abort DMA Xfer if any */
;;;4081           if (hi2c->hdmatx != NULL)
;;;4082           {
;;;4083             /* Set the I2C DMA Abort callback :
;;;4084              will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4085             hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
;;;4086   
;;;4087             /* Abort DMA TX */
;;;4088             if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
;;;4089             {
;;;4090               /* Call Directly XferAbortCallback function in case of error */
;;;4091               hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
;;;4092             }
;;;4093           }
;;;4094         }
;;;4095       }
;;;4096       else
;;;4097       {
;;;4098         /* Nothing to do */
;;;4099       }
;;;4100   
;;;4101       /* Check if the I2C is already enabled */
;;;4102       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;4103       {
;;;4104         /* Enable I2C peripheral */
;;;4105         __HAL_I2C_ENABLE(hi2c);
;;;4106       }
;;;4107   
;;;4108       /* Disable Pos */
;;;4109       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;4110   
;;;4111       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;4112       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;4113       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4114   
;;;4115       /* Prepare transfer parameters */
;;;4116       hi2c->pBuffPtr    = pData;
;;;4117       hi2c->XferCount   = Size;
;;;4118       hi2c->XferSize    = hi2c->XferCount;
;;;4119       hi2c->XferOptions = XferOptions;
;;;4120   
;;;4121       /* Set the I2C DMA transfer complete callback */
;;;4122       hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;4123   
;;;4124       /* Set the DMA error callback */
;;;4125       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;4126   
;;;4127       /* Set the unused DMA callbacks to NULL */
;;;4128       hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;4129       hi2c->hdmatx->XferAbortCallback = NULL;
;;;4130   
;;;4131       /* Enable the DMA stream */
;;;4132       dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;4133   
;;;4134       if (dmaxferstatus == HAL_OK)
;;;4135       {
;;;4136         /* Enable Address Acknowledge */
;;;4137         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;4138   
;;;4139         /* Clear ADDR flag */
;;;4140         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4141   
;;;4142         /* Process Unlocked */
;;;4143         __HAL_UNLOCK(hi2c);
;;;4144   
;;;4145         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4146         to avoid the risk of I2C interrupt handle execution before current
;;;4147         process unlock */
;;;4148         /* Enable EVT and ERR interrupt */
;;;4149         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4150   
;;;4151         /* Enable DMA Request */
;;;4152         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;4153   
;;;4154         return HAL_OK;
;;;4155       }
;;;4156       else
;;;4157       {
;;;4158         /* Update I2C state */
;;;4159         hi2c->State     = HAL_I2C_STATE_READY;
;;;4160         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;4161   
;;;4162         /* Update I2C error code */
;;;4163         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;4164   
;;;4165         /* Process Unlocked */
;;;4166         __HAL_UNLOCK(hi2c);
;;;4167   
;;;4168         return HAL_ERROR;
;;;4169       }
;;;4170     }
;;;4171     else
;;;4172     {
;;;4173       return HAL_BUSY;
;;;4174     }
;;;4175   }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L45.34|
000022  bf00              NOP                            ;4045
000024  f894003c          LDRB     r0,[r4,#0x3c]         ;4045
000028  2801              CMP      r0,#1                 ;4045
00002a  d101              BNE      |L45.48|
00002c  2002              MOVS     r0,#2                 ;4045
00002e  e7f6              B        |L45.30|
                  |L45.48|
000030  2001              MOVS     r0,#1                 ;4045
000032  f884003c          STRB     r0,[r4,#0x3c]         ;4045
000036  bf00              NOP                            ;4045
000038  6820              LDR      r0,[r4,#0]            ;4048
00003a  6840              LDR      r0,[r0,#4]            ;4048
00003c  f4207040          BIC      r0,r0,#0x300          ;4048
000040  6821              LDR      r1,[r4,#0]            ;4048
000042  6048              STR      r0,[r1,#4]            ;4048
000044  f894003d          LDRB     r0,[r4,#0x3d]         ;4052
000048  282a              CMP      r0,#0x2a              ;4052
00004a  d119              BNE      |L45.128|
00004c  6820              LDR      r0,[r4,#0]            ;4054
00004e  6840              LDR      r0,[r0,#4]            ;4054
000050  f4006000          AND      r0,r0,#0x800          ;4054
000054  f5b06f00          CMP      r0,#0x800             ;4054
000058  d12f              BNE      |L45.186|
00005a  6ba0              LDR      r0,[r4,#0x38]         ;4057
00005c  b368              CBZ      r0,|L45.186|
00005e  6820              LDR      r0,[r4,#0]            ;4059
000060  6840              LDR      r0,[r0,#4]            ;4059
000062  f4206000          BIC      r0,r0,#0x800          ;4059
000066  6821              LDR      r1,[r4,#0]            ;4059
000068  6048              STR      r0,[r1,#4]            ;4059
00006a  484b              LDR      r0,|L45.408|
00006c  6ba1              LDR      r1,[r4,#0x38]         ;4063
00006e  6508              STR      r0,[r1,#0x50]         ;4063
000070  6ba0              LDR      r0,[r4,#0x38]         ;4066
000072  f7fffffe          BL       HAL_DMA_Abort_IT
000076  b300              CBZ      r0,|L45.186|
000078  6ba0              LDR      r0,[r4,#0x38]         ;4069
00007a  6d01              LDR      r1,[r0,#0x50]         ;4069
00007c  4788              BLX      r1                    ;4069
00007e  e01c              B        |L45.186|
                  |L45.128|
000080  f894003d          LDRB     r0,[r4,#0x3d]         ;4074
000084  2829              CMP      r0,#0x29              ;4074
000086  d118              BNE      |L45.186|
000088  6820              LDR      r0,[r4,#0]            ;4076
00008a  6840              LDR      r0,[r0,#4]            ;4076
00008c  f4006000          AND      r0,r0,#0x800          ;4076
000090  f5b06f00          CMP      r0,#0x800             ;4076
000094  d111              BNE      |L45.186|
000096  6820              LDR      r0,[r4,#0]            ;4078
000098  6840              LDR      r0,[r0,#4]            ;4078
00009a  f4206000          BIC      r0,r0,#0x800          ;4078
00009e  6821              LDR      r1,[r4,#0]            ;4078
0000a0  6048              STR      r0,[r1,#4]            ;4078
0000a2  6b60              LDR      r0,[r4,#0x34]         ;4081
0000a4  b148              CBZ      r0,|L45.186|
0000a6  483c              LDR      r0,|L45.408|
0000a8  6b61              LDR      r1,[r4,#0x34]         ;4085
0000aa  6508              STR      r0,[r1,#0x50]         ;4085
0000ac  6b60              LDR      r0,[r4,#0x34]         ;4088
0000ae  f7fffffe          BL       HAL_DMA_Abort_IT
0000b2  b110              CBZ      r0,|L45.186|
0000b4  6b60              LDR      r0,[r4,#0x34]         ;4091
0000b6  6d01              LDR      r1,[r0,#0x50]         ;4091
0000b8  4788              BLX      r1                    ;4091
                  |L45.186|
0000ba  6820              LDR      r0,[r4,#0]            ;4102
0000bc  6800              LDR      r0,[r0,#0]            ;4102
0000be  f0000001          AND      r0,r0,#1              ;4102
0000c2  b928              CBNZ     r0,|L45.208|
0000c4  6820              LDR      r0,[r4,#0]            ;4105
0000c6  6800              LDR      r0,[r0,#0]            ;4105
0000c8  f0400001          ORR      r0,r0,#1              ;4105
0000cc  6821              LDR      r1,[r4,#0]            ;4105
0000ce  6008              STR      r0,[r1,#0]            ;4105
                  |L45.208|
0000d0  6820              LDR      r0,[r4,#0]            ;4109
0000d2  6800              LDR      r0,[r0,#0]            ;4109
0000d4  f4206000          BIC      r0,r0,#0x800          ;4109
0000d8  6821              LDR      r1,[r4,#0]            ;4109
0000da  6008              STR      r0,[r1,#0]            ;4109
0000dc  2029              MOVS     r0,#0x29              ;4111
0000de  f884003d          STRB     r0,[r4,#0x3d]         ;4111
0000e2  2020              MOVS     r0,#0x20              ;4112
0000e4  f884003e          STRB     r0,[r4,#0x3e]         ;4112
0000e8  2000              MOVS     r0,#0                 ;4113
0000ea  6420              STR      r0,[r4,#0x40]         ;4113
0000ec  6265              STR      r5,[r4,#0x24]         ;4116
0000ee  8566              STRH     r6,[r4,#0x2a]         ;4117
0000f0  8d60              LDRH     r0,[r4,#0x2a]         ;4118
0000f2  8520              STRH     r0,[r4,#0x28]         ;4118
0000f4  f8c4802c          STR      r8,[r4,#0x2c]         ;4119
0000f8  4828              LDR      r0,|L45.412|
0000fa  6b61              LDR      r1,[r4,#0x34]         ;4122
0000fc  63c8              STR      r0,[r1,#0x3c]         ;4122
0000fe  4828              LDR      r0,|L45.416|
000100  6b61              LDR      r1,[r4,#0x34]         ;4125
000102  64c8              STR      r0,[r1,#0x4c]         ;4125
000104  2000              MOVS     r0,#0                 ;4128
000106  6b61              LDR      r1,[r4,#0x34]         ;4128
000108  6408              STR      r0,[r1,#0x40]         ;4128
00010a  6b61              LDR      r1,[r4,#0x34]         ;4129
00010c  6508              STR      r0,[r1,#0x50]         ;4129
00010e  8d23              LDRH     r3,[r4,#0x28]         ;4132
000110  e000              B        |L45.276|
                  |L45.274|
000112  e03e              B        |L45.402|
                  |L45.276|
000114  f8d4c000          LDR      r12,[r4,#0]           ;4132
000118  f10c0210          ADD      r2,r12,#0x10          ;4132
00011c  6a61              LDR      r1,[r4,#0x24]         ;4132
00011e  6b60              LDR      r0,[r4,#0x34]         ;4132
000120  f7fffffe          BL       HAL_DMA_Start_IT
000124  4607              MOV      r7,r0                 ;4132
000126  bb1f              CBNZ     r7,|L45.368|
000128  6820              LDR      r0,[r4,#0]            ;4137
00012a  6800              LDR      r0,[r0,#0]            ;4137
00012c  f4406080          ORR      r0,r0,#0x400          ;4137
000130  6821              LDR      r1,[r4,#0]            ;4137
000132  6008              STR      r0,[r1,#0]            ;4137
000134  bf00              NOP                            ;4140
000136  2000              MOVS     r0,#0                 ;4140
000138  9000              STR      r0,[sp,#0]            ;4140
00013a  6820              LDR      r0,[r4,#0]            ;4140
00013c  6940              LDR      r0,[r0,#0x14]         ;4140
00013e  9000              STR      r0,[sp,#0]            ;4140
000140  6820              LDR      r0,[r4,#0]            ;4140
000142  6980              LDR      r0,[r0,#0x18]         ;4140
000144  9000              STR      r0,[sp,#0]            ;4140
000146  bf00              NOP                            ;4140
000148  bf00              NOP                            ;4140
00014a  bf00              NOP                            ;4143
00014c  2000              MOVS     r0,#0                 ;4143
00014e  f884003c          STRB     r0,[r4,#0x3c]         ;4143
000152  bf00              NOP                            ;4143
000154  6820              LDR      r0,[r4,#0]            ;4149
000156  6840              LDR      r0,[r0,#4]            ;4149
000158  f4407040          ORR      r0,r0,#0x300          ;4149
00015c  6821              LDR      r1,[r4,#0]            ;4149
00015e  6048              STR      r0,[r1,#4]            ;4149
000160  6820              LDR      r0,[r4,#0]            ;4152
000162  6840              LDR      r0,[r0,#4]            ;4152
000164  f4406000          ORR      r0,r0,#0x800          ;4152
000168  6821              LDR      r1,[r4,#0]            ;4152
00016a  6048              STR      r0,[r1,#4]            ;4152
00016c  2000              MOVS     r0,#0                 ;4154
00016e  e756              B        |L45.30|
                  |L45.368|
000170  2020              MOVS     r0,#0x20              ;4159
000172  f884003d          STRB     r0,[r4,#0x3d]         ;4159
000176  2000              MOVS     r0,#0                 ;4160
000178  f884003e          STRB     r0,[r4,#0x3e]         ;4160
00017c  6c20              LDR      r0,[r4,#0x40]         ;4163
00017e  f0400010          ORR      r0,r0,#0x10           ;4163
000182  6420              STR      r0,[r4,#0x40]         ;4163
000184  bf00              NOP                            ;4166
000186  2000              MOVS     r0,#0                 ;4166
000188  f884003c          STRB     r0,[r4,#0x3c]         ;4166
00018c  bf00              NOP                            ;4166
00018e  2001              MOVS     r0,#1                 ;4168
000190  e745              B        |L45.30|
                  |L45.402|
000192  2002              MOVS     r0,#2                 ;4173
000194  e743              B        |L45.30|
;;;4176   
                          ENDP

000196  0000              DCW      0x0000
                  |L45.408|
                          DCD      I2C_DMAAbort
                  |L45.412|
                          DCD      I2C_DMAXferCplt
                  |L45.416|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Seq_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Seq_Transmit_IT PROC
;;;3963     */
;;;3964   HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b538              PUSH     {r3-r5,lr}
;;;3965   {
000002  4604              MOV      r4,r0
;;;3966     /* Check the parameters */
;;;3967     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;3968   
;;;3969     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  f0000028          AND      r0,r0,#0x28
00000c  2828              CMP      r0,#0x28
00000e  d144              BNE      |L46.154|
;;;3970     {
;;;3971       if ((pData == NULL) || (Size == 0U))
000010  b101              CBZ      r1,|L46.20|
000012  b90a              CBNZ     r2,|L46.24|
                  |L46.20|
;;;3972       {
;;;3973         return  HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L46.22|
;;;3974       }
;;;3975   
;;;3976       /* Process Locked */
;;;3977       __HAL_LOCK(hi2c);
;;;3978   
;;;3979       /* Check if the I2C is already enabled */
;;;3980       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3981       {
;;;3982         /* Enable I2C peripheral */
;;;3983         __HAL_I2C_ENABLE(hi2c);
;;;3984       }
;;;3985   
;;;3986       /* Disable Pos */
;;;3987       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;3988   
;;;3989       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;3990       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;3991       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3992   
;;;3993       /* Prepare transfer parameters */
;;;3994       hi2c->pBuffPtr    = pData;
;;;3995       hi2c->XferCount   = Size;
;;;3996       hi2c->XferSize    = hi2c->XferCount;
;;;3997       hi2c->XferOptions = XferOptions;
;;;3998   
;;;3999       /* Clear ADDR flag */
;;;4000       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4001   
;;;4002       /* Process Unlocked */
;;;4003       __HAL_UNLOCK(hi2c);
;;;4004   
;;;4005       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;4006                 to avoid the risk of I2C interrupt handle execution before current
;;;4007                 process unlock */
;;;4008   
;;;4009       /* Enable EVT, BUF and ERR interrupt */
;;;4010       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4011   
;;;4012       return HAL_OK;
;;;4013     }
;;;4014     else
;;;4015     {
;;;4016       return HAL_BUSY;
;;;4017     }
;;;4018   }
000016  bd38              POP      {r3-r5,pc}
                  |L46.24|
000018  bf00              NOP                            ;3977
00001a  f894003c          LDRB     r0,[r4,#0x3c]         ;3977
00001e  2801              CMP      r0,#1                 ;3977
000020  d101              BNE      |L46.38|
000022  2002              MOVS     r0,#2                 ;3977
000024  e7f7              B        |L46.22|
                  |L46.38|
000026  2001              MOVS     r0,#1                 ;3977
000028  f884003c          STRB     r0,[r4,#0x3c]         ;3977
00002c  bf00              NOP                            ;3977
00002e  6820              LDR      r0,[r4,#0]            ;3980
000030  6800              LDR      r0,[r0,#0]            ;3980
000032  f0000001          AND      r0,r0,#1              ;3980
000036  b928              CBNZ     r0,|L46.68|
000038  6820              LDR      r0,[r4,#0]            ;3983
00003a  6800              LDR      r0,[r0,#0]            ;3983
00003c  f0400001          ORR      r0,r0,#1              ;3983
000040  6825              LDR      r5,[r4,#0]            ;3983
000042  6028              STR      r0,[r5,#0]            ;3983
                  |L46.68|
000044  6820              LDR      r0,[r4,#0]            ;3987
000046  6800              LDR      r0,[r0,#0]            ;3987
000048  f4206000          BIC      r0,r0,#0x800          ;3987
00004c  6825              LDR      r5,[r4,#0]            ;3987
00004e  6028              STR      r0,[r5,#0]            ;3987
000050  2029              MOVS     r0,#0x29              ;3989
000052  f884003d          STRB     r0,[r4,#0x3d]         ;3989
000056  2020              MOVS     r0,#0x20              ;3990
000058  f884003e          STRB     r0,[r4,#0x3e]         ;3990
00005c  2000              MOVS     r0,#0                 ;3991
00005e  6420              STR      r0,[r4,#0x40]         ;3991
000060  6261              STR      r1,[r4,#0x24]         ;3994
000062  8562              STRH     r2,[r4,#0x2a]         ;3995
000064  8d60              LDRH     r0,[r4,#0x2a]         ;3996
000066  8520              STRH     r0,[r4,#0x28]         ;3996
000068  62e3              STR      r3,[r4,#0x2c]         ;3997
00006a  bf00              NOP                            ;4000
00006c  2000              MOVS     r0,#0                 ;4000
00006e  9000              STR      r0,[sp,#0]            ;4000
000070  6820              LDR      r0,[r4,#0]            ;4000
000072  6940              LDR      r0,[r0,#0x14]         ;4000
000074  9000              STR      r0,[sp,#0]            ;4000
000076  6820              LDR      r0,[r4,#0]            ;4000
000078  6980              LDR      r0,[r0,#0x18]         ;4000
00007a  9000              STR      r0,[sp,#0]            ;4000
00007c  bf00              NOP                            ;4000
00007e  bf00              NOP                            ;4000
000080  bf00              NOP                            ;4003
000082  2000              MOVS     r0,#0                 ;4003
000084  f884003c          STRB     r0,[r4,#0x3c]         ;4003
000088  bf00              NOP                            ;4003
00008a  6820              LDR      r0,[r4,#0]            ;4010
00008c  6840              LDR      r0,[r0,#4]            ;4010
00008e  f44060e0          ORR      r0,r0,#0x700          ;4010
000092  6825              LDR      r5,[r4,#0]            ;4010
000094  6068              STR      r0,[r5,#4]            ;4010
000096  2000              MOVS     r0,#0                 ;4012
000098  e7bd              B        |L46.22|
                  |L46.154|
00009a  2002              MOVS     r0,#2                 ;4016
00009c  e7bb              B        |L46.22|
;;;4019   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit PROC
;;;1388     */
;;;1389   HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1390   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1391     /* Init tickstart for timeout management*/
;;;1392     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;1393   
;;;1394     if (hi2c->State == HAL_I2C_STATE_READY)
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2820              CMP      r0,#0x20
000018  d171              BNE      |L47.254|
;;;1395     {
;;;1396       if ((pData == NULL) || (Size == 0U))
00001a  b106              CBZ      r6,|L47.30|
00001c  b917              CBNZ     r7,|L47.36|
                  |L47.30|
;;;1397       {
;;;1398         return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L47.32|
;;;1399       }
;;;1400   
;;;1401       /* Process Locked */
;;;1402       __HAL_LOCK(hi2c);
;;;1403   
;;;1404       /* Check if the I2C is already enabled */
;;;1405       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1406       {
;;;1407         /* Enable I2C peripheral */
;;;1408         __HAL_I2C_ENABLE(hi2c);
;;;1409       }
;;;1410   
;;;1411       /* Disable Pos */
;;;1412       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1413   
;;;1414       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1415       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1416       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1417   
;;;1418       /* Prepare transfer parameters */
;;;1419       hi2c->pBuffPtr    = pData;
;;;1420       hi2c->XferCount   = Size;
;;;1421       hi2c->XferSize    = hi2c->XferCount;
;;;1422       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1423   
;;;1424       /* Enable Address Acknowledge */
;;;1425       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1426   
;;;1427       /* Wait until ADDR flag is set */
;;;1428       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1429       {
;;;1430         return HAL_ERROR;
;;;1431       }
;;;1432   
;;;1433       /* Clear ADDR flag */
;;;1434       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1435   
;;;1436       /* If 10bit addressing mode is selected */
;;;1437       if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;1438       {
;;;1439         /* Wait until ADDR flag is set */
;;;1440         if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1441         {
;;;1442           return HAL_ERROR;
;;;1443         }
;;;1444   
;;;1445         /* Clear ADDR flag */
;;;1446         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1447       }
;;;1448   
;;;1449       while (hi2c->XferSize > 0U)
;;;1450       {
;;;1451         /* Wait until TXE flag is set */
;;;1452         if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1453         {
;;;1454           /* Disable Address Acknowledge */
;;;1455           CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1456   
;;;1457           return HAL_ERROR;
;;;1458         }
;;;1459   
;;;1460         /* Write data to DR */
;;;1461         hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1462   
;;;1463         /* Increment Buffer pointer */
;;;1464         hi2c->pBuffPtr++;
;;;1465   
;;;1466         /* Update counter */
;;;1467         hi2c->XferCount--;
;;;1468         hi2c->XferSize--;
;;;1469   
;;;1470         if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1471         {
;;;1472           /* Write data to DR */
;;;1473           hi2c->Instance->DR = *hi2c->pBuffPtr;
;;;1474   
;;;1475           /* Increment Buffer pointer */
;;;1476           hi2c->pBuffPtr++;
;;;1477   
;;;1478           /* Update counter */
;;;1479           hi2c->XferCount--;
;;;1480           hi2c->XferSize--;
;;;1481         }
;;;1482       }
;;;1483   
;;;1484       /* Wait until AF flag is set */
;;;1485       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
;;;1486       {
;;;1487         return HAL_ERROR;
;;;1488       }
;;;1489   
;;;1490       /* Clear AF flag */
;;;1491       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;1492   
;;;1493       /* Disable Address Acknowledge */
;;;1494       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1495   
;;;1496       hi2c->State = HAL_I2C_STATE_READY;
;;;1497       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1498   
;;;1499       /* Process Unlocked */
;;;1500       __HAL_UNLOCK(hi2c);
;;;1501   
;;;1502       return HAL_OK;
;;;1503     }
;;;1504     else
;;;1505     {
;;;1506       return HAL_BUSY;
;;;1507     }
;;;1508   }
000020  e8bd83f8          POP      {r3-r9,pc}
                  |L47.36|
000024  bf00              NOP                            ;1402
000026  f894003c          LDRB     r0,[r4,#0x3c]         ;1402
00002a  2801              CMP      r0,#1                 ;1402
00002c  d101              BNE      |L47.50|
00002e  2002              MOVS     r0,#2                 ;1402
000030  e7f6              B        |L47.32|
                  |L47.50|
000032  2001              MOVS     r0,#1                 ;1402
000034  f884003c          STRB     r0,[r4,#0x3c]         ;1402
000038  bf00              NOP                            ;1402
00003a  6820              LDR      r0,[r4,#0]            ;1405
00003c  6800              LDR      r0,[r0,#0]            ;1405
00003e  f0000001          AND      r0,r0,#1              ;1405
000042  b928              CBNZ     r0,|L47.80|
000044  6820              LDR      r0,[r4,#0]            ;1408
000046  6800              LDR      r0,[r0,#0]            ;1408
000048  f0400001          ORR      r0,r0,#1              ;1408
00004c  6821              LDR      r1,[r4,#0]            ;1408
00004e  6008              STR      r0,[r1,#0]            ;1408
                  |L47.80|
000050  6820              LDR      r0,[r4,#0]            ;1412
000052  6800              LDR      r0,[r0,#0]            ;1412
000054  f4206000          BIC      r0,r0,#0x800          ;1412
000058  6821              LDR      r1,[r4,#0]            ;1412
00005a  6008              STR      r0,[r1,#0]            ;1412
00005c  2021              MOVS     r0,#0x21              ;1414
00005e  f884003d          STRB     r0,[r4,#0x3d]         ;1414
000062  2020              MOVS     r0,#0x20              ;1415
000064  f884003e          STRB     r0,[r4,#0x3e]         ;1415
000068  2000              MOVS     r0,#0                 ;1416
00006a  6420              STR      r0,[r4,#0x40]         ;1416
00006c  6266              STR      r6,[r4,#0x24]         ;1419
00006e  8567              STRH     r7,[r4,#0x2a]         ;1420
000070  8d60              LDRH     r0,[r4,#0x2a]         ;1421
000072  8520              STRH     r0,[r4,#0x28]         ;1421
000074  4845              LDR      r0,|L47.396|
000076  62e0              STR      r0,[r4,#0x2c]         ;1422
000078  6820              LDR      r0,[r4,#0]            ;1425
00007a  6800              LDR      r0,[r0,#0]            ;1425
00007c  f4406080          ORR      r0,r0,#0x400          ;1425
000080  6821              LDR      r1,[r4,#0]            ;1425
000082  6008              STR      r0,[r1,#0]            ;1425
000084  4643              MOV      r3,r8                 ;1428
000086  2200              MOVS     r2,#0                 ;1428
000088  4941              LDR      r1,|L47.400|
00008a  4620              MOV      r0,r4                 ;1428
00008c  9500              STR      r5,[sp,#0]            ;1428
00008e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000092  b108              CBZ      r0,|L47.152|
000094  2001              MOVS     r0,#1                 ;1430
000096  e7c3              B        |L47.32|
                  |L47.152|
000098  bf00              NOP                            ;1434
00009a  2000              MOVS     r0,#0                 ;1434
00009c  9000              STR      r0,[sp,#0]            ;1434
00009e  6820              LDR      r0,[r4,#0]            ;1434
0000a0  6940              LDR      r0,[r0,#0x14]         ;1434
0000a2  9000              STR      r0,[sp,#0]            ;1434
0000a4  6820              LDR      r0,[r4,#0]            ;1434
0000a6  6980              LDR      r0,[r0,#0x18]         ;1434
0000a8  9000              STR      r0,[sp,#0]            ;1434
0000aa  bf00              NOP                            ;1434
0000ac  bf00              NOP                            ;1434
0000ae  6920              LDR      r0,[r4,#0x10]         ;1437
0000b0  f5b04f40          CMP      r0,#0xc000            ;1437
0000b4  d114              BNE      |L47.224|
0000b6  4643              MOV      r3,r8                 ;1440
0000b8  2200              MOVS     r2,#0                 ;1440
0000ba  4935              LDR      r1,|L47.400|
0000bc  4620              MOV      r0,r4                 ;1440
0000be  9500              STR      r5,[sp,#0]            ;1440
0000c0  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000c4  b108              CBZ      r0,|L47.202|
0000c6  2001              MOVS     r0,#1                 ;1442
0000c8  e7aa              B        |L47.32|
                  |L47.202|
0000ca  bf00              NOP                            ;1446
0000cc  2000              MOVS     r0,#0                 ;1446
0000ce  9000              STR      r0,[sp,#0]            ;1446
0000d0  6820              LDR      r0,[r4,#0]            ;1446
0000d2  6940              LDR      r0,[r0,#0x14]         ;1446
0000d4  9000              STR      r0,[sp,#0]            ;1446
0000d6  6820              LDR      r0,[r4,#0]            ;1446
0000d8  6980              LDR      r0,[r0,#0x18]         ;1446
0000da  9000              STR      r0,[sp,#0]            ;1446
0000dc  bf00              NOP                            ;1446
0000de  bf00              NOP                            ;1446
                  |L47.224|
0000e0  e02f              B        |L47.322|
                  |L47.226|
0000e2  462a              MOV      r2,r5                 ;1452
0000e4  4641              MOV      r1,r8                 ;1452
0000e6  4620              MOV      r0,r4                 ;1452
0000e8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000ec  b140              CBZ      r0,|L47.256|
0000ee  6820              LDR      r0,[r4,#0]            ;1455
0000f0  6800              LDR      r0,[r0,#0]            ;1455
0000f2  f4206080          BIC      r0,r0,#0x400          ;1455
0000f6  6821              LDR      r1,[r4,#0]            ;1455
0000f8  6008              STR      r0,[r1,#0]            ;1455
0000fa  2001              MOVS     r0,#1                 ;1457
0000fc  e790              B        |L47.32|
                  |L47.254|
0000fe  e043              B        |L47.392|
                  |L47.256|
000100  6a60              LDR      r0,[r4,#0x24]         ;1461
000102  7800              LDRB     r0,[r0,#0]            ;1461
000104  6821              LDR      r1,[r4,#0]            ;1461
000106  6108              STR      r0,[r1,#0x10]         ;1461
000108  6a60              LDR      r0,[r4,#0x24]         ;1464
00010a  1c40              ADDS     r0,r0,#1              ;1464
00010c  6260              STR      r0,[r4,#0x24]         ;1464
00010e  8d60              LDRH     r0,[r4,#0x2a]         ;1467
000110  1e40              SUBS     r0,r0,#1              ;1467
000112  8560              STRH     r0,[r4,#0x2a]         ;1467
000114  8d20              LDRH     r0,[r4,#0x28]         ;1468
000116  1e40              SUBS     r0,r0,#1              ;1468
000118  8520              STRH     r0,[r4,#0x28]         ;1468
00011a  6820              LDR      r0,[r4,#0]            ;1470
00011c  6940              LDR      r0,[r0,#0x14]         ;1470
00011e  f3c00080          UBFX     r0,r0,#2,#1           ;1470
000122  b170              CBZ      r0,|L47.322|
000124  8d20              LDRH     r0,[r4,#0x28]         ;1470
000126  b160              CBZ      r0,|L47.322|
000128  6a60              LDR      r0,[r4,#0x24]         ;1473
00012a  7800              LDRB     r0,[r0,#0]            ;1473
00012c  6821              LDR      r1,[r4,#0]            ;1473
00012e  6108              STR      r0,[r1,#0x10]         ;1473
000130  6a60              LDR      r0,[r4,#0x24]         ;1476
000132  1c40              ADDS     r0,r0,#1              ;1476
000134  6260              STR      r0,[r4,#0x24]         ;1476
000136  8d60              LDRH     r0,[r4,#0x2a]         ;1479
000138  1e40              SUBS     r0,r0,#1              ;1479
00013a  8560              STRH     r0,[r4,#0x2a]         ;1479
00013c  8d20              LDRH     r0,[r4,#0x28]         ;1480
00013e  1e40              SUBS     r0,r0,#1              ;1480
000140  8520              STRH     r0,[r4,#0x28]         ;1480
                  |L47.322|
000142  8d20              LDRH     r0,[r4,#0x28]         ;1449
000144  2800              CMP      r0,#0                 ;1449
000146  d1cc              BNE      |L47.226|
000148  4643              MOV      r3,r8                 ;1485
00014a  2200              MOVS     r2,#0                 ;1485
00014c  f44f3182          MOV      r1,#0x10400           ;1485
000150  4620              MOV      r0,r4                 ;1485
000152  9500              STR      r5,[sp,#0]            ;1485
000154  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000158  b108              CBZ      r0,|L47.350|
00015a  2001              MOVS     r0,#1                 ;1487
00015c  e760              B        |L47.32|
                  |L47.350|
00015e  f46f6080          MVN      r0,#0x400             ;1491
000162  6821              LDR      r1,[r4,#0]            ;1491
000164  6148              STR      r0,[r1,#0x14]         ;1491
000166  6820              LDR      r0,[r4,#0]            ;1494
000168  6800              LDR      r0,[r0,#0]            ;1494
00016a  f4206080          BIC      r0,r0,#0x400          ;1494
00016e  6821              LDR      r1,[r4,#0]            ;1494
000170  6008              STR      r0,[r1,#0]            ;1494
000172  2020              MOVS     r0,#0x20              ;1496
000174  f884003d          STRB     r0,[r4,#0x3d]         ;1496
000178  2000              MOVS     r0,#0                 ;1497
00017a  f884003e          STRB     r0,[r4,#0x3e]         ;1497
00017e  bf00              NOP                            ;1500
000180  f884003c          STRB     r0,[r4,#0x3c]         ;1500
000184  bf00              NOP                            ;1500
000186  e74b              B        |L47.32|
                  |L47.392|
000188  2002              MOVS     r0,#2                 ;1506
00018a  e749              B        |L47.32|
;;;1509   
                          ENDP

                  |L47.396|
                          DCD      0xffff0000
                  |L47.400|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_DMA PROC
;;;2207     */
;;;2208   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2209   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2210     HAL_StatusTypeDef dmaxferstatus;
;;;2211   
;;;2212     if (hi2c->State == HAL_I2C_STATE_READY)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2820              CMP      r0,#0x20
000010  d173              BNE      |L48.250|
;;;2213     {
;;;2214       if ((pData == NULL) || (Size == 0U))
000012  b105              CBZ      r5,|L48.22|
000014  b916              CBNZ     r6,|L48.28|
                  |L48.22|
;;;2215       {
;;;2216         return  HAL_ERROR;
000016  2001              MOVS     r0,#1
                  |L48.24|
;;;2217       }
;;;2218   
;;;2219       /* Process Locked */
;;;2220       __HAL_LOCK(hi2c);
;;;2221   
;;;2222       /* Check if the I2C is already enabled */
;;;2223       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2224       {
;;;2225         /* Enable I2C peripheral */
;;;2226         __HAL_I2C_ENABLE(hi2c);
;;;2227       }
;;;2228   
;;;2229       /* Disable Pos */
;;;2230       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2231   
;;;2232       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2233       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2234       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2235   
;;;2236       /* Prepare transfer parameters */
;;;2237       hi2c->pBuffPtr    = pData;
;;;2238       hi2c->XferCount   = Size;
;;;2239       hi2c->XferSize    = hi2c->XferCount;
;;;2240       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2241   
;;;2242       /* Set the I2C DMA transfer complete callback */
;;;2243       hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;2244   
;;;2245       /* Set the DMA error callback */
;;;2246       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2247   
;;;2248       /* Set the unused DMA callbacks to NULL */
;;;2249       hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2250       hi2c->hdmatx->XferM1CpltCallback = NULL;
;;;2251       hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
;;;2252       hi2c->hdmatx->XferAbortCallback = NULL;
;;;2253   
;;;2254       /* Enable the DMA stream */
;;;2255       dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;2256   
;;;2257       if (dmaxferstatus == HAL_OK)
;;;2258       {
;;;2259         /* Enable Address Acknowledge */
;;;2260         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2261   
;;;2262         /* Process Unlocked */
;;;2263         __HAL_UNLOCK(hi2c);
;;;2264   
;;;2265         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2266         to avoid the risk of I2C interrupt handle execution before current
;;;2267         process unlock */
;;;2268         /* Enable EVT and ERR interrupt */
;;;2269         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2270   
;;;2271         /* Enable DMA Request */
;;;2272         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;2273   
;;;2274         return HAL_OK;
;;;2275       }
;;;2276       else
;;;2277       {
;;;2278         /* Update I2C state */
;;;2279         hi2c->State     = HAL_I2C_STATE_READY;
;;;2280         hi2c->Mode      = HAL_I2C_MODE_NONE;
;;;2281   
;;;2282         /* Update I2C error code */
;;;2283         hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
;;;2284   
;;;2285         /* Process Unlocked */
;;;2286         __HAL_UNLOCK(hi2c);
;;;2287   
;;;2288         return HAL_ERROR;
;;;2289       }
;;;2290     }
;;;2291     else
;;;2292     {
;;;2293       return HAL_BUSY;
;;;2294     }
;;;2295   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L48.28|
00001c  bf00              NOP                            ;2220
00001e  f894003c          LDRB     r0,[r4,#0x3c]         ;2220
000022  2801              CMP      r0,#1                 ;2220
000024  d101              BNE      |L48.42|
000026  2002              MOVS     r0,#2                 ;2220
000028  e7f6              B        |L48.24|
                  |L48.42|
00002a  2001              MOVS     r0,#1                 ;2220
00002c  f884003c          STRB     r0,[r4,#0x3c]         ;2220
000030  bf00              NOP                            ;2220
000032  6820              LDR      r0,[r4,#0]            ;2223
000034  6800              LDR      r0,[r0,#0]            ;2223
000036  f0000001          AND      r0,r0,#1              ;2223
00003a  b928              CBNZ     r0,|L48.72|
00003c  6820              LDR      r0,[r4,#0]            ;2226
00003e  6800              LDR      r0,[r0,#0]            ;2226
000040  f0400001          ORR      r0,r0,#1              ;2226
000044  6821              LDR      r1,[r4,#0]            ;2226
000046  6008              STR      r0,[r1,#0]            ;2226
                  |L48.72|
000048  6820              LDR      r0,[r4,#0]            ;2230
00004a  6800              LDR      r0,[r0,#0]            ;2230
00004c  f4206000          BIC      r0,r0,#0x800          ;2230
000050  6821              LDR      r1,[r4,#0]            ;2230
000052  6008              STR      r0,[r1,#0]            ;2230
000054  2021              MOVS     r0,#0x21              ;2232
000056  f884003d          STRB     r0,[r4,#0x3d]         ;2232
00005a  2020              MOVS     r0,#0x20              ;2233
00005c  f884003e          STRB     r0,[r4,#0x3e]         ;2233
000060  2000              MOVS     r0,#0                 ;2234
000062  6420              STR      r0,[r4,#0x40]         ;2234
000064  6265              STR      r5,[r4,#0x24]         ;2237
000066  8566              STRH     r6,[r4,#0x2a]         ;2238
000068  8d60              LDRH     r0,[r4,#0x2a]         ;2239
00006a  8520              STRH     r0,[r4,#0x28]         ;2239
00006c  4824              LDR      r0,|L48.256|
00006e  62e0              STR      r0,[r4,#0x2c]         ;2240
000070  4824              LDR      r0,|L48.260|
000072  6b61              LDR      r1,[r4,#0x34]         ;2243
000074  63c8              STR      r0,[r1,#0x3c]         ;2243
000076  4824              LDR      r0,|L48.264|
000078  6b61              LDR      r1,[r4,#0x34]         ;2246
00007a  64c8              STR      r0,[r1,#0x4c]         ;2246
00007c  2000              MOVS     r0,#0                 ;2249
00007e  6b61              LDR      r1,[r4,#0x34]         ;2249
000080  6408              STR      r0,[r1,#0x40]         ;2249
000082  6b61              LDR      r1,[r4,#0x34]         ;2250
000084  6448              STR      r0,[r1,#0x44]         ;2250
000086  6b61              LDR      r1,[r4,#0x34]         ;2251
000088  6488              STR      r0,[r1,#0x48]         ;2251
00008a  6b61              LDR      r1,[r4,#0x34]         ;2252
00008c  6508              STR      r0,[r1,#0x50]         ;2252
00008e  8d23              LDRH     r3,[r4,#0x28]         ;2255
000090  f8d4c000          LDR      r12,[r4,#0]           ;2255
000094  f10c0210          ADD      r2,r12,#0x10          ;2255
000098  6a61              LDR      r1,[r4,#0x24]         ;2255
00009a  6b60              LDR      r0,[r4,#0x34]         ;2255
00009c  f7fffffe          BL       HAL_DMA_Start_IT
0000a0  4607              MOV      r7,r0                 ;2255
0000a2  b9c7              CBNZ     r7,|L48.214|
0000a4  6820              LDR      r0,[r4,#0]            ;2260
0000a6  6800              LDR      r0,[r0,#0]            ;2260
0000a8  f4406080          ORR      r0,r0,#0x400          ;2260
0000ac  6821              LDR      r1,[r4,#0]            ;2260
0000ae  6008              STR      r0,[r1,#0]            ;2260
0000b0  bf00              NOP                            ;2263
0000b2  2000              MOVS     r0,#0                 ;2263
0000b4  f884003c          STRB     r0,[r4,#0x3c]         ;2263
0000b8  bf00              NOP                            ;2263
0000ba  6820              LDR      r0,[r4,#0]            ;2269
0000bc  6840              LDR      r0,[r0,#4]            ;2269
0000be  f4407040          ORR      r0,r0,#0x300          ;2269
0000c2  6821              LDR      r1,[r4,#0]            ;2269
0000c4  6048              STR      r0,[r1,#4]            ;2269
0000c6  6820              LDR      r0,[r4,#0]            ;2272
0000c8  6840              LDR      r0,[r0,#4]            ;2272
0000ca  f4406000          ORR      r0,r0,#0x800          ;2272
0000ce  6821              LDR      r1,[r4,#0]            ;2272
0000d0  6048              STR      r0,[r1,#4]            ;2272
0000d2  2000              MOVS     r0,#0                 ;2274
0000d4  e7a0              B        |L48.24|
                  |L48.214|
0000d6  2020              MOVS     r0,#0x20              ;2279
0000d8  f884003d          STRB     r0,[r4,#0x3d]         ;2279
0000dc  2000              MOVS     r0,#0                 ;2280
0000de  f884003e          STRB     r0,[r4,#0x3e]         ;2280
0000e2  6c20              LDR      r0,[r4,#0x40]         ;2283
0000e4  f0400010          ORR      r0,r0,#0x10           ;2283
0000e8  6420              STR      r0,[r4,#0x40]         ;2283
0000ea  bf00              NOP                            ;2286
0000ec  2000              MOVS     r0,#0                 ;2286
0000ee  f884003c          STRB     r0,[r4,#0x3c]         ;2286
0000f2  bf00              NOP                            ;2286
0000f4  2001              MOVS     r0,#1                 ;2288
0000f6  e78f              B        |L48.24|
0000f8  e7ff              B        |L48.250|
                  |L48.250|
0000fa  2002              MOVS     r0,#2                 ;2293
0000fc  e78c              B        |L48.24|
;;;2296   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L48.256|
                          DCD      0xffff0000
                  |L48.260|
                          DCD      I2C_DMAXferCplt
                  |L48.264|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_IT PROC
;;;1801     */
;;;1802   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1803   {
000002  4603              MOV      r3,r0
;;;1804   
;;;1805     if (hi2c->State == HAL_I2C_STATE_READY)
000004  f893003d          LDRB     r0,[r3,#0x3d]
000008  2820              CMP      r0,#0x20
00000a  d140              BNE      |L49.142|
;;;1806     {
;;;1807       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L49.16|
00000e  b90a              CBNZ     r2,|L49.20|
                  |L49.16|
;;;1808       {
;;;1809         return  HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L49.18|
;;;1810       }
;;;1811   
;;;1812       /* Process Locked */
;;;1813       __HAL_LOCK(hi2c);
;;;1814   
;;;1815       /* Check if the I2C is already enabled */
;;;1816       if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1817       {
;;;1818         /* Enable I2C peripheral */
;;;1819         __HAL_I2C_ENABLE(hi2c);
;;;1820       }
;;;1821   
;;;1822       /* Disable Pos */
;;;1823       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1824   
;;;1825       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1826       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1827       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1828   
;;;1829       /* Prepare transfer parameters */
;;;1830       hi2c->pBuffPtr    = pData;
;;;1831       hi2c->XferCount   = Size;
;;;1832       hi2c->XferSize    = hi2c->XferCount;
;;;1833       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1834   
;;;1835       /* Enable Address Acknowledge */
;;;1836       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1837   
;;;1838       /* Process Unlocked */
;;;1839       __HAL_UNLOCK(hi2c);
;;;1840   
;;;1841       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1842                 to avoid the risk of I2C interrupt handle execution before current
;;;1843                 process unlock */
;;;1844   
;;;1845       /* Enable EVT, BUF and ERR interrupt */
;;;1846       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1847   
;;;1848       return HAL_OK;
;;;1849     }
;;;1850     else
;;;1851     {
;;;1852       return HAL_BUSY;
;;;1853     }
;;;1854   }
000012  bd10              POP      {r4,pc}
                  |L49.20|
000014  bf00              NOP                            ;1813
000016  f893003c          LDRB     r0,[r3,#0x3c]         ;1813
00001a  2801              CMP      r0,#1                 ;1813
00001c  d101              BNE      |L49.34|
00001e  2002              MOVS     r0,#2                 ;1813
000020  e7f7              B        |L49.18|
                  |L49.34|
000022  2001              MOVS     r0,#1                 ;1813
000024  f883003c          STRB     r0,[r3,#0x3c]         ;1813
000028  bf00              NOP                            ;1813
00002a  6818              LDR      r0,[r3,#0]            ;1816
00002c  6800              LDR      r0,[r0,#0]            ;1816
00002e  f0000001          AND      r0,r0,#1              ;1816
000032  b928              CBNZ     r0,|L49.64|
000034  6818              LDR      r0,[r3,#0]            ;1819
000036  6800              LDR      r0,[r0,#0]            ;1819
000038  f0400001          ORR      r0,r0,#1              ;1819
00003c  681c              LDR      r4,[r3,#0]            ;1819
00003e  6020              STR      r0,[r4,#0]            ;1819
                  |L49.64|
000040  6818              LDR      r0,[r3,#0]            ;1823
000042  6800              LDR      r0,[r0,#0]            ;1823
000044  f4206000          BIC      r0,r0,#0x800          ;1823
000048  681c              LDR      r4,[r3,#0]            ;1823
00004a  6020              STR      r0,[r4,#0]            ;1823
00004c  2021              MOVS     r0,#0x21              ;1825
00004e  f883003d          STRB     r0,[r3,#0x3d]         ;1825
000052  2020              MOVS     r0,#0x20              ;1826
000054  f883003e          STRB     r0,[r3,#0x3e]         ;1826
000058  2000              MOVS     r0,#0                 ;1827
00005a  6418              STR      r0,[r3,#0x40]         ;1827
00005c  6259              STR      r1,[r3,#0x24]         ;1830
00005e  855a              STRH     r2,[r3,#0x2a]         ;1831
000060  8d58              LDRH     r0,[r3,#0x2a]         ;1832
000062  8518              STRH     r0,[r3,#0x28]         ;1832
000064  480b              LDR      r0,|L49.148|
000066  62d8              STR      r0,[r3,#0x2c]         ;1833
000068  6818              LDR      r0,[r3,#0]            ;1836
00006a  6800              LDR      r0,[r0,#0]            ;1836
00006c  f4406080          ORR      r0,r0,#0x400          ;1836
000070  681c              LDR      r4,[r3,#0]            ;1836
000072  6020              STR      r0,[r4,#0]            ;1836
000074  bf00              NOP                            ;1839
000076  2000              MOVS     r0,#0                 ;1839
000078  f883003c          STRB     r0,[r3,#0x3c]         ;1839
00007c  bf00              NOP                            ;1839
00007e  6818              LDR      r0,[r3,#0]            ;1846
000080  6840              LDR      r0,[r0,#4]            ;1846
000082  f44060e0          ORR      r0,r0,#0x700          ;1846
000086  681c              LDR      r4,[r3,#0]            ;1846
000088  6060              STR      r0,[r4,#4]            ;1846
00008a  2000              MOVS     r0,#0                 ;1848
00008c  e7c1              B        |L49.18|
                  |L49.142|
00008e  2002              MOVS     r0,#2                 ;1852
000090  e7bf              B        |L49.18|
;;;1855   
                          ENDP

000092  0000              DCW      0x0000
                  |L49.148|
                          DCD      0xffff0000

                          AREA ||i.I2C_ConvertOtherXferOptions||, CODE, READONLY, ALIGN=1

                  I2C_ConvertOtherXferOptions PROC
;;;7062     */
;;;7063   static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;7064   {
;;;7065     /* if user set XferOptions to I2C_OTHER_FRAME            */
;;;7066     /* it request implicitly to generate a restart condition */
;;;7067     /* set XferOptions to I2C_FIRST_FRAME                    */
;;;7068     if (hi2c->XferOptions == I2C_OTHER_FRAME)
000002  f5b10f2a          CMP      r1,#0xaa0000
000006  d102              BNE      |L50.14|
;;;7069     {
;;;7070       hi2c->XferOptions = I2C_FIRST_FRAME;
000008  2101              MOVS     r1,#1
00000a  62c1              STR      r1,[r0,#0x2c]
00000c  e005              B        |L50.26|
                  |L50.14|
;;;7071     }
;;;7072     /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
;;;7073     /* it request implicitly to generate a restart condition    */
;;;7074     /* then generate a stop condition at the end of transfer    */
;;;7075     /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
;;;7076     else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
00000e  6ac1              LDR      r1,[r0,#0x2c]
000010  f1b14f2a          CMP      r1,#0xaa000000
000014  d101              BNE      |L50.26|
;;;7077     {
;;;7078       hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
000016  2108              MOVS     r1,#8
000018  62c1              STR      r1,[r0,#0x2c]
                  |L50.26|
;;;7079     }
;;;7080     else
;;;7081     {
;;;7082       /* Nothing to do */
;;;7083     }
;;;7084   }
00001a  4770              BX       lr
;;;7085   
                          ENDP


                          AREA ||i.I2C_DMAAbort||, CODE, READONLY, ALIGN=1

                  I2C_DMAAbort PROC
;;;6720     */
;;;6721   static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;6722   {
000002  4605              MOV      r5,r0
;;;6723     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;6724   
;;;6725     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6726     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000006  f894603d          LDRB     r6,[r4,#0x3d]
;;;6727   
;;;6728     /* Clear Complete callback */
;;;6729     hi2c->hdmatx->XferCpltCallback = NULL;
00000a  2000              MOVS     r0,#0
00000c  6b61              LDR      r1,[r4,#0x34]
00000e  63c8              STR      r0,[r1,#0x3c]
;;;6730     hi2c->hdmarx->XferCpltCallback = NULL;
000010  6ba1              LDR      r1,[r4,#0x38]
000012  63c8              STR      r0,[r1,#0x3c]
;;;6731   
;;;6732     /* Disable Acknowledge */
;;;6733     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000014  6820              LDR      r0,[r4,#0]
000016  6800              LDR      r0,[r0,#0]
000018  f4206080          BIC      r0,r0,#0x400
00001c  6821              LDR      r1,[r4,#0]
00001e  6008              STR      r0,[r1,#0]
;;;6734   
;;;6735     hi2c->XferCount = 0U;
000020  2000              MOVS     r0,#0
000022  8560              STRH     r0,[r4,#0x2a]
;;;6736   
;;;6737     /* Reset XferAbortCallback */
;;;6738     hi2c->hdmatx->XferAbortCallback = NULL;
000024  6b61              LDR      r1,[r4,#0x34]
000026  6508              STR      r0,[r1,#0x50]
;;;6739     hi2c->hdmarx->XferAbortCallback = NULL;
000028  6ba1              LDR      r1,[r4,#0x38]
00002a  6508              STR      r0,[r1,#0x50]
;;;6740   
;;;6741     /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6742     __HAL_I2C_DISABLE(hi2c);
00002c  6820              LDR      r0,[r4,#0]
00002e  6800              LDR      r0,[r0,#0]
000030  f0200001          BIC      r0,r0,#1
000034  6821              LDR      r1,[r4,#0]
000036  6008              STR      r0,[r1,#0]
;;;6743   
;;;6744     /* Check if come from abort from user */
;;;6745     if (hi2c->State == HAL_I2C_STATE_ABORT)
000038  f894003d          LDRB     r0,[r4,#0x3d]
00003c  2860              CMP      r0,#0x60
00003e  d10a              BNE      |L51.86|
;;;6746     {
;;;6747       hi2c->State         = HAL_I2C_STATE_READY;
000040  2020              MOVS     r0,#0x20
000042  f884003d          STRB     r0,[r4,#0x3d]
;;;6748       hi2c->Mode          = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;6749       hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
00004c  6420              STR      r0,[r4,#0x40]
;;;6750   
;;;6751       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6752   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6753       hi2c->AbortCpltCallback(hi2c);
;;;6754   #else
;;;6755       HAL_I2C_AbortCpltCallback(hi2c);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_I2C_AbortCpltCallback
000054  e01e              B        |L51.148|
                  |L51.86|
;;;6756   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6757     }
;;;6758     else
;;;6759     {
;;;6760       if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000056  f0060028          AND      r0,r6,#0x28
00005a  2828              CMP      r0,#0x28
00005c  d111              BNE      |L51.130|
;;;6761       {
;;;6762         /* Renable I2C peripheral */
;;;6763         __HAL_I2C_ENABLE(hi2c);
00005e  6820              LDR      r0,[r4,#0]
000060  6800              LDR      r0,[r0,#0]
000062  f0400001          ORR      r0,r0,#1
000066  6821              LDR      r1,[r4,#0]
000068  6008              STR      r0,[r1,#0]
;;;6764   
;;;6765         /* Enable Acknowledge */
;;;6766         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00006a  6820              LDR      r0,[r4,#0]
00006c  6800              LDR      r0,[r0,#0]
00006e  f4406080          ORR      r0,r0,#0x400
000072  6821              LDR      r1,[r4,#0]
000074  6008              STR      r0,[r1,#0]
;;;6767   
;;;6768         /* keep HAL_I2C_STATE_LISTEN */
;;;6769         hi2c->PreviousState = I2C_STATE_NONE;
000076  2000              MOVS     r0,#0
000078  6320              STR      r0,[r4,#0x30]
;;;6770         hi2c->State = HAL_I2C_STATE_LISTEN;
00007a  2028              MOVS     r0,#0x28
00007c  f884003d          STRB     r0,[r4,#0x3d]
000080  e005              B        |L51.142|
                  |L51.130|
;;;6771       }
;;;6772       else
;;;6773       {
;;;6774         hi2c->State = HAL_I2C_STATE_READY;
000082  2020              MOVS     r0,#0x20
000084  f884003d          STRB     r0,[r4,#0x3d]
;;;6775         hi2c->Mode = HAL_I2C_MODE_NONE;
000088  2000              MOVS     r0,#0
00008a  f884003e          STRB     r0,[r4,#0x3e]
                  |L51.142|
;;;6776       }
;;;6777   
;;;6778       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6779   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6780       hi2c->ErrorCallback(hi2c);
;;;6781   #else
;;;6782       HAL_I2C_ErrorCallback(hi2c);
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L51.148|
;;;6783   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6784     }
;;;6785   }
000094  bd70              POP      {r4-r6,pc}
;;;6786   
                          ENDP


                          AREA ||i.I2C_DMAError||, CODE, READONLY, ALIGN=1

                  I2C_DMAError PROC
;;;6685     */
;;;6686   static void I2C_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;6687   {
000002  4605              MOV      r5,r0
;;;6688     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;6689   
;;;6690     /* Clear Complete callback */
;;;6691     hi2c->hdmatx->XferCpltCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6b61              LDR      r1,[r4,#0x34]
00000a  63c8              STR      r0,[r1,#0x3c]
;;;6692     hi2c->hdmarx->XferCpltCallback = NULL;
00000c  6ba1              LDR      r1,[r4,#0x38]
00000e  63c8              STR      r0,[r1,#0x3c]
;;;6693   
;;;6694     /* Ignore DMA FIFO error */
;;;6695     if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       HAL_DMA_GetError
000016  2802              CMP      r0,#2
000018  d014              BEQ      |L52.68|
;;;6696     {
;;;6697       /* Disable Acknowledge */
;;;6698       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
00001a  6820              LDR      r0,[r4,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f4206080          BIC      r0,r0,#0x400
000022  6821              LDR      r1,[r4,#0]
000024  6008              STR      r0,[r1,#0]
;;;6699   
;;;6700       hi2c->XferCount = 0U;
000026  2000              MOVS     r0,#0
000028  8560              STRH     r0,[r4,#0x2a]
;;;6701   
;;;6702       hi2c->State = HAL_I2C_STATE_READY;
00002a  2020              MOVS     r0,#0x20
00002c  f884003d          STRB     r0,[r4,#0x3d]
;;;6703       hi2c->Mode = HAL_I2C_MODE_NONE;
000030  2000              MOVS     r0,#0
000032  f884003e          STRB     r0,[r4,#0x3e]
;;;6704   
;;;6705       hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
000036  6c20              LDR      r0,[r4,#0x40]
000038  f0400010          ORR      r0,r0,#0x10
00003c  6420              STR      r0,[r4,#0x40]
;;;6706   
;;;6707   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6708       hi2c->ErrorCallback(hi2c);
;;;6709   #else
;;;6710       HAL_I2C_ErrorCallback(hi2c);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L52.68|
;;;6711   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6712     }
;;;6713   }
000044  bd70              POP      {r4-r6,pc}
;;;6714   
                          ENDP


                          AREA ||i.I2C_DMAXferCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAXferCplt PROC
;;;6553     */
;;;6554   static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6555   {
000004  4607              MOV      r7,r0
;;;6556     I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
000006  6bbc              LDR      r4,[r7,#0x38]
;;;6557   
;;;6558     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6559     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000008  f894503d          LDRB     r5,[r4,#0x3d]
;;;6560     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
00000c  f894803e          LDRB     r8,[r4,#0x3e]
;;;6561     uint32_t CurrentXferOptions       = hi2c->XferOptions;
000010  6ae6              LDR      r6,[r4,#0x2c]
;;;6562   
;;;6563     /* Disable EVT and ERR interrupt */
;;;6564     __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000012  6820              LDR      r0,[r4,#0]
000014  6840              LDR      r0,[r0,#4]
000016  f4207040          BIC      r0,r0,#0x300
00001a  6821              LDR      r1,[r4,#0]
00001c  6048              STR      r0,[r1,#4]
;;;6565   
;;;6566     /* Clear Complete callback */
;;;6567     hi2c->hdmatx->XferCpltCallback = NULL;
00001e  2000              MOVS     r0,#0
000020  6b61              LDR      r1,[r4,#0x34]
000022  63c8              STR      r0,[r1,#0x3c]
;;;6568     hi2c->hdmarx->XferCpltCallback = NULL;
000024  6ba1              LDR      r1,[r4,#0x38]
000026  63c8              STR      r0,[r1,#0x3c]
;;;6569   
;;;6570     if ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_TX) == (uint32_t)HAL_I2C_STATE_BUSY_TX) || ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_RX) == (uint32_t)HAL_I2C_STATE_BUSY_RX) && (CurrentMode == HAL_I2C_MODE_SLAVE)))
000028  f0050021          AND      r0,r5,#0x21
00002c  2821              CMP      r0,#0x21
00002e  d006              BEQ      |L53.62|
000030  f0050022          AND      r0,r5,#0x22
000034  2822              CMP      r0,#0x22
000036  d126              BNE      |L53.134|
000038  f1b80f20          CMP      r8,#0x20
00003c  d123              BNE      |L53.134|
                  |L53.62|
;;;6571     {
;;;6572       /* Disable DMA Request */
;;;6573       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
00003e  6820              LDR      r0,[r4,#0]
000040  6840              LDR      r0,[r0,#4]
000042  f4206000          BIC      r0,r0,#0x800
000046  6821              LDR      r1,[r4,#0]
000048  6048              STR      r0,[r1,#4]
;;;6574   
;;;6575       hi2c->XferCount = 0U;
00004a  2000              MOVS     r0,#0
00004c  8560              STRH     r0,[r4,#0x2a]
;;;6576   
;;;6577       if (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN)
00004e  2d29              CMP      r5,#0x29
000050  d108              BNE      |L53.100|
;;;6578       {
;;;6579         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6580         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
000052  2021              MOVS     r0,#0x21
000054  6320              STR      r0,[r4,#0x30]
;;;6581         hi2c->State = HAL_I2C_STATE_LISTEN;
000056  2028              MOVS     r0,#0x28
000058  f884003d          STRB     r0,[r4,#0x3d]
;;;6582   
;;;6583         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6584   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6585         hi2c->SlaveTxCpltCallback(hi2c);
;;;6586   #else
;;;6587         HAL_I2C_SlaveTxCpltCallback(hi2c);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
000062  e009              B        |L53.120|
                  |L53.100|
;;;6588   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6589       }
;;;6590       else if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
000064  2d2a              CMP      r5,#0x2a
000066  d107              BNE      |L53.120|
;;;6591       {
;;;6592         /* Set state at HAL_I2C_STATE_LISTEN */
;;;6593         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000068  2022              MOVS     r0,#0x22
00006a  6320              STR      r0,[r4,#0x30]
;;;6594         hi2c->State = HAL_I2C_STATE_LISTEN;
00006c  2028              MOVS     r0,#0x28
00006e  f884003d          STRB     r0,[r4,#0x3d]
;;;6595   
;;;6596         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6597   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6598         hi2c->SlaveRxCpltCallback(hi2c);
;;;6599   #else
;;;6600         HAL_I2C_SlaveRxCpltCallback(hi2c);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L53.120|
;;;6601   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6602       }
;;;6603       else
;;;6604       {
;;;6605         /* Do nothing */
;;;6606       }
;;;6607   
;;;6608       /* Enable EVT and ERR interrupt to treat end of transfer in IRQ handler */
;;;6609       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
000078  6820              LDR      r0,[r4,#0]
00007a  6840              LDR      r0,[r0,#4]
00007c  f4407040          ORR      r0,r0,#0x300
000080  6821              LDR      r1,[r4,#0]
000082  6048              STR      r0,[r1,#4]
000084  e04d              B        |L53.290|
                  |L53.134|
;;;6610     }
;;;6611     /* Check current Mode, in case of treatment DMA handler have been preempted by a prior interrupt */
;;;6612     else if (hi2c->Mode != HAL_I2C_MODE_NONE)
000086  f894003e          LDRB     r0,[r4,#0x3e]
00008a  2800              CMP      r0,#0
00008c  d049              BEQ      |L53.290|
;;;6613     {
;;;6614       if (hi2c->XferCount == (uint16_t)1)
00008e  8d60              LDRH     r0,[r4,#0x2a]
000090  2801              CMP      r0,#1
000092  d105              BNE      |L53.160|
;;;6615       {
;;;6616         /* Disable Acknowledge */
;;;6617         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000094  6820              LDR      r0,[r4,#0]
000096  6800              LDR      r0,[r0,#0]
000098  f4206080          BIC      r0,r0,#0x400
00009c  6821              LDR      r1,[r4,#0]
00009e  6008              STR      r0,[r1,#0]
                  |L53.160|
;;;6618       }
;;;6619   
;;;6620       /* Disable EVT and ERR interrupt */
;;;6621       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6840              LDR      r0,[r0,#4]
0000a4  f4207040          BIC      r0,r0,#0x300
0000a8  6821              LDR      r1,[r4,#0]
0000aa  6048              STR      r0,[r1,#4]
;;;6622   
;;;6623       /* Prepare next transfer or stop current transfer */
;;;6624       if ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_OTHER_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
0000ac  f5163f80          CMN      r6,#0x10000
0000b0  d006              BEQ      |L53.192|
0000b2  2e08              CMP      r6,#8
0000b4  d004              BEQ      |L53.192|
0000b6  f1b64f2a          CMP      r6,#0xaa000000
0000ba  d001              BEQ      |L53.192|
0000bc  2e20              CMP      r6,#0x20
0000be  d105              BNE      |L53.204|
                  |L53.192|
;;;6625       {
;;;6626         /* Generate Stop */
;;;6627         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6800              LDR      r0,[r0,#0]
0000c4  f4407000          ORR      r0,r0,#0x200
0000c8  6821              LDR      r1,[r4,#0]
0000ca  6008              STR      r0,[r1,#0]
                  |L53.204|
;;;6628       }
;;;6629   
;;;6630       /* Disable Last DMA */
;;;6631       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
0000cc  6820              LDR      r0,[r4,#0]
0000ce  6840              LDR      r0,[r0,#4]
0000d0  f4205080          BIC      r0,r0,#0x1000
0000d4  6821              LDR      r1,[r4,#0]
0000d6  6048              STR      r0,[r1,#4]
;;;6632   
;;;6633       /* Disable DMA Request */
;;;6634       CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
0000d8  6820              LDR      r0,[r4,#0]
0000da  6840              LDR      r0,[r0,#4]
0000dc  f4206000          BIC      r0,r0,#0x800
0000e0  6821              LDR      r1,[r4,#0]
0000e2  6048              STR      r0,[r1,#4]
;;;6635   
;;;6636       hi2c->XferCount = 0U;
0000e4  2000              MOVS     r0,#0
0000e6  8560              STRH     r0,[r4,#0x2a]
;;;6637   
;;;6638       /* Check if Errors has been detected during transfer */
;;;6639       if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
0000e8  6c20              LDR      r0,[r4,#0x40]
0000ea  b118              CBZ      r0,|L53.244|
;;;6640       {
;;;6641   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6642         hi2c->ErrorCallback(hi2c);
;;;6643   #else
;;;6644         HAL_I2C_ErrorCallback(hi2c);
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       HAL_I2C_ErrorCallback
0000f2  e016              B        |L53.290|
                  |L53.244|
;;;6645   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6646       }
;;;6647       else
;;;6648       {
;;;6649         hi2c->State = HAL_I2C_STATE_READY;
0000f4  2020              MOVS     r0,#0x20
0000f6  f884003d          STRB     r0,[r4,#0x3d]
;;;6650   
;;;6651         if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000fa  f894003e          LDRB     r0,[r4,#0x3e]
0000fe  2840              CMP      r0,#0x40
000100  d107              BNE      |L53.274|
;;;6652         {
;;;6653           hi2c->Mode = HAL_I2C_MODE_NONE;
000102  2000              MOVS     r0,#0
000104  f884003e          STRB     r0,[r4,#0x3e]
;;;6654           hi2c->PreviousState = I2C_STATE_NONE;
000108  6320              STR      r0,[r4,#0x30]
;;;6655   
;;;6656   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6657           hi2c->MemRxCpltCallback(hi2c);
;;;6658   #else
;;;6659           HAL_I2C_MemRxCpltCallback(hi2c);
00010a  4620              MOV      r0,r4
00010c  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
000110  e007              B        |L53.290|
                  |L53.274|
;;;6660   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6661         }
;;;6662         else
;;;6663         {
;;;6664           hi2c->Mode = HAL_I2C_MODE_NONE;
000112  2000              MOVS     r0,#0
000114  f884003e          STRB     r0,[r4,#0x3e]
;;;6665           hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000118  2012              MOVS     r0,#0x12
00011a  6320              STR      r0,[r4,#0x30]
;;;6666   
;;;6667   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6668           hi2c->MasterRxCpltCallback(hi2c);
;;;6669   #else
;;;6670           HAL_I2C_MasterRxCpltCallback(hi2c);
00011c  4620              MOV      r0,r4
00011e  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L53.290|
;;;6671   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6672         }
;;;6673       }
;;;6674     }
;;;6675     else
;;;6676     {
;;;6677       /* Do nothing */
;;;6678     }
;;;6679   }
000122  e8bd81f0          POP      {r4-r8,pc}
;;;6680   
                          ENDP


                          AREA ||i.I2C_ITError||, CODE, READONLY, ALIGN=2

                  I2C_ITError PROC
;;;6063     */
;;;6064   static void I2C_ITError(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;6065   {
000002  4604              MOV      r4,r0
;;;6066     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6067     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;6068   
;;;6069     if ((hi2c->Mode == HAL_I2C_MODE_MASTER) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
000008  f894003e          LDRB     r0,[r4,#0x3e]
00000c  2810              CMP      r0,#0x10
00000e  d107              BNE      |L54.32|
000010  2d22              CMP      r5,#0x22
000012  d105              BNE      |L54.32|
;;;6070     {
;;;6071       /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
;;;6072       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
000014  6820              LDR      r0,[r4,#0]
000016  6800              LDR      r0,[r0,#0]
000018  f4206000          BIC      r0,r0,#0x800
00001c  6821              LDR      r1,[r4,#0]
00001e  6008              STR      r0,[r1,#0]
                  |L54.32|
;;;6073     }
;;;6074   
;;;6075     if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
000020  f0050028          AND      r0,r5,#0x28
000024  2828              CMP      r0,#0x28
000026  d105              BNE      |L54.52|
;;;6076     {
;;;6077       /* keep HAL_I2C_STATE_LISTEN */
;;;6078       hi2c->PreviousState = I2C_STATE_NONE;
000028  2000              MOVS     r0,#0
00002a  6320              STR      r0,[r4,#0x30]
;;;6079       hi2c->State = HAL_I2C_STATE_LISTEN;
00002c  2028              MOVS     r0,#0x28
00002e  f884003d          STRB     r0,[r4,#0x3d]
000032  e00f              B        |L54.84|
                  |L54.52|
;;;6080     }
;;;6081     else
;;;6082     {
;;;6083       /* If state is an abort treatment on going, don't change state */
;;;6084       /* This change will be do later */
;;;6085       if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
000034  6820              LDR      r0,[r4,#0]
000036  6840              LDR      r0,[r0,#4]
000038  f4006000          AND      r0,r0,#0x800
00003c  f5b06f00          CMP      r0,#0x800
000040  d004              BEQ      |L54.76|
000042  2d60              CMP      r5,#0x60
000044  d002              BEQ      |L54.76|
;;;6086       {
;;;6087         hi2c->State = HAL_I2C_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  f884003d          STRB     r0,[r4,#0x3d]
                  |L54.76|
;;;6088       }
;;;6089       hi2c->PreviousState = I2C_STATE_NONE;
00004c  2000              MOVS     r0,#0
00004e  6320              STR      r0,[r4,#0x30]
;;;6090       hi2c->Mode = HAL_I2C_MODE_NONE;
000050  f884003e          STRB     r0,[r4,#0x3e]
                  |L54.84|
;;;6091     }
;;;6092   
;;;6093     /* Abort DMA transfer */
;;;6094     if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
000054  6820              LDR      r0,[r4,#0]
000056  6840              LDR      r0,[r0,#4]
000058  f4006000          AND      r0,r0,#0x800
00005c  f5b06f00          CMP      r0,#0x800
000060  d140              BNE      |L54.228|
;;;6095     {
;;;6096       hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
000062  6820              LDR      r0,[r4,#0]
000064  6840              LDR      r0,[r0,#4]
000066  f4206000          BIC      r0,r0,#0x800
00006a  6821              LDR      r1,[r4,#0]
00006c  6048              STR      r0,[r1,#4]
;;;6097   
;;;6098       if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
00006e  6b60              LDR      r0,[r4,#0x34]
000070  f8900035          LDRB     r0,[r0,#0x35]
000074  2801              CMP      r0,#1
000076  d014              BEQ      |L54.162|
;;;6099       {
;;;6100         /* Set the DMA Abort callback :
;;;6101         will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6102         hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
000078  4840              LDR      r0,|L54.380|
00007a  6b61              LDR      r1,[r4,#0x34]
00007c  6508              STR      r0,[r1,#0x50]
;;;6103   
;;;6104         if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
00007e  6b60              LDR      r0,[r4,#0x34]
000080  f7fffffe          BL       HAL_DMA_Abort_IT
000084  2800              CMP      r0,#0
000086  d05b              BEQ      |L54.320|
;;;6105         {
;;;6106           /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6107           __HAL_I2C_DISABLE(hi2c);
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  f0200001          BIC      r0,r0,#1
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
;;;6108   
;;;6109           hi2c->State = HAL_I2C_STATE_READY;
000094  2020              MOVS     r0,#0x20
000096  f884003d          STRB     r0,[r4,#0x3d]
;;;6110   
;;;6111           /* Call Directly XferAbortCallback function in case of error */
;;;6112           hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
00009a  6b60              LDR      r0,[r4,#0x34]
00009c  6d01              LDR      r1,[r0,#0x50]
00009e  4788              BLX      r1
0000a0  e04e              B        |L54.320|
                  |L54.162|
;;;6113         }
;;;6114       }
;;;6115       else
;;;6116       {
;;;6117         /* Set the DMA Abort callback :
;;;6118         will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;6119         hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
0000a2  4836              LDR      r0,|L54.380|
0000a4  6ba1              LDR      r1,[r4,#0x38]
0000a6  6508              STR      r0,[r1,#0x50]
;;;6120   
;;;6121         if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
0000a8  6ba0              LDR      r0,[r4,#0x38]
0000aa  f7fffffe          BL       HAL_DMA_Abort_IT
0000ae  2800              CMP      r0,#0
0000b0  d046              BEQ      |L54.320|
;;;6122         {
;;;6123           /* Store Last receive data if any */
;;;6124           if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6940              LDR      r0,[r0,#0x14]
0000b6  f3c01080          UBFX     r0,r0,#6,#1
0000ba  b130              CBZ      r0,|L54.202|
;;;6125           {
;;;6126             /* Read data from DR */
;;;6127             *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000bc  6820              LDR      r0,[r4,#0]
0000be  6900              LDR      r0,[r0,#0x10]
0000c0  6a61              LDR      r1,[r4,#0x24]
0000c2  7008              STRB     r0,[r1,#0]
;;;6128   
;;;6129             /* Increment Buffer pointer */
;;;6130             hi2c->pBuffPtr++;
0000c4  6a60              LDR      r0,[r4,#0x24]
0000c6  1c40              ADDS     r0,r0,#1
0000c8  6260              STR      r0,[r4,#0x24]
                  |L54.202|
;;;6131           }
;;;6132   
;;;6133           /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6134           __HAL_I2C_DISABLE(hi2c);
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6800              LDR      r0,[r0,#0]
0000ce  f0200001          BIC      r0,r0,#1
0000d2  6821              LDR      r1,[r4,#0]
0000d4  6008              STR      r0,[r1,#0]
;;;6135   
;;;6136           hi2c->State = HAL_I2C_STATE_READY;
0000d6  2020              MOVS     r0,#0x20
0000d8  f884003d          STRB     r0,[r4,#0x3d]
;;;6137   
;;;6138           /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
;;;6139           hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
0000dc  6ba0              LDR      r0,[r4,#0x38]
0000de  6d01              LDR      r1,[r0,#0x50]
0000e0  4788              BLX      r1
0000e2  e02d              B        |L54.320|
                  |L54.228|
;;;6140         }
;;;6141       }
;;;6142     }
;;;6143     else if (hi2c->State == HAL_I2C_STATE_ABORT)
0000e4  f894003d          LDRB     r0,[r4,#0x3d]
0000e8  2860              CMP      r0,#0x60
0000ea  d11a              BNE      |L54.290|
;;;6144     {
;;;6145       hi2c->State = HAL_I2C_STATE_READY;
0000ec  2020              MOVS     r0,#0x20
0000ee  f884003d          STRB     r0,[r4,#0x3d]
;;;6146       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
0000f2  2000              MOVS     r0,#0
0000f4  6420              STR      r0,[r4,#0x40]
;;;6147   
;;;6148       /* Store Last receive data if any */
;;;6149       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000f6  6820              LDR      r0,[r4,#0]
0000f8  6940              LDR      r0,[r0,#0x14]
0000fa  f3c01080          UBFX     r0,r0,#6,#1
0000fe  b130              CBZ      r0,|L54.270|
;;;6150       {
;;;6151         /* Read data from DR */
;;;6152         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000100  6820              LDR      r0,[r4,#0]
000102  6900              LDR      r0,[r0,#0x10]
000104  6a61              LDR      r1,[r4,#0x24]
000106  7008              STRB     r0,[r1,#0]
;;;6153   
;;;6154         /* Increment Buffer pointer */
;;;6155         hi2c->pBuffPtr++;
000108  6a60              LDR      r0,[r4,#0x24]
00010a  1c40              ADDS     r0,r0,#1
00010c  6260              STR      r0,[r4,#0x24]
                  |L54.270|
;;;6156       }
;;;6157   
;;;6158       /* Disable I2C peripheral to prevent dummy data in buffer */
;;;6159       __HAL_I2C_DISABLE(hi2c);
00010e  6820              LDR      r0,[r4,#0]
000110  6800              LDR      r0,[r0,#0]
000112  f0200001          BIC      r0,r0,#1
000116  6821              LDR      r1,[r4,#0]
000118  6008              STR      r0,[r1,#0]
;;;6160   
;;;6161       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;6162   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6163       hi2c->AbortCpltCallback(hi2c);
;;;6164   #else
;;;6165       HAL_I2C_AbortCpltCallback(hi2c);
00011a  4620              MOV      r0,r4
00011c  f7fffffe          BL       HAL_I2C_AbortCpltCallback
000120  e00e              B        |L54.320|
                  |L54.290|
;;;6166   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6167     }
;;;6168     else
;;;6169     {
;;;6170       /* Store Last receive data if any */
;;;6171       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
000122  6820              LDR      r0,[r4,#0]
000124  6940              LDR      r0,[r0,#0x14]
000126  f3c01080          UBFX     r0,r0,#6,#1
00012a  b130              CBZ      r0,|L54.314|
;;;6172       {
;;;6173         /* Read data from DR */
;;;6174         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
00012c  6820              LDR      r0,[r4,#0]
00012e  6900              LDR      r0,[r0,#0x10]
000130  6a61              LDR      r1,[r4,#0x24]
000132  7008              STRB     r0,[r1,#0]
;;;6175   
;;;6176         /* Increment Buffer pointer */
;;;6177         hi2c->pBuffPtr++;
000134  6a60              LDR      r0,[r4,#0x24]
000136  1c40              ADDS     r0,r0,#1
000138  6260              STR      r0,[r4,#0x24]
                  |L54.314|
;;;6178       }
;;;6179   
;;;6180       /* Call user error callback */
;;;6181   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6182       hi2c->ErrorCallback(hi2c);
;;;6183   #else
;;;6184       HAL_I2C_ErrorCallback(hi2c);
00013a  4620              MOV      r0,r4
00013c  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L54.320|
;;;6185   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6186     }
;;;6187     /* STOP Flag is not set after a NACK reception */
;;;6188     /* So may inform upper layer that listen phase is stopped */
;;;6189     /* during NACK error treatment */
;;;6190     CurrentState = hi2c->State;
000140  f894503d          LDRB     r5,[r4,#0x3d]
;;;6191     if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
000144  6c20              LDR      r0,[r4,#0x40]
000146  f0000004          AND      r0,r0,#4
00014a  2804              CMP      r0,#4
00014c  d114              BNE      |L54.376|
00014e  2d28              CMP      r5,#0x28
000150  d112              BNE      |L54.376|
;;;6192     {
;;;6193       /* Disable EVT, BUF and ERR interrupt */
;;;6194       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000152  6820              LDR      r0,[r4,#0]
000154  6840              LDR      r0,[r0,#4]
000156  f42060e0          BIC      r0,r0,#0x700
00015a  6821              LDR      r1,[r4,#0]
00015c  6048              STR      r0,[r1,#4]
;;;6195   
;;;6196       hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
00015e  4808              LDR      r0,|L54.384|
000160  62e0              STR      r0,[r4,#0x2c]
;;;6197       hi2c->PreviousState = I2C_STATE_NONE;
000162  2000              MOVS     r0,#0
000164  6320              STR      r0,[r4,#0x30]
;;;6198       hi2c->State         = HAL_I2C_STATE_READY;
000166  2020              MOVS     r0,#0x20
000168  f884003d          STRB     r0,[r4,#0x3d]
;;;6199       hi2c->Mode          = HAL_I2C_MODE_NONE;
00016c  2000              MOVS     r0,#0
00016e  f884003e          STRB     r0,[r4,#0x3e]
;;;6200   
;;;6201       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;6202   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6203       hi2c->ListenCpltCallback(hi2c);
;;;6204   #else
;;;6205       HAL_I2C_ListenCpltCallback(hi2c);
000172  4620              MOV      r0,r4
000174  f7fffffe          BL       HAL_I2C_ListenCpltCallback
                  |L54.376|
;;;6206   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6207     }
;;;6208   }
000178  bd70              POP      {r4-r6,pc}
;;;6209   
                          ENDP

00017a  0000              DCW      0x0000
                  |L54.380|
                          DCD      I2C_DMAAbort
                  |L54.384|
                          DCD      0xffff0000

                          AREA ||i.I2C_IsAcknowledgeFailed||, CODE, READONLY, ALIGN=1

                  I2C_IsAcknowledgeFailed PROC
;;;7037     */
;;;7038   static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;7039   {
;;;7040     if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
000002  6808              LDR      r0,[r1,#0]
000004  6940              LDR      r0,[r0,#0x14]
000006  f3c02080          UBFX     r0,r0,#10,#1
00000a  b1b0              CBZ      r0,|L55.58|
;;;7041     {
;;;7042       /* Clear NACKF Flag */
;;;7043       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00000c  f46f6080          MVN      r0,#0x400
000010  680a              LDR      r2,[r1,#0]
000012  6150              STR      r0,[r2,#0x14]
;;;7044   
;;;7045       hi2c->PreviousState       = I2C_STATE_NONE;
000014  2000              MOVS     r0,#0
000016  6308              STR      r0,[r1,#0x30]
;;;7046       hi2c->State               = HAL_I2C_STATE_READY;
000018  2020              MOVS     r0,#0x20
00001a  f881003d          STRB     r0,[r1,#0x3d]
;;;7047       hi2c->Mode                = HAL_I2C_MODE_NONE;
00001e  2000              MOVS     r0,#0
000020  f881003e          STRB     r0,[r1,#0x3e]
;;;7048       hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
000024  6c08              LDR      r0,[r1,#0x40]
000026  f0400004          ORR      r0,r0,#4
00002a  6408              STR      r0,[r1,#0x40]
;;;7049   
;;;7050       /* Process Unlocked */
;;;7051       __HAL_UNLOCK(hi2c);
00002c  bf00              NOP      
00002e  2000              MOVS     r0,#0
000030  f881003c          STRB     r0,[r1,#0x3c]
000034  bf00              NOP      
;;;7052   
;;;7053       return HAL_ERROR;
000036  2001              MOVS     r0,#1
                  |L55.56|
;;;7054     }
;;;7055     return HAL_OK;
;;;7056   }
000038  4770              BX       lr
                  |L55.58|
00003a  2000              MOVS     r0,#0                 ;7055
00003c  e7fc              B        |L55.56|
;;;7057   
                          ENDP


                          AREA ||i.I2C_MasterReceive_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_BTF PROC
;;;5297     */
;;;5298   static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5299   {
000002  4604              MOV      r4,r0
;;;5300     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5301     uint32_t CurrentXferOptions = hi2c->XferOptions;
000004  6ae5              LDR      r5,[r4,#0x2c]
;;;5302   
;;;5303     if (hi2c->XferCount == 4U)
000006  8d60              LDRH     r0,[r4,#0x2a]
000008  2804              CMP      r0,#4
00000a  d110              BNE      |L56.46|
;;;5304     {
;;;5305       /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
;;;5306          on BTF subroutine if there is a reception delay between N-1 and N byte */
;;;5307       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
00000c  6820              LDR      r0,[r4,#0]
00000e  6840              LDR      r0,[r0,#4]
000010  f4206080          BIC      r0,r0,#0x400
000014  6821              LDR      r1,[r4,#0]
000016  6048              STR      r0,[r1,#4]
;;;5308   
;;;5309       /* Read data from DR */
;;;5310       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000018  6820              LDR      r0,[r4,#0]
00001a  6900              LDR      r0,[r0,#0x10]
00001c  6a61              LDR      r1,[r4,#0x24]
00001e  7008              STRB     r0,[r1,#0]
;;;5311   
;;;5312       /* Increment Buffer pointer */
;;;5313       hi2c->pBuffPtr++;
000020  6a60              LDR      r0,[r4,#0x24]
000022  1c40              ADDS     r0,r0,#1
000024  6260              STR      r0,[r4,#0x24]
;;;5314   
;;;5315       /* Update counter */
;;;5316       hi2c->XferCount--;
000026  8d60              LDRH     r0,[r4,#0x2a]
000028  1e40              SUBS     r0,r0,#1
00002a  8560              STRH     r0,[r4,#0x2a]
00002c  e07a              B        |L56.292|
                  |L56.46|
;;;5317     }
;;;5318     else if (hi2c->XferCount == 3U)
00002e  8d60              LDRH     r0,[r4,#0x2a]
000030  2803              CMP      r0,#3
000032  d11a              BNE      |L56.106|
;;;5319     {
;;;5320       /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
;;;5321          on BTF subroutine if there is a reception delay between N-1 and N byte */
;;;5322       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000034  6820              LDR      r0,[r4,#0]
000036  6840              LDR      r0,[r0,#4]
000038  f4206080          BIC      r0,r0,#0x400
00003c  6821              LDR      r1,[r4,#0]
00003e  6048              STR      r0,[r1,#4]
;;;5323   
;;;5324       if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
000040  2d04              CMP      r5,#4
000042  d007              BEQ      |L56.84|
000044  2d02              CMP      r5,#2
000046  d005              BEQ      |L56.84|
;;;5325       {
;;;5326         /* Disable Acknowledge */
;;;5327         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000048  6820              LDR      r0,[r4,#0]
00004a  6800              LDR      r0,[r0,#0]
00004c  f4206080          BIC      r0,r0,#0x400
000050  6821              LDR      r1,[r4,#0]
000052  6008              STR      r0,[r1,#0]
                  |L56.84|
;;;5328       }
;;;5329   
;;;5330       /* Read data from DR */
;;;5331       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000054  6820              LDR      r0,[r4,#0]
000056  6900              LDR      r0,[r0,#0x10]
000058  6a61              LDR      r1,[r4,#0x24]
00005a  7008              STRB     r0,[r1,#0]
;;;5332   
;;;5333       /* Increment Buffer pointer */
;;;5334       hi2c->pBuffPtr++;
00005c  6a60              LDR      r0,[r4,#0x24]
00005e  1c40              ADDS     r0,r0,#1
000060  6260              STR      r0,[r4,#0x24]
;;;5335   
;;;5336       /* Update counter */
;;;5337       hi2c->XferCount--;
000062  8d60              LDRH     r0,[r4,#0x2a]
000064  1e40              SUBS     r0,r0,#1
000066  8560              STRH     r0,[r4,#0x2a]
000068  e05c              B        |L56.292|
                  |L56.106|
;;;5338     }
;;;5339     else if (hi2c->XferCount == 2U)
00006a  8d60              LDRH     r0,[r4,#0x2a]
00006c  2802              CMP      r0,#2
00006e  d14f              BNE      |L56.272|
;;;5340     {
;;;5341       /* Prepare next transfer or stop current transfer */
;;;5342       if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
000070  2d01              CMP      r5,#1
000072  d001              BEQ      |L56.120|
000074  2d10              CMP      r5,#0x10
000076  d106              BNE      |L56.134|
                  |L56.120|
;;;5343       {
;;;5344         /* Disable Acknowledge */
;;;5345         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000078  6820              LDR      r0,[r4,#0]
00007a  6800              LDR      r0,[r0,#0]
00007c  f4206080          BIC      r0,r0,#0x400
000080  6821              LDR      r1,[r4,#0]
000082  6008              STR      r0,[r1,#0]
000084  e012              B        |L56.172|
                  |L56.134|
;;;5346       }
;;;5347       else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
000086  2d04              CMP      r5,#4
000088  d001              BEQ      |L56.142|
00008a  2d02              CMP      r5,#2
00008c  d106              BNE      |L56.156|
                  |L56.142|
;;;5348       {
;;;5349         /* Enable Acknowledge */
;;;5350         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00008e  6820              LDR      r0,[r4,#0]
000090  6800              LDR      r0,[r0,#0]
000092  f4406080          ORR      r0,r0,#0x400
000096  6821              LDR      r1,[r4,#0]
000098  6008              STR      r0,[r1,#0]
00009a  e007              B        |L56.172|
                  |L56.156|
;;;5351       }
;;;5352       else if (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP)
00009c  2d10              CMP      r5,#0x10
00009e  d005              BEQ      |L56.172|
;;;5353       {
;;;5354         /* Generate Stop */
;;;5355         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6800              LDR      r0,[r0,#0]
0000a4  f4407000          ORR      r0,r0,#0x200
0000a8  6821              LDR      r1,[r4,#0]
0000aa  6008              STR      r0,[r1,#0]
                  |L56.172|
;;;5356       }
;;;5357       else
;;;5358       {
;;;5359         /* Do nothing */
;;;5360       }
;;;5361   
;;;5362       /* Read data from DR */
;;;5363       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6900              LDR      r0,[r0,#0x10]
0000b0  6a61              LDR      r1,[r4,#0x24]
0000b2  7008              STRB     r0,[r1,#0]
;;;5364   
;;;5365       /* Increment Buffer pointer */
;;;5366       hi2c->pBuffPtr++;
0000b4  6a60              LDR      r0,[r4,#0x24]
0000b6  1c40              ADDS     r0,r0,#1
0000b8  6260              STR      r0,[r4,#0x24]
;;;5367   
;;;5368       /* Update counter */
;;;5369       hi2c->XferCount--;
0000ba  8d60              LDRH     r0,[r4,#0x2a]
0000bc  1e40              SUBS     r0,r0,#1
0000be  8560              STRH     r0,[r4,#0x2a]
;;;5370   
;;;5371       /* Read data from DR */
;;;5372       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6900              LDR      r0,[r0,#0x10]
0000c4  6a61              LDR      r1,[r4,#0x24]
0000c6  7008              STRB     r0,[r1,#0]
;;;5373   
;;;5374       /* Increment Buffer pointer */
;;;5375       hi2c->pBuffPtr++;
0000c8  6a60              LDR      r0,[r4,#0x24]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  6260              STR      r0,[r4,#0x24]
;;;5376   
;;;5377       /* Update counter */
;;;5378       hi2c->XferCount--;
0000ce  8d60              LDRH     r0,[r4,#0x2a]
0000d0  1e40              SUBS     r0,r0,#1
0000d2  8560              STRH     r0,[r4,#0x2a]
;;;5379   
;;;5380       /* Disable EVT and ERR interrupt */
;;;5381       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6840              LDR      r0,[r0,#4]
0000d8  f4207040          BIC      r0,r0,#0x300
0000dc  6821              LDR      r1,[r4,#0]
0000de  6048              STR      r0,[r1,#4]
;;;5382   
;;;5383       hi2c->State = HAL_I2C_STATE_READY;
0000e0  2020              MOVS     r0,#0x20
0000e2  f884003d          STRB     r0,[r4,#0x3d]
;;;5384       if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000e6  f894003e          LDRB     r0,[r4,#0x3e]
0000ea  2840              CMP      r0,#0x40
0000ec  d107              BNE      |L56.254|
;;;5385       {
;;;5386         hi2c->Mode = HAL_I2C_MODE_NONE;
0000ee  2000              MOVS     r0,#0
0000f0  f884003e          STRB     r0,[r4,#0x3e]
;;;5387         hi2c->PreviousState = I2C_STATE_NONE;
0000f4  6320              STR      r0,[r4,#0x30]
;;;5388   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5389         hi2c->MemRxCpltCallback(hi2c);
;;;5390   #else
;;;5391         HAL_I2C_MemRxCpltCallback(hi2c);
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
0000fc  e012              B        |L56.292|
                  |L56.254|
;;;5392   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5393       }
;;;5394       else
;;;5395       {
;;;5396         hi2c->Mode = HAL_I2C_MODE_NONE;
0000fe  2000              MOVS     r0,#0
000100  f884003e          STRB     r0,[r4,#0x3e]
;;;5397         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000104  2012              MOVS     r0,#0x12
000106  6320              STR      r0,[r4,#0x30]
;;;5398   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5399         hi2c->MasterRxCpltCallback(hi2c);
;;;5400   #else
;;;5401         HAL_I2C_MasterRxCpltCallback(hi2c);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
00010e  e009              B        |L56.292|
                  |L56.272|
;;;5402   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5403       }
;;;5404     }
;;;5405     else
;;;5406     {
;;;5407       /* Read data from DR */
;;;5408       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000110  6820              LDR      r0,[r4,#0]
000112  6900              LDR      r0,[r0,#0x10]
000114  6a61              LDR      r1,[r4,#0x24]
000116  7008              STRB     r0,[r1,#0]
;;;5409   
;;;5410       /* Increment Buffer pointer */
;;;5411       hi2c->pBuffPtr++;
000118  6a60              LDR      r0,[r4,#0x24]
00011a  1c40              ADDS     r0,r0,#1
00011c  6260              STR      r0,[r4,#0x24]
;;;5412   
;;;5413       /* Update counter */
;;;5414       hi2c->XferCount--;
00011e  8d60              LDRH     r0,[r4,#0x2a]
000120  1e40              SUBS     r0,r0,#1
000122  8560              STRH     r0,[r4,#0x2a]
                  |L56.292|
;;;5415     }
;;;5416   }
000124  bd70              POP      {r4-r6,pc}
;;;5417   
                          ENDP


                          AREA ||i.I2C_MasterReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_RXNE PROC
;;;5216     */
;;;5217   static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5218   {
000002  4604              MOV      r4,r0
;;;5219     if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
000004  f894003d          LDRB     r0,[r4,#0x3d]
000008  2822              CMP      r0,#0x22
00000a  d14a              BNE      |L57.162|
;;;5220     {
;;;5221       uint32_t tmp;
;;;5222   
;;;5223       tmp = hi2c->XferCount;
00000c  8d65              LDRH     r5,[r4,#0x2a]
;;;5224       if (tmp > 3U)
00000e  2d03              CMP      r5,#3
000010  d913              BLS      |L57.58|
;;;5225       {
;;;5226         /* Read data from DR */
;;;5227         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000012  6820              LDR      r0,[r4,#0]
000014  6900              LDR      r0,[r0,#0x10]
000016  6a61              LDR      r1,[r4,#0x24]
000018  7008              STRB     r0,[r1,#0]
;;;5228   
;;;5229         /* Increment Buffer pointer */
;;;5230         hi2c->pBuffPtr++;
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  1c40              ADDS     r0,r0,#1
00001e  6260              STR      r0,[r4,#0x24]
;;;5231   
;;;5232         /* Update counter */
;;;5233         hi2c->XferCount--;
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  1e40              SUBS     r0,r0,#1
000024  8560              STRH     r0,[r4,#0x2a]
;;;5234   
;;;5235         if (hi2c->XferCount == (uint16_t)3)
000026  8d60              LDRH     r0,[r4,#0x2a]
000028  2803              CMP      r0,#3
00002a  d139              BNE      |L57.160|
;;;5236         {
;;;5237           /* Disable BUF interrupt, this help to treat correctly the last 4 bytes
;;;5238           on BTF subroutine */
;;;5239           /* Disable BUF interrupt */
;;;5240           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  f4206080          BIC      r0,r0,#0x400
000034  6821              LDR      r1,[r4,#0]
000036  6048              STR      r0,[r1,#4]
000038  e032              B        |L57.160|
                  |L57.58|
;;;5241         }
;;;5242       }
;;;5243       else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  2802              CMP      r0,#2
00003e  d02f              BEQ      |L57.160|
000040  2d01              CMP      r5,#1
000042  d000              BEQ      |L57.70|
000044  bb1d              CBNZ     r5,|L57.142|
                  |L57.70|
;;;5244       {
;;;5245         /* Disable Acknowledge */
;;;5246         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000046  6820              LDR      r0,[r4,#0]
000048  6800              LDR      r0,[r0,#0]
00004a  f4206080          BIC      r0,r0,#0x400
00004e  6821              LDR      r1,[r4,#0]
000050  6008              STR      r0,[r1,#0]
;;;5247   
;;;5248         /* Disable EVT, BUF and ERR interrupt */
;;;5249         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000052  6820              LDR      r0,[r4,#0]
000054  6840              LDR      r0,[r0,#4]
000056  f42060e0          BIC      r0,r0,#0x700
00005a  6821              LDR      r1,[r4,#0]
00005c  6048              STR      r0,[r1,#4]
;;;5250   
;;;5251         /* Read data from DR */
;;;5252         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
00005e  6820              LDR      r0,[r4,#0]
000060  6900              LDR      r0,[r0,#0x10]
000062  6a61              LDR      r1,[r4,#0x24]
000064  7008              STRB     r0,[r1,#0]
;;;5253   
;;;5254         /* Increment Buffer pointer */
;;;5255         hi2c->pBuffPtr++;
000066  6a60              LDR      r0,[r4,#0x24]
000068  1c40              ADDS     r0,r0,#1
00006a  6260              STR      r0,[r4,#0x24]
;;;5256   
;;;5257         /* Update counter */
;;;5258         hi2c->XferCount--;
00006c  8d60              LDRH     r0,[r4,#0x2a]
00006e  1e40              SUBS     r0,r0,#1
000070  8560              STRH     r0,[r4,#0x2a]
;;;5259   
;;;5260         hi2c->State = HAL_I2C_STATE_READY;
000072  2020              MOVS     r0,#0x20
000074  f884003d          STRB     r0,[r4,#0x3d]
;;;5261   
;;;5262         if (hi2c->Mode == HAL_I2C_MODE_MEM)
000078  f894003e          LDRB     r0,[r4,#0x3e]
00007c  2840              CMP      r0,#0x40
00007e  d107              BNE      |L57.144|
;;;5263         {
;;;5264           hi2c->Mode = HAL_I2C_MODE_NONE;
000080  2000              MOVS     r0,#0
000082  f884003e          STRB     r0,[r4,#0x3e]
;;;5265           hi2c->PreviousState = I2C_STATE_NONE;
000086  6320              STR      r0,[r4,#0x30]
;;;5266   
;;;5267   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5268           hi2c->MemRxCpltCallback(hi2c);
;;;5269   #else
;;;5270           HAL_I2C_MemRxCpltCallback(hi2c);
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
                  |L57.142|
00008e  e007              B        |L57.160|
                  |L57.144|
;;;5271   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5272         }
;;;5273         else
;;;5274         {
;;;5275           hi2c->Mode = HAL_I2C_MODE_NONE;
000090  2000              MOVS     r0,#0
000092  f884003e          STRB     r0,[r4,#0x3e]
;;;5276           hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000096  2012              MOVS     r0,#0x12
000098  6320              STR      r0,[r4,#0x30]
;;;5277   
;;;5278   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5279           hi2c->MasterRxCpltCallback(hi2c);
;;;5280   #else
;;;5281           HAL_I2C_MasterRxCpltCallback(hi2c);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L57.160|
;;;5282   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5283         }
;;;5284       }
;;;5285       else
;;;5286       {
;;;5287         /* Do nothing */
;;;5288       }
;;;5289     }
0000a0  bf00              NOP      
                  |L57.162|
;;;5290   }
0000a2  bd70              POP      {r4-r6,pc}
;;;5291   
                          ENDP


                          AREA ||i.I2C_MasterRequestRead||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestRead PROC
;;;6284     */
;;;6285   static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6286   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;6287     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6288     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000c  6ae7              LDR      r7,[r4,#0x2c]
;;;6289   
;;;6290     /* Enable Acknowledge */
;;;6291     SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f4406080          ORR      r0,r0,#0x400
000016  6821              LDR      r1,[r4,#0]
000018  6008              STR      r0,[r1,#0]
;;;6292   
;;;6293     /* Generate Start condition if first transfer */
;;;6294     if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME)  || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
00001a  2f08              CMP      r7,#8
00001c  d004              BEQ      |L58.40|
00001e  2f01              CMP      r7,#1
000020  d002              BEQ      |L58.40|
000022  f5173f80          CMN      r7,#0x10000
000026  d106              BNE      |L58.54|
                  |L58.40|
;;;6295     {
;;;6296       /* Generate Start */
;;;6297       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f4407080          ORR      r0,r0,#0x100
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
000034  e008              B        |L58.72|
                  |L58.54|
;;;6298     }
;;;6299     else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
000036  6b20              LDR      r0,[r4,#0x30]
000038  2811              CMP      r0,#0x11
00003a  d105              BNE      |L58.72|
;;;6300     {
;;;6301       /* Generate ReStart */
;;;6302       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00003c  6820              LDR      r0,[r4,#0]
00003e  6800              LDR      r0,[r0,#0]
000040  f4407080          ORR      r0,r0,#0x100
000044  6821              LDR      r1,[r4,#0]
000046  6008              STR      r0,[r1,#0]
                  |L58.72|
;;;6303     }
;;;6304     else
;;;6305     {
;;;6306       /* Do nothing */
;;;6307     }
;;;6308   
;;;6309     /* Wait until SB flag is set */
;;;6310     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000048  4643              MOV      r3,r8
00004a  2200              MOVS     r2,#0
00004c  f04f1101          MOV      r1,#0x10001
000050  4620              MOV      r0,r4
000052  9600              STR      r6,[sp,#0]
000054  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000058  b110              CBZ      r0,|L58.96|
;;;6311     {
;;;6312       return HAL_ERROR;
00005a  2001              MOVS     r0,#1
                  |L58.92|
;;;6313     }
;;;6314   
;;;6315     if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;6316     {
;;;6317       /* Send slave address */
;;;6318       hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;6319     }
;;;6320     else
;;;6321     {
;;;6322       /* Send header of slave address */
;;;6323       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;6324   
;;;6325       /* Wait until ADD10 flag is set */
;;;6326       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
;;;6327       {
;;;6328         return HAL_ERROR;
;;;6329       }
;;;6330   
;;;6331       /* Send slave address */
;;;6332       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;6333   
;;;6334       /* Wait until ADDR flag is set */
;;;6335       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6336       {
;;;6337         return HAL_ERROR;
;;;6338       }
;;;6339   
;;;6340       /* Clear ADDR flag */
;;;6341       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6342   
;;;6343       /* Generate Restart */
;;;6344       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;6345   
;;;6346       /* Wait until SB flag is set */
;;;6347       if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
;;;6348       {
;;;6349         return HAL_ERROR;
;;;6350       }
;;;6351   
;;;6352       /* Send header of slave address */
;;;6353       hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
;;;6354     }
;;;6355   
;;;6356     /* Wait until ADDR flag is set */
;;;6357     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6358     {
;;;6359       return HAL_ERROR;
;;;6360     }
;;;6361   
;;;6362     return HAL_OK;
;;;6363   }
00005c  e8bd83f8          POP      {r3-r9,pc}
                  |L58.96|
000060  6920              LDR      r0,[r4,#0x10]         ;6315
000062  f5b04f80          CMP      r0,#0x4000            ;6315
000066  d105              BNE      |L58.116|
000068  b2e8              UXTB     r0,r5                 ;6318
00006a  f0400001          ORR      r0,r0,#1              ;6318
00006e  6821              LDR      r1,[r4,#0]            ;6318
000070  6108              STR      r0,[r1,#0x10]         ;6318
000072  e03f              B        |L58.244|
                  |L58.116|
000074  f4057040          AND      r0,r5,#0x300          ;6323
000078  21f0              MOVS     r1,#0xf0              ;6323
00007a  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6323
00007e  6821              LDR      r1,[r4,#0]            ;6323
000080  6108              STR      r0,[r1,#0x10]         ;6323
000082  4633              MOV      r3,r6                 ;6326
000084  4642              MOV      r2,r8                 ;6326
000086  4921              LDR      r1,|L58.268|
000088  4620              MOV      r0,r4                 ;6326
00008a  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00008e  b108              CBZ      r0,|L58.148|
000090  2001              MOVS     r0,#1                 ;6328
000092  e7e3              B        |L58.92|
                  |L58.148|
000094  b2e8              UXTB     r0,r5                 ;6332
000096  6821              LDR      r1,[r4,#0]            ;6332
000098  6108              STR      r0,[r1,#0x10]         ;6332
00009a  4633              MOV      r3,r6                 ;6335
00009c  4642              MOV      r2,r8                 ;6335
00009e  491b              LDR      r1,|L58.268|
0000a0  1f89              SUBS     r1,r1,#6              ;6335
0000a2  4620              MOV      r0,r4                 ;6335
0000a4  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000a8  b108              CBZ      r0,|L58.174|
0000aa  2001              MOVS     r0,#1                 ;6337
0000ac  e7d6              B        |L58.92|
                  |L58.174|
0000ae  bf00              NOP                            ;6341
0000b0  2000              MOVS     r0,#0                 ;6341
0000b2  9000              STR      r0,[sp,#0]            ;6341
0000b4  6820              LDR      r0,[r4,#0]            ;6341
0000b6  6940              LDR      r0,[r0,#0x14]         ;6341
0000b8  9000              STR      r0,[sp,#0]            ;6341
0000ba  6820              LDR      r0,[r4,#0]            ;6341
0000bc  6980              LDR      r0,[r0,#0x18]         ;6341
0000be  9000              STR      r0,[sp,#0]            ;6341
0000c0  bf00              NOP                            ;6341
0000c2  bf00              NOP                            ;6341
0000c4  6820              LDR      r0,[r4,#0]            ;6344
0000c6  6800              LDR      r0,[r0,#0]            ;6344
0000c8  f4407080          ORR      r0,r0,#0x100          ;6344
0000cc  6821              LDR      r1,[r4,#0]            ;6344
0000ce  6008              STR      r0,[r1,#0]            ;6344
0000d0  4643              MOV      r3,r8                 ;6347
0000d2  2200              MOVS     r2,#0                 ;6347
0000d4  f04f1101          MOV      r1,#0x10001           ;6347
0000d8  4620              MOV      r0,r4                 ;6347
0000da  9600              STR      r6,[sp,#0]            ;6347
0000dc  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000e0  b108              CBZ      r0,|L58.230|
0000e2  2001              MOVS     r0,#1                 ;6349
0000e4  e7ba              B        |L58.92|
                  |L58.230|
0000e6  f4057040          AND      r0,r5,#0x300          ;6353
0000ea  21f1              MOVS     r1,#0xf1              ;6353
0000ec  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6353
0000f0  6821              LDR      r1,[r4,#0]            ;6353
0000f2  6108              STR      r0,[r1,#0x10]         ;6353
                  |L58.244|
0000f4  4633              MOV      r3,r6                 ;6357
0000f6  4642              MOV      r2,r8                 ;6357
0000f8  4904              LDR      r1,|L58.268|
0000fa  1f89              SUBS     r1,r1,#6              ;6357
0000fc  4620              MOV      r0,r4                 ;6357
0000fe  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000102  b108              CBZ      r0,|L58.264|
000104  2001              MOVS     r0,#1                 ;6359
000106  e7a9              B        |L58.92|
                  |L58.264|
000108  2000              MOVS     r0,#0                 ;6362
00010a  e7a7              B        |L58.92|
;;;6364   
                          ENDP

                  |L58.268|
                          DCD      0x00010008

                          AREA ||i.I2C_MasterRequestWrite||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestWrite PROC
;;;6218     */
;;;6219   static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6220   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;6221     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;6222     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000c  6ae6              LDR      r6,[r4,#0x2c]
;;;6223   
;;;6224     /* Generate Start condition if first transfer */
;;;6225     if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
00000e  2e08              CMP      r6,#8
000010  d004              BEQ      |L59.28|
000012  2e01              CMP      r6,#1
000014  d002              BEQ      |L59.28|
000016  f5163f80          CMN      r6,#0x10000
00001a  d106              BNE      |L59.42|
                  |L59.28|
;;;6226     {
;;;6227       /* Generate Start */
;;;6228       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f4407080          ORR      r0,r0,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  6008              STR      r0,[r1,#0]
000028  e008              B        |L59.60|
                  |L59.42|
;;;6229     }
;;;6230     else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  2812              CMP      r0,#0x12
00002e  d105              BNE      |L59.60|
;;;6231     {
;;;6232       /* Generate ReStart */
;;;6233       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000030  6820              LDR      r0,[r4,#0]
000032  6800              LDR      r0,[r0,#0]
000034  f4407080          ORR      r0,r0,#0x100
000038  6821              LDR      r1,[r4,#0]
00003a  6008              STR      r0,[r1,#0]
                  |L59.60|
;;;6234     }
;;;6235     else
;;;6236     {
;;;6237       /* Do nothing */
;;;6238     }
;;;6239   
;;;6240     /* Wait until SB flag is set */
;;;6241     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
00003c  463b              MOV      r3,r7
00003e  2200              MOVS     r2,#0
000040  f04f1101          MOV      r1,#0x10001
000044  4620              MOV      r0,r4
000046  f8cd8000          STR      r8,[sp,#0]
00004a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00004e  b110              CBZ      r0,|L59.86|
;;;6242     {
;;;6243       return HAL_ERROR;
000050  2001              MOVS     r0,#1
                  |L59.82|
;;;6244     }
;;;6245   
;;;6246     if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;6247     {
;;;6248       /* Send slave address */
;;;6249       hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6250     }
;;;6251     else
;;;6252     {
;;;6253       /* Send header of slave address */
;;;6254       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;6255   
;;;6256       /* Wait until ADD10 flag is set */
;;;6257       if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
;;;6258       {
;;;6259         return HAL_ERROR;
;;;6260       }
;;;6261   
;;;6262       /* Send slave address */
;;;6263       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;6264     }
;;;6265   
;;;6266     /* Wait until ADDR flag is set */
;;;6267     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6268     {
;;;6269       return HAL_ERROR;
;;;6270     }
;;;6271   
;;;6272     return HAL_OK;
;;;6273   }
000052  e8bd83f8          POP      {r3-r9,pc}
                  |L59.86|
000056  6920              LDR      r0,[r4,#0x10]         ;6246
000058  f5b04f80          CMP      r0,#0x4000            ;6246
00005c  d104              BNE      |L59.104|
00005e  f00500fe          AND      r0,r5,#0xfe           ;6249
000062  6821              LDR      r1,[r4,#0]            ;6249
000064  6108              STR      r0,[r1,#0x10]         ;6249
000066  e012              B        |L59.142|
                  |L59.104|
000068  f4057040          AND      r0,r5,#0x300          ;6254
00006c  21f0              MOVS     r1,#0xf0              ;6254
00006e  ea4110e0          ORR      r0,r1,r0,ASR #7       ;6254
000072  6821              LDR      r1,[r4,#0]            ;6254
000074  6108              STR      r0,[r1,#0x10]         ;6254
000076  4643              MOV      r3,r8                 ;6257
000078  463a              MOV      r2,r7                 ;6257
00007a  490b              LDR      r1,|L59.168|
00007c  4620              MOV      r0,r4                 ;6257
00007e  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000082  b108              CBZ      r0,|L59.136|
000084  2001              MOVS     r0,#1                 ;6259
000086  e7e4              B        |L59.82|
                  |L59.136|
000088  b2e8              UXTB     r0,r5                 ;6263
00008a  6821              LDR      r1,[r4,#0]            ;6263
00008c  6108              STR      r0,[r1,#0x10]         ;6263
                  |L59.142|
00008e  4643              MOV      r3,r8                 ;6267
000090  463a              MOV      r2,r7                 ;6267
000092  4905              LDR      r1,|L59.168|
000094  1f89              SUBS     r1,r1,#6              ;6267
000096  4620              MOV      r0,r4                 ;6267
000098  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00009c  b108              CBZ      r0,|L59.162|
00009e  2001              MOVS     r0,#1                 ;6269
0000a0  e7d7              B        |L59.82|
                  |L59.162|
0000a2  2000              MOVS     r0,#0                 ;6272
0000a4  e7d5              B        |L59.82|
;;;6274   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L59.168|
                          DCD      0x00010008

                          AREA ||i.I2C_MasterTransmit_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransmit_BTF PROC
;;;5140     */
;;;5141   static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5142   {
000002  4604              MOV      r4,r0
;;;5143     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5144     uint32_t CurrentXferOptions = hi2c->XferOptions;
000004  6ae5              LDR      r5,[r4,#0x2c]
;;;5145   
;;;5146     if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2821              CMP      r0,#0x21
00000c  d147              BNE      |L60.158|
;;;5147     {
;;;5148       if (hi2c->XferCount != 0U)
00000e  8d60              LDRH     r0,[r4,#0x2a]
000010  b150              CBZ      r0,|L60.40|
;;;5149       {
;;;5150         /* Write data to DR */
;;;5151         hi2c->Instance->DR = *hi2c->pBuffPtr;
000012  6a60              LDR      r0,[r4,#0x24]
000014  7800              LDRB     r0,[r0,#0]
000016  6821              LDR      r1,[r4,#0]
000018  6108              STR      r0,[r1,#0x10]
;;;5152   
;;;5153         /* Increment Buffer pointer */
;;;5154         hi2c->pBuffPtr++;
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  1c40              ADDS     r0,r0,#1
00001e  6260              STR      r0,[r4,#0x24]
;;;5155   
;;;5156         /* Update counter */
;;;5157         hi2c->XferCount--;
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  1e40              SUBS     r0,r0,#1
000024  8560              STRH     r0,[r4,#0x2a]
000026  e03a              B        |L60.158|
                  |L60.40|
;;;5158       }
;;;5159       else
;;;5160       {
;;;5161         /* Call TxCpltCallback() directly if no stop mode is set */
;;;5162         if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
000028  2d08              CMP      r5,#8
00002a  d016              BEQ      |L60.90|
00002c  2d20              CMP      r5,#0x20
00002e  d014              BEQ      |L60.90|
000030  f5153f80          CMN      r5,#0x10000
000034  d011              BEQ      |L60.90|
;;;5163         {
;;;5164           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000036  6820              LDR      r0,[r4,#0]
000038  6840              LDR      r0,[r0,#4]
00003a  f42060e0          BIC      r0,r0,#0x700
00003e  6821              LDR      r1,[r4,#0]
000040  6048              STR      r0,[r1,#4]
;;;5165   
;;;5166           hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
000042  2011              MOVS     r0,#0x11
000044  6320              STR      r0,[r4,#0x30]
;;;5167           hi2c->Mode = HAL_I2C_MODE_NONE;
000046  2000              MOVS     r0,#0
000048  f884003e          STRB     r0,[r4,#0x3e]
;;;5168           hi2c->State = HAL_I2C_STATE_READY;
00004c  2020              MOVS     r0,#0x20
00004e  f884003d          STRB     r0,[r4,#0x3d]
;;;5169   
;;;5170   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5171           hi2c->MasterTxCpltCallback(hi2c);
;;;5172   #else
;;;5173           HAL_I2C_MasterTxCpltCallback(hi2c);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000058  e021              B        |L60.158|
                  |L60.90|
;;;5174   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5175         }
;;;5176         else /* Generate Stop condition then Call TxCpltCallback() */
;;;5177         {
;;;5178           /* Disable EVT, BUF and ERR interrupt */
;;;5179           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00005a  6820              LDR      r0,[r4,#0]
00005c  6840              LDR      r0,[r0,#4]
00005e  f42060e0          BIC      r0,r0,#0x700
000062  6821              LDR      r1,[r4,#0]
000064  6048              STR      r0,[r1,#4]
;;;5180   
;;;5181           /* Generate Stop */
;;;5182           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f4407000          ORR      r0,r0,#0x200
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
;;;5183   
;;;5184           hi2c->PreviousState = I2C_STATE_NONE;
000072  2000              MOVS     r0,#0
000074  6320              STR      r0,[r4,#0x30]
;;;5185           hi2c->State = HAL_I2C_STATE_READY;
000076  2020              MOVS     r0,#0x20
000078  f884003d          STRB     r0,[r4,#0x3d]
;;;5186   
;;;5187           if (hi2c->Mode == HAL_I2C_MODE_MEM)
00007c  f894003e          LDRB     r0,[r4,#0x3e]
000080  2840              CMP      r0,#0x40
000082  d106              BNE      |L60.146|
;;;5188           {
;;;5189             hi2c->Mode = HAL_I2C_MODE_NONE;
000084  2000              MOVS     r0,#0
000086  f884003e          STRB     r0,[r4,#0x3e]
;;;5190   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5191             hi2c->MemTxCpltCallback(hi2c);
;;;5192   #else
;;;5193             HAL_I2C_MemTxCpltCallback(hi2c);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
000090  e005              B        |L60.158|
                  |L60.146|
;;;5194   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5195           }
;;;5196           else
;;;5197           {
;;;5198             hi2c->Mode = HAL_I2C_MODE_NONE;
000092  2000              MOVS     r0,#0
000094  f884003e          STRB     r0,[r4,#0x3e]
;;;5199   
;;;5200   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5201             hi2c->MasterTxCpltCallback(hi2c);
;;;5202   #else
;;;5203             HAL_I2C_MasterTxCpltCallback(hi2c);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
                  |L60.158|
;;;5204   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5205           }
;;;5206         }
;;;5207       }
;;;5208     }
;;;5209   }
00009e  bd70              POP      {r4-r6,pc}
;;;5210   
                          ENDP


                          AREA ||i.I2C_MasterTransmit_TXE||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransmit_TXE PROC
;;;4994     */
;;;4995   static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4996   {
000004  4604              MOV      r4,r0
;;;4997     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;4998     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000006  f894503d          LDRB     r5,[r4,#0x3d]
;;;4999     HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
00000a  f894703e          LDRB     r7,[r4,#0x3e]
;;;5000     uint32_t CurrentXferOptions       = hi2c->XferOptions;
00000e  6ae6              LDR      r6,[r4,#0x2c]
;;;5001   
;;;5002     if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
000010  8d20              LDRH     r0,[r4,#0x28]
000012  bbb0              CBNZ     r0,|L61.130|
000014  2d21              CMP      r5,#0x21
000016  d13c              BNE      |L61.146|
;;;5003     {
;;;5004       /* Call TxCpltCallback() directly if no stop mode is set */
;;;5005       if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
000018  2e08              CMP      r6,#8
00001a  d016              BEQ      |L61.74|
00001c  2e20              CMP      r6,#0x20
00001e  d014              BEQ      |L61.74|
000020  f5163f80          CMN      r6,#0x10000
000024  d011              BEQ      |L61.74|
;;;5006       {
;;;5007         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000026  6820              LDR      r0,[r4,#0]
000028  6840              LDR      r0,[r0,#4]
00002a  f42060e0          BIC      r0,r0,#0x700
00002e  6821              LDR      r1,[r4,#0]
000030  6048              STR      r0,[r1,#4]
;;;5008   
;;;5009         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
000032  2011              MOVS     r0,#0x11
000034  6320              STR      r0,[r4,#0x30]
;;;5010         hi2c->Mode = HAL_I2C_MODE_NONE;
000036  2000              MOVS     r0,#0
000038  f884003e          STRB     r0,[r4,#0x3e]
;;;5011         hi2c->State = HAL_I2C_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;5012   
;;;5013   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5014         hi2c->MasterTxCpltCallback(hi2c);
;;;5015   #else
;;;5016         HAL_I2C_MasterTxCpltCallback(hi2c);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000048  e07e              B        |L61.328|
                  |L61.74|
;;;5017   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5018       }
;;;5019       else /* Generate Stop condition then Call TxCpltCallback() */
;;;5020       {
;;;5021         /* Disable EVT, BUF and ERR interrupt */
;;;5022         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00004a  6820              LDR      r0,[r4,#0]
00004c  6840              LDR      r0,[r0,#4]
00004e  f42060e0          BIC      r0,r0,#0x700
000052  6821              LDR      r1,[r4,#0]
000054  6048              STR      r0,[r1,#4]
;;;5023   
;;;5024         /* Generate Stop */
;;;5025         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f4407000          ORR      r0,r0,#0x200
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
;;;5026   
;;;5027         hi2c->PreviousState = I2C_STATE_NONE;
000062  2000              MOVS     r0,#0
000064  6320              STR      r0,[r4,#0x30]
;;;5028         hi2c->State = HAL_I2C_STATE_READY;
000066  2020              MOVS     r0,#0x20
000068  f884003d          STRB     r0,[r4,#0x3d]
;;;5029   
;;;5030         if (hi2c->Mode == HAL_I2C_MODE_MEM)
00006c  f894003e          LDRB     r0,[r4,#0x3e]
000070  2840              CMP      r0,#0x40
000072  d107              BNE      |L61.132|
;;;5031         {
;;;5032           hi2c->Mode = HAL_I2C_MODE_NONE;
000074  2000              MOVS     r0,#0
000076  f884003e          STRB     r0,[r4,#0x3e]
;;;5033   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5034           hi2c->MemTxCpltCallback(hi2c);
;;;5035   #else
;;;5036           HAL_I2C_MemTxCpltCallback(hi2c);
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
000080  e062              B        |L61.328|
                  |L61.130|
000082  e006              B        |L61.146|
                  |L61.132|
;;;5037   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5038         }
;;;5039         else
;;;5040         {
;;;5041           hi2c->Mode = HAL_I2C_MODE_NONE;
000084  2000              MOVS     r0,#0
000086  f884003e          STRB     r0,[r4,#0x3e]
;;;5042   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5043           hi2c->MasterTxCpltCallback(hi2c);
;;;5044   #else
;;;5045           HAL_I2C_MasterTxCpltCallback(hi2c);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000090  e05a              B        |L61.328|
                  |L61.146|
;;;5046   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5047         }
;;;5048       }
;;;5049     }
;;;5050     else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
000092  2d21              CMP      r5,#0x21
000094  d003              BEQ      |L61.158|
;;;5051              ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
000096  2f40              CMP      r7,#0x40
000098  d156              BNE      |L61.328|
00009a  2d22              CMP      r5,#0x22
00009c  d154              BNE      |L61.328|
                  |L61.158|
;;;5052     {
;;;5053       if (hi2c->XferCount == 0U)
00009e  8d60              LDRH     r0,[r4,#0x2a]
0000a0  b930              CBNZ     r0,|L61.176|
;;;5054       {
;;;5055         /* Disable BUF interrupt */
;;;5056         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6840              LDR      r0,[r0,#4]
0000a6  f4206080          BIC      r0,r0,#0x400
0000aa  6821              LDR      r1,[r4,#0]
0000ac  6048              STR      r0,[r1,#4]
0000ae  e04b              B        |L61.328|
                  |L61.176|
;;;5057       }
;;;5058       else
;;;5059       {
;;;5060         if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000b0  f894003e          LDRB     r0,[r4,#0x3e]
0000b4  2840              CMP      r0,#0x40
0000b6  d13d              BNE      |L61.308|
;;;5061         {
;;;5062           if (hi2c->EventCount == 0U)
0000b8  6d20              LDR      r0,[r4,#0x50]
0000ba  b998              CBNZ     r0,|L61.228|
;;;5063           {
;;;5064             /* If Memory address size is 8Bit */
;;;5065             if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
0000bc  6ce0              LDR      r0,[r4,#0x4c]
0000be  2801              CMP      r0,#1
0000c0  d107              BNE      |L61.210|
;;;5066             {
;;;5067               /* Send Memory Address */
;;;5068               hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
0000c2  6ca0              LDR      r0,[r4,#0x48]
0000c4  b2c0              UXTB     r0,r0
0000c6  6821              LDR      r1,[r4,#0]
0000c8  6108              STR      r0,[r1,#0x10]
;;;5069   
;;;5070               hi2c->EventCount += 2U;
0000ca  6d20              LDR      r0,[r4,#0x50]
0000cc  1c80              ADDS     r0,r0,#2
0000ce  6520              STR      r0,[r4,#0x50]
0000d0  e03a              B        |L61.328|
                  |L61.210|
;;;5071             }
;;;5072             /* If Memory address size is 16Bit */
;;;5073             else
;;;5074             {
;;;5075               /* Send MSB of Memory Address */
;;;5076               hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
0000d2  6ca0              LDR      r0,[r4,#0x48]
0000d4  f3c02007          UBFX     r0,r0,#8,#8
0000d8  6821              LDR      r1,[r4,#0]
0000da  6108              STR      r0,[r1,#0x10]
;;;5077   
;;;5078               hi2c->EventCount++;
0000dc  6d20              LDR      r0,[r4,#0x50]
0000de  1c40              ADDS     r0,r0,#1
0000e0  6520              STR      r0,[r4,#0x50]
0000e2  e031              B        |L61.328|
                  |L61.228|
;;;5079             }
;;;5080           }
;;;5081           else if (hi2c->EventCount == 1U)
0000e4  6d20              LDR      r0,[r4,#0x50]
0000e6  2801              CMP      r0,#1
0000e8  d107              BNE      |L61.250|
;;;5082           {
;;;5083             /* Send LSB of Memory Address */
;;;5084             hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
0000ea  6ca0              LDR      r0,[r4,#0x48]
0000ec  b2c0              UXTB     r0,r0
0000ee  6821              LDR      r1,[r4,#0]
0000f0  6108              STR      r0,[r1,#0x10]
;;;5085   
;;;5086             hi2c->EventCount++;
0000f2  6d20              LDR      r0,[r4,#0x50]
0000f4  1c40              ADDS     r0,r0,#1
0000f6  6520              STR      r0,[r4,#0x50]
0000f8  e026              B        |L61.328|
                  |L61.250|
;;;5087           }
;;;5088           else if (hi2c->EventCount == 2U)
0000fa  6d20              LDR      r0,[r4,#0x50]
0000fc  2802              CMP      r0,#2
0000fe  d123              BNE      |L61.328|
;;;5089           {
;;;5090             if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
000100  f894003d          LDRB     r0,[r4,#0x3d]
000104  2822              CMP      r0,#0x22
000106  d106              BNE      |L61.278|
;;;5091             {
;;;5092               /* Generate Restart */
;;;5093               hi2c->Instance->CR1 |= I2C_CR1_START;
000108  6820              LDR      r0,[r4,#0]
00010a  6800              LDR      r0,[r0,#0]
00010c  f4407080          ORR      r0,r0,#0x100
000110  6821              LDR      r1,[r4,#0]
000112  6008              STR      r0,[r1,#0]
000114  e018              B        |L61.328|
                  |L61.278|
;;;5094             }
;;;5095             else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
000116  f894003d          LDRB     r0,[r4,#0x3d]
00011a  2821              CMP      r0,#0x21
00011c  d114              BNE      |L61.328|
;;;5096             {
;;;5097               /* Write data to DR */
;;;5098               hi2c->Instance->DR = *hi2c->pBuffPtr;
00011e  6a60              LDR      r0,[r4,#0x24]
000120  7800              LDRB     r0,[r0,#0]
000122  6821              LDR      r1,[r4,#0]
000124  6108              STR      r0,[r1,#0x10]
;;;5099   
;;;5100               /* Increment Buffer pointer */
;;;5101               hi2c->pBuffPtr++;
000126  6a60              LDR      r0,[r4,#0x24]
000128  1c40              ADDS     r0,r0,#1
00012a  6260              STR      r0,[r4,#0x24]
;;;5102   
;;;5103               /* Update counter */
;;;5104               hi2c->XferCount--;
00012c  8d60              LDRH     r0,[r4,#0x2a]
00012e  1e40              SUBS     r0,r0,#1
000130  8560              STRH     r0,[r4,#0x2a]
000132  e009              B        |L61.328|
                  |L61.308|
;;;5105             }
;;;5106             else
;;;5107             {
;;;5108               /* Do nothing */
;;;5109             }
;;;5110           }
;;;5111           else
;;;5112           {
;;;5113             /* Do nothing */
;;;5114           }
;;;5115         }
;;;5116         else
;;;5117         {
;;;5118           /* Write data to DR */
;;;5119           hi2c->Instance->DR = *hi2c->pBuffPtr;
000134  6a60              LDR      r0,[r4,#0x24]
000136  7800              LDRB     r0,[r0,#0]
000138  6821              LDR      r1,[r4,#0]
00013a  6108              STR      r0,[r1,#0x10]
;;;5120   
;;;5121           /* Increment Buffer pointer */
;;;5122           hi2c->pBuffPtr++;
00013c  6a60              LDR      r0,[r4,#0x24]
00013e  1c40              ADDS     r0,r0,#1
000140  6260              STR      r0,[r4,#0x24]
;;;5123   
;;;5124           /* Update counter */
;;;5125           hi2c->XferCount--;
000142  8d60              LDRH     r0,[r4,#0x2a]
000144  1e40              SUBS     r0,r0,#1
000146  8560              STRH     r0,[r4,#0x2a]
                  |L61.328|
;;;5126         }
;;;5127       }
;;;5128     }
;;;5129     else
;;;5130     {
;;;5131       /* Do nothing */
;;;5132     }
;;;5133   }
000148  e8bd81f0          POP      {r4-r8,pc}
;;;5134   
                          ENDP


                          AREA ||i.I2C_Master_ADD10||, CODE, READONLY, ALIGN=1

                  I2C_Master_ADD10 PROC
;;;5486     */
;;;5487   static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
000000  6c41              LDR      r1,[r0,#0x44]
;;;5488   {
;;;5489     /* Send slave address */
;;;5490     hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
000002  b2c9              UXTB     r1,r1
000004  6802              LDR      r2,[r0,#0]
000006  6111              STR      r1,[r2,#0x10]
;;;5491   
;;;5492     if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
000008  6b41              LDR      r1,[r0,#0x34]
00000a  b909              CBNZ     r1,|L62.16|
00000c  6b81              LDR      r1,[r0,#0x38]
00000e  b159              CBZ      r1,|L62.40|
                  |L62.16|
;;;5493     {
;;;5494       if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
000010  6b41              LDR      r1,[r0,#0x34]
000012  6bc9              LDR      r1,[r1,#0x3c]
000014  b911              CBNZ     r1,|L62.28|
000016  6b81              LDR      r1,[r0,#0x38]
000018  6bc9              LDR      r1,[r1,#0x3c]
00001a  b129              CBZ      r1,|L62.40|
                  |L62.28|
;;;5495       {
;;;5496         /* Enable DMA Request */
;;;5497         SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
00001c  6801              LDR      r1,[r0,#0]
00001e  6849              LDR      r1,[r1,#4]
000020  f4416100          ORR      r1,r1,#0x800
000024  6802              LDR      r2,[r0,#0]
000026  6051              STR      r1,[r2,#4]
                  |L62.40|
;;;5498       }
;;;5499     }
;;;5500   }
000028  4770              BX       lr
;;;5501   
                          ENDP


                          AREA ||i.I2C_Master_ADDR||, CODE, READONLY, ALIGN=1

                  I2C_Master_ADDR PROC
;;;5507     */
;;;5508   static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
000000  b538              PUSH     {r3-r5,lr}
;;;5509   {
;;;5510     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;5511     HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
000002  f890203e          LDRB     r2,[r0,#0x3e]
;;;5512     uint32_t CurrentXferOptions           = hi2c->XferOptions;
000006  6ac1              LDR      r1,[r0,#0x2c]
;;;5513     uint32_t Prev_State                   = hi2c->PreviousState;
000008  6b03              LDR      r3,[r0,#0x30]
;;;5514   
;;;5515     if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
00000a  f890403d          LDRB     r4,[r0,#0x3d]
00000e  2c22              CMP      r4,#0x22
000010  d173              BNE      |L63.250|
;;;5516     {
;;;5517       if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
000012  6d04              LDR      r4,[r0,#0x50]
000014  b964              CBNZ     r4,|L63.48|
000016  2a40              CMP      r2,#0x40
000018  d10a              BNE      |L63.48|
;;;5518       {
;;;5519         /* Clear ADDR flag */
;;;5520         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00001a  bf00              NOP      
00001c  2400              MOVS     r4,#0
00001e  9400              STR      r4,[sp,#0]
000020  6804              LDR      r4,[r0,#0]
000022  6964              LDR      r4,[r4,#0x14]
000024  9400              STR      r4,[sp,#0]
000026  6804              LDR      r4,[r0,#0]
000028  69a4              LDR      r4,[r4,#0x18]
00002a  9400              STR      r4,[sp,#0]
00002c  bf00              NOP      
00002e  e11a              B        |L63.614|
                  |L63.48|
;;;5521       }
;;;5522       else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
000030  6d04              LDR      r4,[r0,#0x50]
000032  b9c4              CBNZ     r4,|L63.102|
000034  6904              LDR      r4,[r0,#0x10]
000036  f5b44f40          CMP      r4,#0xc000
00003a  d114              BNE      |L63.102|
;;;5523       {
;;;5524         /* Clear ADDR flag */
;;;5525         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00003c  bf00              NOP      
00003e  2400              MOVS     r4,#0
000040  9400              STR      r4,[sp,#0]
000042  6804              LDR      r4,[r0,#0]
000044  6964              LDR      r4,[r4,#0x14]
000046  9400              STR      r4,[sp,#0]
000048  6804              LDR      r4,[r0,#0]
00004a  69a4              LDR      r4,[r4,#0x18]
00004c  9400              STR      r4,[sp,#0]
00004e  bf00              NOP      
000050  bf00              NOP      
;;;5526   
;;;5527         /* Generate Restart */
;;;5528         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000052  6804              LDR      r4,[r0,#0]
000054  6824              LDR      r4,[r4,#0]
000056  f4447480          ORR      r4,r4,#0x100
00005a  6805              LDR      r5,[r0,#0]
00005c  602c              STR      r4,[r5,#0]
;;;5529   
;;;5530         hi2c->EventCount++;
00005e  6d04              LDR      r4,[r0,#0x50]
000060  1c64              ADDS     r4,r4,#1
000062  6504              STR      r4,[r0,#0x50]
000064  e0ff              B        |L63.614|
                  |L63.102|
;;;5531       }
;;;5532       else
;;;5533       {
;;;5534         if (hi2c->XferCount == 0U)
000066  8d44              LDRH     r4,[r0,#0x2a]
000068  b98c              CBNZ     r4,|L63.142|
;;;5535         {
;;;5536           /* Clear ADDR flag */
;;;5537           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00006a  bf00              NOP      
00006c  2400              MOVS     r4,#0
00006e  9400              STR      r4,[sp,#0]
000070  6804              LDR      r4,[r0,#0]
000072  6964              LDR      r4,[r4,#0x14]
000074  9400              STR      r4,[sp,#0]
000076  6804              LDR      r4,[r0,#0]
000078  69a4              LDR      r4,[r4,#0x18]
00007a  9400              STR      r4,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
;;;5538   
;;;5539           /* Generate Stop */
;;;5540           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000080  6804              LDR      r4,[r0,#0]
000082  6824              LDR      r4,[r4,#0]
000084  f4447400          ORR      r4,r4,#0x200
000088  6805              LDR      r5,[r0,#0]
00008a  602c              STR      r4,[r5,#0]
00008c  e0dd              B        |L63.586|
                  |L63.142|
;;;5541         }
;;;5542         else if (hi2c->XferCount == 1U)
00008e  8d44              LDRH     r4,[r0,#0x2a]
000090  2c01              CMP      r4,#1
000092  d172              BNE      |L63.378|
;;;5543         {
;;;5544           if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
000094  f5113f80          CMN      r1,#0x10000
000098  d130              BNE      |L63.252|
;;;5545           {
;;;5546             /* Disable Acknowledge */
;;;5547             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00009a  6804              LDR      r4,[r0,#0]
00009c  6824              LDR      r4,[r4,#0]
00009e  f4246480          BIC      r4,r4,#0x400
0000a2  6805              LDR      r5,[r0,#0]
0000a4  602c              STR      r4,[r5,#0]
;;;5548   
;;;5549             if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
0000a6  6804              LDR      r4,[r0,#0]
0000a8  6864              LDR      r4,[r4,#4]
0000aa  f4046400          AND      r4,r4,#0x800
0000ae  f5b46f00          CMP      r4,#0x800
0000b2  d110              BNE      |L63.214|
;;;5550             {
;;;5551               /* Disable Acknowledge */
;;;5552               CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0000b4  6804              LDR      r4,[r0,#0]
0000b6  6824              LDR      r4,[r4,#0]
0000b8  f4246480          BIC      r4,r4,#0x400
0000bc  6805              LDR      r5,[r0,#0]
0000be  602c              STR      r4,[r5,#0]
;;;5553   
;;;5554               /* Clear ADDR flag */
;;;5555               __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0000c0  bf00              NOP      
0000c2  2400              MOVS     r4,#0
0000c4  9400              STR      r4,[sp,#0]
0000c6  6804              LDR      r4,[r0,#0]
0000c8  6964              LDR      r4,[r4,#0x14]
0000ca  9400              STR      r4,[sp,#0]
0000cc  6804              LDR      r4,[r0,#0]
0000ce  69a4              LDR      r4,[r4,#0x18]
0000d0  9400              STR      r4,[sp,#0]
0000d2  bf00              NOP      
0000d4  e0b9              B        |L63.586|
                  |L63.214|
;;;5556             }
;;;5557             else
;;;5558             {
;;;5559               /* Clear ADDR flag */
;;;5560               __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0000d6  bf00              NOP      
0000d8  2400              MOVS     r4,#0
0000da  9400              STR      r4,[sp,#0]
0000dc  6804              LDR      r4,[r0,#0]
0000de  6964              LDR      r4,[r4,#0x14]
0000e0  9400              STR      r4,[sp,#0]
0000e2  6804              LDR      r4,[r0,#0]
0000e4  69a4              LDR      r4,[r4,#0x18]
0000e6  9400              STR      r4,[sp,#0]
0000e8  bf00              NOP      
0000ea  bf00              NOP      
;;;5561   
;;;5562               /* Generate Stop */
;;;5563               SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000ec  6804              LDR      r4,[r0,#0]
0000ee  6824              LDR      r4,[r4,#0]
0000f0  f4447400          ORR      r4,r4,#0x200
0000f4  6805              LDR      r5,[r0,#0]
0000f6  602c              STR      r4,[r5,#0]
0000f8  e0a7              B        |L63.586|
                  |L63.250|
0000fa  e0a9              B        |L63.592|
                  |L63.252|
;;;5564             }
;;;5565           }
;;;5566           /* Prepare next transfer or stop current transfer */
;;;5567           else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
0000fc  2908              CMP      r1,#8
0000fe  d023              BEQ      |L63.328|
000100  2920              CMP      r1,#0x20
000102  d021              BEQ      |L63.328|
;;;5568                    && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
000104  2b12              CMP      r3,#0x12
000106  d101              BNE      |L63.268|
000108  2901              CMP      r1,#1
00010a  d11d              BNE      |L63.328|
                  |L63.268|
;;;5569           {
;;;5570             if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
00010c  2904              CMP      r1,#4
00010e  d00a              BEQ      |L63.294|
000110  2902              CMP      r1,#2
000112  d008              BEQ      |L63.294|
000114  2910              CMP      r1,#0x10
000116  d006              BEQ      |L63.294|
;;;5571             {
;;;5572               /* Disable Acknowledge */
;;;5573               CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000118  6804              LDR      r4,[r0,#0]
00011a  6824              LDR      r4,[r4,#0]
00011c  f4246480          BIC      r4,r4,#0x400
000120  6805              LDR      r5,[r0,#0]
000122  602c              STR      r4,[r5,#0]
000124  e005              B        |L63.306|
                  |L63.294|
;;;5574             }
;;;5575             else
;;;5576             {
;;;5577               /* Enable Acknowledge */
;;;5578               SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000126  6804              LDR      r4,[r0,#0]
000128  6824              LDR      r4,[r4,#0]
00012a  f4446480          ORR      r4,r4,#0x400
00012e  6805              LDR      r5,[r0,#0]
000130  602c              STR      r4,[r5,#0]
                  |L63.306|
;;;5579             }
;;;5580   
;;;5581             /* Clear ADDR flag */
;;;5582             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000132  bf00              NOP      
000134  2400              MOVS     r4,#0
000136  9400              STR      r4,[sp,#0]
000138  6804              LDR      r4,[r0,#0]
00013a  6964              LDR      r4,[r4,#0x14]
00013c  9400              STR      r4,[sp,#0]
00013e  6804              LDR      r4,[r0,#0]
000140  69a4              LDR      r4,[r4,#0x18]
000142  9400              STR      r4,[sp,#0]
000144  bf00              NOP      
000146  e080              B        |L63.586|
                  |L63.328|
;;;5583           }
;;;5584           else
;;;5585           {
;;;5586             /* Disable Acknowledge */
;;;5587             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000148  6804              LDR      r4,[r0,#0]
00014a  6824              LDR      r4,[r4,#0]
00014c  f4246480          BIC      r4,r4,#0x400
000150  6805              LDR      r5,[r0,#0]
000152  602c              STR      r4,[r5,#0]
;;;5588   
;;;5589             /* Clear ADDR flag */
;;;5590             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000154  bf00              NOP      
000156  2400              MOVS     r4,#0
000158  9400              STR      r4,[sp,#0]
00015a  6804              LDR      r4,[r0,#0]
00015c  6964              LDR      r4,[r4,#0x14]
00015e  9400              STR      r4,[sp,#0]
000160  6804              LDR      r4,[r0,#0]
000162  69a4              LDR      r4,[r4,#0x18]
000164  9400              STR      r4,[sp,#0]
000166  bf00              NOP      
000168  bf00              NOP      
;;;5591   
;;;5592             /* Generate Stop */
;;;5593             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00016a  6804              LDR      r4,[r0,#0]
00016c  6824              LDR      r4,[r4,#0]
00016e  f4447400          ORR      r4,r4,#0x200
000172  6805              LDR      r5,[r0,#0]
000174  602c              STR      r4,[r5,#0]
000176  e068              B        |L63.586|
000178  e7ff              B        |L63.378|
                  |L63.378|
;;;5594           }
;;;5595         }
;;;5596         else if (hi2c->XferCount == 2U)
00017a  8d44              LDRH     r4,[r0,#0x2a]
00017c  2c02              CMP      r4,#2
00017e  d13b              BNE      |L63.504|
;;;5597         {
;;;5598           if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
000180  2904              CMP      r1,#4
000182  d010              BEQ      |L63.422|
000184  2902              CMP      r1,#2
000186  d00e              BEQ      |L63.422|
000188  2910              CMP      r1,#0x10
00018a  d00c              BEQ      |L63.422|
;;;5599           {
;;;5600             /* Disable Acknowledge */
;;;5601             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00018c  6804              LDR      r4,[r0,#0]
00018e  6824              LDR      r4,[r4,#0]
000190  f4246480          BIC      r4,r4,#0x400
000194  6805              LDR      r5,[r0,#0]
000196  602c              STR      r4,[r5,#0]
;;;5602   
;;;5603             /* Enable Pos */
;;;5604             SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000198  6804              LDR      r4,[r0,#0]
00019a  6824              LDR      r4,[r4,#0]
00019c  f4446400          ORR      r4,r4,#0x800
0001a0  6805              LDR      r5,[r0,#0]
0001a2  602c              STR      r4,[r5,#0]
0001a4  e005              B        |L63.434|
                  |L63.422|
;;;5605           }
;;;5606           else
;;;5607           {
;;;5608             /* Enable Acknowledge */
;;;5609             SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0001a6  6804              LDR      r4,[r0,#0]
0001a8  6824              LDR      r4,[r4,#0]
0001aa  f4446480          ORR      r4,r4,#0x400
0001ae  6805              LDR      r5,[r0,#0]
0001b0  602c              STR      r4,[r5,#0]
                  |L63.434|
;;;5610           }
;;;5611   
;;;5612           if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
0001b2  6804              LDR      r4,[r0,#0]
0001b4  6864              LDR      r4,[r4,#4]
0001b6  f4046400          AND      r4,r4,#0x800
0001ba  f5b46f00          CMP      r4,#0x800
0001be  d110              BNE      |L63.482|
0001c0  f5113f80          CMN      r1,#0x10000
0001c4  d007              BEQ      |L63.470|
0001c6  2901              CMP      r1,#1
0001c8  d005              BEQ      |L63.470|
0001ca  2908              CMP      r1,#8
0001cc  d003              BEQ      |L63.470|
0001ce  2910              CMP      r1,#0x10
0001d0  d001              BEQ      |L63.470|
0001d2  2920              CMP      r1,#0x20
0001d4  d105              BNE      |L63.482|
                  |L63.470|
;;;5613           {
;;;5614             /* Enable Last DMA bit */
;;;5615             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
0001d6  6804              LDR      r4,[r0,#0]
0001d8  6864              LDR      r4,[r4,#4]
0001da  f4445480          ORR      r4,r4,#0x1000
0001de  6805              LDR      r5,[r0,#0]
0001e0  606c              STR      r4,[r5,#4]
                  |L63.482|
;;;5616           }
;;;5617   
;;;5618           /* Clear ADDR flag */
;;;5619           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0001e2  bf00              NOP      
0001e4  2400              MOVS     r4,#0
0001e6  9400              STR      r4,[sp,#0]
0001e8  6804              LDR      r4,[r0,#0]
0001ea  6964              LDR      r4,[r4,#0x14]
0001ec  9400              STR      r4,[sp,#0]
0001ee  6804              LDR      r4,[r0,#0]
0001f0  69a4              LDR      r4,[r4,#0x18]
0001f2  9400              STR      r4,[sp,#0]
0001f4  bf00              NOP      
0001f6  e028              B        |L63.586|
                  |L63.504|
;;;5620         }
;;;5621         else
;;;5622         {
;;;5623           /* Enable Acknowledge */
;;;5624           SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0001f8  6804              LDR      r4,[r0,#0]
0001fa  6824              LDR      r4,[r4,#0]
0001fc  f4446480          ORR      r4,r4,#0x400
000200  6805              LDR      r5,[r0,#0]
000202  602c              STR      r4,[r5,#0]
;;;5625   
;;;5626           if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
000204  6804              LDR      r4,[r0,#0]
000206  6864              LDR      r4,[r4,#4]
000208  f4046400          AND      r4,r4,#0x800
00020c  f5b46f00          CMP      r4,#0x800
000210  d110              BNE      |L63.564|
000212  f5113f80          CMN      r1,#0x10000
000216  d007              BEQ      |L63.552|
000218  2901              CMP      r1,#1
00021a  d005              BEQ      |L63.552|
00021c  2908              CMP      r1,#8
00021e  d003              BEQ      |L63.552|
000220  2910              CMP      r1,#0x10
000222  d001              BEQ      |L63.552|
000224  2920              CMP      r1,#0x20
000226  d105              BNE      |L63.564|
                  |L63.552|
;;;5627           {
;;;5628             /* Enable Last DMA bit */
;;;5629             SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
000228  6804              LDR      r4,[r0,#0]
00022a  6864              LDR      r4,[r4,#4]
00022c  f4445480          ORR      r4,r4,#0x1000
000230  6805              LDR      r5,[r0,#0]
000232  606c              STR      r4,[r5,#4]
                  |L63.564|
;;;5630           }
;;;5631   
;;;5632           /* Clear ADDR flag */
;;;5633           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000234  bf00              NOP      
000236  2400              MOVS     r4,#0
000238  9400              STR      r4,[sp,#0]
00023a  6804              LDR      r4,[r0,#0]
00023c  6964              LDR      r4,[r4,#0x14]
00023e  9400              STR      r4,[sp,#0]
000240  6804              LDR      r4,[r0,#0]
000242  69a4              LDR      r4,[r4,#0x18]
000244  9400              STR      r4,[sp,#0]
000246  bf00              NOP      
000248  bf00              NOP      
                  |L63.586|
;;;5634         }
;;;5635   
;;;5636         /* Reset Event counter  */
;;;5637         hi2c->EventCount = 0U;
00024a  2400              MOVS     r4,#0
00024c  6504              STR      r4,[r0,#0x50]
00024e  e00a              B        |L63.614|
                  |L63.592|
;;;5638       }
;;;5639     }
;;;5640     else
;;;5641     {
;;;5642       /* Clear ADDR flag */
;;;5643       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000250  bf00              NOP      
000252  2400              MOVS     r4,#0
000254  9400              STR      r4,[sp,#0]
000256  6804              LDR      r4,[r0,#0]
000258  6964              LDR      r4,[r4,#0x14]
00025a  9400              STR      r4,[sp,#0]
00025c  6804              LDR      r4,[r0,#0]
00025e  69a4              LDR      r4,[r4,#0x18]
000260  9400              STR      r4,[sp,#0]
000262  bf00              NOP      
000264  bf00              NOP      
                  |L63.614|
;;;5644     }
;;;5645   }
000266  bd38              POP      {r3-r5,pc}
;;;5646   
                          ENDP


                          AREA ||i.I2C_Master_SB||, CODE, READONLY, ALIGN=1

                  I2C_Master_SB PROC
;;;5423     */
;;;5424   static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
000000  f890103e          LDRB     r1,[r0,#0x3e]
;;;5425   {
;;;5426     if (hi2c->Mode == HAL_I2C_MODE_MEM)
000004  2940              CMP      r1,#0x40
000006  d10e              BNE      |L64.38|
;;;5427     {
;;;5428       if (hi2c->EventCount == 0U)
000008  6d01              LDR      r1,[r0,#0x50]
00000a  b929              CBNZ     r1,|L64.24|
;;;5429       {
;;;5430         /* Send slave address */
;;;5431         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
00000c  6c41              LDR      r1,[r0,#0x44]
00000e  f00101fe          AND      r1,r1,#0xfe
000012  6802              LDR      r2,[r0,#0]
000014  6111              STR      r1,[r2,#0x10]
000016  e041              B        |L64.156|
                  |L64.24|
;;;5432       }
;;;5433       else
;;;5434       {
;;;5435         hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
000018  6c41              LDR      r1,[r0,#0x44]
00001a  b2c9              UXTB     r1,r1
00001c  f0410101          ORR      r1,r1,#1
000020  6802              LDR      r2,[r0,#0]
000022  6111              STR      r1,[r2,#0x10]
000024  e03a              B        |L64.156|
                  |L64.38|
;;;5436       }
;;;5437     }
;;;5438     else
;;;5439     {
;;;5440       if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
000026  6901              LDR      r1,[r0,#0x10]
000028  f5b14f80          CMP      r1,#0x4000
00002c  d120              BNE      |L64.112|
;;;5441       {
;;;5442         /* Send slave 7 Bits address */
;;;5443         if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
00002e  f890103d          LDRB     r1,[r0,#0x3d]
000032  2921              CMP      r1,#0x21
000034  d105              BNE      |L64.66|
;;;5444         {
;;;5445           hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
000036  6c41              LDR      r1,[r0,#0x44]
000038  f00101fe          AND      r1,r1,#0xfe
00003c  6802              LDR      r2,[r0,#0]
00003e  6111              STR      r1,[r2,#0x10]
000040  e005              B        |L64.78|
                  |L64.66|
;;;5446         }
;;;5447         else
;;;5448         {
;;;5449           hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
000042  6c41              LDR      r1,[r0,#0x44]
000044  b2c9              UXTB     r1,r1
000046  f0410101          ORR      r1,r1,#1
00004a  6802              LDR      r2,[r0,#0]
00004c  6111              STR      r1,[r2,#0x10]
                  |L64.78|
;;;5450         }
;;;5451   
;;;5452         if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
00004e  6b41              LDR      r1,[r0,#0x34]
000050  b909              CBNZ     r1,|L64.86|
000052  6b81              LDR      r1,[r0,#0x38]
000054  b311              CBZ      r1,|L64.156|
                  |L64.86|
;;;5453         {
;;;5454           if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
000056  6b41              LDR      r1,[r0,#0x34]
000058  6bc9              LDR      r1,[r1,#0x3c]
00005a  b911              CBNZ     r1,|L64.98|
00005c  6b81              LDR      r1,[r0,#0x38]
00005e  6bc9              LDR      r1,[r1,#0x3c]
000060  b1e1              CBZ      r1,|L64.156|
                  |L64.98|
;;;5455           {
;;;5456             /* Enable DMA Request */
;;;5457             SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000062  6801              LDR      r1,[r0,#0]
000064  6849              LDR      r1,[r1,#4]
000066  f4416100          ORR      r1,r1,#0x800
00006a  6802              LDR      r2,[r0,#0]
00006c  6051              STR      r1,[r2,#4]
00006e  e015              B        |L64.156|
                  |L64.112|
;;;5458           }
;;;5459         }
;;;5460       }
;;;5461       else
;;;5462       {
;;;5463         if (hi2c->EventCount == 0U)
000070  6d01              LDR      r1,[r0,#0x50]
000072  b941              CBNZ     r1,|L64.134|
;;;5464         {
;;;5465           /* Send header of slave address */
;;;5466           hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
000074  6c41              LDR      r1,[r0,#0x44]
000076  f4017140          AND      r1,r1,#0x300
00007a  22f0              MOVS     r2,#0xf0
00007c  ea4211e1          ORR      r1,r2,r1,ASR #7
000080  6802              LDR      r2,[r0,#0]
000082  6111              STR      r1,[r2,#0x10]
000084  e00a              B        |L64.156|
                  |L64.134|
;;;5467         }
;;;5468         else if (hi2c->EventCount == 1U)
000086  6d01              LDR      r1,[r0,#0x50]
000088  2901              CMP      r1,#1
00008a  d107              BNE      |L64.156|
;;;5469         {
;;;5470           /* Send header of slave address */
;;;5471           hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
00008c  6c41              LDR      r1,[r0,#0x44]
00008e  f4017140          AND      r1,r1,#0x300
000092  22f1              MOVS     r2,#0xf1
000094  ea4211e1          ORR      r1,r2,r1,ASR #7
000098  6802              LDR      r2,[r0,#0]
00009a  6111              STR      r1,[r2,#0x10]
                  |L64.156|
;;;5472         }
;;;5473         else
;;;5474         {
;;;5475           /* Do nothing */
;;;5476         }
;;;5477       }
;;;5478     }
;;;5479   }
00009c  4770              BX       lr
;;;5480   
                          ENDP


                          AREA ||i.I2C_RequestMemoryRead||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryRead PROC
;;;6452     */
;;;6453   static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6454   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
00000c  e9dd8608          LDRD     r8,r6,[sp,#0x20]
;;;6455     /* Enable Acknowledge */
;;;6456     SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f4406080          ORR      r0,r0,#0x400
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;6457   
;;;6458     /* Generate Start */
;;;6459     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f4407080          ORR      r0,r0,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  6008              STR      r0,[r1,#0]
;;;6460   
;;;6461     /* Wait until SB flag is set */
;;;6462     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000028  4643              MOV      r3,r8
00002a  2200              MOVS     r2,#0
00002c  f04f1101          MOV      r1,#0x10001
000030  4620              MOV      r0,r4
000032  9600              STR      r6,[sp,#0]
000034  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000038  b110              CBZ      r0,|L65.64|
;;;6463     {
;;;6464       return HAL_ERROR;
00003a  2001              MOVS     r0,#1
                  |L65.60|
;;;6465     }
;;;6466   
;;;6467     /* Send slave address */
;;;6468     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6469   
;;;6470     /* Wait until ADDR flag is set */
;;;6471     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6472     {
;;;6473       return HAL_ERROR;
;;;6474     }
;;;6475   
;;;6476     /* Clear ADDR flag */
;;;6477     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6478   
;;;6479     /* Wait until TXE flag is set */
;;;6480     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6481     {
;;;6482       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6483       {
;;;6484         /* Generate Stop */
;;;6485         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6486       }
;;;6487       return HAL_ERROR;
;;;6488     }
;;;6489   
;;;6490     /* If Memory address size is 8Bit */
;;;6491     if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;6492     {
;;;6493       /* Send Memory Address */
;;;6494       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6495     }
;;;6496     /* If Memory address size is 16Bit */
;;;6497     else
;;;6498     {
;;;6499       /* Send MSB of Memory Address */
;;;6500       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;6501   
;;;6502       /* Wait until TXE flag is set */
;;;6503       if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6504       {
;;;6505         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6506         {
;;;6507           /* Generate Stop */
;;;6508           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6509         }
;;;6510         return HAL_ERROR;
;;;6511       }
;;;6512   
;;;6513       /* Send LSB of Memory Address */
;;;6514       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6515     }
;;;6516   
;;;6517     /* Wait until TXE flag is set */
;;;6518     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6519     {
;;;6520       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6521       {
;;;6522         /* Generate Stop */
;;;6523         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6524       }
;;;6525       return HAL_ERROR;
;;;6526     }
;;;6527   
;;;6528     /* Generate Restart */
;;;6529     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;6530   
;;;6531     /* Wait until SB flag is set */
;;;6532     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
;;;6533     {
;;;6534       return HAL_ERROR;
;;;6535     }
;;;6536   
;;;6537     /* Send slave address */
;;;6538     hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;6539   
;;;6540     /* Wait until ADDR flag is set */
;;;6541     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6542     {
;;;6543       return HAL_ERROR;
;;;6544     }
;;;6545   
;;;6546     return HAL_OK;
;;;6547   }
00003c  e8bd83f8          POP      {r3-r9,pc}
                  |L65.64|
000040  f00700fe          AND      r0,r7,#0xfe           ;6468
000044  6821              LDR      r1,[r4,#0]            ;6468
000046  6108              STR      r0,[r1,#0x10]         ;6468
000048  4633              MOV      r3,r6                 ;6471
00004a  4642              MOV      r2,r8                 ;6471
00004c  4939              LDR      r1,|L65.308|
00004e  4620              MOV      r0,r4                 ;6471
000050  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000054  b108              CBZ      r0,|L65.90|
000056  2001              MOVS     r0,#1                 ;6473
000058  e7f0              B        |L65.60|
                  |L65.90|
00005a  bf00              NOP                            ;6477
00005c  2000              MOVS     r0,#0                 ;6477
00005e  9000              STR      r0,[sp,#0]            ;6477
000060  6820              LDR      r0,[r4,#0]            ;6477
000062  6940              LDR      r0,[r0,#0x14]         ;6477
000064  9000              STR      r0,[sp,#0]            ;6477
000066  6820              LDR      r0,[r4,#0]            ;6477
000068  6980              LDR      r0,[r0,#0x18]         ;6477
00006a  9000              STR      r0,[sp,#0]            ;6477
00006c  bf00              NOP                            ;6477
00006e  bf00              NOP                            ;6477
000070  4632              MOV      r2,r6                 ;6480
000072  4641              MOV      r1,r8                 ;6480
000074  4620              MOV      r0,r4                 ;6480
000076  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
00007a  b150              CBZ      r0,|L65.146|
00007c  6c20              LDR      r0,[r4,#0x40]         ;6482
00007e  2804              CMP      r0,#4                 ;6482
000080  d105              BNE      |L65.142|
000082  6820              LDR      r0,[r4,#0]            ;6485
000084  6800              LDR      r0,[r0,#0]            ;6485
000086  f4407000          ORR      r0,r0,#0x200          ;6485
00008a  6821              LDR      r1,[r4,#0]            ;6485
00008c  6008              STR      r0,[r1,#0]            ;6485
                  |L65.142|
00008e  2001              MOVS     r0,#1                 ;6487
000090  e7d4              B        |L65.60|
                  |L65.146|
000092  f1b90f01          CMP      r9,#1                 ;6491
000096  d103              BNE      |L65.160|
000098  b2e8              UXTB     r0,r5                 ;6494
00009a  6821              LDR      r1,[r4,#0]            ;6494
00009c  6108              STR      r0,[r1,#0x10]         ;6494
00009e  e017              B        |L65.208|
                  |L65.160|
0000a0  f3c52007          UBFX     r0,r5,#8,#8           ;6500
0000a4  6821              LDR      r1,[r4,#0]            ;6500
0000a6  6108              STR      r0,[r1,#0x10]         ;6500
0000a8  4632              MOV      r2,r6                 ;6503
0000aa  4641              MOV      r1,r8                 ;6503
0000ac  4620              MOV      r0,r4                 ;6503
0000ae  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000b2  b150              CBZ      r0,|L65.202|
0000b4  6c20              LDR      r0,[r4,#0x40]         ;6505
0000b6  2804              CMP      r0,#4                 ;6505
0000b8  d105              BNE      |L65.198|
0000ba  6820              LDR      r0,[r4,#0]            ;6508
0000bc  6800              LDR      r0,[r0,#0]            ;6508
0000be  f4407000          ORR      r0,r0,#0x200          ;6508
0000c2  6821              LDR      r1,[r4,#0]            ;6508
0000c4  6008              STR      r0,[r1,#0]            ;6508
                  |L65.198|
0000c6  2001              MOVS     r0,#1                 ;6510
0000c8  e7b8              B        |L65.60|
                  |L65.202|
0000ca  b2e8              UXTB     r0,r5                 ;6514
0000cc  6821              LDR      r1,[r4,#0]            ;6514
0000ce  6108              STR      r0,[r1,#0x10]         ;6514
                  |L65.208|
0000d0  4632              MOV      r2,r6                 ;6518
0000d2  4641              MOV      r1,r8                 ;6518
0000d4  4620              MOV      r0,r4                 ;6518
0000d6  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000da  b150              CBZ      r0,|L65.242|
0000dc  6c20              LDR      r0,[r4,#0x40]         ;6520
0000de  2804              CMP      r0,#4                 ;6520
0000e0  d105              BNE      |L65.238|
0000e2  6820              LDR      r0,[r4,#0]            ;6523
0000e4  6800              LDR      r0,[r0,#0]            ;6523
0000e6  f4407000          ORR      r0,r0,#0x200          ;6523
0000ea  6821              LDR      r1,[r4,#0]            ;6523
0000ec  6008              STR      r0,[r1,#0]            ;6523
                  |L65.238|
0000ee  2001              MOVS     r0,#1                 ;6525
0000f0  e7a4              B        |L65.60|
                  |L65.242|
0000f2  6820              LDR      r0,[r4,#0]            ;6529
0000f4  6800              LDR      r0,[r0,#0]            ;6529
0000f6  f4407080          ORR      r0,r0,#0x100          ;6529
0000fa  6821              LDR      r1,[r4,#0]            ;6529
0000fc  6008              STR      r0,[r1,#0]            ;6529
0000fe  4643              MOV      r3,r8                 ;6532
000100  2200              MOVS     r2,#0                 ;6532
000102  f04f1101          MOV      r1,#0x10001           ;6532
000106  4620              MOV      r0,r4                 ;6532
000108  9600              STR      r6,[sp,#0]            ;6532
00010a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00010e  b108              CBZ      r0,|L65.276|
000110  2001              MOVS     r0,#1                 ;6534
000112  e793              B        |L65.60|
                  |L65.276|
000114  b2f8              UXTB     r0,r7                 ;6538
000116  f0400001          ORR      r0,r0,#1              ;6538
00011a  6821              LDR      r1,[r4,#0]            ;6538
00011c  6108              STR      r0,[r1,#0x10]         ;6538
00011e  4633              MOV      r3,r6                 ;6541
000120  4642              MOV      r2,r8                 ;6541
000122  4904              LDR      r1,|L65.308|
000124  4620              MOV      r0,r4                 ;6541
000126  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00012a  b108              CBZ      r0,|L65.304|
00012c  2001              MOVS     r0,#1                 ;6543
00012e  e785              B        |L65.60|
                  |L65.304|
000130  2000              MOVS     r0,#0                 ;6546
000132  e783              B        |L65.60|
;;;6548   
                          ENDP

                  |L65.308|
                          DCD      0x00010002

                          AREA ||i.I2C_RequestMemoryWrite||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryWrite PROC
;;;6376     */
;;;6377   static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;6378   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
00000c  e9dd6708          LDRD     r6,r7,[sp,#0x20]
;;;6379     /* Generate Start */
;;;6380     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f4407080          ORR      r0,r0,#0x100
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;6381   
;;;6382     /* Wait until SB flag is set */
;;;6383     if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
00001c  4633              MOV      r3,r6
00001e  2200              MOVS     r2,#0
000020  f04f1101          MOV      r1,#0x10001
000024  4620              MOV      r0,r4
000026  9700              STR      r7,[sp,#0]
000028  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002c  b110              CBZ      r0,|L66.52|
;;;6384     {
;;;6385       return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L66.48|
;;;6386     }
;;;6387   
;;;6388     /* Send slave address */
;;;6389     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;6390   
;;;6391     /* Wait until ADDR flag is set */
;;;6392     if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;6393     {
;;;6394       return HAL_ERROR;
;;;6395     }
;;;6396   
;;;6397     /* Clear ADDR flag */
;;;6398     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;6399   
;;;6400     /* Wait until TXE flag is set */
;;;6401     if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6402     {
;;;6403       if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6404       {
;;;6405         /* Generate Stop */
;;;6406         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6407       }
;;;6408       return HAL_ERROR;
;;;6409     }
;;;6410   
;;;6411     /* If Memory address size is 8Bit */
;;;6412     if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;6413     {
;;;6414       /* Send Memory Address */
;;;6415       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6416     }
;;;6417     /* If Memory address size is 16Bit */
;;;6418     else
;;;6419     {
;;;6420       /* Send MSB of Memory Address */
;;;6421       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;6422   
;;;6423       /* Wait until TXE flag is set */
;;;6424       if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;6425       {
;;;6426         if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;6427         {
;;;6428           /* Generate Stop */
;;;6429           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;6430         }
;;;6431         return HAL_ERROR;
;;;6432       }
;;;6433   
;;;6434       /* Send LSB of Memory Address */
;;;6435       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;6436     }
;;;6437   
;;;6438     return HAL_OK;
;;;6439   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L66.52|
000034  f00800fe          AND      r0,r8,#0xfe           ;6389
000038  6821              LDR      r1,[r4,#0]            ;6389
00003a  6108              STR      r0,[r1,#0x10]         ;6389
00003c  463b              MOV      r3,r7                 ;6392
00003e  4632              MOV      r2,r6                 ;6392
000040  4921              LDR      r1,|L66.200|
000042  4620              MOV      r0,r4                 ;6392
000044  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000048  b108              CBZ      r0,|L66.78|
00004a  2001              MOVS     r0,#1                 ;6394
00004c  e7f0              B        |L66.48|
                  |L66.78|
00004e  bf00              NOP                            ;6398
000050  2000              MOVS     r0,#0                 ;6398
000052  9000              STR      r0,[sp,#0]            ;6398
000054  6820              LDR      r0,[r4,#0]            ;6398
000056  6940              LDR      r0,[r0,#0x14]         ;6398
000058  9000              STR      r0,[sp,#0]            ;6398
00005a  6820              LDR      r0,[r4,#0]            ;6398
00005c  6980              LDR      r0,[r0,#0x18]         ;6398
00005e  9000              STR      r0,[sp,#0]            ;6398
000060  bf00              NOP                            ;6398
000062  bf00              NOP                            ;6398
000064  463a              MOV      r2,r7                 ;6401
000066  4631              MOV      r1,r6                 ;6401
000068  4620              MOV      r0,r4                 ;6401
00006a  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
00006e  b150              CBZ      r0,|L66.134|
000070  6c20              LDR      r0,[r4,#0x40]         ;6403
000072  2804              CMP      r0,#4                 ;6403
000074  d105              BNE      |L66.130|
000076  6820              LDR      r0,[r4,#0]            ;6406
000078  6800              LDR      r0,[r0,#0]            ;6406
00007a  f4407000          ORR      r0,r0,#0x200          ;6406
00007e  6821              LDR      r1,[r4,#0]            ;6406
000080  6008              STR      r0,[r1,#0]            ;6406
                  |L66.130|
000082  2001              MOVS     r0,#1                 ;6408
000084  e7d4              B        |L66.48|
                  |L66.134|
000086  f1b90f01          CMP      r9,#1                 ;6412
00008a  d103              BNE      |L66.148|
00008c  b2e8              UXTB     r0,r5                 ;6415
00008e  6821              LDR      r1,[r4,#0]            ;6415
000090  6108              STR      r0,[r1,#0x10]         ;6415
000092  e017              B        |L66.196|
                  |L66.148|
000094  f3c52007          UBFX     r0,r5,#8,#8           ;6421
000098  6821              LDR      r1,[r4,#0]            ;6421
00009a  6108              STR      r0,[r1,#0x10]         ;6421
00009c  463a              MOV      r2,r7                 ;6424
00009e  4631              MOV      r1,r6                 ;6424
0000a0  4620              MOV      r0,r4                 ;6424
0000a2  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000a6  b150              CBZ      r0,|L66.190|
0000a8  6c20              LDR      r0,[r4,#0x40]         ;6426
0000aa  2804              CMP      r0,#4                 ;6426
0000ac  d105              BNE      |L66.186|
0000ae  6820              LDR      r0,[r4,#0]            ;6429
0000b0  6800              LDR      r0,[r0,#0]            ;6429
0000b2  f4407000          ORR      r0,r0,#0x200          ;6429
0000b6  6821              LDR      r1,[r4,#0]            ;6429
0000b8  6008              STR      r0,[r1,#0]            ;6429
                  |L66.186|
0000ba  2001              MOVS     r0,#1                 ;6431
0000bc  e7b8              B        |L66.48|
                  |L66.190|
0000be  b2e8              UXTB     r0,r5                 ;6435
0000c0  6821              LDR      r1,[r4,#0]            ;6435
0000c2  6108              STR      r0,[r1,#0x10]         ;6435
                  |L66.196|
0000c4  2000              MOVS     r0,#0                 ;6438
0000c6  e7b3              B        |L66.48|
;;;6440   
                          ENDP

                  |L66.200|
                          DCD      0x00010002

                          AREA ||i.I2C_SlaveReceive_BTF||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReceive_BTF PROC
;;;5755     */
;;;5756   static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  8d41              LDRH     r1,[r0,#0x2a]
;;;5757   {
;;;5758     if (hi2c->XferCount != 0U)
000002  b149              CBZ      r1,|L67.24|
;;;5759     {
;;;5760       /* Read data from DR */
;;;5761       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
000004  6801              LDR      r1,[r0,#0]
000006  6909              LDR      r1,[r1,#0x10]
000008  6a42              LDR      r2,[r0,#0x24]
00000a  7011              STRB     r1,[r2,#0]
;;;5762   
;;;5763       /* Increment Buffer pointer */
;;;5764       hi2c->pBuffPtr++;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  1c49              ADDS     r1,r1,#1
000010  6241              STR      r1,[r0,#0x24]
;;;5765   
;;;5766       /* Update counter */
;;;5767       hi2c->XferCount--;
000012  8d41              LDRH     r1,[r0,#0x2a]
000014  1e49              SUBS     r1,r1,#1
000016  8541              STRH     r1,[r0,#0x2a]
                  |L67.24|
;;;5768     }
;;;5769   }
000018  4770              BX       lr
;;;5770   
                          ENDP


                          AREA ||i.I2C_SlaveReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReceive_RXNE PROC
;;;5714     */
;;;5715   static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5716   {
000002  4604              MOV      r4,r0
;;;5717     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5718     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5719   
;;;5720     if (hi2c->XferCount != 0U)
000008  8d60              LDRH     r0,[r4,#0x2a]
00000a  b1d8              CBZ      r0,|L68.68|
;;;5721     {
;;;5722       /* Read data from DR */
;;;5723       *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
00000c  6820              LDR      r0,[r4,#0]
00000e  6900              LDR      r0,[r0,#0x10]
000010  6a61              LDR      r1,[r4,#0x24]
000012  7008              STRB     r0,[r1,#0]
;;;5724   
;;;5725       /* Increment Buffer pointer */
;;;5726       hi2c->pBuffPtr++;
000014  6a60              LDR      r0,[r4,#0x24]
000016  1c40              ADDS     r0,r0,#1
000018  6260              STR      r0,[r4,#0x24]
;;;5727   
;;;5728       /* Update counter */
;;;5729       hi2c->XferCount--;
00001a  8d60              LDRH     r0,[r4,#0x2a]
00001c  1e40              SUBS     r0,r0,#1
00001e  8560              STRH     r0,[r4,#0x2a]
;;;5730   
;;;5731       if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  b978              CBNZ     r0,|L68.68|
000024  2d2a              CMP      r5,#0x2a
000026  d10d              BNE      |L68.68|
;;;5732       {
;;;5733         /* Last Byte is received, disable Interrupt */
;;;5734         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  f4206080          BIC      r0,r0,#0x400
000030  6821              LDR      r1,[r4,#0]
000032  6048              STR      r0,[r1,#4]
;;;5735   
;;;5736         /* Set state at HAL_I2C_STATE_LISTEN */
;;;5737         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000034  2022              MOVS     r0,#0x22
000036  6320              STR      r0,[r4,#0x30]
;;;5738         hi2c->State = HAL_I2C_STATE_LISTEN;
000038  2028              MOVS     r0,#0x28
00003a  f884003d          STRB     r0,[r4,#0x3d]
;;;5739   
;;;5740         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5741   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5742         hi2c->SlaveRxCpltCallback(hi2c);
;;;5743   #else
;;;5744         HAL_I2C_SlaveRxCpltCallback(hi2c);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L68.68|
;;;5745   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5746       }
;;;5747     }
;;;5748   }
000044  bd70              POP      {r4-r6,pc}
;;;5749   
                          ENDP


                          AREA ||i.I2C_SlaveTransmit_BTF||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransmit_BTF PROC
;;;5693     */
;;;5694   static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
000000  8d41              LDRH     r1,[r0,#0x2a]
;;;5695   {
;;;5696     if (hi2c->XferCount != 0U)
000002  b149              CBZ      r1,|L69.24|
;;;5697     {
;;;5698       /* Write data to DR */
;;;5699       hi2c->Instance->DR = *hi2c->pBuffPtr;
000004  6a41              LDR      r1,[r0,#0x24]
000006  7809              LDRB     r1,[r1,#0]
000008  6802              LDR      r2,[r0,#0]
00000a  6111              STR      r1,[r2,#0x10]
;;;5700   
;;;5701       /* Increment Buffer pointer */
;;;5702       hi2c->pBuffPtr++;
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  1c49              ADDS     r1,r1,#1
000010  6241              STR      r1,[r0,#0x24]
;;;5703   
;;;5704       /* Update counter */
;;;5705       hi2c->XferCount--;
000012  8d41              LDRH     r1,[r0,#0x2a]
000014  1e49              SUBS     r1,r1,#1
000016  8541              STRH     r1,[r0,#0x2a]
                  |L69.24|
;;;5706     }
;;;5707   }
000018  4770              BX       lr
;;;5708   
                          ENDP


                          AREA ||i.I2C_SlaveTransmit_TXE||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransmit_TXE PROC
;;;5652     */
;;;5653   static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5654   {
000002  4604              MOV      r4,r0
;;;5655     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;5656     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5657   
;;;5658     if (hi2c->XferCount != 0U)
000008  8d60              LDRH     r0,[r4,#0x2a]
00000a  b1d8              CBZ      r0,|L70.68|
;;;5659     {
;;;5660       /* Write data to DR */
;;;5661       hi2c->Instance->DR = *hi2c->pBuffPtr;
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  7800              LDRB     r0,[r0,#0]
000010  6821              LDR      r1,[r4,#0]
000012  6108              STR      r0,[r1,#0x10]
;;;5662   
;;;5663       /* Increment Buffer pointer */
;;;5664       hi2c->pBuffPtr++;
000014  6a60              LDR      r0,[r4,#0x24]
000016  1c40              ADDS     r0,r0,#1
000018  6260              STR      r0,[r4,#0x24]
;;;5665   
;;;5666       /* Update counter */
;;;5667       hi2c->XferCount--;
00001a  8d60              LDRH     r0,[r4,#0x2a]
00001c  1e40              SUBS     r0,r0,#1
00001e  8560              STRH     r0,[r4,#0x2a]
;;;5668   
;;;5669       if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
000020  8d60              LDRH     r0,[r4,#0x2a]
000022  b978              CBNZ     r0,|L70.68|
000024  2d29              CMP      r5,#0x29
000026  d10d              BNE      |L70.68|
;;;5670       {
;;;5671         /* Last Byte is received, disable Interrupt */
;;;5672         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  f4206080          BIC      r0,r0,#0x400
000030  6821              LDR      r1,[r4,#0]
000032  6048              STR      r0,[r1,#4]
;;;5673   
;;;5674         /* Set state at HAL_I2C_STATE_LISTEN */
;;;5675         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
000034  2021              MOVS     r0,#0x21
000036  6320              STR      r0,[r4,#0x30]
;;;5676         hi2c->State = HAL_I2C_STATE_LISTEN;
000038  2028              MOVS     r0,#0x28
00003a  f884003d          STRB     r0,[r4,#0x3d]
;;;5677   
;;;5678         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5679   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5680         hi2c->SlaveTxCpltCallback(hi2c);
;;;5681   #else
;;;5682         HAL_I2C_SlaveTxCpltCallback(hi2c);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
                  |L70.68|
;;;5683   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5684       }
;;;5685     }
;;;5686   }
000044  bd70              POP      {r4-r6,pc}
;;;5687   
                          ENDP


                          AREA ||i.I2C_Slave_ADDR||, CODE, READONLY, ALIGN=1

                  I2C_Slave_ADDR PROC
;;;5777     */
;;;5778   static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5779   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;5780     uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
000008  2700              MOVS     r7,#0
;;;5781     uint16_t SlaveAddrCode;
;;;5782   
;;;5783     if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  f0000028          AND      r0,r0,#0x28
000012  2828              CMP      r0,#0x28
000014  d11c              BNE      |L71.80|
;;;5784     {
;;;5785       /* Disable BUF interrupt, BUF enabling is manage through slave specific interface */
;;;5786       __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
000016  6820              LDR      r0,[r4,#0]
000018  6840              LDR      r0,[r0,#4]
00001a  f4206080          BIC      r0,r0,#0x400
00001e  6821              LDR      r1,[r4,#0]
000020  6048              STR      r0,[r1,#4]
;;;5787   
;;;5788       /* Transfer Direction requested by Master */
;;;5789       if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
000022  f3c50080          UBFX     r0,r5,#2,#1
000026  b900              CBNZ     r0,|L71.42|
;;;5790       {
;;;5791         TransferDirection = I2C_DIRECTION_TRANSMIT;
000028  2701              MOVS     r7,#1
                  |L71.42|
;;;5792       }
;;;5793   
;;;5794       if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
00002a  f3c510c0          UBFX     r0,r5,#7,#1
00002e  b910              CBNZ     r0,|L71.54|
;;;5795       {
;;;5796         SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
000030  89a0              LDRH     r0,[r4,#0xc]
000032  b286              UXTH     r6,r0
000034  e001              B        |L71.58|
                  |L71.54|
;;;5797       }
;;;5798       else
;;;5799       {
;;;5800         SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
000036  8b20              LDRH     r0,[r4,#0x18]
000038  b286              UXTH     r6,r0
                  |L71.58|
;;;5801       }
;;;5802   
;;;5803       /* Process Unlocked */
;;;5804       __HAL_UNLOCK(hi2c);
00003a  bf00              NOP      
00003c  2000              MOVS     r0,#0
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;5805   
;;;5806       /* Call Slave Addr callback */
;;;5807   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5808       hi2c->AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
;;;5809   #else
;;;5810       HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
000044  4632              MOV      r2,r6
000046  4639              MOV      r1,r7
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_I2C_AddrCallback
00004e  e008              B        |L71.98|
                  |L71.80|
;;;5811   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5812     }
;;;5813     else
;;;5814     {
;;;5815       /* Clear ADDR flag */
;;;5816       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
000050  f06f0002          MVN      r0,#2
000054  6821              LDR      r1,[r4,#0]
000056  6148              STR      r0,[r1,#0x14]
;;;5817   
;;;5818       /* Process Unlocked */
;;;5819       __HAL_UNLOCK(hi2c);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f884003c          STRB     r0,[r4,#0x3c]
000060  bf00              NOP      
                  |L71.98|
;;;5820     }
;;;5821   }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;5822   
                          ENDP


                          AREA ||i.I2C_Slave_AF||, CODE, READONLY, ALIGN=2

                  I2C_Slave_AF PROC
;;;5997     */
;;;5998   static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;5999   {
000002  4604              MOV      r4,r0
;;;6000     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;6001     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;6002     uint32_t CurrentXferOptions       = hi2c->XferOptions;
000008  6ae6              LDR      r6,[r4,#0x2c]
;;;6003   
;;;6004     if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
00000a  2e08              CMP      r6,#8
00000c  d001              BEQ      |L72.18|
00000e  2e20              CMP      r6,#0x20
000010  d11f              BNE      |L72.82|
                  |L72.18|
;;;6005         (CurrentState == HAL_I2C_STATE_LISTEN))
000012  2d28              CMP      r5,#0x28
000014  d11d              BNE      |L72.82|
;;;6006     {
;;;6007       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
000016  4821              LDR      r0,|L72.156|
000018  62e0              STR      r0,[r4,#0x2c]
;;;6008   
;;;6009       /* Disable EVT, BUF and ERR interrupt */
;;;6010       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f42060e0          BIC      r0,r0,#0x700
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;6011   
;;;6012       /* Clear AF flag */
;;;6013       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000026  f46f6080          MVN      r0,#0x400
00002a  6821              LDR      r1,[r4,#0]
00002c  6148              STR      r0,[r1,#0x14]
;;;6014   
;;;6015       /* Disable Acknowledge */
;;;6016       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f4206080          BIC      r0,r0,#0x400
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;6017   
;;;6018       hi2c->PreviousState = I2C_STATE_NONE;
00003a  2000              MOVS     r0,#0
00003c  6320              STR      r0,[r4,#0x30]
;;;6019       hi2c->State         = HAL_I2C_STATE_READY;
00003e  2020              MOVS     r0,#0x20
000040  f884003d          STRB     r0,[r4,#0x3d]
;;;6020       hi2c->Mode          = HAL_I2C_MODE_NONE;
000044  2000              MOVS     r0,#0
000046  f884003e          STRB     r0,[r4,#0x3e]
;;;6021   
;;;6022       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;6023   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6024       hi2c->ListenCpltCallback(hi2c);
;;;6025   #else
;;;6026       HAL_I2C_ListenCpltCallback(hi2c);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       HAL_I2C_ListenCpltCallback
000050  e023              B        |L72.154|
                  |L72.82|
;;;6027   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6028     }
;;;6029     else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
000052  2d21              CMP      r5,#0x21
000054  d11d              BNE      |L72.146|
;;;6030     {
;;;6031       hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
000056  4811              LDR      r0,|L72.156|
000058  62e0              STR      r0,[r4,#0x2c]
;;;6032       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
00005a  2021              MOVS     r0,#0x21
00005c  6320              STR      r0,[r4,#0x30]
;;;6033       hi2c->State         = HAL_I2C_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  f884003d          STRB     r0,[r4,#0x3d]
;;;6034       hi2c->Mode          = HAL_I2C_MODE_NONE;
000064  2000              MOVS     r0,#0
000066  f884003e          STRB     r0,[r4,#0x3e]
;;;6035   
;;;6036       /* Disable EVT, BUF and ERR interrupt */
;;;6037       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00006a  6820              LDR      r0,[r4,#0]
00006c  6840              LDR      r0,[r0,#4]
00006e  f42060e0          BIC      r0,r0,#0x700
000072  6821              LDR      r1,[r4,#0]
000074  6048              STR      r0,[r1,#4]
;;;6038   
;;;6039       /* Clear AF flag */
;;;6040       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000076  f46f6080          MVN      r0,#0x400
00007a  6821              LDR      r1,[r4,#0]
00007c  6148              STR      r0,[r1,#0x14]
;;;6041   
;;;6042       /* Disable Acknowledge */
;;;6043       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00007e  6820              LDR      r0,[r4,#0]
000080  6800              LDR      r0,[r0,#0]
000082  f4206080          BIC      r0,r0,#0x400
000086  6821              LDR      r1,[r4,#0]
000088  6008              STR      r0,[r1,#0]
;;;6044   
;;;6045   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;6046       hi2c->SlaveTxCpltCallback(hi2c);
;;;6047   #else
;;;6048       HAL_I2C_SlaveTxCpltCallback(hi2c);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
000090  e003              B        |L72.154|
                  |L72.146|
;;;6049   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;6050     }
;;;6051     else
;;;6052     {
;;;6053       /* Clear AF flag only */
;;;6054       /* State Listen, but XferOptions == FIRST or NEXT */
;;;6055       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000092  f46f6080          MVN      r0,#0x400
000096  6821              LDR      r1,[r4,#0]
000098  6148              STR      r0,[r1,#0x14]
                  |L72.154|
;;;6056     }
;;;6057   }
00009a  bd70              POP      {r4-r6,pc}
;;;6058   
                          ENDP

                  |L72.156|
                          DCD      0xffff0000

                          AREA ||i.I2C_Slave_STOPF||, CODE, READONLY, ALIGN=2

                  I2C_Slave_STOPF PROC
;;;5828     */
;;;5829   static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
000000  b538              PUSH     {r3-r5,lr}
;;;5830   {
000002  4604              MOV      r4,r0
;;;5831     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;5832     HAL_I2C_StateTypeDef CurrentState = hi2c->State;
000004  f894503d          LDRB     r5,[r4,#0x3d]
;;;5833   
;;;5834     /* Disable EVT, BUF and ERR interrupt */
;;;5835     __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000008  6820              LDR      r0,[r4,#0]
00000a  6840              LDR      r0,[r0,#4]
00000c  f42060e0          BIC      r0,r0,#0x700
000010  6821              LDR      r1,[r4,#0]
000012  6048              STR      r0,[r1,#4]
;;;5836   
;;;5837     /* Clear STOPF flag */
;;;5838     __HAL_I2C_CLEAR_STOPFLAG(hi2c);
000014  bf00              NOP      
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
00001a  6820              LDR      r0,[r4,#0]
00001c  6940              LDR      r0,[r0,#0x14]
00001e  9000              STR      r0,[sp,#0]
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0400001          ORR      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;5839   
;;;5840     /* Disable Acknowledge */
;;;5841     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000030  6820              LDR      r0,[r4,#0]
000032  6800              LDR      r0,[r0,#0]
000034  f4206080          BIC      r0,r0,#0x400
000038  6821              LDR      r1,[r4,#0]
00003a  6008              STR      r0,[r1,#0]
;;;5842   
;;;5843     /* If a DMA is ongoing, Update handle size context */
;;;5844     if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
00003c  6820              LDR      r0,[r4,#0]
00003e  6840              LDR      r0,[r0,#4]
000040  f4006000          AND      r0,r0,#0x800
000044  f5b06f00          CMP      r0,#0x800
000048  d142              BNE      |L73.208|
;;;5845     {
;;;5846       if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
00004a  2d22              CMP      r5,#0x22
00004c  d001              BEQ      |L73.82|
00004e  2d2a              CMP      r5,#0x2a
000050  d11f              BNE      |L73.146|
                  |L73.82|
;;;5847       {
;;;5848         hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
000052  6ba0              LDR      r0,[r4,#0x38]
000054  6800              LDR      r0,[r0,#0]
000056  6840              LDR      r0,[r0,#4]
000058  8560              STRH     r0,[r4,#0x2a]
;;;5849   
;;;5850         if (hi2c->XferCount != 0U)
00005a  8d60              LDRH     r0,[r4,#0x2a]
00005c  b118              CBZ      r0,|L73.102|
;;;5851         {
;;;5852           /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;5853           hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00005e  6c20              LDR      r0,[r4,#0x40]
000060  f0400004          ORR      r0,r0,#4
000064  6420              STR      r0,[r4,#0x40]
                  |L73.102|
;;;5854         }
;;;5855   
;;;5856         /* Disable, stop the current DMA */
;;;5857         CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000066  6820              LDR      r0,[r4,#0]
000068  6840              LDR      r0,[r0,#4]
00006a  f4206000          BIC      r0,r0,#0x800
00006e  6821              LDR      r1,[r4,#0]
000070  6048              STR      r0,[r1,#4]
;;;5858   
;;;5859         /* Abort DMA Xfer if any */
;;;5860         if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
000072  6ba0              LDR      r0,[r4,#0x38]
000074  f7fffffe          BL       HAL_DMA_GetState
000078  2801              CMP      r0,#1
00007a  d029              BEQ      |L73.208|
;;;5861         {
;;;5862           /* Set the I2C DMA Abort callback :
;;;5863           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;5864           hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
00007c  4841              LDR      r0,|L73.388|
00007e  6ba1              LDR      r1,[r4,#0x38]
000080  6508              STR      r0,[r1,#0x50]
;;;5865   
;;;5866           /* Abort DMA RX */
;;;5867           if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
000082  6ba0              LDR      r0,[r4,#0x38]
000084  f7fffffe          BL       HAL_DMA_Abort_IT
000088  b310              CBZ      r0,|L73.208|
;;;5868           {
;;;5869             /* Call Directly XferAbortCallback function in case of error */
;;;5870             hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
00008a  6ba0              LDR      r0,[r4,#0x38]
00008c  6d01              LDR      r1,[r0,#0x50]
00008e  4788              BLX      r1
000090  e01e              B        |L73.208|
                  |L73.146|
;;;5871           }
;;;5872         }
;;;5873       }
;;;5874       else
;;;5875       {
;;;5876         hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
000092  6b60              LDR      r0,[r4,#0x34]
000094  6800              LDR      r0,[r0,#0]
000096  6840              LDR      r0,[r0,#4]
000098  8560              STRH     r0,[r4,#0x2a]
;;;5877   
;;;5878         if (hi2c->XferCount != 0U)
00009a  8d60              LDRH     r0,[r4,#0x2a]
00009c  b118              CBZ      r0,|L73.166|
;;;5879         {
;;;5880           /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;5881           hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00009e  6c20              LDR      r0,[r4,#0x40]
0000a0  f0400004          ORR      r0,r0,#4
0000a4  6420              STR      r0,[r4,#0x40]
                  |L73.166|
;;;5882         }
;;;5883   
;;;5884         /* Disable, stop the current DMA */
;;;5885         CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
0000a6  6820              LDR      r0,[r4,#0]
0000a8  6840              LDR      r0,[r0,#4]
0000aa  f4206000          BIC      r0,r0,#0x800
0000ae  6821              LDR      r1,[r4,#0]
0000b0  6048              STR      r0,[r1,#4]
;;;5886   
;;;5887         /* Abort DMA Xfer if any */
;;;5888         if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
0000b2  6b60              LDR      r0,[r4,#0x34]
0000b4  f7fffffe          BL       HAL_DMA_GetState
0000b8  2801              CMP      r0,#1
0000ba  d009              BEQ      |L73.208|
;;;5889         {
;;;5890           /* Set the I2C DMA Abort callback :
;;;5891           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;5892           hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
0000bc  4831              LDR      r0,|L73.388|
0000be  6b61              LDR      r1,[r4,#0x34]
0000c0  6508              STR      r0,[r1,#0x50]
;;;5893   
;;;5894           /* Abort DMA TX */
;;;5895           if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
0000c2  6b60              LDR      r0,[r4,#0x34]
0000c4  f7fffffe          BL       HAL_DMA_Abort_IT
0000c8  b110              CBZ      r0,|L73.208|
;;;5896           {
;;;5897             /* Call Directly XferAbortCallback function in case of error */
;;;5898             hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
0000ca  6b60              LDR      r0,[r4,#0x34]
0000cc  6d01              LDR      r1,[r0,#0x50]
0000ce  4788              BLX      r1
                  |L73.208|
;;;5899           }
;;;5900         }
;;;5901       }
;;;5902     }
;;;5903   
;;;5904     /* All data are not transferred, so set error code accordingly */
;;;5905     if (hi2c->XferCount != 0U)
0000d0  8d60              LDRH     r0,[r4,#0x2a]
0000d2  b318              CBZ      r0,|L73.284|
;;;5906     {
;;;5907       /* Store Last receive data if any */
;;;5908       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6940              LDR      r0,[r0,#0x14]
0000d8  f3c00080          UBFX     r0,r0,#2,#1
0000dc  b148              CBZ      r0,|L73.242|
;;;5909       {
;;;5910         /* Read data from DR */
;;;5911         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000de  6820              LDR      r0,[r4,#0]
0000e0  6900              LDR      r0,[r0,#0x10]
0000e2  6a61              LDR      r1,[r4,#0x24]
0000e4  7008              STRB     r0,[r1,#0]
;;;5912   
;;;5913         /* Increment Buffer pointer */
;;;5914         hi2c->pBuffPtr++;
0000e6  6a60              LDR      r0,[r4,#0x24]
0000e8  1c40              ADDS     r0,r0,#1
0000ea  6260              STR      r0,[r4,#0x24]
;;;5915   
;;;5916         /* Update counter */
;;;5917         hi2c->XferCount--;
0000ec  8d60              LDRH     r0,[r4,#0x2a]
0000ee  1e40              SUBS     r0,r0,#1
0000f0  8560              STRH     r0,[r4,#0x2a]
                  |L73.242|
;;;5918       }
;;;5919   
;;;5920       /* Store Last receive data if any */
;;;5921       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6940              LDR      r0,[r0,#0x14]
0000f6  f3c01080          UBFX     r0,r0,#6,#1
0000fa  b148              CBZ      r0,|L73.272|
;;;5922       {
;;;5923         /* Read data from DR */
;;;5924         *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
0000fc  6820              LDR      r0,[r4,#0]
0000fe  6900              LDR      r0,[r0,#0x10]
000100  6a61              LDR      r1,[r4,#0x24]
000102  7008              STRB     r0,[r1,#0]
;;;5925   
;;;5926         /* Increment Buffer pointer */
;;;5927         hi2c->pBuffPtr++;
000104  6a60              LDR      r0,[r4,#0x24]
000106  1c40              ADDS     r0,r0,#1
000108  6260              STR      r0,[r4,#0x24]
;;;5928   
;;;5929         /* Update counter */
;;;5930         hi2c->XferCount--;
00010a  8d60              LDRH     r0,[r4,#0x2a]
00010c  1e40              SUBS     r0,r0,#1
00010e  8560              STRH     r0,[r4,#0x2a]
                  |L73.272|
;;;5931       }
;;;5932   
;;;5933       if (hi2c->XferCount != 0U)
000110  8d60              LDRH     r0,[r4,#0x2a]
000112  b118              CBZ      r0,|L73.284|
;;;5934       {
;;;5935         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;5936         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000114  6c20              LDR      r0,[r4,#0x40]
000116  f0400004          ORR      r0,r0,#4
00011a  6420              STR      r0,[r4,#0x40]
                  |L73.284|
;;;5937       }
;;;5938     }
;;;5939   
;;;5940     if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
00011c  6c20              LDR      r0,[r4,#0x40]
00011e  b118              CBZ      r0,|L73.296|
;;;5941     {
;;;5942       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5943       I2C_ITError(hi2c);
000120  4620              MOV      r0,r4
000122  f7fffffe          BL       I2C_ITError
000126  e02b              B        |L73.384|
                  |L73.296|
;;;5944     }
;;;5945     else
;;;5946     {
;;;5947       if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
000128  2d2a              CMP      r5,#0x2a
00012a  d107              BNE      |L73.316|
;;;5948       {
;;;5949         /* Set state at HAL_I2C_STATE_LISTEN */
;;;5950         hi2c->PreviousState = I2C_STATE_NONE;
00012c  2000              MOVS     r0,#0
00012e  6320              STR      r0,[r4,#0x30]
;;;5951         hi2c->State = HAL_I2C_STATE_LISTEN;
000130  2028              MOVS     r0,#0x28
000132  f884003d          STRB     r0,[r4,#0x3d]
;;;5952   
;;;5953         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5954   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5955         hi2c->SlaveRxCpltCallback(hi2c);
;;;5956   #else
;;;5957         HAL_I2C_SlaveRxCpltCallback(hi2c);
000136  4620              MOV      r0,r4
000138  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L73.316|
;;;5958   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5959       }
;;;5960   
;;;5961       if (hi2c->State == HAL_I2C_STATE_LISTEN)
00013c  f894003d          LDRB     r0,[r4,#0x3d]
000140  2828              CMP      r0,#0x28
000142  d10d              BNE      |L73.352|
;;;5962       {
;;;5963         hi2c->XferOptions = I2C_NO_OPTION_FRAME;
000144  4810              LDR      r0,|L73.392|
000146  62e0              STR      r0,[r4,#0x2c]
;;;5964         hi2c->PreviousState = I2C_STATE_NONE;
000148  2000              MOVS     r0,#0
00014a  6320              STR      r0,[r4,#0x30]
;;;5965         hi2c->State = HAL_I2C_STATE_READY;
00014c  2020              MOVS     r0,#0x20
00014e  f884003d          STRB     r0,[r4,#0x3d]
;;;5966         hi2c->Mode = HAL_I2C_MODE_NONE;
000152  2000              MOVS     r0,#0
000154  f884003e          STRB     r0,[r4,#0x3e]
;;;5967   
;;;5968         /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;5969   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5970         hi2c->ListenCpltCallback(hi2c);
;;;5971   #else
;;;5972         HAL_I2C_ListenCpltCallback(hi2c);
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       HAL_I2C_ListenCpltCallback
00015e  e00f              B        |L73.384|
                  |L73.352|
;;;5973   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5974       }
;;;5975       else
;;;5976       {
;;;5977         if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
000160  6b20              LDR      r0,[r4,#0x30]
000162  2822              CMP      r0,#0x22
000164  d001              BEQ      |L73.362|
000166  2d22              CMP      r5,#0x22
000168  d10a              BNE      |L73.384|
                  |L73.362|
;;;5978         {
;;;5979           hi2c->PreviousState = I2C_STATE_NONE;
00016a  2000              MOVS     r0,#0
00016c  6320              STR      r0,[r4,#0x30]
;;;5980           hi2c->State = HAL_I2C_STATE_READY;
00016e  2020              MOVS     r0,#0x20
000170  f884003d          STRB     r0,[r4,#0x3d]
;;;5981           hi2c->Mode = HAL_I2C_MODE_NONE;
000174  2000              MOVS     r0,#0
000176  f884003e          STRB     r0,[r4,#0x3e]
;;;5982   
;;;5983   #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
;;;5984           hi2c->SlaveRxCpltCallback(hi2c);
;;;5985   #else
;;;5986           HAL_I2C_SlaveRxCpltCallback(hi2c);
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L73.384|
;;;5987   #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
;;;5988         }
;;;5989       }
;;;5990     }
;;;5991   }
000180  bd38              POP      {r3-r5,pc}
;;;5992   
                          ENDP

000182  0000              DCW      0x0000
                  |L73.388|
                          DCD      I2C_DMAAbort
                  |L73.392|
                          DCD      0xffff0000

                          AREA ||i.I2C_WaitOnBTFFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnBTFFlagUntilTimeout PROC
;;;6919     */
;;;6920   static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;6921   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;6922     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
000008  e020              B        |L74.76|
                  |L74.10|
;;;6923     {
;;;6924       /* Check if a NACK is detected */
;;;6925       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L74.22|
;;;6926       {
;;;6927         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L74.20|
;;;6928       }
;;;6929   
;;;6930       /* Check for the Timeout */
;;;6931       if (Timeout != HAL_MAX_DELAY)
;;;6932       {
;;;6933         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6934         {
;;;6935           hi2c->PreviousState       = I2C_STATE_NONE;
;;;6936           hi2c->State               = HAL_I2C_STATE_READY;
;;;6937           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;6938           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;6939   
;;;6940           /* Process Unlocked */
;;;6941           __HAL_UNLOCK(hi2c);
;;;6942   
;;;6943           return HAL_ERROR;
;;;6944         }
;;;6945       }
;;;6946     }
;;;6947     return HAL_OK;
;;;6948   }
000014  bd70              POP      {r4-r6,pc}
                  |L74.22|
000016  1c68              ADDS     r0,r5,#1              ;6931
000018  b1c0              CBZ      r0,|L74.76|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6              ;6933
000020  42a8              CMP      r0,r5                 ;6933
000022  d800              BHI      |L74.38|
000024  b995              CBNZ     r5,|L74.76|
                  |L74.38|
000026  2000              MOVS     r0,#0                 ;6935
000028  6320              STR      r0,[r4,#0x30]         ;6935
00002a  2020              MOVS     r0,#0x20              ;6936
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;6936
000030  2000              MOVS     r0,#0                 ;6937
000032  f884003e          STRB     r0,[r4,#0x3e]         ;6937
000036  6c20              LDR      r0,[r4,#0x40]         ;6938
000038  f0400020          ORR      r0,r0,#0x20           ;6938
00003c  6420              STR      r0,[r4,#0x40]         ;6938
00003e  bf00              NOP                            ;6941
000040  2000              MOVS     r0,#0                 ;6941
000042  f884003c          STRB     r0,[r4,#0x3c]         ;6941
000046  bf00              NOP                            ;6941
000048  2001              MOVS     r0,#1                 ;6943
00004a  e7e3              B        |L74.20|
                  |L74.76|
00004c  6820              LDR      r0,[r4,#0]            ;6922
00004e  6940              LDR      r0,[r0,#0x14]         ;6922
000050  f3c00080          UBFX     r0,r0,#2,#1           ;6922
000054  2800              CMP      r0,#0                 ;6922
000056  d0d8              BEQ      |L74.10|
000058  2000              MOVS     r0,#0                 ;6947
00005a  e7db              B        |L74.20|
;;;6949   
                          ENDP


                          AREA ||i.I2C_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnFlagUntilTimeout PROC
;;;6796     */
;;;6797   static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6798   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;6799     /* Wait until flag is set */
;;;6800     while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
000010  e01c              B        |L75.76|
                  |L75.18|
;;;6801     {
;;;6802       /* Check for the Timeout */
;;;6803       if (Timeout != HAL_MAX_DELAY)
000012  1c70              ADDS     r0,r6,#1
000014  b1d0              CBZ      r0,|L75.76|
;;;6804       {
;;;6805         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d800              BHI      |L75.36|
000022  b99e              CBNZ     r6,|L75.76|
                  |L75.36|
;;;6806         {
;;;6807           hi2c->PreviousState     = I2C_STATE_NONE;
000024  2000              MOVS     r0,#0
000026  6320              STR      r0,[r4,#0x30]
;;;6808           hi2c->State             = HAL_I2C_STATE_READY;
000028  2020              MOVS     r0,#0x20
00002a  f884003d          STRB     r0,[r4,#0x3d]
;;;6809           hi2c->Mode              = HAL_I2C_MODE_NONE;
00002e  2000              MOVS     r0,#0
000030  f884003e          STRB     r0,[r4,#0x3e]
;;;6810           hi2c->ErrorCode         |= HAL_I2C_ERROR_TIMEOUT;
000034  6c20              LDR      r0,[r4,#0x40]
000036  f0400020          ORR      r0,r0,#0x20
00003a  6420              STR      r0,[r4,#0x40]
;;;6811   
;;;6812           /* Process Unlocked */
;;;6813           __HAL_UNLOCK(hi2c);
00003c  bf00              NOP      
00003e  2000              MOVS     r0,#0
000040  f884003c          STRB     r0,[r4,#0x3c]
000044  bf00              NOP      
;;;6814   
;;;6815           return HAL_ERROR;
000046  2001              MOVS     r0,#1
                  |L75.72|
;;;6816         }
;;;6817       }
;;;6818     }
;;;6819     return HAL_OK;
;;;6820   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L75.76|
00004c  f3c54007          UBFX     r0,r5,#16,#8          ;6800
000050  2801              CMP      r0,#1                 ;6800
000052  d10a              BNE      |L75.106|
000054  6820              LDR      r0,[r4,#0]            ;6800
000056  6940              LDR      r0,[r0,#0x14]         ;6800
000058  b2a9              UXTH     r1,r5                 ;6800
00005a  4008              ANDS     r0,r0,r1              ;6800
00005c  b2a9              UXTH     r1,r5                 ;6800
00005e  4288              CMP      r0,r1                 ;6800
000060  d101              BNE      |L75.102|
000062  2001              MOVS     r0,#1                 ;6800
000064  e00b              B        |L75.126|
                  |L75.102|
000066  2000              MOVS     r0,#0                 ;6800
000068  e009              B        |L75.126|
                  |L75.106|
00006a  6820              LDR      r0,[r4,#0]            ;6800
00006c  6980              LDR      r0,[r0,#0x18]         ;6800
00006e  b2a9              UXTH     r1,r5                 ;6800
000070  4008              ANDS     r0,r0,r1              ;6800
000072  b2a9              UXTH     r1,r5                 ;6800
000074  4288              CMP      r0,r1                 ;6800
000076  d101              BNE      |L75.124|
000078  2001              MOVS     r0,#1                 ;6800
00007a  e000              B        |L75.126|
                  |L75.124|
00007c  2000              MOVS     r0,#0                 ;6800
                  |L75.126|
00007e  42b8              CMP      r0,r7                 ;6800
000080  d0c7              BEQ      |L75.18|
000082  2000              MOVS     r0,#0                 ;6819
000084  e7e0              B        |L75.72|
;;;6821   
                          ENDP


                          AREA ||i.I2C_WaitOnMasterAddressFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnMasterAddressFlagUntilTimeout PROC
;;;6830     */
;;;6831   static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6832   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;6833     while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
00000c  e03d              B        |L76.138|
                  |L76.14|
;;;6834     {
;;;6835       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
00000e  6820              LDR      r0,[r4,#0]
000010  6940              LDR      r0,[r0,#0x14]
000012  f3c02080          UBFX     r0,r0,#10,#1
000016  b1e8              CBZ      r0,|L76.84|
;;;6836       {
;;;6837         /* Generate Stop */
;;;6838         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
000018  6820              LDR      r0,[r4,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  f4407000          ORR      r0,r0,#0x200
000020  6821              LDR      r1,[r4,#0]
000022  6008              STR      r0,[r1,#0]
;;;6839   
;;;6840         /* Clear AF Flag */
;;;6841         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000024  f46f6080          MVN      r0,#0x400
000028  6821              LDR      r1,[r4,#0]
00002a  6148              STR      r0,[r1,#0x14]
;;;6842   
;;;6843         hi2c->PreviousState       = I2C_STATE_NONE;
00002c  2000              MOVS     r0,#0
00002e  6320              STR      r0,[r4,#0x30]
;;;6844         hi2c->State               = HAL_I2C_STATE_READY;
000030  2020              MOVS     r0,#0x20
000032  f884003d          STRB     r0,[r4,#0x3d]
;;;6845         hi2c->Mode                = HAL_I2C_MODE_NONE;
000036  2000              MOVS     r0,#0
000038  f884003e          STRB     r0,[r4,#0x3e]
;;;6846         hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
00003c  6c20              LDR      r0,[r4,#0x40]
00003e  f0400004          ORR      r0,r0,#4
000042  6420              STR      r0,[r4,#0x40]
;;;6847   
;;;6848         /* Process Unlocked */
;;;6849         __HAL_UNLOCK(hi2c);
000044  bf00              NOP      
000046  2000              MOVS     r0,#0
000048  f884003c          STRB     r0,[r4,#0x3c]
00004c  bf00              NOP      
;;;6850   
;;;6851         return HAL_ERROR;
00004e  2001              MOVS     r0,#1
                  |L76.80|
;;;6852       }
;;;6853   
;;;6854       /* Check for the Timeout */
;;;6855       if (Timeout != HAL_MAX_DELAY)
;;;6856       {
;;;6857         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6858         {
;;;6859           hi2c->PreviousState       = I2C_STATE_NONE;
;;;6860           hi2c->State               = HAL_I2C_STATE_READY;
;;;6861           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;6862           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;6863   
;;;6864           /* Process Unlocked */
;;;6865           __HAL_UNLOCK(hi2c);
;;;6866   
;;;6867           return HAL_ERROR;
;;;6868         }
;;;6869       }
;;;6870     }
;;;6871     return HAL_OK;
;;;6872   }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L76.84|
000054  1c70              ADDS     r0,r6,#1              ;6855
000056  b1c0              CBZ      r0,|L76.138|
000058  f7fffffe          BL       HAL_GetTick
00005c  1bc0              SUBS     r0,r0,r7              ;6857
00005e  42b0              CMP      r0,r6                 ;6857
000060  d800              BHI      |L76.100|
000062  b996              CBNZ     r6,|L76.138|
                  |L76.100|
000064  2000              MOVS     r0,#0                 ;6859
000066  6320              STR      r0,[r4,#0x30]         ;6859
000068  2020              MOVS     r0,#0x20              ;6860
00006a  f884003d          STRB     r0,[r4,#0x3d]         ;6860
00006e  2000              MOVS     r0,#0                 ;6861
000070  f884003e          STRB     r0,[r4,#0x3e]         ;6861
000074  6c20              LDR      r0,[r4,#0x40]         ;6862
000076  f0400020          ORR      r0,r0,#0x20           ;6862
00007a  6420              STR      r0,[r4,#0x40]         ;6862
00007c  bf00              NOP                            ;6865
00007e  2000              MOVS     r0,#0                 ;6865
000080  f884003c          STRB     r0,[r4,#0x3c]         ;6865
000084  bf00              NOP                            ;6865
000086  2001              MOVS     r0,#1                 ;6867
000088  e7e2              B        |L76.80|
                  |L76.138|
00008a  f3c54007          UBFX     r0,r5,#16,#8          ;6833
00008e  2801              CMP      r0,#1                 ;6833
000090  d10a              BNE      |L76.168|
000092  6820              LDR      r0,[r4,#0]            ;6833
000094  6940              LDR      r0,[r0,#0x14]         ;6833
000096  b2a9              UXTH     r1,r5                 ;6833
000098  4008              ANDS     r0,r0,r1              ;6833
00009a  b2a9              UXTH     r1,r5                 ;6833
00009c  4288              CMP      r0,r1                 ;6833
00009e  d101              BNE      |L76.164|
0000a0  2001              MOVS     r0,#1                 ;6833
0000a2  e00b              B        |L76.188|
                  |L76.164|
0000a4  2000              MOVS     r0,#0                 ;6833
0000a6  e009              B        |L76.188|
                  |L76.168|
0000a8  6820              LDR      r0,[r4,#0]            ;6833
0000aa  6980              LDR      r0,[r0,#0x18]         ;6833
0000ac  b2a9              UXTH     r1,r5                 ;6833
0000ae  4008              ANDS     r0,r0,r1              ;6833
0000b0  b2a9              UXTH     r1,r5                 ;6833
0000b2  4288              CMP      r0,r1                 ;6833
0000b4  d101              BNE      |L76.186|
0000b6  2001              MOVS     r0,#1                 ;6833
0000b8  e000              B        |L76.188|
                  |L76.186|
0000ba  2000              MOVS     r0,#0                 ;6833
                  |L76.188|
0000bc  2800              CMP      r0,#0                 ;6833
0000be  d0a6              BEQ      |L76.14|
0000c0  2000              MOVS     r0,#0                 ;6871
0000c2  e7c5              B        |L76.80|
;;;6873   
                          ENDP


                          AREA ||i.I2C_WaitOnRXNEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnRXNEFlagUntilTimeout PROC
;;;6992     */
;;;6993   static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;6994   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;6995   
;;;6996     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
000008  e032              B        |L77.112|
                  |L77.10|
;;;6997     {
;;;6998       /* Check if a STOPF is detected */
;;;6999       if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
00000a  6820              LDR      r0,[r4,#0]
00000c  6940              LDR      r0,[r0,#0x14]
00000e  f3c01000          UBFX     r0,r0,#4,#1
000012  b1a0              CBZ      r0,|L77.62|
;;;7000       {
;;;7001         /* Clear STOP Flag */
;;;7002         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
000014  f06f0010          MVN      r0,#0x10
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
;;;7003   
;;;7004         hi2c->PreviousState       = I2C_STATE_NONE;
00001c  2000              MOVS     r0,#0
00001e  6320              STR      r0,[r4,#0x30]
;;;7005         hi2c->State               = HAL_I2C_STATE_READY;
000020  2020              MOVS     r0,#0x20
000022  f884003d          STRB     r0,[r4,#0x3d]
;;;7006         hi2c->Mode                = HAL_I2C_MODE_NONE;
000026  2000              MOVS     r0,#0
000028  f884003e          STRB     r0,[r4,#0x3e]
;;;7007         hi2c->ErrorCode           |= HAL_I2C_ERROR_NONE;
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  6420              STR      r0,[r4,#0x40]
;;;7008   
;;;7009         /* Process Unlocked */
;;;7010         __HAL_UNLOCK(hi2c);
000030  bf00              NOP      
000032  2000              MOVS     r0,#0
000034  f884003c          STRB     r0,[r4,#0x3c]
000038  bf00              NOP      
;;;7011   
;;;7012         return HAL_ERROR;
00003a  2001              MOVS     r0,#1
                  |L77.60|
;;;7013       }
;;;7014   
;;;7015       /* Check for the Timeout */
;;;7016       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;7017       {
;;;7018         hi2c->PreviousState       = I2C_STATE_NONE;
;;;7019         hi2c->State               = HAL_I2C_STATE_READY;
;;;7020         hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;7021         hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;7022   
;;;7023         /* Process Unlocked */
;;;7024         __HAL_UNLOCK(hi2c);
;;;7025   
;;;7026         return HAL_ERROR;
;;;7027       }
;;;7028     }
;;;7029     return HAL_OK;
;;;7030   }
00003c  bd70              POP      {r4-r6,pc}
                  |L77.62|
00003e  f7fffffe          BL       HAL_GetTick
000042  1b80              SUBS     r0,r0,r6              ;7016
000044  42a8              CMP      r0,r5                 ;7016
000046  d800              BHI      |L77.74|
000048  b995              CBNZ     r5,|L77.112|
                  |L77.74|
00004a  2000              MOVS     r0,#0                 ;7018
00004c  6320              STR      r0,[r4,#0x30]         ;7018
00004e  2020              MOVS     r0,#0x20              ;7019
000050  f884003d          STRB     r0,[r4,#0x3d]         ;7019
000054  2000              MOVS     r0,#0                 ;7020
000056  f884003e          STRB     r0,[r4,#0x3e]         ;7020
00005a  6c20              LDR      r0,[r4,#0x40]         ;7021
00005c  f0400020          ORR      r0,r0,#0x20           ;7021
000060  6420              STR      r0,[r4,#0x40]         ;7021
000062  bf00              NOP                            ;7024
000064  2000              MOVS     r0,#0                 ;7024
000066  f884003c          STRB     r0,[r4,#0x3c]         ;7024
00006a  bf00              NOP                            ;7024
00006c  2001              MOVS     r0,#1                 ;7026
00006e  e7e5              B        |L77.60|
                  |L77.112|
000070  6820              LDR      r0,[r4,#0]            ;6996
000072  6940              LDR      r0,[r0,#0x14]         ;6996
000074  f3c01080          UBFX     r0,r0,#6,#1           ;6996
000078  2800              CMP      r0,#0                 ;6996
00007a  d0c6              BEQ      |L77.10|
00007c  2000              MOVS     r0,#0                 ;7029
00007e  e7dd              B        |L77.60|
;;;7031   
                          ENDP


                          AREA ||i.I2C_WaitOnSTOPFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnSTOPFlagUntilTimeout PROC
;;;6957     */
;;;6958   static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;6959   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;6960     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
000008  e01e              B        |L78.72|
                  |L78.10|
;;;6961     {
;;;6962       /* Check if a NACK is detected */
;;;6963       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L78.22|
;;;6964       {
;;;6965         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L78.20|
;;;6966       }
;;;6967   
;;;6968       /* Check for the Timeout */
;;;6969       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6970       {
;;;6971         hi2c->PreviousState       = I2C_STATE_NONE;
;;;6972         hi2c->State               = HAL_I2C_STATE_READY;
;;;6973         hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;6974         hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;6975   
;;;6976         /* Process Unlocked */
;;;6977         __HAL_UNLOCK(hi2c);
;;;6978   
;;;6979         return HAL_ERROR;
;;;6980       }
;;;6981     }
;;;6982     return HAL_OK;
;;;6983   }
000014  bd70              POP      {r4-r6,pc}
                  |L78.22|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6              ;6969
00001c  42a8              CMP      r0,r5                 ;6969
00001e  d800              BHI      |L78.34|
000020  b995              CBNZ     r5,|L78.72|
                  |L78.34|
000022  2000              MOVS     r0,#0                 ;6971
000024  6320              STR      r0,[r4,#0x30]         ;6971
000026  2020              MOVS     r0,#0x20              ;6972
000028  f884003d          STRB     r0,[r4,#0x3d]         ;6972
00002c  2000              MOVS     r0,#0                 ;6973
00002e  f884003e          STRB     r0,[r4,#0x3e]         ;6973
000032  6c20              LDR      r0,[r4,#0x40]         ;6974
000034  f0400020          ORR      r0,r0,#0x20           ;6974
000038  6420              STR      r0,[r4,#0x40]         ;6974
00003a  bf00              NOP                            ;6977
00003c  2000              MOVS     r0,#0                 ;6977
00003e  f884003c          STRB     r0,[r4,#0x3c]         ;6977
000042  bf00              NOP                            ;6977
000044  2001              MOVS     r0,#1                 ;6979
000046  e7e5              B        |L78.20|
                  |L78.72|
000048  6820              LDR      r0,[r4,#0]            ;6960
00004a  6940              LDR      r0,[r0,#0x14]         ;6960
00004c  f3c01000          UBFX     r0,r0,#4,#1           ;6960
000050  2800              CMP      r0,#0                 ;6960
000052  d0da              BEQ      |L78.10|
000054  2000              MOVS     r0,#0                 ;6982
000056  e7dd              B        |L78.20|
;;;6984   
                          ENDP


                          AREA ||i.I2C_WaitOnTXEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnTXEFlagUntilTimeout PROC
;;;6881     */
;;;6882   static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;6883   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;6884     while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
000008  e020              B        |L79.76|
                  |L79.10|
;;;6885     {
;;;6886       /* Check if a NACK is detected */
;;;6887       if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L79.22|
;;;6888       {
;;;6889         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L79.20|
;;;6890       }
;;;6891   
;;;6892       /* Check for the Timeout */
;;;6893       if (Timeout != HAL_MAX_DELAY)
;;;6894       {
;;;6895         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
;;;6896         {
;;;6897           hi2c->PreviousState       = I2C_STATE_NONE;
;;;6898           hi2c->State               = HAL_I2C_STATE_READY;
;;;6899           hi2c->Mode                = HAL_I2C_MODE_NONE;
;;;6900           hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
;;;6901   
;;;6902           /* Process Unlocked */
;;;6903           __HAL_UNLOCK(hi2c);
;;;6904   
;;;6905           return HAL_ERROR;
;;;6906         }
;;;6907       }
;;;6908     }
;;;6909     return HAL_OK;
;;;6910   }
000014  bd70              POP      {r4-r6,pc}
                  |L79.22|
000016  1c68              ADDS     r0,r5,#1              ;6893
000018  b1c0              CBZ      r0,|L79.76|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b80              SUBS     r0,r0,r6              ;6895
000020  42a8              CMP      r0,r5                 ;6895
000022  d800              BHI      |L79.38|
000024  b995              CBNZ     r5,|L79.76|
                  |L79.38|
000026  2000              MOVS     r0,#0                 ;6897
000028  6320              STR      r0,[r4,#0x30]         ;6897
00002a  2020              MOVS     r0,#0x20              ;6898
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;6898
000030  2000              MOVS     r0,#0                 ;6899
000032  f884003e          STRB     r0,[r4,#0x3e]         ;6899
000036  6c20              LDR      r0,[r4,#0x40]         ;6900
000038  f0400020          ORR      r0,r0,#0x20           ;6900
00003c  6420              STR      r0,[r4,#0x40]         ;6900
00003e  bf00              NOP                            ;6903
000040  2000              MOVS     r0,#0                 ;6903
000042  f884003c          STRB     r0,[r4,#0x3c]         ;6903
000046  bf00              NOP                            ;6903
000048  2001              MOVS     r0,#1                 ;6905
00004a  e7e3              B        |L79.20|
                  |L79.76|
00004c  6820              LDR      r0,[r4,#0]            ;6884
00004e  6940              LDR      r0,[r0,#0x14]         ;6884
000050  f3c010c0          UBFX     r0,r0,#7,#1           ;6884
000054  2800              CMP      r0,#0                 ;6884
000056  d0d8              BEQ      |L79.10|
000058  2000              MOVS     r0,#0                 ;6909
00005a  e7db              B        |L79.20|
;;;6911   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____RRX|
#line 587
|__asm___19_stm32f4xx_hal_i2c_c_0eb271f4____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
