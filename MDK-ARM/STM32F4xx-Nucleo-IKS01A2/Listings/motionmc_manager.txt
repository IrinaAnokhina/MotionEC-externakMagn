; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\motionmc_manager.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\motionmc_manager.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\Src\MotionMC_Manager.c]
                          THUMB

                          AREA ||i.MotionMC_LoadCalFromNVM||, CODE, READONLY, ALIGN=1

                  MotionMC_LoadCalFromNVM PROC
;;;255     */
;;;256    char MotionMC_LoadCalFromNVM(unsigned short int datasize, unsigned int *data)
000000  4602              MOV      r2,r0
;;;257    {
;;;258      return (char)1; /* FAILURE: Read from NVM not implemented. */
000002  2001              MOVS     r0,#1
;;;259    }
000004  4770              BX       lr
;;;260    
                          ENDP


                          AREA ||i.MotionMC_SaveCalInNVM||, CODE, READONLY, ALIGN=1

                  MotionMC_SaveCalInNVM PROC
;;;268     */
;;;269    char MotionMC_SaveCalInNVM(unsigned short int datasize, unsigned int *data)
000000  4602              MOV      r2,r0
;;;270    {
;;;271      return (char)1; /* FAILURE: Write to NVM not implemented. */
000002  2001              MOVS     r0,#1
;;;272    }
000004  4770              BX       lr
;;;273    
                          ENDP


                          AREA ||i.MotionMC_manager_compensate||, CODE, READONLY, ALIGN=2

                  MotionMC_manager_compensate PROC
;;;197     */
;;;198    void MotionMC_manager_compensate(IKS01A2_MOTION_SENSOR_Axes_t *data_raw, IKS01A2_MOTION_SENSOR_Axes_t *data_comp)
000000  b530              PUSH     {r4,r5,lr}
;;;199    {
000002  b093              SUB      sp,sp,#0x4c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;200    #if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
;;;201      MMC_Output_t data_out;
;;;202    
;;;203      MotionMC_GetCalParams(&data_out);
000008  a806              ADD      r0,sp,#0x18
00000a  f7fffffe          BL       MotionMC_GetCalParams
;;;204    
;;;205    #elif (defined (USE_STM32L0XX_NUCLEO))
;;;206      MMC_CM0P_Output_t data_out;
;;;207    
;;;208      MotionMC_CM0P_GetCalParams(&data_out);
;;;209    
;;;210    #else
;;;211    #error Not supported platform
;;;212    #endif
;;;213    
;;;214      float mag_raw_mG[3];
;;;215      float mag_comp_mG[3];
;;;216    
;;;217      mag_raw_mG[0] = (float)data_raw->x;
00000e  ed940a00          VLDR     s0,[r4,#0]
000012  eeb80ac0          VCVT.F32.S32 s0,s0
000016  ed8d0a03          VSTR     s0,[sp,#0xc]
;;;218      mag_raw_mG[1] = (float)data_raw->y;
00001a  ed940a01          VLDR     s0,[r4,#4]
00001e  eeb80ac0          VCVT.F32.S32 s0,s0
000022  ed8d0a04          VSTR     s0,[sp,#0x10]
;;;219      mag_raw_mG[2] = (float)data_raw->z;
000026  ed940a02          VLDR     s0,[r4,#8]
00002a  eeb80ac0          VCVT.F32.S32 s0,s0
00002e  ed8d0a05          VSTR     s0,[sp,#0x14]
;;;220    
;;;221      /* Compensate magnetometer data */
;;;222      /* NOTE: Convert hard iron coeficients [uT] to [mGauss] */
;;;223      for (int i = 0; i < 3; i++)
000032  2000              MOVS     r0,#0
000034  e04a              B        |L3.204|
                  |L3.54|
;;;224      {
;;;225        mag_comp_mG[i] = 0.0f;
000036  ed9f0a30          VLDR     s0,|L3.248|
00003a  4669              MOV      r1,sp
00003c  eb010180          ADD      r1,r1,r0,LSL #2
000040  ed810a00          VSTR     s0,[r1,#0]
;;;226        for (int j = 0; j < 3; j++)
000044  2100              MOVS     r1,#0
000046  e023              B        |L3.144|
                  |L3.72|
;;;227        {
;;;228    #if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
;;;229          mag_comp_mG[i] += (mag_raw_mG[j] - data_out.HI_Bias[j] * 10.0f) * data_out.SF_Matrix[i][j];
000048  aa03              ADD      r2,sp,#0xc
00004a  eb020281          ADD      r2,r2,r1,LSL #2
00004e  ed920a00          VLDR     s0,[r2,#0]
000052  aa06              ADD      r2,sp,#0x18
000054  eb020281          ADD      r2,r2,r1,LSL #2
000058  edd20a00          VLDR     s1,[r2,#0]
00005c  eeb21a04          VMOV.F32 s2,#10.00000000
000060  ee000ac1          VMLS.F32 s0,s1,s2
000064  eb000340          ADD      r3,r0,r0,LSL #1
000068  aa09              ADD      r2,sp,#0x24
00006a  eb020283          ADD      r2,r2,r3,LSL #2
00006e  eb020281          ADD      r2,r2,r1,LSL #2
000072  ed921a00          VLDR     s2,[r2,#0]
000076  466a              MOV      r2,sp
000078  eb020280          ADD      r2,r2,r0,LSL #2
00007c  edd20a00          VLDR     s1,[r2,#0]
000080  ee400a01          VMLA.F32 s1,s0,s2
000084  466a              MOV      r2,sp
000086  eb020280          ADD      r2,r2,r0,LSL #2
00008a  edc20a00          VSTR     s1,[r2,#0]
00008e  1c49              ADDS     r1,r1,#1              ;226
                  |L3.144|
000090  2903              CMP      r1,#3                 ;226
000092  dbd9              BLT      |L3.72|
;;;230    
;;;231    #elif (defined (USE_STM32L0XX_NUCLEO))
;;;232          mag_comp_mG[i] += (mag_raw_mG[j] - data_out.HI_Bias[j] * 10.0f) * data_out.SI_Matrix[i][j];
;;;233    
;;;234    #else
;;;235    #error Not supported platform
;;;236    #endif
;;;237        }
;;;238    
;;;239        /* MISRA C-2012 rule 10.1_R3 violation for purpose */
;;;240        mag_comp_mG[i] += (mag_comp_mG[i] >= 0.0f) ? 0.5f : -0.5f;
000094  4669              MOV      r1,sp
000096  eb010180          ADD      r1,r1,r0,LSL #2
00009a  ed910a00          VLDR     s0,[r1,#0]
00009e  4669              MOV      r1,sp
0000a0  eb010180          ADD      r1,r1,r0,LSL #2
0000a4  edd10a00          VLDR     s1,[r1,#0]
0000a8  eef50ac0          VCMPE.F32 s1,#0.0
0000ac  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000b0  db02              BLT      |L3.184|
0000b2  eef60a00          VMOV.F32 s1,#0.50000000
0000b6  e001              B        |L3.188|
                  |L3.184|
0000b8  eefe0a00          VMOV.F32 s1,#-0.50000000
                  |L3.188|
0000bc  ee300a20          VADD.F32 s0,s0,s1
0000c0  4669              MOV      r1,sp
0000c2  eb010180          ADD      r1,r1,r0,LSL #2
0000c6  ed810a00          VSTR     s0,[r1,#0]
0000ca  1c40              ADDS     r0,r0,#1              ;223
                  |L3.204|
0000cc  2803              CMP      r0,#3                 ;223
0000ce  dbb2              BLT      |L3.54|
;;;241      }
;;;242    
;;;243      data_comp->x = (int32_t)mag_comp_mG[0];
0000d0  ed9d0a00          VLDR     s0,[sp,#0]
0000d4  eebd0ac0          VCVT.S32.F32 s0,s0
0000d8  ed850a00          VSTR     s0,[r5,#0]
;;;244      data_comp->y = (int32_t)mag_comp_mG[1];
0000dc  ed9d0a01          VLDR     s0,[sp,#4]
0000e0  eebd0ac0          VCVT.S32.F32 s0,s0
0000e4  ed850a01          VSTR     s0,[r5,#4]
;;;245      data_comp->z = (int32_t)mag_comp_mG[2];
0000e8  ed9d0a02          VLDR     s0,[sp,#8]
0000ec  eebd0ac0          VCVT.S32.F32 s0,s0
0000f0  ed850a02          VSTR     s0,[r5,#8]
;;;246    }
0000f4  b013              ADD      sp,sp,#0x4c
0000f6  bd30              POP      {r4,r5,pc}
;;;247    
                          ENDP

                  |L3.248|
0000f8  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.MotionMC_manager_get_params||, CODE, READONLY, ALIGN=1

                  MotionMC_manager_get_params PROC
;;;82      */
;;;83     void MotionMC_manager_get_params(MMC_Output_t *data_out)
000000  b510              PUSH     {r4,lr}
;;;84     {
000002  4604              MOV      r4,r0
;;;85       MotionMC_GetCalParams(data_out);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       MotionMC_GetCalParams
;;;86     }
00000a  bd10              POP      {r4,pc}
;;;87     
                          ENDP


                          AREA ||i.MotionMC_manager_get_version||, CODE, READONLY, ALIGN=1

                  MotionMC_manager_get_version PROC
;;;178     */
;;;179    void MotionMC_manager_get_version(char *version, int *length)
000000  b570              PUSH     {r4-r6,lr}
;;;180    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;181    #if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
;;;182      *length = (int)MotionMC_GetLibVersion(version);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       MotionMC_GetLibVersion
00000c  6020              STR      r0,[r4,#0]
;;;183    
;;;184    #elif (defined (USE_STM32L0XX_NUCLEO))
;;;185      *length = (int)MotionMC_CM0P_GetLibVersion(version);
;;;186    
;;;187    #else
;;;188    #error Not supported platform
;;;189    #endif
;;;190    }
00000e  bd70              POP      {r4-r6,pc}
;;;191    
                          ENDP


                          AREA ||i.MotionMC_manager_init||, CODE, READONLY, ALIGN=1

                  MotionMC_manager_init PROC
;;;62      */
;;;63     void MotionMC_manager_init(int sampletime, unsigned short int enable)
000000  b570              PUSH     {r4-r6,lr}
;;;64     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;65       MotionMC_Initialize(sampletime, enable);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       MotionMC_Initialize
;;;66     }
00000e  bd70              POP      {r4-r6,pc}
;;;67     
                          ENDP


                          AREA ||i.MotionMC_manager_run||, CODE, READONLY, ALIGN=2

                  MotionMC_manager_run PROC
;;;129     */
;;;130    void MotionMC_manager_run(TMsg *Msg)
000000  b510              PUSH     {r4,lr}
;;;131    {
000002  b092              SUB      sp,sp,#0x48
000004  4604              MOV      r4,r0
;;;132    #if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
;;;133      MMC_Input_t  data_in;
;;;134      MMC_Output_t data_out;
;;;135    
;;;136    #elif (defined (USE_STM32L0XX_NUCLEO))
;;;137      MMC_CM0P_Input_t  data_in;
;;;138      MMC_CM0P_Output_t data_out;
;;;139    
;;;140    #else
;;;141    #error Not supported platform
;;;142    #endif
;;;143    
;;;144      /* Convert magnetometer data from [mGauss] to [uT] */
;;;145      data_in.Mag[0] = (float)MagValue.x / 10.0f;
000006  4823              LDR      r0,|L7.148|
000008  ed900a00          VLDR     s0,[r0,#0]
00000c  eeb80ac0          VCVT.F32.S32 s0,s0
000010  eef20a04          VMOV.F32 s1,#10.00000000
000014  ee801a20          VDIV.F32 s2,s0,s1
000018  ed8d1a0e          VSTR     s2,[sp,#0x38]
;;;146      data_in.Mag[1] = (float)MagValue.y / 10.0f;
00001c  ed900a01          VLDR     s0,[r0,#4]
000020  eeb80ac0          VCVT.F32.S32 s0,s0
000024  eef20a04          VMOV.F32 s1,#10.00000000
000028  ee801a20          VDIV.F32 s2,s0,s1
00002c  ed8d1a0f          VSTR     s2,[sp,#0x3c]
;;;147      data_in.Mag[2] = (float)MagValue.z / 10.0f;
000030  ed900a02          VLDR     s0,[r0,#8]
000034  eeb80ac0          VCVT.F32.S32 s0,s0
000038  eef20a04          VMOV.F32 s1,#10.00000000
00003c  ee801a20          VDIV.F32 s2,s0,s1
000040  ed8d1a10          VSTR     s2,[sp,#0x40]
;;;148    
;;;149    #if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
;;;150      /* Time stamp [ms] */
;;;151      data_in.TimeStamp = (int)TimeStamp;
000044  4814              LDR      r0,|L7.152|
000046  6800              LDR      r0,[r0,#0]  ; TimeStamp
000048  9011              STR      r0,[sp,#0x44]
;;;152    #endif
;;;153    
;;;154      /* Run Magnetometer Calibration algorithm */
;;;155      MotionMC_manager_update(&data_in);
00004a  a80e              ADD      r0,sp,#0x38
00004c  f7fffffe          BL       MotionMC_manager_update
;;;156    
;;;157      /* Get the magnetometer compensation for hard/soft iron */
;;;158      MotionMC_manager_get_params(&data_out);
000050  a801              ADD      r0,sp,#4
000052  f7fffffe          BL       MotionMC_manager_get_params
;;;159    
;;;160      /* Do hard & soft iron calibration */
;;;161      MotionMC_manager_compensate(&MagValue, &MagValueComp);
000056  4911              LDR      r1,|L7.156|
000058  480e              LDR      r0,|L7.148|
00005a  f7fffffe          BL       MotionMC_manager_compensate
;;;162    
;;;163      /* Calibrated data */
;;;164      /* NOTE: Magnetometer data unit is [mGauss] */
;;;165      Serialize_s32(&Msg->Data[43], MagValueComp.x, 4);
00005e  480f              LDR      r0,|L7.156|
000060  2204              MOVS     r2,#4
000062  6801              LDR      r1,[r0,#0]  ; MagValueComp
000064  f104002f          ADD      r0,r4,#0x2f
000068  f7fffffe          BL       Serialize_s32
;;;166      Serialize_s32(&Msg->Data[47], MagValueComp.y, 4);
00006c  480b              LDR      r0,|L7.156|
00006e  2204              MOVS     r2,#4
000070  6841              LDR      r1,[r0,#4]  ; MagValueComp
000072  f1040033          ADD      r0,r4,#0x33
000076  f7fffffe          BL       Serialize_s32
;;;167      Serialize_s32(&Msg->Data[51], MagValueComp.z, 4);
00007a  4808              LDR      r0,|L7.156|
00007c  2204              MOVS     r2,#4
00007e  6881              LDR      r1,[r0,#8]  ; MagValueComp
000080  f1040037          ADD      r0,r4,#0x37
000084  f7fffffe          BL       Serialize_s32
;;;168    
;;;169      /* Calibration quality */
;;;170      Msg->Data[124] = (uint8_t)data_out.CalQuality;
000088  f89d1034          LDRB     r1,[sp,#0x34]
00008c  f8841080          STRB     r1,[r4,#0x80]
;;;171    }
000090  b012              ADD      sp,sp,#0x48
000092  bd10              POP      {r4,pc}
;;;172    
                          ENDP

                  |L7.148|
                          DCD      MagValue
                  |L7.152|
                          DCD      TimeStamp
                  |L7.156|
                          DCD      MagValueComp

                          AREA ||i.MotionMC_manager_update||, CODE, READONLY, ALIGN=1

                  MotionMC_manager_update PROC
;;;72      */
;;;73     void MotionMC_manager_update(MMC_Input_t *data_in)
000000  b510              PUSH     {r4,lr}
;;;74     {
000002  4604              MOV      r4,r0
;;;75       MotionMC_Update(data_in);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       MotionMC_Update
;;;76     }
00000a  bd10              POP      {r4,pc}
;;;77     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  TimeStamp
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Src\\MotionMC_Manager.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MotionMC_Manager_c_e6e64b99____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___18_MotionMC_Manager_c_e6e64b99____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MotionMC_Manager_c_e6e64b99____REVSH|
#line 402
|__asm___18_MotionMC_Manager_c_e6e64b99____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_MotionMC_Manager_c_e6e64b99____RRX|
#line 587
|__asm___18_MotionMC_Manager_c_e6e64b99____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
