; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\hts221.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\hts221.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\BSP\Components\hts221\hts221.c]
                          THUMB

                          AREA ||i.HTS221_DeInit||, CODE, READONLY, ALIGN=1

                  HTS221_DeInit PROC
;;;168     */
;;;169    int32_t HTS221_DeInit(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;170    {
000002  4604              MOV      r4,r0
;;;171      if (pObj->is_initialized == 1U)
000004  f8940028          LDRB     r0,[r4,#0x28]
000008  2801              CMP      r0,#1
00000a  d10d              BNE      |L1.40|
;;;172      {
;;;173        if (HTS221_HUM_Disable(pObj) != HTS221_OK)
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HTS221_HUM_Disable
000012  b110              CBZ      r0,|L1.26|
;;;174        {
;;;175          return HTS221_ERROR;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L1.24|
;;;176        }
;;;177    
;;;178        if (HTS221_TEMP_Disable(pObj) != HTS221_OK)
;;;179        {
;;;180          return HTS221_ERROR;
;;;181        }
;;;182      }
;;;183    
;;;184      pObj->is_initialized = 0;
;;;185    
;;;186      return HTS221_OK;
;;;187    }
000018  bd10              POP      {r4,pc}
                  |L1.26|
00001a  4620              MOV      r0,r4                 ;178
00001c  f7fffffe          BL       HTS221_TEMP_Disable
000020  b110              CBZ      r0,|L1.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;180
000026  e7f7              B        |L1.24|
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;184
00002a  f8840028          STRB     r0,[r4,#0x28]         ;184
00002e  bf00              NOP                            ;186
000030  e7f2              B        |L1.24|
;;;188    
                          ENDP


                          AREA ||i.HTS221_Enable_DRDY_Interrupt||, CODE, READONLY, ALIGN=1

                  HTS221_Enable_DRDY_Interrupt PROC
;;;744     */
;;;745    int32_t HTS221_Enable_DRDY_Interrupt(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;746    {
000002  4604              MOV      r4,r0
;;;747      if (hts221_drdy_on_int_set(&(pObj->Ctx), PROPERTY_ENABLE) != HTS221_OK)
000004  2101              MOVS     r1,#1
000006  f104001c          ADD      r0,r4,#0x1c
00000a  f7fffffe          BL       hts221_drdy_on_int_set
00000e  b110              CBZ      r0,|L2.22|
;;;748      {
;;;749        return HTS221_ERROR;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L2.20|
;;;750      }  
;;;751      
;;;752      return HTS221_OK;
;;;753    }
000014  bd10              POP      {r4,pc}
                  |L2.22|
000016  2000              MOVS     r0,#0                 ;752
000018  e7fc              B        |L2.20|
;;;754    
                          ENDP


                          AREA ||i.HTS221_GetCapabilities||, CODE, READONLY, ALIGN=2

                  HTS221_GetCapabilities PROC
;;;210     */
;;;211    int32_t HTS221_GetCapabilities(HTS221_Object_t *pObj, HTS221_Capabilities_t *Capabilities)
000000  4602              MOV      r2,r0
;;;212    {
;;;213      /* Prevent unused argument(s) compilation warning */
;;;214      (void)(pObj);
;;;215    
;;;216      Capabilities->Humidity    = 1;
000002  2001              MOVS     r0,#1
000004  7088              STRB     r0,[r1,#2]
;;;217      Capabilities->Pressure    = 0;
000006  2000              MOVS     r0,#0
000008  7048              STRB     r0,[r1,#1]
;;;218      Capabilities->Temperature = 1;
00000a  2001              MOVS     r0,#1
00000c  7008              STRB     r0,[r1,#0]
;;;219      Capabilities->LowPower    = 0;
00000e  2000              MOVS     r0,#0
000010  70c8              STRB     r0,[r1,#3]
;;;220      Capabilities->HumMaxOdr   = 12.5f;
000012  eeb20a09          VMOV.F32 s0,#12.50000000
000016  ed810a01          VSTR     s0,[r1,#4]
;;;221      Capabilities->TempMaxOdr  = 12.5f;
00001a  eeb20a09          VMOV.F32 s0,#12.50000000
00001e  ed810a02          VSTR     s0,[r1,#8]
;;;222      Capabilities->PressMaxOdr = 0.0f;
000022  ed9f0a02          VLDR     s0,|L3.44|
000026  ed810a03          VSTR     s0,[r1,#0xc]
;;;223      return HTS221_OK;
;;;224    }
00002a  4770              BX       lr
;;;225    
                          ENDP

                  |L3.44|
00002c  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.HTS221_GetOutputDataRate||, CODE, READONLY, ALIGN=2

                  HTS221_GetOutputDataRate PROC
;;;653     */
;;;654    static int32_t HTS221_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;655    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;656      int32_t ret = HTS221_OK;
000006  2600              MOVS     r6,#0
;;;657      hts221_odr_t odr_low_level;
;;;658    
;;;659      if (hts221_data_rate_get(&(pObj->Ctx), &odr_low_level) != HTS221_OK)
000008  4669              MOV      r1,sp
00000a  f105001c          ADD      r0,r5,#0x1c
00000e  f7fffffe          BL       hts221_data_rate_get
000012  b108              CBZ      r0,|L4.24|
;;;660      {
;;;661        return HTS221_ERROR;
000014  1e70              SUBS     r0,r6,#1
                  |L4.22|
;;;662      }
;;;663    
;;;664      switch (odr_low_level)
;;;665      {
;;;666        case HTS221_ONE_SHOT:
;;;667          *Odr = 0.0f;
;;;668          break;
;;;669    
;;;670        case HTS221_ODR_1Hz:
;;;671          *Odr = 1.0f;
;;;672          break;
;;;673    
;;;674        case HTS221_ODR_7Hz:
;;;675          *Odr = 7.0f;
;;;676          break;
;;;677    
;;;678        case HTS221_ODR_12Hz5:
;;;679          *Odr = 12.5f;
;;;680          break;
;;;681    
;;;682        default:
;;;683          ret = HTS221_ERROR;
;;;684          break;
;;;685      }
;;;686    
;;;687      return ret;
;;;688    }
000016  bdf8              POP      {r3-r7,pc}
                  |L4.24|
000018  f89d0000          LDRB     r0,[sp,#0]            ;664
00001c  b130              CBZ      r0,|L4.44|
00001e  2801              CMP      r0,#1                 ;664
000020  d009              BEQ      |L4.54|
000022  2802              CMP      r0,#2                 ;664
000024  d00c              BEQ      |L4.64|
000026  2803              CMP      r0,#3                 ;664
000028  d114              BNE      |L4.84|
00002a  e00e              B        |L4.74|
                  |L4.44|
00002c  ed9f0a0c          VLDR     s0,|L4.96|
000030  ed840a00          VSTR     s0,[r4,#0]            ;667
000034  e011              B        |L4.90|
                  |L4.54|
000036  eeb70a00          VMOV.F32 s0,#1.00000000        ;671
00003a  ed840a00          VSTR     s0,[r4,#0]            ;671
00003e  e00c              B        |L4.90|
                  |L4.64|
000040  eeb10a0c          VMOV.F32 s0,#7.00000000        ;675
000044  ed840a00          VSTR     s0,[r4,#0]            ;675
000048  e007              B        |L4.90|
                  |L4.74|
00004a  eeb20a09          VMOV.F32 s0,#12.50000000       ;679
00004e  ed840a00          VSTR     s0,[r4,#0]            ;679
000052  e002              B        |L4.90|
                  |L4.84|
000054  f04f36ff          MOV      r6,#0xffffffff        ;683
000058  bf00              NOP                            ;684
                  |L4.90|
00005a  bf00              NOP                            ;668
00005c  4630              MOV      r0,r6                 ;687
00005e  e7da              B        |L4.22|
;;;689    
                          ENDP

                  |L4.96|
000060  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.HTS221_Get_Init_Status||, CODE, READONLY, ALIGN=1

                  HTS221_Get_Init_Status PROC
;;;231     */
;;;232    int32_t HTS221_Get_Init_Status(HTS221_Object_t *pObj, uint8_t *Status)
000000  4602              MOV      r2,r0
;;;233    {
;;;234      if (pObj == NULL)
000002  b912              CBNZ     r2,|L5.10|
;;;235      {
;;;236        return HTS221_ERROR;
000004  f04f30ff          MOV      r0,#0xffffffff
                  |L5.8|
;;;237      }
;;;238    
;;;239      *Status = pObj->is_initialized;
;;;240    
;;;241      return HTS221_OK;
;;;242    }
000008  4770              BX       lr
                  |L5.10|
00000a  f8920028          LDRB     r0,[r2,#0x28]         ;239
00000e  7008              STRB     r0,[r1,#0]            ;239
000010  2000              MOVS     r0,#0                 ;241
000012  e7f9              B        |L5.8|
;;;243    
                          ENDP


                          AREA ||i.HTS221_Get_One_Shot_Status||, CODE, READONLY, ALIGN=1

                  HTS221_Get_One_Shot_Status PROC
;;;576     */
;;;577    int32_t HTS221_Get_One_Shot_Status(HTS221_Object_t *pObj, uint8_t *Status)
000000  b57c              PUSH     {r2-r6,lr}
;;;578    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;579      uint8_t h_da;
;;;580      uint8_t t_da;
;;;581    
;;;582      /* Get DataReady for humidity */
;;;583      if(hts221_hum_data_ready_get(&(pObj->Ctx), &h_da) != HTS221_OK)
000006  a901              ADD      r1,sp,#4
000008  f105001c          ADD      r0,r5,#0x1c
00000c  f7fffffe          BL       hts221_hum_data_ready_get
000010  b110              CBZ      r0,|L6.24|
;;;584      {
;;;585        return HTS221_ERROR;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L6.22|
;;;586      }
;;;587    
;;;588      /* Get DataReady for temperature */
;;;589      if(hts221_temp_data_ready_get(&(pObj->Ctx), &t_da) != HTS221_OK)
;;;590      {
;;;591        return HTS221_ERROR;
;;;592      }
;;;593    
;;;594      if(h_da && t_da)
;;;595      {
;;;596        *Status = 1;
;;;597      }
;;;598      else
;;;599      {
;;;600        *Status = 0;
;;;601      }
;;;602    
;;;603      return HTS221_OK;
;;;604    }
000016  bd7c              POP      {r2-r6,pc}
                  |L6.24|
000018  4669              MOV      r1,sp                 ;589
00001a  f105001c          ADD      r0,r5,#0x1c           ;589
00001e  f7fffffe          BL       hts221_temp_data_ready_get
000022  b110              CBZ      r0,|L6.42|
000024  f04f30ff          MOV      r0,#0xffffffff        ;591
000028  e7f5              B        |L6.22|
                  |L6.42|
00002a  f89d0004          LDRB     r0,[sp,#4]            ;594
00002e  b128              CBZ      r0,|L6.60|
000030  f89d0000          LDRB     r0,[sp,#0]            ;594
000034  b110              CBZ      r0,|L6.60|
000036  2001              MOVS     r0,#1                 ;596
000038  7020              STRB     r0,[r4,#0]            ;596
00003a  e001              B        |L6.64|
                  |L6.60|
00003c  2000              MOVS     r0,#0                 ;600
00003e  7020              STRB     r0,[r4,#0]            ;600
                  |L6.64|
000040  2000              MOVS     r0,#0                 ;603
000042  e7e8              B        |L6.22|
;;;605    
                          ENDP


                          AREA ||i.HTS221_HUM_Disable||, CODE, READONLY, ALIGN=1

                  HTS221_HUM_Disable PROC
;;;277     */
;;;278    int32_t HTS221_HUM_Disable(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;279    {
000002  4604              MOV      r4,r0
;;;280      /* Check if the component is already disabled */
;;;281      if (pObj->hum_is_enabled == 0U)
000004  f8940029          LDRB     r0,[r4,#0x29]
000008  b908              CBNZ     r0,|L7.14|
;;;282      {
;;;283        return HTS221_OK;
00000a  2000              MOVS     r0,#0
                  |L7.12|
;;;284      }
;;;285    
;;;286      /* Check if the HTS221 temperature sensor is still enable. */
;;;287      /* If yes, skip the disable function, if not call disable function */
;;;288      if (pObj->temp_is_enabled == 0U)
;;;289      {
;;;290        /* Power off the component. */
;;;291        if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_DISABLE) != HTS221_OK)
;;;292        {
;;;293          return HTS221_ERROR;
;;;294        }
;;;295      }
;;;296    
;;;297      pObj->hum_is_enabled = 0;
;;;298    
;;;299      return HTS221_OK;
;;;300    }
00000c  bd10              POP      {r4,pc}
                  |L7.14|
00000e  f894002a          LDRB     r0,[r4,#0x2a]         ;288
000012  b940              CBNZ     r0,|L7.38|
000014  2100              MOVS     r1,#0                 ;291
000016  f104001c          ADD      r0,r4,#0x1c           ;291
00001a  f7fffffe          BL       hts221_power_on_set
00001e  b110              CBZ      r0,|L7.38|
000020  f04f30ff          MOV      r0,#0xffffffff        ;293
000024  e7f2              B        |L7.12|
                  |L7.38|
000026  2000              MOVS     r0,#0                 ;297
000028  f8840029          STRB     r0,[r4,#0x29]         ;297
00002c  bf00              NOP                            ;299
00002e  e7ed              B        |L7.12|
;;;301    
                          ENDP


                          AREA ||i.HTS221_HUM_Enable||, CODE, READONLY, ALIGN=1

                  HTS221_HUM_Enable PROC
;;;248     */
;;;249    int32_t HTS221_HUM_Enable(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;250    {
000002  4604              MOV      r4,r0
;;;251      /* Check if the component is already enabled */
;;;252      if (pObj->hum_is_enabled == 1U)
000004  f8940029          LDRB     r0,[r4,#0x29]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L8.16|
;;;253      {
;;;254        return HTS221_OK;
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;255      }
;;;256    
;;;257      /* Check if the HTS221 temperature sensor is already enabled. */
;;;258      /* If yes, skip the enable function, if not call enable function */
;;;259      if (pObj->temp_is_enabled == 0U)
;;;260      {
;;;261        /* Power on the component. */
;;;262        if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_ENABLE) != HTS221_OK)
;;;263        {
;;;264          return HTS221_ERROR;
;;;265        }
;;;266      }
;;;267    
;;;268      pObj->hum_is_enabled = 1;
;;;269    
;;;270      return HTS221_OK;
;;;271    }
00000e  bd10              POP      {r4,pc}
                  |L8.16|
000010  f894002a          LDRB     r0,[r4,#0x2a]         ;259
000014  b940              CBNZ     r0,|L8.40|
000016  2101              MOVS     r1,#1                 ;262
000018  f104001c          ADD      r0,r4,#0x1c           ;262
00001c  f7fffffe          BL       hts221_power_on_set
000020  b110              CBZ      r0,|L8.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;264
000026  e7f2              B        |L8.14|
                  |L8.40|
000028  2001              MOVS     r0,#1                 ;268
00002a  f8840029          STRB     r0,[r4,#0x29]         ;268
00002e  2000              MOVS     r0,#0                 ;270
000030  e7ed              B        |L8.14|
;;;272    
                          ENDP


                          AREA ||i.HTS221_HUM_GetHumidity||, CODE, READONLY, ALIGN=2

                  HTS221_HUM_GetHumidity PROC
;;;329     */
;;;330    int32_t HTS221_HUM_GetHumidity(HTS221_Object_t *pObj, float *Value)
000000  b530              PUSH     {r4,r5,lr}
;;;331    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;332      axis1bit16_t data_raw_humidity;
;;;333      axis1bit16_t coeff;
;;;334      lin_t lin_hum;
;;;335    
;;;336      if (hts221_hum_adc_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
000008  a905              ADD      r1,sp,#0x14
00000a  f104001c          ADD      r0,r4,#0x1c
00000e  f7fffffe          BL       hts221_hum_adc_point_0_get
000012  b118              CBZ      r0,|L9.28|
;;;337      {
;;;338        return HTS221_ERROR;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L9.24|
;;;339      }
;;;340    
;;;341      lin_hum.x0 = (float)coeff.i16bit;
;;;342    
;;;343      if (hts221_hum_rh_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
;;;344      {
;;;345        return HTS221_ERROR;
;;;346      }
;;;347    
;;;348      lin_hum.y0 = (float)coeff.u8bit[0];
;;;349    
;;;350      if (hts221_hum_adc_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
;;;351      {
;;;352        return HTS221_ERROR;
;;;353      }
;;;354    
;;;355      lin_hum.x1 = (float)coeff.i16bit;
;;;356    
;;;357      if (hts221_hum_rh_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
;;;358      {
;;;359        return HTS221_ERROR;
;;;360      }
;;;361    
;;;362      lin_hum.y1 = (float)coeff.u8bit[0];
;;;363    
;;;364      (void)memset(data_raw_humidity.u8bit, 0x00, sizeof(int16_t));
;;;365      if (hts221_humidity_raw_get(&(pObj->Ctx), data_raw_humidity.u8bit) != HTS221_OK)
;;;366      {
;;;367        return HTS221_ERROR;
;;;368      }
;;;369    
;;;370      *Value = Linear_Interpolation(&lin_hum, (float)data_raw_humidity.i16bit);
;;;371    
;;;372      if (*Value < 0.0f)
;;;373      {
;;;374        *Value = 0.0f;
;;;375      }
;;;376    
;;;377      if (*Value > 100.0f)
;;;378      {
;;;379        *Value = 100.0f;
;;;380      }
;;;381    
;;;382      return HTS221_OK;
;;;383    }
000018  b007              ADD      sp,sp,#0x1c
00001a  bd30              POP      {r4,r5,pc}
                  |L9.28|
00001c  f9bd0014          LDRSH    r0,[sp,#0x14]         ;341
000020  ee000a10          VMOV     s0,r0                 ;341
000024  eeb80ac0          VCVT.F32.S32 s0,s0                 ;341
000028  ed8d0a01          VSTR     s0,[sp,#4]            ;341
00002c  a905              ADD      r1,sp,#0x14           ;343
00002e  f104001c          ADD      r0,r4,#0x1c           ;343
000032  f7fffffe          BL       hts221_hum_rh_point_0_get
000036  b110              CBZ      r0,|L9.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;345
00003c  e7ec              B        |L9.24|
                  |L9.62|
00003e  f89d0014          LDRB     r0,[sp,#0x14]         ;348
000042  ee000a10          VMOV     s0,r0                 ;348
000046  eeb80a40          VCVT.F32.U32 s0,s0                 ;348
00004a  ed8d0a02          VSTR     s0,[sp,#8]            ;348
00004e  a905              ADD      r1,sp,#0x14           ;350
000050  f104001c          ADD      r0,r4,#0x1c           ;350
000054  f7fffffe          BL       hts221_hum_adc_point_1_get
000058  b110              CBZ      r0,|L9.96|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;352
00005e  e7db              B        |L9.24|
                  |L9.96|
000060  f9bd0014          LDRSH    r0,[sp,#0x14]         ;355
000064  ee000a10          VMOV     s0,r0                 ;355
000068  eeb80ac0          VCVT.F32.S32 s0,s0                 ;355
00006c  ed8d0a03          VSTR     s0,[sp,#0xc]          ;355
000070  a905              ADD      r1,sp,#0x14           ;357
000072  f104001c          ADD      r0,r4,#0x1c           ;357
000076  f7fffffe          BL       hts221_hum_rh_point_1_get
00007a  b110              CBZ      r0,|L9.130|
00007c  f04f30ff          MOV      r0,#0xffffffff        ;359
000080  e7ca              B        |L9.24|
                  |L9.130|
000082  f89d0014          LDRB     r0,[sp,#0x14]         ;362
000086  ee000a10          VMOV     s0,r0                 ;362
00008a  eeb80a40          VCVT.F32.U32 s0,s0                 ;362
00008e  ed8d0a04          VSTR     s0,[sp,#0x10]         ;362
000092  2000              MOVS     r0,#0                 ;364
000094  9006              STR      r0,[sp,#0x18]         ;364
000096  a906              ADD      r1,sp,#0x18           ;365
000098  f104001c          ADD      r0,r4,#0x1c           ;365
00009c  f7fffffe          BL       hts221_humidity_raw_get
0000a0  b110              CBZ      r0,|L9.168|
0000a2  f04f30ff          MOV      r0,#0xffffffff        ;367
0000a6  e7b7              B        |L9.24|
                  |L9.168|
0000a8  f9bd0018          LDRSH    r0,[sp,#0x18]         ;370
0000ac  ee000a90          VMOV     s1,r0                 ;370
0000b0  eef80ae0          VCVT.F32.S32 s1,s1                 ;370
0000b4  eeb00a60          VMOV.F32 s0,s1                 ;370
0000b8  a801              ADD      r0,sp,#4              ;370
0000ba  f7fffffe          BL       Linear_Interpolation
0000be  ed850a00          VSTR     s0,[r5,#0]            ;370
0000c2  ed950a00          VLDR     s0,[r5,#0]            ;372
0000c6  eeb50ac0          VCMPE.F32 s0,#0.0               ;372
0000ca  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;372
0000ce  d203              BCS      |L9.216|
0000d0  ed9f0a09          VLDR     s0,|L9.248|
0000d4  ed850a00          VSTR     s0,[r5,#0]            ;374
                  |L9.216|
0000d8  ed950a00          VLDR     s0,[r5,#0]            ;377
0000dc  eddf0a07          VLDR     s1,|L9.252|
0000e0  eeb40ae0          VCMPE.F32 s0,s1                 ;377
0000e4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;377
0000e8  dd03              BLE      |L9.242|
0000ea  ed9f0a04          VLDR     s0,|L9.252|
0000ee  ed850a00          VSTR     s0,[r5,#0]            ;379
                  |L9.242|
0000f2  2000              MOVS     r0,#0                 ;382
0000f4  e790              B        |L9.24|
;;;384    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L9.248|
0000f8  00000000          DCFS     0x00000000 ; 0
                  |L9.252|
0000fc  42c80000          DCFS     0x42c80000 ; 100

                          AREA ||i.HTS221_HUM_GetOutputDataRate||, CODE, READONLY, ALIGN=1

                  HTS221_HUM_GetOutputDataRate PROC
;;;307     */
;;;308    int32_t HTS221_HUM_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)
000000  b570              PUSH     {r4-r6,lr}
;;;309    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;310      return HTS221_GetOutputDataRate(pObj, Odr);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       HTS221_GetOutputDataRate
;;;311    }
00000e  bd70              POP      {r4-r6,pc}
;;;312    
                          ENDP


                          AREA ||i.HTS221_HUM_Get_DRDY_Status||, CODE, READONLY, ALIGN=1

                  HTS221_HUM_Get_DRDY_Status PROC
;;;390     */
;;;391    int32_t HTS221_HUM_Get_DRDY_Status(HTS221_Object_t *pObj, uint8_t *Status)
000000  b570              PUSH     {r4-r6,lr}
;;;392    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;393      if (hts221_hum_data_ready_get(&(pObj->Ctx), Status) != HTS221_OK)
000006  4629              MOV      r1,r5
000008  f104001c          ADD      r0,r4,#0x1c
00000c  f7fffffe          BL       hts221_hum_data_ready_get
000010  b110              CBZ      r0,|L11.24|
;;;394      {
;;;395        return HTS221_ERROR;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L11.22|
;;;396      }
;;;397    
;;;398      return HTS221_OK;
;;;399    }
000016  bd70              POP      {r4-r6,pc}
                  |L11.24|
000018  2000              MOVS     r0,#0                 ;398
00001a  e7fc              B        |L11.22|
;;;400    
                          ENDP


                          AREA ||i.HTS221_HUM_SetOutputDataRate||, CODE, READONLY, ALIGN=1

                  HTS221_HUM_SetOutputDataRate PROC
;;;318     */
;;;319    int32_t HTS221_HUM_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)
000000  b510              PUSH     {r4,lr}
;;;320    {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
000008  eeb08a40          VMOV.F32 s16,s0
;;;321      return HTS221_SetOutputDataRate(pObj, Odr);
00000c  eeb00a48          VMOV.F32 s0,s16
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HTS221_SetOutputDataRate
;;;322    }
000016  ecbd8b02          VPOP     {d8}
00001a  bd10              POP      {r4,pc}
;;;323    
                          ENDP


                          AREA ||i.HTS221_Init||, CODE, READONLY, ALIGN=1

                  HTS221_Init PROC
;;;148     */
;;;149    int32_t HTS221_Init(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;150    {
000002  4604              MOV      r4,r0
;;;151      if (pObj->is_initialized == 0U)
000004  f8940028          LDRB     r0,[r4,#0x28]
000008  b930              CBNZ     r0,|L13.24|
;;;152      {
;;;153        if (HTS221_Initialize(pObj) != HTS221_OK)
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       HTS221_Initialize
000010  b110              CBZ      r0,|L13.24|
;;;154        {
;;;155          return HTS221_ERROR;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L13.22|
;;;156        }
;;;157      }
;;;158    
;;;159      pObj->is_initialized = 1;
;;;160    
;;;161      return HTS221_OK;
;;;162    }
000016  bd10              POP      {r4,pc}
                  |L13.24|
000018  2001              MOVS     r0,#1                 ;159
00001a  f8840028          STRB     r0,[r4,#0x28]         ;159
00001e  2000              MOVS     r0,#0                 ;161
000020  e7f9              B        |L13.22|
;;;163    
                          ENDP


                          AREA ||i.HTS221_Initialize||, CODE, READONLY, ALIGN=1

                  HTS221_Initialize PROC
;;;716     */
;;;717    static int32_t HTS221_Initialize(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;718    {
000002  4604              MOV      r4,r0
;;;719      /* Power off the component. */
;;;720      if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_DISABLE) != HTS221_OK)
000004  2100              MOVS     r1,#0
000006  f104001c          ADD      r0,r4,#0x1c
00000a  f7fffffe          BL       hts221_power_on_set
00000e  b110              CBZ      r0,|L14.22|
;;;721      {
;;;722        return HTS221_ERROR;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L14.20|
;;;723      }
;;;724    
;;;725      /* Enable BDU */
;;;726      if (hts221_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != HTS221_OK)
;;;727      {
;;;728        return HTS221_ERROR;
;;;729      }
;;;730    
;;;731      /* Set default ODR */
;;;732      if (HTS221_SetOutputDataRate(pObj, 1.0f) != HTS221_OK)
;;;733      {
;;;734        return HTS221_ERROR;
;;;735      }
;;;736    
;;;737      return HTS221_OK;
;;;738    }
000014  bd10              POP      {r4,pc}
                  |L14.22|
000016  2101              MOVS     r1,#1                 ;726
000018  f104001c          ADD      r0,r4,#0x1c           ;726
00001c  f7fffffe          BL       hts221_block_data_update_set
000020  b110              CBZ      r0,|L14.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;728
000026  e7f5              B        |L14.20|
                  |L14.40|
000028  eeb70a00          VMOV.F32 s0,#1.00000000        ;732
00002c  4620              MOV      r0,r4                 ;732
00002e  f7fffffe          BL       HTS221_SetOutputDataRate
000032  b110              CBZ      r0,|L14.58|
000034  f04f30ff          MOV      r0,#0xffffffff        ;734
000038  e7ec              B        |L14.20|
                  |L14.58|
00003a  2000              MOVS     r0,#0                 ;737
00003c  e7ea              B        |L14.20|
;;;739    
                          ENDP


                          AREA ||i.HTS221_ReadID||, CODE, READONLY, ALIGN=1

                  HTS221_ReadID PROC
;;;194     */
;;;195    int32_t HTS221_ReadID(HTS221_Object_t *pObj, uint8_t *Id)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;197      if (hts221_device_id_get(&(pObj->Ctx), Id) != HTS221_OK)
000006  4629              MOV      r1,r5
000008  f104001c          ADD      r0,r4,#0x1c
00000c  f7fffffe          BL       hts221_device_id_get
000010  b110              CBZ      r0,|L15.24|
;;;198      {
;;;199        return HTS221_ERROR;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L15.22|
;;;200      }
;;;201    
;;;202      return HTS221_OK;
;;;203    }
000016  bd70              POP      {r4-r6,pc}
                  |L15.24|
000018  2000              MOVS     r0,#0                 ;202
00001a  e7fc              B        |L15.22|
;;;204    
                          ENDP


                          AREA ||i.HTS221_Read_Reg||, CODE, READONLY, ALIGN=1

                  HTS221_Read_Reg PROC
;;;612     */
;;;613    int32_t HTS221_Read_Reg(HTS221_Object_t *pObj, uint8_t Reg, uint8_t *Data)
000000  b570              PUSH     {r4-r6,lr}
;;;614    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;615      if (hts221_read_reg(&(pObj->Ctx), Reg, Data, 1) != HTS221_OK)
000008  2301              MOVS     r3,#1
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  f104001c          ADD      r0,r4,#0x1c
000012  f7fffffe          BL       hts221_read_reg
000016  b110              CBZ      r0,|L16.30|
;;;616      {
;;;617        return HTS221_ERROR;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L16.28|
;;;618      }
;;;619    
;;;620      return HTS221_OK;
;;;621    }
00001c  bd70              POP      {r4-r6,pc}
                  |L16.30|
00001e  2000              MOVS     r0,#0                 ;620
000020  e7fc              B        |L16.28|
;;;622    
                          ENDP


                          AREA ||i.HTS221_RegisterBusIO||, CODE, READONLY, ALIGN=2

                  HTS221_RegisterBusIO PROC
;;;108     */
;;;109    int32_t HTS221_RegisterBusIO(HTS221_Object_t *pObj, HTS221_IO_t *pIO)
000000  b570              PUSH     {r4-r6,lr}
;;;110    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;111      int32_t ret;
;;;112    
;;;113      if (pObj == NULL)
000006  b914              CBNZ     r4,|L17.14|
;;;114      {
;;;115        ret = HTS221_ERROR;
000008  f04f30ff          MOV      r0,#0xffffffff
00000c  e019              B        |L17.66|
                  |L17.14|
;;;116      }
;;;117      else
;;;118      {
;;;119        pObj->IO.Init      = pIO->Init;
00000e  6829              LDR      r1,[r5,#0]
000010  6021              STR      r1,[r4,#0]
;;;120        pObj->IO.DeInit    = pIO->DeInit;
000012  6869              LDR      r1,[r5,#4]
000014  6061              STR      r1,[r4,#4]
;;;121        pObj->IO.BusType   = pIO->BusType;
000016  68a9              LDR      r1,[r5,#8]
000018  60a1              STR      r1,[r4,#8]
;;;122        pObj->IO.Address   = pIO->Address;
00001a  7b29              LDRB     r1,[r5,#0xc]
00001c  7321              STRB     r1,[r4,#0xc]
;;;123        pObj->IO.WriteReg  = pIO->WriteReg;
00001e  6929              LDR      r1,[r5,#0x10]
000020  6121              STR      r1,[r4,#0x10]
;;;124        pObj->IO.ReadReg   = pIO->ReadReg;
000022  6969              LDR      r1,[r5,#0x14]
000024  6161              STR      r1,[r4,#0x14]
;;;125        pObj->IO.GetTick   = pIO->GetTick;
000026  69a9              LDR      r1,[r5,#0x18]
000028  61a1              STR      r1,[r4,#0x18]
;;;126    
;;;127        pObj->Ctx.read_reg  = ReadRegWrap;
00002a  4a06              LDR      r2,|L17.68|
00002c  6222              STR      r2,[r4,#0x20]
;;;128        pObj->Ctx.write_reg = WriteRegWrap;
00002e  4906              LDR      r1,|L17.72|
000030  61e1              STR      r1,[r4,#0x1c]
;;;129        pObj->Ctx.handle   = pObj;
000032  6264              STR      r4,[r4,#0x24]
;;;130    
;;;131        if (pObj->IO.Init != NULL)
000034  6821              LDR      r1,[r4,#0]
000036  b111              CBZ      r1,|L17.62|
;;;132        {
;;;133          ret = pObj->IO.Init();
000038  6821              LDR      r1,[r4,#0]
00003a  4788              BLX      r1
00003c  e001              B        |L17.66|
                  |L17.62|
;;;134        }
;;;135        else
;;;136        {
;;;137          ret = HTS221_ERROR;
00003e  f04f30ff          MOV      r0,#0xffffffff
                  |L17.66|
;;;138        }
;;;139      }
;;;140    
;;;141      return ret;
;;;142    }
000042  bd70              POP      {r4-r6,pc}
;;;143    
                          ENDP

                  |L17.68|
                          DCD      ReadRegWrap
                  |L17.72|
                          DCD      WriteRegWrap

                          AREA ||i.HTS221_SetOutputDataRate||, CODE, READONLY, ALIGN=1

                  HTS221_SetOutputDataRate PROC
;;;695     */
;;;696    static int32_t HTS221_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)
000000  b570              PUSH     {r4-r6,lr}
;;;697    {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
000008  eeb08a40          VMOV.F32 s16,s0
;;;698      hts221_odr_t new_odr;
;;;699    
;;;700      new_odr = (Odr <= 1.0f) ? HTS221_ODR_1Hz
00000c  eeb70a00          VMOV.F32 s0,#1.00000000
000010  eeb48ac0          VCMPE.F32 s16,s0
000014  eef1fa10          VMRS     APSR_nzcv,FPSCR
000018  d801              BHI      |L18.30|
00001a  2001              MOVS     r0,#1
00001c  e009              B        |L18.50|
                  |L18.30|
;;;701                : (Odr <= 7.0f) ? HTS221_ODR_7Hz
00001e  eeb10a0c          VMOV.F32 s0,#7.00000000
000022  eeb48ac0          VCMPE.F32 s16,s0
000026  eef1fa10          VMRS     APSR_nzcv,FPSCR
00002a  d801              BHI      |L18.48|
00002c  2002              MOVS     r0,#2
00002e  e000              B        |L18.50|
                  |L18.48|
;;;702                :                 HTS221_ODR_12Hz5;
000030  2003              MOVS     r0,#3
                  |L18.50|
000032  4605              MOV      r5,r0
;;;703    
;;;704      if (hts221_data_rate_set(&(pObj->Ctx), new_odr) != HTS221_OK)
000034  4629              MOV      r1,r5
000036  f104001c          ADD      r0,r4,#0x1c
00003a  f7fffffe          BL       hts221_data_rate_set
00003e  b120              CBZ      r0,|L18.74|
;;;705      {
;;;706        return HTS221_ERROR;
000040  f04f30ff          MOV      r0,#0xffffffff
                  |L18.68|
;;;707      }
;;;708    
;;;709      return HTS221_OK;
;;;710    }
000044  ecbd8b02          VPOP     {d8}
000048  bd70              POP      {r4-r6,pc}
                  |L18.74|
00004a  2000              MOVS     r0,#0                 ;709
00004c  e7fa              B        |L18.68|
;;;711    
                          ENDP


                          AREA ||i.HTS221_Set_One_Shot||, CODE, READONLY, ALIGN=1

                  HTS221_Set_One_Shot PROC
;;;552     */
;;;553    int32_t HTS221_Set_One_Shot(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;554    {
000002  4604              MOV      r4,r0
;;;555    
;;;556      /* Set ODR */
;;;557      if(hts221_data_rate_set(&(pObj->Ctx), HTS221_ONE_SHOT)!= HTS221_OK)
000004  2100              MOVS     r1,#0
000006  f104001c          ADD      r0,r4,#0x1c
00000a  f7fffffe          BL       hts221_data_rate_set
00000e  b110              CBZ      r0,|L19.22|
;;;558      {
;;;559        return HTS221_ERROR;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L19.20|
;;;560      }
;;;561      
;;;562      /* Start One Shot Measurement */
;;;563      if(hts221_one_shoot_trigger_set(&(pObj->Ctx), 1) != HTS221_OK)
;;;564      {
;;;565        return HTS221_ERROR;
;;;566      }
;;;567      
;;;568      return HTS221_OK;
;;;569    }
000014  bd10              POP      {r4,pc}
                  |L19.22|
000016  2101              MOVS     r1,#1                 ;563
000018  f104001c          ADD      r0,r4,#0x1c           ;563
00001c  f7fffffe          BL       hts221_one_shoot_trigger_set
000020  b110              CBZ      r0,|L19.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;565
000026  e7f5              B        |L19.20|
                  |L19.40|
000028  2000              MOVS     r0,#0                 ;568
00002a  e7f3              B        |L19.20|
;;;570    
                          ENDP


                          AREA ||i.HTS221_TEMP_Disable||, CODE, READONLY, ALIGN=1

                  HTS221_TEMP_Disable PROC
;;;434     */
;;;435    int32_t HTS221_TEMP_Disable(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;436    {
000002  4604              MOV      r4,r0
;;;437      /* Check if the component is already disabled */
;;;438      if (pObj->temp_is_enabled == 0U)
000004  f894002a          LDRB     r0,[r4,#0x2a]
000008  b908              CBNZ     r0,|L20.14|
;;;439      {
;;;440        return HTS221_OK;
00000a  2000              MOVS     r0,#0
                  |L20.12|
;;;441      }
;;;442    
;;;443      /* Check if the HTS221 humidity sensor is still enable. */
;;;444      /* If yes, skip the disable function, if not call disable function */
;;;445      if (pObj->hum_is_enabled == 0U)
;;;446      {
;;;447        /* Power off the component. */
;;;448        if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_DISABLE) != HTS221_OK)
;;;449        {
;;;450          return HTS221_ERROR;
;;;451        }
;;;452      }
;;;453    
;;;454      pObj->temp_is_enabled = 0;
;;;455    
;;;456      return HTS221_OK;
;;;457    }
00000c  bd10              POP      {r4,pc}
                  |L20.14|
00000e  f8940029          LDRB     r0,[r4,#0x29]         ;445
000012  b940              CBNZ     r0,|L20.38|
000014  2100              MOVS     r1,#0                 ;448
000016  f104001c          ADD      r0,r4,#0x1c           ;448
00001a  f7fffffe          BL       hts221_power_on_set
00001e  b110              CBZ      r0,|L20.38|
000020  f04f30ff          MOV      r0,#0xffffffff        ;450
000024  e7f2              B        |L20.12|
                  |L20.38|
000026  2000              MOVS     r0,#0                 ;454
000028  f884002a          STRB     r0,[r4,#0x2a]         ;454
00002c  bf00              NOP                            ;456
00002e  e7ed              B        |L20.12|
;;;458    
                          ENDP


                          AREA ||i.HTS221_TEMP_Enable||, CODE, READONLY, ALIGN=1

                  HTS221_TEMP_Enable PROC
;;;405     */
;;;406    int32_t HTS221_TEMP_Enable(HTS221_Object_t *pObj)
000000  b510              PUSH     {r4,lr}
;;;407    {
000002  4604              MOV      r4,r0
;;;408      /* Check if the component is already enabled */
;;;409      if (pObj->temp_is_enabled == 1U)
000004  f894002a          LDRB     r0,[r4,#0x2a]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L21.16|
;;;410      {
;;;411        return HTS221_OK;
00000c  2000              MOVS     r0,#0
                  |L21.14|
;;;412      }
;;;413    
;;;414      /* Check if the HTS221 humidity sensor is already enabled. */
;;;415      /* If yes, skip the enable function, if not call enable function */
;;;416      if (pObj->hum_is_enabled == 0U)
;;;417      {
;;;418        /* Power on the component. */
;;;419        if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_ENABLE) != HTS221_OK)
;;;420        {
;;;421          return HTS221_ERROR;
;;;422        }
;;;423      }
;;;424    
;;;425      pObj->temp_is_enabled = 1;
;;;426    
;;;427      return HTS221_OK;
;;;428    }
00000e  bd10              POP      {r4,pc}
                  |L21.16|
000010  f8940029          LDRB     r0,[r4,#0x29]         ;416
000014  b940              CBNZ     r0,|L21.40|
000016  2101              MOVS     r1,#1                 ;419
000018  f104001c          ADD      r0,r4,#0x1c           ;419
00001c  f7fffffe          BL       hts221_power_on_set
000020  b110              CBZ      r0,|L21.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;421
000026  e7f2              B        |L21.14|
                  |L21.40|
000028  2001              MOVS     r0,#1                 ;425
00002a  f884002a          STRB     r0,[r4,#0x2a]         ;425
00002e  2000              MOVS     r0,#0                 ;427
000030  e7ed              B        |L21.14|
;;;429    
                          ENDP


                          AREA ||i.HTS221_TEMP_GetOutputDataRate||, CODE, READONLY, ALIGN=1

                  HTS221_TEMP_GetOutputDataRate PROC
;;;464     */
;;;465    int32_t HTS221_TEMP_GetOutputDataRate(HTS221_Object_t *pObj, float *Odr)
000000  b570              PUSH     {r4-r6,lr}
;;;466    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;467      return HTS221_GetOutputDataRate(pObj, Odr);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       HTS221_GetOutputDataRate
;;;468    }
00000e  bd70              POP      {r4-r6,pc}
;;;469    
                          ENDP


                          AREA ||i.HTS221_TEMP_GetTemperature||, CODE, READONLY, ALIGN=1

                  HTS221_TEMP_GetTemperature PROC
;;;486     */
;;;487    int32_t HTS221_TEMP_GetTemperature(HTS221_Object_t *pObj, float *Value)
000000  b530              PUSH     {r4,r5,lr}
;;;488    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;489      axis1bit16_t data_raw_temperature;
;;;490      axis1bit16_t coeff;
;;;491      lin_t lin_temp;
;;;492    
;;;493      if (hts221_temp_adc_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
000008  a905              ADD      r1,sp,#0x14
00000a  f104001c          ADD      r0,r4,#0x1c
00000e  f7fffffe          BL       hts221_temp_adc_point_0_get
000012  b118              CBZ      r0,|L23.28|
;;;494      {
;;;495        return HTS221_ERROR;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L23.24|
;;;496      }
;;;497    
;;;498      lin_temp.x0 = (float)coeff.i16bit;
;;;499    
;;;500      if (hts221_temp_deg_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
;;;501      {
;;;502        return HTS221_ERROR;
;;;503      }
;;;504    
;;;505      lin_temp.y0 = (float)coeff.u8bit[0];
;;;506    
;;;507      if (hts221_temp_adc_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
;;;508      {
;;;509        return HTS221_ERROR;
;;;510      }
;;;511    
;;;512      lin_temp.x1 = (float)coeff.i16bit;
;;;513    
;;;514      if (hts221_temp_deg_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
;;;515      {
;;;516        return HTS221_ERROR;
;;;517      }
;;;518    
;;;519      lin_temp.y1 = (float)coeff.u8bit[0];
;;;520    
;;;521      (void)memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
;;;522      if (hts221_temperature_raw_get(&(pObj->Ctx), data_raw_temperature.u8bit) != HTS221_OK)
;;;523      {
;;;524        return HTS221_ERROR;
;;;525      }
;;;526    
;;;527      *Value = Linear_Interpolation(&lin_temp, (float)data_raw_temperature.i16bit);
;;;528    
;;;529      return HTS221_OK;
;;;530    }
000018  b007              ADD      sp,sp,#0x1c
00001a  bd30              POP      {r4,r5,pc}
                  |L23.28|
00001c  f9bd0014          LDRSH    r0,[sp,#0x14]         ;498
000020  ee000a10          VMOV     s0,r0                 ;498
000024  eeb80ac0          VCVT.F32.S32 s0,s0                 ;498
000028  ed8d0a01          VSTR     s0,[sp,#4]            ;498
00002c  a905              ADD      r1,sp,#0x14           ;500
00002e  f104001c          ADD      r0,r4,#0x1c           ;500
000032  f7fffffe          BL       hts221_temp_deg_point_0_get
000036  b110              CBZ      r0,|L23.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;502
00003c  e7ec              B        |L23.24|
                  |L23.62|
00003e  f89d0014          LDRB     r0,[sp,#0x14]         ;505
000042  ee000a10          VMOV     s0,r0                 ;505
000046  eeb80a40          VCVT.F32.U32 s0,s0                 ;505
00004a  ed8d0a02          VSTR     s0,[sp,#8]            ;505
00004e  a905              ADD      r1,sp,#0x14           ;507
000050  f104001c          ADD      r0,r4,#0x1c           ;507
000054  f7fffffe          BL       hts221_temp_adc_point_1_get
000058  b110              CBZ      r0,|L23.96|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;509
00005e  e7db              B        |L23.24|
                  |L23.96|
000060  f9bd0014          LDRSH    r0,[sp,#0x14]         ;512
000064  ee000a10          VMOV     s0,r0                 ;512
000068  eeb80ac0          VCVT.F32.S32 s0,s0                 ;512
00006c  ed8d0a03          VSTR     s0,[sp,#0xc]          ;512
000070  a905              ADD      r1,sp,#0x14           ;514
000072  f104001c          ADD      r0,r4,#0x1c           ;514
000076  f7fffffe          BL       hts221_temp_deg_point_1_get
00007a  b110              CBZ      r0,|L23.130|
00007c  f04f30ff          MOV      r0,#0xffffffff        ;516
000080  e7ca              B        |L23.24|
                  |L23.130|
000082  f89d0014          LDRB     r0,[sp,#0x14]         ;519
000086  ee000a10          VMOV     s0,r0                 ;519
00008a  eeb80a40          VCVT.F32.U32 s0,s0                 ;519
00008e  ed8d0a04          VSTR     s0,[sp,#0x10]         ;519
000092  2000              MOVS     r0,#0                 ;521
000094  9006              STR      r0,[sp,#0x18]         ;521
000096  a906              ADD      r1,sp,#0x18           ;522
000098  f104001c          ADD      r0,r4,#0x1c           ;522
00009c  f7fffffe          BL       hts221_temperature_raw_get
0000a0  b110              CBZ      r0,|L23.168|
0000a2  f04f30ff          MOV      r0,#0xffffffff        ;524
0000a6  e7b7              B        |L23.24|
                  |L23.168|
0000a8  f9bd0018          LDRSH    r0,[sp,#0x18]         ;527
0000ac  ee000a90          VMOV     s1,r0                 ;527
0000b0  eef80ae0          VCVT.F32.S32 s1,s1                 ;527
0000b4  eeb00a60          VMOV.F32 s0,s1                 ;527
0000b8  a801              ADD      r0,sp,#4              ;527
0000ba  f7fffffe          BL       Linear_Interpolation
0000be  ed850a00          VSTR     s0,[r5,#0]            ;527
0000c2  2000              MOVS     r0,#0                 ;529
0000c4  e7a8              B        |L23.24|
;;;531    
                          ENDP


                          AREA ||i.HTS221_TEMP_Get_DRDY_Status||, CODE, READONLY, ALIGN=1

                  HTS221_TEMP_Get_DRDY_Status PROC
;;;537     */
;;;538    int32_t HTS221_TEMP_Get_DRDY_Status(HTS221_Object_t *pObj, uint8_t *Status)
000000  b570              PUSH     {r4-r6,lr}
;;;539    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;540      if (hts221_temp_data_ready_get(&(pObj->Ctx), Status) != HTS221_OK)
000006  4629              MOV      r1,r5
000008  f104001c          ADD      r0,r4,#0x1c
00000c  f7fffffe          BL       hts221_temp_data_ready_get
000010  b110              CBZ      r0,|L24.24|
;;;541      {
;;;542        return HTS221_ERROR;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L24.22|
;;;543      }
;;;544    
;;;545      return HTS221_OK;
;;;546    }
000016  bd70              POP      {r4-r6,pc}
                  |L24.24|
000018  2000              MOVS     r0,#0                 ;545
00001a  e7fc              B        |L24.22|
;;;547    
                          ENDP


                          AREA ||i.HTS221_TEMP_SetOutputDataRate||, CODE, READONLY, ALIGN=1

                  HTS221_TEMP_SetOutputDataRate PROC
;;;475     */
;;;476    int32_t HTS221_TEMP_SetOutputDataRate(HTS221_Object_t *pObj, float Odr)
000000  b510              PUSH     {r4,lr}
;;;477    {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
000008  eeb08a40          VMOV.F32 s16,s0
;;;478      return HTS221_SetOutputDataRate(pObj, Odr);
00000c  eeb00a48          VMOV.F32 s0,s16
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HTS221_SetOutputDataRate
;;;479    }
000016  ecbd8b02          VPOP     {d8}
00001a  bd10              POP      {r4,pc}
;;;480    
                          ENDP


                          AREA ||i.HTS221_Write_Reg||, CODE, READONLY, ALIGN=1

                  HTS221_Write_Reg PROC
;;;629     */
;;;630    int32_t HTS221_Write_Reg(HTS221_Object_t *pObj, uint8_t Reg, uint8_t Data)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;631    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;632      if (hts221_write_reg(&(pObj->Ctx), Reg, &Data, 1) != HTS221_OK)
000006  2301              MOVS     r3,#1
000008  aa02              ADD      r2,sp,#8
00000a  4629              MOV      r1,r5
00000c  f104001c          ADD      r0,r4,#0x1c
000010  f7fffffe          BL       hts221_write_reg
000014  b110              CBZ      r0,|L26.28|
;;;633      {
;;;634        return HTS221_ERROR;
000016  f04f30ff          MOV      r0,#0xffffffff
                  |L26.26|
;;;635      }
;;;636    
;;;637      return HTS221_OK;
;;;638    }
00001a  bd3e              POP      {r1-r5,pc}
                  |L26.28|
00001c  2000              MOVS     r0,#0                 ;637
00001e  e7fc              B        |L26.26|
;;;639    
                          ENDP


                          AREA ||i.Linear_Interpolation||, CODE, READONLY, ALIGN=1

                  Linear_Interpolation PROC
;;;760     */
;;;761    static float Linear_Interpolation(lin_t *Lin, float Coeff)
000000  eef00a40          VMOV.F32 s1,s0
;;;762    {
;;;763      return (((Lin->y1 - Lin->y0) * Coeff) + ((Lin->x1 * Lin->y0) - (Lin->x0 * Lin->y1))) / (Lin->x1 - Lin->x0);
000004  ed900a02          VLDR     s0,[r0,#8]
000008  ed901a01          VLDR     s2,[r0,#4]
00000c  ee200a01          VMUL.F32 s0,s0,s2
000010  ed901a00          VLDR     s2,[r0,#0]
000014  edd01a03          VLDR     s3,[r0,#0xc]
000018  ee010a61          VMLS.F32 s0,s2,s3
00001c  ed901a03          VLDR     s2,[r0,#0xc]
000020  edd01a01          VLDR     s3,[r0,#4]
000024  ee311a61          VSUB.F32 s2,s2,s3
000028  ee010a20          VMLA.F32 s0,s2,s1
00002c  ed901a02          VLDR     s2,[r0,#8]
000030  edd01a00          VLDR     s3,[r0,#0]
000034  ee711a61          VSUB.F32 s3,s2,s3
000038  ee801a21          VDIV.F32 s2,s0,s3
00003c  eeb00a41          VMOV.F32 s0,s2
;;;764    }
000040  4770              BX       lr
;;;765    
                          ENDP


                          AREA ||i.ReadRegWrap||, CODE, READONLY, ALIGN=1

                  ReadRegWrap PROC
;;;773     */
;;;774    static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;775    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;776      HTS221_Object_t *pObj = (HTS221_Object_t *)Handle;
00000c  462c              MOV      r4,r5
;;;777    
;;;778      if (pObj->IO.BusType == (uint32_t)HTS221_I2C_BUS) /* I2C */
00000e  68a0              LDR      r0,[r4,#8]
000010  b948              CBNZ     r0,|L28.38|
;;;779      {
;;;780        /* Enable Multi-byte read */
;;;781        return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
000012  f0460180          ORR      r1,r6,#0x80
000016  7b20              LDRB     r0,[r4,#0xc]
000018  4643              MOV      r3,r8
00001a  463a              MOV      r2,r7
00001c  f8d4c014          LDR      r12,[r4,#0x14]
000020  47e0              BLX      r12
                  |L28.34|
;;;782      }
;;;783      else /* SPI 3-Wires */
;;;784      {
;;;785        /* Enable Multi-byte read */
;;;786        return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
;;;787      }
;;;788    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L28.38|
000026  f0460140          ORR      r1,r6,#0x40           ;786
00002a  7b20              LDRB     r0,[r4,#0xc]          ;786
00002c  4643              MOV      r3,r8                 ;786
00002e  463a              MOV      r2,r7                 ;786
000030  f8d4c014          LDR      r12,[r4,#0x14]        ;786
000034  47e0              BLX      r12                   ;786
000036  e7f4              B        |L28.34|
;;;789    
                          ENDP


                          AREA ||i.WriteRegWrap||, CODE, READONLY, ALIGN=1

                  WriteRegWrap PROC
;;;797     */
;;;798    static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;799    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;800      HTS221_Object_t *pObj = (HTS221_Object_t *)Handle;
00000c  462c              MOV      r4,r5
;;;801    
;;;802      if (pObj->IO.BusType == (uint32_t)HTS221_I2C_BUS) /* I2C */
00000e  68a0              LDR      r0,[r4,#8]
000010  b948              CBNZ     r0,|L29.38|
;;;803      {
;;;804        /* Enable Multi-byte write */
;;;805        return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
000012  f0460180          ORR      r1,r6,#0x80
000016  7b20              LDRB     r0,[r4,#0xc]
000018  4643              MOV      r3,r8
00001a  463a              MOV      r2,r7
00001c  f8d4c010          LDR      r12,[r4,#0x10]
000020  47e0              BLX      r12
                  |L29.34|
;;;806      }
;;;807      else /* SPI 3-Wires */
;;;808      {
;;;809        /* Enable Multi-byte write */
;;;810        return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
;;;811      }
;;;812    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L29.38|
000026  f0460140          ORR      r1,r6,#0x40           ;810
00002a  7b20              LDRB     r0,[r4,#0xc]          ;810
00002c  4643              MOV      r3,r8                 ;810
00002e  463a              MOV      r2,r7                 ;810
000030  f8d4c010          LDR      r12,[r4,#0x10]        ;810
000034  47e0              BLX      r12                   ;810
000036  e7f4              B        |L29.34|
;;;813    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  HTS221_COMMON_Driver
                          DCD      HTS221_Init
                          DCD      HTS221_DeInit
                          DCD      HTS221_ReadID
                          DCD      HTS221_GetCapabilities
                  HTS221_HUM_Driver
                          DCD      HTS221_HUM_Enable
                          DCD      HTS221_HUM_Disable
                          DCD      HTS221_HUM_GetOutputDataRate
                          DCD      HTS221_HUM_SetOutputDataRate
                          DCD      HTS221_HUM_GetHumidity
                  HTS221_TEMP_Driver
                          DCD      HTS221_TEMP_Enable
                          DCD      HTS221_TEMP_Disable
                          DCD      HTS221_TEMP_GetOutputDataRate
                          DCD      HTS221_TEMP_SetOutputDataRate
                          DCD      HTS221_TEMP_GetTemperature
