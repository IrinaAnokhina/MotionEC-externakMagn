; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_tim_ex.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_tim_ex.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim_ex.c]
                          THUMB

                          AREA ||i.HAL_TIMEx_BreakCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_BreakCallback PROC
;;;1841     */
;;;1842   __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1843   {
;;;1844     /* Prevent unused argument(s) compilation warning */
;;;1845     UNUSED(htim);
;;;1846   
;;;1847     /* NOTE : This function should not be modified, when the callback is needed,
;;;1848               the HAL_TIMEx_BreakCallback could be implemented in the user file
;;;1849      */
;;;1850   }
;;;1851   /**
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutCallback PROC
;;;1812     */
;;;1813   __weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1814   {
;;;1815     /* Prevent unused argument(s) compilation warning */
;;;1816     UNUSED(htim);
;;;1817   
;;;1818     /* NOTE : This function should not be modified, when the callback is needed,
;;;1819               the HAL_TIMEx_CommutCallback could be implemented in the user file
;;;1820      */
;;;1821   }
;;;1822   /**
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutHalfCpltCallback PROC
;;;1826     */
;;;1827   __weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1828   {
;;;1829     /* Prevent unused argument(s) compilation warning */
;;;1830     UNUSED(htim);
;;;1831   
;;;1832     /* NOTE : This function should not be modified, when the callback is needed,
;;;1833               the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file
;;;1834      */
;;;1835   }
;;;1836   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigBreakDeadTime||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigBreakDeadTime PROC
;;;1680     */
;;;1681   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
000000  b510              PUSH     {r4,lr}
;;;1682                                                   TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
;;;1683   {
000002  4603              MOV      r3,r0
;;;1684     /* Keep this variable initialized to 0 as it is used to configure BDTR register */
;;;1685     uint32_t tmpbdtr = 0U;
000004  2200              MOVS     r2,#0
;;;1686   
;;;1687     /* Check the parameters */
;;;1688     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;1689     assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
;;;1690     assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
;;;1691     assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
;;;1692     assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
;;;1693     assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
;;;1694     assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
;;;1695     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
;;;1696   
;;;1697     /* Check input state */
;;;1698     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  f893003c          LDRB     r0,[r3,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L4.20|
000010  2002              MOVS     r0,#2
                  |L4.18|
;;;1699   
;;;1700     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;1701        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;1702   
;;;1703     /* Set the BDTR bits */
;;;1704     MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
;;;1705     MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
;;;1706     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
;;;1707     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
;;;1708     MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
;;;1709     MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
;;;1710     MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
;;;1711   
;;;1712   
;;;1713     /* Set TIMx_BDTR */
;;;1714     htim->Instance->BDTR = tmpbdtr;
;;;1715   
;;;1716     __HAL_UNLOCK(htim);
;;;1717   
;;;1718     return HAL_OK;
;;;1719   }
000012  bd10              POP      {r4,pc}
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;1698
000016  f883003c          STRB     r0,[r3,#0x3c]         ;1698
00001a  bf00              NOP                            ;1698
00001c  f02200ff          BIC      r0,r2,#0xff           ;1704
000020  68cc              LDR      r4,[r1,#0xc]          ;1704
000022  ea400204          ORR      r2,r0,r4              ;1704
000026  f4227040          BIC      r0,r2,#0x300          ;1705
00002a  688c              LDR      r4,[r1,#8]            ;1705
00002c  ea400204          ORR      r2,r0,r4              ;1705
000030  f4226080          BIC      r0,r2,#0x400          ;1706
000034  684c              LDR      r4,[r1,#4]            ;1706
000036  ea400204          ORR      r2,r0,r4              ;1706
00003a  f4226000          BIC      r0,r2,#0x800          ;1707
00003e  680c              LDR      r4,[r1,#0]            ;1707
000040  ea400204          ORR      r2,r0,r4              ;1707
000044  f4225080          BIC      r0,r2,#0x1000         ;1708
000048  690c              LDR      r4,[r1,#0x10]         ;1708
00004a  ea400204          ORR      r2,r0,r4              ;1708
00004e  f4225000          BIC      r0,r2,#0x2000         ;1709
000052  694c              LDR      r4,[r1,#0x14]         ;1709
000054  ea400204          ORR      r2,r0,r4              ;1709
000058  f4224080          BIC      r0,r2,#0x4000         ;1710
00005c  69cc              LDR      r4,[r1,#0x1c]         ;1710
00005e  ea400204          ORR      r2,r0,r4              ;1710
000062  6818              LDR      r0,[r3,#0]            ;1714
000064  6442              STR      r2,[r0,#0x44]         ;1714
000066  bf00              NOP                            ;1716
000068  2000              MOVS     r0,#0                 ;1716
00006a  f883003c          STRB     r0,[r3,#0x3c]         ;1716
00006e  bf00              NOP                            ;1716
000070  bf00              NOP                            ;1718
000072  e7ce              B        |L4.18|
;;;1720   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutEvent PROC
;;;1466     */
;;;1467   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1468   {
000002  4603              MOV      r3,r0
;;;1469     /* Check the parameters */
;;;1470     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1471     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1472   
;;;1473     __HAL_LOCK(htim);
000004  bf00              NOP      
000006  f893003c          LDRB     r0,[r3,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L5.18|
00000e  2002              MOVS     r0,#2
                  |L5.16|
;;;1474   
;;;1475     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
;;;1476         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
;;;1477     {
;;;1478       /* Select the Input trigger */
;;;1479       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1480       htim->Instance->SMCR |= InputTrigger;
;;;1481     }
;;;1482   
;;;1483     /* Select the Capture Compare preload feature */
;;;1484     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1485     /* Select the Commutation event source */
;;;1486     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1487     htim->Instance->CR2 |= CommutationSource;
;;;1488   
;;;1489     /* Disable Commutation Interrupt */
;;;1490     __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
;;;1491   
;;;1492     /* Disable Commutation DMA request */
;;;1493     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
;;;1494   
;;;1495     __HAL_UNLOCK(htim);
;;;1496   
;;;1497     return HAL_OK;
;;;1498   }
000010  bd10              POP      {r4,pc}
                  |L5.18|
000012  2001              MOVS     r0,#1                 ;1473
000014  f883003c          STRB     r0,[r3,#0x3c]         ;1473
000018  bf00              NOP                            ;1473
00001a  b129              CBZ      r1,|L5.40|
00001c  2910              CMP      r1,#0x10              ;1475
00001e  d003              BEQ      |L5.40|
000020  2920              CMP      r1,#0x20              ;1476
000022  d001              BEQ      |L5.40|
000024  2930              CMP      r1,#0x30              ;1476
000026  d10a              BNE      |L5.62|
                  |L5.40|
000028  6818              LDR      r0,[r3,#0]            ;1479
00002a  6880              LDR      r0,[r0,#8]            ;1479
00002c  f0200070          BIC      r0,r0,#0x70           ;1479
000030  681c              LDR      r4,[r3,#0]            ;1479
000032  60a0              STR      r0,[r4,#8]            ;1479
000034  6818              LDR      r0,[r3,#0]            ;1480
000036  6880              LDR      r0,[r0,#8]            ;1480
000038  4308              ORRS     r0,r0,r1              ;1480
00003a  681c              LDR      r4,[r3,#0]            ;1480
00003c  60a0              STR      r0,[r4,#8]            ;1480
                  |L5.62|
00003e  6818              LDR      r0,[r3,#0]            ;1484
000040  6840              LDR      r0,[r0,#4]            ;1484
000042  f0400001          ORR      r0,r0,#1              ;1484
000046  681c              LDR      r4,[r3,#0]            ;1484
000048  6060              STR      r0,[r4,#4]            ;1484
00004a  6818              LDR      r0,[r3,#0]            ;1486
00004c  6840              LDR      r0,[r0,#4]            ;1486
00004e  f0200004          BIC      r0,r0,#4              ;1486
000052  681c              LDR      r4,[r3,#0]            ;1486
000054  6060              STR      r0,[r4,#4]            ;1486
000056  6818              LDR      r0,[r3,#0]            ;1487
000058  6840              LDR      r0,[r0,#4]            ;1487
00005a  4310              ORRS     r0,r0,r2              ;1487
00005c  681c              LDR      r4,[r3,#0]            ;1487
00005e  6060              STR      r0,[r4,#4]            ;1487
000060  6818              LDR      r0,[r3,#0]            ;1490
000062  68c0              LDR      r0,[r0,#0xc]          ;1490
000064  f0200020          BIC      r0,r0,#0x20           ;1490
000068  681c              LDR      r4,[r3,#0]            ;1490
00006a  60e0              STR      r0,[r4,#0xc]          ;1490
00006c  6818              LDR      r0,[r3,#0]            ;1493
00006e  68c0              LDR      r0,[r0,#0xc]          ;1493
000070  f4205000          BIC      r0,r0,#0x2000         ;1493
000074  681c              LDR      r4,[r3,#0]            ;1493
000076  60e0              STR      r0,[r4,#0xc]          ;1493
000078  bf00              NOP                            ;1495
00007a  2000              MOVS     r0,#0                 ;1495
00007c  f883003c          STRB     r0,[r3,#0x3c]         ;1495
000080  bf00              NOP                            ;1495
000082  bf00              NOP                            ;1497
000084  e7c4              B        |L5.16|
;;;1499   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutEvent_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigCommutEvent_DMA PROC
;;;1577     */
;;;1578   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1579   {
000002  4603              MOV      r3,r0
;;;1580     /* Check the parameters */
;;;1581     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1582     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1583   
;;;1584     __HAL_LOCK(htim);
000004  bf00              NOP      
000006  f893003c          LDRB     r0,[r3,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L6.18|
00000e  2002              MOVS     r0,#2
                  |L6.16|
;;;1585   
;;;1586     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
;;;1587         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
;;;1588     {
;;;1589       /* Select the Input trigger */
;;;1590       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1591       htim->Instance->SMCR |= InputTrigger;
;;;1592     }
;;;1593   
;;;1594     /* Select the Capture Compare preload feature */
;;;1595     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1596     /* Select the Commutation event source */
;;;1597     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1598     htim->Instance->CR2 |= CommutationSource;
;;;1599   
;;;1600     /* Enable the Commutation DMA Request */
;;;1601     /* Set the DMA Commutation Callback */
;;;1602     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;1603     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;
;;;1604     /* Set the DMA error callback */
;;;1605     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
;;;1606   
;;;1607     /* Disable Commutation Interrupt */
;;;1608     __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
;;;1609   
;;;1610     /* Enable the Commutation DMA Request */
;;;1611     __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
;;;1612   
;;;1613     __HAL_UNLOCK(htim);
;;;1614   
;;;1615     return HAL_OK;
;;;1616   }
000010  bd10              POP      {r4,pc}
                  |L6.18|
000012  2001              MOVS     r0,#1                 ;1584
000014  f883003c          STRB     r0,[r3,#0x3c]         ;1584
000018  bf00              NOP                            ;1584
00001a  b129              CBZ      r1,|L6.40|
00001c  2910              CMP      r1,#0x10              ;1586
00001e  d003              BEQ      |L6.40|
000020  2920              CMP      r1,#0x20              ;1587
000022  d001              BEQ      |L6.40|
000024  2930              CMP      r1,#0x30              ;1587
000026  d10a              BNE      |L6.62|
                  |L6.40|
000028  6818              LDR      r0,[r3,#0]            ;1590
00002a  6880              LDR      r0,[r0,#8]            ;1590
00002c  f0200070          BIC      r0,r0,#0x70           ;1590
000030  681c              LDR      r4,[r3,#0]            ;1590
000032  60a0              STR      r0,[r4,#8]            ;1590
000034  6818              LDR      r0,[r3,#0]            ;1591
000036  6880              LDR      r0,[r0,#8]            ;1591
000038  4308              ORRS     r0,r0,r1              ;1591
00003a  681c              LDR      r4,[r3,#0]            ;1591
00003c  60a0              STR      r0,[r4,#8]            ;1591
                  |L6.62|
00003e  6818              LDR      r0,[r3,#0]            ;1595
000040  6840              LDR      r0,[r0,#4]            ;1595
000042  f0400001          ORR      r0,r0,#1              ;1595
000046  681c              LDR      r4,[r3,#0]            ;1595
000048  6060              STR      r0,[r4,#4]            ;1595
00004a  6818              LDR      r0,[r3,#0]            ;1597
00004c  6840              LDR      r0,[r0,#4]            ;1597
00004e  f0200004          BIC      r0,r0,#4              ;1597
000052  681c              LDR      r4,[r3,#0]            ;1597
000054  6060              STR      r0,[r4,#4]            ;1597
000056  6818              LDR      r0,[r3,#0]            ;1598
000058  6840              LDR      r0,[r0,#4]            ;1598
00005a  4310              ORRS     r0,r0,r2              ;1598
00005c  681c              LDR      r4,[r3,#0]            ;1598
00005e  6060              STR      r0,[r4,#4]            ;1598
000060  4c0d              LDR      r4,|L6.152|
000062  6b58              LDR      r0,[r3,#0x34]         ;1602
000064  63c4              STR      r4,[r0,#0x3c]         ;1602
000066  4c0d              LDR      r4,|L6.156|
000068  6b58              LDR      r0,[r3,#0x34]         ;1603
00006a  6404              STR      r4,[r0,#0x40]         ;1603
00006c  4c0c              LDR      r4,|L6.160|
00006e  6b58              LDR      r0,[r3,#0x34]         ;1605
000070  64c4              STR      r4,[r0,#0x4c]         ;1605
000072  6818              LDR      r0,[r3,#0]            ;1608
000074  68c0              LDR      r0,[r0,#0xc]          ;1608
000076  f0200020          BIC      r0,r0,#0x20           ;1608
00007a  681c              LDR      r4,[r3,#0]            ;1608
00007c  60e0              STR      r0,[r4,#0xc]          ;1608
00007e  6818              LDR      r0,[r3,#0]            ;1611
000080  68c0              LDR      r0,[r0,#0xc]          ;1611
000082  f4405000          ORR      r0,r0,#0x2000         ;1611
000086  681c              LDR      r4,[r3,#0]            ;1611
000088  60e0              STR      r0,[r4,#0xc]          ;1611
00008a  bf00              NOP                            ;1613
00008c  2000              MOVS     r0,#0                 ;1613
00008e  f883003c          STRB     r0,[r3,#0x3c]         ;1613
000092  bf00              NOP                            ;1613
000094  bf00              NOP                            ;1615
000096  e7bb              B        |L6.16|
;;;1617   
                          ENDP

                  |L6.152|
                          DCD      TIMEx_DMACommutationCplt
                  |L6.156|
                          DCD      TIMEx_DMACommutationHalfCplt
                  |L6.160|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_ConfigCommutEvent_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutEvent_IT PROC
;;;1521     */
;;;1522   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1523   {
000002  4603              MOV      r3,r0
;;;1524     /* Check the parameters */
;;;1525     assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
;;;1526     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1527   
;;;1528     __HAL_LOCK(htim);
000004  bf00              NOP      
000006  f893003c          LDRB     r0,[r3,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L7.18|
00000e  2002              MOVS     r0,#2
                  |L7.16|
;;;1529   
;;;1530     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
;;;1531         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
;;;1532     {
;;;1533       /* Select the Input trigger */
;;;1534       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1535       htim->Instance->SMCR |= InputTrigger;
;;;1536     }
;;;1537   
;;;1538     /* Select the Capture Compare preload feature */
;;;1539     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1540     /* Select the Commutation event source */
;;;1541     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1542     htim->Instance->CR2 |= CommutationSource;
;;;1543   
;;;1544     /* Disable Commutation DMA request */
;;;1545     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
;;;1546   
;;;1547     /* Enable the Commutation Interrupt */
;;;1548     __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
;;;1549   
;;;1550     __HAL_UNLOCK(htim);
;;;1551   
;;;1552     return HAL_OK;
;;;1553   }
000010  bd10              POP      {r4,pc}
                  |L7.18|
000012  2001              MOVS     r0,#1                 ;1528
000014  f883003c          STRB     r0,[r3,#0x3c]         ;1528
000018  bf00              NOP                            ;1528
00001a  b129              CBZ      r1,|L7.40|
00001c  2910              CMP      r1,#0x10              ;1530
00001e  d003              BEQ      |L7.40|
000020  2920              CMP      r1,#0x20              ;1531
000022  d001              BEQ      |L7.40|
000024  2930              CMP      r1,#0x30              ;1531
000026  d10a              BNE      |L7.62|
                  |L7.40|
000028  6818              LDR      r0,[r3,#0]            ;1534
00002a  6880              LDR      r0,[r0,#8]            ;1534
00002c  f0200070          BIC      r0,r0,#0x70           ;1534
000030  681c              LDR      r4,[r3,#0]            ;1534
000032  60a0              STR      r0,[r4,#8]            ;1534
000034  6818              LDR      r0,[r3,#0]            ;1535
000036  6880              LDR      r0,[r0,#8]            ;1535
000038  4308              ORRS     r0,r0,r1              ;1535
00003a  681c              LDR      r4,[r3,#0]            ;1535
00003c  60a0              STR      r0,[r4,#8]            ;1535
                  |L7.62|
00003e  6818              LDR      r0,[r3,#0]            ;1539
000040  6840              LDR      r0,[r0,#4]            ;1539
000042  f0400001          ORR      r0,r0,#1              ;1539
000046  681c              LDR      r4,[r3,#0]            ;1539
000048  6060              STR      r0,[r4,#4]            ;1539
00004a  6818              LDR      r0,[r3,#0]            ;1541
00004c  6840              LDR      r0,[r0,#4]            ;1541
00004e  f0200004          BIC      r0,r0,#4              ;1541
000052  681c              LDR      r4,[r3,#0]            ;1541
000054  6060              STR      r0,[r4,#4]            ;1541
000056  6818              LDR      r0,[r3,#0]            ;1542
000058  6840              LDR      r0,[r0,#4]            ;1542
00005a  4310              ORRS     r0,r0,r2              ;1542
00005c  681c              LDR      r4,[r3,#0]            ;1542
00005e  6060              STR      r0,[r4,#4]            ;1542
000060  6818              LDR      r0,[r3,#0]            ;1545
000062  68c0              LDR      r0,[r0,#0xc]          ;1545
000064  f4205000          BIC      r0,r0,#0x2000         ;1545
000068  681c              LDR      r4,[r3,#0]            ;1545
00006a  60e0              STR      r0,[r4,#0xc]          ;1545
00006c  6818              LDR      r0,[r3,#0]            ;1548
00006e  68c0              LDR      r0,[r0,#0xc]          ;1548
000070  f0400020          ORR      r0,r0,#0x20           ;1548
000074  681c              LDR      r4,[r3,#0]            ;1548
000076  60e0              STR      r0,[r4,#0xc]          ;1548
000078  bf00              NOP                            ;1550
00007a  2000              MOVS     r0,#0                 ;1550
00007c  f883003c          STRB     r0,[r3,#0x3c]         ;1550
000080  bf00              NOP                            ;1550
000082  bf00              NOP                            ;1552
000084  e7c4              B        |L7.16|
;;;1554   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_DeInit PROC
;;;221      */
;;;222    HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;223    {
000002  4604              MOV      r4,r0
;;;224      /* Check the parameters */
;;;225      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;226    
;;;227      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;228    
;;;229      /* Disable the TIM Peripheral Clock */
;;;230      __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L8.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L8.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L8.46|
00002e  bf00              NOP      
;;;231    
;;;232    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;233      if (htim->HallSensor_MspDeInitCallback == NULL)
;;;234      {
;;;235        htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;
;;;236      }
;;;237      /* DeInit the low level hardware */
;;;238      htim->HallSensor_MspDeInitCallback(htim);
;;;239    #else
;;;240      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;241      HAL_TIMEx_HallSensor_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIMEx_HallSensor_MspDeInit
;;;242    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;243    
;;;244      /* Change TIM state */
;;;245      htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f884003d          STRB     r0,[r4,#0x3d]
;;;246    
;;;247      /* Release Lock */
;;;248      __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;249    
;;;250      return HAL_OK;
;;;251    }
000044  bd10              POP      {r4,pc}
;;;252    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_GetState PROC
;;;1874     */
;;;1875   HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;1876   {
;;;1877     return htim->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;1878   }
000006  4770              BX       lr
;;;1879   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Init PROC
;;;129      */
;;;130    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;131    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;132      TIM_OC_InitTypeDef OC_Config;
;;;133    
;;;134      /* Check the TIM handle allocation */
;;;135      if (htim == NULL)
000008  b914              CBNZ     r4,|L10.16|
;;;136      {
;;;137        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L10.12|
;;;138      }
;;;139    
;;;140      /* Check the parameters */
;;;141      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;142      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;143      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;144      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;145      assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;146      assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;147      assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;148    
;;;149      if (htim->State == HAL_TIM_STATE_RESET)
;;;150      {
;;;151        /* Allocate lock resource and initialize it */
;;;152        htim->Lock = HAL_UNLOCKED;
;;;153    
;;;154    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;155        /* Reset interrupt callbacks to legacy week callbacks */
;;;156        TIM_ResetCallback(htim);
;;;157    
;;;158        if (htim->HallSensor_MspInitCallback == NULL)
;;;159        {
;;;160          htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;
;;;161        }
;;;162        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;163        htim->HallSensor_MspInitCallback(htim);
;;;164    #else
;;;165        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;166        HAL_TIMEx_HallSensor_MspInit(htim);
;;;167    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;168      }
;;;169    
;;;170      /* Set the TIM state */
;;;171      htim->State = HAL_TIM_STATE_BUSY;
;;;172    
;;;173      /* Configure the Time base in the Encoder Mode */
;;;174      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;175    
;;;176      /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
;;;177      TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
;;;178    
;;;179      /* Reset the IC1PSC Bits */
;;;180      htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;181      /* Set the IC1PSC value */
;;;182      htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
;;;183    
;;;184      /* Enable the Hall sensor interface (XOR function of the three inputs) */
;;;185      htim->Instance->CR2 |= TIM_CR2_TI1S;
;;;186    
;;;187      /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
;;;188      htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;189      htim->Instance->SMCR |= TIM_TS_TI1F_ED;
;;;190    
;;;191      /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
;;;192      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;193      htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
;;;194    
;;;195      /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
;;;196      OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
;;;197      OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
;;;198      OC_Config.OCMode = TIM_OCMODE_PWM2;
;;;199      OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
;;;200      OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
;;;201      OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;202      OC_Config.Pulse = sConfig->Commutation_Delay;
;;;203    
;;;204      TIM_OC2_SetConfig(htim->Instance, &OC_Config);
;;;205    
;;;206      /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
;;;207        register to 101 */
;;;208      htim->Instance->CR2 &= ~TIM_CR2_MMS;
;;;209      htim->Instance->CR2 |= TIM_TRGO_OC2REF;
;;;210    
;;;211      /* Initialize the TIM state*/
;;;212      htim->State = HAL_TIM_STATE_READY;
;;;213    
;;;214      return HAL_OK;
;;;215    }
00000c  b007              ADD      sp,sp,#0x1c
00000e  bd30              POP      {r4,r5,pc}
                  |L10.16|
000010  f894003d          LDRB     r0,[r4,#0x3d]         ;149
000014  b928              CBNZ     r0,|L10.34|
000016  2000              MOVS     r0,#0                 ;152
000018  f884003c          STRB     r0,[r4,#0x3c]         ;152
00001c  4620              MOV      r0,r4                 ;166
00001e  f7fffffe          BL       HAL_TIMEx_HallSensor_MspInit
                  |L10.34|
000022  2002              MOVS     r0,#2                 ;171
000024  f884003d          STRB     r0,[r4,#0x3d]         ;171
000028  1d21              ADDS     r1,r4,#4              ;174
00002a  6820              LDR      r0,[r4,#0]            ;174
00002c  f7fffffe          BL       TIM_Base_SetConfig
000030  68ab              LDR      r3,[r5,#8]            ;177
000032  6829              LDR      r1,[r5,#0]            ;177
000034  2203              MOVS     r2,#3                 ;177
000036  6820              LDR      r0,[r4,#0]            ;177
000038  f7fffffe          BL       TIM_TI1_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;180
00003e  6980              LDR      r0,[r0,#0x18]         ;180
000040  f020000c          BIC      r0,r0,#0xc            ;180
000044  6821              LDR      r1,[r4,#0]            ;180
000046  6188              STR      r0,[r1,#0x18]         ;180
000048  6820              LDR      r0,[r4,#0]            ;182
00004a  6980              LDR      r0,[r0,#0x18]         ;182
00004c  6869              LDR      r1,[r5,#4]            ;182
00004e  4308              ORRS     r0,r0,r1              ;182
000050  6821              LDR      r1,[r4,#0]            ;182
000052  6188              STR      r0,[r1,#0x18]         ;182
000054  6820              LDR      r0,[r4,#0]            ;185
000056  6840              LDR      r0,[r0,#4]            ;185
000058  f0400080          ORR      r0,r0,#0x80           ;185
00005c  6821              LDR      r1,[r4,#0]            ;185
00005e  6048              STR      r0,[r1,#4]            ;185
000060  6820              LDR      r0,[r4,#0]            ;188
000062  6880              LDR      r0,[r0,#8]            ;188
000064  f0200070          BIC      r0,r0,#0x70           ;188
000068  6821              LDR      r1,[r4,#0]            ;188
00006a  6088              STR      r0,[r1,#8]            ;188
00006c  6820              LDR      r0,[r4,#0]            ;189
00006e  6880              LDR      r0,[r0,#8]            ;189
000070  f0400040          ORR      r0,r0,#0x40           ;189
000074  6821              LDR      r1,[r4,#0]            ;189
000076  6088              STR      r0,[r1,#8]            ;189
000078  6820              LDR      r0,[r4,#0]            ;192
00007a  6880              LDR      r0,[r0,#8]            ;192
00007c  f0200007          BIC      r0,r0,#7              ;192
000080  6821              LDR      r1,[r4,#0]            ;192
000082  6088              STR      r0,[r1,#8]            ;192
000084  6820              LDR      r0,[r4,#0]            ;193
000086  6880              LDR      r0,[r0,#8]            ;193
000088  f0400004          ORR      r0,r0,#4              ;193
00008c  6821              LDR      r1,[r4,#0]            ;193
00008e  6088              STR      r0,[r1,#8]            ;193
000090  2000              MOVS     r0,#0                 ;196
000092  9004              STR      r0,[sp,#0x10]         ;196
000094  9005              STR      r0,[sp,#0x14]         ;197
000096  2070              MOVS     r0,#0x70              ;198
000098  9000              STR      r0,[sp,#0]            ;198
00009a  2000              MOVS     r0,#0                 ;199
00009c  9006              STR      r0,[sp,#0x18]         ;199
00009e  9003              STR      r0,[sp,#0xc]          ;200
0000a0  9002              STR      r0,[sp,#8]            ;201
0000a2  68e8              LDR      r0,[r5,#0xc]          ;202
0000a4  9001              STR      r0,[sp,#4]            ;202
0000a6  4669              MOV      r1,sp                 ;204
0000a8  6820              LDR      r0,[r4,#0]            ;204
0000aa  f7fffffe          BL       TIM_OC2_SetConfig
0000ae  6820              LDR      r0,[r4,#0]            ;208
0000b0  6840              LDR      r0,[r0,#4]            ;208
0000b2  f0200070          BIC      r0,r0,#0x70           ;208
0000b6  6821              LDR      r1,[r4,#0]            ;208
0000b8  6048              STR      r0,[r1,#4]            ;208
0000ba  6820              LDR      r0,[r4,#0]            ;209
0000bc  6840              LDR      r0,[r0,#4]            ;209
0000be  f0400050          ORR      r0,r0,#0x50           ;209
0000c2  6821              LDR      r1,[r4,#0]            ;209
0000c4  6048              STR      r0,[r1,#4]            ;209
0000c6  2001              MOVS     r0,#1                 ;212
0000c8  f884003d          STRB     r0,[r4,#0x3d]         ;212
0000cc  2000              MOVS     r0,#0                 ;214
0000ce  e79d              B        |L10.12|
;;;216    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspDeInit PROC
;;;272      */
;;;273    __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;274    {
;;;275      /* Prevent unused argument(s) compilation warning */
;;;276      UNUSED(htim);
;;;277    
;;;278      /* NOTE : This function should not be modified, when the callback is needed,
;;;279                the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
;;;280       */
;;;281    }
;;;282    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspInit PROC
;;;257      */
;;;258    __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;259    {
;;;260      /* Prevent unused argument(s) compilation warning */
;;;261      UNUSED(htim);
;;;262    
;;;263      /* NOTE : This function should not be modified, when the callback is needed,
;;;264                the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
;;;265       */
;;;266    }
;;;267    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start PROC
;;;287      */
;;;288    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;289    {
000002  4604              MOV      r4,r0
;;;290      uint32_t tmpsmcr;
;;;291    
;;;292      /* Check the parameters */
;;;293      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;294    
;;;295      /* Enable the Input Capture channel 1
;;;296        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;297      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;298    
;;;299      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;300      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
00000e  6820              LDR      r0,[r4,#0]
000010  6880              LDR      r0,[r0,#8]
000012  f0000507          AND      r5,r0,#7
;;;301      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000016  2d06              CMP      r5,#6
000018  d005              BEQ      |L13.38|
;;;302      {
;;;303        __HAL_TIM_ENABLE(htim);
00001a  6820              LDR      r0,[r4,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400001          ORR      r0,r0,#1
000022  6821              LDR      r1,[r4,#0]
000024  6008              STR      r0,[r1,#0]
                  |L13.38|
;;;304      }
;;;305    
;;;306      /* Return function status */
;;;307      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;308    }
000028  bd70              POP      {r4-r6,pc}
;;;309    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_DMA PROC
;;;391      */
;;;392    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;393    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;394      uint32_t tmpsmcr;
;;;395    
;;;396      /* Check the parameters */
;;;397      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;398    
;;;399      if ((htim->State == HAL_TIM_STATE_BUSY))
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2802              CMP      r0,#2
000010  d101              BNE      |L14.22|
                  |L14.18|
;;;400      {
;;;401        return HAL_BUSY;
;;;402      }
;;;403      else if ((htim->State == HAL_TIM_STATE_READY))
;;;404      {
;;;405        if (((uint32_t)pData == 0U) && (Length > 0U))
;;;406        {
;;;407          return HAL_ERROR;
;;;408        }
;;;409        else
;;;410        {
;;;411          htim->State = HAL_TIM_STATE_BUSY;
;;;412        }
;;;413      }
;;;414      else
;;;415      {
;;;416        /* nothing to do */
;;;417      }
;;;418      /* Enable the Input Capture channel 1
;;;419        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;420      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;421    
;;;422      /* Set the DMA Input Capture 1 Callbacks */
;;;423      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;424      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;425      /* Set the DMA error callback */
;;;426      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;427    
;;;428      /* Enable the DMA stream for Capture 1*/
;;;429      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
;;;430      {
;;;431        return HAL_ERROR;
;;;432      }
;;;433      /* Enable the capture compare 1 Interrupt */
;;;434      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;435    
;;;436      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;437      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;438      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;439      {
;;;440        __HAL_TIM_ENABLE(htim);
;;;441      }
;;;442    
;;;443      /* Return function status */
;;;444      return HAL_OK;
;;;445    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L14.22|
000016  f894003d          LDRB     r0,[r4,#0x3d]         ;403
00001a  2801              CMP      r0,#1                 ;403
00001c  d105              BNE      |L14.42|
00001e  b90d              CBNZ     r5,|L14.36|
000020  b106              CBZ      r6,|L14.36|
000022  e7f6              B        |L14.18|
                  |L14.36|
000024  2002              MOVS     r0,#2                 ;411
000026  f884003d          STRB     r0,[r4,#0x3d]         ;411
                  |L14.42|
00002a  2201              MOVS     r2,#1                 ;420
00002c  2100              MOVS     r1,#0                 ;420
00002e  6820              LDR      r0,[r4,#0]            ;420
000030  f7fffffe          BL       TIM_CCxChannelCmd
000034  4913              LDR      r1,|L14.132|
000036  6a60              LDR      r0,[r4,#0x24]         ;423
000038  63c1              STR      r1,[r0,#0x3c]         ;423
00003a  4913              LDR      r1,|L14.136|
00003c  6a60              LDR      r0,[r4,#0x24]         ;424
00003e  6401              STR      r1,[r0,#0x40]         ;424
000040  4912              LDR      r1,|L14.140|
000042  6a60              LDR      r0,[r4,#0x24]         ;426
000044  64c1              STR      r1,[r0,#0x4c]         ;426
000046  6822              LDR      r2,[r4,#0]            ;429
000048  f1020134          ADD      r1,r2,#0x34           ;429
00004c  4633              MOV      r3,r6                 ;429
00004e  462a              MOV      r2,r5                 ;429
000050  6a60              LDR      r0,[r4,#0x24]         ;429
000052  f7fffffe          BL       HAL_DMA_Start_IT
000056  b108              CBZ      r0,|L14.92|
000058  2001              MOVS     r0,#1                 ;431
00005a  e7da              B        |L14.18|
                  |L14.92|
00005c  6820              LDR      r0,[r4,#0]            ;434
00005e  68c0              LDR      r0,[r0,#0xc]          ;434
000060  f4407000          ORR      r0,r0,#0x200          ;434
000064  6821              LDR      r1,[r4,#0]            ;434
000066  60c8              STR      r0,[r1,#0xc]          ;434
000068  6820              LDR      r0,[r4,#0]            ;437
00006a  6880              LDR      r0,[r0,#8]            ;437
00006c  f0000707          AND      r7,r0,#7              ;437
000070  2f06              CMP      r7,#6                 ;438
000072  d005              BEQ      |L14.128|
000074  6820              LDR      r0,[r4,#0]            ;440
000076  6800              LDR      r0,[r0,#0]            ;440
000078  f0400001          ORR      r0,r0,#1              ;440
00007c  6821              LDR      r1,[r4,#0]            ;440
00007e  6008              STR      r0,[r1,#0]            ;440
                  |L14.128|
000080  2000              MOVS     r0,#0                 ;444
000082  e7c6              B        |L14.18|
;;;446    
                          ENDP

                  |L14.132|
                          DCD      TIM_DMACaptureCplt
                  |L14.136|
                          DCD      TIM_DMACaptureHalfCplt
                  |L14.140|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_HallSensor_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start_IT PROC
;;;335      */
;;;336    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;337    {
000002  4604              MOV      r4,r0
;;;338      uint32_t tmpsmcr;
;;;339    
;;;340      /* Check the parameters */
;;;341      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;342    
;;;343      /* Enable the capture compare Interrupts 1 event */
;;;344      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f0400002          ORR      r0,r0,#2
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;345    
;;;346      /* Enable the Input Capture channel 1
;;;347        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;348      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000010  2201              MOVS     r2,#1
000012  2100              MOVS     r1,#0
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;349    
;;;350      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;351      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
00001a  6820              LDR      r0,[r4,#0]
00001c  6880              LDR      r0,[r0,#8]
00001e  f0000507          AND      r5,r0,#7
;;;352      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000022  2d06              CMP      r5,#6
000024  d005              BEQ      |L15.50|
;;;353      {
;;;354        __HAL_TIM_ENABLE(htim);
000026  6820              LDR      r0,[r4,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0400001          ORR      r0,r0,#1
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
                  |L15.50|
;;;355      }
;;;356    
;;;357      /* Return function status */
;;;358      return HAL_OK;
000032  2000              MOVS     r0,#0
;;;359    }
000034  bd70              POP      {r4-r6,pc}
;;;360    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop PROC
;;;314      */
;;;315    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;316    {
000002  4604              MOV      r4,r0
;;;317      /* Check the parameters */
;;;318      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;319    
;;;320      /* Disable the Input Capture channels 1, 2 and 3
;;;321        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;322      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;323    
;;;324      /* Disable the Peripheral */
;;;325      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6820              LDR      r0,[r4,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  f2411111          MOV      r1,#0x1111
000018  4008              ANDS     r0,r0,r1
00001a  b950              CBNZ     r0,|L16.50|
00001c  6820              LDR      r0,[r4,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1089              ASRS     r1,r1,#2
000022  4008              ANDS     r0,r0,r1
000024  b928              CBNZ     r0,|L16.50|
000026  6820              LDR      r0,[r4,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0200001          BIC      r0,r0,#1
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
                  |L16.50|
000032  bf00              NOP      
;;;326    
;;;327      /* Return function status */
;;;328      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;329    }
000036  bd10              POP      {r4,pc}
;;;330    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_DMA PROC
;;;451      */
;;;452    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;453    {
000002  4604              MOV      r4,r0
;;;454      /* Check the parameters */
;;;455      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;456    
;;;457      /* Disable the Input Capture channel 1
;;;458        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;459      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;460    
;;;461    
;;;462      /* Disable the capture compare Interrupts 1 event */
;;;463      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  f4207000          BIC      r0,r0,#0x200
000016  6821              LDR      r1,[r4,#0]
000018  60c8              STR      r0,[r1,#0xc]
;;;464    
;;;465      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  f7fffffe          BL       HAL_DMA_Abort_IT
;;;466      /* Disable the Peripheral */
;;;467      __HAL_TIM_DISABLE(htim);
000020  bf00              NOP      
000022  6820              LDR      r0,[r4,#0]
000024  6a00              LDR      r0,[r0,#0x20]
000026  f2411111          MOV      r1,#0x1111
00002a  4008              ANDS     r0,r0,r1
00002c  b950              CBNZ     r0,|L17.68|
00002e  6820              LDR      r0,[r4,#0]
000030  6a00              LDR      r0,[r0,#0x20]
000032  1089              ASRS     r1,r1,#2
000034  4008              ANDS     r0,r0,r1
000036  b928              CBNZ     r0,|L17.68|
000038  6820              LDR      r0,[r4,#0]
00003a  6800              LDR      r0,[r0,#0]
00003c  f0200001          BIC      r0,r0,#1
000040  6821              LDR      r1,[r4,#0]
000042  6008              STR      r0,[r1,#0]
                  |L17.68|
000044  bf00              NOP      
;;;468    
;;;469      /* Return function status */
;;;470      return HAL_OK;
000046  2000              MOVS     r0,#0
;;;471    }
000048  bd10              POP      {r4,pc}
;;;472    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_IT PROC
;;;365      */
;;;366    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;367    {
000002  4604              MOV      r4,r0
;;;368      /* Check the parameters */
;;;369      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
;;;370    
;;;371      /* Disable the Input Capture channel 1
;;;372        (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
;;;373      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  2200              MOVS     r2,#0
000006  4611              MOV      r1,r2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;374    
;;;375      /* Disable the capture compare Interrupts event */
;;;376      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  f0200002          BIC      r0,r0,#2
000016  6821              LDR      r1,[r4,#0]
000018  60c8              STR      r0,[r1,#0xc]
;;;377    
;;;378      /* Disable the Peripheral */
;;;379      __HAL_TIM_DISABLE(htim);
00001a  bf00              NOP      
00001c  6820              LDR      r0,[r4,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  f2411111          MOV      r1,#0x1111
000024  4008              ANDS     r0,r0,r1
000026  b950              CBNZ     r0,|L18.62|
000028  6820              LDR      r0,[r4,#0]
00002a  6a00              LDR      r0,[r0,#0x20]
00002c  1089              ASRS     r1,r1,#2
00002e  4008              ANDS     r0,r0,r1
000030  b928              CBNZ     r0,|L18.62|
000032  6820              LDR      r0,[r4,#0]
000034  6800              LDR      r0,[r0,#0]
000036  f0200001          BIC      r0,r0,#1
00003a  6821              LDR      r1,[r4,#0]
00003c  6008              STR      r0,[r1,#0]
                  |L18.62|
00003e  bf00              NOP      
;;;380    
;;;381      /* Return function status */
;;;382      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;383    }
000042  bd10              POP      {r4,pc}
;;;384    
                          ENDP


                          AREA ||i.HAL_TIMEx_MasterConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_MasterConfigSynchronization PROC
;;;1625     */
;;;1626   HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
000000  b510              PUSH     {r4,lr}
;;;1627                                                           TIM_MasterConfigTypeDef *sMasterConfig)
;;;1628   {
000002  4602              MOV      r2,r0
;;;1629     uint32_t tmpcr2;
;;;1630     uint32_t tmpsmcr;
;;;1631   
;;;1632     /* Check the parameters */
;;;1633     assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
;;;1634     assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
;;;1635     assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
;;;1636   
;;;1637     /* Check input state */
;;;1638     __HAL_LOCK(htim);
000004  bf00              NOP      
000006  f892003c          LDRB     r0,[r2,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L19.18|
00000e  2002              MOVS     r0,#2
                  |L19.16|
;;;1639   
;;;1640     /* Change the handler state */
;;;1641     htim->State = HAL_TIM_STATE_BUSY;
;;;1642   
;;;1643     /* Get the TIMx CR2 register value */
;;;1644     tmpcr2 = htim->Instance->CR2;
;;;1645   
;;;1646     /* Get the TIMx SMCR register value */
;;;1647     tmpsmcr = htim->Instance->SMCR;
;;;1648   
;;;1649     /* Reset the MMS Bits */
;;;1650     tmpcr2 &= ~TIM_CR2_MMS;
;;;1651     /* Select the TRGO source */
;;;1652     tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
;;;1653   
;;;1654     /* Reset the MSM Bit */
;;;1655     tmpsmcr &= ~TIM_SMCR_MSM;
;;;1656     /* Set master mode */
;;;1657     tmpsmcr |= sMasterConfig->MasterSlaveMode;
;;;1658   
;;;1659     /* Update TIMx CR2 */
;;;1660     htim->Instance->CR2 = tmpcr2;
;;;1661   
;;;1662     /* Update TIMx SMCR */
;;;1663     htim->Instance->SMCR = tmpsmcr;
;;;1664   
;;;1665     /* Change the htim state */
;;;1666     htim->State = HAL_TIM_STATE_READY;
;;;1667   
;;;1668     __HAL_UNLOCK(htim);
;;;1669   
;;;1670     return HAL_OK;
;;;1671   }
000010  bd10              POP      {r4,pc}
                  |L19.18|
000012  2001              MOVS     r0,#1                 ;1638
000014  f882003c          STRB     r0,[r2,#0x3c]         ;1638
000018  bf00              NOP                            ;1638
00001a  2002              MOVS     r0,#2                 ;1641
00001c  f882003d          STRB     r0,[r2,#0x3d]         ;1641
000020  6810              LDR      r0,[r2,#0]            ;1644
000022  6843              LDR      r3,[r0,#4]            ;1644
000024  6810              LDR      r0,[r2,#0]            ;1647
000026  6884              LDR      r4,[r0,#8]            ;1647
000028  f0230370          BIC      r3,r3,#0x70           ;1650
00002c  6808              LDR      r0,[r1,#0]            ;1652
00002e  4303              ORRS     r3,r3,r0              ;1652
000030  f0240480          BIC      r4,r4,#0x80           ;1655
000034  6848              LDR      r0,[r1,#4]            ;1657
000036  4304              ORRS     r4,r4,r0              ;1657
000038  6810              LDR      r0,[r2,#0]            ;1660
00003a  6043              STR      r3,[r0,#4]            ;1660
00003c  6810              LDR      r0,[r2,#0]            ;1663
00003e  6084              STR      r4,[r0,#8]            ;1663
000040  2001              MOVS     r0,#1                 ;1666
000042  f882003d          STRB     r0,[r2,#0x3d]         ;1666
000046  bf00              NOP                            ;1668
000048  2000              MOVS     r0,#0                 ;1668
00004a  f882003c          STRB     r0,[r2,#0x3c]         ;1668
00004e  bf00              NOP                            ;1668
000050  bf00              NOP                            ;1670
000052  e7dd              B        |L19.16|
;;;1672   
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start PROC
;;;507      */
;;;508    HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;509    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;510      uint32_t tmpsmcr;
;;;511    
;;;512      /* Check the parameters */
;;;513      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;514    
;;;515      /* Enable the Capture compare channel N */
;;;516      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000006  2204              MOVS     r2,#4
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;517    
;;;518      /* Enable the Main Output */
;;;519      __HAL_TIM_MOE_ENABLE(htim);
000010  6820              LDR      r0,[r4,#0]
000012  6c40              LDR      r0,[r0,#0x44]
000014  f4404000          ORR      r0,r0,#0x8000
000018  6821              LDR      r1,[r4,#0]
00001a  6448              STR      r0,[r1,#0x44]
;;;520    
;;;521      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;522      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
00001c  6820              LDR      r0,[r4,#0]
00001e  6880              LDR      r0,[r0,#8]
000020  f0000607          AND      r6,r0,#7
;;;523      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000024  2e06              CMP      r6,#6
000026  d005              BEQ      |L20.52|
;;;524      {
;;;525        __HAL_TIM_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400001          ORR      r0,r0,#1
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
                  |L20.52|
;;;526      }
;;;527    
;;;528      /* Return function status */
;;;529      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;530    }
000036  bd70              POP      {r4-r6,pc}
;;;531    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_DMA PROC
;;;703      */
;;;704    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;705    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;706      uint32_t tmpsmcr;
;;;707    
;;;708      /* Check the parameters */
;;;709      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;710    
;;;711      if ((htim->State == HAL_TIM_STATE_BUSY))
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L21.24|
                  |L21.20|
;;;712      {
;;;713        return HAL_BUSY;
;;;714      }
;;;715      else if ((htim->State == HAL_TIM_STATE_READY))
;;;716      {
;;;717        if (((uint32_t)pData == 0U) && (Length > 0U))
;;;718        {
;;;719          return HAL_ERROR;
;;;720        }
;;;721        else
;;;722        {
;;;723          htim->State = HAL_TIM_STATE_BUSY;
;;;724        }
;;;725      }
;;;726      else
;;;727      {
;;;728        /* nothing to do  */
;;;729      }
;;;730    
;;;731      switch (Channel)
;;;732      {
;;;733        case TIM_CHANNEL_1:
;;;734        {
;;;735          /* Set the DMA compare callbacks */
;;;736          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;737          htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;738    
;;;739          /* Set the DMA error callback */
;;;740          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;741    
;;;742          /* Enable the DMA stream */
;;;743          if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
;;;744          {
;;;745            return HAL_ERROR;
;;;746          }
;;;747          /* Enable the TIM Output Compare DMA request */
;;;748          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;749          break;
;;;750        }
;;;751    
;;;752        case TIM_CHANNEL_2:
;;;753        {
;;;754          /* Set the DMA compare callbacks */
;;;755          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;756          htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;757    
;;;758          /* Set the DMA error callback */
;;;759          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;760    
;;;761          /* Enable the DMA stream */
;;;762          if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
;;;763          {
;;;764            return HAL_ERROR;
;;;765          }
;;;766          /* Enable the TIM Output Compare DMA request */
;;;767          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;768          break;
;;;769        }
;;;770    
;;;771        case TIM_CHANNEL_3:
;;;772        {
;;;773          /* Set the DMA compare callbacks */
;;;774          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;775          htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;776    
;;;777          /* Set the DMA error callback */
;;;778          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;779    
;;;780          /* Enable the DMA stream */
;;;781          if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
;;;782          {
;;;783            return HAL_ERROR;
;;;784          }
;;;785          /* Enable the TIM Output Compare DMA request */
;;;786          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;787          break;
;;;788        }
;;;789    
;;;790        default:
;;;791          break;
;;;792      }
;;;793    
;;;794      /* Enable the Capture compare channel N */
;;;795      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;796    
;;;797      /* Enable the Main Output */
;;;798      __HAL_TIM_MOE_ENABLE(htim);
;;;799    
;;;800      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;801      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;802      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;803      {
;;;804        __HAL_TIM_ENABLE(htim);
;;;805      }
;;;806    
;;;807      /* Return function status */
;;;808      return HAL_OK;
;;;809    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L21.24|
000018  f894003d          LDRB     r0,[r4,#0x3d]         ;715
00001c  2801              CMP      r0,#1                 ;715
00001e  d105              BNE      |L21.44|
000020  b90d              CBNZ     r5,|L21.38|
000022  b107              CBZ      r7,|L21.38|
000024  e7f6              B        |L21.20|
                  |L21.38|
000026  2002              MOVS     r0,#2                 ;723
000028  f884003d          STRB     r0,[r4,#0x3d]         ;723
                  |L21.44|
00002c  b126              CBZ      r6,|L21.56|
00002e  2e04              CMP      r6,#4                 ;731
000030  d01d              BEQ      |L21.110|
000032  2e08              CMP      r6,#8                 ;731
000034  d151              BNE      |L21.218|
000036  e035              B        |L21.164|
                  |L21.56|
000038  4936              LDR      r1,|L21.276|
00003a  6a60              LDR      r0,[r4,#0x24]         ;736
00003c  63c1              STR      r1,[r0,#0x3c]         ;736
00003e  4936              LDR      r1,|L21.280|
000040  6a60              LDR      r0,[r4,#0x24]         ;737
000042  6401              STR      r1,[r0,#0x40]         ;737
000044  4935              LDR      r1,|L21.284|
000046  6a60              LDR      r0,[r4,#0x24]         ;740
000048  64c1              STR      r1,[r0,#0x4c]         ;740
00004a  6821              LDR      r1,[r4,#0]            ;743
00004c  f1010234          ADD      r2,r1,#0x34           ;743
000050  463b              MOV      r3,r7                 ;743
000052  4629              MOV      r1,r5                 ;743
000054  6a60              LDR      r0,[r4,#0x24]         ;743
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  b108              CBZ      r0,|L21.96|
00005c  2001              MOVS     r0,#1                 ;745
00005e  e7d9              B        |L21.20|
                  |L21.96|
000060  6820              LDR      r0,[r4,#0]            ;748
000062  68c0              LDR      r0,[r0,#0xc]          ;748
000064  f4407000          ORR      r0,r0,#0x200          ;748
000068  6821              LDR      r1,[r4,#0]            ;748
00006a  60c8              STR      r0,[r1,#0xc]          ;748
00006c  e036              B        |L21.220|
                  |L21.110|
00006e  4929              LDR      r1,|L21.276|
000070  6aa0              LDR      r0,[r4,#0x28]         ;755
000072  63c1              STR      r1,[r0,#0x3c]         ;755
000074  4928              LDR      r1,|L21.280|
000076  6aa0              LDR      r0,[r4,#0x28]         ;756
000078  6401              STR      r1,[r0,#0x40]         ;756
00007a  4928              LDR      r1,|L21.284|
00007c  6aa0              LDR      r0,[r4,#0x28]         ;759
00007e  64c1              STR      r1,[r0,#0x4c]         ;759
000080  6821              LDR      r1,[r4,#0]            ;762
000082  f1010238          ADD      r2,r1,#0x38           ;762
000086  463b              MOV      r3,r7                 ;762
000088  4629              MOV      r1,r5                 ;762
00008a  6aa0              LDR      r0,[r4,#0x28]         ;762
00008c  f7fffffe          BL       HAL_DMA_Start_IT
000090  b108              CBZ      r0,|L21.150|
000092  2001              MOVS     r0,#1                 ;764
000094  e7be              B        |L21.20|
                  |L21.150|
000096  6820              LDR      r0,[r4,#0]            ;767
000098  68c0              LDR      r0,[r0,#0xc]          ;767
00009a  f4406080          ORR      r0,r0,#0x400          ;767
00009e  6821              LDR      r1,[r4,#0]            ;767
0000a0  60c8              STR      r0,[r1,#0xc]          ;767
0000a2  e01b              B        |L21.220|
                  |L21.164|
0000a4  491b              LDR      r1,|L21.276|
0000a6  6ae0              LDR      r0,[r4,#0x2c]         ;774
0000a8  63c1              STR      r1,[r0,#0x3c]         ;774
0000aa  491b              LDR      r1,|L21.280|
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;775
0000ae  6401              STR      r1,[r0,#0x40]         ;775
0000b0  491a              LDR      r1,|L21.284|
0000b2  6ae0              LDR      r0,[r4,#0x2c]         ;778
0000b4  64c1              STR      r1,[r0,#0x4c]         ;778
0000b6  6821              LDR      r1,[r4,#0]            ;781
0000b8  f101023c          ADD      r2,r1,#0x3c           ;781
0000bc  463b              MOV      r3,r7                 ;781
0000be  4629              MOV      r1,r5                 ;781
0000c0  6ae0              LDR      r0,[r4,#0x2c]         ;781
0000c2  f7fffffe          BL       HAL_DMA_Start_IT
0000c6  b108              CBZ      r0,|L21.204|
0000c8  2001              MOVS     r0,#1                 ;783
0000ca  e7a3              B        |L21.20|
                  |L21.204|
0000cc  6820              LDR      r0,[r4,#0]            ;786
0000ce  68c0              LDR      r0,[r0,#0xc]          ;786
0000d0  f4406000          ORR      r0,r0,#0x800          ;786
0000d4  6821              LDR      r1,[r4,#0]            ;786
0000d6  60c8              STR      r0,[r1,#0xc]          ;786
0000d8  e000              B        |L21.220|
                  |L21.218|
0000da  bf00              NOP                            ;791
                  |L21.220|
0000dc  bf00              NOP                            ;749
0000de  2204              MOVS     r2,#4                 ;795
0000e0  4631              MOV      r1,r6                 ;795
0000e2  6820              LDR      r0,[r4,#0]            ;795
0000e4  f7fffffe          BL       TIM_CCxNChannelCmd
0000e8  6820              LDR      r0,[r4,#0]            ;798
0000ea  6c40              LDR      r0,[r0,#0x44]         ;798
0000ec  f4404000          ORR      r0,r0,#0x8000         ;798
0000f0  6821              LDR      r1,[r4,#0]            ;798
0000f2  6448              STR      r0,[r1,#0x44]         ;798
0000f4  6820              LDR      r0,[r4,#0]            ;801
0000f6  6880              LDR      r0,[r0,#8]            ;801
0000f8  f0000807          AND      r8,r0,#7              ;801
0000fc  f1b80f06          CMP      r8,#6                 ;802
000100  d005              BEQ      |L21.270|
000102  6820              LDR      r0,[r4,#0]            ;804
000104  6800              LDR      r0,[r0,#0]            ;804
000106  f0400001          ORR      r0,r0,#1              ;804
00010a  6821              LDR      r1,[r4,#0]            ;804
00010c  6008              STR      r0,[r1,#0]            ;804
                  |L21.270|
00010e  2000              MOVS     r0,#0                 ;808
000110  e780              B        |L21.20|
;;;810    
                          ENDP

000112  0000              DCW      0x0000
                  |L21.276|
                          DCD      TIM_DMADelayPulseCplt
                  |L21.280|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L21.284|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_OCN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start_IT PROC
;;;571      */
;;;572    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;573    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;574      uint32_t tmpsmcr;
;;;575    
;;;576      /* Check the parameters */
;;;577      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;578    
;;;579      switch (Channel)
000006  b125              CBZ      r5,|L22.18|
000008  2d04              CMP      r5,#4
00000a  d009              BEQ      |L22.32|
00000c  2d08              CMP      r5,#8
00000e  d115              BNE      |L22.60|
000010  e00d              B        |L22.46|
                  |L22.18|
;;;580      {
;;;581        case TIM_CHANNEL_1:
;;;582        {
;;;583          /* Enable the TIM Output Compare interrupt */
;;;584          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0400002          ORR      r0,r0,#2
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;585          break;
00001e  e00e              B        |L22.62|
                  |L22.32|
;;;586        }
;;;587    
;;;588        case TIM_CHANNEL_2:
;;;589        {
;;;590          /* Enable the TIM Output Compare interrupt */
;;;591          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000020  6820              LDR      r0,[r4,#0]
000022  68c0              LDR      r0,[r0,#0xc]
000024  f0400004          ORR      r0,r0,#4
000028  6821              LDR      r1,[r4,#0]
00002a  60c8              STR      r0,[r1,#0xc]
;;;592          break;
00002c  e007              B        |L22.62|
                  |L22.46|
;;;593        }
;;;594    
;;;595        case TIM_CHANNEL_3:
;;;596        {
;;;597          /* Enable the TIM Output Compare interrupt */
;;;598          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f0400008          ORR      r0,r0,#8
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
;;;599          break;
00003a  e000              B        |L22.62|
                  |L22.60|
;;;600        }
;;;601    
;;;602    
;;;603        default:
;;;604          break;
00003c  bf00              NOP      
                  |L22.62|
00003e  bf00              NOP                            ;585
;;;605      }
;;;606    
;;;607      /* Enable the TIM Break interrupt */
;;;608      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400080          ORR      r0,r0,#0x80
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;609    
;;;610      /* Enable the Capture compare channel N */
;;;611      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
00004c  2204              MOVS     r2,#4
00004e  4629              MOV      r1,r5
000050  6820              LDR      r0,[r4,#0]
000052  f7fffffe          BL       TIM_CCxNChannelCmd
;;;612    
;;;613      /* Enable the Main Output */
;;;614      __HAL_TIM_MOE_ENABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6c40              LDR      r0,[r0,#0x44]
00005a  f4404000          ORR      r0,r0,#0x8000
00005e  6821              LDR      r1,[r4,#0]
000060  6448              STR      r0,[r1,#0x44]
;;;615    
;;;616      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;617      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
000062  6820              LDR      r0,[r4,#0]
000064  6880              LDR      r0,[r0,#8]
000066  f0000607          AND      r6,r0,#7
;;;618      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
00006a  2e06              CMP      r6,#6
00006c  d005              BEQ      |L22.122|
;;;619      {
;;;620        __HAL_TIM_ENABLE(htim);
00006e  6820              LDR      r0,[r4,#0]
000070  6800              LDR      r0,[r0,#0]
000072  f0400001          ORR      r0,r0,#1
000076  6821              LDR      r1,[r4,#0]
000078  6008              STR      r0,[r1,#0]
                  |L22.122|
;;;621      }
;;;622    
;;;623      /* Return function status */
;;;624      return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;625    }
00007c  bd70              POP      {r4-r6,pc}
;;;626    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop PROC
;;;542      */
;;;543    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;544    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;545      /* Check the parameters */
;;;546      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;547    
;;;548      /* Disable the Capture compare channel N */
;;;549      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;550    
;;;551      /* Disable the Main Output */
;;;552      __HAL_TIM_MOE_DISABLE(htim);
000010  bf00              NOP      
000012  6820              LDR      r0,[r4,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  f2411111          MOV      r1,#0x1111
00001a  4008              ANDS     r0,r0,r1
00001c  b950              CBNZ     r0,|L23.52|
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1089              ASRS     r1,r1,#2
000024  4008              ANDS     r0,r0,r1
000026  b928              CBNZ     r0,|L23.52|
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4204000          BIC      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L23.52|
000034  bf00              NOP      
;;;553    
;;;554      /* Disable the Peripheral */
;;;555      __HAL_TIM_DISABLE(htim);
000036  bf00              NOP      
000038  6820              LDR      r0,[r4,#0]
00003a  6a00              LDR      r0,[r0,#0x20]
00003c  f2411111          MOV      r1,#0x1111
000040  4008              ANDS     r0,r0,r1
000042  b950              CBNZ     r0,|L23.90|
000044  6820              LDR      r0,[r4,#0]
000046  6a00              LDR      r0,[r0,#0x20]
000048  1089              ASRS     r1,r1,#2
00004a  4008              ANDS     r0,r0,r1
00004c  b928              CBNZ     r0,|L23.90|
00004e  6820              LDR      r0,[r4,#0]
000050  6800              LDR      r0,[r0,#0]
000052  f0200001          BIC      r0,r0,#1
000056  6821              LDR      r1,[r4,#0]
000058  6008              STR      r0,[r1,#0]
                  |L23.90|
00005a  bf00              NOP      
;;;556    
;;;557      /* Return function status */
;;;558      return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;559    }
00005e  bd70              POP      {r4-r6,pc}
;;;560    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_DMA PROC
;;;821      */
;;;822    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;823    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;824      /* Check the parameters */
;;;825      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;826    
;;;827      switch (Channel)
000006  b125              CBZ      r5,|L24.18|
000008  2d04              CMP      r5,#4
00000a  d00c              BEQ      |L24.38|
00000c  2d08              CMP      r5,#8
00000e  d11e              BNE      |L24.78|
000010  e013              B        |L24.58|
                  |L24.18|
;;;828      {
;;;829        case TIM_CHANNEL_1:
;;;830        {
;;;831          /* Disable the TIM Output Compare DMA request */
;;;832          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f4207000          BIC      r0,r0,#0x200
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;833          (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00001e  6a60              LDR      r0,[r4,#0x24]
000020  f7fffffe          BL       HAL_DMA_Abort_IT
;;;834          break;
000024  e014              B        |L24.80|
                  |L24.38|
;;;835        }
;;;836    
;;;837        case TIM_CHANNEL_2:
;;;838        {
;;;839          /* Disable the TIM Output Compare DMA request */
;;;840          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f4206080          BIC      r0,r0,#0x400
00002e  6821              LDR      r1,[r4,#0]
000030  60c8              STR      r0,[r1,#0xc]
;;;841          (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000032  6aa0              LDR      r0,[r4,#0x28]
000034  f7fffffe          BL       HAL_DMA_Abort_IT
;;;842          break;
000038  e00a              B        |L24.80|
                  |L24.58|
;;;843        }
;;;844    
;;;845        case TIM_CHANNEL_3:
;;;846        {
;;;847          /* Disable the TIM Output Compare DMA request */
;;;848          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00003a  6820              LDR      r0,[r4,#0]
00003c  68c0              LDR      r0,[r0,#0xc]
00003e  f4206000          BIC      r0,r0,#0x800
000042  6821              LDR      r1,[r4,#0]
000044  60c8              STR      r0,[r1,#0xc]
;;;849          (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  f7fffffe          BL       HAL_DMA_Abort_IT
;;;850          break;
00004c  e000              B        |L24.80|
                  |L24.78|
;;;851        }
;;;852    
;;;853        default:
;;;854          break;
00004e  bf00              NOP      
                  |L24.80|
000050  bf00              NOP                            ;834
;;;855      }
;;;856    
;;;857      /* Disable the Capture compare channel N */
;;;858      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxNChannelCmd
;;;859    
;;;860      /* Disable the Main Output */
;;;861      __HAL_TIM_MOE_DISABLE(htim);
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L24.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L24.128|
000074  6820              LDR      r0,[r4,#0]
000076  6c40              LDR      r0,[r0,#0x44]
000078  f4204000          BIC      r0,r0,#0x8000
00007c  6821              LDR      r1,[r4,#0]
00007e  6448              STR      r0,[r1,#0x44]
                  |L24.128|
000080  bf00              NOP      
;;;862    
;;;863      /* Disable the Peripheral */
;;;864      __HAL_TIM_DISABLE(htim);
000082  bf00              NOP      
000084  6820              LDR      r0,[r4,#0]
000086  6a00              LDR      r0,[r0,#0x20]
000088  f2411111          MOV      r1,#0x1111
00008c  4008              ANDS     r0,r0,r1
00008e  b950              CBNZ     r0,|L24.166|
000090  6820              LDR      r0,[r4,#0]
000092  6a00              LDR      r0,[r0,#0x20]
000094  1089              ASRS     r1,r1,#2
000096  4008              ANDS     r0,r0,r1
000098  b928              CBNZ     r0,|L24.166|
00009a  6820              LDR      r0,[r4,#0]
00009c  6800              LDR      r0,[r0,#0]
00009e  f0200001          BIC      r0,r0,#1
0000a2  6821              LDR      r1,[r4,#0]
0000a4  6008              STR      r0,[r1,#0]
                  |L24.166|
0000a6  bf00              NOP      
;;;865    
;;;866      /* Change the htim state */
;;;867      htim->State = HAL_TIM_STATE_READY;
0000a8  2001              MOVS     r0,#1
0000aa  f884003d          STRB     r0,[r4,#0x3d]
;;;868    
;;;869      /* Return function status */
;;;870      return HAL_OK;
0000ae  2000              MOVS     r0,#0
;;;871    }
0000b0  bd70              POP      {r4-r6,pc}
;;;872    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_IT PROC
;;;637      */
;;;638    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;639    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;640      uint32_t tmpccer;
;;;641      /* Check the parameters */
;;;642      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;643    
;;;644      switch (Channel)
000006  b125              CBZ      r5,|L25.18|
000008  2d04              CMP      r5,#4
00000a  d009              BEQ      |L25.32|
00000c  2d08              CMP      r5,#8
00000e  d115              BNE      |L25.60|
000010  e00d              B        |L25.46|
                  |L25.18|
;;;645      {
;;;646        case TIM_CHANNEL_1:
;;;647        {
;;;648          /* Disable the TIM Output Compare interrupt */
;;;649          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200002          BIC      r0,r0,#2
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;650          break;
00001e  e00e              B        |L25.62|
                  |L25.32|
;;;651        }
;;;652    
;;;653        case TIM_CHANNEL_2:
;;;654        {
;;;655          /* Disable the TIM Output Compare interrupt */
;;;656          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000020  6820              LDR      r0,[r4,#0]
000022  68c0              LDR      r0,[r0,#0xc]
000024  f0200004          BIC      r0,r0,#4
000028  6821              LDR      r1,[r4,#0]
00002a  60c8              STR      r0,[r1,#0xc]
;;;657          break;
00002c  e007              B        |L25.62|
                  |L25.46|
;;;658        }
;;;659    
;;;660        case TIM_CHANNEL_3:
;;;661        {
;;;662          /* Disable the TIM Output Compare interrupt */
;;;663          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f0200008          BIC      r0,r0,#8
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
;;;664          break;
00003a  e000              B        |L25.62|
                  |L25.60|
;;;665        }
;;;666    
;;;667        default:
;;;668          break;
00003c  bf00              NOP      
                  |L25.62|
00003e  bf00              NOP                            ;650
;;;669      }
;;;670    
;;;671      /* Disable the Capture compare channel N */
;;;672      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000040  2200              MOVS     r2,#0
000042  4629              MOV      r1,r5
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       TIM_CCxNChannelCmd
;;;673    
;;;674      /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;675      tmpccer = htim->Instance->CCER;
00004a  6820              LDR      r0,[r4,#0]
00004c  6a06              LDR      r6,[r0,#0x20]
;;;676      if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
00004e  f2404044          MOV      r0,#0x444
000052  4030              ANDS     r0,r0,r6
000054  b928              CBNZ     r0,|L25.98|
;;;677      {
;;;678        __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000056  6820              LDR      r0,[r4,#0]
000058  68c0              LDR      r0,[r0,#0xc]
00005a  f0200080          BIC      r0,r0,#0x80
00005e  6821              LDR      r1,[r4,#0]
000060  60c8              STR      r0,[r1,#0xc]
                  |L25.98|
;;;679      }
;;;680    
;;;681      /* Disable the Main Output */
;;;682      __HAL_TIM_MOE_DISABLE(htim);
000062  bf00              NOP      
000064  6820              LDR      r0,[r4,#0]
000066  6a00              LDR      r0,[r0,#0x20]
000068  f2411111          MOV      r1,#0x1111
00006c  4008              ANDS     r0,r0,r1
00006e  b950              CBNZ     r0,|L25.134|
000070  6820              LDR      r0,[r4,#0]
000072  6a00              LDR      r0,[r0,#0x20]
000074  1089              ASRS     r1,r1,#2
000076  4008              ANDS     r0,r0,r1
000078  b928              CBNZ     r0,|L25.134|
00007a  6820              LDR      r0,[r4,#0]
00007c  6c40              LDR      r0,[r0,#0x44]
00007e  f4204000          BIC      r0,r0,#0x8000
000082  6821              LDR      r1,[r4,#0]
000084  6448              STR      r0,[r1,#0x44]
                  |L25.134|
000086  bf00              NOP      
;;;683    
;;;684      /* Disable the Peripheral */
;;;685      __HAL_TIM_DISABLE(htim);
000088  bf00              NOP      
00008a  6820              LDR      r0,[r4,#0]
00008c  6a00              LDR      r0,[r0,#0x20]
00008e  f2411111          MOV      r1,#0x1111
000092  4008              ANDS     r0,r0,r1
000094  b950              CBNZ     r0,|L25.172|
000096  6820              LDR      r0,[r4,#0]
000098  6a00              LDR      r0,[r0,#0x20]
00009a  1089              ASRS     r1,r1,#2
00009c  4008              ANDS     r0,r0,r1
00009e  b928              CBNZ     r0,|L25.172|
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6800              LDR      r0,[r0,#0]
0000a4  f0200001          BIC      r0,r0,#1
0000a8  6821              LDR      r1,[r4,#0]
0000aa  6008              STR      r0,[r1,#0]
                  |L25.172|
0000ac  bf00              NOP      
;;;686    
;;;687      /* Return function status */
;;;688      return HAL_OK;
0000ae  2000              MOVS     r0,#0
;;;689    }
0000b0  bd70              POP      {r4-r6,pc}
;;;690    
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start PROC
;;;1311     */
;;;1312   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b570              PUSH     {r4-r6,lr}
;;;1313   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1314     /* Check the parameters */
;;;1315     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1316   
;;;1317     /* Enable the complementary One Pulse output */
;;;1318     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
000006  2204              MOVS     r2,#4
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1319   
;;;1320     /* Enable the Main Output */
;;;1321     __HAL_TIM_MOE_ENABLE(htim);
000010  6820              LDR      r0,[r4,#0]
000012  6c40              LDR      r0,[r0,#0x44]
000014  f4404000          ORR      r0,r0,#0x8000
000018  6821              LDR      r1,[r4,#0]
00001a  6448              STR      r0,[r1,#0x44]
;;;1322   
;;;1323     /* Return function status */
;;;1324     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;1325   }
00001e  bd70              POP      {r4-r6,pc}
;;;1326   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start_IT PROC
;;;1365     */
;;;1366   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b570              PUSH     {r4-r6,lr}
;;;1367   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1368     /* Check the parameters */
;;;1369     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1370   
;;;1371     /* Enable the TIM Capture/Compare 1 interrupt */
;;;1372     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0400002          ORR      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;1373   
;;;1374     /* Enable the TIM Capture/Compare 2 interrupt */
;;;1375     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0400004          ORR      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;1376   
;;;1377     /* Enable the complementary One Pulse output */
;;;1378     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
00001e  2204              MOVS     r2,#4
000020  4629              MOV      r1,r5
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1379   
;;;1380     /* Enable the Main Output */
;;;1381     __HAL_TIM_MOE_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4404000          ORR      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
;;;1382   
;;;1383     /* Return function status */
;;;1384     return HAL_OK;
000034  2000              MOVS     r0,#0
;;;1385   }
000036  bd70              POP      {r4-r6,pc}
;;;1386   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop PROC
;;;1336     */
;;;1337   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b570              PUSH     {r4-r6,lr}
;;;1338   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1339   
;;;1340     /* Check the parameters */
;;;1341     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1342   
;;;1343     /* Disable the complementary One Pulse output */
;;;1344     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1345   
;;;1346     /* Disable the Main Output */
;;;1347     __HAL_TIM_MOE_DISABLE(htim);
000010  bf00              NOP      
000012  6820              LDR      r0,[r4,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  f2411111          MOV      r1,#0x1111
00001a  4008              ANDS     r0,r0,r1
00001c  b950              CBNZ     r0,|L28.52|
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1089              ASRS     r1,r1,#2
000024  4008              ANDS     r0,r0,r1
000026  b928              CBNZ     r0,|L28.52|
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4204000          BIC      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L28.52|
000034  bf00              NOP      
;;;1348   
;;;1349     /* Disable the Peripheral */
;;;1350     __HAL_TIM_DISABLE(htim);
000036  bf00              NOP      
000038  6820              LDR      r0,[r4,#0]
00003a  6a00              LDR      r0,[r0,#0x20]
00003c  f2411111          MOV      r1,#0x1111
000040  4008              ANDS     r0,r0,r1
000042  b950              CBNZ     r0,|L28.90|
000044  6820              LDR      r0,[r4,#0]
000046  6a00              LDR      r0,[r0,#0x20]
000048  1089              ASRS     r1,r1,#2
00004a  4008              ANDS     r0,r0,r1
00004c  b928              CBNZ     r0,|L28.90|
00004e  6820              LDR      r0,[r4,#0]
000050  6800              LDR      r0,[r0,#0]
000052  f0200001          BIC      r0,r0,#1
000056  6821              LDR      r1,[r4,#0]
000058  6008              STR      r0,[r1,#0]
                  |L28.90|
00005a  bf00              NOP      
;;;1351   
;;;1352     /* Return function status */
;;;1353     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;1354   }
00005e  bd70              POP      {r4-r6,pc}
;;;1355   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop_IT PROC
;;;1396     */
;;;1397   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b570              PUSH     {r4-r6,lr}
;;;1398   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1399     /* Check the parameters */
;;;1400     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
;;;1401   
;;;1402     /* Disable the TIM Capture/Compare 1 interrupt */
;;;1403     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0200002          BIC      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;1404   
;;;1405     /* Disable the TIM Capture/Compare 2 interrupt */
;;;1406     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200004          BIC      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;1407   
;;;1408     /* Disable the complementary One Pulse output */
;;;1409     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
00001e  2200              MOVS     r2,#0
000020  4629              MOV      r1,r5
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1410   
;;;1411     /* Disable the Main Output */
;;;1412     __HAL_TIM_MOE_DISABLE(htim);
000028  bf00              NOP      
00002a  6820              LDR      r0,[r4,#0]
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  4008              ANDS     r0,r0,r1
000034  b950              CBNZ     r0,|L29.76|
000036  6820              LDR      r0,[r4,#0]
000038  6a00              LDR      r0,[r0,#0x20]
00003a  1089              ASRS     r1,r1,#2
00003c  4008              ANDS     r0,r0,r1
00003e  b928              CBNZ     r0,|L29.76|
000040  6820              LDR      r0,[r4,#0]
000042  6c40              LDR      r0,[r0,#0x44]
000044  f4204000          BIC      r0,r0,#0x8000
000048  6821              LDR      r1,[r4,#0]
00004a  6448              STR      r0,[r1,#0x44]
                  |L29.76|
00004c  bf00              NOP      
;;;1413   
;;;1414     /* Disable the Peripheral */
;;;1415     __HAL_TIM_DISABLE(htim);
00004e  bf00              NOP      
000050  6820              LDR      r0,[r4,#0]
000052  6a00              LDR      r0,[r0,#0x20]
000054  f2411111          MOV      r1,#0x1111
000058  4008              ANDS     r0,r0,r1
00005a  b950              CBNZ     r0,|L29.114|
00005c  6820              LDR      r0,[r4,#0]
00005e  6a00              LDR      r0,[r0,#0x20]
000060  1089              ASRS     r1,r1,#2
000062  4008              ANDS     r0,r0,r1
000064  b928              CBNZ     r0,|L29.114|
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200001          BIC      r0,r0,#1
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L29.114|
000072  bf00              NOP      
;;;1416   
;;;1417     /* Return function status */
;;;1418     return HAL_OK;
000074  2000              MOVS     r0,#0
;;;1419   }
000076  bd70              POP      {r4-r6,pc}
;;;1420   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start PROC
;;;916      */
;;;917    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;918    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;919      uint32_t tmpsmcr;
;;;920    
;;;921      /* Check the parameters */
;;;922      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;923    
;;;924      /* Enable the complementary PWM output  */
;;;925      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000006  2204              MOVS     r2,#4
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;926    
;;;927      /* Enable the Main Output */
;;;928      __HAL_TIM_MOE_ENABLE(htim);
000010  6820              LDR      r0,[r4,#0]
000012  6c40              LDR      r0,[r0,#0x44]
000014  f4404000          ORR      r0,r0,#0x8000
000018  6821              LDR      r1,[r4,#0]
00001a  6448              STR      r0,[r1,#0x44]
;;;929    
;;;930      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;931      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
00001c  6820              LDR      r0,[r4,#0]
00001e  6880              LDR      r0,[r0,#8]
000020  f0000607          AND      r6,r0,#7
;;;932      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000024  2e06              CMP      r6,#6
000026  d005              BEQ      |L30.52|
;;;933      {
;;;934        __HAL_TIM_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400001          ORR      r0,r0,#1
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
                  |L30.52|
;;;935      }
;;;936    
;;;937      /* Return function status */
;;;938      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;939    }
000036  bd70              POP      {r4-r6,pc}
;;;940    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_DMA PROC
;;;1111     */
;;;1112   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1113   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1114     uint32_t tmpsmcr;
;;;1115   
;;;1116     /* Check the parameters */
;;;1117     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1118   
;;;1119     if ((htim->State == HAL_TIM_STATE_BUSY))
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L31.24|
                  |L31.20|
;;;1120     {
;;;1121       return HAL_BUSY;
;;;1122     }
;;;1123     else if ((htim->State == HAL_TIM_STATE_READY))
;;;1124     {
;;;1125       if (((uint32_t)pData == 0U) && (Length > 0U))
;;;1126       {
;;;1127         return HAL_ERROR;
;;;1128       }
;;;1129       else
;;;1130       {
;;;1131         htim->State = HAL_TIM_STATE_BUSY;
;;;1132       }
;;;1133     }
;;;1134     else
;;;1135     {
;;;1136       /* nothing to do */
;;;1137     }
;;;1138     switch (Channel)
;;;1139     {
;;;1140       case TIM_CHANNEL_1:
;;;1141       {
;;;1142         /* Set the DMA compare callbacks */
;;;1143         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1144         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1145   
;;;1146         /* Set the DMA error callback */
;;;1147         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1148   
;;;1149         /* Enable the DMA stream */
;;;1150         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
;;;1151         {
;;;1152           return HAL_ERROR;
;;;1153         }
;;;1154         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1155         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1156         break;
;;;1157       }
;;;1158   
;;;1159       case TIM_CHANNEL_2:
;;;1160       {
;;;1161         /* Set the DMA compare callbacks */
;;;1162         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1163         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1164   
;;;1165         /* Set the DMA error callback */
;;;1166         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1167   
;;;1168         /* Enable the DMA stream */
;;;1169         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
;;;1170         {
;;;1171           return HAL_ERROR;
;;;1172         }
;;;1173         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1174         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1175         break;
;;;1176       }
;;;1177   
;;;1178       case TIM_CHANNEL_3:
;;;1179       {
;;;1180         /* Set the DMA compare callbacks */
;;;1181         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1182         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1183   
;;;1184         /* Set the DMA error callback */
;;;1185         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1186   
;;;1187         /* Enable the DMA stream */
;;;1188         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
;;;1189         {
;;;1190           return HAL_ERROR;
;;;1191         }
;;;1192         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1193         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1194         break;
;;;1195       }
;;;1196   
;;;1197       default:
;;;1198         break;
;;;1199     }
;;;1200   
;;;1201     /* Enable the complementary PWM output  */
;;;1202     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1203   
;;;1204     /* Enable the Main Output */
;;;1205     __HAL_TIM_MOE_ENABLE(htim);
;;;1206   
;;;1207     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1208     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1209     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1210     {
;;;1211       __HAL_TIM_ENABLE(htim);
;;;1212     }
;;;1213   
;;;1214     /* Return function status */
;;;1215     return HAL_OK;
;;;1216   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L31.24|
000018  f894003d          LDRB     r0,[r4,#0x3d]         ;1123
00001c  2801              CMP      r0,#1                 ;1123
00001e  d105              BNE      |L31.44|
000020  b90d              CBNZ     r5,|L31.38|
000022  b107              CBZ      r7,|L31.38|
000024  e7f6              B        |L31.20|
                  |L31.38|
000026  2002              MOVS     r0,#2                 ;1131
000028  f884003d          STRB     r0,[r4,#0x3d]         ;1131
                  |L31.44|
00002c  b126              CBZ      r6,|L31.56|
00002e  2e04              CMP      r6,#4                 ;1138
000030  d01d              BEQ      |L31.110|
000032  2e08              CMP      r6,#8                 ;1138
000034  d151              BNE      |L31.218|
000036  e035              B        |L31.164|
                  |L31.56|
000038  4936              LDR      r1,|L31.276|
00003a  6a60              LDR      r0,[r4,#0x24]         ;1143
00003c  63c1              STR      r1,[r0,#0x3c]         ;1143
00003e  4936              LDR      r1,|L31.280|
000040  6a60              LDR      r0,[r4,#0x24]         ;1144
000042  6401              STR      r1,[r0,#0x40]         ;1144
000044  4935              LDR      r1,|L31.284|
000046  6a60              LDR      r0,[r4,#0x24]         ;1147
000048  64c1              STR      r1,[r0,#0x4c]         ;1147
00004a  6821              LDR      r1,[r4,#0]            ;1150
00004c  f1010234          ADD      r2,r1,#0x34           ;1150
000050  463b              MOV      r3,r7                 ;1150
000052  4629              MOV      r1,r5                 ;1150
000054  6a60              LDR      r0,[r4,#0x24]         ;1150
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  b108              CBZ      r0,|L31.96|
00005c  2001              MOVS     r0,#1                 ;1152
00005e  e7d9              B        |L31.20|
                  |L31.96|
000060  6820              LDR      r0,[r4,#0]            ;1155
000062  68c0              LDR      r0,[r0,#0xc]          ;1155
000064  f4407000          ORR      r0,r0,#0x200          ;1155
000068  6821              LDR      r1,[r4,#0]            ;1155
00006a  60c8              STR      r0,[r1,#0xc]          ;1155
00006c  e036              B        |L31.220|
                  |L31.110|
00006e  4929              LDR      r1,|L31.276|
000070  6aa0              LDR      r0,[r4,#0x28]         ;1162
000072  63c1              STR      r1,[r0,#0x3c]         ;1162
000074  4928              LDR      r1,|L31.280|
000076  6aa0              LDR      r0,[r4,#0x28]         ;1163
000078  6401              STR      r1,[r0,#0x40]         ;1163
00007a  4928              LDR      r1,|L31.284|
00007c  6aa0              LDR      r0,[r4,#0x28]         ;1166
00007e  64c1              STR      r1,[r0,#0x4c]         ;1166
000080  6821              LDR      r1,[r4,#0]            ;1169
000082  f1010238          ADD      r2,r1,#0x38           ;1169
000086  463b              MOV      r3,r7                 ;1169
000088  4629              MOV      r1,r5                 ;1169
00008a  6aa0              LDR      r0,[r4,#0x28]         ;1169
00008c  f7fffffe          BL       HAL_DMA_Start_IT
000090  b108              CBZ      r0,|L31.150|
000092  2001              MOVS     r0,#1                 ;1171
000094  e7be              B        |L31.20|
                  |L31.150|
000096  6820              LDR      r0,[r4,#0]            ;1174
000098  68c0              LDR      r0,[r0,#0xc]          ;1174
00009a  f4406080          ORR      r0,r0,#0x400          ;1174
00009e  6821              LDR      r1,[r4,#0]            ;1174
0000a0  60c8              STR      r0,[r1,#0xc]          ;1174
0000a2  e01b              B        |L31.220|
                  |L31.164|
0000a4  491b              LDR      r1,|L31.276|
0000a6  6ae0              LDR      r0,[r4,#0x2c]         ;1181
0000a8  63c1              STR      r1,[r0,#0x3c]         ;1181
0000aa  491b              LDR      r1,|L31.280|
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;1182
0000ae  6401              STR      r1,[r0,#0x40]         ;1182
0000b0  491a              LDR      r1,|L31.284|
0000b2  6ae0              LDR      r0,[r4,#0x2c]         ;1185
0000b4  64c1              STR      r1,[r0,#0x4c]         ;1185
0000b6  6821              LDR      r1,[r4,#0]            ;1188
0000b8  f101023c          ADD      r2,r1,#0x3c           ;1188
0000bc  463b              MOV      r3,r7                 ;1188
0000be  4629              MOV      r1,r5                 ;1188
0000c0  6ae0              LDR      r0,[r4,#0x2c]         ;1188
0000c2  f7fffffe          BL       HAL_DMA_Start_IT
0000c6  b108              CBZ      r0,|L31.204|
0000c8  2001              MOVS     r0,#1                 ;1190
0000ca  e7a3              B        |L31.20|
                  |L31.204|
0000cc  6820              LDR      r0,[r4,#0]            ;1193
0000ce  68c0              LDR      r0,[r0,#0xc]          ;1193
0000d0  f4406000          ORR      r0,r0,#0x800          ;1193
0000d4  6821              LDR      r1,[r4,#0]            ;1193
0000d6  60c8              STR      r0,[r1,#0xc]          ;1193
0000d8  e000              B        |L31.220|
                  |L31.218|
0000da  bf00              NOP                            ;1198
                  |L31.220|
0000dc  bf00              NOP                            ;1156
0000de  2204              MOVS     r2,#4                 ;1202
0000e0  4631              MOV      r1,r6                 ;1202
0000e2  6820              LDR      r0,[r4,#0]            ;1202
0000e4  f7fffffe          BL       TIM_CCxNChannelCmd
0000e8  6820              LDR      r0,[r4,#0]            ;1205
0000ea  6c40              LDR      r0,[r0,#0x44]         ;1205
0000ec  f4404000          ORR      r0,r0,#0x8000         ;1205
0000f0  6821              LDR      r1,[r4,#0]            ;1205
0000f2  6448              STR      r0,[r1,#0x44]         ;1205
0000f4  6820              LDR      r0,[r4,#0]            ;1208
0000f6  6880              LDR      r0,[r0,#8]            ;1208
0000f8  f0000807          AND      r8,r0,#7              ;1208
0000fc  f1b80f06          CMP      r8,#6                 ;1209
000100  d005              BEQ      |L31.270|
000102  6820              LDR      r0,[r4,#0]            ;1211
000104  6800              LDR      r0,[r0,#0]            ;1211
000106  f0400001          ORR      r0,r0,#1              ;1211
00010a  6821              LDR      r1,[r4,#0]            ;1211
00010c  6008              STR      r0,[r1,#0]            ;1211
                  |L31.270|
00010e  2000              MOVS     r0,#0                 ;1215
000110  e780              B        |L31.20|
;;;1217   
                          ENDP

000112  0000              DCW      0x0000
                  |L31.276|
                          DCD      TIM_DMADelayPulseCplt
                  |L31.280|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L31.284|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_PWMN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start_IT PROC
;;;979      */
;;;980    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;981    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;982      uint32_t tmpsmcr;
;;;983    
;;;984      /* Check the parameters */
;;;985      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;986    
;;;987      switch (Channel)
000006  b125              CBZ      r5,|L32.18|
000008  2d04              CMP      r5,#4
00000a  d009              BEQ      |L32.32|
00000c  2d08              CMP      r5,#8
00000e  d115              BNE      |L32.60|
000010  e00d              B        |L32.46|
                  |L32.18|
;;;988      {
;;;989        case TIM_CHANNEL_1:
;;;990        {
;;;991          /* Enable the TIM Capture/Compare 1 interrupt */
;;;992          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0400002          ORR      r0,r0,#2
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;993          break;
00001e  e00e              B        |L32.62|
                  |L32.32|
;;;994        }
;;;995    
;;;996        case TIM_CHANNEL_2:
;;;997        {
;;;998          /* Enable the TIM Capture/Compare 2 interrupt */
;;;999          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000020  6820              LDR      r0,[r4,#0]
000022  68c0              LDR      r0,[r0,#0xc]
000024  f0400004          ORR      r0,r0,#4
000028  6821              LDR      r1,[r4,#0]
00002a  60c8              STR      r0,[r1,#0xc]
;;;1000         break;
00002c  e007              B        |L32.62|
                  |L32.46|
;;;1001       }
;;;1002   
;;;1003       case TIM_CHANNEL_3:
;;;1004       {
;;;1005         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1006         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f0400008          ORR      r0,r0,#8
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
;;;1007         break;
00003a  e000              B        |L32.62|
                  |L32.60|
;;;1008       }
;;;1009   
;;;1010       default:
;;;1011         break;
00003c  bf00              NOP      
                  |L32.62|
00003e  bf00              NOP                            ;993
;;;1012     }
;;;1013   
;;;1014     /* Enable the TIM Break interrupt */
;;;1015     __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400080          ORR      r0,r0,#0x80
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1016   
;;;1017     /* Enable the complementary PWM output  */
;;;1018     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
00004c  2204              MOVS     r2,#4
00004e  4629              MOV      r1,r5
000050  6820              LDR      r0,[r4,#0]
000052  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1019   
;;;1020     /* Enable the Main Output */
;;;1021     __HAL_TIM_MOE_ENABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6c40              LDR      r0,[r0,#0x44]
00005a  f4404000          ORR      r0,r0,#0x8000
00005e  6821              LDR      r1,[r4,#0]
000060  6448              STR      r0,[r1,#0x44]
;;;1022   
;;;1023     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1024     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
000062  6820              LDR      r0,[r4,#0]
000064  6880              LDR      r0,[r0,#8]
000066  f0000607          AND      r6,r0,#7
;;;1025     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
00006a  2e06              CMP      r6,#6
00006c  d005              BEQ      |L32.122|
;;;1026     {
;;;1027       __HAL_TIM_ENABLE(htim);
00006e  6820              LDR      r0,[r4,#0]
000070  6800              LDR      r0,[r0,#0]
000072  f0400001          ORR      r0,r0,#1
000076  6821              LDR      r1,[r4,#0]
000078  6008              STR      r0,[r1,#0]
                  |L32.122|
;;;1028     }
;;;1029   
;;;1030     /* Return function status */
;;;1031     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;1032   }
00007c  bd70              POP      {r4-r6,pc}
;;;1033   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop PROC
;;;950      */
;;;951    HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;952    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;953      /* Check the parameters */
;;;954      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;955    
;;;956      /* Disable the complementary PWM output  */
;;;957      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;958    
;;;959      /* Disable the Main Output */
;;;960      __HAL_TIM_MOE_DISABLE(htim);
000010  bf00              NOP      
000012  6820              LDR      r0,[r4,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  f2411111          MOV      r1,#0x1111
00001a  4008              ANDS     r0,r0,r1
00001c  b950              CBNZ     r0,|L33.52|
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1089              ASRS     r1,r1,#2
000024  4008              ANDS     r0,r0,r1
000026  b928              CBNZ     r0,|L33.52|
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4204000          BIC      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L33.52|
000034  bf00              NOP      
;;;961    
;;;962      /* Disable the Peripheral */
;;;963      __HAL_TIM_DISABLE(htim);
000036  bf00              NOP      
000038  6820              LDR      r0,[r4,#0]
00003a  6a00              LDR      r0,[r0,#0x20]
00003c  f2411111          MOV      r1,#0x1111
000040  4008              ANDS     r0,r0,r1
000042  b950              CBNZ     r0,|L33.90|
000044  6820              LDR      r0,[r4,#0]
000046  6a00              LDR      r0,[r0,#0x20]
000048  1089              ASRS     r1,r1,#2
00004a  4008              ANDS     r0,r0,r1
00004c  b928              CBNZ     r0,|L33.90|
00004e  6820              LDR      r0,[r4,#0]
000050  6800              LDR      r0,[r0,#0]
000052  f0200001          BIC      r0,r0,#1
000056  6821              LDR      r1,[r4,#0]
000058  6008              STR      r0,[r1,#0]
                  |L33.90|
00005a  bf00              NOP      
;;;964    
;;;965      /* Return function status */
;;;966      return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;967    }
00005e  bd70              POP      {r4-r6,pc}
;;;968    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_DMA PROC
;;;1228     */
;;;1229   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1230   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1231     /* Check the parameters */
;;;1232     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1233   
;;;1234     switch (Channel)
000006  b125              CBZ      r5,|L34.18|
000008  2d04              CMP      r5,#4
00000a  d00c              BEQ      |L34.38|
00000c  2d08              CMP      r5,#8
00000e  d11e              BNE      |L34.78|
000010  e013              B        |L34.58|
                  |L34.18|
;;;1235     {
;;;1236       case TIM_CHANNEL_1:
;;;1237       {
;;;1238         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1239         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f4207000          BIC      r0,r0,#0x200
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;1240         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00001e  6a60              LDR      r0,[r4,#0x24]
000020  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1241         break;
000024  e014              B        |L34.80|
                  |L34.38|
;;;1242       }
;;;1243   
;;;1244       case TIM_CHANNEL_2:
;;;1245       {
;;;1246         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1247         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f4206080          BIC      r0,r0,#0x400
00002e  6821              LDR      r1,[r4,#0]
000030  60c8              STR      r0,[r1,#0xc]
;;;1248         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000032  6aa0              LDR      r0,[r4,#0x28]
000034  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1249         break;
000038  e00a              B        |L34.80|
                  |L34.58|
;;;1250       }
;;;1251   
;;;1252       case TIM_CHANNEL_3:
;;;1253       {
;;;1254         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1255         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00003a  6820              LDR      r0,[r4,#0]
00003c  68c0              LDR      r0,[r0,#0xc]
00003e  f4206000          BIC      r0,r0,#0x800
000042  6821              LDR      r1,[r4,#0]
000044  60c8              STR      r0,[r1,#0xc]
;;;1256         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1257         break;
00004c  e000              B        |L34.80|
                  |L34.78|
;;;1258       }
;;;1259   
;;;1260       default:
;;;1261         break;
00004e  bf00              NOP      
                  |L34.80|
000050  bf00              NOP                            ;1241
;;;1262     }
;;;1263   
;;;1264     /* Disable the complementary PWM output */
;;;1265     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1266   
;;;1267     /* Disable the Main Output */
;;;1268     __HAL_TIM_MOE_DISABLE(htim);
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L34.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L34.128|
000074  6820              LDR      r0,[r4,#0]
000076  6c40              LDR      r0,[r0,#0x44]
000078  f4204000          BIC      r0,r0,#0x8000
00007c  6821              LDR      r1,[r4,#0]
00007e  6448              STR      r0,[r1,#0x44]
                  |L34.128|
000080  bf00              NOP      
;;;1269   
;;;1270     /* Disable the Peripheral */
;;;1271     __HAL_TIM_DISABLE(htim);
000082  bf00              NOP      
000084  6820              LDR      r0,[r4,#0]
000086  6a00              LDR      r0,[r0,#0x20]
000088  f2411111          MOV      r1,#0x1111
00008c  4008              ANDS     r0,r0,r1
00008e  b950              CBNZ     r0,|L34.166|
000090  6820              LDR      r0,[r4,#0]
000092  6a00              LDR      r0,[r0,#0x20]
000094  1089              ASRS     r1,r1,#2
000096  4008              ANDS     r0,r0,r1
000098  b928              CBNZ     r0,|L34.166|
00009a  6820              LDR      r0,[r4,#0]
00009c  6800              LDR      r0,[r0,#0]
00009e  f0200001          BIC      r0,r0,#1
0000a2  6821              LDR      r1,[r4,#0]
0000a4  6008              STR      r0,[r1,#0]
                  |L34.166|
0000a6  bf00              NOP      
;;;1272   
;;;1273     /* Change the htim state */
;;;1274     htim->State = HAL_TIM_STATE_READY;
0000a8  2001              MOVS     r0,#1
0000aa  f884003d          STRB     r0,[r4,#0x3d]
;;;1275   
;;;1276     /* Return function status */
;;;1277     return HAL_OK;
0000ae  2000              MOVS     r0,#0
;;;1278   }
0000b0  bd70              POP      {r4-r6,pc}
;;;1279   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_IT PROC
;;;1044     */
;;;1045   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1046   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1047     uint32_t tmpccer;
;;;1048   
;;;1049     /* Check the parameters */
;;;1050     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
;;;1051   
;;;1052     switch (Channel)
000006  b125              CBZ      r5,|L35.18|
000008  2d04              CMP      r5,#4
00000a  d009              BEQ      |L35.32|
00000c  2d08              CMP      r5,#8
00000e  d115              BNE      |L35.60|
000010  e00d              B        |L35.46|
                  |L35.18|
;;;1053     {
;;;1054       case TIM_CHANNEL_1:
;;;1055       {
;;;1056         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1057         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200002          BIC      r0,r0,#2
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;1058         break;
00001e  e00e              B        |L35.62|
                  |L35.32|
;;;1059       }
;;;1060   
;;;1061       case TIM_CHANNEL_2:
;;;1062       {
;;;1063         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1064         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000020  6820              LDR      r0,[r4,#0]
000022  68c0              LDR      r0,[r0,#0xc]
000024  f0200004          BIC      r0,r0,#4
000028  6821              LDR      r1,[r4,#0]
00002a  60c8              STR      r0,[r1,#0xc]
;;;1065         break;
00002c  e007              B        |L35.62|
                  |L35.46|
;;;1066       }
;;;1067   
;;;1068       case TIM_CHANNEL_3:
;;;1069       {
;;;1070         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1071         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f0200008          BIC      r0,r0,#8
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
;;;1072         break;
00003a  e000              B        |L35.62|
                  |L35.60|
;;;1073       }
;;;1074   
;;;1075       default:
;;;1076         break;
00003c  bf00              NOP      
                  |L35.62|
00003e  bf00              NOP                            ;1058
;;;1077     }
;;;1078   
;;;1079     /* Disable the complementary PWM output  */
;;;1080     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000040  2200              MOVS     r2,#0
000042  4629              MOV      r1,r5
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1081   
;;;1082     /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;1083     tmpccer = htim->Instance->CCER;
00004a  6820              LDR      r0,[r4,#0]
00004c  6a06              LDR      r6,[r0,#0x20]
;;;1084     if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
00004e  f2404044          MOV      r0,#0x444
000052  4030              ANDS     r0,r0,r6
000054  b928              CBNZ     r0,|L35.98|
;;;1085     {
;;;1086       __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000056  6820              LDR      r0,[r4,#0]
000058  68c0              LDR      r0,[r0,#0xc]
00005a  f0200080          BIC      r0,r0,#0x80
00005e  6821              LDR      r1,[r4,#0]
000060  60c8              STR      r0,[r1,#0xc]
                  |L35.98|
;;;1087     }
;;;1088   
;;;1089     /* Disable the Main Output */
;;;1090     __HAL_TIM_MOE_DISABLE(htim);
000062  bf00              NOP      
000064  6820              LDR      r0,[r4,#0]
000066  6a00              LDR      r0,[r0,#0x20]
000068  f2411111          MOV      r1,#0x1111
00006c  4008              ANDS     r0,r0,r1
00006e  b950              CBNZ     r0,|L35.134|
000070  6820              LDR      r0,[r4,#0]
000072  6a00              LDR      r0,[r0,#0x20]
000074  1089              ASRS     r1,r1,#2
000076  4008              ANDS     r0,r0,r1
000078  b928              CBNZ     r0,|L35.134|
00007a  6820              LDR      r0,[r4,#0]
00007c  6c40              LDR      r0,[r0,#0x44]
00007e  f4204000          BIC      r0,r0,#0x8000
000082  6821              LDR      r1,[r4,#0]
000084  6448              STR      r0,[r1,#0x44]
                  |L35.134|
000086  bf00              NOP      
;;;1091   
;;;1092     /* Disable the Peripheral */
;;;1093     __HAL_TIM_DISABLE(htim);
000088  bf00              NOP      
00008a  6820              LDR      r0,[r4,#0]
00008c  6a00              LDR      r0,[r0,#0x20]
00008e  f2411111          MOV      r1,#0x1111
000092  4008              ANDS     r0,r0,r1
000094  b950              CBNZ     r0,|L35.172|
000096  6820              LDR      r0,[r4,#0]
000098  6a00              LDR      r0,[r0,#0x20]
00009a  1089              ASRS     r1,r1,#2
00009c  4008              ANDS     r0,r0,r1
00009e  b928              CBNZ     r0,|L35.172|
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6800              LDR      r0,[r0,#0]
0000a4  f0200001          BIC      r0,r0,#1
0000a8  6821              LDR      r1,[r4,#0]
0000aa  6008              STR      r0,[r1,#0]
                  |L35.172|
0000ac  bf00              NOP      
;;;1094   
;;;1095     /* Return function status */
;;;1096     return HAL_OK;
0000ae  2000              MOVS     r0,#0
;;;1097   }
0000b0  bd70              POP      {r4-r6,pc}
;;;1098   
                          ENDP


                          AREA ||i.HAL_TIMEx_RemapConfig||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_RemapConfig PROC
;;;1756     */
;;;1757   HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
000000  4602              MOV      r2,r0
;;;1758   {
;;;1759     __HAL_LOCK(htim);
000002  bf00              NOP      
000004  f892003c          LDRB     r0,[r2,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L36.16|
00000c  2002              MOVS     r0,#2
                  |L36.14|
;;;1760   
;;;1761     /* Check parameters */
;;;1762     assert_param(IS_TIM_REMAP(htim->Instance, Remap));
;;;1763   
;;;1764   #if defined(LPTIM_OR_TIM1_ITR2_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP)
;;;1765     if ((Remap & LPTIM_REMAP_MASK) == LPTIM_REMAP_MASK)
;;;1766     {
;;;1767       /* Connect TIMx internal trigger to LPTIM1 output */
;;;1768       __HAL_RCC_LPTIM1_CLK_ENABLE();
;;;1769       MODIFY_REG(LPTIM1->OR,
;;;1770                  (LPTIM_OR_TIM1_ITR2_RMP | LPTIM_OR_TIM5_ITR1_RMP | LPTIM_OR_TIM9_ITR1_RMP),
;;;1771                  Remap & ~(LPTIM_REMAP_MASK));
;;;1772     }
;;;1773     else
;;;1774     {
;;;1775       /* Set the Timer remapping configuration */
;;;1776       WRITE_REG(htim->Instance->OR, Remap);
;;;1777     }
;;;1778   #else
;;;1779     /* Set the Timer remapping configuration */
;;;1780     WRITE_REG(htim->Instance->OR, Remap);
;;;1781   #endif /* LPTIM_OR_TIM1_ITR2_RMP &&  LPTIM_OR_TIM5_ITR1_RMP && LPTIM_OR_TIM5_ITR1_RMP */
;;;1782   
;;;1783     __HAL_UNLOCK(htim);
;;;1784   
;;;1785     return HAL_OK;
;;;1786   }
00000e  4770              BX       lr
                  |L36.16|
000010  2001              MOVS     r0,#1                 ;1759
000012  f882003c          STRB     r0,[r2,#0x3c]         ;1759
000016  bf00              NOP                            ;1759
000018  6810              LDR      r0,[r2,#0]            ;1780
00001a  6501              STR      r1,[r0,#0x50]         ;1780
00001c  bf00              NOP                            ;1783
00001e  2000              MOVS     r0,#0                 ;1783
000020  f882003c          STRB     r0,[r2,#0x3c]         ;1783
000024  bf00              NOP                            ;1783
000026  bf00              NOP                            ;1785
000028  e7f1              B        |L36.14|
;;;1787   
                          ENDP


                          AREA ||i.TIMEx_DMACommutationCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationCplt PROC
;;;1897     */
;;;1898   void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1899   {
000002  4604              MOV      r4,r0
;;;1900     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1901   
;;;1902     /* Change the htim state */
;;;1903     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f885003d          STRB     r0,[r5,#0x3d]
;;;1904   
;;;1905   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1906     htim->CommutationCallback(htim);
;;;1907   #else
;;;1908     HAL_TIMEx_CommutCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIMEx_CommutCallback
;;;1909   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1910   }
000012  bd70              POP      {r4-r6,pc}
;;;1911   
                          ENDP


                          AREA ||i.TIMEx_DMACommutationHalfCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationHalfCplt PROC
;;;1916     */
;;;1917   void TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1918   {
000002  4604              MOV      r4,r0
;;;1919     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1920   
;;;1921     /* Change the htim state */
;;;1922     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f885003d          STRB     r0,[r5,#0x3d]
;;;1923   
;;;1924   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1925     htim->CommutationHalfCpltCallback(htim);
;;;1926   #else
;;;1927     HAL_TIMEx_CommutHalfCpltCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIMEx_CommutHalfCpltCallback
;;;1928   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1929   }
000012  bd70              POP      {r4-r6,pc}
;;;1930   
                          ENDP


                          AREA ||i.TIM_CCxNChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNChannelCmd PROC
;;;1943     */
;;;1944   static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)
000000  b530              PUSH     {r4,r5,lr}
;;;1945   {
;;;1946     uint32_t tmp;
;;;1947   
;;;1948     tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
000002  f001051f          AND      r5,r1,#0x1f
000006  2404              MOVS     r4,#4
000008  fa04f305          LSL      r3,r4,r5
;;;1949   
;;;1950     /* Reset the CCxNE Bit */
;;;1951     TIMx->CCER &=  ~tmp;
00000c  6a04              LDR      r4,[r0,#0x20]
00000e  439c              BICS     r4,r4,r3
000010  6204              STR      r4,[r0,#0x20]
;;;1952   
;;;1953     /* Set or reset the CCxNE Bit */
;;;1954     TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
000012  6a04              LDR      r4,[r0,#0x20]
000014  f001051f          AND      r5,r1,#0x1f
000018  fa02f505          LSL      r5,r2,r5
00001c  432c              ORRS     r4,r4,r5
00001e  6204              STR      r4,[r0,#0x20]
;;;1955   }
000020  bd30              POP      {r4,r5,pc}
;;;1956   /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____RRX|
#line 587
|__asm___22_stm32f4xx_hal_tim_ex_c_e8ef3920____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
