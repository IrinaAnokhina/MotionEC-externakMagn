; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_crc.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_crc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_crc.c]
                          THUMB

                          AREA ||i.HAL_CRC_Accumulate||, CODE, READONLY, ALIGN=1

                  HAL_CRC_Accumulate PROC
;;;228      */
;;;229    uint32_t HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;231      uint32_t index;      /* CRC input data buffer index */
;;;232      uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
000006  2000              MOVS     r0,#0
;;;233    
;;;234      /* Change CRC peripheral state */
;;;235      hcrc->State = HAL_CRC_STATE_BUSY;
000008  2502              MOVS     r5,#2
00000a  715d              STRB     r5,[r3,#5]
;;;236    
;;;237      /* Enter Data to the CRC calculator */
;;;238      for (index = 0U; index < BufferLength; index++)
00000c  2100              MOVS     r1,#0
00000e  e004              B        |L1.26|
                  |L1.16|
;;;239      {
;;;240        hcrc->Instance->DR = pBuffer[index];
000010  f8545021          LDR      r5,[r4,r1,LSL #2]
000014  681e              LDR      r6,[r3,#0]
000016  6035              STR      r5,[r6,#0]
000018  1c49              ADDS     r1,r1,#1              ;238
                  |L1.26|
00001a  4291              CMP      r1,r2                 ;238
00001c  d3f8              BCC      |L1.16|
;;;241      }
;;;242      temp = hcrc->Instance->DR;
00001e  681d              LDR      r5,[r3,#0]
000020  6828              LDR      r0,[r5,#0]
;;;243    
;;;244      /* Change CRC peripheral state */
;;;245      hcrc->State = HAL_CRC_STATE_READY;
000022  2501              MOVS     r5,#1
000024  715d              STRB     r5,[r3,#5]
;;;246    
;;;247      /* Return the CRC computed value */
;;;248      return temp;
;;;249    }
000026  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP


                          AREA ||i.HAL_CRC_Calculate||, CODE, READONLY, ALIGN=1

                  HAL_CRC_Calculate PROC
;;;258      */
;;;259    uint32_t HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength)
000000  b570              PUSH     {r4-r6,lr}
;;;260    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;261      uint32_t index;      /* CRC input data buffer index */
;;;262      uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
000006  2000              MOVS     r0,#0
;;;263    
;;;264      /* Change CRC peripheral state */
;;;265      hcrc->State = HAL_CRC_STATE_BUSY;
000008  2502              MOVS     r5,#2
00000a  715d              STRB     r5,[r3,#5]
;;;266    
;;;267      /* Reset CRC Calculation Unit (hcrc->Instance->INIT is
;;;268      *  written in hcrc->Instance->DR) */
;;;269      __HAL_CRC_DR_RESET(hcrc);
00000c  681d              LDR      r5,[r3,#0]
00000e  68ad              LDR      r5,[r5,#8]
000010  f0450501          ORR      r5,r5,#1
000014  681e              LDR      r6,[r3,#0]
000016  60b5              STR      r5,[r6,#8]
;;;270    
;;;271      /* Enter 32-bit input data to the CRC calculator */
;;;272      for (index = 0U; index < BufferLength; index++)
000018  2100              MOVS     r1,#0
00001a  e004              B        |L2.38|
                  |L2.28|
;;;273      {
;;;274        hcrc->Instance->DR = pBuffer[index];
00001c  f8545021          LDR      r5,[r4,r1,LSL #2]
000020  681e              LDR      r6,[r3,#0]
000022  6035              STR      r5,[r6,#0]
000024  1c49              ADDS     r1,r1,#1              ;272
                  |L2.38|
000026  4291              CMP      r1,r2                 ;272
000028  d3f8              BCC      |L2.28|
;;;275      }
;;;276      temp = hcrc->Instance->DR;
00002a  681d              LDR      r5,[r3,#0]
00002c  6828              LDR      r0,[r5,#0]
;;;277    
;;;278      /* Change CRC peripheral state */
;;;279      hcrc->State = HAL_CRC_STATE_READY;
00002e  2501              MOVS     r5,#1
000030  715d              STRB     r5,[r3,#5]
;;;280    
;;;281      /* Return the CRC computed value */
;;;282      return temp;
;;;283    }
000032  bd70              POP      {r4-r6,pc}
;;;284    
                          ENDP


                          AREA ||i.HAL_CRC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_CRC_DeInit PROC
;;;127      */
;;;128    HAL_StatusTypeDef HAL_CRC_DeInit(CRC_HandleTypeDef *hcrc)
000000  b510              PUSH     {r4,lr}
;;;129    {
000002  4604              MOV      r4,r0
;;;130      /* Check the CRC handle allocation */
;;;131      if (hcrc == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;132      {
;;;133        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;134      }
;;;135    
;;;136      /* Check the parameters */
;;;137      assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));
;;;138    
;;;139      /* Check the CRC peripheral state */
;;;140      if (hcrc->State == HAL_CRC_STATE_BUSY)
;;;141      {
;;;142        return HAL_BUSY;
;;;143      }
;;;144    
;;;145      /* Change CRC peripheral state */
;;;146      hcrc->State = HAL_CRC_STATE_BUSY;
;;;147    
;;;148      /* Reset CRC calculation unit */
;;;149      __HAL_CRC_DR_RESET(hcrc);
;;;150    
;;;151      /* Reset IDR register content */
;;;152      CLEAR_BIT(hcrc->Instance->IDR, CRC_IDR_IDR);
;;;153    
;;;154      /* DeInit the low level hardware */
;;;155      HAL_CRC_MspDeInit(hcrc);
;;;156    
;;;157      /* Change CRC peripheral state */
;;;158      hcrc->State = HAL_CRC_STATE_RESET;
;;;159    
;;;160      /* Process unlocked */
;;;161      __HAL_UNLOCK(hcrc);
;;;162    
;;;163      /* Return function status */
;;;164      return HAL_OK;
;;;165    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  7960              LDRB     r0,[r4,#5]            ;140
00000c  2802              CMP      r0,#2                 ;140
00000e  d100              BNE      |L3.18|
000010  e7fa              B        |L3.8|
                  |L3.18|
000012  2002              MOVS     r0,#2                 ;146
000014  7160              STRB     r0,[r4,#5]            ;146
000016  6820              LDR      r0,[r4,#0]            ;149
000018  6880              LDR      r0,[r0,#8]            ;149
00001a  f0400001          ORR      r0,r0,#1              ;149
00001e  6821              LDR      r1,[r4,#0]            ;149
000020  6088              STR      r0,[r1,#8]            ;149
000022  6820              LDR      r0,[r4,#0]            ;152
000024  7900              LDRB     r0,[r0,#4]            ;152
000026  2000              MOVS     r0,#0                 ;152
000028  6821              LDR      r1,[r4,#0]            ;152
00002a  7108              STRB     r0,[r1,#4]            ;152
00002c  4620              MOV      r0,r4                 ;155
00002e  f7fffffe          BL       HAL_CRC_MspDeInit
000032  2000              MOVS     r0,#0                 ;158
000034  7160              STRB     r0,[r4,#5]            ;158
000036  bf00              NOP                            ;161
000038  7120              STRB     r0,[r4,#4]            ;161
00003a  bf00              NOP                            ;161
00003c  bf00              NOP                            ;164
00003e  e7e3              B        |L3.8|
;;;166    
                          ENDP


                          AREA ||i.HAL_CRC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_CRC_GetState PROC
;;;307      */
;;;308    HAL_CRC_StateTypeDef HAL_CRC_GetState(CRC_HandleTypeDef *hcrc)
000000  4601              MOV      r1,r0
;;;309    {
;;;310      /* Return CRC handle state */
;;;311      return hcrc->State;
000002  7948              LDRB     r0,[r1,#5]
;;;312    }
000004  4770              BX       lr
;;;313    
                          ENDP


                          AREA ||i.HAL_CRC_Init||, CODE, READONLY, ALIGN=1

                  HAL_CRC_Init PROC
;;;94       */
;;;95     HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
000000  b510              PUSH     {r4,lr}
;;;96     {
000002  4604              MOV      r4,r0
;;;97       /* Check the CRC handle allocation */
;;;98       if (hcrc == NULL)
000004  b90c              CBNZ     r4,|L5.10|
;;;99       {
;;;100        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L5.8|
;;;101      }
;;;102    
;;;103      /* Check the parameters */
;;;104      assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));
;;;105    
;;;106      if (hcrc->State == HAL_CRC_STATE_RESET)
;;;107      {
;;;108        /* Allocate lock resource and initialize it */
;;;109        hcrc->Lock = HAL_UNLOCKED;
;;;110        /* Init the low level hardware */
;;;111        HAL_CRC_MspInit(hcrc);
;;;112      }
;;;113    
;;;114      hcrc->State = HAL_CRC_STATE_BUSY;
;;;115    
;;;116      /* Change CRC peripheral state */
;;;117      hcrc->State = HAL_CRC_STATE_READY;
;;;118    
;;;119      /* Return function status */
;;;120      return HAL_OK;
;;;121    }
000008  bd10              POP      {r4,pc}
                  |L5.10|
00000a  7960              LDRB     r0,[r4,#5]            ;106
00000c  b920              CBNZ     r0,|L5.24|
00000e  2000              MOVS     r0,#0                 ;109
000010  7120              STRB     r0,[r4,#4]            ;109
000012  4620              MOV      r0,r4                 ;111
000014  f7fffffe          BL       HAL_CRC_MspInit
                  |L5.24|
000018  2002              MOVS     r0,#2                 ;114
00001a  7160              STRB     r0,[r4,#5]            ;114
00001c  2001              MOVS     r0,#1                 ;117
00001e  7160              STRB     r0,[r4,#5]            ;117
000020  2000              MOVS     r0,#0                 ;120
000022  e7f1              B        |L5.8|
;;;122    
                          ENDP


                          AREA ||i.HAL_CRC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_CRC_MspDeInit PROC
;;;186      */
;;;187    __weak void HAL_CRC_MspDeInit(CRC_HandleTypeDef *hcrc)
000000  4770              BX       lr
;;;188    {
;;;189      /* Prevent unused argument(s) compilation warning */
;;;190      UNUSED(hcrc);
;;;191    
;;;192      /* NOTE : This function should not be modified, when the callback is needed,
;;;193                the HAL_CRC_MspDeInit can be implemented in the user file
;;;194       */
;;;195    }
;;;196    
                          ENDP


                          AREA ||i.HAL_CRC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_CRC_MspInit PROC
;;;171      */
;;;172    __weak void HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
000000  4770              BX       lr
;;;173    {
;;;174      /* Prevent unused argument(s) compilation warning */
;;;175      UNUSED(hcrc);
;;;176    
;;;177      /* NOTE : This function should not be modified, when the callback is needed,
;;;178                the HAL_CRC_MspInit can be implemented in the user file
;;;179       */
;;;180    }
;;;181    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_crc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_crc_c_14c421d9____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_crc_c_14c421d9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_crc_c_14c421d9____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_crc_c_14c421d9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_crc_c_14c421d9____RRX|
#line 587
|__asm___19_stm32f4xx_hal_crc_c_14c421d9____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
