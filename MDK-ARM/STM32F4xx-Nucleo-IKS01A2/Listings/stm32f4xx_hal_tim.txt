; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_tim.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;308      */
;;;309    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;310    {
000002  4604              MOV      r4,r0
;;;311      /* Check the parameters */
;;;312      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;313    
;;;314      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;315    
;;;316      /* Disable the TIM Peripheral Clock */
;;;317      __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L1.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L1.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L1.46|
00002e  bf00              NOP      
;;;318    
;;;319    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;320      if (htim->Base_MspDeInitCallback == NULL)
;;;321      {
;;;322        htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
;;;323      }
;;;324      /* DeInit the low level hardware */
;;;325      htim->Base_MspDeInitCallback(htim);
;;;326    #else
;;;327      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;328      HAL_TIM_Base_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;329    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;330    
;;;331      /* Change TIM state */
;;;332      htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f884003d          STRB     r0,[r4,#0x3d]
;;;333    
;;;334      /* Release Lock */
;;;335      __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;336    
;;;337      return HAL_OK;
;;;338    }
000044  bd10              POP      {r4,pc}
;;;339    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;5462     */
;;;5463   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5464   {
;;;5465     return htim->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;5466   }
000006  4770              BX       lr
;;;5467   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;256      */
;;;257    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;258    {
000002  4604              MOV      r4,r0
;;;259      /* Check the TIM handle allocation */
;;;260      if (htim == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;261      {
;;;262        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;263      }
;;;264    
;;;265      /* Check the parameters */
;;;266      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;267      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;268      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;269      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;270    
;;;271      if (htim->State == HAL_TIM_STATE_RESET)
;;;272      {
;;;273        /* Allocate lock resource and initialize it */
;;;274        htim->Lock = HAL_UNLOCKED;
;;;275    
;;;276    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;277        /* Reset interrupt callbacks to legacy weak callbacks */
;;;278        TIM_ResetCallback(htim);
;;;279    
;;;280        if (htim->Base_MspInitCallback == NULL)
;;;281        {
;;;282          htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
;;;283        }
;;;284        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;285        htim->Base_MspInitCallback(htim);
;;;286    #else
;;;287        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;288        HAL_TIM_Base_MspInit(htim);
;;;289    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;290      }
;;;291    
;;;292      /* Set the TIM state */
;;;293      htim->State = HAL_TIM_STATE_BUSY;
;;;294    
;;;295      /* Set the Time Base configuration */
;;;296      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;297    
;;;298      /* Initialize the TIM state*/
;;;299      htim->State = HAL_TIM_STATE_READY;
;;;300    
;;;301      return HAL_OK;
;;;302    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;271
00000e  b928              CBNZ     r0,|L3.28|
000010  2000              MOVS     r0,#0                 ;274
000012  f884003c          STRB     r0,[r4,#0x3c]         ;274
000016  4620              MOV      r0,r4                 ;288
000018  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.28|
00001c  2002              MOVS     r0,#2                 ;293
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;293
000022  1d21              ADDS     r1,r4,#4              ;296
000024  6820              LDR      r0,[r4,#0]            ;296
000026  f7fffffe          BL       TIM_Base_SetConfig
00002a  2001              MOVS     r0,#1                 ;299
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;299
000030  2000              MOVS     r0,#0                 ;301
000032  e7e9              B        |L3.8|
;;;303    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;359      */
;;;360    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;361    {
;;;362      /* Prevent unused argument(s) compilation warning */
;;;363      UNUSED(htim);
;;;364    
;;;365      /* NOTE : This function should not be modified, when the callback is needed,
;;;366                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;367       */
;;;368    }
;;;369    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;344      */
;;;345    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;346    {
;;;347      /* Prevent unused argument(s) compilation warning */
;;;348      UNUSED(htim);
;;;349    
;;;350      /* NOTE : This function should not be modified, when the callback is needed,
;;;351                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;352       */
;;;353    }
;;;354    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;375      */
;;;376    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;377    {
;;;378      uint32_t tmpsmcr;
;;;379    
;;;380      /* Check the parameters */
;;;381      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;382    
;;;383      /* Set the TIM state */
;;;384      htim->State = HAL_TIM_STATE_BUSY;
000002  2002              MOVS     r0,#2
000004  f881003d          STRB     r0,[r1,#0x3d]
;;;385    
;;;386      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;387      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
000008  6808              LDR      r0,[r1,#0]
00000a  6880              LDR      r0,[r0,#8]
00000c  f0000207          AND      r2,r0,#7
;;;388      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000010  2a06              CMP      r2,#6
000012  d005              BEQ      |L6.32|
;;;389      {
;;;390        __HAL_TIM_ENABLE(htim);
000014  6808              LDR      r0,[r1,#0]
000016  6800              LDR      r0,[r0,#0]
000018  f0400001          ORR      r0,r0,#1
00001c  680b              LDR      r3,[r1,#0]
00001e  6018              STR      r0,[r3,#0]
                  |L6.32|
;;;391      }
;;;392    
;;;393      /* Change the TIM state*/
;;;394      htim->State = HAL_TIM_STATE_READY;
000020  2001              MOVS     r0,#1
000022  f881003d          STRB     r0,[r1,#0x3d]
;;;395    
;;;396      /* Return function status */
;;;397      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;398    }
000028  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;474      */
;;;475    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;476    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;477      uint32_t tmpsmcr;
;;;478    
;;;479      /* Check the parameters */
;;;480      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;481    
;;;482      if ((htim->State == HAL_TIM_STATE_BUSY))
00000a  f894003d          LDRB     r0,[r4,#0x3d]
00000e  2802              CMP      r0,#2
000010  d101              BNE      |L7.22|
                  |L7.18|
;;;483      {
;;;484        return HAL_BUSY;
;;;485      }
;;;486      else if ((htim->State == HAL_TIM_STATE_READY))
;;;487      {
;;;488        if ((pData == NULL) && (Length > 0U))
;;;489        {
;;;490          return HAL_ERROR;
;;;491        }
;;;492        else
;;;493        {
;;;494          htim->State = HAL_TIM_STATE_BUSY;
;;;495        }
;;;496      }
;;;497      else
;;;498      {
;;;499        /* nothing to do */
;;;500      }
;;;501    
;;;502      /* Set the DMA Period elapsed callbacks */
;;;503      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;504      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
;;;505    
;;;506      /* Set the DMA error callback */
;;;507      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;508    
;;;509      /* Enable the DMA stream */
;;;510      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
;;;511      {
;;;512        return HAL_ERROR;
;;;513      }
;;;514    
;;;515      /* Enable the TIM Update DMA request */
;;;516      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;517    
;;;518      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;519      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;520      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;521      {
;;;522        __HAL_TIM_ENABLE(htim);
;;;523      }
;;;524    
;;;525      /* Return function status */
;;;526      return HAL_OK;
;;;527    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L7.22|
000016  f894003d          LDRB     r0,[r4,#0x3d]         ;486
00001a  2801              CMP      r0,#1                 ;486
00001c  d105              BNE      |L7.42|
00001e  b90e              CBNZ     r6,|L7.36|
000020  b105              CBZ      r5,|L7.36|
000022  e7f6              B        |L7.18|
                  |L7.36|
000024  2002              MOVS     r0,#2                 ;494
000026  f884003d          STRB     r0,[r4,#0x3d]         ;494
                  |L7.42|
00002a  4814              LDR      r0,|L7.124|
00002c  6a21              LDR      r1,[r4,#0x20]         ;503
00002e  63c8              STR      r0,[r1,#0x3c]         ;503
000030  4813              LDR      r0,|L7.128|
000032  6a21              LDR      r1,[r4,#0x20]         ;504
000034  6408              STR      r0,[r1,#0x40]         ;504
000036  4813              LDR      r0,|L7.132|
000038  6a21              LDR      r1,[r4,#0x20]         ;507
00003a  64c8              STR      r0,[r1,#0x4c]         ;507
00003c  6821              LDR      r1,[r4,#0]            ;510
00003e  f101022c          ADD      r2,r1,#0x2c           ;510
000042  462b              MOV      r3,r5                 ;510
000044  4631              MOV      r1,r6                 ;510
000046  6a20              LDR      r0,[r4,#0x20]         ;510
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  b108              CBZ      r0,|L7.82|
00004e  2001              MOVS     r0,#1                 ;512
000050  e7df              B        |L7.18|
                  |L7.82|
000052  6820              LDR      r0,[r4,#0]            ;516
000054  68c0              LDR      r0,[r0,#0xc]          ;516
000056  f4407080          ORR      r0,r0,#0x100          ;516
00005a  6821              LDR      r1,[r4,#0]            ;516
00005c  60c8              STR      r0,[r1,#0xc]          ;516
00005e  6820              LDR      r0,[r4,#0]            ;519
000060  6880              LDR      r0,[r0,#8]            ;519
000062  f0000707          AND      r7,r0,#7              ;519
000066  2f06              CMP      r7,#6                 ;520
000068  d005              BEQ      |L7.118|
00006a  6820              LDR      r0,[r4,#0]            ;522
00006c  6800              LDR      r0,[r0,#0]            ;522
00006e  f0400001          ORR      r0,r0,#1              ;522
000072  6821              LDR      r1,[r4,#0]            ;522
000074  6008              STR      r0,[r1,#0]            ;522
                  |L7.118|
000076  2000              MOVS     r0,#0                 ;526
000078  e7cb              B        |L7.18|
;;;528    
                          ENDP

00007a  0000              DCW      0x0000
                  |L7.124|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.128|
                          DCD      TIM_DMAPeriodElapsedHalfCplt
                  |L7.132|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;427      */
;;;428    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;429    {
;;;430      uint32_t tmpsmcr;
;;;431    
;;;432      /* Check the parameters */
;;;433      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;434    
;;;435      /* Enable the TIM Update interrupt */
;;;436      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f0400001          ORR      r0,r0,#1
00000a  680b              LDR      r3,[r1,#0]
00000c  60d8              STR      r0,[r3,#0xc]
;;;437    
;;;438      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;439      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
00000e  6808              LDR      r0,[r1,#0]
000010  6880              LDR      r0,[r0,#8]
000012  f0000207          AND      r2,r0,#7
;;;440      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000016  2a06              CMP      r2,#6
000018  d005              BEQ      |L8.38|
;;;441      {
;;;442        __HAL_TIM_ENABLE(htim);
00001a  6808              LDR      r0,[r1,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400001          ORR      r0,r0,#1
000022  680b              LDR      r3,[r1,#0]
000024  6018              STR      r0,[r3,#0]
                  |L8.38|
;;;443      }
;;;444    
;;;445      /* Return function status */
;;;446      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;447    }
000028  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;404      */
;;;405    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;406    {
;;;407      /* Check the parameters */
;;;408      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;409    
;;;410      /* Set the TIM state */
;;;411      htim->State = HAL_TIM_STATE_BUSY;
000002  2002              MOVS     r0,#2
000004  f881003d          STRB     r0,[r1,#0x3d]
;;;412    
;;;413      /* Disable the Peripheral */
;;;414      __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6808              LDR      r0,[r1,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4010              ANDS     r0,r0,r2
000014  b950              CBNZ     r0,|L9.44|
000016  6808              LDR      r0,[r1,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1092              ASRS     r2,r2,#2
00001c  4010              ANDS     r0,r0,r2
00001e  b928              CBNZ     r0,|L9.44|
000020  6808              LDR      r0,[r1,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  680a              LDR      r2,[r1,#0]
00002a  6010              STR      r0,[r2,#0]
                  |L9.44|
00002c  bf00              NOP      
;;;415    
;;;416      /* Change the TIM state*/
;;;417      htim->State = HAL_TIM_STATE_READY;
00002e  2001              MOVS     r0,#1
000030  f881003d          STRB     r0,[r1,#0x3d]
;;;418    
;;;419      /* Return function status */
;;;420      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;421    }
000036  4770              BX       lr
;;;422    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;533      */
;;;534    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;535    {
000002  4604              MOV      r4,r0
;;;536      /* Check the parameters */
;;;537      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;538    
;;;539      /* Disable the TIM Update DMA request */
;;;540      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f4207080          BIC      r0,r0,#0x100
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;541    
;;;542      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
000010  6a20              LDR      r0,[r4,#0x20]
000012  f7fffffe          BL       HAL_DMA_Abort_IT
;;;543    
;;;544      /* Disable the Peripheral */
;;;545      __HAL_TIM_DISABLE(htim);
000016  bf00              NOP      
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  f2411111          MOV      r1,#0x1111
000020  4008              ANDS     r0,r0,r1
000022  b950              CBNZ     r0,|L10.58|
000024  6820              LDR      r0,[r4,#0]
000026  6a00              LDR      r0,[r0,#0x20]
000028  1089              ASRS     r1,r1,#2
00002a  4008              ANDS     r0,r0,r1
00002c  b928              CBNZ     r0,|L10.58|
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0200001          BIC      r0,r0,#1
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
                  |L10.58|
00003a  bf00              NOP      
;;;546    
;;;547      /* Change the htim state */
;;;548      htim->State = HAL_TIM_STATE_READY;
00003c  2001              MOVS     r0,#1
00003e  f884003d          STRB     r0,[r4,#0x3d]
;;;549    
;;;550      /* Return function status */
;;;551      return HAL_OK;
000042  2000              MOVS     r0,#0
;;;552    }
000044  bd10              POP      {r4,pc}
;;;553    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;453      */
;;;454    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;455    {
;;;456      /* Check the parameters */
;;;457      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;458      /* Disable the TIM Update interrupt */
;;;459      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f0200001          BIC      r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;460    
;;;461      /* Disable the Peripheral */
;;;462      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6808              LDR      r0,[r1,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  f2411211          MOV      r2,#0x1111
000018  4010              ANDS     r0,r0,r2
00001a  b950              CBNZ     r0,|L11.50|
00001c  6808              LDR      r0,[r1,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1092              ASRS     r2,r2,#2
000022  4010              ANDS     r0,r0,r2
000024  b928              CBNZ     r0,|L11.50|
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0200001          BIC      r0,r0,#1
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
                  |L11.50|
000032  bf00              NOP      
;;;463    
;;;464      /* Return function status */
;;;465      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;466    }
000036  4770              BX       lr
;;;467    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;4460     */
;;;4461   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4462   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;4463     uint32_t tmpsmcr;
;;;4464   
;;;4465     /* Process Locked */
;;;4466     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  f894003c          LDRB     r0,[r4,#0x3c]
00000e  2801              CMP      r0,#1
000010  d102              BNE      |L12.24|
000012  2002              MOVS     r0,#2
                  |L12.20|
;;;4467   
;;;4468     htim->State = HAL_TIM_STATE_BUSY;
;;;4469   
;;;4470     /* Check the parameters */
;;;4471     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;4472   
;;;4473     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;4474     tmpsmcr = htim->Instance->SMCR;
;;;4475     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4476     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;4477     htim->Instance->SMCR = tmpsmcr;
;;;4478   
;;;4479     switch (sClockSourceConfig->ClockSource)
;;;4480     {
;;;4481       case TIM_CLOCKSOURCE_INTERNAL:
;;;4482       {
;;;4483         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;4484         break;
;;;4485       }
;;;4486   
;;;4487       case TIM_CLOCKSOURCE_ETRMODE1:
;;;4488       {
;;;4489         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;4490         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;4491   
;;;4492         /* Check ETR input conditioning related parameters */
;;;4493         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4494         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4495         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4496   
;;;4497         /* Configure the ETR Clock source */
;;;4498         TIM_ETR_SetConfig(htim->Instance,
;;;4499                           sClockSourceConfig->ClockPrescaler,
;;;4500                           sClockSourceConfig->ClockPolarity,
;;;4501                           sClockSourceConfig->ClockFilter);
;;;4502   
;;;4503         /* Select the External clock mode1 and the ETRF trigger */
;;;4504         tmpsmcr = htim->Instance->SMCR;
;;;4505         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;4506         /* Write to TIMx SMCR */
;;;4507         htim->Instance->SMCR = tmpsmcr;
;;;4508         break;
;;;4509       }
;;;4510   
;;;4511       case TIM_CLOCKSOURCE_ETRMODE2:
;;;4512       {
;;;4513         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;4514         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;4515   
;;;4516         /* Check ETR input conditioning related parameters */
;;;4517         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4518         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4519         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4520   
;;;4521         /* Configure the ETR Clock source */
;;;4522         TIM_ETR_SetConfig(htim->Instance,
;;;4523                           sClockSourceConfig->ClockPrescaler,
;;;4524                           sClockSourceConfig->ClockPolarity,
;;;4525                           sClockSourceConfig->ClockFilter);
;;;4526         /* Enable the External clock mode2 */
;;;4527         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4528         break;
;;;4529       }
;;;4530   
;;;4531       case TIM_CLOCKSOURCE_TI1:
;;;4532       {
;;;4533         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4534         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4535   
;;;4536         /* Check TI1 input conditioning related parameters */
;;;4537         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4538         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4539   
;;;4540         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4541                                  sClockSourceConfig->ClockPolarity,
;;;4542                                  sClockSourceConfig->ClockFilter);
;;;4543         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4544         break;
;;;4545       }
;;;4546   
;;;4547       case TIM_CLOCKSOURCE_TI2:
;;;4548       {
;;;4549         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;4550         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4551   
;;;4552         /* Check TI2 input conditioning related parameters */
;;;4553         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4554         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4555   
;;;4556         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4557                                  sClockSourceConfig->ClockPolarity,
;;;4558                                  sClockSourceConfig->ClockFilter);
;;;4559         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4560         break;
;;;4561       }
;;;4562   
;;;4563       case TIM_CLOCKSOURCE_TI1ED:
;;;4564       {
;;;4565         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4566         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4567   
;;;4568         /* Check TI1 input conditioning related parameters */
;;;4569         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4570         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4571   
;;;4572         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4573                                  sClockSourceConfig->ClockPolarity,
;;;4574                                  sClockSourceConfig->ClockFilter);
;;;4575         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4576         break;
;;;4577       }
;;;4578   
;;;4579       case TIM_CLOCKSOURCE_ITR0:
;;;4580       case TIM_CLOCKSOURCE_ITR1:
;;;4581       case TIM_CLOCKSOURCE_ITR2:
;;;4582       case TIM_CLOCKSOURCE_ITR3:
;;;4583       {
;;;4584         /* Check whether or not the timer instance supports internal trigger input */
;;;4585         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4586   
;;;4587         TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
;;;4588         break;
;;;4589       }
;;;4590   
;;;4591       default:
;;;4592         break;
;;;4593     }
;;;4594     htim->State = HAL_TIM_STATE_READY;
;;;4595   
;;;4596     __HAL_UNLOCK(htim);
;;;4597   
;;;4598     return HAL_OK;
;;;4599   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L12.24|
000018  2001              MOVS     r0,#1                 ;4466
00001a  f884003c          STRB     r0,[r4,#0x3c]         ;4466
00001e  bf00              NOP                            ;4466
000020  2002              MOVS     r0,#2                 ;4468
000022  f884003d          STRB     r0,[r4,#0x3d]         ;4468
000026  6820              LDR      r0,[r4,#0]            ;4474
000028  6886              LDR      r6,[r0,#8]            ;4474
00002a  f0260677          BIC      r6,r6,#0x77           ;4475
00002e  f426467f          BIC      r6,r6,#0xff00         ;4476
000032  6820              LDR      r0,[r4,#0]            ;4477
000034  6086              STR      r6,[r0,#8]            ;4477
000036  6828              LDR      r0,[r5,#0]            ;4479
000038  2850              CMP      r0,#0x50              ;4479
00003a  d033              BEQ      |L12.164|
00003c  dc0c              BGT      |L12.88|
00003e  2820              CMP      r0,#0x20              ;4479
000040  d050              BEQ      |L12.228|
000042  dc04              BGT      |L12.78|
000044  2800              CMP      r0,#0                 ;4479
000046  d04b              BEQ      |L12.224|
000048  2810              CMP      r0,#0x10              ;4479
00004a  d151              BNE      |L12.240|
00004c  e049              B        |L12.226|
                  |L12.78|
00004e  2830              CMP      r0,#0x30              ;4479
000050  d049              BEQ      |L12.230|
000052  2840              CMP      r0,#0x40              ;4479
000054  d14c              BNE      |L12.240|
000056  e039              B        |L12.204|
                  |L12.88|
000058  2860              CMP      r0,#0x60              ;4479
00005a  d02d              BEQ      |L12.184|
00005c  2870              CMP      r0,#0x70              ;4479
00005e  d007              BEQ      |L12.112|
000060  f5b05f80          CMP      r0,#0x1000            ;4479
000064  d003              BEQ      |L12.110|
000066  f5b05f00          CMP      r0,#0x2000            ;4479
00006a  d141              BNE      |L12.240|
00006c  e00d              B        |L12.138|
                  |L12.110|
00006e  e040              B        |L12.242|
                  |L12.112|
000070  e9d51302          LDRD     r1,r3,[r5,#8]         ;4498
000074  686a              LDR      r2,[r5,#4]            ;4498
000076  6820              LDR      r0,[r4,#0]            ;4498
000078  f7fffffe          BL       TIM_ETR_SetConfig
00007c  6820              LDR      r0,[r4,#0]            ;4504
00007e  6886              LDR      r6,[r0,#8]            ;4504
000080  f0460677          ORR      r6,r6,#0x77           ;4505
000084  6820              LDR      r0,[r4,#0]            ;4507
000086  6086              STR      r6,[r0,#8]            ;4507
000088  e033              B        |L12.242|
                  |L12.138|
00008a  e9d51302          LDRD     r1,r3,[r5,#8]         ;4522
00008e  686a              LDR      r2,[r5,#4]            ;4522
000090  6820              LDR      r0,[r4,#0]            ;4522
000092  f7fffffe          BL       TIM_ETR_SetConfig
000096  6820              LDR      r0,[r4,#0]            ;4527
000098  6880              LDR      r0,[r0,#8]            ;4527
00009a  f4404080          ORR      r0,r0,#0x4000         ;4527
00009e  6821              LDR      r1,[r4,#0]            ;4527
0000a0  6088              STR      r0,[r1,#8]            ;4527
0000a2  e026              B        |L12.242|
                  |L12.164|
0000a4  68ea              LDR      r2,[r5,#0xc]          ;4540
0000a6  6869              LDR      r1,[r5,#4]            ;4540
0000a8  6820              LDR      r0,[r4,#0]            ;4540
0000aa  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000ae  2150              MOVS     r1,#0x50              ;4543
0000b0  6820              LDR      r0,[r4,#0]            ;4543
0000b2  f7fffffe          BL       TIM_ITRx_SetConfig
0000b6  e01c              B        |L12.242|
                  |L12.184|
0000b8  68ea              LDR      r2,[r5,#0xc]          ;4556
0000ba  6869              LDR      r1,[r5,#4]            ;4556
0000bc  6820              LDR      r0,[r4,#0]            ;4556
0000be  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000c2  2160              MOVS     r1,#0x60              ;4559
0000c4  6820              LDR      r0,[r4,#0]            ;4559
0000c6  f7fffffe          BL       TIM_ITRx_SetConfig
0000ca  e012              B        |L12.242|
                  |L12.204|
0000cc  68ea              LDR      r2,[r5,#0xc]          ;4572
0000ce  6869              LDR      r1,[r5,#4]            ;4572
0000d0  6820              LDR      r0,[r4,#0]            ;4572
0000d2  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000d6  2140              MOVS     r1,#0x40              ;4575
0000d8  6820              LDR      r0,[r4,#0]            ;4575
0000da  f7fffffe          BL       TIM_ITRx_SetConfig
0000de  e008              B        |L12.242|
                  |L12.224|
0000e0  bf00              NOP                            ;4580
                  |L12.226|
0000e2  bf00              NOP                            ;4581
                  |L12.228|
0000e4  bf00              NOP                            ;4582
                  |L12.230|
0000e6  6829              LDR      r1,[r5,#0]            ;4587
0000e8  6820              LDR      r0,[r4,#0]            ;4587
0000ea  f7fffffe          BL       TIM_ITRx_SetConfig
0000ee  e000              B        |L12.242|
                  |L12.240|
0000f0  bf00              NOP                            ;4592
                  |L12.242|
0000f2  bf00              NOP                            ;4484
0000f4  2001              MOVS     r0,#1                 ;4594
0000f6  f884003d          STRB     r0,[r4,#0x3d]         ;4594
0000fa  bf00              NOP                            ;4596
0000fc  2000              MOVS     r0,#0                 ;4596
0000fe  f884003c          STRB     r0,[r4,#0x3c]         ;4596
000102  bf00              NOP                            ;4596
000104  bf00              NOP                            ;4598
000106  e785              B        |L12.20|
;;;4600   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;4336     */
;;;4337   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
000000  b5f0              PUSH     {r4-r7,lr}
;;;4338                                              TIM_ClearInputConfigTypeDef *sClearInputConfig,
;;;4339                                              uint32_t Channel)
;;;4340   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;4341     /* Check the parameters */
;;;4342     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;4343     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;4344   
;;;4345     /* Process Locked */
;;;4346     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  f894003c          LDRB     r0,[r4,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L13.22|
000012  2002              MOVS     r0,#2
                  |L13.20|
;;;4347   
;;;4348     htim->State = HAL_TIM_STATE_BUSY;
;;;4349   
;;;4350     switch (sClearInputConfig->ClearInputSource)
;;;4351     {
;;;4352       case TIM_CLEARINPUTSOURCE_NONE:
;;;4353       {
;;;4354         /* Clear the OCREF clear selection bit and the the ETR Bits */
;;;4355         CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
;;;4356         break;
;;;4357       }
;;;4358   
;;;4359       case TIM_CLEARINPUTSOURCE_ETR:
;;;4360       {
;;;4361         /* Check the parameters */
;;;4362         assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;4363         assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;4364         assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;4365   
;;;4366         /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
;;;4367         if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
;;;4368         {
;;;4369             htim->State = HAL_TIM_STATE_READY;
;;;4370           __HAL_UNLOCK(htim);
;;;4371           return HAL_ERROR;
;;;4372         }
;;;4373   
;;;4374         TIM_ETR_SetConfig(htim->Instance,
;;;4375                           sClearInputConfig->ClearInputPrescaler,
;;;4376                           sClearInputConfig->ClearInputPolarity,
;;;4377                           sClearInputConfig->ClearInputFilter);
;;;4378         break;
;;;4379       }
;;;4380   
;;;4381       default:
;;;4382         break;
;;;4383     }
;;;4384   
;;;4385     switch (Channel)
;;;4386     {
;;;4387       case TIM_CHANNEL_1:
;;;4388       {
;;;4389         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;4390         {
;;;4391           /* Enable the OCREF clear feature for Channel 1 */
;;;4392           SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
;;;4393         }
;;;4394         else
;;;4395         {
;;;4396           /* Disable the OCREF clear feature for Channel 1 */
;;;4397           CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
;;;4398         }
;;;4399         break;
;;;4400       }
;;;4401       case TIM_CHANNEL_2:
;;;4402       {
;;;4403         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;4404         {
;;;4405           /* Enable the OCREF clear feature for Channel 2 */
;;;4406           SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
;;;4407         }
;;;4408         else
;;;4409         {
;;;4410           /* Disable the OCREF clear feature for Channel 2 */
;;;4411           CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
;;;4412         }
;;;4413         break;
;;;4414       }
;;;4415       case TIM_CHANNEL_3:
;;;4416       {
;;;4417         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;4418         {
;;;4419           /* Enable the OCREF clear feature for Channel 3 */
;;;4420           SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
;;;4421         }
;;;4422         else
;;;4423         {
;;;4424           /* Disable the OCREF clear feature for Channel 3 */
;;;4425           CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
;;;4426         }
;;;4427         break;
;;;4428       }
;;;4429       case TIM_CHANNEL_4:
;;;4430       {
;;;4431         if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
;;;4432         {
;;;4433           /* Enable the OCREF clear feature for Channel 4 */
;;;4434           SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
;;;4435         }
;;;4436         else
;;;4437         {
;;;4438           /* Disable the OCREF clear feature for Channel 4 */
;;;4439           CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
;;;4440         }
;;;4441         break;
;;;4442       }
;;;4443       default:
;;;4444         break;
;;;4445     }
;;;4446   
;;;4447     htim->State = HAL_TIM_STATE_READY;
;;;4448   
;;;4449     __HAL_UNLOCK(htim);
;;;4450   
;;;4451     return HAL_OK;
;;;4452   }
000014  bdf0              POP      {r4-r7,pc}
                  |L13.22|
000016  2001              MOVS     r0,#1                 ;4346
000018  f884003c          STRB     r0,[r4,#0x3c]         ;4346
00001c  bf00              NOP                            ;4346
00001e  2002              MOVS     r0,#2                 ;4348
000020  f884003d          STRB     r0,[r4,#0x3d]         ;4348
000024  6868              LDR      r0,[r5,#4]            ;4350
000026  b110              CBZ      r0,|L13.46|
000028  2801              CMP      r0,#1                 ;4350
00002a  d11a              BNE      |L13.98|
00002c  e006              B        |L13.60|
                  |L13.46|
00002e  6820              LDR      r0,[r4,#0]            ;4355
000030  6880              LDR      r0,[r0,#8]            ;4355
000032  f420407f          BIC      r0,r0,#0xff00         ;4355
000036  6821              LDR      r1,[r4,#0]            ;4355
000038  6088              STR      r0,[r1,#8]            ;4355
00003a  e013              B        |L13.100|
                  |L13.60|
00003c  68e8              LDR      r0,[r5,#0xc]          ;4367
00003e  b148              CBZ      r0,|L13.84|
000040  2001              MOVS     r0,#1                 ;4369
000042  f884003d          STRB     r0,[r4,#0x3d]         ;4369
000046  bf00              NOP                            ;4370
000048  2000              MOVS     r0,#0                 ;4370
00004a  f884003c          STRB     r0,[r4,#0x3c]         ;4370
00004e  bf00              NOP                            ;4370
000050  2001              MOVS     r0,#1                 ;4371
000052  e7df              B        |L13.20|
                  |L13.84|
000054  e9d51303          LDRD     r1,r3,[r5,#0xc]       ;4374
000058  68aa              LDR      r2,[r5,#8]            ;4374
00005a  6820              LDR      r0,[r4,#0]            ;4374
00005c  f7fffffe          BL       TIM_ETR_SetConfig
000060  e000              B        |L13.100|
                  |L13.98|
000062  bf00              NOP                            ;4382
                  |L13.100|
000064  bf00              NOP                            ;4356
000066  b136              CBZ      r6,|L13.118|
000068  2e04              CMP      r6,#4                 ;4385
00006a  d014              BEQ      |L13.150|
00006c  2e08              CMP      r6,#8                 ;4385
00006e  d022              BEQ      |L13.182|
000070  2e0c              CMP      r6,#0xc               ;4385
000072  d140              BNE      |L13.246|
000074  e02f              B        |L13.214|
                  |L13.118|
000076  6828              LDR      r0,[r5,#0]            ;4389
000078  b130              CBZ      r0,|L13.136|
00007a  6820              LDR      r0,[r4,#0]            ;4392
00007c  6980              LDR      r0,[r0,#0x18]         ;4392
00007e  f0400080          ORR      r0,r0,#0x80           ;4392
000082  6821              LDR      r1,[r4,#0]            ;4392
000084  6188              STR      r0,[r1,#0x18]         ;4392
000086  e005              B        |L13.148|
                  |L13.136|
000088  6820              LDR      r0,[r4,#0]            ;4397
00008a  6980              LDR      r0,[r0,#0x18]         ;4397
00008c  f0200080          BIC      r0,r0,#0x80           ;4397
000090  6821              LDR      r1,[r4,#0]            ;4397
000092  6188              STR      r0,[r1,#0x18]         ;4397
                  |L13.148|
000094  e030              B        |L13.248|
                  |L13.150|
000096  6828              LDR      r0,[r5,#0]            ;4403
000098  b130              CBZ      r0,|L13.168|
00009a  6820              LDR      r0,[r4,#0]            ;4406
00009c  6980              LDR      r0,[r0,#0x18]         ;4406
00009e  f4404000          ORR      r0,r0,#0x8000         ;4406
0000a2  6821              LDR      r1,[r4,#0]            ;4406
0000a4  6188              STR      r0,[r1,#0x18]         ;4406
0000a6  e005              B        |L13.180|
                  |L13.168|
0000a8  6820              LDR      r0,[r4,#0]            ;4411
0000aa  6980              LDR      r0,[r0,#0x18]         ;4411
0000ac  f4204000          BIC      r0,r0,#0x8000         ;4411
0000b0  6821              LDR      r1,[r4,#0]            ;4411
0000b2  6188              STR      r0,[r1,#0x18]         ;4411
                  |L13.180|
0000b4  e020              B        |L13.248|
                  |L13.182|
0000b6  6828              LDR      r0,[r5,#0]            ;4417
0000b8  b130              CBZ      r0,|L13.200|
0000ba  6820              LDR      r0,[r4,#0]            ;4420
0000bc  69c0              LDR      r0,[r0,#0x1c]         ;4420
0000be  f0400080          ORR      r0,r0,#0x80           ;4420
0000c2  6821              LDR      r1,[r4,#0]            ;4420
0000c4  61c8              STR      r0,[r1,#0x1c]         ;4420
0000c6  e005              B        |L13.212|
                  |L13.200|
0000c8  6820              LDR      r0,[r4,#0]            ;4425
0000ca  69c0              LDR      r0,[r0,#0x1c]         ;4425
0000cc  f0200080          BIC      r0,r0,#0x80           ;4425
0000d0  6821              LDR      r1,[r4,#0]            ;4425
0000d2  61c8              STR      r0,[r1,#0x1c]         ;4425
                  |L13.212|
0000d4  e010              B        |L13.248|
                  |L13.214|
0000d6  6828              LDR      r0,[r5,#0]            ;4431
0000d8  b130              CBZ      r0,|L13.232|
0000da  6820              LDR      r0,[r4,#0]            ;4434
0000dc  69c0              LDR      r0,[r0,#0x1c]         ;4434
0000de  f4404000          ORR      r0,r0,#0x8000         ;4434
0000e2  6821              LDR      r1,[r4,#0]            ;4434
0000e4  61c8              STR      r0,[r1,#0x1c]         ;4434
0000e6  e005              B        |L13.244|
                  |L13.232|
0000e8  6820              LDR      r0,[r4,#0]            ;4439
0000ea  69c0              LDR      r0,[r0,#0x1c]         ;4439
0000ec  f4204000          BIC      r0,r0,#0x8000         ;4439
0000f0  6821              LDR      r1,[r4,#0]            ;4439
0000f2  61c8              STR      r0,[r1,#0x1c]         ;4439
                  |L13.244|
0000f4  e000              B        |L13.248|
                  |L13.246|
0000f6  bf00              NOP                            ;4444
                  |L13.248|
0000f8  bf00              NOP                            ;4399
0000fa  2001              MOVS     r0,#1                 ;4447
0000fc  f884003d          STRB     r0,[r4,#0x3d]         ;4447
000100  bf00              NOP                            ;4449
000102  2000              MOVS     r0,#0                 ;4449
000104  f884003c          STRB     r0,[r4,#0x3c]         ;4449
000108  bf00              NOP                            ;4449
00010a  bf00              NOP                            ;4451
00010c  e782              B        |L13.20|
;;;4453   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4612     */
;;;4613   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  4602              MOV      r2,r0
;;;4614   {
000002  460b              MOV      r3,r1
;;;4615     uint32_t tmpcr2;
;;;4616   
;;;4617     /* Check the parameters */
;;;4618     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;4619     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4620   
;;;4621     /* Get the TIMx CR2 register value */
;;;4622     tmpcr2 = htim->Instance->CR2;
000004  6810              LDR      r0,[r2,#0]
000006  6841              LDR      r1,[r0,#4]
;;;4623   
;;;4624     /* Reset the TI1 selection */
;;;4625     tmpcr2 &= ~TIM_CR2_TI1S;
000008  f0210180          BIC      r1,r1,#0x80
;;;4626   
;;;4627     /* Set the TI1 selection */
;;;4628     tmpcr2 |= TI1_Selection;
00000c  4319              ORRS     r1,r1,r3
;;;4629   
;;;4630     /* Write to TIMxCR2 */
;;;4631     htim->Instance->CR2 = tmpcr2;
00000e  6810              LDR      r0,[r2,#0]
000010  6041              STR      r1,[r0,#4]
;;;4632   
;;;4633     return HAL_OK;
000012  2000              MOVS     r0,#0
;;;4634   }
000014  4770              BX       lr
;;;4635   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;4057     */
;;;4058   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4059                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;4060   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;4061     /* Check the parameters */
;;;4062     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;4063     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;4064     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;4065     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;4066   
;;;4067     if ((htim->State == HAL_TIM_STATE_BUSY))
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2802              CMP      r0,#2
000014  d101              BNE      |L15.26|
                  |L15.22|
;;;4068     {
;;;4069       return HAL_BUSY;
;;;4070     }
;;;4071     else if ((htim->State == HAL_TIM_STATE_READY))
;;;4072     {
;;;4073       if ((BurstBuffer == NULL) && (BurstLength > 0U))
;;;4074       {
;;;4075         return HAL_ERROR;
;;;4076       }
;;;4077       else
;;;4078       {
;;;4079         htim->State = HAL_TIM_STATE_BUSY;
;;;4080       }
;;;4081     }
;;;4082     else
;;;4083     {
;;;4084       /* nothing to do */
;;;4085     }
;;;4086     switch (BurstRequestSrc)
;;;4087     {
;;;4088       case TIM_DMA_UPDATE:
;;;4089       {
;;;4090         /* Set the DMA Period elapsed callbacks */
;;;4091         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;4092         htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
;;;4093   
;;;4094         /* Set the DMA error callback */
;;;4095         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;4096   
;;;4097         /* Enable the DMA stream */
;;;4098         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;4099         {
;;;4100           return HAL_ERROR;
;;;4101         }
;;;4102         break;
;;;4103       }
;;;4104       case TIM_DMA_CC1:
;;;4105       {
;;;4106         /* Set the DMA capture callbacks */
;;;4107         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;4108         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;4109   
;;;4110         /* Set the DMA error callback */
;;;4111         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;4112   
;;;4113         /* Enable the DMA stream */
;;;4114         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;4115         {
;;;4116           return HAL_ERROR;
;;;4117         }
;;;4118         break;
;;;4119       }
;;;4120       case TIM_DMA_CC2:
;;;4121       {
;;;4122         /* Set the DMA capture/compare callbacks */
;;;4123         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;4124         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;4125   
;;;4126         /* Set the DMA error callback */
;;;4127         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;4128   
;;;4129         /* Enable the DMA stream */
;;;4130         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;4131         {
;;;4132           return HAL_ERROR;
;;;4133         }
;;;4134         break;
;;;4135       }
;;;4136       case TIM_DMA_CC3:
;;;4137       {
;;;4138         /* Set the DMA capture callbacks */
;;;4139         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;4140         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;4141   
;;;4142         /* Set the DMA error callback */
;;;4143         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;4144   
;;;4145         /* Enable the DMA stream */
;;;4146         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;4147         {
;;;4148           return HAL_ERROR;
;;;4149         }
;;;4150         break;
;;;4151       }
;;;4152       case TIM_DMA_CC4:
;;;4153       {
;;;4154         /* Set the DMA capture callbacks */
;;;4155         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;4156         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;4157   
;;;4158         /* Set the DMA error callback */
;;;4159         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;4160   
;;;4161         /* Enable the DMA stream */
;;;4162         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;4163         {
;;;4164           return HAL_ERROR;
;;;4165         }
;;;4166         break;
;;;4167       }
;;;4168       case TIM_DMA_COM:
;;;4169       {
;;;4170         /* Set the DMA commutation callbacks */
;;;4171         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;4172         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
;;;4173   
;;;4174         /* Set the DMA error callback */
;;;4175         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;4176   
;;;4177         /* Enable the DMA stream */
;;;4178         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;4179         {
;;;4180           return HAL_ERROR;
;;;4181         }
;;;4182         break;
;;;4183       }
;;;4184       case TIM_DMA_TRIGGER:
;;;4185       {
;;;4186         /* Set the DMA trigger callbacks */
;;;4187         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;4188         htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
;;;4189   
;;;4190         /* Set the DMA error callback */
;;;4191         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;4192   
;;;4193         /* Enable the DMA stream */
;;;4194         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;4195         {
;;;4196           return HAL_ERROR;
;;;4197         }
;;;4198         break;
;;;4199       }
;;;4200       default:
;;;4201         break;
;;;4202     }
;;;4203   
;;;4204     /* configure the DMA Burst Mode */
;;;4205     htim->Instance->DCR = (BurstBaseAddress | BurstLength);
;;;4206   
;;;4207     /* Enable the TIM DMA Request */
;;;4208     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;4209   
;;;4210     htim->State = HAL_TIM_STATE_READY;
;;;4211   
;;;4212     /* Return function status */
;;;4213     return HAL_OK;
;;;4214   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L15.26|
00001a  f894003d          LDRB     r0,[r4,#0x3d]         ;4071
00001e  2801              CMP      r0,#1                 ;4071
000020  d105              BNE      |L15.46|
000022  b90f              CBNZ     r7,|L15.40|
000024  b105              CBZ      r5,|L15.40|
000026  e7f6              B        |L15.22|
                  |L15.40|
000028  2002              MOVS     r0,#2                 ;4079
00002a  f884003d          STRB     r0,[r4,#0x3d]         ;4079
                  |L15.46|
00002e  f5b66f00          CMP      r6,#0x800             ;4086
000032  d059              BEQ      |L15.232|
000034  dc09              BGT      |L15.74|
000036  f5b67f80          CMP      r6,#0x100             ;4086
00003a  d010              BEQ      |L15.94|
00003c  f5b67f00          CMP      r6,#0x200             ;4086
000040  d024              BEQ      |L15.140|
000042  f5b66f80          CMP      r6,#0x400             ;4086
                  |L15.70|
000046  d17c              BNE      |L15.322|
000048  e037              B        |L15.186|
                  |L15.74|
00004a  f5b65f80          CMP      r6,#0x1000            ;4086
00004e  d062              BEQ      |L15.278|
000050  f5b65f00          CMP      r6,#0x2000            ;4086
000054  d078              BEQ      |L15.328|
000056  f5b64f80          CMP      r6,#0x4000            ;4086
00005a  d1f4              BNE      |L15.70|
00005c  e08b              B        |L15.374|
                  |L15.94|
00005e  4859              LDR      r0,|L15.452|
000060  6a21              LDR      r1,[r4,#0x20]         ;4091
000062  63c8              STR      r0,[r1,#0x3c]         ;4091
000064  4858              LDR      r0,|L15.456|
000066  6a21              LDR      r1,[r4,#0x20]         ;4092
000068  6408              STR      r0,[r1,#0x40]         ;4092
00006a  4858              LDR      r0,|L15.460|
00006c  6a21              LDR      r1,[r4,#0x20]         ;4095
00006e  64c8              STR      r0,[r1,#0x4c]         ;4095
000070  2201              MOVS     r2,#1                 ;4098
000072  eb022315          ADD      r3,r2,r5,LSR #8       ;4098
000076  6822              LDR      r2,[r4,#0]            ;4098
000078  f102014c          ADD      r1,r2,#0x4c           ;4098
00007c  463a              MOV      r2,r7                 ;4098
00007e  6a20              LDR      r0,[r4,#0x20]         ;4098
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  b108              CBZ      r0,|L15.138|
000086  2001              MOVS     r0,#1                 ;4100
000088  e7c5              B        |L15.22|
                  |L15.138|
00008a  e08c              B        |L15.422|
                  |L15.140|
00008c  4950              LDR      r1,|L15.464|
00008e  6a60              LDR      r0,[r4,#0x24]         ;4107
000090  63c1              STR      r1,[r0,#0x3c]         ;4107
000092  4950              LDR      r1,|L15.468|
000094  6a60              LDR      r0,[r4,#0x24]         ;4108
000096  6401              STR      r1,[r0,#0x40]         ;4108
000098  494c              LDR      r1,|L15.460|
00009a  6a60              LDR      r0,[r4,#0x24]         ;4111
00009c  64c1              STR      r1,[r0,#0x4c]         ;4111
00009e  2201              MOVS     r2,#1                 ;4114
0000a0  eb022315          ADD      r3,r2,r5,LSR #8       ;4114
0000a4  6822              LDR      r2,[r4,#0]            ;4114
0000a6  f102014c          ADD      r1,r2,#0x4c           ;4114
0000aa  463a              MOV      r2,r7                 ;4114
0000ac  6a60              LDR      r0,[r4,#0x24]         ;4114
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  b108              CBZ      r0,|L15.184|
0000b4  2001              MOVS     r0,#1                 ;4116
0000b6  e7ae              B        |L15.22|
                  |L15.184|
0000b8  e075              B        |L15.422|
                  |L15.186|
0000ba  4945              LDR      r1,|L15.464|
0000bc  6aa0              LDR      r0,[r4,#0x28]         ;4123
0000be  63c1              STR      r1,[r0,#0x3c]         ;4123
0000c0  4944              LDR      r1,|L15.468|
0000c2  6aa0              LDR      r0,[r4,#0x28]         ;4124
0000c4  6401              STR      r1,[r0,#0x40]         ;4124
0000c6  4941              LDR      r1,|L15.460|
0000c8  6aa0              LDR      r0,[r4,#0x28]         ;4127
0000ca  64c1              STR      r1,[r0,#0x4c]         ;4127
0000cc  2201              MOVS     r2,#1                 ;4130
0000ce  eb022315          ADD      r3,r2,r5,LSR #8       ;4130
0000d2  6822              LDR      r2,[r4,#0]            ;4130
0000d4  f102014c          ADD      r1,r2,#0x4c           ;4130
0000d8  463a              MOV      r2,r7                 ;4130
0000da  6aa0              LDR      r0,[r4,#0x28]         ;4130
0000dc  f7fffffe          BL       HAL_DMA_Start_IT
0000e0  b108              CBZ      r0,|L15.230|
0000e2  2001              MOVS     r0,#1                 ;4132
0000e4  e797              B        |L15.22|
                  |L15.230|
0000e6  e05e              B        |L15.422|
                  |L15.232|
0000e8  4939              LDR      r1,|L15.464|
0000ea  6ae0              LDR      r0,[r4,#0x2c]         ;4139
0000ec  63c1              STR      r1,[r0,#0x3c]         ;4139
0000ee  4939              LDR      r1,|L15.468|
0000f0  6ae0              LDR      r0,[r4,#0x2c]         ;4140
0000f2  6401              STR      r1,[r0,#0x40]         ;4140
0000f4  4935              LDR      r1,|L15.460|
0000f6  6ae0              LDR      r0,[r4,#0x2c]         ;4143
0000f8  64c1              STR      r1,[r0,#0x4c]         ;4143
0000fa  2201              MOVS     r2,#1                 ;4146
0000fc  eb022315          ADD      r3,r2,r5,LSR #8       ;4146
000100  6822              LDR      r2,[r4,#0]            ;4146
000102  f102014c          ADD      r1,r2,#0x4c           ;4146
000106  463a              MOV      r2,r7                 ;4146
000108  6ae0              LDR      r0,[r4,#0x2c]         ;4146
00010a  f7fffffe          BL       HAL_DMA_Start_IT
00010e  b108              CBZ      r0,|L15.276|
000110  2001              MOVS     r0,#1                 ;4148
000112  e780              B        |L15.22|
                  |L15.276|
000114  e047              B        |L15.422|
                  |L15.278|
000116  492e              LDR      r1,|L15.464|
000118  6b20              LDR      r0,[r4,#0x30]         ;4155
00011a  63c1              STR      r1,[r0,#0x3c]         ;4155
00011c  492d              LDR      r1,|L15.468|
00011e  6b20              LDR      r0,[r4,#0x30]         ;4156
000120  6401              STR      r1,[r0,#0x40]         ;4156
000122  492a              LDR      r1,|L15.460|
000124  6b20              LDR      r0,[r4,#0x30]         ;4159
000126  64c1              STR      r1,[r0,#0x4c]         ;4159
000128  2201              MOVS     r2,#1                 ;4162
00012a  eb022315          ADD      r3,r2,r5,LSR #8       ;4162
00012e  6822              LDR      r2,[r4,#0]            ;4162
000130  f102014c          ADD      r1,r2,#0x4c           ;4162
000134  463a              MOV      r2,r7                 ;4162
000136  6b20              LDR      r0,[r4,#0x30]         ;4162
000138  f7fffffe          BL       HAL_DMA_Start_IT
00013c  b118              CBZ      r0,|L15.326|
00013e  2001              MOVS     r0,#1                 ;4164
000140  e769              B        |L15.22|
                  |L15.322|
000142  e02f              B        |L15.420|
000144  e000              B        |L15.328|
                  |L15.326|
000146  e02e              B        |L15.422|
                  |L15.328|
000148  4923              LDR      r1,|L15.472|
00014a  6b60              LDR      r0,[r4,#0x34]         ;4171
00014c  63c1              STR      r1,[r0,#0x3c]         ;4171
00014e  4923              LDR      r1,|L15.476|
000150  6b60              LDR      r0,[r4,#0x34]         ;4172
000152  6401              STR      r1,[r0,#0x40]         ;4172
000154  491d              LDR      r1,|L15.460|
000156  6b60              LDR      r0,[r4,#0x34]         ;4175
000158  64c1              STR      r1,[r0,#0x4c]         ;4175
00015a  2201              MOVS     r2,#1                 ;4178
00015c  eb022315          ADD      r3,r2,r5,LSR #8       ;4178
000160  6822              LDR      r2,[r4,#0]            ;4178
000162  f102014c          ADD      r1,r2,#0x4c           ;4178
000166  463a              MOV      r2,r7                 ;4178
000168  6b60              LDR      r0,[r4,#0x34]         ;4178
00016a  f7fffffe          BL       HAL_DMA_Start_IT
00016e  b108              CBZ      r0,|L15.372|
000170  2001              MOVS     r0,#1                 ;4180
000172  e750              B        |L15.22|
                  |L15.372|
000174  e017              B        |L15.422|
                  |L15.374|
000176  491a              LDR      r1,|L15.480|
000178  6ba0              LDR      r0,[r4,#0x38]         ;4187
00017a  63c1              STR      r1,[r0,#0x3c]         ;4187
00017c  4919              LDR      r1,|L15.484|
00017e  6ba0              LDR      r0,[r4,#0x38]         ;4188
000180  6401              STR      r1,[r0,#0x40]         ;4188
000182  4912              LDR      r1,|L15.460|
000184  6ba0              LDR      r0,[r4,#0x38]         ;4191
000186  64c1              STR      r1,[r0,#0x4c]         ;4191
000188  2201              MOVS     r2,#1                 ;4194
00018a  eb022315          ADD      r3,r2,r5,LSR #8       ;4194
00018e  6822              LDR      r2,[r4,#0]            ;4194
000190  f102014c          ADD      r1,r2,#0x4c           ;4194
000194  463a              MOV      r2,r7                 ;4194
000196  6ba0              LDR      r0,[r4,#0x38]         ;4194
000198  f7fffffe          BL       HAL_DMA_Start_IT
00019c  b108              CBZ      r0,|L15.418|
00019e  2001              MOVS     r0,#1                 ;4196
0001a0  e739              B        |L15.22|
                  |L15.418|
0001a2  e000              B        |L15.422|
                  |L15.420|
0001a4  bf00              NOP                            ;4201
                  |L15.422|
0001a6  bf00              NOP                            ;4102
0001a8  ea480005          ORR      r0,r8,r5              ;4205
0001ac  6821              LDR      r1,[r4,#0]            ;4205
0001ae  6488              STR      r0,[r1,#0x48]         ;4205
0001b0  6820              LDR      r0,[r4,#0]            ;4208
0001b2  68c0              LDR      r0,[r0,#0xc]          ;4208
0001b4  4330              ORRS     r0,r0,r6              ;4208
0001b6  6821              LDR      r1,[r4,#0]            ;4208
0001b8  60c8              STR      r0,[r1,#0xc]          ;4208
0001ba  2001              MOVS     r0,#1                 ;4210
0001bc  f884003d          STRB     r0,[r4,#0x3d]         ;4210
0001c0  2000              MOVS     r0,#0                 ;4213
0001c2  e728              B        |L15.22|
;;;4215   
                          ENDP

                  |L15.452|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.456|
                          DCD      TIM_DMAPeriodElapsedHalfCplt
                  |L15.460|
                          DCD      TIM_DMAError
                  |L15.464|
                          DCD      TIM_DMACaptureCplt
                  |L15.468|
                          DCD      TIM_DMACaptureHalfCplt
                  |L15.472|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.476|
                          DCD      TIMEx_DMACommutationHalfCplt
                  |L15.480|
                          DCD      TIM_DMATriggerCplt
                  |L15.484|
                          DCD      TIM_DMATriggerHalfCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;4221     */
;;;4222   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;4223   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4224     HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;4225     /* Check the parameters */
;;;4226     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;4227   
;;;4228     /* Abort the DMA transfer (at least disable the DMA stream) */
;;;4229     switch (BurstRequestSrc)
000008  f5b56f00          CMP      r5,#0x800
00000c  d023              BEQ      |L16.86|
00000e  dc09              BGT      |L16.36|
000010  f5b57f80          CMP      r5,#0x100
000014  d010              BEQ      |L16.56|
000016  f5b57f00          CMP      r5,#0x200
00001a  d012              BEQ      |L16.66|
00001c  f5b56f80          CMP      r5,#0x400
000020  d12d              BNE      |L16.126|
000022  e013              B        |L16.76|
                  |L16.36|
000024  f5b55f80          CMP      r5,#0x1000
000028  d01a              BEQ      |L16.96|
00002a  f5b55f00          CMP      r5,#0x2000
00002e  d01c              BEQ      |L16.106|
000030  f5b54f80          CMP      r5,#0x4000
000034  d123              BNE      |L16.126|
000036  e01d              B        |L16.116|
                  |L16.56|
;;;4230     {
;;;4231       case TIM_DMA_UPDATE:
;;;4232       {
;;;4233         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
000038  6a20              LDR      r0,[r4,#0x20]
00003a  f7fffffe          BL       HAL_DMA_Abort_IT
00003e  4606              MOV      r6,r0
;;;4234         break;
000040  e01e              B        |L16.128|
                  |L16.66|
;;;4235       }
;;;4236       case TIM_DMA_CC1:
;;;4237       {
;;;4238         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000042  6a60              LDR      r0,[r4,#0x24]
000044  f7fffffe          BL       HAL_DMA_Abort_IT
000048  4606              MOV      r6,r0
;;;4239         break;
00004a  e019              B        |L16.128|
                  |L16.76|
;;;4240       }
;;;4241       case TIM_DMA_CC2:
;;;4242       {
;;;4243         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
00004c  6aa0              LDR      r0,[r4,#0x28]
00004e  f7fffffe          BL       HAL_DMA_Abort_IT
000052  4606              MOV      r6,r0
;;;4244         break;
000054  e014              B        |L16.128|
                  |L16.86|
;;;4245       }
;;;4246       case TIM_DMA_CC3:
;;;4247       {
;;;4248         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  f7fffffe          BL       HAL_DMA_Abort_IT
00005c  4606              MOV      r6,r0
;;;4249         break;
00005e  e00f              B        |L16.128|
                  |L16.96|
;;;4250       }
;;;4251       case TIM_DMA_CC4:
;;;4252       {
;;;4253         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
000060  6b20              LDR      r0,[r4,#0x30]
000062  f7fffffe          BL       HAL_DMA_Abort_IT
000066  4606              MOV      r6,r0
;;;4254         break;
000068  e00a              B        |L16.128|
                  |L16.106|
;;;4255       }
;;;4256       case TIM_DMA_COM:
;;;4257       {
;;;4258         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00006a  6b60              LDR      r0,[r4,#0x34]
00006c  f7fffffe          BL       HAL_DMA_Abort_IT
000070  4606              MOV      r6,r0
;;;4259         break;
000072  e005              B        |L16.128|
                  |L16.116|
;;;4260       }
;;;4261       case TIM_DMA_TRIGGER:
;;;4262       {
;;;4263         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
000074  6ba0              LDR      r0,[r4,#0x38]
000076  f7fffffe          BL       HAL_DMA_Abort_IT
00007a  4606              MOV      r6,r0
;;;4264         break;
00007c  e000              B        |L16.128|
                  |L16.126|
;;;4265       }
;;;4266       default:
;;;4267         break;
00007e  bf00              NOP      
                  |L16.128|
000080  bf00              NOP                            ;4234
;;;4268     }
;;;4269   
;;;4270     if (HAL_OK == status)
000082  b926              CBNZ     r6,|L16.142|
;;;4271     {
;;;4272       /* Disable the TIM Update DMA request */
;;;4273       __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000084  6820              LDR      r0,[r4,#0]
000086  68c0              LDR      r0,[r0,#0xc]
000088  43a8              BICS     r0,r0,r5
00008a  6821              LDR      r1,[r4,#0]
00008c  60c8              STR      r0,[r1,#0xc]
                  |L16.142|
;;;4274     }
;;;4275   
;;;4276     /* Return function status */
;;;4277     return status;
00008e  4630              MOV      r0,r6
;;;4278   }
000090  bd70              POP      {r4-r6,pc}
;;;4279   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3798     */
;;;3799   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3800                                                 uint32_t *BurstBuffer, uint32_t  BurstLength)
;;;3801   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;3802     /* Check the parameters */
;;;3803     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3804     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3805     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3806     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3807   
;;;3808     if ((htim->State == HAL_TIM_STATE_BUSY))
00000e  f894003d          LDRB     r0,[r4,#0x3d]
000012  2802              CMP      r0,#2
000014  d101              BNE      |L17.26|
                  |L17.22|
;;;3809     {
;;;3810       return HAL_BUSY;
;;;3811     }
;;;3812     else if ((htim->State == HAL_TIM_STATE_READY))
;;;3813     {
;;;3814       if ((BurstBuffer == NULL) && (BurstLength > 0U))
;;;3815       {
;;;3816         return HAL_ERROR;
;;;3817       }
;;;3818       else
;;;3819       {
;;;3820         htim->State = HAL_TIM_STATE_BUSY;
;;;3821       }
;;;3822     }
;;;3823     else
;;;3824     {
;;;3825       /* nothing to do */
;;;3826     }
;;;3827     switch (BurstRequestSrc)
;;;3828     {
;;;3829       case TIM_DMA_UPDATE:
;;;3830       {
;;;3831         /* Set the DMA Period elapsed callbacks */
;;;3832         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3833         htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
;;;3834   
;;;3835         /* Set the DMA error callback */
;;;3836         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3837   
;;;3838         /* Enable the DMA stream */
;;;3839         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;3840         {
;;;3841           return HAL_ERROR;
;;;3842         }
;;;3843         break;
;;;3844       }
;;;3845       case TIM_DMA_CC1:
;;;3846       {
;;;3847         /* Set the DMA compare callbacks */
;;;3848         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3849         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;3850   
;;;3851         /* Set the DMA error callback */
;;;3852         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3853   
;;;3854         /* Enable the DMA stream */
;;;3855         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;3856         {
;;;3857           return HAL_ERROR;
;;;3858         }
;;;3859         break;
;;;3860       }
;;;3861       case TIM_DMA_CC2:
;;;3862       {
;;;3863         /* Set the DMA compare callbacks */
;;;3864         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3865         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;3866   
;;;3867         /* Set the DMA error callback */
;;;3868         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3869   
;;;3870         /* Enable the DMA stream */
;;;3871         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;3872         {
;;;3873           return HAL_ERROR;
;;;3874         }
;;;3875         break;
;;;3876       }
;;;3877       case TIM_DMA_CC3:
;;;3878       {
;;;3879         /* Set the DMA compare callbacks */
;;;3880         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3881         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;3882   
;;;3883         /* Set the DMA error callback */
;;;3884         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3885   
;;;3886         /* Enable the DMA stream */
;;;3887         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;3888         {
;;;3889           return HAL_ERROR;
;;;3890         }
;;;3891         break;
;;;3892       }
;;;3893       case TIM_DMA_CC4:
;;;3894       {
;;;3895         /* Set the DMA compare callbacks */
;;;3896         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3897         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;3898   
;;;3899         /* Set the DMA error callback */
;;;3900         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3901   
;;;3902         /* Enable the DMA stream */
;;;3903         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;3904         {
;;;3905           return HAL_ERROR;
;;;3906         }
;;;3907         break;
;;;3908       }
;;;3909       case TIM_DMA_COM:
;;;3910       {
;;;3911         /* Set the DMA commutation callbacks */
;;;3912         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3913         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
;;;3914   
;;;3915         /* Set the DMA error callback */
;;;3916         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3917   
;;;3918         /* Enable the DMA stream */
;;;3919         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;3920         {
;;;3921           return HAL_ERROR;
;;;3922         }
;;;3923         break;
;;;3924       }
;;;3925       case TIM_DMA_TRIGGER:
;;;3926       {
;;;3927         /* Set the DMA trigger callbacks */
;;;3928         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3929         htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
;;;3930   
;;;3931         /* Set the DMA error callback */
;;;3932         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3933   
;;;3934         /* Enable the DMA stream */
;;;3935         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
;;;3936         {
;;;3937           return HAL_ERROR;
;;;3938         }
;;;3939         break;
;;;3940       }
;;;3941       default:
;;;3942         break;
;;;3943     }
;;;3944     /* configure the DMA Burst Mode */
;;;3945     htim->Instance->DCR = (BurstBaseAddress | BurstLength);
;;;3946   
;;;3947     /* Enable the TIM DMA Request */
;;;3948     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3949   
;;;3950     htim->State = HAL_TIM_STATE_READY;
;;;3951   
;;;3952     /* Return function status */
;;;3953     return HAL_OK;
;;;3954   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L17.26|
00001a  f894003d          LDRB     r0,[r4,#0x3d]         ;3812
00001e  2801              CMP      r0,#1                 ;3812
000020  d105              BNE      |L17.46|
000022  b90f              CBNZ     r7,|L17.40|
000024  b105              CBZ      r5,|L17.40|
000026  e7f6              B        |L17.22|
                  |L17.40|
000028  2002              MOVS     r0,#2                 ;3820
00002a  f884003d          STRB     r0,[r4,#0x3d]         ;3820
                  |L17.46|
00002e  f5b66f00          CMP      r6,#0x800             ;3827
000032  d059              BEQ      |L17.232|
000034  dc09              BGT      |L17.74|
000036  f5b67f80          CMP      r6,#0x100             ;3827
00003a  d010              BEQ      |L17.94|
00003c  f5b67f00          CMP      r6,#0x200             ;3827
000040  d024              BEQ      |L17.140|
000042  f5b66f80          CMP      r6,#0x400             ;3827
                  |L17.70|
000046  d17c              BNE      |L17.322|
000048  e037              B        |L17.186|
                  |L17.74|
00004a  f5b65f80          CMP      r6,#0x1000            ;3827
00004e  d062              BEQ      |L17.278|
000050  f5b65f00          CMP      r6,#0x2000            ;3827
000054  d078              BEQ      |L17.328|
000056  f5b64f80          CMP      r6,#0x4000            ;3827
00005a  d1f4              BNE      |L17.70|
00005c  e08b              B        |L17.374|
                  |L17.94|
00005e  4859              LDR      r0,|L17.452|
000060  6a21              LDR      r1,[r4,#0x20]         ;3832
000062  63c8              STR      r0,[r1,#0x3c]         ;3832
000064  4858              LDR      r0,|L17.456|
000066  6a21              LDR      r1,[r4,#0x20]         ;3833
000068  6408              STR      r0,[r1,#0x40]         ;3833
00006a  4858              LDR      r0,|L17.460|
00006c  6a21              LDR      r1,[r4,#0x20]         ;3836
00006e  64c8              STR      r0,[r1,#0x4c]         ;3836
000070  2101              MOVS     r1,#1                 ;3839
000072  eb012315          ADD      r3,r1,r5,LSR #8       ;3839
000076  6821              LDR      r1,[r4,#0]            ;3839
000078  f101024c          ADD      r2,r1,#0x4c           ;3839
00007c  4639              MOV      r1,r7                 ;3839
00007e  6a20              LDR      r0,[r4,#0x20]         ;3839
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  b108              CBZ      r0,|L17.138|
000086  2001              MOVS     r0,#1                 ;3841
000088  e7c5              B        |L17.22|
                  |L17.138|
00008a  e08c              B        |L17.422|
                  |L17.140|
00008c  4950              LDR      r1,|L17.464|
00008e  6a60              LDR      r0,[r4,#0x24]         ;3848
000090  63c1              STR      r1,[r0,#0x3c]         ;3848
000092  4950              LDR      r1,|L17.468|
000094  6a60              LDR      r0,[r4,#0x24]         ;3849
000096  6401              STR      r1,[r0,#0x40]         ;3849
000098  494c              LDR      r1,|L17.460|
00009a  6a60              LDR      r0,[r4,#0x24]         ;3852
00009c  64c1              STR      r1,[r0,#0x4c]         ;3852
00009e  2101              MOVS     r1,#1                 ;3855
0000a0  eb012315          ADD      r3,r1,r5,LSR #8       ;3855
0000a4  6821              LDR      r1,[r4,#0]            ;3855
0000a6  f101024c          ADD      r2,r1,#0x4c           ;3855
0000aa  4639              MOV      r1,r7                 ;3855
0000ac  6a60              LDR      r0,[r4,#0x24]         ;3855
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  b108              CBZ      r0,|L17.184|
0000b4  2001              MOVS     r0,#1                 ;3857
0000b6  e7ae              B        |L17.22|
                  |L17.184|
0000b8  e075              B        |L17.422|
                  |L17.186|
0000ba  4945              LDR      r1,|L17.464|
0000bc  6aa0              LDR      r0,[r4,#0x28]         ;3864
0000be  63c1              STR      r1,[r0,#0x3c]         ;3864
0000c0  4944              LDR      r1,|L17.468|
0000c2  6aa0              LDR      r0,[r4,#0x28]         ;3865
0000c4  6401              STR      r1,[r0,#0x40]         ;3865
0000c6  4941              LDR      r1,|L17.460|
0000c8  6aa0              LDR      r0,[r4,#0x28]         ;3868
0000ca  64c1              STR      r1,[r0,#0x4c]         ;3868
0000cc  2101              MOVS     r1,#1                 ;3871
0000ce  eb012315          ADD      r3,r1,r5,LSR #8       ;3871
0000d2  6821              LDR      r1,[r4,#0]            ;3871
0000d4  f101024c          ADD      r2,r1,#0x4c           ;3871
0000d8  4639              MOV      r1,r7                 ;3871
0000da  6aa0              LDR      r0,[r4,#0x28]         ;3871
0000dc  f7fffffe          BL       HAL_DMA_Start_IT
0000e0  b108              CBZ      r0,|L17.230|
0000e2  2001              MOVS     r0,#1                 ;3873
0000e4  e797              B        |L17.22|
                  |L17.230|
0000e6  e05e              B        |L17.422|
                  |L17.232|
0000e8  4939              LDR      r1,|L17.464|
0000ea  6ae0              LDR      r0,[r4,#0x2c]         ;3880
0000ec  63c1              STR      r1,[r0,#0x3c]         ;3880
0000ee  4939              LDR      r1,|L17.468|
0000f0  6ae0              LDR      r0,[r4,#0x2c]         ;3881
0000f2  6401              STR      r1,[r0,#0x40]         ;3881
0000f4  4935              LDR      r1,|L17.460|
0000f6  6ae0              LDR      r0,[r4,#0x2c]         ;3884
0000f8  64c1              STR      r1,[r0,#0x4c]         ;3884
0000fa  2101              MOVS     r1,#1                 ;3887
0000fc  eb012315          ADD      r3,r1,r5,LSR #8       ;3887
000100  6821              LDR      r1,[r4,#0]            ;3887
000102  f101024c          ADD      r2,r1,#0x4c           ;3887
000106  4639              MOV      r1,r7                 ;3887
000108  6ae0              LDR      r0,[r4,#0x2c]         ;3887
00010a  f7fffffe          BL       HAL_DMA_Start_IT
00010e  b108              CBZ      r0,|L17.276|
000110  2001              MOVS     r0,#1                 ;3889
000112  e780              B        |L17.22|
                  |L17.276|
000114  e047              B        |L17.422|
                  |L17.278|
000116  492e              LDR      r1,|L17.464|
000118  6b20              LDR      r0,[r4,#0x30]         ;3896
00011a  63c1              STR      r1,[r0,#0x3c]         ;3896
00011c  492d              LDR      r1,|L17.468|
00011e  6b20              LDR      r0,[r4,#0x30]         ;3897
000120  6401              STR      r1,[r0,#0x40]         ;3897
000122  492a              LDR      r1,|L17.460|
000124  6b20              LDR      r0,[r4,#0x30]         ;3900
000126  64c1              STR      r1,[r0,#0x4c]         ;3900
000128  2101              MOVS     r1,#1                 ;3903
00012a  eb012315          ADD      r3,r1,r5,LSR #8       ;3903
00012e  6821              LDR      r1,[r4,#0]            ;3903
000130  f101024c          ADD      r2,r1,#0x4c           ;3903
000134  4639              MOV      r1,r7                 ;3903
000136  6b20              LDR      r0,[r4,#0x30]         ;3903
000138  f7fffffe          BL       HAL_DMA_Start_IT
00013c  b118              CBZ      r0,|L17.326|
00013e  2001              MOVS     r0,#1                 ;3905
000140  e769              B        |L17.22|
                  |L17.322|
000142  e02f              B        |L17.420|
000144  e000              B        |L17.328|
                  |L17.326|
000146  e02e              B        |L17.422|
                  |L17.328|
000148  4923              LDR      r1,|L17.472|
00014a  6b60              LDR      r0,[r4,#0x34]         ;3912
00014c  63c1              STR      r1,[r0,#0x3c]         ;3912
00014e  4923              LDR      r1,|L17.476|
000150  6b60              LDR      r0,[r4,#0x34]         ;3913
000152  6401              STR      r1,[r0,#0x40]         ;3913
000154  491d              LDR      r1,|L17.460|
000156  6b60              LDR      r0,[r4,#0x34]         ;3916
000158  64c1              STR      r1,[r0,#0x4c]         ;3916
00015a  2101              MOVS     r1,#1                 ;3919
00015c  eb012315          ADD      r3,r1,r5,LSR #8       ;3919
000160  6821              LDR      r1,[r4,#0]            ;3919
000162  f101024c          ADD      r2,r1,#0x4c           ;3919
000166  4639              MOV      r1,r7                 ;3919
000168  6b60              LDR      r0,[r4,#0x34]         ;3919
00016a  f7fffffe          BL       HAL_DMA_Start_IT
00016e  b108              CBZ      r0,|L17.372|
000170  2001              MOVS     r0,#1                 ;3921
000172  e750              B        |L17.22|
                  |L17.372|
000174  e017              B        |L17.422|
                  |L17.374|
000176  491a              LDR      r1,|L17.480|
000178  6ba0              LDR      r0,[r4,#0x38]         ;3928
00017a  63c1              STR      r1,[r0,#0x3c]         ;3928
00017c  4919              LDR      r1,|L17.484|
00017e  6ba0              LDR      r0,[r4,#0x38]         ;3929
000180  6401              STR      r1,[r0,#0x40]         ;3929
000182  4912              LDR      r1,|L17.460|
000184  6ba0              LDR      r0,[r4,#0x38]         ;3932
000186  64c1              STR      r1,[r0,#0x4c]         ;3932
000188  2101              MOVS     r1,#1                 ;3935
00018a  eb012315          ADD      r3,r1,r5,LSR #8       ;3935
00018e  6821              LDR      r1,[r4,#0]            ;3935
000190  f101024c          ADD      r2,r1,#0x4c           ;3935
000194  4639              MOV      r1,r7                 ;3935
000196  6ba0              LDR      r0,[r4,#0x38]         ;3935
000198  f7fffffe          BL       HAL_DMA_Start_IT
00019c  b108              CBZ      r0,|L17.418|
00019e  2001              MOVS     r0,#1                 ;3937
0001a0  e739              B        |L17.22|
                  |L17.418|
0001a2  e000              B        |L17.422|
                  |L17.420|
0001a4  bf00              NOP                            ;3942
                  |L17.422|
0001a6  bf00              NOP                            ;3843
0001a8  ea480005          ORR      r0,r8,r5              ;3945
0001ac  6821              LDR      r1,[r4,#0]            ;3945
0001ae  6488              STR      r0,[r1,#0x48]         ;3945
0001b0  6820              LDR      r0,[r4,#0]            ;3948
0001b2  68c0              LDR      r0,[r0,#0xc]          ;3948
0001b4  4330              ORRS     r0,r0,r6              ;3948
0001b6  6821              LDR      r1,[r4,#0]            ;3948
0001b8  60c8              STR      r0,[r1,#0xc]          ;3948
0001ba  2001              MOVS     r0,#1                 ;3950
0001bc  f884003d          STRB     r0,[r4,#0x3d]         ;3950
0001c0  2000              MOVS     r0,#0                 ;3953
0001c2  e728              B        |L17.22|
;;;3955   
                          ENDP

                  |L17.452|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.456|
                          DCD      TIM_DMAPeriodElapsedHalfCplt
                  |L17.460|
                          DCD      TIM_DMAError
                  |L17.464|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.468|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L17.472|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.476|
                          DCD      TIMEx_DMACommutationHalfCplt
                  |L17.480|
                          DCD      TIM_DMATriggerCplt
                  |L17.484|
                          DCD      TIM_DMATriggerHalfCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3961     */
;;;3962   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3963   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3964     HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;3965     /* Check the parameters */
;;;3966     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3967   
;;;3968     /* Abort the DMA transfer (at least disable the DMA stream) */
;;;3969     switch (BurstRequestSrc)
000008  f5b56f00          CMP      r5,#0x800
00000c  d023              BEQ      |L18.86|
00000e  dc09              BGT      |L18.36|
000010  f5b57f80          CMP      r5,#0x100
000014  d010              BEQ      |L18.56|
000016  f5b57f00          CMP      r5,#0x200
00001a  d012              BEQ      |L18.66|
00001c  f5b56f80          CMP      r5,#0x400
000020  d12d              BNE      |L18.126|
000022  e013              B        |L18.76|
                  |L18.36|
000024  f5b55f80          CMP      r5,#0x1000
000028  d01a              BEQ      |L18.96|
00002a  f5b55f00          CMP      r5,#0x2000
00002e  d01c              BEQ      |L18.106|
000030  f5b54f80          CMP      r5,#0x4000
000034  d123              BNE      |L18.126|
000036  e01d              B        |L18.116|
                  |L18.56|
;;;3970     {
;;;3971       case TIM_DMA_UPDATE:
;;;3972       {
;;;3973         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
000038  6a20              LDR      r0,[r4,#0x20]
00003a  f7fffffe          BL       HAL_DMA_Abort_IT
00003e  4606              MOV      r6,r0
;;;3974         break;
000040  e01e              B        |L18.128|
                  |L18.66|
;;;3975       }
;;;3976       case TIM_DMA_CC1:
;;;3977       {
;;;3978         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000042  6a60              LDR      r0,[r4,#0x24]
000044  f7fffffe          BL       HAL_DMA_Abort_IT
000048  4606              MOV      r6,r0
;;;3979         break;
00004a  e019              B        |L18.128|
                  |L18.76|
;;;3980       }
;;;3981       case TIM_DMA_CC2:
;;;3982       {
;;;3983         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
00004c  6aa0              LDR      r0,[r4,#0x28]
00004e  f7fffffe          BL       HAL_DMA_Abort_IT
000052  4606              MOV      r6,r0
;;;3984         break;
000054  e014              B        |L18.128|
                  |L18.86|
;;;3985       }
;;;3986       case TIM_DMA_CC3:
;;;3987       {
;;;3988         status =  HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  f7fffffe          BL       HAL_DMA_Abort_IT
00005c  4606              MOV      r6,r0
;;;3989         break;
00005e  e00f              B        |L18.128|
                  |L18.96|
;;;3990       }
;;;3991       case TIM_DMA_CC4:
;;;3992       {
;;;3993         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
000060  6b20              LDR      r0,[r4,#0x30]
000062  f7fffffe          BL       HAL_DMA_Abort_IT
000066  4606              MOV      r6,r0
;;;3994         break;
000068  e00a              B        |L18.128|
                  |L18.106|
;;;3995       }
;;;3996       case TIM_DMA_COM:
;;;3997       {
;;;3998         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00006a  6b60              LDR      r0,[r4,#0x34]
00006c  f7fffffe          BL       HAL_DMA_Abort_IT
000070  4606              MOV      r6,r0
;;;3999         break;
000072  e005              B        |L18.128|
                  |L18.116|
;;;4000       }
;;;4001       case TIM_DMA_TRIGGER:
;;;4002       {
;;;4003         status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
000074  6ba0              LDR      r0,[r4,#0x38]
000076  f7fffffe          BL       HAL_DMA_Abort_IT
00007a  4606              MOV      r6,r0
;;;4004         break;
00007c  e000              B        |L18.128|
                  |L18.126|
;;;4005       }
;;;4006       default:
;;;4007         break;
00007e  bf00              NOP      
                  |L18.128|
000080  bf00              NOP                            ;3974
;;;4008     }
;;;4009   
;;;4010     if (HAL_OK == status)
000082  b926              CBNZ     r6,|L18.142|
;;;4011     {
;;;4012       /* Disable the TIM Update DMA request */
;;;4013       __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000084  6820              LDR      r0,[r4,#0]
000086  68c0              LDR      r0,[r0,#0xc]
000088  43a8              BICS     r0,r0,r5
00008a  6821              LDR      r1,[r4,#0]
00008c  60c8              STR      r0,[r1,#0xc]
                  |L18.142|
;;;4014     }
;;;4015   
;;;4016     /* Return function status */
;;;4017     return status;
00008e  4630              MOV      r0,r6
;;;4018   }
000090  bd70              POP      {r4-r6,pc}
;;;4019   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2692     */
;;;2693   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2694   {
000002  4604              MOV      r4,r0
;;;2695     /* Check the parameters */
;;;2696     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2697   
;;;2698     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;2699   
;;;2700     /* Disable the TIM Peripheral Clock */
;;;2701     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L19.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L19.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L19.46|
00002e  bf00              NOP      
;;;2702   
;;;2703   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2704     if (htim->Encoder_MspDeInitCallback == NULL)
;;;2705     {
;;;2706       htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
;;;2707     }
;;;2708     /* DeInit the low level hardware */
;;;2709     htim->Encoder_MspDeInitCallback(htim);
;;;2710   #else
;;;2711     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2712     HAL_TIM_Encoder_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2713   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2714   
;;;2715     /* Change TIM state */
;;;2716     htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f884003d          STRB     r0,[r4,#0x3d]
;;;2717   
;;;2718     /* Release Lock */
;;;2719     __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;2720   
;;;2721     return HAL_OK;
;;;2722   }
000044  bd10              POP      {r4,pc}
;;;2723   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;5512     */
;;;5513   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5514   {
;;;5515     return htim->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;5516   }
000006  4770              BX       lr
;;;5517   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2587     */
;;;2588   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2589   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2590     uint32_t tmpsmcr;
;;;2591     uint32_t tmpccmr1;
;;;2592     uint32_t tmpccer;
;;;2593   
;;;2594     /* Check the TIM handle allocation */
;;;2595     if (htim == NULL)
000008  b914              CBNZ     r4,|L21.16|
;;;2596     {
;;;2597       return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L21.12|
;;;2598     }
;;;2599   
;;;2600     /* Check the parameters */
;;;2601     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2602     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2603     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2604     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2605     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2606     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2607     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2608     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2609     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2610     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2611     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2612     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2613     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2614   
;;;2615     if (htim->State == HAL_TIM_STATE_RESET)
;;;2616     {
;;;2617       /* Allocate lock resource and initialize it */
;;;2618       htim->Lock = HAL_UNLOCKED;
;;;2619   
;;;2620   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2621       /* Reset interrupt callbacks to legacy weak callbacks */
;;;2622       TIM_ResetCallback(htim);
;;;2623   
;;;2624       if (htim->Encoder_MspInitCallback == NULL)
;;;2625       {
;;;2626         htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
;;;2627       }
;;;2628       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2629       htim->Encoder_MspInitCallback(htim);
;;;2630   #else
;;;2631       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2632       HAL_TIM_Encoder_MspInit(htim);
;;;2633   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2634     }
;;;2635   
;;;2636     /* Set the TIM state */
;;;2637     htim->State = HAL_TIM_STATE_BUSY;
;;;2638   
;;;2639     /* Reset the SMS and ECE bits */
;;;2640     htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
;;;2641   
;;;2642     /* Configure the Time base in the Encoder Mode */
;;;2643     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2644   
;;;2645     /* Get the TIMx SMCR register value */
;;;2646     tmpsmcr = htim->Instance->SMCR;
;;;2647   
;;;2648     /* Get the TIMx CCMR1 register value */
;;;2649     tmpccmr1 = htim->Instance->CCMR1;
;;;2650   
;;;2651     /* Get the TIMx CCER register value */
;;;2652     tmpccer = htim->Instance->CCER;
;;;2653   
;;;2654     /* Set the encoder Mode */
;;;2655     tmpsmcr |= sConfig->EncoderMode;
;;;2656   
;;;2657     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2658     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2659     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
;;;2660   
;;;2661     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2662     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2663     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2664     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
;;;2665     tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
;;;2666   
;;;2667     /* Set the TI1 and the TI2 Polarities */
;;;2668     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2669     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2670     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
;;;2671   
;;;2672     /* Write to TIMx SMCR */
;;;2673     htim->Instance->SMCR = tmpsmcr;
;;;2674   
;;;2675     /* Write to TIMx CCMR1 */
;;;2676     htim->Instance->CCMR1 = tmpccmr1;
;;;2677   
;;;2678     /* Write to TIMx CCER */
;;;2679     htim->Instance->CCER = tmpccer;
;;;2680   
;;;2681     /* Initialize the TIM state*/
;;;2682     htim->State = HAL_TIM_STATE_READY;
;;;2683   
;;;2684     return HAL_OK;
;;;2685   }
00000c  e8bd81f0          POP      {r4-r8,pc}
                  |L21.16|
000010  f894003d          LDRB     r0,[r4,#0x3d]         ;2615
000014  b928              CBNZ     r0,|L21.34|
000016  2000              MOVS     r0,#0                 ;2618
000018  f884003c          STRB     r0,[r4,#0x3c]         ;2618
00001c  4620              MOV      r0,r4                 ;2632
00001e  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.34|
000022  2002              MOVS     r0,#2                 ;2637
000024  f884003d          STRB     r0,[r4,#0x3d]         ;2637
000028  6820              LDR      r0,[r4,#0]            ;2640
00002a  6880              LDR      r0,[r0,#8]            ;2640
00002c  f2440107          MOV      r1,#0x4007            ;2640
000030  4388              BICS     r0,r0,r1              ;2640
000032  6821              LDR      r1,[r4,#0]            ;2640
000034  6088              STR      r0,[r1,#8]            ;2640
000036  1d21              ADDS     r1,r4,#4              ;2643
000038  6820              LDR      r0,[r4,#0]            ;2643
00003a  f7fffffe          BL       TIM_Base_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;2646
000040  f8d08008          LDR      r8,[r0,#8]            ;2646
000044  6820              LDR      r0,[r4,#0]            ;2649
000046  6986              LDR      r6,[r0,#0x18]         ;2649
000048  6820              LDR      r0,[r4,#0]            ;2652
00004a  6a07              LDR      r7,[r0,#0x20]         ;2652
00004c  6828              LDR      r0,[r5,#0]            ;2655
00004e  ea400808          ORR      r8,r0,r8              ;2655
000052  f2403003          MOV      r0,#0x303             ;2658
000056  4386              BICS     r6,r6,r0              ;2658
000058  69a9              LDR      r1,[r5,#0x18]         ;2659
00005a  68a8              LDR      r0,[r5,#8]            ;2659
00005c  ea402001          ORR      r0,r0,r1,LSL #8       ;2659
000060  4306              ORRS     r6,r6,r0              ;2659
000062  f640400c          MOV      r0,#0xc0c             ;2662
000066  4386              BICS     r6,r6,r0              ;2662
000068  f24f00f0          MOV      r0,#0xf0f0            ;2663
00006c  4386              BICS     r6,r6,r0              ;2663
00006e  69e9              LDR      r1,[r5,#0x1c]         ;2664
000070  68e8              LDR      r0,[r5,#0xc]          ;2664
000072  ea402001          ORR      r0,r0,r1,LSL #8       ;2664
000076  4306              ORRS     r6,r6,r0              ;2664
000078  6928              LDR      r0,[r5,#0x10]         ;2665
00007a  0100              LSLS     r0,r0,#4              ;2665
00007c  6a29              LDR      r1,[r5,#0x20]         ;2665
00007e  ea403001          ORR      r0,r0,r1,LSL #12      ;2665
000082  4306              ORRS     r6,r6,r0              ;2665
000084  f0270722          BIC      r7,r7,#0x22           ;2668
000088  f0270788          BIC      r7,r7,#0x88           ;2669
00008c  6969              LDR      r1,[r5,#0x14]         ;2670
00008e  6868              LDR      r0,[r5,#4]            ;2670
000090  ea401001          ORR      r0,r0,r1,LSL #4       ;2670
000094  4307              ORRS     r7,r7,r0              ;2670
000096  6820              LDR      r0,[r4,#0]            ;2673
000098  f8c08008          STR      r8,[r0,#8]            ;2673
00009c  6820              LDR      r0,[r4,#0]            ;2676
00009e  6186              STR      r6,[r0,#0x18]         ;2676
0000a0  6820              LDR      r0,[r4,#0]            ;2679
0000a2  6207              STR      r7,[r0,#0x20]         ;2679
0000a4  2001              MOVS     r0,#1                 ;2682
0000a6  f884003d          STRB     r0,[r4,#0x3d]         ;2682
0000aa  2000              MOVS     r0,#0                 ;2684
0000ac  e7ae              B        |L21.12|
;;;2686   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2743     */
;;;2744   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2745   {
;;;2746     /* Prevent unused argument(s) compilation warning */
;;;2747     UNUSED(htim);
;;;2748   
;;;2749     /* NOTE : This function should not be modified, when the callback is needed,
;;;2750               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2751      */
;;;2752   }
;;;2753   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2728     */
;;;2729   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2730   {
;;;2731     /* Prevent unused argument(s) compilation warning */
;;;2732     UNUSED(htim);
;;;2733   
;;;2734     /* NOTE : This function should not be modified, when the callback is needed,
;;;2735               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2736      */
;;;2737   }
;;;2738   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2763     */
;;;2764   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2765   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2766     /* Check the parameters */
;;;2767     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2768   
;;;2769     /* Enable the encoder interface channels */
;;;2770     switch (Channel)
000006  b115              CBZ      r5,|L24.14|
000008  2d04              CMP      r5,#4
00000a  d10c              BNE      |L24.38|
00000c  e005              B        |L24.26|
                  |L24.14|
;;;2771     {
;;;2772       case TIM_CHANNEL_1:
;;;2773       {
;;;2774         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2775         break;
000018  e010              B        |L24.60|
                  |L24.26|
;;;2776       }
;;;2777   
;;;2778       case TIM_CHANNEL_2:
;;;2779       {
;;;2780         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00001a  2201              MOVS     r2,#1
00001c  2104              MOVS     r1,#4
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       TIM_CCxChannelCmd
;;;2781         break;
000024  e00a              B        |L24.60|
                  |L24.38|
;;;2782       }
;;;2783   
;;;2784       default :
;;;2785       {
;;;2786         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  2100              MOVS     r1,#0
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2787         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000030  2201              MOVS     r2,#1
000032  2104              MOVS     r1,#4
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       TIM_CCxChannelCmd
;;;2788         break;
00003a  bf00              NOP      
                  |L24.60|
00003c  bf00              NOP                            ;2775
;;;2789       }
;;;2790     }
;;;2791     /* Enable the Peripheral */
;;;2792     __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6800              LDR      r0,[r0,#0]
000042  f0400001          ORR      r0,r0,#1
000046  6821              LDR      r1,[r4,#0]
000048  6008              STR      r0,[r1,#0]
;;;2793   
;;;2794     /* Return function status */
;;;2795     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;2796   }
00004c  bd30              POP      {r4,r5,pc}
;;;2797   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2957     */
;;;2958   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2959   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;2960     /* Check the parameters */
;;;2961     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2962   
;;;2963     if ((htim->State == HAL_TIM_STATE_BUSY))
000010  f894003d          LDRB     r0,[r4,#0x3d]
000014  2802              CMP      r0,#2
000016  d101              BNE      |L25.28|
                  |L25.24|
;;;2964     {
;;;2965       return HAL_BUSY;
;;;2966     }
;;;2967     else if ((htim->State == HAL_TIM_STATE_READY))
;;;2968     {
;;;2969       if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
;;;2970       {
;;;2971         return HAL_ERROR;
;;;2972       }
;;;2973       else
;;;2974       {
;;;2975         htim->State = HAL_TIM_STATE_BUSY;
;;;2976       }
;;;2977     }
;;;2978     else
;;;2979     {
;;;2980       /* nothing to do */
;;;2981     }
;;;2982   
;;;2983     switch (Channel)
;;;2984     {
;;;2985       case TIM_CHANNEL_1:
;;;2986       {
;;;2987         /* Set the DMA capture callbacks */
;;;2988         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2989         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2990   
;;;2991         /* Set the DMA error callback */
;;;2992         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2993   
;;;2994         /* Enable the DMA stream */
;;;2995         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
;;;2996         {
;;;2997           return HAL_ERROR;
;;;2998         }
;;;2999         /* Enable the TIM Input Capture DMA request */
;;;3000         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;3001   
;;;3002         /* Enable the Peripheral */
;;;3003         __HAL_TIM_ENABLE(htim);
;;;3004   
;;;3005         /* Enable the Capture compare channel */
;;;3006         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;3007         break;
;;;3008       }
;;;3009   
;;;3010       case TIM_CHANNEL_2:
;;;3011       {
;;;3012         /* Set the DMA capture callbacks */
;;;3013         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3014         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;3015   
;;;3016         /* Set the DMA error callback */
;;;3017         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;3018         /* Enable the DMA stream */
;;;3019         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
;;;3020         {
;;;3021           return HAL_ERROR;
;;;3022         }
;;;3023         /* Enable the TIM Input Capture  DMA request */
;;;3024         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;3025   
;;;3026         /* Enable the Peripheral */
;;;3027         __HAL_TIM_ENABLE(htim);
;;;3028   
;;;3029         /* Enable the Capture compare channel */
;;;3030         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;3031         break;
;;;3032       }
;;;3033   
;;;3034       case TIM_CHANNEL_ALL:
;;;3035       {
;;;3036         /* Set the DMA capture callbacks */
;;;3037         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3038         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;3039   
;;;3040         /* Set the DMA error callback */
;;;3041         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3042   
;;;3043         /* Enable the DMA stream */
;;;3044         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
;;;3045         {
;;;3046           return HAL_ERROR;
;;;3047         }
;;;3048   
;;;3049         /* Set the DMA capture callbacks */
;;;3050         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3051         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;3052   
;;;3053         /* Set the DMA error callback */
;;;3054         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3055   
;;;3056         /* Enable the DMA stream */
;;;3057         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
;;;3058         {
;;;3059           return HAL_ERROR;
;;;3060         }
;;;3061         /* Enable the Peripheral */
;;;3062         __HAL_TIM_ENABLE(htim);
;;;3063   
;;;3064         /* Enable the Capture compare channel */
;;;3065         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;3066         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;3067   
;;;3068         /* Enable the TIM Input Capture  DMA request */
;;;3069         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;3070         /* Enable the TIM Input Capture  DMA request */
;;;3071         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;3072         break;
;;;3073       }
;;;3074   
;;;3075       default:
;;;3076         break;
;;;3077     }
;;;3078     /* Return function status */
;;;3079     return HAL_OK;
;;;3080   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L25.28|
00001c  f894003d          LDRB     r0,[r4,#0x3d]         ;2967
000020  2801              CMP      r0,#1                 ;2967
000022  d109              BNE      |L25.56|
000024  b107              CBZ      r7,|L25.40|
000026  b925              CBNZ     r5,|L25.50|
                  |L25.40|
000028  f1b80f00          CMP      r8,#0                 ;2969
00002c  d001              BEQ      |L25.50|
00002e  2001              MOVS     r0,#1                 ;2971
000030  e7f2              B        |L25.24|
                  |L25.50|
000032  2002              MOVS     r0,#2                 ;2975
000034  f884003d          STRB     r0,[r4,#0x3d]         ;2975
                  |L25.56|
000038  b126              CBZ      r6,|L25.68|
00003a  2e04              CMP      r6,#4                 ;2983
00003c  d028              BEQ      |L25.144|
00003e  2e3c              CMP      r6,#0x3c              ;2983
000040  d174              BNE      |L25.300|
000042  e04b              B        |L25.220|
                  |L25.68|
000044  494a              LDR      r1,|L25.368|
000046  6a60              LDR      r0,[r4,#0x24]         ;2988
000048  63c1              STR      r1,[r0,#0x3c]         ;2988
00004a  494a              LDR      r1,|L25.372|
00004c  6a60              LDR      r0,[r4,#0x24]         ;2989
00004e  6401              STR      r1,[r0,#0x40]         ;2989
000050  4949              LDR      r1,|L25.376|
000052  6a60              LDR      r0,[r4,#0x24]         ;2992
000054  64c1              STR      r1,[r0,#0x4c]         ;2992
000056  6822              LDR      r2,[r4,#0]            ;2995
000058  f1020134          ADD      r1,r2,#0x34           ;2995
00005c  4643              MOV      r3,r8                 ;2995
00005e  463a              MOV      r2,r7                 ;2995
000060  6a60              LDR      r0,[r4,#0x24]         ;2995
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  b108              CBZ      r0,|L25.108|
000068  2001              MOVS     r0,#1                 ;2997
00006a  e7d5              B        |L25.24|
                  |L25.108|
00006c  6820              LDR      r0,[r4,#0]            ;3000
00006e  68c0              LDR      r0,[r0,#0xc]          ;3000
000070  f4407000          ORR      r0,r0,#0x200          ;3000
000074  6821              LDR      r1,[r4,#0]            ;3000
000076  60c8              STR      r0,[r1,#0xc]          ;3000
000078  6820              LDR      r0,[r4,#0]            ;3003
00007a  6800              LDR      r0,[r0,#0]            ;3003
00007c  f0400001          ORR      r0,r0,#1              ;3003
000080  6821              LDR      r1,[r4,#0]            ;3003
000082  6008              STR      r0,[r1,#0]            ;3003
000084  2201              MOVS     r2,#1                 ;3006
000086  2100              MOVS     r1,#0                 ;3006
000088  6820              LDR      r0,[r4,#0]            ;3006
00008a  f7fffffe          BL       TIM_CCxChannelCmd
00008e  e06c              B        |L25.362|
                  |L25.144|
000090  4937              LDR      r1,|L25.368|
000092  6aa0              LDR      r0,[r4,#0x28]         ;3013
000094  63c1              STR      r1,[r0,#0x3c]         ;3013
000096  4937              LDR      r1,|L25.372|
000098  6aa0              LDR      r0,[r4,#0x28]         ;3014
00009a  6401              STR      r1,[r0,#0x40]         ;3014
00009c  4936              LDR      r1,|L25.376|
00009e  6aa0              LDR      r0,[r4,#0x28]         ;3017
0000a0  64c1              STR      r1,[r0,#0x4c]         ;3017
0000a2  6822              LDR      r2,[r4,#0]            ;3019
0000a4  f1020138          ADD      r1,r2,#0x38           ;3019
0000a8  4643              MOV      r3,r8                 ;3019
0000aa  462a              MOV      r2,r5                 ;3019
0000ac  6aa0              LDR      r0,[r4,#0x28]         ;3019
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  b108              CBZ      r0,|L25.184|
0000b4  2001              MOVS     r0,#1                 ;3021
0000b6  e7af              B        |L25.24|
                  |L25.184|
0000b8  6820              LDR      r0,[r4,#0]            ;3024
0000ba  68c0              LDR      r0,[r0,#0xc]          ;3024
0000bc  f4406080          ORR      r0,r0,#0x400          ;3024
0000c0  6821              LDR      r1,[r4,#0]            ;3024
0000c2  60c8              STR      r0,[r1,#0xc]          ;3024
0000c4  6820              LDR      r0,[r4,#0]            ;3027
0000c6  6800              LDR      r0,[r0,#0]            ;3027
0000c8  f0400001          ORR      r0,r0,#1              ;3027
0000cc  6821              LDR      r1,[r4,#0]            ;3027
0000ce  6008              STR      r0,[r1,#0]            ;3027
0000d0  2201              MOVS     r2,#1                 ;3030
0000d2  2104              MOVS     r1,#4                 ;3030
0000d4  6820              LDR      r0,[r4,#0]            ;3030
0000d6  f7fffffe          BL       TIM_CCxChannelCmd
0000da  e046              B        |L25.362|
                  |L25.220|
0000dc  4924              LDR      r1,|L25.368|
0000de  6a60              LDR      r0,[r4,#0x24]         ;3037
0000e0  63c1              STR      r1,[r0,#0x3c]         ;3037
0000e2  4924              LDR      r1,|L25.372|
0000e4  6a60              LDR      r0,[r4,#0x24]         ;3038
0000e6  6401              STR      r1,[r0,#0x40]         ;3038
0000e8  4923              LDR      r1,|L25.376|
0000ea  6a60              LDR      r0,[r4,#0x24]         ;3041
0000ec  64c1              STR      r1,[r0,#0x4c]         ;3041
0000ee  6822              LDR      r2,[r4,#0]            ;3044
0000f0  f1020134          ADD      r1,r2,#0x34           ;3044
0000f4  4643              MOV      r3,r8                 ;3044
0000f6  463a              MOV      r2,r7                 ;3044
0000f8  6a60              LDR      r0,[r4,#0x24]         ;3044
0000fa  f7fffffe          BL       HAL_DMA_Start_IT
0000fe  b108              CBZ      r0,|L25.260|
000100  2001              MOVS     r0,#1                 ;3046
000102  e789              B        |L25.24|
                  |L25.260|
000104  491a              LDR      r1,|L25.368|
000106  6aa0              LDR      r0,[r4,#0x28]         ;3050
000108  63c1              STR      r1,[r0,#0x3c]         ;3050
00010a  491a              LDR      r1,|L25.372|
00010c  6aa0              LDR      r0,[r4,#0x28]         ;3051
00010e  6401              STR      r1,[r0,#0x40]         ;3051
000110  4919              LDR      r1,|L25.376|
000112  6aa0              LDR      r0,[r4,#0x28]         ;3054
000114  64c1              STR      r1,[r0,#0x4c]         ;3054
000116  6822              LDR      r2,[r4,#0]            ;3057
000118  f1020138          ADD      r1,r2,#0x38           ;3057
00011c  4643              MOV      r3,r8                 ;3057
00011e  462a              MOV      r2,r5                 ;3057
000120  6aa0              LDR      r0,[r4,#0x28]         ;3057
000122  f7fffffe          BL       HAL_DMA_Start_IT
000126  b110              CBZ      r0,|L25.302|
000128  2001              MOVS     r0,#1                 ;3059
00012a  e775              B        |L25.24|
                  |L25.300|
00012c  e01c              B        |L25.360|
                  |L25.302|
00012e  6820              LDR      r0,[r4,#0]            ;3062
000130  6800              LDR      r0,[r0,#0]            ;3062
000132  f0400001          ORR      r0,r0,#1              ;3062
000136  6821              LDR      r1,[r4,#0]            ;3062
000138  6008              STR      r0,[r1,#0]            ;3062
00013a  2201              MOVS     r2,#1                 ;3065
00013c  2100              MOVS     r1,#0                 ;3065
00013e  6820              LDR      r0,[r4,#0]            ;3065
000140  f7fffffe          BL       TIM_CCxChannelCmd
000144  2201              MOVS     r2,#1                 ;3066
000146  2104              MOVS     r1,#4                 ;3066
000148  6820              LDR      r0,[r4,#0]            ;3066
00014a  f7fffffe          BL       TIM_CCxChannelCmd
00014e  6820              LDR      r0,[r4,#0]            ;3069
000150  68c0              LDR      r0,[r0,#0xc]          ;3069
000152  f4407000          ORR      r0,r0,#0x200          ;3069
000156  6821              LDR      r1,[r4,#0]            ;3069
000158  60c8              STR      r0,[r1,#0xc]          ;3069
00015a  6820              LDR      r0,[r4,#0]            ;3071
00015c  68c0              LDR      r0,[r0,#0xc]          ;3071
00015e  f4406080          ORR      r0,r0,#0x400          ;3071
000162  6821              LDR      r1,[r4,#0]            ;3071
000164  60c8              STR      r0,[r1,#0xc]          ;3071
000166  e000              B        |L25.362|
                  |L25.360|
000168  bf00              NOP                            ;3076
                  |L25.362|
00016a  bf00              NOP                            ;3007
00016c  2000              MOVS     r0,#0                 ;3079
00016e  e753              B        |L25.24|
;;;3081   
                          ENDP

                  |L25.368|
                          DCD      TIM_DMACaptureCplt
                  |L25.372|
                          DCD      TIM_DMACaptureHalfCplt
                  |L25.376|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2853     */
;;;2854   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2855   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2856     /* Check the parameters */
;;;2857     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2858   
;;;2859     /* Enable the encoder interface channels */
;;;2860     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2861     switch (Channel)
000006  b115              CBZ      r5,|L26.14|
000008  2d04              CMP      r5,#4
00000a  d118              BNE      |L26.62|
00000c  e00b              B        |L26.38|
                  |L26.14|
;;;2862     {
;;;2863       case TIM_CHANNEL_1:
;;;2864       {
;;;2865         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2866         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  f0400002          ORR      r0,r0,#2
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;2867         break;
000024  e022              B        |L26.108|
                  |L26.38|
;;;2868       }
;;;2869   
;;;2870       case TIM_CHANNEL_2:
;;;2871       {
;;;2872         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  2104              MOVS     r1,#4
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2873         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000030  6820              LDR      r0,[r4,#0]
000032  68c0              LDR      r0,[r0,#0xc]
000034  f0400004          ORR      r0,r0,#4
000038  6821              LDR      r1,[r4,#0]
00003a  60c8              STR      r0,[r1,#0xc]
;;;2874         break;
00003c  e016              B        |L26.108|
                  |L26.62|
;;;2875       }
;;;2876   
;;;2877       default :
;;;2878       {
;;;2879         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00003e  2201              MOVS     r2,#1
000040  2100              MOVS     r1,#0
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       TIM_CCxChannelCmd
;;;2880         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000048  2201              MOVS     r2,#1
00004a  2104              MOVS     r1,#4
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2881         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000052  6820              LDR      r0,[r4,#0]
000054  68c0              LDR      r0,[r0,#0xc]
000056  f0400002          ORR      r0,r0,#2
00005a  6821              LDR      r1,[r4,#0]
00005c  60c8              STR      r0,[r1,#0xc]
;;;2882         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00005e  6820              LDR      r0,[r4,#0]
000060  68c0              LDR      r0,[r0,#0xc]
000062  f0400004          ORR      r0,r0,#4
000066  6821              LDR      r1,[r4,#0]
000068  60c8              STR      r0,[r1,#0xc]
;;;2883         break;
00006a  bf00              NOP      
                  |L26.108|
00006c  bf00              NOP                            ;2867
;;;2884       }
;;;2885     }
;;;2886   
;;;2887     /* Enable the Peripheral */
;;;2888     __HAL_TIM_ENABLE(htim);
00006e  6820              LDR      r0,[r4,#0]
000070  6800              LDR      r0,[r0,#0]
000072  f0400001          ORR      r0,r0,#1
000076  6821              LDR      r1,[r4,#0]
000078  6008              STR      r0,[r1,#0]
;;;2889   
;;;2890     /* Return function status */
;;;2891     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;2892   }
00007c  bd30              POP      {r4,r5,pc}
;;;2893   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;2807     */
;;;2808   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2809   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2810     /* Check the parameters */
;;;2811     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2812   
;;;2813     /* Disable the Input Capture channels 1 and 2
;;;2814       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2815     switch (Channel)
000006  b115              CBZ      r5,|L27.14|
000008  2d04              CMP      r5,#4
00000a  d10c              BNE      |L27.38|
00000c  e005              B        |L27.26|
                  |L27.14|
;;;2816     {
;;;2817       case TIM_CHANNEL_1:
;;;2818       {
;;;2819         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2820         break;
000018  e010              B        |L27.60|
                  |L27.26|
;;;2821       }
;;;2822   
;;;2823       case TIM_CHANNEL_2:
;;;2824       {
;;;2825         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00001a  2200              MOVS     r2,#0
00001c  2104              MOVS     r1,#4
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       TIM_CCxChannelCmd
;;;2826         break;
000024  e00a              B        |L27.60|
                  |L27.38|
;;;2827       }
;;;2828   
;;;2829       default :
;;;2830       {
;;;2831         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  4611              MOV      r1,r2
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2832         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000030  2200              MOVS     r2,#0
000032  2104              MOVS     r1,#4
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       TIM_CCxChannelCmd
;;;2833         break;
00003a  bf00              NOP      
                  |L27.60|
00003c  bf00              NOP                            ;2820
;;;2834       }
;;;2835     }
;;;2836   
;;;2837     /* Disable the Peripheral */
;;;2838     __HAL_TIM_DISABLE(htim);
00003e  bf00              NOP      
000040  6820              LDR      r0,[r4,#0]
000042  6a00              LDR      r0,[r0,#0x20]
000044  f2411111          MOV      r1,#0x1111
000048  4008              ANDS     r0,r0,r1
00004a  b950              CBNZ     r0,|L27.98|
00004c  6820              LDR      r0,[r4,#0]
00004e  6a00              LDR      r0,[r0,#0x20]
000050  1089              ASRS     r1,r1,#2
000052  4008              ANDS     r0,r0,r1
000054  b928              CBNZ     r0,|L27.98|
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
                  |L27.98|
000062  bf00              NOP      
;;;2839   
;;;2840     /* Return function status */
;;;2841     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;2842   }
000066  bd30              POP      {r4,r5,pc}
;;;2843   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;3091     */
;;;3092   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3093   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3094     /* Check the parameters */
;;;3095     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;3096   
;;;3097     /* Disable the Input Capture channels 1 and 2
;;;3098       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;3099     if (Channel == TIM_CHANNEL_1)
000006  b975              CBNZ     r5,|L28.38|
;;;3100     {
;;;3101       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxChannelCmd
;;;3102   
;;;3103       /* Disable the capture compare DMA Request 1 */
;;;3104       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f4207000          BIC      r0,r0,#0x200
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;3105       (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
00001e  6a60              LDR      r0,[r4,#0x24]
000020  f7fffffe          BL       HAL_DMA_Abort_IT
000024  e02c              B        |L28.128|
                  |L28.38|
;;;3106     }
;;;3107     else if (Channel == TIM_CHANNEL_2)
000026  2d04              CMP      r5,#4
000028  d10e              BNE      |L28.72|
;;;3108     {
;;;3109       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00002a  2200              MOVS     r2,#0
00002c  2104              MOVS     r1,#4
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       TIM_CCxChannelCmd
;;;3110   
;;;3111       /* Disable the capture compare DMA Request 2 */
;;;3112       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  f4206080          BIC      r0,r0,#0x400
00003c  6821              LDR      r1,[r4,#0]
00003e  60c8              STR      r0,[r1,#0xc]
;;;3113       (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000040  6aa0              LDR      r0,[r4,#0x28]
000042  f7fffffe          BL       HAL_DMA_Abort_IT
000046  e01b              B        |L28.128|
                  |L28.72|
;;;3114     }
;;;3115     else
;;;3116     {
;;;3117       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000048  2200              MOVS     r2,#0
00004a  4611              MOV      r1,r2
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       TIM_CCxChannelCmd
;;;3118       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  2104              MOVS     r1,#4
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;3119   
;;;3120       /* Disable the capture compare DMA Request 1 and 2 */
;;;3121       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00005c  6820              LDR      r0,[r4,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f4207000          BIC      r0,r0,#0x200
000064  6821              LDR      r1,[r4,#0]
000066  60c8              STR      r0,[r1,#0xc]
;;;3122       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000068  6820              LDR      r0,[r4,#0]
00006a  68c0              LDR      r0,[r0,#0xc]
00006c  f4206080          BIC      r0,r0,#0x400
000070  6821              LDR      r1,[r4,#0]
000072  60c8              STR      r0,[r1,#0xc]
;;;3123       (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000074  6a60              LDR      r0,[r4,#0x24]
000076  f7fffffe          BL       HAL_DMA_Abort_IT
;;;3124       (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
00007a  6aa0              LDR      r0,[r4,#0x28]
00007c  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L28.128|
;;;3125     }
;;;3126   
;;;3127     /* Disable the Peripheral */
;;;3128     __HAL_TIM_DISABLE(htim);
000080  bf00              NOP      
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  f2411111          MOV      r1,#0x1111
00008a  4008              ANDS     r0,r0,r1
00008c  b950              CBNZ     r0,|L28.164|
00008e  6820              LDR      r0,[r4,#0]
000090  6a00              LDR      r0,[r0,#0x20]
000092  1089              ASRS     r1,r1,#2
000094  4008              ANDS     r0,r0,r1
000096  b928              CBNZ     r0,|L28.164|
000098  6820              LDR      r0,[r4,#0]
00009a  6800              LDR      r0,[r0,#0]
00009c  f0200001          BIC      r0,r0,#1
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6008              STR      r0,[r1,#0]
                  |L28.164|
0000a4  bf00              NOP      
;;;3129   
;;;3130     /* Change the htim state */
;;;3131     htim->State = HAL_TIM_STATE_READY;
0000a6  2001              MOVS     r0,#1
0000a8  f884003d          STRB     r0,[r4,#0x3d]
;;;3132   
;;;3133     /* Return function status */
;;;3134     return HAL_OK;
0000ac  2000              MOVS     r0,#0
;;;3135   }
0000ae  bd70              POP      {r4-r6,pc}
;;;3136   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2903     */
;;;2904   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2905   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2906     /* Check the parameters */
;;;2907     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2908   
;;;2909     /* Disable the Input Capture channels 1 and 2
;;;2910       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2911     if (Channel == TIM_CHANNEL_1)
000006  b95d              CBNZ     r5,|L29.32|
;;;2912     {
;;;2913       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2914   
;;;2915       /* Disable the capture compare Interrupts 1 */
;;;2916       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200002          BIC      r0,r0,#2
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
00001e  e023              B        |L29.104|
                  |L29.32|
;;;2917     }
;;;2918     else if (Channel == TIM_CHANNEL_2)
000020  2d04              CMP      r5,#4
000022  d10b              BNE      |L29.60|
;;;2919     {
;;;2920       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2921   
;;;2922       /* Disable the capture compare Interrupts 2 */
;;;2923       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
00003a  e015              B        |L29.104|
                  |L29.60|
;;;2924     }
;;;2925     else
;;;2926     {
;;;2927       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00003c  2200              MOVS     r2,#0
00003e  4611              MOV      r1,r2
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;2928       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000046  2200              MOVS     r2,#0
000048  2104              MOVS     r1,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2929   
;;;2930       /* Disable the capture compare Interrupts 1 and 2 */
;;;2931       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f0200002          BIC      r0,r0,#2
000058  6821              LDR      r1,[r4,#0]
00005a  60c8              STR      r0,[r1,#0xc]
;;;2932       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00005c  6820              LDR      r0,[r4,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f0200004          BIC      r0,r0,#4
000064  6821              LDR      r1,[r4,#0]
000066  60c8              STR      r0,[r1,#0xc]
                  |L29.104|
;;;2933     }
;;;2934   
;;;2935     /* Disable the Peripheral */
;;;2936     __HAL_TIM_DISABLE(htim);
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  f2411111          MOV      r1,#0x1111
000072  4008              ANDS     r0,r0,r1
000074  b950              CBNZ     r0,|L29.140|
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  1089              ASRS     r1,r1,#2
00007c  4008              ANDS     r0,r0,r1
00007e  b928              CBNZ     r0,|L29.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0200001          BIC      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L29.140|
00008c  bf00              NOP      
;;;2937   
;;;2938     /* Change the htim state */
;;;2939     htim->State = HAL_TIM_STATE_READY;
00008e  2001              MOVS     r0,#1
000090  f884003d          STRB     r0,[r4,#0x3d]
;;;2940   
;;;2941     /* Return function status */
;;;2942     return HAL_OK;
000094  2000              MOVS     r0,#0
;;;2943   }
000096  bd30              POP      {r4,r5,pc}
;;;2944   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4946     */
;;;4947   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4948   {
;;;4949     /* Prevent unused argument(s) compilation warning */
;;;4950     UNUSED(htim);
;;;4951   
;;;4952     /* NOTE : This function should not be modified, when the callback is needed,
;;;4953               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4954      */
;;;4955   }
;;;4956   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;4299   
;;;4300   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  4602              MOV      r2,r0
;;;4301   {
;;;4302     /* Check the parameters */
;;;4303     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;4304     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;4305   
;;;4306     /* Process Locked */
;;;4307     __HAL_LOCK(htim);
000002  bf00              NOP      
000004  f892003c          LDRB     r0,[r2,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L31.16|
00000c  2002              MOVS     r0,#2
                  |L31.14|
;;;4308   
;;;4309     /* Change the TIM state */
;;;4310     htim->State = HAL_TIM_STATE_BUSY;
;;;4311   
;;;4312     /* Set the event sources */
;;;4313     htim->Instance->EGR = EventSource;
;;;4314   
;;;4315     /* Change the TIM state */
;;;4316     htim->State = HAL_TIM_STATE_READY;
;;;4317   
;;;4318     __HAL_UNLOCK(htim);
;;;4319   
;;;4320     /* Return function status */
;;;4321     return HAL_OK;
;;;4322   }
00000e  4770              BX       lr
                  |L31.16|
000010  2001              MOVS     r0,#1                 ;4307
000012  f882003c          STRB     r0,[r2,#0x3c]         ;4307
000016  bf00              NOP                            ;4307
000018  2002              MOVS     r0,#2                 ;4310
00001a  f882003d          STRB     r0,[r2,#0x3d]         ;4310
00001e  6810              LDR      r0,[r2,#0]            ;4313
000020  6141              STR      r1,[r0,#0x14]         ;4313
000022  2001              MOVS     r0,#1                 ;4316
000024  f882003d          STRB     r0,[r2,#0x3d]         ;4316
000028  bf00              NOP                            ;4318
00002a  2000              MOVS     r0,#0                 ;4318
00002c  f882003c          STRB     r0,[r2,#0x3c]         ;4318
000030  bf00              NOP                            ;4318
000032  bf00              NOP                            ;4321
000034  e7eb              B        |L31.14|
;;;4323   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4856     */
;;;4857   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4858   {
;;;4859     /* Prevent unused argument(s) compilation warning */
;;;4860     UNUSED(htim);
;;;4861   
;;;4862     /* NOTE : This function should not be modified, when the callback is needed,
;;;4863               the HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4864      */
;;;4865   }
;;;4866   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureHalfCpltCallback PROC
;;;4871     */
;;;4872   __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4873   {
;;;4874     /* Prevent unused argument(s) compilation warning */
;;;4875     UNUSED(htim);
;;;4876   
;;;4877     /* NOTE : This function should not be modified, when the callback is needed,
;;;4878               the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
;;;4879      */
;;;4880   }
;;;4881   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3452     */
;;;3453   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3454   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;3455     /* Check the parameters */
;;;3456     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3457     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3458     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3459     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3460     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3461   
;;;3462     /* Process Locked */
;;;3463     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  f894003c          LDRB     r0,[r4,#0x3c]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L34.26|
000014  2002              MOVS     r0,#2
                  |L34.22|
;;;3464   
;;;3465     htim->State = HAL_TIM_STATE_BUSY;
;;;3466   
;;;3467     if (Channel == TIM_CHANNEL_1)
;;;3468     {
;;;3469       /* TI1 Configuration */
;;;3470       TIM_TI1_SetConfig(htim->Instance,
;;;3471                         sConfig->ICPolarity,
;;;3472                         sConfig->ICSelection,
;;;3473                         sConfig->ICFilter);
;;;3474   
;;;3475       /* Reset the IC1PSC Bits */
;;;3476       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3477   
;;;3478       /* Set the IC1PSC value */
;;;3479       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3480     }
;;;3481     else if (Channel == TIM_CHANNEL_2)
;;;3482     {
;;;3483       /* TI2 Configuration */
;;;3484       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3485   
;;;3486       TIM_TI2_SetConfig(htim->Instance,
;;;3487                         sConfig->ICPolarity,
;;;3488                         sConfig->ICSelection,
;;;3489                         sConfig->ICFilter);
;;;3490   
;;;3491       /* Reset the IC2PSC Bits */
;;;3492       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3493   
;;;3494       /* Set the IC2PSC value */
;;;3495       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
;;;3496     }
;;;3497     else if (Channel == TIM_CHANNEL_3)
;;;3498     {
;;;3499       /* TI3 Configuration */
;;;3500       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3501   
;;;3502       TIM_TI3_SetConfig(htim->Instance,
;;;3503                         sConfig->ICPolarity,
;;;3504                         sConfig->ICSelection,
;;;3505                         sConfig->ICFilter);
;;;3506   
;;;3507       /* Reset the IC3PSC Bits */
;;;3508       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3509   
;;;3510       /* Set the IC3PSC value */
;;;3511       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3512     }
;;;3513     else
;;;3514     {
;;;3515       /* TI4 Configuration */
;;;3516       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3517   
;;;3518       TIM_TI4_SetConfig(htim->Instance,
;;;3519                         sConfig->ICPolarity,
;;;3520                         sConfig->ICSelection,
;;;3521                         sConfig->ICFilter);
;;;3522   
;;;3523       /* Reset the IC4PSC Bits */
;;;3524       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3525   
;;;3526       /* Set the IC4PSC value */
;;;3527       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
;;;3528     }
;;;3529   
;;;3530     htim->State = HAL_TIM_STATE_READY;
;;;3531   
;;;3532     __HAL_UNLOCK(htim);
;;;3533   
;;;3534     return HAL_OK;
;;;3535   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L34.26|
00001a  2001              MOVS     r0,#1                 ;3463
00001c  f884003c          STRB     r0,[r4,#0x3c]         ;3463
000020  bf00              NOP                            ;3463
000022  2002              MOVS     r0,#2                 ;3465
000024  f884003d          STRB     r0,[r4,#0x3d]         ;3465
000028  b996              CBNZ     r6,|L34.80|
00002a  68eb              LDR      r3,[r5,#0xc]          ;3470
00002c  e9d51200          LDRD     r1,r2,[r5,#0]         ;3470
000030  6820              LDR      r0,[r4,#0]            ;3470
000032  f7fffffe          BL       TIM_TI1_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;3476
000038  6980              LDR      r0,[r0,#0x18]         ;3476
00003a  f020000c          BIC      r0,r0,#0xc            ;3476
00003e  6821              LDR      r1,[r4,#0]            ;3476
000040  6188              STR      r0,[r1,#0x18]         ;3476
000042  6820              LDR      r0,[r4,#0]            ;3479
000044  6980              LDR      r0,[r0,#0x18]         ;3479
000046  68a9              LDR      r1,[r5,#8]            ;3479
000048  4308              ORRS     r0,r0,r1              ;3479
00004a  6821              LDR      r1,[r4,#0]            ;3479
00004c  6188              STR      r0,[r1,#0x18]         ;3479
00004e  e03d              B        |L34.204|
                  |L34.80|
000050  2e04              CMP      r6,#4                 ;3481
000052  d113              BNE      |L34.124|
000054  68eb              LDR      r3,[r5,#0xc]          ;3486
000056  e9d51200          LDRD     r1,r2,[r5,#0]         ;3486
00005a  6820              LDR      r0,[r4,#0]            ;3486
00005c  f7fffffe          BL       TIM_TI2_SetConfig
000060  6820              LDR      r0,[r4,#0]            ;3492
000062  6980              LDR      r0,[r0,#0x18]         ;3492
000064  f4206040          BIC      r0,r0,#0xc00          ;3492
000068  6821              LDR      r1,[r4,#0]            ;3492
00006a  6188              STR      r0,[r1,#0x18]         ;3492
00006c  6820              LDR      r0,[r4,#0]            ;3495
00006e  6980              LDR      r0,[r0,#0x18]         ;3495
000070  68a9              LDR      r1,[r5,#8]            ;3495
000072  ea402001          ORR      r0,r0,r1,LSL #8       ;3495
000076  6821              LDR      r1,[r4,#0]            ;3495
000078  6188              STR      r0,[r1,#0x18]         ;3495
00007a  e027              B        |L34.204|
                  |L34.124|
00007c  2e08              CMP      r6,#8                 ;3497
00007e  d112              BNE      |L34.166|
000080  68eb              LDR      r3,[r5,#0xc]          ;3502
000082  e9d51200          LDRD     r1,r2,[r5,#0]         ;3502
000086  6820              LDR      r0,[r4,#0]            ;3502
000088  f7fffffe          BL       TIM_TI3_SetConfig
00008c  6820              LDR      r0,[r4,#0]            ;3508
00008e  69c0              LDR      r0,[r0,#0x1c]         ;3508
000090  f020000c          BIC      r0,r0,#0xc            ;3508
000094  6821              LDR      r1,[r4,#0]            ;3508
000096  61c8              STR      r0,[r1,#0x1c]         ;3508
000098  6820              LDR      r0,[r4,#0]            ;3511
00009a  69c0              LDR      r0,[r0,#0x1c]         ;3511
00009c  68a9              LDR      r1,[r5,#8]            ;3511
00009e  4308              ORRS     r0,r0,r1              ;3511
0000a0  6821              LDR      r1,[r4,#0]            ;3511
0000a2  61c8              STR      r0,[r1,#0x1c]         ;3511
0000a4  e012              B        |L34.204|
                  |L34.166|
0000a6  68eb              LDR      r3,[r5,#0xc]          ;3518
0000a8  e9d51200          LDRD     r1,r2,[r5,#0]         ;3518
0000ac  6820              LDR      r0,[r4,#0]            ;3518
0000ae  f7fffffe          BL       TIM_TI4_SetConfig
0000b2  6820              LDR      r0,[r4,#0]            ;3524
0000b4  69c0              LDR      r0,[r0,#0x1c]         ;3524
0000b6  f4206040          BIC      r0,r0,#0xc00          ;3524
0000ba  6821              LDR      r1,[r4,#0]            ;3524
0000bc  61c8              STR      r0,[r1,#0x1c]         ;3524
0000be  6820              LDR      r0,[r4,#0]            ;3527
0000c0  69c0              LDR      r0,[r0,#0x1c]         ;3527
0000c2  68a9              LDR      r1,[r5,#8]            ;3527
0000c4  ea402001          ORR      r0,r0,r1,LSL #8       ;3527
0000c8  6821              LDR      r1,[r4,#0]            ;3527
0000ca  61c8              STR      r0,[r1,#0x1c]         ;3527
                  |L34.204|
0000cc  2001              MOVS     r0,#1                 ;3530
0000ce  f884003d          STRB     r0,[r4,#0x3d]         ;3530
0000d2  bf00              NOP                            ;3532
0000d4  2000              MOVS     r0,#0                 ;3532
0000d6  f884003c          STRB     r0,[r4,#0x3c]         ;3532
0000da  bf00              NOP                            ;3532
0000dc  bf00              NOP                            ;3534
0000de  e79a              B        |L34.22|
;;;3536   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1787     */
;;;1788   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1789   {
000002  4604              MOV      r4,r0
;;;1790     /* Check the parameters */
;;;1791     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1792   
;;;1793     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;1794   
;;;1795     /* Disable the TIM Peripheral Clock */
;;;1796     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L35.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L35.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L35.46|
00002e  bf00              NOP      
;;;1797   
;;;1798   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1799     if (htim->IC_MspDeInitCallback == NULL)
;;;1800     {
;;;1801       htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
;;;1802     }
;;;1803     /* DeInit the low level hardware */
;;;1804     htim->IC_MspDeInitCallback(htim);
;;;1805   #else
;;;1806     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1807     HAL_TIM_IC_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1808   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1809   
;;;1810     /* Change TIM state */
;;;1811     htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f884003d          STRB     r0,[r4,#0x3d]
;;;1812   
;;;1813     /* Release Lock */
;;;1814     __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;1815   
;;;1816     return HAL_OK;
;;;1817   }
000044  bd10              POP      {r4,pc}
;;;1818   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;5492     */
;;;5493   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5494   {
;;;5495     return htim->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;5496   }
000006  4770              BX       lr
;;;5497   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1735     */
;;;1736   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1737   {
000002  4604              MOV      r4,r0
;;;1738     /* Check the TIM handle allocation */
;;;1739     if (htim == NULL)
000004  b90c              CBNZ     r4,|L37.10|
;;;1740     {
;;;1741       return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L37.8|
;;;1742     }
;;;1743   
;;;1744     /* Check the parameters */
;;;1745     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1746     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1747     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1748     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1749   
;;;1750     if (htim->State == HAL_TIM_STATE_RESET)
;;;1751     {
;;;1752       /* Allocate lock resource and initialize it */
;;;1753       htim->Lock = HAL_UNLOCKED;
;;;1754   
;;;1755   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1756       /* Reset interrupt callbacks to legacy weak callbacks */
;;;1757       TIM_ResetCallback(htim);
;;;1758   
;;;1759       if (htim->IC_MspInitCallback == NULL)
;;;1760       {
;;;1761         htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
;;;1762       }
;;;1763       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1764       htim->IC_MspInitCallback(htim);
;;;1765   #else
;;;1766       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1767       HAL_TIM_IC_MspInit(htim);
;;;1768   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1769     }
;;;1770   
;;;1771     /* Set the TIM state */
;;;1772     htim->State = HAL_TIM_STATE_BUSY;
;;;1773   
;;;1774     /* Init the base time for the input capture */
;;;1775     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1776   
;;;1777     /* Initialize the TIM state*/
;;;1778     htim->State = HAL_TIM_STATE_READY;
;;;1779   
;;;1780     return HAL_OK;
;;;1781   }
000008  bd10              POP      {r4,pc}
                  |L37.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;1750
00000e  b928              CBNZ     r0,|L37.28|
000010  2000              MOVS     r0,#0                 ;1753
000012  f884003c          STRB     r0,[r4,#0x3c]         ;1753
000016  4620              MOV      r0,r4                 ;1767
000018  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L37.28|
00001c  2002              MOVS     r0,#2                 ;1772
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;1772
000022  1d21              ADDS     r1,r4,#4              ;1775
000024  6820              LDR      r0,[r4,#0]            ;1775
000026  f7fffffe          BL       TIM_Base_SetConfig
00002a  2001              MOVS     r0,#1                 ;1778
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;1778
000030  2000              MOVS     r0,#0                 ;1780
000032  e7e9              B        |L37.8|
;;;1782   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1838     */
;;;1839   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1840   {
;;;1841     /* Prevent unused argument(s) compilation warning */
;;;1842     UNUSED(htim);
;;;1843   
;;;1844     /* NOTE : This function should not be modified, when the callback is needed,
;;;1845               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1846      */
;;;1847   }
;;;1848   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1823     */
;;;1824   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1825   {
;;;1826     /* Prevent unused argument(s) compilation warning */
;;;1827     UNUSED(htim);
;;;1828   
;;;1829     /* NOTE : This function should not be modified, when the callback is needed,
;;;1830               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1831      */
;;;1832   }
;;;1833   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1859     */
;;;1860   HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1861   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1862     uint32_t tmpsmcr;
;;;1863   
;;;1864     /* Check the parameters */
;;;1865     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1866   
;;;1867     /* Enable the Input Capture channel */
;;;1868     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1869   
;;;1870     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1871     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  f0000607          AND      r6,r0,#7
;;;1872     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000018  2e06              CMP      r6,#6
00001a  d005              BEQ      |L40.40|
;;;1873     {
;;;1874       __HAL_TIM_ENABLE(htim);
00001c  6820              LDR      r0,[r4,#0]
00001e  6800              LDR      r0,[r0,#0]
000020  f0400001          ORR      r0,r0,#1
000024  6821              LDR      r1,[r4,#0]
000026  6008              STR      r0,[r1,#0]
                  |L40.40|
;;;1875     }
;;;1876   
;;;1877     /* Return function status */
;;;1878     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1879   }
00002a  bd70              POP      {r4-r6,pc}
;;;1880   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;2044     */
;;;2045   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2046   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2047     uint32_t tmpsmcr;
;;;2048   
;;;2049     /* Check the parameters */
;;;2050     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2051     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2052   
;;;2053     if ((htim->State == HAL_TIM_STATE_BUSY))
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L41.24|
                  |L41.20|
;;;2054     {
;;;2055       return HAL_BUSY;
;;;2056     }
;;;2057     else if ((htim->State == HAL_TIM_STATE_READY))
;;;2058     {
;;;2059       if ((pData == NULL) && (Length > 0U))
;;;2060       {
;;;2061         return HAL_ERROR;
;;;2062       }
;;;2063       else
;;;2064       {
;;;2065         htim->State = HAL_TIM_STATE_BUSY;
;;;2066       }
;;;2067     }
;;;2068     else
;;;2069     {
;;;2070       /* nothing to do */
;;;2071     }
;;;2072   
;;;2073     switch (Channel)
;;;2074     {
;;;2075       case TIM_CHANNEL_1:
;;;2076       {
;;;2077         /* Set the DMA capture callbacks */
;;;2078         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2079         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2080   
;;;2081         /* Set the DMA error callback */
;;;2082         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2083   
;;;2084         /* Enable the DMA stream */
;;;2085         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
;;;2086         {
;;;2087           return HAL_ERROR;
;;;2088         }
;;;2089         /* Enable the TIM Capture/Compare 1 DMA request */
;;;2090         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2091         break;
;;;2092       }
;;;2093   
;;;2094       case TIM_CHANNEL_2:
;;;2095       {
;;;2096         /* Set the DMA capture callbacks */
;;;2097         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2098         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2099   
;;;2100         /* Set the DMA error callback */
;;;2101         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2102   
;;;2103         /* Enable the DMA stream */
;;;2104         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
;;;2105         {
;;;2106           return HAL_ERROR;
;;;2107         }
;;;2108         /* Enable the TIM Capture/Compare 2  DMA request */
;;;2109         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2110         break;
;;;2111       }
;;;2112   
;;;2113       case TIM_CHANNEL_3:
;;;2114       {
;;;2115         /* Set the DMA capture callbacks */
;;;2116         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2117         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2118   
;;;2119         /* Set the DMA error callback */
;;;2120         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;2121   
;;;2122         /* Enable the DMA stream */
;;;2123         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
;;;2124         {
;;;2125           return HAL_ERROR;
;;;2126         }
;;;2127         /* Enable the TIM Capture/Compare 3  DMA request */
;;;2128         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;2129         break;
;;;2130       }
;;;2131   
;;;2132       case TIM_CHANNEL_4:
;;;2133       {
;;;2134         /* Set the DMA capture callbacks */
;;;2135         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2136         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
;;;2137   
;;;2138         /* Set the DMA error callback */
;;;2139         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;2140   
;;;2141         /* Enable the DMA stream */
;;;2142         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
;;;2143         {
;;;2144           return HAL_ERROR;
;;;2145         }
;;;2146         /* Enable the TIM Capture/Compare 4  DMA request */
;;;2147         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;2148         break;
;;;2149       }
;;;2150   
;;;2151       default:
;;;2152         break;
;;;2153     }
;;;2154   
;;;2155     /* Enable the Input Capture channel */
;;;2156     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;2157   
;;;2158     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;2159     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;2160     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;2161     {
;;;2162       __HAL_TIM_ENABLE(htim);
;;;2163     }
;;;2164   
;;;2165     /* Return function status */
;;;2166     return HAL_OK;
;;;2167   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L41.24|
000018  f894003d          LDRB     r0,[r4,#0x3d]         ;2057
00001c  2801              CMP      r0,#1                 ;2057
00001e  d105              BNE      |L41.44|
000020  b90e              CBNZ     r6,|L41.38|
000022  b107              CBZ      r7,|L41.38|
000024  e7f6              B        |L41.20|
                  |L41.38|
000026  2002              MOVS     r0,#2                 ;2065
000028  f884003d          STRB     r0,[r4,#0x3d]         ;2065
                  |L41.44|
00002c  b135              CBZ      r5,|L41.60|
00002e  2d04              CMP      r5,#4                 ;2073
000030  d01f              BEQ      |L41.114|
000032  2d08              CMP      r5,#8                 ;2073
000034  d038              BEQ      |L41.168|
000036  2d0c              CMP      r5,#0xc               ;2073
000038  d16c              BNE      |L41.276|
00003a  e050              B        |L41.222|
                  |L41.60|
00003c  4940              LDR      r1,|L41.320|
00003e  6a60              LDR      r0,[r4,#0x24]         ;2078
000040  63c1              STR      r1,[r0,#0x3c]         ;2078
000042  4940              LDR      r1,|L41.324|
000044  6a60              LDR      r0,[r4,#0x24]         ;2079
000046  6401              STR      r1,[r0,#0x40]         ;2079
000048  493f              LDR      r1,|L41.328|
00004a  6a60              LDR      r0,[r4,#0x24]         ;2082
00004c  64c1              STR      r1,[r0,#0x4c]         ;2082
00004e  6822              LDR      r2,[r4,#0]            ;2085
000050  f1020134          ADD      r1,r2,#0x34           ;2085
000054  463b              MOV      r3,r7                 ;2085
000056  4632              MOV      r2,r6                 ;2085
000058  6a60              LDR      r0,[r4,#0x24]         ;2085
00005a  f7fffffe          BL       HAL_DMA_Start_IT
00005e  b108              CBZ      r0,|L41.100|
000060  2001              MOVS     r0,#1                 ;2087
000062  e7d7              B        |L41.20|
                  |L41.100|
000064  6820              LDR      r0,[r4,#0]            ;2090
000066  68c0              LDR      r0,[r0,#0xc]          ;2090
000068  f4407000          ORR      r0,r0,#0x200          ;2090
00006c  6821              LDR      r1,[r4,#0]            ;2090
00006e  60c8              STR      r0,[r1,#0xc]          ;2090
000070  e051              B        |L41.278|
                  |L41.114|
000072  4933              LDR      r1,|L41.320|
000074  6aa0              LDR      r0,[r4,#0x28]         ;2097
000076  63c1              STR      r1,[r0,#0x3c]         ;2097
000078  4932              LDR      r1,|L41.324|
00007a  6aa0              LDR      r0,[r4,#0x28]         ;2098
00007c  6401              STR      r1,[r0,#0x40]         ;2098
00007e  4932              LDR      r1,|L41.328|
000080  6aa0              LDR      r0,[r4,#0x28]         ;2101
000082  64c1              STR      r1,[r0,#0x4c]         ;2101
000084  6822              LDR      r2,[r4,#0]            ;2104
000086  f1020138          ADD      r1,r2,#0x38           ;2104
00008a  463b              MOV      r3,r7                 ;2104
00008c  4632              MOV      r2,r6                 ;2104
00008e  6aa0              LDR      r0,[r4,#0x28]         ;2104
000090  f7fffffe          BL       HAL_DMA_Start_IT
000094  b108              CBZ      r0,|L41.154|
000096  2001              MOVS     r0,#1                 ;2106
000098  e7bc              B        |L41.20|
                  |L41.154|
00009a  6820              LDR      r0,[r4,#0]            ;2109
00009c  68c0              LDR      r0,[r0,#0xc]          ;2109
00009e  f4406080          ORR      r0,r0,#0x400          ;2109
0000a2  6821              LDR      r1,[r4,#0]            ;2109
0000a4  60c8              STR      r0,[r1,#0xc]          ;2109
0000a6  e036              B        |L41.278|
                  |L41.168|
0000a8  4925              LDR      r1,|L41.320|
0000aa  6ae0              LDR      r0,[r4,#0x2c]         ;2116
0000ac  63c1              STR      r1,[r0,#0x3c]         ;2116
0000ae  4925              LDR      r1,|L41.324|
0000b0  6ae0              LDR      r0,[r4,#0x2c]         ;2117
0000b2  6401              STR      r1,[r0,#0x40]         ;2117
0000b4  4924              LDR      r1,|L41.328|
0000b6  6ae0              LDR      r0,[r4,#0x2c]         ;2120
0000b8  64c1              STR      r1,[r0,#0x4c]         ;2120
0000ba  6822              LDR      r2,[r4,#0]            ;2123
0000bc  f102013c          ADD      r1,r2,#0x3c           ;2123
0000c0  463b              MOV      r3,r7                 ;2123
0000c2  4632              MOV      r2,r6                 ;2123
0000c4  6ae0              LDR      r0,[r4,#0x2c]         ;2123
0000c6  f7fffffe          BL       HAL_DMA_Start_IT
0000ca  b108              CBZ      r0,|L41.208|
0000cc  2001              MOVS     r0,#1                 ;2125
0000ce  e7a1              B        |L41.20|
                  |L41.208|
0000d0  6820              LDR      r0,[r4,#0]            ;2128
0000d2  68c0              LDR      r0,[r0,#0xc]          ;2128
0000d4  f4406000          ORR      r0,r0,#0x800          ;2128
0000d8  6821              LDR      r1,[r4,#0]            ;2128
0000da  60c8              STR      r0,[r1,#0xc]          ;2128
0000dc  e01b              B        |L41.278|
                  |L41.222|
0000de  4918              LDR      r1,|L41.320|
0000e0  6b20              LDR      r0,[r4,#0x30]         ;2135
0000e2  63c1              STR      r1,[r0,#0x3c]         ;2135
0000e4  4917              LDR      r1,|L41.324|
0000e6  6b20              LDR      r0,[r4,#0x30]         ;2136
0000e8  6401              STR      r1,[r0,#0x40]         ;2136
0000ea  4917              LDR      r1,|L41.328|
0000ec  6b20              LDR      r0,[r4,#0x30]         ;2139
0000ee  64c1              STR      r1,[r0,#0x4c]         ;2139
0000f0  6822              LDR      r2,[r4,#0]            ;2142
0000f2  f1020140          ADD      r1,r2,#0x40           ;2142
0000f6  463b              MOV      r3,r7                 ;2142
0000f8  4632              MOV      r2,r6                 ;2142
0000fa  6b20              LDR      r0,[r4,#0x30]         ;2142
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  b108              CBZ      r0,|L41.262|
000102  2001              MOVS     r0,#1                 ;2144
000104  e786              B        |L41.20|
                  |L41.262|
000106  6820              LDR      r0,[r4,#0]            ;2147
000108  68c0              LDR      r0,[r0,#0xc]          ;2147
00010a  f4405080          ORR      r0,r0,#0x1000         ;2147
00010e  6821              LDR      r1,[r4,#0]            ;2147
000110  60c8              STR      r0,[r1,#0xc]          ;2147
000112  e000              B        |L41.278|
                  |L41.276|
000114  bf00              NOP                            ;2152
                  |L41.278|
000116  bf00              NOP                            ;2091
000118  2201              MOVS     r2,#1                 ;2156
00011a  4629              MOV      r1,r5                 ;2156
00011c  6820              LDR      r0,[r4,#0]            ;2156
00011e  f7fffffe          BL       TIM_CCxChannelCmd
000122  6820              LDR      r0,[r4,#0]            ;2159
000124  6880              LDR      r0,[r0,#8]            ;2159
000126  f0000807          AND      r8,r0,#7              ;2159
00012a  f1b80f06          CMP      r8,#6                 ;2160
00012e  d005              BEQ      |L41.316|
000130  6820              LDR      r0,[r4,#0]            ;2162
000132  6800              LDR      r0,[r0,#0]            ;2162
000134  f0400001          ORR      r0,r0,#1              ;2162
000138  6821              LDR      r1,[r4,#0]            ;2162
00013a  6008              STR      r0,[r1,#0]            ;2162
                  |L41.316|
00013c  2000              MOVS     r0,#0                 ;2166
00013e  e769              B        |L41.20|
;;;2168   
                          ENDP

                  |L41.320|
                          DCD      TIM_DMACaptureCplt
                  |L41.324|
                          DCD      TIM_DMACaptureHalfCplt
                  |L41.328|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1917     */
;;;1918   HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1919   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1920     uint32_t tmpsmcr;
;;;1921   
;;;1922     /* Check the parameters */
;;;1923     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1924   
;;;1925     switch (Channel)
000006  b135              CBZ      r5,|L42.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L42.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L42.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L42.78|
000014  e014              B        |L42.64|
                  |L42.22|
;;;1926     {
;;;1927       case TIM_CHANNEL_1:
;;;1928       {
;;;1929         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1930         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1931         break;
000022  e015              B        |L42.80|
                  |L42.36|
;;;1932       }
;;;1933   
;;;1934       case TIM_CHANNEL_2:
;;;1935       {
;;;1936         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1937         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1938         break;
000030  e00e              B        |L42.80|
                  |L42.50|
;;;1939       }
;;;1940   
;;;1941       case TIM_CHANNEL_3:
;;;1942       {
;;;1943         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1944         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1945         break;
00003e  e007              B        |L42.80|
                  |L42.64|
;;;1946       }
;;;1947   
;;;1948       case TIM_CHANNEL_4:
;;;1949       {
;;;1950         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1951         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1952         break;
00004c  e000              B        |L42.80|
                  |L42.78|
;;;1953       }
;;;1954   
;;;1955       default:
;;;1956         break;
00004e  bf00              NOP      
                  |L42.80|
000050  bf00              NOP                            ;1931
;;;1957     }
;;;1958     /* Enable the Input Capture channel */
;;;1959     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1960   
;;;1961     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1962     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
00005c  6820              LDR      r0,[r4,#0]
00005e  6880              LDR      r0,[r0,#8]
000060  f0000607          AND      r6,r0,#7
;;;1963     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000064  2e06              CMP      r6,#6
000066  d005              BEQ      |L42.116|
;;;1964     {
;;;1965       __HAL_TIM_ENABLE(htim);
000068  6820              LDR      r0,[r4,#0]
00006a  6800              LDR      r0,[r0,#0]
00006c  f0400001          ORR      r0,r0,#1
000070  6821              LDR      r1,[r4,#0]
000072  6008              STR      r0,[r1,#0]
                  |L42.116|
;;;1966     }
;;;1967   
;;;1968     /* Return function status */
;;;1969     return HAL_OK;
000074  2000              MOVS     r0,#0
;;;1970   }
000076  bd70              POP      {r4-r6,pc}
;;;1971   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1891     */
;;;1892   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1893   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1894     /* Check the parameters */
;;;1895     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1896   
;;;1897     /* Disable the Input Capture channel */
;;;1898     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1899   
;;;1900     /* Disable the Peripheral */
;;;1901     __HAL_TIM_DISABLE(htim);
000010  bf00              NOP      
000012  6820              LDR      r0,[r4,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  f2411111          MOV      r1,#0x1111
00001a  4008              ANDS     r0,r0,r1
00001c  b950              CBNZ     r0,|L43.52|
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1089              ASRS     r1,r1,#2
000024  4008              ANDS     r0,r0,r1
000026  b928              CBNZ     r0,|L43.52|
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f0200001          BIC      r0,r0,#1
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
                  |L43.52|
000034  bf00              NOP      
;;;1902   
;;;1903     /* Return function status */
;;;1904     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1905   }
000038  bd30              POP      {r4,r5,pc}
;;;1906   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;2179     */
;;;2180   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2181   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2182     /* Check the parameters */
;;;2183     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2184     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2185   
;;;2186     switch (Channel)
000006  b135              CBZ      r5,|L44.22|
000008  2d04              CMP      r5,#4
00000a  d00e              BEQ      |L44.42|
00000c  2d08              CMP      r5,#8
00000e  d016              BEQ      |L44.62|
000010  2d0c              CMP      r5,#0xc
000012  d128              BNE      |L44.102|
000014  e01d              B        |L44.82|
                  |L44.22|
;;;2187     {
;;;2188       case TIM_CHANNEL_1:
;;;2189       {
;;;2190         /* Disable the TIM Capture/Compare 1 DMA request */
;;;2191         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;2192         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000022  6a60              LDR      r0,[r4,#0x24]
000024  f7fffffe          BL       HAL_DMA_Abort_IT
;;;2193         break;
000028  e01e              B        |L44.104|
                  |L44.42|
;;;2194       }
;;;2195   
;;;2196       case TIM_CHANNEL_2:
;;;2197       {
;;;2198         /* Disable the TIM Capture/Compare 2 DMA request */
;;;2199         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  f4206080          BIC      r0,r0,#0x400
000032  6821              LDR      r1,[r4,#0]
000034  60c8              STR      r0,[r1,#0xc]
;;;2200         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000036  6aa0              LDR      r0,[r4,#0x28]
000038  f7fffffe          BL       HAL_DMA_Abort_IT
;;;2201         break;
00003c  e014              B        |L44.104|
                  |L44.62|
;;;2202       }
;;;2203   
;;;2204       case TIM_CHANNEL_3:
;;;2205       {
;;;2206         /* Disable the TIM Capture/Compare 3  DMA request */
;;;2207         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00003e  6820              LDR      r0,[r4,#0]
000040  68c0              LDR      r0,[r0,#0xc]
000042  f4206000          BIC      r0,r0,#0x800
000046  6821              LDR      r1,[r4,#0]
000048  60c8              STR      r0,[r1,#0xc]
;;;2208         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
00004a  6ae0              LDR      r0,[r4,#0x2c]
00004c  f7fffffe          BL       HAL_DMA_Abort_IT
;;;2209         break;
000050  e00a              B        |L44.104|
                  |L44.82|
;;;2210       }
;;;2211   
;;;2212       case TIM_CHANNEL_4:
;;;2213       {
;;;2214         /* Disable the TIM Capture/Compare 4  DMA request */
;;;2215         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000052  6820              LDR      r0,[r4,#0]
000054  68c0              LDR      r0,[r0,#0xc]
000056  f4205080          BIC      r0,r0,#0x1000
00005a  6821              LDR      r1,[r4,#0]
00005c  60c8              STR      r0,[r1,#0xc]
;;;2216         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
00005e  6b20              LDR      r0,[r4,#0x30]
000060  f7fffffe          BL       HAL_DMA_Abort_IT
;;;2217         break;
000064  e000              B        |L44.104|
                  |L44.102|
;;;2218       }
;;;2219   
;;;2220       default:
;;;2221         break;
000066  bf00              NOP      
                  |L44.104|
000068  bf00              NOP                            ;2193
;;;2222     }
;;;2223   
;;;2224     /* Disable the Input Capture channel */
;;;2225     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00006a  2200              MOVS     r2,#0
00006c  4629              MOV      r1,r5
00006e  6820              LDR      r0,[r4,#0]
000070  f7fffffe          BL       TIM_CCxChannelCmd
;;;2226   
;;;2227     /* Disable the Peripheral */
;;;2228     __HAL_TIM_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L44.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L44.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6800              LDR      r0,[r0,#0]
000090  f0200001          BIC      r0,r0,#1
000094  6821              LDR      r1,[r4,#0]
000096  6008              STR      r0,[r1,#0]
                  |L44.152|
000098  bf00              NOP      
;;;2229   
;;;2230     /* Change the htim state */
;;;2231     htim->State = HAL_TIM_STATE_READY;
00009a  2001              MOVS     r0,#1
00009c  f884003d          STRB     r0,[r4,#0x3d]
;;;2232   
;;;2233     /* Return function status */
;;;2234     return HAL_OK;
0000a0  2000              MOVS     r0,#0
;;;2235   }
0000a2  bd70              POP      {r4-r6,pc}
;;;2236   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1982     */
;;;1983   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1984   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1985     /* Check the parameters */
;;;1986     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1987   
;;;1988     switch (Channel)
000006  b135              CBZ      r5,|L45.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L45.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L45.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L45.78|
000014  e014              B        |L45.64|
                  |L45.22|
;;;1989     {
;;;1990       case TIM_CHANNEL_1:
;;;1991       {
;;;1992         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1993         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1994         break;
000022  e015              B        |L45.80|
                  |L45.36|
;;;1995       }
;;;1996   
;;;1997       case TIM_CHANNEL_2:
;;;1998       {
;;;1999         /* Disable the TIM Capture/Compare 2 interrupt */
;;;2000         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;2001         break;
000030  e00e              B        |L45.80|
                  |L45.50|
;;;2002       }
;;;2003   
;;;2004       case TIM_CHANNEL_3:
;;;2005       {
;;;2006         /* Disable the TIM Capture/Compare 3 interrupt */
;;;2007         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;2008         break;
00003e  e007              B        |L45.80|
                  |L45.64|
;;;2009       }
;;;2010   
;;;2011       case TIM_CHANNEL_4:
;;;2012       {
;;;2013         /* Disable the TIM Capture/Compare 4 interrupt */
;;;2014         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;2015         break;
00004c  e000              B        |L45.80|
                  |L45.78|
;;;2016       }
;;;2017   
;;;2018       default:
;;;2019         break;
00004e  bf00              NOP      
                  |L45.80|
000050  bf00              NOP                            ;1994
;;;2020     }
;;;2021   
;;;2022     /* Disable the Input Capture channel */
;;;2023     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;2024   
;;;2025     /* Disable the Peripheral */
;;;2026     __HAL_TIM_DISABLE(htim);
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L45.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L45.128|
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  f0200001          BIC      r0,r0,#1
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L45.128|
000080  bf00              NOP      
;;;2027   
;;;2028     /* Return function status */
;;;2029     return HAL_OK;
000082  2000              MOVS     r0,#0
;;;2030   }
000084  bd30              POP      {r4,r5,pc}
;;;2031   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;3157     */
;;;3158   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;3159   {
000002  4604              MOV      r4,r0
;;;3160     /* Capture compare 1 event */
;;;3161     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6900              LDR      r0,[r0,#0x10]
000008  f3c00040          UBFX     r0,r0,#1,#1
00000c  b1d8              CBZ      r0,|L46.70|
;;;3162     {
;;;3163       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  f3c00040          UBFX     r0,r0,#1,#1
000016  b1b0              CBZ      r0,|L46.70|
;;;3164       {
;;;3165         {
;;;3166           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
000018  f06f0002          MVN      r0,#2
00001c  6821              LDR      r1,[r4,#0]
00001e  6108              STR      r0,[r1,#0x10]
;;;3167           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000020  2001              MOVS     r0,#1
000022  7720              STRB     r0,[r4,#0x1c]
;;;3168   
;;;3169           /* Input capture event */
;;;3170           if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
000024  6820              LDR      r0,[r4,#0]
000026  6980              LDR      r0,[r0,#0x18]
000028  f0000003          AND      r0,r0,#3
00002c  b118              CBZ      r0,|L46.54|
;;;3171           {
;;;3172   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3173             htim->IC_CaptureCallback(htim);
;;;3174   #else
;;;3175             HAL_TIM_IC_CaptureCallback(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000034  e005              B        |L46.66|
                  |L46.54|
;;;3176   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3177           }
;;;3178           /* Output compare event */
;;;3179           else
;;;3180           {
;;;3181   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3182             htim->OC_DelayElapsedCallback(htim);
;;;3183             htim->PWM_PulseFinishedCallback(htim);
;;;3184   #else
;;;3185             HAL_TIM_OC_DelayElapsedCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3186             HAL_TIM_PWM_PulseFinishedCallback(htim);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L46.66|
;;;3187   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3188           }
;;;3189           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000042  2000              MOVS     r0,#0
000044  7720              STRB     r0,[r4,#0x1c]
                  |L46.70|
;;;3190         }
;;;3191       }
;;;3192     }
;;;3193     /* Capture compare 2 event */
;;;3194     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000046  6820              LDR      r0,[r4,#0]
000048  6900              LDR      r0,[r0,#0x10]
00004a  f3c00080          UBFX     r0,r0,#2,#1
00004e  b1d8              CBZ      r0,|L46.136|
;;;3195     {
;;;3196       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f3c00080          UBFX     r0,r0,#2,#1
000058  b1b0              CBZ      r0,|L46.136|
;;;3197       {
;;;3198         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
00005a  f06f0004          MVN      r0,#4
00005e  6821              LDR      r1,[r4,#0]
000060  6108              STR      r0,[r1,#0x10]
;;;3199         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000062  2002              MOVS     r0,#2
000064  7720              STRB     r0,[r4,#0x1c]
;;;3200         /* Input capture event */
;;;3201         if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
000066  6820              LDR      r0,[r4,#0]
000068  6980              LDR      r0,[r0,#0x18]
00006a  f4007040          AND      r0,r0,#0x300
00006e  b118              CBZ      r0,|L46.120|
;;;3202         {
;;;3203   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3204           htim->IC_CaptureCallback(htim);
;;;3205   #else
;;;3206           HAL_TIM_IC_CaptureCallback(htim);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000076  e005              B        |L46.132|
                  |L46.120|
;;;3207   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3208         }
;;;3209         /* Output compare event */
;;;3210         else
;;;3211         {
;;;3212   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3213           htim->OC_DelayElapsedCallback(htim);
;;;3214           htim->PWM_PulseFinishedCallback(htim);
;;;3215   #else
;;;3216           HAL_TIM_OC_DelayElapsedCallback(htim);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3217           HAL_TIM_PWM_PulseFinishedCallback(htim);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L46.132|
;;;3218   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3219         }
;;;3220         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000084  2000              MOVS     r0,#0
000086  7720              STRB     r0,[r4,#0x1c]
                  |L46.136|
;;;3221       }
;;;3222     }
;;;3223     /* Capture compare 3 event */
;;;3224     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000088  6820              LDR      r0,[r4,#0]
00008a  6900              LDR      r0,[r0,#0x10]
00008c  f3c000c0          UBFX     r0,r0,#3,#1
000090  b1d8              CBZ      r0,|L46.202|
;;;3225     {
;;;3226       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
000092  6820              LDR      r0,[r4,#0]
000094  68c0              LDR      r0,[r0,#0xc]
000096  f3c000c0          UBFX     r0,r0,#3,#1
00009a  b1b0              CBZ      r0,|L46.202|
;;;3227       {
;;;3228         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00009c  f06f0008          MVN      r0,#8
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6108              STR      r0,[r1,#0x10]
;;;3229         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
0000a4  2004              MOVS     r0,#4
0000a6  7720              STRB     r0,[r4,#0x1c]
;;;3230         /* Input capture event */
;;;3231         if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
0000a8  6820              LDR      r0,[r4,#0]
0000aa  69c0              LDR      r0,[r0,#0x1c]
0000ac  f0000003          AND      r0,r0,#3
0000b0  b118              CBZ      r0,|L46.186|
;;;3232         {
;;;3233   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3234           htim->IC_CaptureCallback(htim);
;;;3235   #else
;;;3236           HAL_TIM_IC_CaptureCallback(htim);
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000b8  e005              B        |L46.198|
                  |L46.186|
;;;3237   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3238         }
;;;3239         /* Output compare event */
;;;3240         else
;;;3241         {
;;;3242   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3243           htim->OC_DelayElapsedCallback(htim);
;;;3244           htim->PWM_PulseFinishedCallback(htim);
;;;3245   #else
;;;3246           HAL_TIM_OC_DelayElapsedCallback(htim);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3247           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L46.198|
;;;3248   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3249         }
;;;3250         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000c6  2000              MOVS     r0,#0
0000c8  7720              STRB     r0,[r4,#0x1c]
                  |L46.202|
;;;3251       }
;;;3252     }
;;;3253     /* Capture compare 4 event */
;;;3254     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6900              LDR      r0,[r0,#0x10]
0000ce  f3c01000          UBFX     r0,r0,#4,#1
0000d2  b1d8              CBZ      r0,|L46.268|
;;;3255     {
;;;3256       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
0000d4  6820              LDR      r0,[r4,#0]
0000d6  68c0              LDR      r0,[r0,#0xc]
0000d8  f3c01000          UBFX     r0,r0,#4,#1
0000dc  b1b0              CBZ      r0,|L46.268|
;;;3257       {
;;;3258         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000de  f06f0010          MVN      r0,#0x10
0000e2  6821              LDR      r1,[r4,#0]
0000e4  6108              STR      r0,[r1,#0x10]
;;;3259         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000e6  2008              MOVS     r0,#8
0000e8  7720              STRB     r0,[r4,#0x1c]
;;;3260         /* Input capture event */
;;;3261         if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
0000ea  6820              LDR      r0,[r4,#0]
0000ec  69c0              LDR      r0,[r0,#0x1c]
0000ee  f4007040          AND      r0,r0,#0x300
0000f2  b118              CBZ      r0,|L46.252|
;;;3262         {
;;;3263   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3264           htim->IC_CaptureCallback(htim);
;;;3265   #else
;;;3266           HAL_TIM_IC_CaptureCallback(htim);
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000fa  e005              B        |L46.264|
                  |L46.252|
;;;3267   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3268         }
;;;3269         /* Output compare event */
;;;3270         else
;;;3271         {
;;;3272   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3273           htim->OC_DelayElapsedCallback(htim);
;;;3274           htim->PWM_PulseFinishedCallback(htim);
;;;3275   #else
;;;3276           HAL_TIM_OC_DelayElapsedCallback(htim);
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3277           HAL_TIM_PWM_PulseFinishedCallback(htim);
000102  4620              MOV      r0,r4
000104  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L46.264|
;;;3278   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3279         }
;;;3280         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000108  2000              MOVS     r0,#0
00010a  7720              STRB     r0,[r4,#0x1c]
                  |L46.268|
;;;3281       }
;;;3282     }
;;;3283     /* TIM Update event */
;;;3284     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
00010c  6820              LDR      r0,[r4,#0]
00010e  6900              LDR      r0,[r0,#0x10]
000110  f0000001          AND      r0,r0,#1
000114  b158              CBZ      r0,|L46.302|
;;;3285     {
;;;3286       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
000116  6820              LDR      r0,[r4,#0]
000118  68c0              LDR      r0,[r0,#0xc]
00011a  f0000001          AND      r0,r0,#1
00011e  b130              CBZ      r0,|L46.302|
;;;3287       {
;;;3288         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000120  f06f0001          MVN      r0,#1
000124  6821              LDR      r1,[r4,#0]
000126  6108              STR      r0,[r1,#0x10]
;;;3289   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3290         htim->PeriodElapsedCallback(htim);
;;;3291   #else
;;;3292         HAL_TIM_PeriodElapsedCallback(htim);
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L46.302|
;;;3293   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3294       }
;;;3295     }
;;;3296     /* TIM Break input event */
;;;3297     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00012e  6820              LDR      r0,[r4,#0]
000130  6900              LDR      r0,[r0,#0x10]
000132  f3c010c0          UBFX     r0,r0,#7,#1
000136  b158              CBZ      r0,|L46.336|
;;;3298     {
;;;3299       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
000138  6820              LDR      r0,[r4,#0]
00013a  68c0              LDR      r0,[r0,#0xc]
00013c  f3c010c0          UBFX     r0,r0,#7,#1
000140  b130              CBZ      r0,|L46.336|
;;;3300       {
;;;3301         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000142  f06f0080          MVN      r0,#0x80
000146  6821              LDR      r1,[r4,#0]
000148  6108              STR      r0,[r1,#0x10]
;;;3302   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3303         htim->BreakCallback(htim);
;;;3304   #else
;;;3305         HAL_TIMEx_BreakCallback(htim);
00014a  4620              MOV      r0,r4
00014c  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L46.336|
;;;3306   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3307       }
;;;3308     }
;;;3309     /* TIM Trigger detection event */
;;;3310     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000150  6820              LDR      r0,[r4,#0]
000152  6900              LDR      r0,[r0,#0x10]
000154  f3c01080          UBFX     r0,r0,#6,#1
000158  b158              CBZ      r0,|L46.370|
;;;3311     {
;;;3312       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
00015a  6820              LDR      r0,[r4,#0]
00015c  68c0              LDR      r0,[r0,#0xc]
00015e  f3c01080          UBFX     r0,r0,#6,#1
000162  b130              CBZ      r0,|L46.370|
;;;3313       {
;;;3314         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000164  f06f0040          MVN      r0,#0x40
000168  6821              LDR      r1,[r4,#0]
00016a  6108              STR      r0,[r1,#0x10]
;;;3315   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3316         htim->TriggerCallback(htim);
;;;3317   #else
;;;3318         HAL_TIM_TriggerCallback(htim);
00016c  4620              MOV      r0,r4
00016e  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L46.370|
;;;3319   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3320       }
;;;3321     }
;;;3322     /* TIM commutation event */
;;;3323     if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000172  6820              LDR      r0,[r4,#0]
000174  6900              LDR      r0,[r0,#0x10]
000176  f3c01040          UBFX     r0,r0,#5,#1
00017a  b158              CBZ      r0,|L46.404|
;;;3324     {
;;;3325       if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
00017c  6820              LDR      r0,[r4,#0]
00017e  68c0              LDR      r0,[r0,#0xc]
000180  f3c01040          UBFX     r0,r0,#5,#1
000184  b130              CBZ      r0,|L46.404|
;;;3326       {
;;;3327         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
000186  f06f0020          MVN      r0,#0x20
00018a  6821              LDR      r1,[r4,#0]
00018c  6108              STR      r0,[r1,#0x10]
;;;3328   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3329         htim->CommutationCallback(htim);
;;;3330   #else
;;;3331         HAL_TIMEx_CommutCallback(htim);
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       HAL_TIMEx_CommutCallback
                  |L46.404|
;;;3332   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3333       }
;;;3334     }
;;;3335   }
000194  bd10              POP      {r4,pc}
;;;3336   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;3372     */
;;;3373   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;3374                                              TIM_OC_InitTypeDef *sConfig,
;;;3375                                              uint32_t Channel)
;;;3376   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;3377     /* Check the parameters */
;;;3378     assert_param(IS_TIM_CHANNELS(Channel));
;;;3379     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;3380     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3381   
;;;3382     /* Process Locked */
;;;3383     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  f894003c          LDRB     r0,[r4,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L47.22|
000012  2002              MOVS     r0,#2
                  |L47.20|
;;;3384   
;;;3385     htim->State = HAL_TIM_STATE_BUSY;
;;;3386   
;;;3387     switch (Channel)
;;;3388     {
;;;3389       case TIM_CHANNEL_1:
;;;3390       {
;;;3391         /* Check the parameters */
;;;3392         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3393   
;;;3394         /* Configure the TIM Channel 1 in Output Compare */
;;;3395         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3396         break;
;;;3397       }
;;;3398   
;;;3399       case TIM_CHANNEL_2:
;;;3400       {
;;;3401         /* Check the parameters */
;;;3402         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3403   
;;;3404         /* Configure the TIM Channel 2 in Output Compare */
;;;3405         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3406         break;
;;;3407       }
;;;3408   
;;;3409       case TIM_CHANNEL_3:
;;;3410       {
;;;3411         /* Check the parameters */
;;;3412         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3413   
;;;3414         /* Configure the TIM Channel 3 in Output Compare */
;;;3415         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3416         break;
;;;3417       }
;;;3418   
;;;3419       case TIM_CHANNEL_4:
;;;3420       {
;;;3421         /* Check the parameters */
;;;3422         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3423   
;;;3424         /* Configure the TIM Channel 4 in Output Compare */
;;;3425         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3426         break;
;;;3427       }
;;;3428   
;;;3429       default:
;;;3430         break;
;;;3431     }
;;;3432   
;;;3433     htim->State = HAL_TIM_STATE_READY;
;;;3434   
;;;3435     __HAL_UNLOCK(htim);
;;;3436   
;;;3437     return HAL_OK;
;;;3438   }
000014  bd70              POP      {r4-r6,pc}
                  |L47.22|
000016  2001              MOVS     r0,#1                 ;3383
000018  f884003c          STRB     r0,[r4,#0x3c]         ;3383
00001c  bf00              NOP                            ;3383
00001e  2002              MOVS     r0,#2                 ;3385
000020  f884003d          STRB     r0,[r4,#0x3d]         ;3385
000024  b135              CBZ      r5,|L47.52|
000026  2d04              CMP      r5,#4                 ;3387
000028  d009              BEQ      |L47.62|
00002a  2d08              CMP      r5,#8                 ;3387
00002c  d00c              BEQ      |L47.72|
00002e  2d0c              CMP      r5,#0xc               ;3387
000030  d114              BNE      |L47.92|
000032  e00e              B        |L47.82|
                  |L47.52|
000034  4631              MOV      r1,r6                 ;3395
000036  6820              LDR      r0,[r4,#0]            ;3395
000038  f7fffffe          BL       TIM_OC1_SetConfig
00003c  e00f              B        |L47.94|
                  |L47.62|
00003e  4631              MOV      r1,r6                 ;3405
000040  6820              LDR      r0,[r4,#0]            ;3405
000042  f7fffffe          BL       TIM_OC2_SetConfig
000046  e00a              B        |L47.94|
                  |L47.72|
000048  4631              MOV      r1,r6                 ;3415
00004a  6820              LDR      r0,[r4,#0]            ;3415
00004c  f7fffffe          BL       TIM_OC3_SetConfig
000050  e005              B        |L47.94|
                  |L47.82|
000052  4631              MOV      r1,r6                 ;3425
000054  6820              LDR      r0,[r4,#0]            ;3425
000056  f7fffffe          BL       TIM_OC4_SetConfig
00005a  e000              B        |L47.94|
                  |L47.92|
00005c  bf00              NOP                            ;3430
                  |L47.94|
00005e  bf00              NOP                            ;3396
000060  2001              MOVS     r0,#1                 ;3433
000062  f884003d          STRB     r0,[r4,#0x3d]         ;3433
000066  bf00              NOP                            ;3435
000068  2000              MOVS     r0,#0                 ;3435
00006a  f884003c          STRB     r0,[r4,#0x3c]         ;3435
00006e  bf00              NOP                            ;3435
000070  bf00              NOP                            ;3437
000072  e7cf              B        |L47.20|
;;;3439   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;640      */
;;;641    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;642    {
000002  4604              MOV      r4,r0
;;;643      /* Check the parameters */
;;;644      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;645    
;;;646      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;647    
;;;648      /* Disable the TIM Peripheral Clock */
;;;649      __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L48.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L48.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L48.46|
00002e  bf00              NOP      
;;;650    
;;;651    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;652      if (htim->OC_MspDeInitCallback == NULL)
;;;653      {
;;;654        htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
;;;655      }
;;;656      /* DeInit the low level hardware */
;;;657      htim->OC_MspDeInitCallback(htim);
;;;658    #else
;;;659      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;660      HAL_TIM_OC_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;661    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;662    
;;;663      /* Change TIM state */
;;;664      htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f884003d          STRB     r0,[r4,#0x3d]
;;;665    
;;;666      /* Release Lock */
;;;667      __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;668    
;;;669      return HAL_OK;
;;;670    }
000044  bd10              POP      {r4,pc}
;;;671    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4841     */
;;;4842   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4843   {
;;;4844     /* Prevent unused argument(s) compilation warning */
;;;4845     UNUSED(htim);
;;;4846   
;;;4847     /* NOTE : This function should not be modified, when the callback is needed,
;;;4848               the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4849      */
;;;4850   }
;;;4851   
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;5472     */
;;;5473   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5474   {
;;;5475     return htim->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;5476   }
000006  4770              BX       lr
;;;5477   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;588      */
;;;589    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;590    {
000002  4604              MOV      r4,r0
;;;591      /* Check the TIM handle allocation */
;;;592      if (htim == NULL)
000004  b90c              CBNZ     r4,|L51.10|
;;;593      {
;;;594        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L51.8|
;;;595      }
;;;596    
;;;597      /* Check the parameters */
;;;598      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;599      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;600      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;601      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;602    
;;;603      if (htim->State == HAL_TIM_STATE_RESET)
;;;604      {
;;;605        /* Allocate lock resource and initialize it */
;;;606        htim->Lock = HAL_UNLOCKED;
;;;607    
;;;608    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;609        /* Reset interrupt callbacks to legacy weak callbacks */
;;;610        TIM_ResetCallback(htim);
;;;611    
;;;612        if (htim->OC_MspInitCallback == NULL)
;;;613        {
;;;614          htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
;;;615        }
;;;616        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;617        htim->OC_MspInitCallback(htim);
;;;618    #else
;;;619        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;620        HAL_TIM_OC_MspInit(htim);
;;;621    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;622      }
;;;623    
;;;624      /* Set the TIM state */
;;;625      htim->State = HAL_TIM_STATE_BUSY;
;;;626    
;;;627      /* Init the base time for the Output Compare */
;;;628      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;629    
;;;630      /* Initialize the TIM state*/
;;;631      htim->State = HAL_TIM_STATE_READY;
;;;632    
;;;633      return HAL_OK;
;;;634    }
000008  bd10              POP      {r4,pc}
                  |L51.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;603
00000e  b928              CBNZ     r0,|L51.28|
000010  2000              MOVS     r0,#0                 ;606
000012  f884003c          STRB     r0,[r4,#0x3c]         ;606
000016  4620              MOV      r0,r4                 ;620
000018  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L51.28|
00001c  2002              MOVS     r0,#2                 ;625
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;625
000022  1d21              ADDS     r1,r4,#4              ;628
000024  6820              LDR      r0,[r4,#0]            ;628
000026  f7fffffe          BL       TIM_Base_SetConfig
00002a  2001              MOVS     r0,#1                 ;631
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;631
000030  2000              MOVS     r0,#0                 ;633
000032  e7e9              B        |L51.8|
;;;635    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;691      */
;;;692    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;693    {
;;;694      /* Prevent unused argument(s) compilation warning */
;;;695      UNUSED(htim);
;;;696    
;;;697      /* NOTE : This function should not be modified, when the callback is needed,
;;;698                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;699       */
;;;700    }
;;;701    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;676      */
;;;677    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;678    {
;;;679      /* Prevent unused argument(s) compilation warning */
;;;680      UNUSED(htim);
;;;681    
;;;682      /* NOTE : This function should not be modified, when the callback is needed,
;;;683                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;684       */
;;;685    }
;;;686    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;712      */
;;;713    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;714    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;715      uint32_t tmpsmcr;
;;;716    
;;;717      /* Check the parameters */
;;;718      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;719    
;;;720      /* Enable the Output compare channel */
;;;721      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4631              MOV      r1,r6
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;722    
;;;723      if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  490d              LDR      r1,|L54.72|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d101              BNE      |L54.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L54.30|
                  |L54.28|
00001c  2000              MOVS     r0,#0
                  |L54.30|
00001e  b128              CBZ      r0,|L54.44|
;;;724      {
;;;725        /* Enable the main output */
;;;726        __HAL_TIM_MOE_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6c40              LDR      r0,[r0,#0x44]
000024  f4404000          ORR      r0,r0,#0x8000
000028  6821              LDR      r1,[r4,#0]
00002a  6448              STR      r0,[r1,#0x44]
                  |L54.44|
;;;727      }
;;;728    
;;;729      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;730      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  f0000507          AND      r5,r0,#7
;;;731      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000034  2d06              CMP      r5,#6
000036  d005              BEQ      |L54.68|
;;;732      {
;;;733        __HAL_TIM_ENABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6800              LDR      r0,[r0,#0]
00003c  f0400001          ORR      r0,r0,#1
000040  6821              LDR      r1,[r4,#0]
000042  6008              STR      r0,[r1,#0]
                  |L54.68|
;;;734      }
;;;735    
;;;736      /* Return function status */
;;;737      return HAL_OK;
000044  2000              MOVS     r0,#0
;;;738    }
000046  bd70              POP      {r4-r6,pc}
;;;739    
                          ENDP

                  |L54.72|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;922      */
;;;923    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;924    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;925       uint32_t tmpsmcr;
;;;926    
;;;927      /* Check the parameters */
;;;928      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;929    
;;;930      if ((htim->State == HAL_TIM_STATE_BUSY))
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L55.24|
                  |L55.20|
;;;931      {
;;;932        return HAL_BUSY;
;;;933      }
;;;934      else if ((htim->State == HAL_TIM_STATE_READY))
;;;935      {
;;;936        if ((pData == NULL) && (Length > 0U))
;;;937        {
;;;938          return HAL_ERROR;
;;;939        }
;;;940        else
;;;941        {
;;;942          htim->State = HAL_TIM_STATE_BUSY;
;;;943        }
;;;944      }
;;;945      else
;;;946      {
;;;947        /* nothing to do */
;;;948      }
;;;949    
;;;950      switch (Channel)
;;;951      {
;;;952        case TIM_CHANNEL_1:
;;;953        {
;;;954          /* Set the DMA compare callbacks */
;;;955          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;956          htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;957    
;;;958          /* Set the DMA error callback */
;;;959          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;960    
;;;961          /* Enable the DMA stream */
;;;962          if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
;;;963          {
;;;964            return HAL_ERROR;
;;;965          }
;;;966    
;;;967          /* Enable the TIM Capture/Compare 1 DMA request */
;;;968          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;969          break;
;;;970        }
;;;971    
;;;972        case TIM_CHANNEL_2:
;;;973        {
;;;974          /* Set the DMA compare callbacks */
;;;975          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;976          htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;977    
;;;978          /* Set the DMA error callback */
;;;979          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;980    
;;;981          /* Enable the DMA stream */
;;;982          if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
;;;983          {
;;;984            return HAL_ERROR;
;;;985          }
;;;986    
;;;987          /* Enable the TIM Capture/Compare 2 DMA request */
;;;988          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;989          break;
;;;990        }
;;;991    
;;;992        case TIM_CHANNEL_3:
;;;993        {
;;;994          /* Set the DMA compare callbacks */
;;;995          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;996          htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;997    
;;;998          /* Set the DMA error callback */
;;;999          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1000   
;;;1001         /* Enable the DMA stream */
;;;1002         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
;;;1003         {
;;;1004           return HAL_ERROR;
;;;1005         }
;;;1006         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1007         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1008         break;
;;;1009       }
;;;1010   
;;;1011       case TIM_CHANNEL_4:
;;;1012       {
;;;1013         /* Set the DMA compare callbacks */
;;;1014         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1015         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1016   
;;;1017         /* Set the DMA error callback */
;;;1018         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1019   
;;;1020         /* Enable the DMA stream */
;;;1021         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
;;;1022         {
;;;1023           return HAL_ERROR;
;;;1024         }
;;;1025         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1026         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1027         break;
;;;1028       }
;;;1029   
;;;1030       default:
;;;1031         break;
;;;1032     }
;;;1033   
;;;1034     /* Enable the Output compare channel */
;;;1035     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1036   
;;;1037     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1038     {
;;;1039       /* Enable the main output */
;;;1040       __HAL_TIM_MOE_ENABLE(htim);
;;;1041     }
;;;1042   
;;;1043     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1044     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1045     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1046     {
;;;1047       __HAL_TIM_ENABLE(htim);
;;;1048     }
;;;1049   
;;;1050     /* Return function status */
;;;1051     return HAL_OK;
;;;1052   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L55.24|
000018  f894003d          LDRB     r0,[r4,#0x3d]         ;934
00001c  2801              CMP      r0,#1                 ;934
00001e  d105              BNE      |L55.44|
000020  b90d              CBNZ     r5,|L55.38|
000022  b107              CBZ      r7,|L55.38|
000024  e7f6              B        |L55.20|
                  |L55.38|
000026  2002              MOVS     r0,#2                 ;942
000028  f884003d          STRB     r0,[r4,#0x3d]         ;942
                  |L55.44|
00002c  b136              CBZ      r6,|L55.60|
00002e  2e04              CMP      r6,#4                 ;950
000030  d01f              BEQ      |L55.114|
000032  2e08              CMP      r6,#8                 ;950
000034  d038              BEQ      |L55.168|
000036  2e0c              CMP      r6,#0xc               ;950
000038  d16c              BNE      |L55.276|
00003a  e050              B        |L55.222|
                  |L55.60|
00003c  4947              LDR      r1,|L55.348|
00003e  6a60              LDR      r0,[r4,#0x24]         ;955
000040  63c1              STR      r1,[r0,#0x3c]         ;955
000042  4947              LDR      r1,|L55.352|
000044  6a60              LDR      r0,[r4,#0x24]         ;956
000046  6401              STR      r1,[r0,#0x40]         ;956
000048  4946              LDR      r1,|L55.356|
00004a  6a60              LDR      r0,[r4,#0x24]         ;959
00004c  64c1              STR      r1,[r0,#0x4c]         ;959
00004e  6821              LDR      r1,[r4,#0]            ;962
000050  f1010234          ADD      r2,r1,#0x34           ;962
000054  463b              MOV      r3,r7                 ;962
000056  4629              MOV      r1,r5                 ;962
000058  6a60              LDR      r0,[r4,#0x24]         ;962
00005a  f7fffffe          BL       HAL_DMA_Start_IT
00005e  b108              CBZ      r0,|L55.100|
000060  2001              MOVS     r0,#1                 ;964
000062  e7d7              B        |L55.20|
                  |L55.100|
000064  6820              LDR      r0,[r4,#0]            ;968
000066  68c0              LDR      r0,[r0,#0xc]          ;968
000068  f4407000          ORR      r0,r0,#0x200          ;968
00006c  6821              LDR      r1,[r4,#0]            ;968
00006e  60c8              STR      r0,[r1,#0xc]          ;968
000070  e051              B        |L55.278|
                  |L55.114|
000072  493a              LDR      r1,|L55.348|
000074  6aa0              LDR      r0,[r4,#0x28]         ;975
000076  63c1              STR      r1,[r0,#0x3c]         ;975
000078  4939              LDR      r1,|L55.352|
00007a  6aa0              LDR      r0,[r4,#0x28]         ;976
00007c  6401              STR      r1,[r0,#0x40]         ;976
00007e  4939              LDR      r1,|L55.356|
000080  6aa0              LDR      r0,[r4,#0x28]         ;979
000082  64c1              STR      r1,[r0,#0x4c]         ;979
000084  6821              LDR      r1,[r4,#0]            ;982
000086  f1010238          ADD      r2,r1,#0x38           ;982
00008a  463b              MOV      r3,r7                 ;982
00008c  4629              MOV      r1,r5                 ;982
00008e  6aa0              LDR      r0,[r4,#0x28]         ;982
000090  f7fffffe          BL       HAL_DMA_Start_IT
000094  b108              CBZ      r0,|L55.154|
000096  2001              MOVS     r0,#1                 ;984
000098  e7bc              B        |L55.20|
                  |L55.154|
00009a  6820              LDR      r0,[r4,#0]            ;988
00009c  68c0              LDR      r0,[r0,#0xc]          ;988
00009e  f4406080          ORR      r0,r0,#0x400          ;988
0000a2  6821              LDR      r1,[r4,#0]            ;988
0000a4  60c8              STR      r0,[r1,#0xc]          ;988
0000a6  e036              B        |L55.278|
                  |L55.168|
0000a8  492c              LDR      r1,|L55.348|
0000aa  6ae0              LDR      r0,[r4,#0x2c]         ;995
0000ac  63c1              STR      r1,[r0,#0x3c]         ;995
0000ae  492c              LDR      r1,|L55.352|
0000b0  6ae0              LDR      r0,[r4,#0x2c]         ;996
0000b2  6401              STR      r1,[r0,#0x40]         ;996
0000b4  492b              LDR      r1,|L55.356|
0000b6  6ae0              LDR      r0,[r4,#0x2c]         ;999
0000b8  64c1              STR      r1,[r0,#0x4c]         ;999
0000ba  6821              LDR      r1,[r4,#0]            ;1002
0000bc  f101023c          ADD      r2,r1,#0x3c           ;1002
0000c0  463b              MOV      r3,r7                 ;1002
0000c2  4629              MOV      r1,r5                 ;1002
0000c4  6ae0              LDR      r0,[r4,#0x2c]         ;1002
0000c6  f7fffffe          BL       HAL_DMA_Start_IT
0000ca  b108              CBZ      r0,|L55.208|
0000cc  2001              MOVS     r0,#1                 ;1004
0000ce  e7a1              B        |L55.20|
                  |L55.208|
0000d0  6820              LDR      r0,[r4,#0]            ;1007
0000d2  68c0              LDR      r0,[r0,#0xc]          ;1007
0000d4  f4406000          ORR      r0,r0,#0x800          ;1007
0000d8  6821              LDR      r1,[r4,#0]            ;1007
0000da  60c8              STR      r0,[r1,#0xc]          ;1007
0000dc  e01b              B        |L55.278|
                  |L55.222|
0000de  491f              LDR      r1,|L55.348|
0000e0  6b20              LDR      r0,[r4,#0x30]         ;1014
0000e2  63c1              STR      r1,[r0,#0x3c]         ;1014
0000e4  491e              LDR      r1,|L55.352|
0000e6  6b20              LDR      r0,[r4,#0x30]         ;1015
0000e8  6401              STR      r1,[r0,#0x40]         ;1015
0000ea  491e              LDR      r1,|L55.356|
0000ec  6b20              LDR      r0,[r4,#0x30]         ;1018
0000ee  64c1              STR      r1,[r0,#0x4c]         ;1018
0000f0  6821              LDR      r1,[r4,#0]            ;1021
0000f2  f1010240          ADD      r2,r1,#0x40           ;1021
0000f6  463b              MOV      r3,r7                 ;1021
0000f8  4629              MOV      r1,r5                 ;1021
0000fa  6b20              LDR      r0,[r4,#0x30]         ;1021
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  b108              CBZ      r0,|L55.262|
000102  2001              MOVS     r0,#1                 ;1023
000104  e786              B        |L55.20|
                  |L55.262|
000106  6820              LDR      r0,[r4,#0]            ;1026
000108  68c0              LDR      r0,[r0,#0xc]          ;1026
00010a  f4405080          ORR      r0,r0,#0x1000         ;1026
00010e  6821              LDR      r1,[r4,#0]            ;1026
000110  60c8              STR      r0,[r1,#0xc]          ;1026
000112  e000              B        |L55.278|
                  |L55.276|
000114  bf00              NOP                            ;1031
                  |L55.278|
000116  bf00              NOP                            ;969
000118  2201              MOVS     r2,#1                 ;1035
00011a  4631              MOV      r1,r6                 ;1035
00011c  6820              LDR      r0,[r4,#0]            ;1035
00011e  f7fffffe          BL       TIM_CCxChannelCmd
000122  4911              LDR      r1,|L55.360|
000124  6820              LDR      r0,[r4,#0]            ;1037
000126  4288              CMP      r0,r1                 ;1037
000128  d101              BNE      |L55.302|
00012a  2001              MOVS     r0,#1                 ;1037
00012c  e000              B        |L55.304|
                  |L55.302|
00012e  2000              MOVS     r0,#0                 ;1037
                  |L55.304|
000130  b128              CBZ      r0,|L55.318|
000132  6820              LDR      r0,[r4,#0]            ;1040
000134  6c40              LDR      r0,[r0,#0x44]         ;1040
000136  f4404000          ORR      r0,r0,#0x8000         ;1040
00013a  6821              LDR      r1,[r4,#0]            ;1040
00013c  6448              STR      r0,[r1,#0x44]         ;1040
                  |L55.318|
00013e  6820              LDR      r0,[r4,#0]            ;1044
000140  6880              LDR      r0,[r0,#8]            ;1044
000142  f0000807          AND      r8,r0,#7              ;1044
000146  f1b80f06          CMP      r8,#6                 ;1045
00014a  d005              BEQ      |L55.344|
00014c  6820              LDR      r0,[r4,#0]            ;1047
00014e  6800              LDR      r0,[r0,#0]            ;1047
000150  f0400001          ORR      r0,r0,#1              ;1047
000154  6821              LDR      r1,[r4,#0]            ;1047
000156  6008              STR      r0,[r1,#0]            ;1047
                  |L55.344|
000158  2000              MOVS     r0,#0                 ;1051
00015a  e75b              B        |L55.20|
;;;1053   
                          ENDP

                  |L55.348|
                          DCD      TIM_DMADelayPulseCplt
                  |L55.352|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L55.356|
                          DCD      TIM_DMAError
                  |L55.360|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;782      */
;;;783    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;784    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;785      uint32_t tmpsmcr;
;;;786    
;;;787      /* Check the parameters */
;;;788      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;789    
;;;790      switch (Channel)
000006  b135              CBZ      r5,|L56.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L56.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L56.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L56.78|
000014  e014              B        |L56.64|
                  |L56.22|
;;;791      {
;;;792        case TIM_CHANNEL_1:
;;;793        {
;;;794          /* Enable the TIM Capture/Compare 1 interrupt */
;;;795          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;796          break;
000022  e015              B        |L56.80|
                  |L56.36|
;;;797        }
;;;798    
;;;799        case TIM_CHANNEL_2:
;;;800        {
;;;801          /* Enable the TIM Capture/Compare 2 interrupt */
;;;802          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;803          break;
000030  e00e              B        |L56.80|
                  |L56.50|
;;;804        }
;;;805    
;;;806        case TIM_CHANNEL_3:
;;;807        {
;;;808          /* Enable the TIM Capture/Compare 3 interrupt */
;;;809          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;810          break;
00003e  e007              B        |L56.80|
                  |L56.64|
;;;811        }
;;;812    
;;;813        case TIM_CHANNEL_4:
;;;814        {
;;;815          /* Enable the TIM Capture/Compare 4 interrupt */
;;;816          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;817          break;
00004c  e000              B        |L56.80|
                  |L56.78|
;;;818        }
;;;819    
;;;820        default:
;;;821          break;
00004e  bf00              NOP      
                  |L56.80|
000050  bf00              NOP                            ;796
;;;822      }
;;;823    
;;;824      /* Enable the Output compare channel */
;;;825      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;826    
;;;827      if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005c  490d              LDR      r1,|L56.148|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d101              BNE      |L56.104|
000064  2001              MOVS     r0,#1
000066  e000              B        |L56.106|
                  |L56.104|
000068  2000              MOVS     r0,#0
                  |L56.106|
00006a  b128              CBZ      r0,|L56.120|
;;;828      {
;;;829        /* Enable the main output */
;;;830        __HAL_TIM_MOE_ENABLE(htim);
00006c  6820              LDR      r0,[r4,#0]
00006e  6c40              LDR      r0,[r0,#0x44]
000070  f4404000          ORR      r0,r0,#0x8000
000074  6821              LDR      r1,[r4,#0]
000076  6448              STR      r0,[r1,#0x44]
                  |L56.120|
;;;831      }
;;;832    
;;;833      /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;834      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
000078  6820              LDR      r0,[r4,#0]
00007a  6880              LDR      r0,[r0,#8]
00007c  f0000607          AND      r6,r0,#7
;;;835      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000080  2e06              CMP      r6,#6
000082  d005              BEQ      |L56.144|
;;;836      {
;;;837        __HAL_TIM_ENABLE(htim);
000084  6820              LDR      r0,[r4,#0]
000086  6800              LDR      r0,[r0,#0]
000088  f0400001          ORR      r0,r0,#1
00008c  6821              LDR      r1,[r4,#0]
00008e  6008              STR      r0,[r1,#0]
                  |L56.144|
;;;838      }
;;;839    
;;;840      /* Return function status */
;;;841      return HAL_OK;
000090  2000              MOVS     r0,#0
;;;842    }
000092  bd70              POP      {r4-r6,pc}
;;;843    
                          ENDP

                  |L56.148|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;750      */
;;;751    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;752    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;753      /* Check the parameters */
;;;754      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;755    
;;;756      /* Disable the Output compare channel */
;;;757      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;758    
;;;759      if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  4917              LDR      r1,|L57.112|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d101              BNE      |L57.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L57.30|
                  |L57.28|
00001c  2000              MOVS     r0,#0
                  |L57.30|
00001e  b190              CBZ      r0,|L57.70|
;;;760      {
;;;761        /* Disable the Main Output */
;;;762        __HAL_TIM_MOE_DISABLE(htim);
000020  bf00              NOP      
000022  6820              LDR      r0,[r4,#0]
000024  6a00              LDR      r0,[r0,#0x20]
000026  f2411111          MOV      r1,#0x1111
00002a  4008              ANDS     r0,r0,r1
00002c  b950              CBNZ     r0,|L57.68|
00002e  6820              LDR      r0,[r4,#0]
000030  6a00              LDR      r0,[r0,#0x20]
000032  1089              ASRS     r1,r1,#2
000034  4008              ANDS     r0,r0,r1
000036  b928              CBNZ     r0,|L57.68|
000038  6820              LDR      r0,[r4,#0]
00003a  6c40              LDR      r0,[r0,#0x44]
00003c  f4204000          BIC      r0,r0,#0x8000
000040  6821              LDR      r1,[r4,#0]
000042  6448              STR      r0,[r1,#0x44]
                  |L57.68|
000044  bf00              NOP      
                  |L57.70|
;;;763      }
;;;764    
;;;765      /* Disable the Peripheral */
;;;766      __HAL_TIM_DISABLE(htim);
000046  bf00              NOP      
000048  6820              LDR      r0,[r4,#0]
00004a  6a00              LDR      r0,[r0,#0x20]
00004c  f2411111          MOV      r1,#0x1111
000050  4008              ANDS     r0,r0,r1
000052  b950              CBNZ     r0,|L57.106|
000054  6820              LDR      r0,[r4,#0]
000056  6a00              LDR      r0,[r0,#0x20]
000058  1089              ASRS     r1,r1,#2
00005a  4008              ANDS     r0,r0,r1
00005c  b928              CBNZ     r0,|L57.106|
00005e  6820              LDR      r0,[r4,#0]
000060  6800              LDR      r0,[r0,#0]
000062  f0200001          BIC      r0,r0,#1
000066  6821              LDR      r1,[r4,#0]
000068  6008              STR      r0,[r1,#0]
                  |L57.106|
00006a  bf00              NOP      
;;;767    
;;;768      /* Return function status */
;;;769      return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;770    }
00006e  bd30              POP      {r4,r5,pc}
;;;771    
                          ENDP

                  |L57.112|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;1064     */
;;;1065   HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1066   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1067     /* Check the parameters */
;;;1068     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1069   
;;;1070     switch (Channel)
000006  b135              CBZ      r5,|L58.22|
000008  2d04              CMP      r5,#4
00000a  d00e              BEQ      |L58.42|
00000c  2d08              CMP      r5,#8
00000e  d016              BEQ      |L58.62|
000010  2d0c              CMP      r5,#0xc
000012  d128              BNE      |L58.102|
000014  e01d              B        |L58.82|
                  |L58.22|
;;;1071     {
;;;1072       case TIM_CHANNEL_1:
;;;1073       {
;;;1074         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1075         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1076         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000022  6a60              LDR      r0,[r4,#0x24]
000024  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1077         break;
000028  e01e              B        |L58.104|
                  |L58.42|
;;;1078       }
;;;1079   
;;;1080       case TIM_CHANNEL_2:
;;;1081       {
;;;1082         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1083         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  f4206080          BIC      r0,r0,#0x400
000032  6821              LDR      r1,[r4,#0]
000034  60c8              STR      r0,[r1,#0xc]
;;;1084         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000036  6aa0              LDR      r0,[r4,#0x28]
000038  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1085         break;
00003c  e014              B        |L58.104|
                  |L58.62|
;;;1086       }
;;;1087   
;;;1088       case TIM_CHANNEL_3:
;;;1089       {
;;;1090         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1091         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00003e  6820              LDR      r0,[r4,#0]
000040  68c0              LDR      r0,[r0,#0xc]
000042  f4206000          BIC      r0,r0,#0x800
000046  6821              LDR      r1,[r4,#0]
000048  60c8              STR      r0,[r1,#0xc]
;;;1092         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
00004a  6ae0              LDR      r0,[r4,#0x2c]
00004c  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1093         break;
000050  e00a              B        |L58.104|
                  |L58.82|
;;;1094       }
;;;1095   
;;;1096       case TIM_CHANNEL_4:
;;;1097       {
;;;1098         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1099         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000052  6820              LDR      r0,[r4,#0]
000054  68c0              LDR      r0,[r0,#0xc]
000056  f4205080          BIC      r0,r0,#0x1000
00005a  6821              LDR      r1,[r4,#0]
00005c  60c8              STR      r0,[r1,#0xc]
;;;1100         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
00005e  6b20              LDR      r0,[r4,#0x30]
000060  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1101         break;
000064  e000              B        |L58.104|
                  |L58.102|
;;;1102       }
;;;1103   
;;;1104       default:
;;;1105         break;
000066  bf00              NOP      
                  |L58.104|
000068  bf00              NOP                            ;1077
;;;1106     }
;;;1107   
;;;1108     /* Disable the Output compare channel */
;;;1109     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00006a  2200              MOVS     r2,#0
00006c  4629              MOV      r1,r5
00006e  6820              LDR      r0,[r4,#0]
000070  f7fffffe          BL       TIM_CCxChannelCmd
;;;1110   
;;;1111     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000074  4919              LDR      r1,|L58.220|
000076  6820              LDR      r0,[r4,#0]
000078  4288              CMP      r0,r1
00007a  d101              BNE      |L58.128|
00007c  2001              MOVS     r0,#1
00007e  e000              B        |L58.130|
                  |L58.128|
000080  2000              MOVS     r0,#0
                  |L58.130|
000082  b190              CBZ      r0,|L58.170|
;;;1112     {
;;;1113       /* Disable the Main Output */
;;;1114       __HAL_TIM_MOE_DISABLE(htim);
000084  bf00              NOP      
000086  6820              LDR      r0,[r4,#0]
000088  6a00              LDR      r0,[r0,#0x20]
00008a  f2411111          MOV      r1,#0x1111
00008e  4008              ANDS     r0,r0,r1
000090  b950              CBNZ     r0,|L58.168|
000092  6820              LDR      r0,[r4,#0]
000094  6a00              LDR      r0,[r0,#0x20]
000096  1089              ASRS     r1,r1,#2
000098  4008              ANDS     r0,r0,r1
00009a  b928              CBNZ     r0,|L58.168|
00009c  6820              LDR      r0,[r4,#0]
00009e  6c40              LDR      r0,[r0,#0x44]
0000a0  f4204000          BIC      r0,r0,#0x8000
0000a4  6821              LDR      r1,[r4,#0]
0000a6  6448              STR      r0,[r1,#0x44]
                  |L58.168|
0000a8  bf00              NOP      
                  |L58.170|
;;;1115     }
;;;1116   
;;;1117     /* Disable the Peripheral */
;;;1118     __HAL_TIM_DISABLE(htim);
0000aa  bf00              NOP      
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6a00              LDR      r0,[r0,#0x20]
0000b0  f2411111          MOV      r1,#0x1111
0000b4  4008              ANDS     r0,r0,r1
0000b6  b950              CBNZ     r0,|L58.206|
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6a00              LDR      r0,[r0,#0x20]
0000bc  1089              ASRS     r1,r1,#2
0000be  4008              ANDS     r0,r0,r1
0000c0  b928              CBNZ     r0,|L58.206|
0000c2  6820              LDR      r0,[r4,#0]
0000c4  6800              LDR      r0,[r0,#0]
0000c6  f0200001          BIC      r0,r0,#1
0000ca  6821              LDR      r1,[r4,#0]
0000cc  6008              STR      r0,[r1,#0]
                  |L58.206|
0000ce  bf00              NOP      
;;;1119   
;;;1120     /* Change the htim state */
;;;1121     htim->State = HAL_TIM_STATE_READY;
0000d0  2001              MOVS     r0,#1
0000d2  f884003d          STRB     r0,[r4,#0x3d]
;;;1122   
;;;1123     /* Return function status */
;;;1124     return HAL_OK;
0000d6  2000              MOVS     r0,#0
;;;1125   }
0000d8  bd70              POP      {r4-r6,pc}
;;;1126   
                          ENDP

0000da  0000              DCW      0x0000
                  |L58.220|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;854      */
;;;855    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;856    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;857      /* Check the parameters */
;;;858      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;859    
;;;860      switch (Channel)
000006  b135              CBZ      r5,|L59.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L59.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L59.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L59.78|
000014  e014              B        |L59.64|
                  |L59.22|
;;;861      {
;;;862        case TIM_CHANNEL_1:
;;;863        {
;;;864          /* Disable the TIM Capture/Compare 1 interrupt */
;;;865          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;866          break;
000022  e015              B        |L59.80|
                  |L59.36|
;;;867        }
;;;868    
;;;869        case TIM_CHANNEL_2:
;;;870        {
;;;871          /* Disable the TIM Capture/Compare 2 interrupt */
;;;872          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;873          break;
000030  e00e              B        |L59.80|
                  |L59.50|
;;;874        }
;;;875    
;;;876        case TIM_CHANNEL_3:
;;;877        {
;;;878          /* Disable the TIM Capture/Compare 3 interrupt */
;;;879          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;880          break;
00003e  e007              B        |L59.80|
                  |L59.64|
;;;881        }
;;;882    
;;;883        case TIM_CHANNEL_4:
;;;884        {
;;;885          /* Disable the TIM Capture/Compare 4 interrupt */
;;;886          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;887          break;
00004c  e000              B        |L59.80|
                  |L59.78|
;;;888        }
;;;889    
;;;890        default:
;;;891          break;
00004e  bf00              NOP      
                  |L59.80|
000050  bf00              NOP                            ;866
;;;892      }
;;;893    
;;;894      /* Disable the Output compare channel */
;;;895      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;896    
;;;897      if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005c  4917              LDR      r1,|L59.188|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d101              BNE      |L59.104|
000064  2001              MOVS     r0,#1
000066  e000              B        |L59.106|
                  |L59.104|
000068  2000              MOVS     r0,#0
                  |L59.106|
00006a  b190              CBZ      r0,|L59.146|
;;;898      {
;;;899        /* Disable the Main Output */
;;;900        __HAL_TIM_MOE_DISABLE(htim);
00006c  bf00              NOP      
00006e  6820              LDR      r0,[r4,#0]
000070  6a00              LDR      r0,[r0,#0x20]
000072  f2411111          MOV      r1,#0x1111
000076  4008              ANDS     r0,r0,r1
000078  b950              CBNZ     r0,|L59.144|
00007a  6820              LDR      r0,[r4,#0]
00007c  6a00              LDR      r0,[r0,#0x20]
00007e  1089              ASRS     r1,r1,#2
000080  4008              ANDS     r0,r0,r1
000082  b928              CBNZ     r0,|L59.144|
000084  6820              LDR      r0,[r4,#0]
000086  6c40              LDR      r0,[r0,#0x44]
000088  f4204000          BIC      r0,r0,#0x8000
00008c  6821              LDR      r1,[r4,#0]
00008e  6448              STR      r0,[r1,#0x44]
                  |L59.144|
000090  bf00              NOP      
                  |L59.146|
;;;901      }
;;;902    
;;;903      /* Disable the Peripheral */
;;;904      __HAL_TIM_DISABLE(htim);
000092  bf00              NOP      
000094  6820              LDR      r0,[r4,#0]
000096  6a00              LDR      r0,[r0,#0x20]
000098  f2411111          MOV      r1,#0x1111
00009c  4008              ANDS     r0,r0,r1
00009e  b950              CBNZ     r0,|L59.182|
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6a00              LDR      r0,[r0,#0x20]
0000a4  1089              ASRS     r1,r1,#2
0000a6  4008              ANDS     r0,r0,r1
0000a8  b928              CBNZ     r0,|L59.182|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6800              LDR      r0,[r0,#0]
0000ae  f0200001          BIC      r0,r0,#1
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6008              STR      r0,[r1,#0]
                  |L59.182|
0000b6  bf00              NOP      
;;;905    
;;;906      /* Return function status */
;;;907      return HAL_OK;
0000b8  2000              MOVS     r0,#0
;;;908    }
0000ba  bd30              POP      {r4,r5,pc}
;;;909    
                          ENDP

                  |L59.188|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3660     */
;;;3661   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3662   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3663     TIM_OC_InitTypeDef temp1;
;;;3664   
;;;3665     /* Check the parameters */
;;;3666     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3667     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3668   
;;;3669     if (OutputChannel != InputChannel)
00000c  42be              CMP      r6,r7
00000e  d078              BEQ      |L60.258|
;;;3670     {
;;;3671       /* Process Locked */
;;;3672       __HAL_LOCK(htim);
000010  bf00              NOP      
000012  f894003c          LDRB     r0,[r4,#0x3c]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L60.32|
00001a  2002              MOVS     r0,#2
                  |L60.28|
;;;3673   
;;;3674       htim->State = HAL_TIM_STATE_BUSY;
;;;3675   
;;;3676       /* Extract the Output compare configuration from sConfig structure */
;;;3677       temp1.OCMode = sConfig->OCMode;
;;;3678       temp1.Pulse = sConfig->Pulse;
;;;3679       temp1.OCPolarity = sConfig->OCPolarity;
;;;3680       temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3681       temp1.OCIdleState = sConfig->OCIdleState;
;;;3682       temp1.OCNIdleState = sConfig->OCNIdleState;
;;;3683   
;;;3684       switch (OutputChannel)
;;;3685       {
;;;3686         case TIM_CHANNEL_1:
;;;3687         {
;;;3688           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3689   
;;;3690           TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;3691           break;
;;;3692         }
;;;3693         case TIM_CHANNEL_2:
;;;3694         {
;;;3695           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3696   
;;;3697           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3698           break;
;;;3699         }
;;;3700         default:
;;;3701           break;
;;;3702       }
;;;3703   
;;;3704       switch (InputChannel)
;;;3705       {
;;;3706         case TIM_CHANNEL_1:
;;;3707         {
;;;3708           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3709   
;;;3710           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3711                             sConfig->ICSelection, sConfig->ICFilter);
;;;3712   
;;;3713           /* Reset the IC1PSC Bits */
;;;3714           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3715   
;;;3716           /* Select the Trigger source */
;;;3717           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3718           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3719   
;;;3720           /* Select the Slave Mode */
;;;3721           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3722           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3723           break;
;;;3724         }
;;;3725         case TIM_CHANNEL_2:
;;;3726         {
;;;3727           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3728   
;;;3729           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3730                             sConfig->ICSelection, sConfig->ICFilter);
;;;3731   
;;;3732           /* Reset the IC2PSC Bits */
;;;3733           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3734   
;;;3735           /* Select the Trigger source */
;;;3736           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3737           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3738   
;;;3739           /* Select the Slave Mode */
;;;3740           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3741           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3742           break;
;;;3743         }
;;;3744   
;;;3745         default:
;;;3746           break;
;;;3747       }
;;;3748   
;;;3749       htim->State = HAL_TIM_STATE_READY;
;;;3750   
;;;3751       __HAL_UNLOCK(htim);
;;;3752   
;;;3753       return HAL_OK;
;;;3754     }
;;;3755     else
;;;3756     {
;;;3757       return HAL_ERROR;
;;;3758     }
;;;3759   }
00001c  b007              ADD      sp,sp,#0x1c
00001e  bdf0              POP      {r4-r7,pc}
                  |L60.32|
000020  2001              MOVS     r0,#1                 ;3672
000022  f884003c          STRB     r0,[r4,#0x3c]         ;3672
000026  bf00              NOP                            ;3672
000028  2002              MOVS     r0,#2                 ;3674
00002a  f884003d          STRB     r0,[r4,#0x3d]         ;3674
00002e  6828              LDR      r0,[r5,#0]            ;3677
000030  9000              STR      r0,[sp,#0]            ;3677
000032  6868              LDR      r0,[r5,#4]            ;3678
000034  9001              STR      r0,[sp,#4]            ;3678
000036  68a8              LDR      r0,[r5,#8]            ;3679
000038  9002              STR      r0,[sp,#8]            ;3679
00003a  68e8              LDR      r0,[r5,#0xc]          ;3680
00003c  9003              STR      r0,[sp,#0xc]          ;3680
00003e  6928              LDR      r0,[r5,#0x10]         ;3681
000040  9005              STR      r0,[sp,#0x14]         ;3681
000042  6968              LDR      r0,[r5,#0x14]         ;3682
000044  9006              STR      r0,[sp,#0x18]         ;3682
000046  b116              CBZ      r6,|L60.78|
000048  2e04              CMP      r6,#4                 ;3684
00004a  d10a              BNE      |L60.98|
00004c  e004              B        |L60.88|
                  |L60.78|
00004e  4669              MOV      r1,sp                 ;3690
000050  6820              LDR      r0,[r4,#0]            ;3690
000052  f7fffffe          BL       TIM_OC1_SetConfig
000056  e005              B        |L60.100|
                  |L60.88|
000058  4669              MOV      r1,sp                 ;3697
00005a  6820              LDR      r0,[r4,#0]            ;3697
00005c  f7fffffe          BL       TIM_OC2_SetConfig
000060  e000              B        |L60.100|
                  |L60.98|
000062  bf00              NOP                            ;3701
                  |L60.100|
000064  bf00              NOP                            ;3691
000066  b117              CBZ      r7,|L60.110|
000068  2f04              CMP      r7,#4                 ;3704
00006a  d14b              BNE      |L60.260|
00006c  e024              B        |L60.184|
                  |L60.110|
00006e  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3710
000072  69a9              LDR      r1,[r5,#0x18]         ;3710
000074  6820              LDR      r0,[r4,#0]            ;3710
000076  f7fffffe          BL       TIM_TI1_SetConfig
00007a  6820              LDR      r0,[r4,#0]            ;3714
00007c  6980              LDR      r0,[r0,#0x18]         ;3714
00007e  f020000c          BIC      r0,r0,#0xc            ;3714
000082  6821              LDR      r1,[r4,#0]            ;3714
000084  6188              STR      r0,[r1,#0x18]         ;3714
000086  6820              LDR      r0,[r4,#0]            ;3717
000088  6880              LDR      r0,[r0,#8]            ;3717
00008a  f0200070          BIC      r0,r0,#0x70           ;3717
00008e  6821              LDR      r1,[r4,#0]            ;3717
000090  6088              STR      r0,[r1,#8]            ;3717
000092  6820              LDR      r0,[r4,#0]            ;3718
000094  6880              LDR      r0,[r0,#8]            ;3718
000096  f0400050          ORR      r0,r0,#0x50           ;3718
00009a  6821              LDR      r1,[r4,#0]            ;3718
00009c  6088              STR      r0,[r1,#8]            ;3718
00009e  6820              LDR      r0,[r4,#0]            ;3721
0000a0  6880              LDR      r0,[r0,#8]            ;3721
0000a2  f0200007          BIC      r0,r0,#7              ;3721
0000a6  6821              LDR      r1,[r4,#0]            ;3721
0000a8  6088              STR      r0,[r1,#8]            ;3721
0000aa  6820              LDR      r0,[r4,#0]            ;3722
0000ac  6880              LDR      r0,[r0,#8]            ;3722
0000ae  f0400006          ORR      r0,r0,#6              ;3722
0000b2  6821              LDR      r1,[r4,#0]            ;3722
0000b4  6088              STR      r0,[r1,#8]            ;3722
0000b6  e026              B        |L60.262|
                  |L60.184|
0000b8  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3729
0000bc  69a9              LDR      r1,[r5,#0x18]         ;3729
0000be  6820              LDR      r0,[r4,#0]            ;3729
0000c0  f7fffffe          BL       TIM_TI2_SetConfig
0000c4  6820              LDR      r0,[r4,#0]            ;3733
0000c6  6980              LDR      r0,[r0,#0x18]         ;3733
0000c8  f4206040          BIC      r0,r0,#0xc00          ;3733
0000cc  6821              LDR      r1,[r4,#0]            ;3733
0000ce  6188              STR      r0,[r1,#0x18]         ;3733
0000d0  6820              LDR      r0,[r4,#0]            ;3736
0000d2  6880              LDR      r0,[r0,#8]            ;3736
0000d4  f0200070          BIC      r0,r0,#0x70           ;3736
0000d8  6821              LDR      r1,[r4,#0]            ;3736
0000da  6088              STR      r0,[r1,#8]            ;3736
0000dc  6820              LDR      r0,[r4,#0]            ;3737
0000de  6880              LDR      r0,[r0,#8]            ;3737
0000e0  f0400060          ORR      r0,r0,#0x60           ;3737
0000e4  6821              LDR      r1,[r4,#0]            ;3737
0000e6  6088              STR      r0,[r1,#8]            ;3737
0000e8  6820              LDR      r0,[r4,#0]            ;3740
0000ea  6880              LDR      r0,[r0,#8]            ;3740
0000ec  f0200007          BIC      r0,r0,#7              ;3740
0000f0  6821              LDR      r1,[r4,#0]            ;3740
0000f2  6088              STR      r0,[r1,#8]            ;3740
0000f4  6820              LDR      r0,[r4,#0]            ;3741
0000f6  6880              LDR      r0,[r0,#8]            ;3741
0000f8  f0400006          ORR      r0,r0,#6              ;3741
0000fc  6821              LDR      r1,[r4,#0]            ;3741
0000fe  6088              STR      r0,[r1,#8]            ;3741
000100  e001              B        |L60.262|
                  |L60.258|
000102  e00a              B        |L60.282|
                  |L60.260|
000104  bf00              NOP                            ;3746
                  |L60.262|
000106  bf00              NOP                            ;3723
000108  2001              MOVS     r0,#1                 ;3749
00010a  f884003d          STRB     r0,[r4,#0x3d]         ;3749
00010e  bf00              NOP                            ;3751
000110  2000              MOVS     r0,#0                 ;3751
000112  f884003c          STRB     r0,[r4,#0x3c]         ;3751
000116  bf00              NOP                            ;3751
000118  e780              B        |L60.28|
                  |L60.282|
00011a  2001              MOVS     r0,#1                 ;3757
00011c  e77e              B        |L60.28|
;;;3760   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2333     */
;;;2334   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2335   {
000002  4604              MOV      r4,r0
;;;2336     /* Check the parameters */
;;;2337     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2338   
;;;2339     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;2340   
;;;2341     /* Disable the TIM Peripheral Clock */
;;;2342     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L61.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L61.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L61.46|
00002e  bf00              NOP      
;;;2343   
;;;2344   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2345     if (htim->OnePulse_MspDeInitCallback == NULL)
;;;2346     {
;;;2347       htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
;;;2348     }
;;;2349     /* DeInit the low level hardware */
;;;2350     htim->OnePulse_MspDeInitCallback(htim);
;;;2351   #else
;;;2352     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2353     HAL_TIM_OnePulse_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2354   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2355   
;;;2356     /* Change TIM state */
;;;2357     htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f884003d          STRB     r0,[r4,#0x3d]
;;;2358   
;;;2359     /* Release Lock */
;;;2360     __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;2361   
;;;2362     return HAL_OK;
;;;2363   }
000044  bd10              POP      {r4,pc}
;;;2364   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;5502     */
;;;5503   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5504   {
;;;5505     return htim->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;5506   }
000006  4770              BX       lr
;;;5507   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;2274     */
;;;2275   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2276   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2277     /* Check the TIM handle allocation */
;;;2278     if (htim == NULL)
000006  b90c              CBNZ     r4,|L63.12|
;;;2279     {
;;;2280       return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L63.10|
;;;2281     }
;;;2282   
;;;2283     /* Check the parameters */
;;;2284     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2285     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2286     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2287     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;2288     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2289   
;;;2290     if (htim->State == HAL_TIM_STATE_RESET)
;;;2291     {
;;;2292       /* Allocate lock resource and initialize it */
;;;2293       htim->Lock = HAL_UNLOCKED;
;;;2294   
;;;2295   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2296       /* Reset interrupt callbacks to legacy weak callbacks */
;;;2297       TIM_ResetCallback(htim);
;;;2298   
;;;2299       if (htim->OnePulse_MspInitCallback == NULL)
;;;2300       {
;;;2301         htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
;;;2302       }
;;;2303       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2304       htim->OnePulse_MspInitCallback(htim);
;;;2305   #else
;;;2306       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2307       HAL_TIM_OnePulse_MspInit(htim);
;;;2308   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2309     }
;;;2310   
;;;2311     /* Set the TIM state */
;;;2312     htim->State = HAL_TIM_STATE_BUSY;
;;;2313   
;;;2314     /* Configure the Time base in the One Pulse Mode */
;;;2315     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2316   
;;;2317     /* Reset the OPM Bit */
;;;2318     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2319   
;;;2320     /* Configure the OPM Mode */
;;;2321     htim->Instance->CR1 |= OnePulseMode;
;;;2322   
;;;2323     /* Initialize the TIM state*/
;;;2324     htim->State = HAL_TIM_STATE_READY;
;;;2325   
;;;2326     return HAL_OK;
;;;2327   }
00000a  bd70              POP      {r4-r6,pc}
                  |L63.12|
00000c  f894003d          LDRB     r0,[r4,#0x3d]         ;2290
000010  b928              CBNZ     r0,|L63.30|
000012  2000              MOVS     r0,#0                 ;2293
000014  f884003c          STRB     r0,[r4,#0x3c]         ;2293
000018  4620              MOV      r0,r4                 ;2307
00001a  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L63.30|
00001e  2002              MOVS     r0,#2                 ;2312
000020  f884003d          STRB     r0,[r4,#0x3d]         ;2312
000024  1d21              ADDS     r1,r4,#4              ;2315
000026  6820              LDR      r0,[r4,#0]            ;2315
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  6820              LDR      r0,[r4,#0]            ;2318
00002e  6800              LDR      r0,[r0,#0]            ;2318
000030  f0200008          BIC      r0,r0,#8              ;2318
000034  6821              LDR      r1,[r4,#0]            ;2318
000036  6008              STR      r0,[r1,#0]            ;2318
000038  6820              LDR      r0,[r4,#0]            ;2321
00003a  6800              LDR      r0,[r0,#0]            ;2321
00003c  4328              ORRS     r0,r0,r5              ;2321
00003e  6821              LDR      r1,[r4,#0]            ;2321
000040  6008              STR      r0,[r1,#0]            ;2321
000042  2001              MOVS     r0,#1                 ;2324
000044  f884003d          STRB     r0,[r4,#0x3d]         ;2324
000048  2000              MOVS     r0,#0                 ;2326
00004a  e7de              B        |L63.10|
;;;2328   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2384     */
;;;2385   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2386   {
;;;2387     /* Prevent unused argument(s) compilation warning */
;;;2388     UNUSED(htim);
;;;2389   
;;;2390     /* NOTE : This function should not be modified, when the callback is needed,
;;;2391               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2392      */
;;;2393   }
;;;2394   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2369     */
;;;2370   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2371   {
;;;2372     /* Prevent unused argument(s) compilation warning */
;;;2373     UNUSED(htim);
;;;2374   
;;;2375     /* NOTE : This function should not be modified, when the callback is needed,
;;;2376               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2377      */
;;;2378   }
;;;2379   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2403     */
;;;2404   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2405   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2406     /* Prevent unused argument(s) compilation warning */
;;;2407     UNUSED(OutputChannel);
;;;2408   
;;;2409     /* Enable the Capture compare and the Input Capture channels
;;;2410       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2411       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2412       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
;;;2413       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
;;;2414   
;;;2415       No need to enable the counter, it's enabled automatically by hardware
;;;2416       (the counter starts in response to a stimulus and generate a pulse */
;;;2417   
;;;2418     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2419     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000010  2201              MOVS     r2,#1
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2420   
;;;2421     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00001a  4908              LDR      r1,|L66.60|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d101              BNE      |L66.38|
000022  2001              MOVS     r0,#1
000024  e000              B        |L66.40|
                  |L66.38|
000026  2000              MOVS     r0,#0
                  |L66.40|
000028  b128              CBZ      r0,|L66.54|
;;;2422     {
;;;2423       /* Enable the main output */
;;;2424       __HAL_TIM_MOE_ENABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6c40              LDR      r0,[r0,#0x44]
00002e  f4404000          ORR      r0,r0,#0x8000
000032  6821              LDR      r1,[r4,#0]
000034  6448              STR      r0,[r1,#0x44]
                  |L66.54|
;;;2425     }
;;;2426   
;;;2427     /* Return function status */
;;;2428     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;2429   }
000038  bd30              POP      {r4,r5,pc}
;;;2430   
                          ENDP

00003a  0000              DCW      0x0000
                  |L66.60|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2475     */
;;;2476   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2477   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2478     /* Prevent unused argument(s) compilation warning */
;;;2479     UNUSED(OutputChannel);
;;;2480   
;;;2481     /* Enable the Capture compare and the Input Capture channels
;;;2482       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2483       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2484       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
;;;2485       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
;;;2486   
;;;2487       No need to enable the counter, it's enabled automatically by hardware
;;;2488       (the counter starts in response to a stimulus and generate a pulse */
;;;2489   
;;;2490     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2491     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0400002          ORR      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2492   
;;;2493     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2494     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0400004          ORR      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2495   
;;;2496     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00001e  2201              MOVS     r2,#1
000020  2100              MOVS     r1,#0
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2497     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000028  2201              MOVS     r2,#1
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2498   
;;;2499     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000032  4908              LDR      r1,|L67.84|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d101              BNE      |L67.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L67.64|
                  |L67.62|
00003e  2000              MOVS     r0,#0
                  |L67.64|
000040  b128              CBZ      r0,|L67.78|
;;;2500     {
;;;2501       /* Enable the main output */
;;;2502       __HAL_TIM_MOE_ENABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6c40              LDR      r0,[r0,#0x44]
000046  f4404000          ORR      r0,r0,#0x8000
00004a  6821              LDR      r1,[r4,#0]
00004c  6448              STR      r0,[r1,#0x44]
                  |L67.78|
;;;2503     }
;;;2504   
;;;2505     /* Return function status */
;;;2506     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;2507   }
000050  bd30              POP      {r4,r5,pc}
;;;2508   
                          ENDP

000052  0000              DCW      0x0000
                  |L67.84|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2439     */
;;;2440   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2441   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2442     /* Prevent unused argument(s) compilation warning */
;;;2443     UNUSED(OutputChannel);
;;;2444   
;;;2445     /* Disable the Capture compare and the Input Capture channels
;;;2446     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2447     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2448     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
;;;2449     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2450   
;;;2451     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2452     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000010  2200              MOVS     r2,#0
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2453   
;;;2454     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00001a  4918              LDR      r1,|L68.124|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d101              BNE      |L68.38|
000022  2001              MOVS     r0,#1
000024  e000              B        |L68.40|
                  |L68.38|
000026  2000              MOVS     r0,#0
                  |L68.40|
000028  b190              CBZ      r0,|L68.80|
;;;2455     {
;;;2456       /* Disable the Main Output */
;;;2457       __HAL_TIM_MOE_DISABLE(htim);
00002a  bf00              NOP      
00002c  6820              LDR      r0,[r4,#0]
00002e  6a00              LDR      r0,[r0,#0x20]
000030  f2411111          MOV      r1,#0x1111
000034  4008              ANDS     r0,r0,r1
000036  b950              CBNZ     r0,|L68.78|
000038  6820              LDR      r0,[r4,#0]
00003a  6a00              LDR      r0,[r0,#0x20]
00003c  1089              ASRS     r1,r1,#2
00003e  4008              ANDS     r0,r0,r1
000040  b928              CBNZ     r0,|L68.78|
000042  6820              LDR      r0,[r4,#0]
000044  6c40              LDR      r0,[r0,#0x44]
000046  f4204000          BIC      r0,r0,#0x8000
00004a  6821              LDR      r1,[r4,#0]
00004c  6448              STR      r0,[r1,#0x44]
                  |L68.78|
00004e  bf00              NOP      
                  |L68.80|
;;;2458     }
;;;2459   
;;;2460     /* Disable the Peripheral */
;;;2461     __HAL_TIM_DISABLE(htim);
000050  bf00              NOP      
000052  6820              LDR      r0,[r4,#0]
000054  6a00              LDR      r0,[r0,#0x20]
000056  f2411111          MOV      r1,#0x1111
00005a  4008              ANDS     r0,r0,r1
00005c  b950              CBNZ     r0,|L68.116|
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  1089              ASRS     r1,r1,#2
000064  4008              ANDS     r0,r0,r1
000066  b928              CBNZ     r0,|L68.116|
000068  6820              LDR      r0,[r4,#0]
00006a  6800              LDR      r0,[r0,#0]
00006c  f0200001          BIC      r0,r0,#1
000070  6821              LDR      r1,[r4,#0]
000072  6008              STR      r0,[r1,#0]
                  |L68.116|
000074  bf00              NOP      
;;;2462   
;;;2463     /* Return function status */
;;;2464     return HAL_OK;
000076  2000              MOVS     r0,#0
;;;2465   }
000078  bd30              POP      {r4,r5,pc}
;;;2466   
                          ENDP

00007a  0000              DCW      0x0000
                  |L68.124|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2517     */
;;;2518   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2519   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2520     /* Prevent unused argument(s) compilation warning */
;;;2521     UNUSED(OutputChannel);
;;;2522   
;;;2523     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2524     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0200002          BIC      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2525   
;;;2526     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2527     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200004          BIC      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2528   
;;;2529     /* Disable the Capture compare and the Input Capture channels
;;;2530     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2531     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2532     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
;;;2533     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2534     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00001e  2200              MOVS     r2,#0
000020  4611              MOV      r1,r2
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2535     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000028  2200              MOVS     r2,#0
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2536   
;;;2537     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000032  4918              LDR      r1,|L69.148|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d101              BNE      |L69.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L69.64|
                  |L69.62|
00003e  2000              MOVS     r0,#0
                  |L69.64|
000040  b190              CBZ      r0,|L69.104|
;;;2538     {
;;;2539       /* Disable the Main Output */
;;;2540       __HAL_TIM_MOE_DISABLE(htim);
000042  bf00              NOP      
000044  6820              LDR      r0,[r4,#0]
000046  6a00              LDR      r0,[r0,#0x20]
000048  f2411111          MOV      r1,#0x1111
00004c  4008              ANDS     r0,r0,r1
00004e  b950              CBNZ     r0,|L69.102|
000050  6820              LDR      r0,[r4,#0]
000052  6a00              LDR      r0,[r0,#0x20]
000054  1089              ASRS     r1,r1,#2
000056  4008              ANDS     r0,r0,r1
000058  b928              CBNZ     r0,|L69.102|
00005a  6820              LDR      r0,[r4,#0]
00005c  6c40              LDR      r0,[r0,#0x44]
00005e  f4204000          BIC      r0,r0,#0x8000
000062  6821              LDR      r1,[r4,#0]
000064  6448              STR      r0,[r1,#0x44]
                  |L69.102|
000066  bf00              NOP      
                  |L69.104|
;;;2541     }
;;;2542   
;;;2543     /* Disable the Peripheral */
;;;2544     __HAL_TIM_DISABLE(htim);
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  f2411111          MOV      r1,#0x1111
000072  4008              ANDS     r0,r0,r1
000074  b950              CBNZ     r0,|L69.140|
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  1089              ASRS     r1,r1,#2
00007c  4008              ANDS     r0,r0,r1
00007e  b928              CBNZ     r0,|L69.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0200001          BIC      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L69.140|
00008c  bf00              NOP      
;;;2545   
;;;2546     /* Return function status */
;;;2547     return HAL_OK;
00008e  2000              MOVS     r0,#0
;;;2548   }
000090  bd30              POP      {r4,r5,pc}
;;;2549   
                          ENDP

000092  0000              DCW      0x0000
                  |L69.148|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3549     */
;;;3550   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;3551                                               TIM_OC_InitTypeDef *sConfig,
;;;3552                                               uint32_t Channel)
;;;3553   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3554     /* Check the parameters */
;;;3555     assert_param(IS_TIM_CHANNELS(Channel));
;;;3556     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3557     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3558     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3559   
;;;3560     /* Process Locked */
;;;3561     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  f894003c          LDRB     r0,[r4,#0x3c]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L70.22|
000012  2002              MOVS     r0,#2
                  |L70.20|
;;;3562   
;;;3563     htim->State = HAL_TIM_STATE_BUSY;
;;;3564   
;;;3565     switch (Channel)
;;;3566     {
;;;3567       case TIM_CHANNEL_1:
;;;3568       {
;;;3569         /* Check the parameters */
;;;3570         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3571   
;;;3572         /* Configure the Channel 1 in PWM mode */
;;;3573         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3574   
;;;3575         /* Set the Preload enable bit for channel1 */
;;;3576         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3577   
;;;3578         /* Configure the Output Fast mode */
;;;3579         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3580         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3581         break;
;;;3582       }
;;;3583   
;;;3584       case TIM_CHANNEL_2:
;;;3585       {
;;;3586         /* Check the parameters */
;;;3587         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3588   
;;;3589         /* Configure the Channel 2 in PWM mode */
;;;3590         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3591   
;;;3592         /* Set the Preload enable bit for channel2 */
;;;3593         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3594   
;;;3595         /* Configure the Output Fast mode */
;;;3596         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3597         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
;;;3598         break;
;;;3599       }
;;;3600   
;;;3601       case TIM_CHANNEL_3:
;;;3602       {
;;;3603         /* Check the parameters */
;;;3604         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3605   
;;;3606         /* Configure the Channel 3 in PWM mode */
;;;3607         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3608   
;;;3609         /* Set the Preload enable bit for channel3 */
;;;3610         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3611   
;;;3612         /* Configure the Output Fast mode */
;;;3613         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3614         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;3615         break;
;;;3616       }
;;;3617   
;;;3618       case TIM_CHANNEL_4:
;;;3619       {
;;;3620         /* Check the parameters */
;;;3621         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3622   
;;;3623         /* Configure the Channel 4 in PWM mode */
;;;3624         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3625   
;;;3626         /* Set the Preload enable bit for channel4 */
;;;3627         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3628   
;;;3629         /* Configure the Output Fast mode */
;;;3630         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3631         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
;;;3632         break;
;;;3633       }
;;;3634   
;;;3635       default:
;;;3636         break;
;;;3637     }
;;;3638   
;;;3639     htim->State = HAL_TIM_STATE_READY;
;;;3640   
;;;3641     __HAL_UNLOCK(htim);
;;;3642   
;;;3643     return HAL_OK;
;;;3644   }
000014  bd70              POP      {r4-r6,pc}
                  |L70.22|
000016  2001              MOVS     r0,#1                 ;3561
000018  f884003c          STRB     r0,[r4,#0x3c]         ;3561
00001c  bf00              NOP                            ;3561
00001e  2002              MOVS     r0,#2                 ;3563
000020  f884003d          STRB     r0,[r4,#0x3d]         ;3563
000024  b136              CBZ      r6,|L70.52|
000026  2e04              CMP      r6,#4                 ;3565
000028  d01b              BEQ      |L70.98|
00002a  2e08              CMP      r6,#8                 ;3565
00002c  d031              BEQ      |L70.146|
00002e  2e0c              CMP      r6,#0xc               ;3565
000030  d15e              BNE      |L70.240|
000032  e045              B        |L70.192|
                  |L70.52|
000034  4629              MOV      r1,r5                 ;3573
000036  6820              LDR      r0,[r4,#0]            ;3573
000038  f7fffffe          BL       TIM_OC1_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;3576
00003e  6980              LDR      r0,[r0,#0x18]         ;3576
000040  f0400008          ORR      r0,r0,#8              ;3576
000044  6821              LDR      r1,[r4,#0]            ;3576
000046  6188              STR      r0,[r1,#0x18]         ;3576
000048  6820              LDR      r0,[r4,#0]            ;3579
00004a  6980              LDR      r0,[r0,#0x18]         ;3579
00004c  f0200004          BIC      r0,r0,#4              ;3579
000050  6821              LDR      r1,[r4,#0]            ;3579
000052  6188              STR      r0,[r1,#0x18]         ;3579
000054  6820              LDR      r0,[r4,#0]            ;3580
000056  6980              LDR      r0,[r0,#0x18]         ;3580
000058  6929              LDR      r1,[r5,#0x10]         ;3580
00005a  4308              ORRS     r0,r0,r1              ;3580
00005c  6821              LDR      r1,[r4,#0]            ;3580
00005e  6188              STR      r0,[r1,#0x18]         ;3580
000060  e047              B        |L70.242|
                  |L70.98|
000062  4629              MOV      r1,r5                 ;3590
000064  6820              LDR      r0,[r4,#0]            ;3590
000066  f7fffffe          BL       TIM_OC2_SetConfig
00006a  6820              LDR      r0,[r4,#0]            ;3593
00006c  6980              LDR      r0,[r0,#0x18]         ;3593
00006e  f4406000          ORR      r0,r0,#0x800          ;3593
000072  6821              LDR      r1,[r4,#0]            ;3593
000074  6188              STR      r0,[r1,#0x18]         ;3593
000076  6820              LDR      r0,[r4,#0]            ;3596
000078  6980              LDR      r0,[r0,#0x18]         ;3596
00007a  f4206080          BIC      r0,r0,#0x400          ;3596
00007e  6821              LDR      r1,[r4,#0]            ;3596
000080  6188              STR      r0,[r1,#0x18]         ;3596
000082  6820              LDR      r0,[r4,#0]            ;3597
000084  6980              LDR      r0,[r0,#0x18]         ;3597
000086  6929              LDR      r1,[r5,#0x10]         ;3597
000088  ea402001          ORR      r0,r0,r1,LSL #8       ;3597
00008c  6821              LDR      r1,[r4,#0]            ;3597
00008e  6188              STR      r0,[r1,#0x18]         ;3597
000090  e02f              B        |L70.242|
                  |L70.146|
000092  4629              MOV      r1,r5                 ;3607
000094  6820              LDR      r0,[r4,#0]            ;3607
000096  f7fffffe          BL       TIM_OC3_SetConfig
00009a  6820              LDR      r0,[r4,#0]            ;3610
00009c  69c0              LDR      r0,[r0,#0x1c]         ;3610
00009e  f0400008          ORR      r0,r0,#8              ;3610
0000a2  6821              LDR      r1,[r4,#0]            ;3610
0000a4  61c8              STR      r0,[r1,#0x1c]         ;3610
0000a6  6820              LDR      r0,[r4,#0]            ;3613
0000a8  69c0              LDR      r0,[r0,#0x1c]         ;3613
0000aa  f0200004          BIC      r0,r0,#4              ;3613
0000ae  6821              LDR      r1,[r4,#0]            ;3613
0000b0  61c8              STR      r0,[r1,#0x1c]         ;3613
0000b2  6820              LDR      r0,[r4,#0]            ;3614
0000b4  69c0              LDR      r0,[r0,#0x1c]         ;3614
0000b6  6929              LDR      r1,[r5,#0x10]         ;3614
0000b8  4308              ORRS     r0,r0,r1              ;3614
0000ba  6821              LDR      r1,[r4,#0]            ;3614
0000bc  61c8              STR      r0,[r1,#0x1c]         ;3614
0000be  e018              B        |L70.242|
                  |L70.192|
0000c0  4629              MOV      r1,r5                 ;3624
0000c2  6820              LDR      r0,[r4,#0]            ;3624
0000c4  f7fffffe          BL       TIM_OC4_SetConfig
0000c8  6820              LDR      r0,[r4,#0]            ;3627
0000ca  69c0              LDR      r0,[r0,#0x1c]         ;3627
0000cc  f4406000          ORR      r0,r0,#0x800          ;3627
0000d0  6821              LDR      r1,[r4,#0]            ;3627
0000d2  61c8              STR      r0,[r1,#0x1c]         ;3627
0000d4  6820              LDR      r0,[r4,#0]            ;3630
0000d6  69c0              LDR      r0,[r0,#0x1c]         ;3630
0000d8  f4206080          BIC      r0,r0,#0x400          ;3630
0000dc  6821              LDR      r1,[r4,#0]            ;3630
0000de  61c8              STR      r0,[r1,#0x1c]         ;3630
0000e0  6820              LDR      r0,[r4,#0]            ;3631
0000e2  69c0              LDR      r0,[r0,#0x1c]         ;3631
0000e4  6929              LDR      r1,[r5,#0x10]         ;3631
0000e6  ea402001          ORR      r0,r0,r1,LSL #8       ;3631
0000ea  6821              LDR      r1,[r4,#0]            ;3631
0000ec  61c8              STR      r0,[r1,#0x1c]         ;3631
0000ee  e000              B        |L70.242|
                  |L70.240|
0000f0  bf00              NOP                            ;3636
                  |L70.242|
0000f2  bf00              NOP                            ;3581
0000f4  2001              MOVS     r0,#1                 ;3639
0000f6  f884003d          STRB     r0,[r4,#0x3d]         ;3639
0000fa  bf00              NOP                            ;3641
0000fc  2000              MOVS     r0,#0                 ;3641
0000fe  f884003c          STRB     r0,[r4,#0x3c]         ;3641
000102  bf00              NOP                            ;3641
000104  bf00              NOP                            ;3643
000106  e785              B        |L70.20|
;;;3645   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1213     */
;;;1214   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1215   {
000002  4604              MOV      r4,r0
;;;1216     /* Check the parameters */
;;;1217     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1218   
;;;1219     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f884003d          STRB     r0,[r4,#0x3d]
;;;1220   
;;;1221     /* Disable the TIM Peripheral Clock */
;;;1222     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  4008              ANDS     r0,r0,r1
000016  b950              CBNZ     r0,|L71.46|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  b928              CBNZ     r0,|L71.46|
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
                  |L71.46|
00002e  bf00              NOP      
;;;1223   
;;;1224   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1225     if (htim->PWM_MspDeInitCallback == NULL)
;;;1226     {
;;;1227       htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
;;;1228     }
;;;1229     /* DeInit the low level hardware */
;;;1230     htim->PWM_MspDeInitCallback(htim);
;;;1231   #else
;;;1232     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1233     HAL_TIM_PWM_MspDeInit(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1234   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1235   
;;;1236     /* Change TIM state */
;;;1237     htim->State = HAL_TIM_STATE_RESET;
000036  2000              MOVS     r0,#0
000038  f884003d          STRB     r0,[r4,#0x3d]
;;;1238   
;;;1239     /* Release Lock */
;;;1240     __HAL_UNLOCK(htim);
00003c  bf00              NOP      
00003e  f884003c          STRB     r0,[r4,#0x3c]
000042  bf00              NOP      
;;;1241   
;;;1242     return HAL_OK;
;;;1243   }
000044  bd10              POP      {r4,pc}
;;;1244   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;5482     */
;;;5483   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5484   {
;;;5485     return htim->State;
000002  f891003d          LDRB     r0,[r1,#0x3d]
;;;5486   }
000006  4770              BX       lr
;;;5487   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;1161     */
;;;1162   HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1163   {
000002  4604              MOV      r4,r0
;;;1164     /* Check the TIM handle allocation */
;;;1165     if (htim == NULL)
000004  b90c              CBNZ     r4,|L73.10|
;;;1166     {
;;;1167       return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L73.8|
;;;1168     }
;;;1169   
;;;1170     /* Check the parameters */
;;;1171     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1172     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1173     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1174     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1175   
;;;1176     if (htim->State == HAL_TIM_STATE_RESET)
;;;1177     {
;;;1178       /* Allocate lock resource and initialize it */
;;;1179       htim->Lock = HAL_UNLOCKED;
;;;1180   
;;;1181   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1182       /* Reset interrupt callbacks to legacy weak callbacks */
;;;1183       TIM_ResetCallback(htim);
;;;1184   
;;;1185       if (htim->PWM_MspInitCallback == NULL)
;;;1186       {
;;;1187         htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
;;;1188       }
;;;1189       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1190       htim->PWM_MspInitCallback(htim);
;;;1191   #else
;;;1192       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1193       HAL_TIM_PWM_MspInit(htim);
;;;1194   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1195     }
;;;1196   
;;;1197     /* Set the TIM state */
;;;1198     htim->State = HAL_TIM_STATE_BUSY;
;;;1199   
;;;1200     /* Init the base time for the PWM */
;;;1201     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1202   
;;;1203     /* Initialize the TIM state*/
;;;1204     htim->State = HAL_TIM_STATE_READY;
;;;1205   
;;;1206     return HAL_OK;
;;;1207   }
000008  bd10              POP      {r4,pc}
                  |L73.10|
00000a  f894003d          LDRB     r0,[r4,#0x3d]         ;1176
00000e  b928              CBNZ     r0,|L73.28|
000010  2000              MOVS     r0,#0                 ;1179
000012  f884003c          STRB     r0,[r4,#0x3c]         ;1179
000016  4620              MOV      r0,r4                 ;1193
000018  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L73.28|
00001c  2002              MOVS     r0,#2                 ;1198
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;1198
000022  1d21              ADDS     r1,r4,#4              ;1201
000024  6820              LDR      r0,[r4,#0]            ;1201
000026  f7fffffe          BL       TIM_Base_SetConfig
00002a  2001              MOVS     r0,#1                 ;1204
00002c  f884003d          STRB     r0,[r4,#0x3d]         ;1204
000030  2000              MOVS     r0,#0                 ;1206
000032  e7e9              B        |L73.8|
;;;1208   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1264     */
;;;1265   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1266   {
;;;1267     /* Prevent unused argument(s) compilation warning */
;;;1268     UNUSED(htim);
;;;1269   
;;;1270     /* NOTE : This function should not be modified, when the callback is needed,
;;;1271               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1272      */
;;;1273   }
;;;1274   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1249     */
;;;1250   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1251   {
;;;1252     /* Prevent unused argument(s) compilation warning */
;;;1253     UNUSED(htim);
;;;1254   
;;;1255     /* NOTE : This function should not be modified, when the callback is needed,
;;;1256               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1257      */
;;;1258   }
;;;1259   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4886     */
;;;4887   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4888   {
;;;4889     /* Prevent unused argument(s) compilation warning */
;;;4890     UNUSED(htim);
;;;4891   
;;;4892     /* NOTE : This function should not be modified, when the callback is needed,
;;;4893               the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4894      */
;;;4895   }
;;;4896   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedHalfCpltCallback PROC
;;;4901     */
;;;4902   __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4903   {
;;;4904     /* Prevent unused argument(s) compilation warning */
;;;4905     UNUSED(htim);
;;;4906   
;;;4907     /* NOTE : This function should not be modified, when the callback is needed,
;;;4908               the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
;;;4909      */
;;;4910   }
;;;4911   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1285     */
;;;1286   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1287   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1288     uint32_t tmpsmcr;
;;;1289   
;;;1290     /* Check the parameters */
;;;1291     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1292   
;;;1293     /* Enable the Capture compare channel */
;;;1294     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4631              MOV      r1,r6
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1295   
;;;1296     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  490d              LDR      r1,|L78.72|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d101              BNE      |L78.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L78.30|
                  |L78.28|
00001c  2000              MOVS     r0,#0
                  |L78.30|
00001e  b128              CBZ      r0,|L78.44|
;;;1297     {
;;;1298       /* Enable the main output */
;;;1299       __HAL_TIM_MOE_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6c40              LDR      r0,[r0,#0x44]
000024  f4404000          ORR      r0,r0,#0x8000
000028  6821              LDR      r1,[r4,#0]
00002a  6448              STR      r0,[r1,#0x44]
                  |L78.44|
;;;1300     }
;;;1301   
;;;1302     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1303     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  f0000507          AND      r5,r0,#7
;;;1304     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000034  2d06              CMP      r5,#6
000036  d005              BEQ      |L78.68|
;;;1305     {
;;;1306       __HAL_TIM_ENABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6800              LDR      r0,[r0,#0]
00003c  f0400001          ORR      r0,r0,#1
000040  6821              LDR      r1,[r4,#0]
000042  6008              STR      r0,[r1,#0]
                  |L78.68|
;;;1307     }
;;;1308   
;;;1309     /* Return function status */
;;;1310     return HAL_OK;
000044  2000              MOVS     r0,#0
;;;1311   }
000046  bd70              POP      {r4-r6,pc}
;;;1312   
                          ENDP

                  |L78.72|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1497     */
;;;1498   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1499   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1500     uint32_t tmpsmcr;
;;;1501   
;;;1502     /* Check the parameters */
;;;1503     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1504   
;;;1505     if ((htim->State == HAL_TIM_STATE_BUSY))
00000c  f894003d          LDRB     r0,[r4,#0x3d]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L79.24|
                  |L79.20|
;;;1506     {
;;;1507       return HAL_BUSY;
;;;1508     }
;;;1509     else if ((htim->State == HAL_TIM_STATE_READY))
;;;1510     {
;;;1511       if ((pData == NULL) && (Length > 0U))
;;;1512       {
;;;1513         return HAL_ERROR;
;;;1514       }
;;;1515       else
;;;1516       {
;;;1517         htim->State = HAL_TIM_STATE_BUSY;
;;;1518       }
;;;1519     }
;;;1520     else
;;;1521     {
;;;1522       /* nothing to do */
;;;1523     }
;;;1524   
;;;1525     switch (Channel)
;;;1526     {
;;;1527       case TIM_CHANNEL_1:
;;;1528       {
;;;1529         /* Set the DMA compare callbacks */
;;;1530         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1531         htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1532   
;;;1533         /* Set the DMA error callback */
;;;1534         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1535   
;;;1536         /* Enable the DMA stream */
;;;1537         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
;;;1538         {
;;;1539           return HAL_ERROR;
;;;1540         }
;;;1541   
;;;1542         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1543         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1544         break;
;;;1545       }
;;;1546   
;;;1547       case TIM_CHANNEL_2:
;;;1548       {
;;;1549         /* Set the DMA compare callbacks */
;;;1550         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1551         htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1552   
;;;1553         /* Set the DMA error callback */
;;;1554         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1555   
;;;1556         /* Enable the DMA stream */
;;;1557         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
;;;1558         {
;;;1559           return HAL_ERROR;
;;;1560         }
;;;1561         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1562         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1563         break;
;;;1564       }
;;;1565   
;;;1566       case TIM_CHANNEL_3:
;;;1567       {
;;;1568         /* Set the DMA compare callbacks */
;;;1569         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1570         htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1571   
;;;1572         /* Set the DMA error callback */
;;;1573         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1574   
;;;1575         /* Enable the DMA stream */
;;;1576         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
;;;1577         {
;;;1578           return HAL_ERROR;
;;;1579         }
;;;1580         /* Enable the TIM Output Capture/Compare 3 request */
;;;1581         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1582         break;
;;;1583       }
;;;1584   
;;;1585       case TIM_CHANNEL_4:
;;;1586       {
;;;1587         /* Set the DMA compare callbacks */
;;;1588         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1589         htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
;;;1590   
;;;1591         /* Set the DMA error callback */
;;;1592         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1593   
;;;1594         /* Enable the DMA stream */
;;;1595         if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
;;;1596         {
;;;1597           return HAL_ERROR;
;;;1598         }
;;;1599         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1600         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1601         break;
;;;1602       }
;;;1603   
;;;1604       default:
;;;1605         break;
;;;1606     }
;;;1607   
;;;1608     /* Enable the Capture compare channel */
;;;1609     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1610   
;;;1611     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1612     {
;;;1613       /* Enable the main output */
;;;1614       __HAL_TIM_MOE_ENABLE(htim);
;;;1615     }
;;;1616   
;;;1617     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1618     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
;;;1619     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
;;;1620     {
;;;1621       __HAL_TIM_ENABLE(htim);
;;;1622     }
;;;1623   
;;;1624     /* Return function status */
;;;1625     return HAL_OK;
;;;1626   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L79.24|
000018  f894003d          LDRB     r0,[r4,#0x3d]         ;1509
00001c  2801              CMP      r0,#1                 ;1509
00001e  d105              BNE      |L79.44|
000020  b90d              CBNZ     r5,|L79.38|
000022  b107              CBZ      r7,|L79.38|
000024  e7f6              B        |L79.20|
                  |L79.38|
000026  2002              MOVS     r0,#2                 ;1517
000028  f884003d          STRB     r0,[r4,#0x3d]         ;1517
                  |L79.44|
00002c  b136              CBZ      r6,|L79.60|
00002e  2e04              CMP      r6,#4                 ;1525
000030  d01f              BEQ      |L79.114|
000032  2e08              CMP      r6,#8                 ;1525
000034  d038              BEQ      |L79.168|
000036  2e0c              CMP      r6,#0xc               ;1525
000038  d16c              BNE      |L79.276|
00003a  e050              B        |L79.222|
                  |L79.60|
00003c  4947              LDR      r1,|L79.348|
00003e  6a60              LDR      r0,[r4,#0x24]         ;1530
000040  63c1              STR      r1,[r0,#0x3c]         ;1530
000042  4947              LDR      r1,|L79.352|
000044  6a60              LDR      r0,[r4,#0x24]         ;1531
000046  6401              STR      r1,[r0,#0x40]         ;1531
000048  4946              LDR      r1,|L79.356|
00004a  6a60              LDR      r0,[r4,#0x24]         ;1534
00004c  64c1              STR      r1,[r0,#0x4c]         ;1534
00004e  6821              LDR      r1,[r4,#0]            ;1537
000050  f1010234          ADD      r2,r1,#0x34           ;1537
000054  463b              MOV      r3,r7                 ;1537
000056  4629              MOV      r1,r5                 ;1537
000058  6a60              LDR      r0,[r4,#0x24]         ;1537
00005a  f7fffffe          BL       HAL_DMA_Start_IT
00005e  b108              CBZ      r0,|L79.100|
000060  2001              MOVS     r0,#1                 ;1539
000062  e7d7              B        |L79.20|
                  |L79.100|
000064  6820              LDR      r0,[r4,#0]            ;1543
000066  68c0              LDR      r0,[r0,#0xc]          ;1543
000068  f4407000          ORR      r0,r0,#0x200          ;1543
00006c  6821              LDR      r1,[r4,#0]            ;1543
00006e  60c8              STR      r0,[r1,#0xc]          ;1543
000070  e051              B        |L79.278|
                  |L79.114|
000072  493a              LDR      r1,|L79.348|
000074  6aa0              LDR      r0,[r4,#0x28]         ;1550
000076  63c1              STR      r1,[r0,#0x3c]         ;1550
000078  4939              LDR      r1,|L79.352|
00007a  6aa0              LDR      r0,[r4,#0x28]         ;1551
00007c  6401              STR      r1,[r0,#0x40]         ;1551
00007e  4939              LDR      r1,|L79.356|
000080  6aa0              LDR      r0,[r4,#0x28]         ;1554
000082  64c1              STR      r1,[r0,#0x4c]         ;1554
000084  6821              LDR      r1,[r4,#0]            ;1557
000086  f1010238          ADD      r2,r1,#0x38           ;1557
00008a  463b              MOV      r3,r7                 ;1557
00008c  4629              MOV      r1,r5                 ;1557
00008e  6aa0              LDR      r0,[r4,#0x28]         ;1557
000090  f7fffffe          BL       HAL_DMA_Start_IT
000094  b108              CBZ      r0,|L79.154|
000096  2001              MOVS     r0,#1                 ;1559
000098  e7bc              B        |L79.20|
                  |L79.154|
00009a  6820              LDR      r0,[r4,#0]            ;1562
00009c  68c0              LDR      r0,[r0,#0xc]          ;1562
00009e  f4406080          ORR      r0,r0,#0x400          ;1562
0000a2  6821              LDR      r1,[r4,#0]            ;1562
0000a4  60c8              STR      r0,[r1,#0xc]          ;1562
0000a6  e036              B        |L79.278|
                  |L79.168|
0000a8  492c              LDR      r1,|L79.348|
0000aa  6ae0              LDR      r0,[r4,#0x2c]         ;1569
0000ac  63c1              STR      r1,[r0,#0x3c]         ;1569
0000ae  492c              LDR      r1,|L79.352|
0000b0  6ae0              LDR      r0,[r4,#0x2c]         ;1570
0000b2  6401              STR      r1,[r0,#0x40]         ;1570
0000b4  492b              LDR      r1,|L79.356|
0000b6  6ae0              LDR      r0,[r4,#0x2c]         ;1573
0000b8  64c1              STR      r1,[r0,#0x4c]         ;1573
0000ba  6821              LDR      r1,[r4,#0]            ;1576
0000bc  f101023c          ADD      r2,r1,#0x3c           ;1576
0000c0  463b              MOV      r3,r7                 ;1576
0000c2  4629              MOV      r1,r5                 ;1576
0000c4  6ae0              LDR      r0,[r4,#0x2c]         ;1576
0000c6  f7fffffe          BL       HAL_DMA_Start_IT
0000ca  b108              CBZ      r0,|L79.208|
0000cc  2001              MOVS     r0,#1                 ;1578
0000ce  e7a1              B        |L79.20|
                  |L79.208|
0000d0  6820              LDR      r0,[r4,#0]            ;1581
0000d2  68c0              LDR      r0,[r0,#0xc]          ;1581
0000d4  f4406000          ORR      r0,r0,#0x800          ;1581
0000d8  6821              LDR      r1,[r4,#0]            ;1581
0000da  60c8              STR      r0,[r1,#0xc]          ;1581
0000dc  e01b              B        |L79.278|
                  |L79.222|
0000de  491f              LDR      r1,|L79.348|
0000e0  6b20              LDR      r0,[r4,#0x30]         ;1588
0000e2  63c1              STR      r1,[r0,#0x3c]         ;1588
0000e4  491e              LDR      r1,|L79.352|
0000e6  6b20              LDR      r0,[r4,#0x30]         ;1589
0000e8  6401              STR      r1,[r0,#0x40]         ;1589
0000ea  491e              LDR      r1,|L79.356|
0000ec  6b20              LDR      r0,[r4,#0x30]         ;1592
0000ee  64c1              STR      r1,[r0,#0x4c]         ;1592
0000f0  6821              LDR      r1,[r4,#0]            ;1595
0000f2  f1010240          ADD      r2,r1,#0x40           ;1595
0000f6  463b              MOV      r3,r7                 ;1595
0000f8  4629              MOV      r1,r5                 ;1595
0000fa  6b20              LDR      r0,[r4,#0x30]         ;1595
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  b108              CBZ      r0,|L79.262|
000102  2001              MOVS     r0,#1                 ;1597
000104  e786              B        |L79.20|
                  |L79.262|
000106  6820              LDR      r0,[r4,#0]            ;1600
000108  68c0              LDR      r0,[r0,#0xc]          ;1600
00010a  f4405080          ORR      r0,r0,#0x1000         ;1600
00010e  6821              LDR      r1,[r4,#0]            ;1600
000110  60c8              STR      r0,[r1,#0xc]          ;1600
000112  e000              B        |L79.278|
                  |L79.276|
000114  bf00              NOP                            ;1605
                  |L79.278|
000116  bf00              NOP                            ;1544
000118  2201              MOVS     r2,#1                 ;1609
00011a  4631              MOV      r1,r6                 ;1609
00011c  6820              LDR      r0,[r4,#0]            ;1609
00011e  f7fffffe          BL       TIM_CCxChannelCmd
000122  4911              LDR      r1,|L79.360|
000124  6820              LDR      r0,[r4,#0]            ;1611
000126  4288              CMP      r0,r1                 ;1611
000128  d101              BNE      |L79.302|
00012a  2001              MOVS     r0,#1                 ;1611
00012c  e000              B        |L79.304|
                  |L79.302|
00012e  2000              MOVS     r0,#0                 ;1611
                  |L79.304|
000130  b128              CBZ      r0,|L79.318|
000132  6820              LDR      r0,[r4,#0]            ;1614
000134  6c40              LDR      r0,[r0,#0x44]         ;1614
000136  f4404000          ORR      r0,r0,#0x8000         ;1614
00013a  6821              LDR      r1,[r4,#0]            ;1614
00013c  6448              STR      r0,[r1,#0x44]         ;1614
                  |L79.318|
00013e  6820              LDR      r0,[r4,#0]            ;1618
000140  6880              LDR      r0,[r0,#8]            ;1618
000142  f0000807          AND      r8,r0,#7              ;1618
000146  f1b80f06          CMP      r8,#6                 ;1619
00014a  d005              BEQ      |L79.344|
00014c  6820              LDR      r0,[r4,#0]            ;1621
00014e  6800              LDR      r0,[r0,#0]            ;1621
000150  f0400001          ORR      r0,r0,#1              ;1621
000154  6821              LDR      r1,[r4,#0]            ;1621
000156  6008              STR      r0,[r1,#0]            ;1621
                  |L79.344|
000158  2000              MOVS     r0,#0                 ;1625
00015a  e75b              B        |L79.20|
;;;1627   
                          ENDP

                  |L79.348|
                          DCD      TIM_DMADelayPulseCplt
                  |L79.352|
                          DCD      TIM_DMADelayPulseHalfCplt
                  |L79.356|
                          DCD      TIM_DMAError
                  |L79.360|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1358     */
;;;1359   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1360   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1361     uint32_t tmpsmcr;
;;;1362     /* Check the parameters */
;;;1363     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1364   
;;;1365     switch (Channel)
000006  b135              CBZ      r5,|L80.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L80.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L80.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L80.78|
000014  e014              B        |L80.64|
                  |L80.22|
;;;1366     {
;;;1367       case TIM_CHANNEL_1:
;;;1368       {
;;;1369         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1370         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1371         break;
000022  e015              B        |L80.80|
                  |L80.36|
;;;1372       }
;;;1373   
;;;1374       case TIM_CHANNEL_2:
;;;1375       {
;;;1376         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1377         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1378         break;
000030  e00e              B        |L80.80|
                  |L80.50|
;;;1379       }
;;;1380   
;;;1381       case TIM_CHANNEL_3:
;;;1382       {
;;;1383         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1384         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1385         break;
00003e  e007              B        |L80.80|
                  |L80.64|
;;;1386       }
;;;1387   
;;;1388       case TIM_CHANNEL_4:
;;;1389       {
;;;1390         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1391         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1392         break;
00004c  e000              B        |L80.80|
                  |L80.78|
;;;1393       }
;;;1394   
;;;1395       default:
;;;1396         break;
00004e  bf00              NOP      
                  |L80.80|
000050  bf00              NOP                            ;1371
;;;1397     }
;;;1398   
;;;1399     /* Enable the Capture compare channel */
;;;1400     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1401   
;;;1402     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005c  490d              LDR      r1,|L80.148|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d101              BNE      |L80.104|
000064  2001              MOVS     r0,#1
000066  e000              B        |L80.106|
                  |L80.104|
000068  2000              MOVS     r0,#0
                  |L80.106|
00006a  b128              CBZ      r0,|L80.120|
;;;1403     {
;;;1404       /* Enable the main output */
;;;1405       __HAL_TIM_MOE_ENABLE(htim);
00006c  6820              LDR      r0,[r4,#0]
00006e  6c40              LDR      r0,[r0,#0x44]
000070  f4404000          ORR      r0,r0,#0x8000
000074  6821              LDR      r1,[r4,#0]
000076  6448              STR      r0,[r1,#0x44]
                  |L80.120|
;;;1406     }
;;;1407   
;;;1408     /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
;;;1409     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
000078  6820              LDR      r0,[r4,#0]
00007a  6880              LDR      r0,[r0,#8]
00007c  f0000607          AND      r6,r0,#7
;;;1410     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
000080  2e06              CMP      r6,#6
000082  d005              BEQ      |L80.144|
;;;1411     {
;;;1412       __HAL_TIM_ENABLE(htim);
000084  6820              LDR      r0,[r4,#0]
000086  6800              LDR      r0,[r0,#0]
000088  f0400001          ORR      r0,r0,#1
00008c  6821              LDR      r1,[r4,#0]
00008e  6008              STR      r0,[r1,#0]
                  |L80.144|
;;;1413     }
;;;1414   
;;;1415     /* Return function status */
;;;1416     return HAL_OK;
000090  2000              MOVS     r0,#0
;;;1417   }
000092  bd70              POP      {r4-r6,pc}
;;;1418   
                          ENDP

                  |L80.148|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1323     */
;;;1324   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1325   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1326     /* Check the parameters */
;;;1327     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1328   
;;;1329     /* Disable the Capture compare channel */
;;;1330     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1331   
;;;1332     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  4919              LDR      r1,|L81.120|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d101              BNE      |L81.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L81.30|
                  |L81.28|
00001c  2000              MOVS     r0,#0
                  |L81.30|
00001e  b190              CBZ      r0,|L81.70|
;;;1333     {
;;;1334       /* Disable the Main Output */
;;;1335       __HAL_TIM_MOE_DISABLE(htim);
000020  bf00              NOP      
000022  6820              LDR      r0,[r4,#0]
000024  6a00              LDR      r0,[r0,#0x20]
000026  f2411111          MOV      r1,#0x1111
00002a  4008              ANDS     r0,r0,r1
00002c  b950              CBNZ     r0,|L81.68|
00002e  6820              LDR      r0,[r4,#0]
000030  6a00              LDR      r0,[r0,#0x20]
000032  1089              ASRS     r1,r1,#2
000034  4008              ANDS     r0,r0,r1
000036  b928              CBNZ     r0,|L81.68|
000038  6820              LDR      r0,[r4,#0]
00003a  6c40              LDR      r0,[r0,#0x44]
00003c  f4204000          BIC      r0,r0,#0x8000
000040  6821              LDR      r1,[r4,#0]
000042  6448              STR      r0,[r1,#0x44]
                  |L81.68|
000044  bf00              NOP      
                  |L81.70|
;;;1336     }
;;;1337   
;;;1338     /* Disable the Peripheral */
;;;1339     __HAL_TIM_DISABLE(htim);
000046  bf00              NOP      
000048  6820              LDR      r0,[r4,#0]
00004a  6a00              LDR      r0,[r0,#0x20]
00004c  f2411111          MOV      r1,#0x1111
000050  4008              ANDS     r0,r0,r1
000052  b950              CBNZ     r0,|L81.106|
000054  6820              LDR      r0,[r4,#0]
000056  6a00              LDR      r0,[r0,#0x20]
000058  1089              ASRS     r1,r1,#2
00005a  4008              ANDS     r0,r0,r1
00005c  b928              CBNZ     r0,|L81.106|
00005e  6820              LDR      r0,[r4,#0]
000060  6800              LDR      r0,[r0,#0]
000062  f0200001          BIC      r0,r0,#1
000066  6821              LDR      r1,[r4,#0]
000068  6008              STR      r0,[r1,#0]
                  |L81.106|
00006a  bf00              NOP      
;;;1340   
;;;1341     /* Change the htim state */
;;;1342     htim->State = HAL_TIM_STATE_READY;
00006c  2001              MOVS     r0,#1
00006e  f884003d          STRB     r0,[r4,#0x3d]
;;;1343   
;;;1344     /* Return function status */
;;;1345     return HAL_OK;
000072  2000              MOVS     r0,#0
;;;1346   }
000074  bd30              POP      {r4,r5,pc}
;;;1347   
                          ENDP

000076  0000              DCW      0x0000
                  |L81.120|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1638     */
;;;1639   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1640   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1641     /* Check the parameters */
;;;1642     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1643   
;;;1644     switch (Channel)
000006  b135              CBZ      r5,|L82.22|
000008  2d04              CMP      r5,#4
00000a  d00e              BEQ      |L82.42|
00000c  2d08              CMP      r5,#8
00000e  d016              BEQ      |L82.62|
000010  2d0c              CMP      r5,#0xc
000012  d128              BNE      |L82.102|
000014  e01d              B        |L82.82|
                  |L82.22|
;;;1645     {
;;;1646       case TIM_CHANNEL_1:
;;;1647       {
;;;1648         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1649         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1650         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
000022  6a60              LDR      r0,[r4,#0x24]
000024  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1651         break;
000028  e01e              B        |L82.104|
                  |L82.42|
;;;1652       }
;;;1653   
;;;1654       case TIM_CHANNEL_2:
;;;1655       {
;;;1656         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1657         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  f4206080          BIC      r0,r0,#0x400
000032  6821              LDR      r1,[r4,#0]
000034  60c8              STR      r0,[r1,#0xc]
;;;1658         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
000036  6aa0              LDR      r0,[r4,#0x28]
000038  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1659         break;
00003c  e014              B        |L82.104|
                  |L82.62|
;;;1660       }
;;;1661   
;;;1662       case TIM_CHANNEL_3:
;;;1663       {
;;;1664         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1665         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00003e  6820              LDR      r0,[r4,#0]
000040  68c0              LDR      r0,[r0,#0xc]
000042  f4206000          BIC      r0,r0,#0x800
000046  6821              LDR      r1,[r4,#0]
000048  60c8              STR      r0,[r1,#0xc]
;;;1666         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
00004a  6ae0              LDR      r0,[r4,#0x2c]
00004c  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1667         break;
000050  e00a              B        |L82.104|
                  |L82.82|
;;;1668       }
;;;1669   
;;;1670       case TIM_CHANNEL_4:
;;;1671       {
;;;1672         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1673         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000052  6820              LDR      r0,[r4,#0]
000054  68c0              LDR      r0,[r0,#0xc]
000056  f4205080          BIC      r0,r0,#0x1000
00005a  6821              LDR      r1,[r4,#0]
00005c  60c8              STR      r0,[r1,#0xc]
;;;1674         (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
00005e  6b20              LDR      r0,[r4,#0x30]
000060  f7fffffe          BL       HAL_DMA_Abort_IT
;;;1675         break;
000064  e000              B        |L82.104|
                  |L82.102|
;;;1676       }
;;;1677   
;;;1678       default:
;;;1679         break;
000066  bf00              NOP      
                  |L82.104|
000068  bf00              NOP                            ;1651
;;;1680     }
;;;1681   
;;;1682     /* Disable the Capture compare channel */
;;;1683     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00006a  2200              MOVS     r2,#0
00006c  4629              MOV      r1,r5
00006e  6820              LDR      r0,[r4,#0]
000070  f7fffffe          BL       TIM_CCxChannelCmd
;;;1684   
;;;1685     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000074  4919              LDR      r1,|L82.220|
000076  6820              LDR      r0,[r4,#0]
000078  4288              CMP      r0,r1
00007a  d101              BNE      |L82.128|
00007c  2001              MOVS     r0,#1
00007e  e000              B        |L82.130|
                  |L82.128|
000080  2000              MOVS     r0,#0
                  |L82.130|
000082  b190              CBZ      r0,|L82.170|
;;;1686     {
;;;1687       /* Disable the Main Output */
;;;1688       __HAL_TIM_MOE_DISABLE(htim);
000084  bf00              NOP      
000086  6820              LDR      r0,[r4,#0]
000088  6a00              LDR      r0,[r0,#0x20]
00008a  f2411111          MOV      r1,#0x1111
00008e  4008              ANDS     r0,r0,r1
000090  b950              CBNZ     r0,|L82.168|
000092  6820              LDR      r0,[r4,#0]
000094  6a00              LDR      r0,[r0,#0x20]
000096  1089              ASRS     r1,r1,#2
000098  4008              ANDS     r0,r0,r1
00009a  b928              CBNZ     r0,|L82.168|
00009c  6820              LDR      r0,[r4,#0]
00009e  6c40              LDR      r0,[r0,#0x44]
0000a0  f4204000          BIC      r0,r0,#0x8000
0000a4  6821              LDR      r1,[r4,#0]
0000a6  6448              STR      r0,[r1,#0x44]
                  |L82.168|
0000a8  bf00              NOP      
                  |L82.170|
;;;1689     }
;;;1690   
;;;1691     /* Disable the Peripheral */
;;;1692     __HAL_TIM_DISABLE(htim);
0000aa  bf00              NOP      
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6a00              LDR      r0,[r0,#0x20]
0000b0  f2411111          MOV      r1,#0x1111
0000b4  4008              ANDS     r0,r0,r1
0000b6  b950              CBNZ     r0,|L82.206|
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6a00              LDR      r0,[r0,#0x20]
0000bc  1089              ASRS     r1,r1,#2
0000be  4008              ANDS     r0,r0,r1
0000c0  b928              CBNZ     r0,|L82.206|
0000c2  6820              LDR      r0,[r4,#0]
0000c4  6800              LDR      r0,[r0,#0]
0000c6  f0200001          BIC      r0,r0,#1
0000ca  6821              LDR      r1,[r4,#0]
0000cc  6008              STR      r0,[r1,#0]
                  |L82.206|
0000ce  bf00              NOP      
;;;1693   
;;;1694     /* Change the htim state */
;;;1695     htim->State = HAL_TIM_STATE_READY;
0000d0  2001              MOVS     r0,#1
0000d2  f884003d          STRB     r0,[r4,#0x3d]
;;;1696   
;;;1697     /* Return function status */
;;;1698     return HAL_OK;
0000d6  2000              MOVS     r0,#0
;;;1699   }
0000d8  bd70              POP      {r4-r6,pc}
;;;1700   
                          ENDP

0000da  0000              DCW      0x0000
                  |L82.220|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1429     */
;;;1430   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1431   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1432     /* Check the parameters */
;;;1433     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1434   
;;;1435     switch (Channel)
000006  b135              CBZ      r5,|L83.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L83.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L83.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L83.78|
000014  e014              B        |L83.64|
                  |L83.22|
;;;1436     {
;;;1437       case TIM_CHANNEL_1:
;;;1438       {
;;;1439         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1440         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1441         break;
000022  e015              B        |L83.80|
                  |L83.36|
;;;1442       }
;;;1443   
;;;1444       case TIM_CHANNEL_2:
;;;1445       {
;;;1446         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1447         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1448         break;
000030  e00e              B        |L83.80|
                  |L83.50|
;;;1449       }
;;;1450   
;;;1451       case TIM_CHANNEL_3:
;;;1452       {
;;;1453         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1454         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1455         break;
00003e  e007              B        |L83.80|
                  |L83.64|
;;;1456       }
;;;1457   
;;;1458       case TIM_CHANNEL_4:
;;;1459       {
;;;1460         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1461         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1462         break;
00004c  e000              B        |L83.80|
                  |L83.78|
;;;1463       }
;;;1464   
;;;1465       default:
;;;1466         break;
00004e  bf00              NOP      
                  |L83.80|
000050  bf00              NOP                            ;1441
;;;1467     }
;;;1468   
;;;1469     /* Disable the Capture compare channel */
;;;1470     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1471   
;;;1472     if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005c  4917              LDR      r1,|L83.188|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d101              BNE      |L83.104|
000064  2001              MOVS     r0,#1
000066  e000              B        |L83.106|
                  |L83.104|
000068  2000              MOVS     r0,#0
                  |L83.106|
00006a  b190              CBZ      r0,|L83.146|
;;;1473     {
;;;1474       /* Disable the Main Output */
;;;1475       __HAL_TIM_MOE_DISABLE(htim);
00006c  bf00              NOP      
00006e  6820              LDR      r0,[r4,#0]
000070  6a00              LDR      r0,[r0,#0x20]
000072  f2411111          MOV      r1,#0x1111
000076  4008              ANDS     r0,r0,r1
000078  b950              CBNZ     r0,|L83.144|
00007a  6820              LDR      r0,[r4,#0]
00007c  6a00              LDR      r0,[r0,#0x20]
00007e  1089              ASRS     r1,r1,#2
000080  4008              ANDS     r0,r0,r1
000082  b928              CBNZ     r0,|L83.144|
000084  6820              LDR      r0,[r4,#0]
000086  6c40              LDR      r0,[r0,#0x44]
000088  f4204000          BIC      r0,r0,#0x8000
00008c  6821              LDR      r1,[r4,#0]
00008e  6448              STR      r0,[r1,#0x44]
                  |L83.144|
000090  bf00              NOP      
                  |L83.146|
;;;1476     }
;;;1477   
;;;1478     /* Disable the Peripheral */
;;;1479     __HAL_TIM_DISABLE(htim);
000092  bf00              NOP      
000094  6820              LDR      r0,[r4,#0]
000096  6a00              LDR      r0,[r0,#0x20]
000098  f2411111          MOV      r1,#0x1111
00009c  4008              ANDS     r0,r0,r1
00009e  b950              CBNZ     r0,|L83.182|
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6a00              LDR      r0,[r0,#0x20]
0000a4  1089              ASRS     r1,r1,#2
0000a6  4008              ANDS     r0,r0,r1
0000a8  b928              CBNZ     r0,|L83.182|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6800              LDR      r0,[r0,#0]
0000ae  f0200001          BIC      r0,r0,#1
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6008              STR      r0,[r1,#0]
                  |L83.182|
0000b6  bf00              NOP      
;;;1480   
;;;1481     /* Return function status */
;;;1482     return HAL_OK;
0000b8  2000              MOVS     r0,#0
;;;1483   }
0000ba  bd30              POP      {r4,r5,pc}
;;;1484   
                          ENDP

                  |L83.188|
                          DCD      0x40010000

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4811     */
;;;4812   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4813   {
;;;4814     /* Prevent unused argument(s) compilation warning */
;;;4815     UNUSED(htim);
;;;4816   
;;;4817     /* NOTE : This function should not be modified, when the callback is needed,
;;;4818               the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4819      */
;;;4820   }
;;;4821   
                          ENDP


                          AREA ||i.HAL_TIM_PeriodElapsedHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedHalfCpltCallback PROC
;;;4826     */
;;;4827   __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4828   {
;;;4829     /* Prevent unused argument(s) compilation warning */
;;;4830     UNUSED(htim);
;;;4831   
;;;4832     /* NOTE : This function should not be modified, when the callback is needed,
;;;4833               the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
;;;4834      */
;;;4835   }
;;;4836   
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4727     */
;;;4728   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;4729   {
;;;4730     uint32_t tmpreg = 0U;
000002  2000              MOVS     r0,#0
;;;4731   
;;;4732     switch (Channel)
000004  b131              CBZ      r1,|L86.20|
000006  2904              CMP      r1,#4
000008  d007              BEQ      |L86.26|
00000a  2908              CMP      r1,#8
00000c  d008              BEQ      |L86.32|
00000e  290c              CMP      r1,#0xc
000010  d10c              BNE      |L86.44|
000012  e008              B        |L86.38|
                  |L86.20|
;;;4733     {
;;;4734       case TIM_CHANNEL_1:
;;;4735       {
;;;4736         /* Check the parameters */
;;;4737         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4738   
;;;4739         /* Return the capture 1 value */
;;;4740         tmpreg =  htim->Instance->CCR1;
000014  6813              LDR      r3,[r2,#0]
000016  6b58              LDR      r0,[r3,#0x34]
;;;4741   
;;;4742         break;
000018  e009              B        |L86.46|
                  |L86.26|
;;;4743       }
;;;4744       case TIM_CHANNEL_2:
;;;4745       {
;;;4746         /* Check the parameters */
;;;4747         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4748   
;;;4749         /* Return the capture 2 value */
;;;4750         tmpreg =   htim->Instance->CCR2;
00001a  6813              LDR      r3,[r2,#0]
00001c  6b98              LDR      r0,[r3,#0x38]
;;;4751   
;;;4752         break;
00001e  e006              B        |L86.46|
                  |L86.32|
;;;4753       }
;;;4754   
;;;4755       case TIM_CHANNEL_3:
;;;4756       {
;;;4757         /* Check the parameters */
;;;4758         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4759   
;;;4760         /* Return the capture 3 value */
;;;4761         tmpreg =   htim->Instance->CCR3;
000020  6813              LDR      r3,[r2,#0]
000022  6bd8              LDR      r0,[r3,#0x3c]
;;;4762   
;;;4763         break;
000024  e003              B        |L86.46|
                  |L86.38|
;;;4764       }
;;;4765   
;;;4766       case TIM_CHANNEL_4:
;;;4767       {
;;;4768         /* Check the parameters */
;;;4769         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4770   
;;;4771         /* Return the capture 4 value */
;;;4772         tmpreg =   htim->Instance->CCR4;
000026  6813              LDR      r3,[r2,#0]
000028  6c18              LDR      r0,[r3,#0x40]
;;;4773   
;;;4774         break;
00002a  e000              B        |L86.46|
                  |L86.44|
;;;4775       }
;;;4776   
;;;4777       default:
;;;4778         break;
00002c  bf00              NOP      
                  |L86.46|
00002e  bf00              NOP                            ;4742
;;;4779     }
;;;4780   
;;;4781     return tmpreg;
;;;4782   }
000030  4770              BX       lr
;;;4783   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchro||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchro PROC
;;;4644     */
;;;4645   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4646   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4647     /* Check the parameters */
;;;4648     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4649     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4650     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4651   
;;;4652     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  f894003c          LDRB     r0,[r4,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L87.20|
000010  2002              MOVS     r0,#2
                  |L87.18|
;;;4653   
;;;4654     htim->State = HAL_TIM_STATE_BUSY;
;;;4655   
;;;4656     if(TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
;;;4657     {
;;;4658         htim->State = HAL_TIM_STATE_READY;
;;;4659       __HAL_UNLOCK(htim);
;;;4660       return HAL_ERROR;
;;;4661     }
;;;4662   
;;;4663     /* Disable Trigger Interrupt */
;;;4664     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
;;;4665   
;;;4666     /* Disable Trigger DMA request */
;;;4667     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4668   
;;;4669     htim->State = HAL_TIM_STATE_READY;
;;;4670   
;;;4671     __HAL_UNLOCK(htim);
;;;4672   
;;;4673     return HAL_OK;
;;;4674   }
000012  bd70              POP      {r4-r6,pc}
                  |L87.20|
000014  2001              MOVS     r0,#1                 ;4652
000016  f884003c          STRB     r0,[r4,#0x3c]         ;4652
00001a  bf00              NOP                            ;4652
00001c  2002              MOVS     r0,#2                 ;4654
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;4654
000022  4629              MOV      r1,r5                 ;4656
000024  4620              MOV      r0,r4                 ;4656
000026  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00002a  b148              CBZ      r0,|L87.64|
00002c  2001              MOVS     r0,#1                 ;4658
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;4658
000032  bf00              NOP                            ;4659
000034  2000              MOVS     r0,#0                 ;4659
000036  f884003c          STRB     r0,[r4,#0x3c]         ;4659
00003a  bf00              NOP                            ;4659
00003c  2001              MOVS     r0,#1                 ;4660
00003e  e7e8              B        |L87.18|
                  |L87.64|
000040  6820              LDR      r0,[r4,#0]            ;4664
000042  68c0              LDR      r0,[r0,#0xc]          ;4664
000044  f0200040          BIC      r0,r0,#0x40           ;4664
000048  6821              LDR      r1,[r4,#0]            ;4664
00004a  60c8              STR      r0,[r1,#0xc]          ;4664
00004c  6820              LDR      r0,[r4,#0]            ;4667
00004e  68c0              LDR      r0,[r0,#0xc]          ;4667
000050  f4204080          BIC      r0,r0,#0x4000         ;4667
000054  6821              LDR      r1,[r4,#0]            ;4667
000056  60c8              STR      r0,[r1,#0xc]          ;4667
000058  2001              MOVS     r0,#1                 ;4669
00005a  f884003d          STRB     r0,[r4,#0x3d]         ;4669
00005e  bf00              NOP                            ;4671
000060  2000              MOVS     r0,#0                 ;4671
000062  f884003c          STRB     r0,[r4,#0x3c]         ;4671
000066  bf00              NOP                            ;4671
000068  bf00              NOP                            ;4673
00006a  e7d2              B        |L87.18|
;;;4675   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchro_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchro_IT PROC
;;;4684     */
;;;4685   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;4686                                                           TIM_SlaveConfigTypeDef *sSlaveConfig)
;;;4687   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4688     /* Check the parameters */
;;;4689     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4690     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4691     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4692   
;;;4693     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  f894003c          LDRB     r0,[r4,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L88.20|
000010  2002              MOVS     r0,#2
                  |L88.18|
;;;4694   
;;;4695     htim->State = HAL_TIM_STATE_BUSY;
;;;4696   
;;;4697     if(TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
;;;4698     {
;;;4699         htim->State = HAL_TIM_STATE_READY;
;;;4700       __HAL_UNLOCK(htim);
;;;4701       return HAL_ERROR;
;;;4702     }
;;;4703   
;;;4704     /* Enable Trigger Interrupt */
;;;4705     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4706   
;;;4707     /* Disable Trigger DMA request */
;;;4708     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4709   
;;;4710     htim->State = HAL_TIM_STATE_READY;
;;;4711   
;;;4712     __HAL_UNLOCK(htim);
;;;4713   
;;;4714     return HAL_OK;
;;;4715   }
000012  bd70              POP      {r4-r6,pc}
                  |L88.20|
000014  2001              MOVS     r0,#1                 ;4693
000016  f884003c          STRB     r0,[r4,#0x3c]         ;4693
00001a  bf00              NOP                            ;4693
00001c  2002              MOVS     r0,#2                 ;4695
00001e  f884003d          STRB     r0,[r4,#0x3d]         ;4695
000022  4629              MOV      r1,r5                 ;4697
000024  4620              MOV      r0,r4                 ;4697
000026  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00002a  b148              CBZ      r0,|L88.64|
00002c  2001              MOVS     r0,#1                 ;4699
00002e  f884003d          STRB     r0,[r4,#0x3d]         ;4699
000032  bf00              NOP                            ;4700
000034  2000              MOVS     r0,#0                 ;4700
000036  f884003c          STRB     r0,[r4,#0x3c]         ;4700
00003a  bf00              NOP                            ;4700
00003c  2001              MOVS     r0,#1                 ;4701
00003e  e7e8              B        |L88.18|
                  |L88.64|
000040  6820              LDR      r0,[r4,#0]            ;4705
000042  68c0              LDR      r0,[r0,#0xc]          ;4705
000044  f0400040          ORR      r0,r0,#0x40           ;4705
000048  6821              LDR      r1,[r4,#0]            ;4705
00004a  60c8              STR      r0,[r1,#0xc]          ;4705
00004c  6820              LDR      r0,[r4,#0]            ;4708
00004e  68c0              LDR      r0,[r0,#0xc]          ;4708
000050  f4204080          BIC      r0,r0,#0x4000         ;4708
000054  6821              LDR      r1,[r4,#0]            ;4708
000056  60c8              STR      r0,[r1,#0xc]          ;4708
000058  2001              MOVS     r0,#1                 ;4710
00005a  f884003d          STRB     r0,[r4,#0x3d]         ;4710
00005e  bf00              NOP                            ;4712
000060  2000              MOVS     r0,#0                 ;4712
000062  f884003c          STRB     r0,[r4,#0x3c]         ;4712
000066  bf00              NOP                            ;4712
000068  bf00              NOP                            ;4714
00006a  e7d2              B        |L88.18|
;;;4716   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4916     */
;;;4917   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4918   {
;;;4919     /* Prevent unused argument(s) compilation warning */
;;;4920     UNUSED(htim);
;;;4921   
;;;4922     /* NOTE : This function should not be modified, when the callback is needed,
;;;4923               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4924      */
;;;4925   }
;;;4926   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerHalfCpltCallback PROC
;;;4931     */
;;;4932   __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4933   {
;;;4934     /* Prevent unused argument(s) compilation warning */
;;;4935     UNUSED(htim);
;;;4936   
;;;4937     /* NOTE : This function should not be modified, when the callback is needed,
;;;4938               the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
;;;4939      */
;;;4940   }
;;;4941   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;5789     */
;;;5790   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b510              PUSH     {r4,lr}
;;;5791   {
;;;5792     uint32_t tmpcr1;
;;;5793     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;5794   
;;;5795     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;5796     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000004  4b20              LDR      r3,|L91.136|
000006  4298              CMP      r0,r3
000008  d00b              BEQ      |L91.34|
00000a  f1b04f80          CMP      r0,#0x40000000
00000e  d008              BEQ      |L91.34|
000010  4b1e              LDR      r3,|L91.140|
000012  4298              CMP      r0,r3
000014  d005              BEQ      |L91.34|
000016  4b1e              LDR      r3,|L91.144|
000018  4298              CMP      r0,r3
00001a  d002              BEQ      |L91.34|
00001c  4b1d              LDR      r3,|L91.148|
00001e  4298              CMP      r0,r3
000020  d103              BNE      |L91.42|
                  |L91.34|
;;;5797     {
;;;5798       /* Select the Counter Mode */
;;;5799       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000022  f0220270          BIC      r2,r2,#0x70
;;;5800       tmpcr1 |= Structure->CounterMode;
000026  684b              LDR      r3,[r1,#4]
000028  431a              ORRS     r2,r2,r3
                  |L91.42|
;;;5801     }
;;;5802   
;;;5803     if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
00002a  4b17              LDR      r3,|L91.136|
00002c  4298              CMP      r0,r3
00002e  d014              BEQ      |L91.90|
000030  f1b04f80          CMP      r0,#0x40000000
000034  d011              BEQ      |L91.90|
000036  4b15              LDR      r3,|L91.140|
000038  4298              CMP      r0,r3
00003a  d00e              BEQ      |L91.90|
00003c  4b14              LDR      r3,|L91.144|
00003e  4298              CMP      r0,r3
000040  d00b              BEQ      |L91.90|
000042  4b14              LDR      r3,|L91.148|
000044  4298              CMP      r0,r3
000046  d008              BEQ      |L91.90|
000048  4b13              LDR      r3,|L91.152|
00004a  4298              CMP      r0,r3
00004c  d005              BEQ      |L91.90|
00004e  4b13              LDR      r3,|L91.156|
000050  4298              CMP      r0,r3
000052  d002              BEQ      |L91.90|
000054  4b12              LDR      r3,|L91.160|
000056  4298              CMP      r0,r3
000058  d103              BNE      |L91.98|
                  |L91.90|
;;;5804     {
;;;5805       /* Set the clock division */
;;;5806       tmpcr1 &= ~TIM_CR1_CKD;
00005a  f4227240          BIC      r2,r2,#0x300
;;;5807       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00005e  68cb              LDR      r3,[r1,#0xc]
000060  431a              ORRS     r2,r2,r3
                  |L91.98|
;;;5808     }
;;;5809   
;;;5810     /* Set the auto-reload preload */
;;;5811     MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
000062  f0220380          BIC      r3,r2,#0x80
000066  694c              LDR      r4,[r1,#0x14]
000068  ea430204          ORR      r2,r3,r4
;;;5812   
;;;5813     TIMx->CR1 = tmpcr1;
00006c  6002              STR      r2,[r0,#0]
;;;5814   
;;;5815     /* Set the Autoreload value */
;;;5816     TIMx->ARR = (uint32_t)Structure->Period ;
00006e  688b              LDR      r3,[r1,#8]
000070  62c3              STR      r3,[r0,#0x2c]
;;;5817   
;;;5818     /* Set the Prescaler value */
;;;5819     TIMx->PSC = Structure->Prescaler;
000072  680b              LDR      r3,[r1,#0]
000074  6283              STR      r3,[r0,#0x28]
;;;5820   
;;;5821     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
000076  4b04              LDR      r3,|L91.136|
000078  4298              CMP      r0,r3
00007a  d101              BNE      |L91.128|
;;;5822     {
;;;5823       /* Set the Repetition Counter value */
;;;5824       TIMx->RCR = Structure->RepetitionCounter;
00007c  690b              LDR      r3,[r1,#0x10]
00007e  6303              STR      r3,[r0,#0x30]
                  |L91.128|
;;;5825     }
;;;5826   
;;;5827     /* Generate an update event to reload the Prescaler
;;;5828        and the repetition counter (only for advanced timer) value immediately */
;;;5829     TIMx->EGR = TIM_EGR_UG;
000080  2301              MOVS     r3,#1
000082  6143              STR      r3,[r0,#0x14]
;;;5830   }
000084  bd10              POP      {r4,pc}
;;;5831   
                          ENDP

000086  0000              DCW      0x0000
                  |L91.136|
                          DCD      0x40010000
                  |L91.140|
                          DCD      0x40000400
                  |L91.144|
                          DCD      0x40000800
                  |L91.148|
                          DCD      0x40000c00
                  |L91.152|
                          DCD      0x40014000
                  |L91.156|
                          DCD      0x40014400
                  |L91.160|
                          DCD      0x40014800

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;6577     */
;;;6578   void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b530              PUSH     {r4,r5,lr}
;;;6579   {
;;;6580     uint32_t tmp;
;;;6581   
;;;6582     /* Check the parameters */
;;;6583     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;6584     assert_param(IS_TIM_CHANNELS(Channel));
;;;6585   
;;;6586     tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
000002  f001051f          AND      r5,r1,#0x1f
000006  2401              MOVS     r4,#1
000008  fa04f305          LSL      r3,r4,r5
;;;6587   
;;;6588     /* Reset the CCxE Bit */
;;;6589     TIMx->CCER &= ~tmp;
00000c  6a04              LDR      r4,[r0,#0x20]
00000e  439c              BICS     r4,r4,r3
000010  6204              STR      r4,[r0,#0x20]
;;;6590   
;;;6591     /* Set or reset the CCxE Bit */
;;;6592     TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
000012  6a04              LDR      r4,[r0,#0x20]
000014  f001051f          AND      r5,r1,#0x1f
000018  fa02f505          LSL      r5,r2,r5
00001c  432c              ORRS     r4,r4,r5
00001e  6204              STR      r4,[r0,#0x20]
;;;6593   }
000020  bd30              POP      {r4,r5,pc}
;;;6594   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;5634     */
;;;5635   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5636   {
000002  4605              MOV      r5,r0
;;;5637     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;5638   
;;;5639     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f884003d          STRB     r0,[r4,#0x3d]
;;;5640   
;;;5641     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L93.24|
;;;5642     {
;;;5643       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000012  2001              MOVS     r0,#1
000014  7720              STRB     r0,[r4,#0x1c]
000016  e010              B        |L93.58|
                  |L93.24|
;;;5644     }
;;;5645     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L93.36|
;;;5646     {
;;;5647       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2002              MOVS     r0,#2
000020  7720              STRB     r0,[r4,#0x1c]
000022  e00a              B        |L93.58|
                  |L93.36|
;;;5648     }
;;;5649     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  42a8              CMP      r0,r5
000028  d102              BNE      |L93.48|
;;;5650     {
;;;5651       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7720              STRB     r0,[r4,#0x1c]
00002e  e004              B        |L93.58|
                  |L93.48|
;;;5652     }
;;;5653     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000030  6b20              LDR      r0,[r4,#0x30]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L93.58|
;;;5654     {
;;;5655       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000036  2008              MOVS     r0,#8
000038  7720              STRB     r0,[r4,#0x1c]
                  |L93.58|
;;;5656     }
;;;5657     else
;;;5658     {
;;;5659       /* nothing to do */
;;;5660     }
;;;5661   
;;;5662   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5663     htim->IC_CaptureCallback(htim);
;;;5664   #else
;;;5665     HAL_TIM_IC_CaptureCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;5666   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5667   
;;;5668     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  2000              MOVS     r0,#0
000042  7720              STRB     r0,[r4,#0x1c]
;;;5669   }
000044  bd70              POP      {r4-r6,pc}
;;;5670   
                          ENDP


                          AREA ||i.TIM_DMACaptureHalfCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureHalfCplt PROC
;;;5675     */
;;;5676   void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5677   {
000002  4605              MOV      r5,r0
;;;5678     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;5679   
;;;5680     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f884003d          STRB     r0,[r4,#0x3d]
;;;5681   
;;;5682     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L94.24|
;;;5683     {
;;;5684       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000012  2001              MOVS     r0,#1
000014  7720              STRB     r0,[r4,#0x1c]
000016  e010              B        |L94.58|
                  |L94.24|
;;;5685     }
;;;5686     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L94.36|
;;;5687     {
;;;5688       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2002              MOVS     r0,#2
000020  7720              STRB     r0,[r4,#0x1c]
000022  e00a              B        |L94.58|
                  |L94.36|
;;;5689     }
;;;5690     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  42a8              CMP      r0,r5
000028  d102              BNE      |L94.48|
;;;5691     {
;;;5692       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7720              STRB     r0,[r4,#0x1c]
00002e  e004              B        |L94.58|
                  |L94.48|
;;;5693     }
;;;5694     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000030  6b20              LDR      r0,[r4,#0x30]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L94.58|
;;;5695     {
;;;5696       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000036  2008              MOVS     r0,#8
000038  7720              STRB     r0,[r4,#0x1c]
                  |L94.58|
;;;5697     }
;;;5698     else
;;;5699     {
;;;5700       /* nothing to do */
;;;5701     }
;;;5702   
;;;5703   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5704     htim->IC_CaptureHalfCpltCallback(htim);
;;;5705   #else
;;;5706     HAL_TIM_IC_CaptureHalfCpltCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_IC_CaptureHalfCpltCallback
;;;5707   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5708   
;;;5709     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  2000              MOVS     r0,#0
000042  7720              STRB     r0,[r4,#0x1c]
;;;5710   }
000044  bd70              POP      {r4-r6,pc}
;;;5711   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;5552     */
;;;5553   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5554   {
000002  4605              MOV      r5,r0
;;;5555     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;5556   
;;;5557     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f884003d          STRB     r0,[r4,#0x3d]
;;;5558   
;;;5559     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L95.24|
;;;5560     {
;;;5561       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000012  2001              MOVS     r0,#1
000014  7720              STRB     r0,[r4,#0x1c]
000016  e010              B        |L95.58|
                  |L95.24|
;;;5562     }
;;;5563     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L95.36|
;;;5564     {
;;;5565       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2002              MOVS     r0,#2
000020  7720              STRB     r0,[r4,#0x1c]
000022  e00a              B        |L95.58|
                  |L95.36|
;;;5566     }
;;;5567     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  42a8              CMP      r0,r5
000028  d102              BNE      |L95.48|
;;;5568     {
;;;5569       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7720              STRB     r0,[r4,#0x1c]
00002e  e004              B        |L95.58|
                  |L95.48|
;;;5570     }
;;;5571     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000030  6b20              LDR      r0,[r4,#0x30]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L95.58|
;;;5572     {
;;;5573       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000036  2008              MOVS     r0,#8
000038  7720              STRB     r0,[r4,#0x1c]
                  |L95.58|
;;;5574     }
;;;5575     else
;;;5576     {
;;;5577       /* nothing to do */
;;;5578     }
;;;5579   
;;;5580   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5581     htim->PWM_PulseFinishedCallback(htim);
;;;5582   #else
;;;5583     HAL_TIM_PWM_PulseFinishedCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;5584   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5585   
;;;5586     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  2000              MOVS     r0,#0
000042  7720              STRB     r0,[r4,#0x1c]
;;;5587   }
000044  bd70              POP      {r4-r6,pc}
;;;5588   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseHalfCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseHalfCplt PROC
;;;5593     */
;;;5594   void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5595   {
000002  4605              MOV      r5,r0
;;;5596     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;5597   
;;;5598     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f884003d          STRB     r0,[r4,#0x3d]
;;;5599   
;;;5600     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L96.24|
;;;5601     {
;;;5602       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000012  2001              MOVS     r0,#1
000014  7720              STRB     r0,[r4,#0x1c]
000016  e010              B        |L96.58|
                  |L96.24|
;;;5603     }
;;;5604     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L96.36|
;;;5605     {
;;;5606       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2002              MOVS     r0,#2
000020  7720              STRB     r0,[r4,#0x1c]
000022  e00a              B        |L96.58|
                  |L96.36|
;;;5607     }
;;;5608     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  42a8              CMP      r0,r5
000028  d102              BNE      |L96.48|
;;;5609     {
;;;5610       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7720              STRB     r0,[r4,#0x1c]
00002e  e004              B        |L96.58|
                  |L96.48|
;;;5611     }
;;;5612     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000030  6b20              LDR      r0,[r4,#0x30]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L96.58|
;;;5613     {
;;;5614       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000036  2008              MOVS     r0,#8
000038  7720              STRB     r0,[r4,#0x1c]
                  |L96.58|
;;;5615     }
;;;5616     else
;;;5617     {
;;;5618       /* nothing to do */
;;;5619     }
;;;5620   
;;;5621   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5622     htim->PWM_PulseFinishedHalfCpltCallback(htim);
;;;5623   #else
;;;5624     HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedHalfCpltCallback
;;;5625   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5626   
;;;5627     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  2000              MOVS     r0,#0
000042  7720              STRB     r0,[r4,#0x1c]
;;;5628   }
000044  bd70              POP      {r4-r6,pc}
;;;5629   
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;5534     */
;;;5535   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5536   {
000002  4604              MOV      r4,r0
;;;5537     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;5538   
;;;5539     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f885003d          STRB     r0,[r5,#0x3d]
;;;5540   
;;;5541   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5542     htim->ErrorCallback(htim);
;;;5543   #else
;;;5544     HAL_TIM_ErrorCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;5545   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5546   }
000012  bd70              POP      {r4-r6,pc}
;;;5547   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;5716     */
;;;5717   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5718   {
000002  4604              MOV      r4,r0
;;;5719     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;5720   
;;;5721     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f885003d          STRB     r0,[r5,#0x3d]
;;;5722   
;;;5723   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5724     htim->PeriodElapsedCallback(htim);
;;;5725   #else
;;;5726     HAL_TIM_PeriodElapsedCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;5727   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5728   }
000012  bd70              POP      {r4-r6,pc}
;;;5729   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedHalfCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedHalfCplt PROC
;;;5734     */
;;;5735   static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5736   {
000002  4604              MOV      r4,r0
;;;5737     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;5738   
;;;5739     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f885003d          STRB     r0,[r5,#0x3d]
;;;5740   
;;;5741   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5742     htim->PeriodElapsedHalfCpltCallback(htim);
;;;5743   #else
;;;5744     HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_PeriodElapsedHalfCpltCallback
;;;5745   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5746   }
000012  bd70              POP      {r4-r6,pc}
;;;5747   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;5752     */
;;;5753   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5754   {
000002  4604              MOV      r4,r0
;;;5755     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;5756   
;;;5757     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f885003d          STRB     r0,[r5,#0x3d]
;;;5758   
;;;5759   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5760     htim->TriggerCallback(htim);
;;;5761   #else
;;;5762     HAL_TIM_TriggerCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;5763   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5764   }
000012  bd70              POP      {r4-r6,pc}
;;;5765   
                          ENDP


                          AREA ||i.TIM_DMATriggerHalfCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerHalfCplt PROC
;;;5770     */
;;;5771   static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5772   {
000002  4604              MOV      r4,r0
;;;5773     TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;5774   
;;;5775     htim->State = HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  f885003d          STRB     r0,[r5,#0x3d]
;;;5776   
;;;5777   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5778     htim->TriggerHalfCpltCallback(htim);
;;;5779   #else
;;;5780     HAL_TIM_TriggerHalfCpltCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_TriggerHalfCpltCallback
;;;5781   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5782   }
000012  bd70              POP      {r4-r6,pc}
;;;5783   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;6547     */
;;;6548   void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b530              PUSH     {r4,r5,lr}
;;;6549                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;6550   {
000002  460c              MOV      r4,r1
;;;6551     uint32_t tmpsmcr;
;;;6552   
;;;6553     tmpsmcr = TIMx->SMCR;
000004  6881              LDR      r1,[r0,#8]
;;;6554   
;;;6555     /* Reset the ETR Bits */
;;;6556     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000006  f421417f          BIC      r1,r1,#0xff00
;;;6557   
;;;6558     /* Set the Prescaler, the Filter value and the Polarity */
;;;6559     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
00000a  ea422503          ORR      r5,r2,r3,LSL #8
00000e  4325              ORRS     r5,r5,r4
000010  4329              ORRS     r1,r1,r5
;;;6560   
;;;6561     /* Write to TIMx SMCR */
;;;6562     TIMx->SMCR = tmpsmcr;
000012  6081              STR      r1,[r0,#8]
;;;6563   }
000014  bd30              POP      {r4,r5,pc}
;;;6564   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;6517     */
;;;6518   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
000000  460a              MOV      r2,r1
;;;6519   {
;;;6520     uint32_t tmpsmcr;
;;;6521   
;;;6522     /* Get the TIMx SMCR register value */
;;;6523     tmpsmcr = TIMx->SMCR;
000002  6881              LDR      r1,[r0,#8]
;;;6524     /* Reset the TS Bits */
;;;6525     tmpsmcr &= ~TIM_SMCR_TS;
000004  f0210170          BIC      r1,r1,#0x70
;;;6526     /* Set the Input Trigger source and the slave mode*/
;;;6527     tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
000008  f0420307          ORR      r3,r2,#7
00000c  4319              ORRS     r1,r1,r3
;;;6528     /* Write to TIMx SMCR */
;;;6529     TIMx->SMCR = tmpsmcr;
00000e  6081              STR      r1,[r0,#8]
;;;6530   }
000010  4770              BX       lr
;;;6531   /**
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;5837     */
;;;5838   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;5839   {
;;;5840     uint32_t tmpccmrx;
;;;5841     uint32_t tmpccer;
;;;5842     uint32_t tmpcr2;
;;;5843   
;;;5844     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5845     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a05              LDR      r5,[r0,#0x20]
000004  f0250501          BIC      r5,r5,#1
000008  6205              STR      r5,[r0,#0x20]
;;;5846   
;;;5847     /* Get the TIMx CCER register value */
;;;5848     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;5849     /* Get the TIMx CR2 register value */
;;;5850     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;5851   
;;;5852     /* Get the TIMx CCMR1 register value */
;;;5853     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;5854   
;;;5855     /* Reset the Output Compare Mode Bits */
;;;5856     tmpccmrx &= ~TIM_CCMR1_OC1M;
000010  f0240470          BIC      r4,r4,#0x70
;;;5857     tmpccmrx &= ~TIM_CCMR1_CC1S;
000014  f0240403          BIC      r4,r4,#3
;;;5858     /* Select the Output Compare Mode */
;;;5859     tmpccmrx |= OC_Config->OCMode;
000018  680d              LDR      r5,[r1,#0]
00001a  432c              ORRS     r4,r4,r5
;;;5860   
;;;5861     /* Reset the Output Polarity level */
;;;5862     tmpccer &= ~TIM_CCER_CC1P;
00001c  f0220202          BIC      r2,r2,#2
;;;5863     /* Set the Output Compare Polarity */
;;;5864     tmpccer |= OC_Config->OCPolarity;
000020  688d              LDR      r5,[r1,#8]
000022  432a              ORRS     r2,r2,r5
;;;5865   
;;;5866     if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
000024  4d0d              LDR      r5,|L104.92|
000026  42a8              CMP      r0,r5
000028  d106              BNE      |L104.56|
00002a  bf00              NOP      
;;;5867     {
;;;5868       /* Check parameters */
;;;5869       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;5870   
;;;5871       /* Reset the Output N Polarity level */
;;;5872       tmpccer &= ~TIM_CCER_CC1NP;
00002c  f0220208          BIC      r2,r2,#8
;;;5873       /* Set the Output N Polarity */
;;;5874       tmpccer |= OC_Config->OCNPolarity;
000030  68cd              LDR      r5,[r1,#0xc]
000032  432a              ORRS     r2,r2,r5
;;;5875       /* Reset the Output N State */
;;;5876       tmpccer &= ~TIM_CCER_CC1NE;
000034  f0220204          BIC      r2,r2,#4
                  |L104.56|
;;;5877     }
;;;5878   
;;;5879     if (IS_TIM_BREAK_INSTANCE(TIMx))
000038  4d08              LDR      r5,|L104.92|
00003a  42a8              CMP      r0,r5
00003c  d107              BNE      |L104.78|
;;;5880     {
;;;5881       /* Check parameters */
;;;5882       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;5883       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;5884   
;;;5885       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5886       tmpcr2 &= ~TIM_CR2_OIS1;
00003e  f4237380          BIC      r3,r3,#0x100
;;;5887       tmpcr2 &= ~TIM_CR2_OIS1N;
000042  f4237300          BIC      r3,r3,#0x200
;;;5888       /* Set the Output Idle state */
;;;5889       tmpcr2 |= OC_Config->OCIdleState;
000046  694d              LDR      r5,[r1,#0x14]
000048  432b              ORRS     r3,r3,r5
;;;5890       /* Set the Output N Idle state */
;;;5891       tmpcr2 |= OC_Config->OCNIdleState;
00004a  698d              LDR      r5,[r1,#0x18]
00004c  432b              ORRS     r3,r3,r5
                  |L104.78|
;;;5892     }
;;;5893   
;;;5894     /* Write to TIMx CR2 */
;;;5895     TIMx->CR2 = tmpcr2;
00004e  6043              STR      r3,[r0,#4]
;;;5896   
;;;5897     /* Write to TIMx CCMR1 */
;;;5898     TIMx->CCMR1 = tmpccmrx;
000050  6184              STR      r4,[r0,#0x18]
;;;5899   
;;;5900     /* Set the Capture Compare Register value */
;;;5901     TIMx->CCR1 = OC_Config->Pulse;
000052  684d              LDR      r5,[r1,#4]
000054  6345              STR      r5,[r0,#0x34]
;;;5902   
;;;5903     /* Write to TIMx CCER */
;;;5904     TIMx->CCER = tmpccer;
000056  6202              STR      r2,[r0,#0x20]
;;;5905   }
000058  bd30              POP      {r4,r5,pc}
;;;5906   
                          ENDP

00005a  0000              DCW      0x0000
                  |L104.92|
                          DCD      0x40010000

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;5912     */
;;;5913   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;5914   {
;;;5915     uint32_t tmpccmrx;
;;;5916     uint32_t tmpccer;
;;;5917     uint32_t tmpcr2;
;;;5918   
;;;5919     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5920     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a05              LDR      r5,[r0,#0x20]
000004  f0250510          BIC      r5,r5,#0x10
000008  6205              STR      r5,[r0,#0x20]
;;;5921   
;;;5922     /* Get the TIMx CCER register value */
;;;5923     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;5924     /* Get the TIMx CR2 register value */
;;;5925     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;5926   
;;;5927     /* Get the TIMx CCMR1 register value */
;;;5928     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;5929   
;;;5930     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5931     tmpccmrx &= ~TIM_CCMR1_OC2M;
000010  f42444e0          BIC      r4,r4,#0x7000
;;;5932     tmpccmrx &= ~TIM_CCMR1_CC2S;
000014  f4247440          BIC      r4,r4,#0x300
;;;5933   
;;;5934     /* Select the Output Compare Mode */
;;;5935     tmpccmrx |= (OC_Config->OCMode << 8U);
000018  680d              LDR      r5,[r1,#0]
00001a  ea442405          ORR      r4,r4,r5,LSL #8
;;;5936   
;;;5937     /* Reset the Output Polarity level */
;;;5938     tmpccer &= ~TIM_CCER_CC2P;
00001e  f0220220          BIC      r2,r2,#0x20
;;;5939     /* Set the Output Compare Polarity */
;;;5940     tmpccer |= (OC_Config->OCPolarity << 4U);
000022  688d              LDR      r5,[r1,#8]
000024  ea421205          ORR      r2,r2,r5,LSL #4
;;;5941   
;;;5942     if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
000028  4d0e              LDR      r5,|L105.100|
00002a  42a8              CMP      r0,r5
00002c  d107              BNE      |L105.62|
00002e  bf00              NOP      
;;;5943     {
;;;5944       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;5945   
;;;5946       /* Reset the Output N Polarity level */
;;;5947       tmpccer &= ~TIM_CCER_CC2NP;
000030  f0220280          BIC      r2,r2,#0x80
;;;5948       /* Set the Output N Polarity */
;;;5949       tmpccer |= (OC_Config->OCNPolarity << 4U);
000034  68cd              LDR      r5,[r1,#0xc]
000036  ea421205          ORR      r2,r2,r5,LSL #4
;;;5950       /* Reset the Output N State */
;;;5951       tmpccer &= ~TIM_CCER_CC2NE;
00003a  f0220240          BIC      r2,r2,#0x40
                  |L105.62|
;;;5952   
;;;5953     }
;;;5954   
;;;5955     if (IS_TIM_BREAK_INSTANCE(TIMx))
00003e  4d09              LDR      r5,|L105.100|
000040  42a8              CMP      r0,r5
000042  d109              BNE      |L105.88|
;;;5956     {
;;;5957       /* Check parameters */
;;;5958       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;5959       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;5960   
;;;5961       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5962       tmpcr2 &= ~TIM_CR2_OIS2;
000044  f4236380          BIC      r3,r3,#0x400
;;;5963       tmpcr2 &= ~TIM_CR2_OIS2N;
000048  f4236300          BIC      r3,r3,#0x800
;;;5964       /* Set the Output Idle state */
;;;5965       tmpcr2 |= (OC_Config->OCIdleState << 2U);
00004c  694d              LDR      r5,[r1,#0x14]
00004e  ea430385          ORR      r3,r3,r5,LSL #2
;;;5966       /* Set the Output N Idle state */
;;;5967       tmpcr2 |= (OC_Config->OCNIdleState << 2U);
000052  698d              LDR      r5,[r1,#0x18]
000054  ea430385          ORR      r3,r3,r5,LSL #2
                  |L105.88|
;;;5968     }
;;;5969   
;;;5970     /* Write to TIMx CR2 */
;;;5971     TIMx->CR2 = tmpcr2;
000058  6043              STR      r3,[r0,#4]
;;;5972   
;;;5973     /* Write to TIMx CCMR1 */
;;;5974     TIMx->CCMR1 = tmpccmrx;
00005a  6184              STR      r4,[r0,#0x18]
;;;5975   
;;;5976     /* Set the Capture Compare Register value */
;;;5977     TIMx->CCR2 = OC_Config->Pulse;
00005c  684d              LDR      r5,[r1,#4]
00005e  6385              STR      r5,[r0,#0x38]
;;;5978   
;;;5979     /* Write to TIMx CCER */
;;;5980     TIMx->CCER = tmpccer;
000060  6202              STR      r2,[r0,#0x20]
;;;5981   }
000062  bd30              POP      {r4,r5,pc}
;;;5982   
                          ENDP

                  |L105.100|
                          DCD      0x40010000

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;5988     */
;;;5989   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;5990   {
;;;5991     uint32_t tmpccmrx;
;;;5992     uint32_t tmpccer;
;;;5993     uint32_t tmpcr2;
;;;5994   
;;;5995     /* Disable the Channel 3: Reset the CC2E Bit */
;;;5996     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a05              LDR      r5,[r0,#0x20]
000004  f4257580          BIC      r5,r5,#0x100
000008  6205              STR      r5,[r0,#0x20]
;;;5997   
;;;5998     /* Get the TIMx CCER register value */
;;;5999     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;6000     /* Get the TIMx CR2 register value */
;;;6001     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;6002   
;;;6003     /* Get the TIMx CCMR2 register value */
;;;6004     tmpccmrx = TIMx->CCMR2;
00000e  69c4              LDR      r4,[r0,#0x1c]
;;;6005   
;;;6006     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;6007     tmpccmrx &= ~TIM_CCMR2_OC3M;
000010  f0240470          BIC      r4,r4,#0x70
;;;6008     tmpccmrx &= ~TIM_CCMR2_CC3S;
000014  f0240403          BIC      r4,r4,#3
;;;6009     /* Select the Output Compare Mode */
;;;6010     tmpccmrx |= OC_Config->OCMode;
000018  680d              LDR      r5,[r1,#0]
00001a  432c              ORRS     r4,r4,r5
;;;6011   
;;;6012     /* Reset the Output Polarity level */
;;;6013     tmpccer &= ~TIM_CCER_CC3P;
00001c  f4227200          BIC      r2,r2,#0x200
;;;6014     /* Set the Output Compare Polarity */
;;;6015     tmpccer |= (OC_Config->OCPolarity << 8U);
000020  688d              LDR      r5,[r1,#8]
000022  ea422205          ORR      r2,r2,r5,LSL #8
;;;6016   
;;;6017     if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
000026  4d0f              LDR      r5,|L106.100|
000028  42a8              CMP      r0,r5
00002a  d107              BNE      |L106.60|
00002c  bf00              NOP      
;;;6018     {
;;;6019       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;6020   
;;;6021       /* Reset the Output N Polarity level */
;;;6022       tmpccer &= ~TIM_CCER_CC3NP;
00002e  f4226200          BIC      r2,r2,#0x800
;;;6023       /* Set the Output N Polarity */
;;;6024       tmpccer |= (OC_Config->OCNPolarity << 8U);
000032  68cd              LDR      r5,[r1,#0xc]
000034  ea422205          ORR      r2,r2,r5,LSL #8
;;;6025       /* Reset the Output N State */
;;;6026       tmpccer &= ~TIM_CCER_CC3NE;
000038  f4226280          BIC      r2,r2,#0x400
                  |L106.60|
;;;6027     }
;;;6028   
;;;6029     if (IS_TIM_BREAK_INSTANCE(TIMx))
00003c  4d09              LDR      r5,|L106.100|
00003e  42a8              CMP      r0,r5
000040  d109              BNE      |L106.86|
;;;6030     {
;;;6031       /* Check parameters */
;;;6032       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;6033       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;6034   
;;;6035       /* Reset the Output Compare and Output Compare N IDLE State */
;;;6036       tmpcr2 &= ~TIM_CR2_OIS3;
000042  f4235380          BIC      r3,r3,#0x1000
;;;6037       tmpcr2 &= ~TIM_CR2_OIS3N;
000046  f4235300          BIC      r3,r3,#0x2000
;;;6038       /* Set the Output Idle state */
;;;6039       tmpcr2 |= (OC_Config->OCIdleState << 4U);
00004a  694d              LDR      r5,[r1,#0x14]
00004c  ea431305          ORR      r3,r3,r5,LSL #4
;;;6040       /* Set the Output N Idle state */
;;;6041       tmpcr2 |= (OC_Config->OCNIdleState << 4U);
000050  698d              LDR      r5,[r1,#0x18]
000052  ea431305          ORR      r3,r3,r5,LSL #4
                  |L106.86|
;;;6042     }
;;;6043   
;;;6044     /* Write to TIMx CR2 */
;;;6045     TIMx->CR2 = tmpcr2;
000056  6043              STR      r3,[r0,#4]
;;;6046   
;;;6047     /* Write to TIMx CCMR2 */
;;;6048     TIMx->CCMR2 = tmpccmrx;
000058  61c4              STR      r4,[r0,#0x1c]
;;;6049   
;;;6050     /* Set the Capture Compare Register value */
;;;6051     TIMx->CCR3 = OC_Config->Pulse;
00005a  684d              LDR      r5,[r1,#4]
00005c  63c5              STR      r5,[r0,#0x3c]
;;;6052   
;;;6053     /* Write to TIMx CCER */
;;;6054     TIMx->CCER = tmpccer;
00005e  6202              STR      r2,[r0,#0x20]
;;;6055   }
000060  bd30              POP      {r4,r5,pc}
;;;6056   
                          ENDP

000062  0000              DCW      0x0000
                  |L106.100|
                          DCD      0x40010000

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;6062     */
;;;6063   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;6064   {
;;;6065     uint32_t tmpccmrx;
;;;6066     uint32_t tmpccer;
;;;6067     uint32_t tmpcr2;
;;;6068   
;;;6069     /* Disable the Channel 4: Reset the CC4E Bit */
;;;6070     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a05              LDR      r5,[r0,#0x20]
000004  f4255580          BIC      r5,r5,#0x1000
000008  6205              STR      r5,[r0,#0x20]
;;;6071   
;;;6072     /* Get the TIMx CCER register value */
;;;6073     tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;6074     /* Get the TIMx CR2 register value */
;;;6075     tmpcr2 =  TIMx->CR2;
00000c  6844              LDR      r4,[r0,#4]
;;;6076   
;;;6077     /* Get the TIMx CCMR2 register value */
;;;6078     tmpccmrx = TIMx->CCMR2;
00000e  69c2              LDR      r2,[r0,#0x1c]
;;;6079   
;;;6080     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;6081     tmpccmrx &= ~TIM_CCMR2_OC4M;
000010  f42242e0          BIC      r2,r2,#0x7000
;;;6082     tmpccmrx &= ~TIM_CCMR2_CC4S;
000014  f4227240          BIC      r2,r2,#0x300
;;;6083   
;;;6084     /* Select the Output Compare Mode */
;;;6085     tmpccmrx |= (OC_Config->OCMode << 8U);
000018  680d              LDR      r5,[r1,#0]
00001a  ea422205          ORR      r2,r2,r5,LSL #8
;;;6086   
;;;6087     /* Reset the Output Polarity level */
;;;6088     tmpccer &= ~TIM_CCER_CC4P;
00001e  f4235300          BIC      r3,r3,#0x2000
;;;6089     /* Set the Output Compare Polarity */
;;;6090     tmpccer |= (OC_Config->OCPolarity << 12U);
000022  688d              LDR      r5,[r1,#8]
000024  ea433305          ORR      r3,r3,r5,LSL #12
;;;6091   
;;;6092     if (IS_TIM_BREAK_INSTANCE(TIMx))
000028  4d06              LDR      r5,|L107.68|
00002a  42a8              CMP      r0,r5
00002c  d104              BNE      |L107.56|
;;;6093     {
;;;6094       /* Check parameters */
;;;6095       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;6096   
;;;6097       /* Reset the Output Compare IDLE State */
;;;6098       tmpcr2 &= ~TIM_CR2_OIS4;
00002e  f4244480          BIC      r4,r4,#0x4000
;;;6099   
;;;6100       /* Set the Output Idle state */
;;;6101       tmpcr2 |= (OC_Config->OCIdleState << 6U);
000032  694d              LDR      r5,[r1,#0x14]
000034  ea441485          ORR      r4,r4,r5,LSL #6
                  |L107.56|
;;;6102     }
;;;6103   
;;;6104     /* Write to TIMx CR2 */
;;;6105     TIMx->CR2 = tmpcr2;
000038  6044              STR      r4,[r0,#4]
;;;6106   
;;;6107     /* Write to TIMx CCMR2 */
;;;6108     TIMx->CCMR2 = tmpccmrx;
00003a  61c2              STR      r2,[r0,#0x1c]
;;;6109   
;;;6110     /* Set the Capture Compare Register value */
;;;6111     TIMx->CCR4 = OC_Config->Pulse;
00003c  684d              LDR      r5,[r1,#4]
00003e  6405              STR      r5,[r0,#0x40]
;;;6112   
;;;6113     /* Write to TIMx CCER */
;;;6114     TIMx->CCER = tmpccer;
000040  6203              STR      r3,[r0,#0x20]
;;;6115   }
000042  bd30              POP      {r4,r5,pc}
;;;6116   
                          ENDP

                  |L107.68|
                          DCD      0x40010000

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;6122     */
;;;6123   static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6124                                        TIM_SlaveConfigTypeDef *sSlaveConfig)
;;;6125   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;6126     uint32_t tmpsmcr;
;;;6127     uint32_t tmpccmr1;
;;;6128     uint32_t tmpccer;
;;;6129   
;;;6130     /* Get the TIMx SMCR register value */
;;;6131     tmpsmcr = htim->Instance->SMCR;
000008  6828              LDR      r0,[r5,#0]
00000a  6886              LDR      r6,[r0,#8]
;;;6132   
;;;6133     /* Reset the Trigger Selection Bits */
;;;6134     tmpsmcr &= ~TIM_SMCR_TS;
00000c  f0260670          BIC      r6,r6,#0x70
;;;6135     /* Set the Input Trigger source */
;;;6136     tmpsmcr |= sSlaveConfig->InputTrigger;
000010  6860              LDR      r0,[r4,#4]
000012  4306              ORRS     r6,r6,r0
;;;6137   
;;;6138     /* Reset the slave mode Bits */
;;;6139     tmpsmcr &= ~TIM_SMCR_SMS;
000014  f0260607          BIC      r6,r6,#7
;;;6140     /* Set the slave mode */
;;;6141     tmpsmcr |= sSlaveConfig->SlaveMode;
000018  6820              LDR      r0,[r4,#0]
00001a  4306              ORRS     r6,r6,r0
;;;6142   
;;;6143     /* Write to TIMx SMCR */
;;;6144     htim->Instance->SMCR = tmpsmcr;
00001c  6828              LDR      r0,[r5,#0]
00001e  6086              STR      r6,[r0,#8]
;;;6145   
;;;6146     /* Configure the trigger prescaler, filter, and polarity */
;;;6147     switch (sSlaveConfig->InputTrigger)
000020  6860              LDR      r0,[r4,#4]
000022  f000010f          AND      r1,r0,#0xf
000026  2900              CMP      r1,#0
000028  d13b              BNE      |L108.162|
00002a  1100              ASRS     r0,r0,#4
00002c  2808              CMP      r0,#8
00002e  d238              BCS      |L108.162|
000030  e8dff000          TBB      [pc,r0]
000034  33343536          DCB      0x33,0x34,0x35,0x36
000038  0b272d04          DCB      0x0b,0x27,0x2d,0x04
;;;6148     {
;;;6149       case TIM_TS_ETRF:
;;;6150       {
;;;6151         /* Check the parameters */
;;;6152         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;6153         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;6154         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;6155         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;6156         /* Configure the ETR Trigger source */
;;;6157         TIM_ETR_SetConfig(htim->Instance,
00003c  e9d41303          LDRD     r1,r3,[r4,#0xc]
000040  68a2              LDR      r2,[r4,#8]
000042  6828              LDR      r0,[r5,#0]
000044  f7fffffe          BL       TIM_ETR_SetConfig
;;;6158                           sSlaveConfig->TriggerPrescaler,
;;;6159                           sSlaveConfig->TriggerPolarity,
;;;6160                           sSlaveConfig->TriggerFilter);
;;;6161         break;
000048  e02c              B        |L108.164|
;;;6162       }
;;;6163   
;;;6164       case TIM_TS_TI1F_ED:
;;;6165       {
;;;6166         /* Check the parameters */
;;;6167         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;6168         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;6169   
;;;6170         if(sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
00004a  6820              LDR      r0,[r4,#0]
00004c  2805              CMP      r0,#5
00004e  d102              BNE      |L108.86|
;;;6171         {
;;;6172           return HAL_ERROR;
000050  2001              MOVS     r0,#1
                  |L108.82|
;;;6173         }
;;;6174   
;;;6175         /* Disable the Channel 1: Reset the CC1E Bit */
;;;6176         tmpccer = htim->Instance->CCER;
;;;6177         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;6178         tmpccmr1 = htim->Instance->CCMR1;
;;;6179   
;;;6180         /* Set the filter */
;;;6181         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;6182         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
;;;6183   
;;;6184         /* Write to TIMx CCMR1 and CCER registers */
;;;6185         htim->Instance->CCMR1 = tmpccmr1;
;;;6186         htim->Instance->CCER = tmpccer;
;;;6187         break;
;;;6188       }
;;;6189   
;;;6190       case TIM_TS_TI1FP1:
;;;6191       {
;;;6192         /* Check the parameters */
;;;6193         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;6194         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;6195         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;6196   
;;;6197         /* Configure TI1 Filter and Polarity */
;;;6198         TIM_TI1_ConfigInputStage(htim->Instance,
;;;6199                                  sSlaveConfig->TriggerPolarity,
;;;6200                                  sSlaveConfig->TriggerFilter);
;;;6201         break;
;;;6202       }
;;;6203   
;;;6204       case TIM_TS_TI2FP2:
;;;6205       {
;;;6206         /* Check the parameters */
;;;6207         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;6208         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;6209         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;6210   
;;;6211         /* Configure TI2 Filter and Polarity */
;;;6212         TIM_TI2_ConfigInputStage(htim->Instance,
;;;6213                                  sSlaveConfig->TriggerPolarity,
;;;6214                                  sSlaveConfig->TriggerFilter);
;;;6215         break;
;;;6216       }
;;;6217   
;;;6218       case TIM_TS_ITR0:
;;;6219       case TIM_TS_ITR1:
;;;6220       case TIM_TS_ITR2:
;;;6221       case TIM_TS_ITR3:
;;;6222       {
;;;6223         /* Check the parameter */
;;;6224         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;6225         break;
;;;6226       }
;;;6227   
;;;6228       default:
;;;6229         break;
;;;6230     }
;;;6231     return HAL_OK;
;;;6232   }
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L108.86|
000056  6828              LDR      r0,[r5,#0]            ;6176
000058  f8d08020          LDR      r8,[r0,#0x20]         ;6176
00005c  6828              LDR      r0,[r5,#0]            ;6177
00005e  6a00              LDR      r0,[r0,#0x20]         ;6177
000060  f0200001          BIC      r0,r0,#1              ;6177
000064  6829              LDR      r1,[r5,#0]            ;6177
000066  6208              STR      r0,[r1,#0x20]         ;6177
000068  6828              LDR      r0,[r5,#0]            ;6178
00006a  6987              LDR      r7,[r0,#0x18]         ;6178
00006c  f02707f0          BIC      r7,r7,#0xf0           ;6181
000070  6920              LDR      r0,[r4,#0x10]         ;6182
000072  ea471700          ORR      r7,r7,r0,LSL #4       ;6182
000076  6828              LDR      r0,[r5,#0]            ;6185
000078  6187              STR      r7,[r0,#0x18]         ;6185
00007a  6828              LDR      r0,[r5,#0]            ;6186
00007c  f8c08020          STR      r8,[r0,#0x20]         ;6186
000080  e010              B        |L108.164|
000082  6922              LDR      r2,[r4,#0x10]         ;6198
000084  68a1              LDR      r1,[r4,#8]            ;6198
000086  6828              LDR      r0,[r5,#0]            ;6198
000088  f7fffffe          BL       TIM_TI1_ConfigInputStage
00008c  e00a              B        |L108.164|
00008e  6922              LDR      r2,[r4,#0x10]         ;6212
000090  68a1              LDR      r1,[r4,#8]            ;6212
000092  6828              LDR      r0,[r5,#0]            ;6212
000094  f7fffffe          BL       TIM_TI2_ConfigInputStage
000098  e004              B        |L108.164|
00009a  bf00              NOP                            ;6219
00009c  bf00              NOP                            ;6220
00009e  bf00              NOP                            ;6221
0000a0  e000              B        |L108.164|
                  |L108.162|
0000a2  bf00              NOP                            ;6229
                  |L108.164|
0000a4  bf00              NOP                            ;6161
0000a6  2000              MOVS     r0,#0                 ;6231
0000a8  e7d3              B        |L108.82|
;;;6233   
                          ENDP


                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;6300     */
;;;6301   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;6302   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;6303     uint32_t tmpccmr1;
;;;6304     uint32_t tmpccer;
;;;6305   
;;;6306     /* Disable the Channel 1: Reset the CC1E Bit */
;;;6307     tmpccer = TIMx->CCER;
000006  6a02              LDR      r2,[r0,#0x20]
;;;6308     TIMx->CCER &= ~TIM_CCER_CC1E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f0250501          BIC      r5,r5,#1
00000e  6205              STR      r5,[r0,#0x20]
;;;6309     tmpccmr1 = TIMx->CCMR1;
000010  6981              LDR      r1,[r0,#0x18]
;;;6310   
;;;6311     /* Set the filter */
;;;6312     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000012  f02101f0          BIC      r1,r1,#0xf0
;;;6313     tmpccmr1 |= (TIM_ICFilter << 4U);
000016  ea411104          ORR      r1,r1,r4,LSL #4
;;;6314   
;;;6315     /* Select the Polarity and set the CC1E Bit */
;;;6316     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00001a  f022020a          BIC      r2,r2,#0xa
;;;6317     tmpccer |= TIM_ICPolarity;
00001e  431a              ORRS     r2,r2,r3
;;;6318   
;;;6319     /* Write to TIMx CCMR1 and CCER registers */
;;;6320     TIMx->CCMR1 = tmpccmr1;
000020  6181              STR      r1,[r0,#0x18]
;;;6321     TIMx->CCER = tmpccer;
000022  6202              STR      r2,[r0,#0x20]
;;;6322   }
000024  bd30              POP      {r4,r5,pc}
;;;6323   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;6253     */
;;;6254   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;6255                          uint32_t TIM_ICFilter)
;;;6256   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;6257     uint32_t tmpccmr1;
;;;6258     uint32_t tmpccer;
;;;6259   
;;;6260     /* Disable the Channel 1: Reset the CC1E Bit */
;;;6261     TIMx->CCER &= ~TIM_CCER_CC1E;
000006  6a06              LDR      r6,[r0,#0x20]
000008  f0260601          BIC      r6,r6,#1
00000c  6206              STR      r6,[r0,#0x20]
;;;6262     tmpccmr1 = TIMx->CCMR1;
00000e  6981              LDR      r1,[r0,#0x18]
;;;6263     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;6264   
;;;6265     /* Select the Input */
;;;6266     if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000012  4e15              LDR      r6,|L110.104|
000014  42b0              CMP      r0,r6
000016  d00e              BEQ      |L110.54|
000018  f1b04f80          CMP      r0,#0x40000000
00001c  d00b              BEQ      |L110.54|
00001e  4e13              LDR      r6,|L110.108|
000020  42b0              CMP      r0,r6
000022  d008              BEQ      |L110.54|
000024  4e12              LDR      r6,|L110.112|
000026  42b0              CMP      r0,r6
000028  d005              BEQ      |L110.54|
00002a  4e12              LDR      r6,|L110.116|
00002c  42b0              CMP      r0,r6
00002e  d002              BEQ      |L110.54|
000030  4e11              LDR      r6,|L110.120|
000032  42b0              CMP      r0,r6
000034  d101              BNE      |L110.58|
                  |L110.54|
000036  2601              MOVS     r6,#1
000038  e000              B        |L110.60|
                  |L110.58|
00003a  2600              MOVS     r6,#0
                  |L110.60|
00003c  b11e              CBZ      r6,|L110.70|
;;;6267     {
;;;6268       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00003e  f0210103          BIC      r1,r1,#3
;;;6269       tmpccmr1 |= TIM_ICSelection;
000042  4329              ORRS     r1,r1,r5
000044  e001              B        |L110.74|
                  |L110.70|
;;;6270     }
;;;6271     else
;;;6272     {
;;;6273       tmpccmr1 |= TIM_CCMR1_CC1S_0;
000046  f0410101          ORR      r1,r1,#1
                  |L110.74|
;;;6274     }
;;;6275   
;;;6276     /* Set the filter */
;;;6277     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00004a  f02101f0          BIC      r1,r1,#0xf0
;;;6278     tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
00004e  26f0              MOVS     r6,#0xf0
000050  ea061603          AND      r6,r6,r3,LSL #4
000054  4331              ORRS     r1,r1,r6
;;;6279   
;;;6280     /* Select the Polarity and set the CC1E Bit */
;;;6281     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000056  f022020a          BIC      r2,r2,#0xa
;;;6282     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
00005a  f004060a          AND      r6,r4,#0xa
00005e  4332              ORRS     r2,r2,r6
;;;6283   
;;;6284     /* Write to TIMx CCMR1 and CCER registers */
;;;6285     TIMx->CCMR1 = tmpccmr1;
000060  6181              STR      r1,[r0,#0x18]
;;;6286     TIMx->CCER = tmpccer;
000062  6202              STR      r2,[r0,#0x20]
;;;6287   }
000064  bd70              POP      {r4-r6,pc}
;;;6288   
                          ENDP

000066  0000              DCW      0x0000
                  |L110.104|
                          DCD      0x40010000
                  |L110.108|
                          DCD      0x40000400
                  |L110.112|
                          DCD      0x40000800
                  |L110.116|
                          DCD      0x40000c00
                  |L110.120|
                          DCD      0x40014000

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;6383     */
;;;6384   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;6385   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;6386     uint32_t tmpccmr1;
;;;6387     uint32_t tmpccer;
;;;6388   
;;;6389     /* Disable the Channel 2: Reset the CC2E Bit */
;;;6390     TIMx->CCER &= ~TIM_CCER_CC2E;
000006  6a05              LDR      r5,[r0,#0x20]
000008  f0250510          BIC      r5,r5,#0x10
00000c  6205              STR      r5,[r0,#0x20]
;;;6391     tmpccmr1 = TIMx->CCMR1;
00000e  6981              LDR      r1,[r0,#0x18]
;;;6392     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;6393   
;;;6394     /* Set the filter */
;;;6395     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000012  f4214170          BIC      r1,r1,#0xf000
;;;6396     tmpccmr1 |= (TIM_ICFilter << 12U);
000016  ea413104          ORR      r1,r1,r4,LSL #12
;;;6397   
;;;6398     /* Select the Polarity and set the CC2E Bit */
;;;6399     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00001a  f02202a0          BIC      r2,r2,#0xa0
;;;6400     tmpccer |= (TIM_ICPolarity << 4U);
00001e  ea421203          ORR      r2,r2,r3,LSL #4
;;;6401   
;;;6402     /* Write to TIMx CCMR1 and CCER registers */
;;;6403     TIMx->CCMR1 = tmpccmr1 ;
000022  6181              STR      r1,[r0,#0x18]
;;;6404     TIMx->CCER = tmpccer;
000024  6202              STR      r2,[r0,#0x20]
;;;6405   }
000026  bd30              POP      {r4,r5,pc}
;;;6406   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;6343     */
;;;6344   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;6345                                 uint32_t TIM_ICFilter)
;;;6346   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;6347     uint32_t tmpccmr1;
;;;6348     uint32_t tmpccer;
;;;6349   
;;;6350     /* Disable the Channel 2: Reset the CC2E Bit */
;;;6351     TIMx->CCER &= ~TIM_CCER_CC2E;
000006  6a06              LDR      r6,[r0,#0x20]
000008  f0260610          BIC      r6,r6,#0x10
00000c  6206              STR      r6,[r0,#0x20]
;;;6352     tmpccmr1 = TIMx->CCMR1;
00000e  6981              LDR      r1,[r0,#0x18]
;;;6353     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;6354   
;;;6355     /* Select the Input */
;;;6356     tmpccmr1 &= ~TIM_CCMR1_CC2S;
000012  f4217140          BIC      r1,r1,#0x300
;;;6357     tmpccmr1 |= (TIM_ICSelection << 8U);
000016  ea412105          ORR      r1,r1,r5,LSL #8
;;;6358   
;;;6359     /* Set the filter */
;;;6360     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00001a  f4214170          BIC      r1,r1,#0xf000
;;;6361     tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
00001e  f44f4670          MOV      r6,#0xf000
000022  ea063603          AND      r6,r6,r3,LSL #12
000026  4331              ORRS     r1,r1,r6
;;;6362   
;;;6363     /* Select the Polarity and set the CC2E Bit */
;;;6364     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000028  f02202a0          BIC      r2,r2,#0xa0
;;;6365     tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
00002c  26a0              MOVS     r6,#0xa0
00002e  ea061604          AND      r6,r6,r4,LSL #4
000032  4332              ORRS     r2,r2,r6
;;;6366   
;;;6367     /* Write to TIMx CCMR1 and CCER registers */
;;;6368     TIMx->CCMR1 = tmpccmr1 ;
000034  6181              STR      r1,[r0,#0x18]
;;;6369     TIMx->CCER = tmpccer;
000036  6202              STR      r2,[r0,#0x20]
;;;6370   }
000038  bd70              POP      {r4-r6,pc}
;;;6371   
                          ENDP


                          AREA ||i.TIM_TI3_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI3_SetConfig PROC
;;;6426     */
;;;6427   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;6428                                 uint32_t TIM_ICFilter)
;;;6429   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;6430     uint32_t tmpccmr2;
;;;6431     uint32_t tmpccer;
;;;6432   
;;;6433     /* Disable the Channel 3: Reset the CC3E Bit */
;;;6434     TIMx->CCER &= ~TIM_CCER_CC3E;
000006  6a06              LDR      r6,[r0,#0x20]
000008  f4267680          BIC      r6,r6,#0x100
00000c  6206              STR      r6,[r0,#0x20]
;;;6435     tmpccmr2 = TIMx->CCMR2;
00000e  69c1              LDR      r1,[r0,#0x1c]
;;;6436     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;6437   
;;;6438     /* Select the Input */
;;;6439     tmpccmr2 &= ~TIM_CCMR2_CC3S;
000012  f0210103          BIC      r1,r1,#3
;;;6440     tmpccmr2 |= TIM_ICSelection;
000016  4329              ORRS     r1,r1,r5
;;;6441   
;;;6442     /* Set the filter */
;;;6443     tmpccmr2 &= ~TIM_CCMR2_IC3F;
000018  f02101f0          BIC      r1,r1,#0xf0
;;;6444     tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
00001c  26f0              MOVS     r6,#0xf0
00001e  ea061603          AND      r6,r6,r3,LSL #4
000022  4331              ORRS     r1,r1,r6
;;;6445   
;;;6446     /* Select the Polarity and set the CC3E Bit */
;;;6447     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000024  f4226220          BIC      r2,r2,#0xa00
;;;6448     tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
000028  f44f6620          MOV      r6,#0xa00
00002c  ea062604          AND      r6,r6,r4,LSL #8
000030  4332              ORRS     r2,r2,r6
;;;6449   
;;;6450     /* Write to TIMx CCMR2 and CCER registers */
;;;6451     TIMx->CCMR2 = tmpccmr2;
000032  61c1              STR      r1,[r0,#0x1c]
;;;6452     TIMx->CCER = tmpccer;
000034  6202              STR      r2,[r0,#0x20]
;;;6453   }
000036  bd70              POP      {r4-r6,pc}
;;;6454   
                          ENDP


                          AREA ||i.TIM_TI4_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI4_SetConfig PROC
;;;6474     */
;;;6475   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;6476                                 uint32_t TIM_ICFilter)
;;;6477   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;6478     uint32_t tmpccmr2;
;;;6479     uint32_t tmpccer;
;;;6480   
;;;6481     /* Disable the Channel 4: Reset the CC4E Bit */
;;;6482     TIMx->CCER &= ~TIM_CCER_CC4E;
000006  6a06              LDR      r6,[r0,#0x20]
000008  f4265680          BIC      r6,r6,#0x1000
00000c  6206              STR      r6,[r0,#0x20]
;;;6483     tmpccmr2 = TIMx->CCMR2;
00000e  69c1              LDR      r1,[r0,#0x1c]
;;;6484     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;6485   
;;;6486     /* Select the Input */
;;;6487     tmpccmr2 &= ~TIM_CCMR2_CC4S;
000012  f4217140          BIC      r1,r1,#0x300
;;;6488     tmpccmr2 |= (TIM_ICSelection << 8U);
000016  ea412105          ORR      r1,r1,r5,LSL #8
;;;6489   
;;;6490     /* Set the filter */
;;;6491     tmpccmr2 &= ~TIM_CCMR2_IC4F;
00001a  f4214170          BIC      r1,r1,#0xf000
;;;6492     tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
00001e  f44f4670          MOV      r6,#0xf000
000022  ea063603          AND      r6,r6,r3,LSL #12
000026  4331              ORRS     r1,r1,r6
;;;6493   
;;;6494     /* Select the Polarity and set the CC4E Bit */
;;;6495     tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
000028  f4224220          BIC      r2,r2,#0xa000
;;;6496     tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
00002c  f44f4620          MOV      r6,#0xa000
000030  ea063604          AND      r6,r6,r4,LSL #12
000034  4332              ORRS     r2,r2,r6
;;;6497   
;;;6498     /* Write to TIMx CCMR2 and CCER registers */
;;;6499     TIMx->CCMR2 = tmpccmr2;
000036  61c1              STR      r1,[r0,#0x1c]
;;;6500     TIMx->CCER = tmpccer ;
000038  6202              STR      r2,[r0,#0x20]
;;;6501   }
00003a  bd70              POP      {r4-r6,pc}
;;;6502   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
