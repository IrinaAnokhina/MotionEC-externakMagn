; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\motionec_manager.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\motionec_manager.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\Src\MotionEC_Manager.c]
                          THUMB

                          AREA ||i.MotionEC_manager_get_version||, CODE, READONLY, ALIGN=1

                  MotionEC_manager_get_version PROC
;;;177     */
;;;178    void MotionEC_manager_get_version(char *version, int *length)
000000  b570              PUSH     {r4-r6,lr}
;;;179    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;180      *length = (int)MotionEC_GetLibVersion(version);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       MotionEC_GetLibVersion
00000c  6020              STR      r0,[r4,#0]
;;;181    }
00000e  bd70              POP      {r4-r6,pc}
;;;182    
                          ENDP


                          AREA ||i.MotionEC_manager_init||, CODE, READONLY, ALIGN=1

                  MotionEC_manager_init PROC
;;;81      */
;;;82     void MotionEC_manager_init(float freq)
000000  b510              PUSH     {r4,lr}
;;;83     {
000002  ed2d0b02          VPUSH    {d0}
;;;84       MotionEC_Initialize(&freq);
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       MotionEC_Initialize
;;;85       MotionEC_SetOrientationEnable(MEC_ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       MotionEC_SetOrientationEnable
;;;86       MotionEC_SetVirtualGyroEnable(MEC_ENABLE);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       MotionEC_SetVirtualGyroEnable
;;;87       MotionEC_SetGravityEnable(MEC_ENABLE);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       MotionEC_SetGravityEnable
;;;88       MotionEC_SetLinearAccEnable(MEC_ENABLE);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       MotionEC_SetLinearAccEnable
;;;89     }
000024  bd1c              POP      {r2-r4,pc}
;;;90     
                          ENDP


                          AREA ||i.MotionEC_manager_run||, CODE, READONLY, ALIGN=2

                  MotionEC_manager_run PROC
;;;95      */
;;;96     void MotionEC_manager_run(TMsg *Msg)
000000  b530              PUSH     {r4,r5,lr}
;;;97     {
000002  b09f              SUB      sp,sp,#0x7c
000004  4604              MOV      r4,r0
;;;98       MEC_input_t  data_in;
;;;99       MEC_output_t data_out;
;;;100    
;;;101      if ((SensorsEnabled & ACCELEROMETER_SENSOR) != ACCELEROMETER_SENSOR)
000006  4877              LDR      r0,|L3.484|
000008  7800              LDRB     r0,[r0,#0]  ; SensorsEnabled
00000a  f0000010          AND      r0,r0,#0x10
00000e  2810              CMP      r0,#0x10
000010  d001              BEQ      |L3.22|
                  |L3.18|
;;;102      {
;;;103        return;
;;;104      }
;;;105    
;;;106      if ((SensorsEnabled & MAGNETIC_SENSOR) != MAGNETIC_SENSOR)
;;;107      {
;;;108        return;
;;;109      }
;;;110    
;;;111      //Do sensor orientation transformation 
;;;112    #if (defined (USE_IKS01A2))
;;;113      transform_xyz_to_enu(&AccValue, data_in.acc, LSM303AGR_0_Matrix);
;;;114      transform_xyz_to_enu(&MagValueComp, data_in.mag, LSM303AGR_0_Matrix);
;;;115    
;;;116    #else
;;;117    #error "ERROR: Unknown MEMS shield!"
;;;118    #endif
;;;119    
;;;120      /* Raw accelerometer data [g] */
;;;121      data_in.acc[0] = data_in.acc[0] / 1000.0f; /* East */
;;;122      data_in.acc[1] = data_in.acc[1] / 1000.0f; /* North */
;;;123      data_in.acc[2] = data_in.acc[2] / 1000.0f; /* Up */
;;;124    
;;;125      /* Compensated magnetometer data [uT / 50], [mGauss / 5] */
;;;126      data_in.mag[0] = data_in.mag[0] / 5.0f; /* East */
;;;127      data_in.mag[1] = data_in.mag[1] / 5.0f; /* North */
;;;128      data_in.mag[2] = data_in.mag[2] / 5.0f; /* Up */
;;;129    
;;;130      /* Delta time [s] */
;;;131      data_in.deltatime_s = (float)ALGO_PERIOD / 1000.0f;
;;;132    
;;;133      /* Run E-Compass algorithm */
;;;134      BSP_LED_On(LED2);
;;;135      MotionEC_Run(&data_in, &data_out);
;;;136      BSP_LED_Off(LED2);
;;;137    
;;;138      /* Write data to output stream */
;;;139      FloatToArray(&Msg->Data[55], data_out.quaternion[0]);
;;;140      FloatToArray(&Msg->Data[59], data_out.quaternion[1]);
;;;141      FloatToArray(&Msg->Data[63], data_out.quaternion[2]);
;;;142      FloatToArray(&Msg->Data[67], data_out.quaternion[3]);
;;;143    
;;;144      FloatToArray(&Msg->Data[71], data_out.euler[0]);
;;;145      FloatToArray(&Msg->Data[75], data_out.euler[1]);
;;;146      FloatToArray(&Msg->Data[79], data_out.euler[2]);
;;;147    
;;;148      FloatToArray(&Msg->Data[83], data_out.i_gyro[0]);
;;;149      FloatToArray(&Msg->Data[87], data_out.i_gyro[1]);
;;;150      FloatToArray(&Msg->Data[91], data_out.i_gyro[2]);
;;;151    
;;;152      FloatToArray(&Msg->Data[95], data_out.gravity[0]);
;;;153      FloatToArray(&Msg->Data[99], data_out.gravity[1]);
;;;154      FloatToArray(&Msg->Data[103], data_out.gravity[2]);
;;;155    
;;;156      FloatToArray(&Msg->Data[107], data_out.linear[0]);
;;;157      FloatToArray(&Msg->Data[111], data_out.linear[1]);
;;;158      FloatToArray(&Msg->Data[115], data_out.linear[2]);
;;;159    
;;;160      float v_base[3] = {0.0, 1.0, 0.0};
;;;161      float v_head[3];
;;;162      float heading;
;;;163      int heading_valid;
;;;164    
;;;165      v_rotate(v_head, data_out.quaternion, v_base);
;;;166      heading_valid = calc_heading(&heading, v_head);
;;;167    
;;;168      FloatToArray(&Msg->Data[119], heading);
;;;169      Msg->Data[123] = (uint8_t)heading_valid;
;;;170    }
000012  b01f              ADD      sp,sp,#0x7c
000014  bd30              POP      {r4,r5,pc}
                  |L3.22|
000016  4873              LDR      r0,|L3.484|
000018  7800              LDRB     r0,[r0,#0]            ;106  ; SensorsEnabled
00001a  f0000040          AND      r0,r0,#0x40           ;106
00001e  2840              CMP      r0,#0x40              ;106
000020  d000              BEQ      |L3.36|
000022  e7f6              B        |L3.18|
                  |L3.36|
000024  4a70              LDR      r2,|L3.488|
000026  a918              ADD      r1,sp,#0x60           ;113
000028  4870              LDR      r0,|L3.492|
00002a  f7fffffe          BL       transform_xyz_to_enu
00002e  4a6e              LDR      r2,|L3.488|
000030  a91b              ADD      r1,sp,#0x6c           ;114
000032  486f              LDR      r0,|L3.496|
000034  f7fffffe          BL       transform_xyz_to_enu
000038  ed9d0a18          VLDR     s0,[sp,#0x60]         ;121
00003c  eddf0a6d          VLDR     s1,|L3.500|
000040  ee801a20          VDIV.F32 s2,s0,s1              ;121
000044  ed8d1a18          VSTR     s2,[sp,#0x60]         ;121
000048  ed9d0a19          VLDR     s0,[sp,#0x64]         ;122
00004c  eddf0a69          VLDR     s1,|L3.500|
000050  ee801a20          VDIV.F32 s2,s0,s1              ;122
000054  ed8d1a19          VSTR     s2,[sp,#0x64]         ;122
000058  ed9d0a1a          VLDR     s0,[sp,#0x68]         ;123
00005c  eddf0a65          VLDR     s1,|L3.500|
000060  ee801a20          VDIV.F32 s2,s0,s1              ;123
000064  ed8d1a1a          VSTR     s2,[sp,#0x68]         ;123
000068  ed9d0a1b          VLDR     s0,[sp,#0x6c]         ;126
00006c  eef10a04          VMOV.F32 s1,#5.00000000        ;126
000070  ee801a20          VDIV.F32 s2,s0,s1              ;126
000074  ed8d1a1b          VSTR     s2,[sp,#0x6c]         ;126
000078  ed9d0a1c          VLDR     s0,[sp,#0x70]         ;127
00007c  eef10a04          VMOV.F32 s1,#5.00000000        ;127
000080  ee801a20          VDIV.F32 s2,s0,s1              ;127
000084  ed8d1a1c          VSTR     s2,[sp,#0x70]         ;127
000088  ed9d0a1d          VLDR     s0,[sp,#0x74]         ;128
00008c  eef10a04          VMOV.F32 s1,#5.00000000        ;128
000090  ee801a20          VDIV.F32 s2,s0,s1              ;128
000094  ed8d1a1d          VSTR     s2,[sp,#0x74]         ;128
000098  ed9f0a57          VLDR     s0,|L3.504|
00009c  ed8d0a1e          VSTR     s0,[sp,#0x78]         ;131
0000a0  2000              MOVS     r0,#0                 ;134
0000a2  f7fffffe          BL       BSP_LED_On
0000a6  a908              ADD      r1,sp,#0x20           ;135
0000a8  a818              ADD      r0,sp,#0x60           ;135
0000aa  f7fffffe          BL       MotionEC_Run
0000ae  2000              MOVS     r0,#0                 ;136
0000b0  f7fffffe          BL       BSP_LED_Off
0000b4  eddd0a08          VLDR     s1,[sp,#0x20]         ;139
0000b8  eeb00a60          VMOV.F32 s0,s1                 ;139
0000bc  f104003b          ADD      r0,r4,#0x3b           ;139
0000c0  f7fffffe          BL       FloatToArray
0000c4  eddd0a09          VLDR     s1,[sp,#0x24]         ;140
0000c8  eeb00a60          VMOV.F32 s0,s1                 ;140
0000cc  f104003f          ADD      r0,r4,#0x3f           ;140
0000d0  f7fffffe          BL       FloatToArray
0000d4  eddd0a0a          VLDR     s1,[sp,#0x28]         ;141
0000d8  eeb00a60          VMOV.F32 s0,s1                 ;141
0000dc  f1040043          ADD      r0,r4,#0x43           ;141
0000e0  f7fffffe          BL       FloatToArray
0000e4  eddd0a0b          VLDR     s1,[sp,#0x2c]         ;142
0000e8  eeb00a60          VMOV.F32 s0,s1                 ;142
0000ec  f1040047          ADD      r0,r4,#0x47           ;142
0000f0  f7fffffe          BL       FloatToArray
0000f4  eddd0a0c          VLDR     s1,[sp,#0x30]         ;144
0000f8  eeb00a60          VMOV.F32 s0,s1                 ;144
0000fc  f104004b          ADD      r0,r4,#0x4b           ;144
000100  f7fffffe          BL       FloatToArray
000104  eddd0a0d          VLDR     s1,[sp,#0x34]         ;145
000108  eeb00a60          VMOV.F32 s0,s1                 ;145
00010c  f104004f          ADD      r0,r4,#0x4f           ;145
000110  f7fffffe          BL       FloatToArray
000114  eddd0a0e          VLDR     s1,[sp,#0x38]         ;146
000118  eeb00a60          VMOV.F32 s0,s1                 ;146
00011c  f1040053          ADD      r0,r4,#0x53           ;146
000120  f7fffffe          BL       FloatToArray
000124  eddd0a0f          VLDR     s1,[sp,#0x3c]         ;148
000128  eeb00a60          VMOV.F32 s0,s1                 ;148
00012c  f1040057          ADD      r0,r4,#0x57           ;148
000130  f7fffffe          BL       FloatToArray
000134  eddd0a10          VLDR     s1,[sp,#0x40]         ;149
000138  eeb00a60          VMOV.F32 s0,s1                 ;149
00013c  f104005b          ADD      r0,r4,#0x5b           ;149
000140  f7fffffe          BL       FloatToArray
000144  eddd0a11          VLDR     s1,[sp,#0x44]         ;150
000148  eeb00a60          VMOV.F32 s0,s1                 ;150
00014c  f104005f          ADD      r0,r4,#0x5f           ;150
000150  f7fffffe          BL       FloatToArray
000154  eddd0a12          VLDR     s1,[sp,#0x48]         ;152
000158  eeb00a60          VMOV.F32 s0,s1                 ;152
00015c  f1040063          ADD      r0,r4,#0x63           ;152
000160  f7fffffe          BL       FloatToArray
000164  eddd0a13          VLDR     s1,[sp,#0x4c]         ;153
000168  eeb00a60          VMOV.F32 s0,s1                 ;153
00016c  f1040067          ADD      r0,r4,#0x67           ;153
000170  f7fffffe          BL       FloatToArray
000174  eddd0a14          VLDR     s1,[sp,#0x50]         ;154
000178  eeb00a60          VMOV.F32 s0,s1                 ;154
00017c  f104006b          ADD      r0,r4,#0x6b           ;154
000180  f7fffffe          BL       FloatToArray
000184  eddd0a15          VLDR     s1,[sp,#0x54]         ;156
000188  eeb00a60          VMOV.F32 s0,s1                 ;156
00018c  f104006f          ADD      r0,r4,#0x6f           ;156
000190  f7fffffe          BL       FloatToArray
000194  eddd0a16          VLDR     s1,[sp,#0x58]         ;157
000198  eeb00a60          VMOV.F32 s0,s1                 ;157
00019c  f1040073          ADD      r0,r4,#0x73           ;157
0001a0  f7fffffe          BL       FloatToArray
0001a4  eddd0a17          VLDR     s1,[sp,#0x5c]         ;158
0001a8  eeb00a60          VMOV.F32 s0,s1                 ;158
0001ac  f1040077          ADD      r0,r4,#0x77           ;158
0001b0  f7fffffe          BL       FloatToArray
0001b4  4a11              LDR      r2,|L3.508|
0001b6  ca07              LDM      r2,{r0-r2}            ;160
0001b8  ab05              ADD      r3,sp,#0x14           ;160
0001ba  c307              STM      r3!,{r0-r2}           ;160
0001bc  aa05              ADD      r2,sp,#0x14           ;165
0001be  a908              ADD      r1,sp,#0x20           ;165
0001c0  a802              ADD      r0,sp,#8              ;165
0001c2  f7fffffe          BL       v_rotate
0001c6  a902              ADD      r1,sp,#8              ;166
0001c8  a801              ADD      r0,sp,#4              ;166
0001ca  f7fffffe          BL       calc_heading
0001ce  4605              MOV      r5,r0                 ;166
0001d0  ed9d0a01          VLDR     s0,[sp,#4]            ;168
0001d4  f104007b          ADD      r0,r4,#0x7b           ;168
0001d8  f7fffffe          BL       FloatToArray
0001dc  f884507f          STRB     r5,[r4,#0x7f]         ;169
0001e0  bf00              NOP      
0001e2  e716              B        |L3.18|
;;;171    
                          ENDP

                  |L3.484|
                          DCD      SensorsEnabled
                  |L3.488|
                          DCD      LSM303AGR_0_Matrix
                  |L3.492|
                          DCD      AccValue
                  |L3.496|
                          DCD      MagValueComp
                  |L3.500|
0001f4  447a0000          DCFS     0x447a0000 ; 1000
                  |L3.504|
0001f8  3ca3d70a          DCFS     0x3ca3d70a ; 0.019999999552965164
                  |L3.508|
                          DCD      ||.constdata||

                          AREA ||i.calc_heading||, CODE, READONLY, ALIGN=2

                  calc_heading PROC
;;;189     */
;;;190    static int calc_heading(float *heading, float v_head[])
000000  b570              PUSH     {r4-r6,lr}
;;;191    {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;192      const float tol_deg = 5.0f; /* Tolerance [deg] */
00000a  eeb10a04          VMOV.F32 s0,#5.00000000
00000e  eef08a40          VMOV.F32 s17,s0
;;;193      float tolerance = sinf(tol_deg * M_PI / 180.0f);
000012  ed9f0a36          VLDR     s0,|L4.236|
000016  f7fffffe          BL       __hardfp_sinf
00001a  eeb08a40          VMOV.F32 s16,s0
;;;194    
;;;195      if (v_head[0] > (-1.0f) * tolerance && v_head[0] < tolerance
00001e  ed950a00          VLDR     s0,[r5,#0]
000022  eeff0a00          VMOV.F32 s1,#-1.00000000
000026  ee680a20          VMUL.F32 s1,s16,s1
00002a  eeb40ae0          VCMPE.F32 s0,s1
00002e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000032  dd20              BLE      |L4.118|
000034  ed950a00          VLDR     s0,[r5,#0]
000038  eeb40ac8          VCMPE.F32 s0,s16
00003c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000040  d219              BCS      |L4.118|
;;;196          && v_head[1] > (-1.0f) * tolerance && v_head[1] < tolerance)
000042  ed950a01          VLDR     s0,[r5,#4]
000046  eeff0a00          VMOV.F32 s1,#-1.00000000
00004a  ee680a20          VMUL.F32 s1,s16,s1
00004e  eeb40ae0          VCMPE.F32 s0,s1
000052  eef1fa10          VMRS     APSR_nzcv,FPSCR
000056  dd0e              BLE      |L4.118|
000058  ed950a01          VLDR     s0,[r5,#4]
00005c  eeb40ac8          VCMPE.F32 s0,s16
000060  eef1fa10          VMRS     APSR_nzcv,FPSCR
000064  d207              BCS      |L4.118|
;;;197      {
;;;198        *heading = 0.0f;
000066  ed9f0a22          VLDR     s0,|L4.240|
00006a  ed840a00          VSTR     s0,[r4,#0]
;;;199        return 0; /* Device is pointing up or down - it is impossible to evaluate heading */
00006e  2000              MOVS     r0,#0
                  |L4.112|
;;;200      }
;;;201    
;;;202      else
;;;203      {
;;;204        *heading = atan2f(v_head[0], v_head[1]) * 180.0f / M_PI;
;;;205        *heading = floorf(*heading * 100.0f + 0.5f) / 100.0f;          /* Rounds number to two decimal digits */
;;;206        *heading = (*heading < 0.0f) ? (*heading + 360.0f) : *heading; /* Change negative value to be in range <0,360) */
;;;207        return 1;
;;;208      }
;;;209    }
000070  ecbd8b02          VPOP     {d8}
000074  bd70              POP      {r4-r6,pc}
                  |L4.118|
000076  ed951a01          VLDR     s2,[r5,#4]            ;204
00007a  eef00a41          VMOV.F32 s1,s2                 ;204
00007e  ed951a00          VLDR     s2,[r5,#0]            ;204
000082  eeb00a41          VMOV.F32 s0,s2                 ;204
000086  f7fffffe          BL       __hardfp_atan2f
00008a  eddf0a1a          VLDR     s1,|L4.244|
00008e  ee200a20          VMUL.F32 s0,s0,s1              ;204
000092  eddf0a19          VLDR     s1,|L4.248|
000096  ee801a20          VDIV.F32 s2,s0,s1              ;204
00009a  ed841a00          VSTR     s2,[r4,#0]            ;204
00009e  ed941a00          VLDR     s2,[r4,#0]            ;205
0000a2  eddf1a16          VLDR     s3,|L4.252|
0000a6  eef60a00          VMOV.F32 s1,#0.50000000        ;205
0000aa  ee410a21          VMLA.F32 s1,s2,s3              ;205
0000ae  eeb00a60          VMOV.F32 s0,s1                 ;205
0000b2  f7fffffe          BL       __hardfp_floorf
0000b6  eddf0a11          VLDR     s1,|L4.252|
0000ba  ee801a20          VDIV.F32 s2,s0,s1              ;205
0000be  ed841a00          VSTR     s2,[r4,#0]            ;205
0000c2  ed940a00          VLDR     s0,[r4,#0]            ;206
0000c6  eeb50ac0          VCMPE.F32 s0,#0.0               ;206
0000ca  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;206
0000ce  d206              BCS      |L4.222|
0000d0  ed940a00          VLDR     s0,[r4,#0]            ;206
0000d4  eddf0a0a          VLDR     s1,|L4.256|
0000d8  ee300a20          VADD.F32 s0,s0,s1              ;206
0000dc  e001              B        |L4.226|
                  |L4.222|
0000de  ed940a00          VLDR     s0,[r4,#0]            ;206
                  |L4.226|
0000e2  ed840a00          VSTR     s0,[r4,#0]            ;206
0000e6  2001              MOVS     r0,#1                 ;207
0000e8  e7c2              B        |L4.112|
;;;210    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L4.236|
0000ec  3db2b8c4          DCFS     0x3db2b8c4 ; 0.087266474962234497
                  |L4.240|
0000f0  00000000          DCFS     0x00000000 ; 0
                  |L4.244|
0000f4  43340000          DCFS     0x43340000 ; 180
                  |L4.248|
0000f8  40490fdc          DCFS     0x40490fdc ; 3.1415929794311523
                  |L4.252|
0000fc  42c80000          DCFS     0x42c80000 ; 100
                  |L4.256|
000100  43b40000          DCFS     0x43b40000 ; 360

                          AREA ||i.q_conjug||, CODE, READONLY, ALIGN=1

                  q_conjug PROC
;;;216     */
;;;217    static void q_conjug(float q_conj[], float q_src[])
000000  ed910a00          VLDR     s0,[r1,#0]
;;;218    {
;;;219      q_conj[0] = (-1.0f) * q_src[0];
000004  eeff0a00          VMOV.F32 s1,#-1.00000000
000008  ee200a20          VMUL.F32 s0,s0,s1
00000c  ed800a00          VSTR     s0,[r0,#0]
;;;220      q_conj[1] = (-1.0f) * q_src[1];
000010  ed910a01          VLDR     s0,[r1,#4]
000014  eeff0a00          VMOV.F32 s1,#-1.00000000
000018  ee200a20          VMUL.F32 s0,s0,s1
00001c  ed800a01          VSTR     s0,[r0,#4]
;;;221      q_conj[2] = (-1.0f) * q_src[2];
000020  ed910a02          VLDR     s0,[r1,#8]
000024  eeff0a00          VMOV.F32 s1,#-1.00000000
000028  ee200a20          VMUL.F32 s0,s0,s1
00002c  ed800a02          VSTR     s0,[r0,#8]
;;;222      q_conj[3] =           q_src[3];
000030  ed910a03          VLDR     s0,[r1,#0xc]
000034  ed800a03          VSTR     s0,[r0,#0xc]
;;;223    
;;;224      return;
;;;225    }
000038  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i.q_multiply||, CODE, READONLY, ALIGN=1

                  q_multiply PROC
;;;233     */
;;;234    static void q_multiply(float q_res[], float q_a[], float q_b[])
000000  ed910a03          VLDR     s0,[r1,#0xc]
;;;235    {
;;;236      q_res[0] =
000004  edd20a00          VLDR     s1,[r2,#0]
000008  ee200a20          VMUL.F32 s0,s0,s1
00000c  edd10a00          VLDR     s1,[r1,#0]
000010  ed921a03          VLDR     s2,[r2,#0xc]
000014  ee000a81          VMLA.F32 s0,s1,s2
000018  edd10a01          VLDR     s1,[r1,#4]
00001c  ed921a02          VLDR     s2,[r2,#8]
000020  ee000a81          VMLA.F32 s0,s1,s2
000024  edd10a02          VLDR     s1,[r1,#8]
000028  ed921a01          VLDR     s2,[r2,#4]
00002c  ee000ac1          VMLS.F32 s0,s1,s2
000030  ed800a00          VSTR     s0,[r0,#0]
;;;237        q_a[3] * q_b[0]
;;;238        + q_a[0] * q_b[3]
;;;239        + q_a[1] * q_b[2]
;;;240        - q_a[2] * q_b[1]
;;;241        ;
;;;242    
;;;243      q_res[1] =
000034  ed910a03          VLDR     s0,[r1,#0xc]
000038  edd20a01          VLDR     s1,[r2,#4]
00003c  ee200a20          VMUL.F32 s0,s0,s1
000040  edd10a01          VLDR     s1,[r1,#4]
000044  ed921a03          VLDR     s2,[r2,#0xc]
000048  ee000a81          VMLA.F32 s0,s1,s2
00004c  edd10a02          VLDR     s1,[r1,#8]
000050  ed921a00          VLDR     s2,[r2,#0]
000054  ee000a81          VMLA.F32 s0,s1,s2
000058  edd10a00          VLDR     s1,[r1,#0]
00005c  ed921a02          VLDR     s2,[r2,#8]
000060  ee000ac1          VMLS.F32 s0,s1,s2
000064  ed800a01          VSTR     s0,[r0,#4]
;;;244        q_a[3] * q_b[1]
;;;245        + q_a[1] * q_b[3]
;;;246        + q_a[2] * q_b[0]
;;;247        - q_a[0] * q_b[2]
;;;248        ;
;;;249    
;;;250      q_res[2] =
000068  ed910a03          VLDR     s0,[r1,#0xc]
00006c  edd20a02          VLDR     s1,[r2,#8]
000070  ee200a20          VMUL.F32 s0,s0,s1
000074  edd10a02          VLDR     s1,[r1,#8]
000078  ed921a03          VLDR     s2,[r2,#0xc]
00007c  ee000a81          VMLA.F32 s0,s1,s2
000080  edd10a00          VLDR     s1,[r1,#0]
000084  ed921a01          VLDR     s2,[r2,#4]
000088  ee000a81          VMLA.F32 s0,s1,s2
00008c  edd10a01          VLDR     s1,[r1,#4]
000090  ed921a00          VLDR     s2,[r2,#0]
000094  ee000ac1          VMLS.F32 s0,s1,s2
000098  ed800a02          VSTR     s0,[r0,#8]
;;;251        q_a[3] * q_b[2]
;;;252        + q_a[2] * q_b[3]
;;;253        + q_a[0] * q_b[1]
;;;254        - q_a[1] * q_b[0]
;;;255        ;
;;;256    
;;;257      q_res[3] =
00009c  ed910a03          VLDR     s0,[r1,#0xc]
0000a0  edd20a03          VLDR     s1,[r2,#0xc]
0000a4  ee200a20          VMUL.F32 s0,s0,s1
0000a8  edd10a00          VLDR     s1,[r1,#0]
0000ac  ed921a00          VLDR     s2,[r2,#0]
0000b0  ee000ac1          VMLS.F32 s0,s1,s2
0000b4  edd10a01          VLDR     s1,[r1,#4]
0000b8  ed921a01          VLDR     s2,[r2,#4]
0000bc  ee000ac1          VMLS.F32 s0,s1,s2
0000c0  edd10a02          VLDR     s1,[r1,#8]
0000c4  ed921a02          VLDR     s2,[r2,#8]
0000c8  ee000ac1          VMLS.F32 s0,s1,s2
0000cc  ed800a03          VSTR     s0,[r0,#0xc]
;;;258        q_a[3] * q_b[3]
;;;259        - q_a[0] * q_b[0]
;;;260        - q_a[1] * q_b[1]
;;;261        - q_a[2] * q_b[2]
;;;262        ;
;;;263    
;;;264      return;
;;;265    }
0000d0  4770              BX       lr
;;;266    
                          ENDP


                          AREA ||i.transform_xyz_to_enu||, CODE, READONLY, ALIGN=1

                  transform_xyz_to_enu PROC
;;;271     */
;;;272    static void transform_xyz_to_enu(IKS01A2_MOTION_SENSOR_Axes_t *input, float output[], float matrix[][3])
000000  edd20a00          VLDR     s1,[r2,#0]
;;;273    {
;;;274      output[0] = matrix[0][0] * (float)input->x  +  matrix[0][1] * (float)input->y  +  matrix[0][2] * (float)input->z;
000004  ed900a00          VLDR     s0,[r0,#0]
000008  eeb80ac0          VCVT.F32.S32 s0,s0
00000c  ee200a80          VMUL.F32 s0,s1,s0
000010  ed921a01          VLDR     s2,[r2,#4]
000014  edd00a01          VLDR     s1,[r0,#4]
000018  eef80ae0          VCVT.F32.S32 s1,s1
00001c  ee010a20          VMLA.F32 s0,s2,s1
000020  ed921a02          VLDR     s2,[r2,#8]
000024  edd00a02          VLDR     s1,[r0,#8]
000028  eef80ae0          VCVT.F32.S32 s1,s1
00002c  ee010a20          VMLA.F32 s0,s2,s1
000030  ed810a00          VSTR     s0,[r1,#0]
;;;275      output[1] = matrix[1][0] * (float)input->x  +  matrix[1][1] * (float)input->y  +  matrix[1][2] * (float)input->z;
000034  edd20a03          VLDR     s1,[r2,#0xc]
000038  ed900a00          VLDR     s0,[r0,#0]
00003c  eeb80ac0          VCVT.F32.S32 s0,s0
000040  ee200a80          VMUL.F32 s0,s1,s0
000044  ed921a04          VLDR     s2,[r2,#0x10]
000048  edd00a01          VLDR     s1,[r0,#4]
00004c  eef80ae0          VCVT.F32.S32 s1,s1
000050  ee010a20          VMLA.F32 s0,s2,s1
000054  ed921a05          VLDR     s2,[r2,#0x14]
000058  edd00a02          VLDR     s1,[r0,#8]
00005c  eef80ae0          VCVT.F32.S32 s1,s1
000060  ee010a20          VMLA.F32 s0,s2,s1
000064  ed810a01          VSTR     s0,[r1,#4]
;;;276      output[2] = matrix[2][0] * (float)input->x  +  matrix[2][1] * (float)input->y  +  matrix[2][2] * (float)input->z;
000068  edd20a06          VLDR     s1,[r2,#0x18]
00006c  ed900a00          VLDR     s0,[r0,#0]
000070  eeb80ac0          VCVT.F32.S32 s0,s0
000074  ee200a80          VMUL.F32 s0,s1,s0
000078  ed921a07          VLDR     s2,[r2,#0x1c]
00007c  edd00a01          VLDR     s1,[r0,#4]
000080  eef80ae0          VCVT.F32.S32 s1,s1
000084  ee010a20          VMLA.F32 s0,s2,s1
000088  ed921a08          VLDR     s2,[r2,#0x20]
00008c  edd00a02          VLDR     s1,[r0,#8]
000090  eef80ae0          VCVT.F32.S32 s1,s1
000094  ee010a20          VMLA.F32 s0,s2,s1
000098  ed810a02          VSTR     s0,[r1,#8]
;;;277    
;;;278      return;
;;;279    }
00009c  4770              BX       lr
;;;280    
                          ENDP


                          AREA ||i.v_rotate||, CODE, READONLY, ALIGN=2

                  v_rotate PROC
;;;289     */
;;;290    static void v_rotate(float v_new[], float q_rot[], float v_old[])
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  b090              SUB      sp,sp,#0x40
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;292      float q_old[4];
;;;293      float q_new[4];
;;;294      float q_rot_inv[4];
;;;295      float q_temp[4];
;;;296    
;;;297      /* Create quaternion from old position vector */
;;;298      q_old[0] = v_old[0];
00000a  ed950a00          VLDR     s0,[r5,#0]
00000e  ed8d0a0c          VSTR     s0,[sp,#0x30]
;;;299      q_old[1] = v_old[1];
000012  ed950a01          VLDR     s0,[r5,#4]
000016  ed8d0a0d          VSTR     s0,[sp,#0x34]
;;;300      q_old[2] = v_old[2];
00001a  ed950a02          VLDR     s0,[r5,#8]
00001e  ed8d0a0e          VSTR     s0,[sp,#0x38]
;;;301      q_old[3] = 0.0f;
000022  ed9f0a10          VLDR     s0,|L8.100|
000026  ed8d0a0f          VSTR     s0,[sp,#0x3c]
;;;302    
;;;303      q_conjug(q_rot_inv, q_rot);
00002a  4631              MOV      r1,r6
00002c  a804              ADD      r0,sp,#0x10
00002e  f7fffffe          BL       q_conjug
;;;304      q_multiply(q_temp, q_old, q_rot_inv);
000032  aa04              ADD      r2,sp,#0x10
000034  a90c              ADD      r1,sp,#0x30
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       q_multiply
;;;305      q_multiply(q_new, q_rot, q_temp);
00003c  466a              MOV      r2,sp
00003e  4631              MOV      r1,r6
000040  a808              ADD      r0,sp,#0x20
000042  f7fffffe          BL       q_multiply
;;;306    
;;;307      v_new[0] = q_new[0];
000046  ed9d0a08          VLDR     s0,[sp,#0x20]
00004a  ed840a00          VSTR     s0,[r4,#0]
;;;308      v_new[1] = q_new[1];
00004e  ed9d0a09          VLDR     s0,[sp,#0x24]
000052  ed840a01          VSTR     s0,[r4,#4]
;;;309      v_new[2] = q_new[2];
000056  ed9d0a0a          VLDR     s0,[sp,#0x28]
00005a  ed840a02          VSTR     s0,[r4,#8]
;;;310    
;;;311      return;
;;;312    }
00005e  b010              ADD      sp,sp,#0x40
000060  bd70              POP      {r4-r6,pc}
;;;313    
                          ENDP

000062  0000              DCW      0x0000
                  |L8.100|
000064  00000000          DCFS     0x00000000 ; 0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00000000          DCFS     0x00000000 ; 0
000004  3f800000          DCFS     0x3f800000 ; 1
000008  00000000          DCFS     0x00000000 ; 0

                          AREA ||.data||, DATA, ALIGN=2

                  LSM303AGR_0_Matrix
000000  00000000          DCFS     0x00000000 ; 0
000004  3f800000          DCFS     0x3f800000 ; 1
000008  00000000          DCFS     0x00000000 ; 0
00000c  3f800000          DCFS     0x3f800000 ; 1
000010  00000000          DCFS     0x00000000 ; 0
000014  00000000          DCFS     0x00000000 ; 0
000018  00000000          DCFS     0x00000000 ; 0
00001c  00000000          DCFS     0x00000000 ; 0
000020  3f800000          DCFS     0x3f800000 ; 1

;*** Start embedded assembler ***

#line 1 "..\\Src\\MotionEC_Manager.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_MotionEC_Manager_c_3d939071____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___18_MotionEC_Manager_c_3d939071____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_MotionEC_Manager_c_3d939071____REVSH|
#line 402
|__asm___18_MotionEC_Manager_c_3d939071____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_MotionEC_Manager_c_3d939071____RRX|
#line 587
|__asm___18_MotionEC_Manager_c_3d939071____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
