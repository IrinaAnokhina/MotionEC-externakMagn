L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl\lsm6dsl_reg.c"
N/*
N ******************************************************************************
N * @file    lsm6dsl_reg.c
N * @author  Sensors Software Solution Team
N * @brief   LSM6DSL driver file
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright
N *      notice, this list of conditions and the following disclaimer in the
N *      documentation and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its
N *      contributors may be used to endorse or promote products derived from
N *      this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N#include "lsm6dsl_reg.h"
L 1 "..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl\lsm6dsl_reg.h" 1
N/*
N ******************************************************************************
N * @file    lsm6dsl_reg.h
N * @author  Sensors Software Solution Team
N * @brief   This file contains all the functions prototypes for the
N *          lsm6dsl_reg.c driver.
N ******************************************************************************
N * @attention
N *
N * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *   1. Redistributions of source code must retain the above copyright notice,
N *      this list of conditions and the following disclaimer.
N *   2. Redistributions in binary form must reproduce the above copyright
N *      notice, this list of conditions and the following disclaimer in the
N *      documentation and/or other materials provided with the distribution.
N *   3. Neither the name of STMicroelectronics nor the names of its
N *      contributors may be used to endorse or promote products derived from
N *      this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef LSM6DSL_DRIVER_H
N#define LSM6DSL_DRIVER_H
N
N#ifdef __cplusplus
S  extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 48 "..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl\lsm6dsl_reg.h" 2
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
N#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 1L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 49 "..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl\lsm6dsl_reg.h" 2
N
N/** @addtogroup LSM6DSL
N  * @{
N  *
N  */
N
N/** @defgroup LSM6DSL_sensors_common_types
N  * @{
N  *
N  */
N
N#ifndef MEMS_SHARED_TYPES
N#define MEMS_SHARED_TYPES
N
N/**
N  * @defgroup axisXbitXX_t
N  * @brief    These unions are useful to represent different sensors data type.
N  *           These unions are not need by the driver.
N  *
N  *           REMOVING the unions you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
N
Ntypedef union{
N  int16_t i16bit[3];
N  uint8_t u8bit[6];
N} axis3bit16_t;
N
Ntypedef union{
N  int16_t i16bit;
N  uint8_t u8bit[2];
N} axis1bit16_t;
N
Ntypedef union{
N  int32_t i32bit[3];
N  uint8_t u8bit[12];
N} axis3bit32_t;
N
Ntypedef union{
N  int32_t i32bit;
N  uint8_t u8bit[4];
N} axis1bit32_t;
N
N/**
N  * @}
N  *
N  */
N
Ntypedef struct{
N  uint8_t bit0       : 1;
N  uint8_t bit1       : 1;
N  uint8_t bit2       : 1;
N  uint8_t bit3       : 1;
N  uint8_t bit4       : 1;
N  uint8_t bit5       : 1;
N  uint8_t bit6       : 1;
N  uint8_t bit7       : 1;
N} bitwise_t;
N
N#define PROPERTY_DISABLE                (0U)
N#define PROPERTY_ENABLE                 (1U)
N
N#endif /* MEMS_SHARED_TYPES */
N
N/**
N  * @}
N  *
N  */
N
N/** @addtogroup  LSM9DS1_Interfaces_Functions
N  * @brief       This section provide a set of functions used to read and
N  *              write a generic register of the device.
N  *              MANDATORY: return 0 -> no Error.
N  * @{
N  *
N  */
N
Ntypedef int32_t (*lsm6dsl_write_ptr)(void *, uint8_t, uint8_t*, uint16_t);
Ntypedef int32_t (*lsm6dsl_read_ptr) (void *, uint8_t, uint8_t*, uint16_t);
N
Ntypedef struct {
N  /** Component mandatory fields **/
N  lsm6dsl_write_ptr  write_reg;
N  lsm6dsl_read_ptr   read_reg;
N  /** Customizable optional pointer **/
N  void *handle;
N} lsm6dsl_ctx_t;
N
N/**
N  * @}
N  *
N  */
N
N/** @defgroup LSM6DSL_Infos
N  * @{
N  *
N  */
N
N/** I2C Device Address 8 bit format  if SA0=0 -> D5 if SA0=1 -> D7 **/
N#define LSM6DSL_I2C_ADD_L     0xD5U
N#define LSM6DSL_I2C_ADD_H     0xD7U
N
N/** Device Identification (Who am I) **/
N#define LSM6DSL_ID            0x6AU
N
N/**
N  * @}
N  *
N  */
N
N#define LSM6DSL_FUNC_CFG_ACCESS              0x01U
Ntypedef struct {
N  uint8_t not_used_01              : 5;
N  uint8_t func_cfg_en              : 3;  /* func_cfg_en + func_cfg_en_b */
N} lsm6dsl_func_cfg_access_t;
N
N#define LSM6DSL_SENSOR_SYNC_TIME_FRAME       0x04U
Ntypedef struct {
N  uint8_t tph                      : 4;
N  uint8_t not_used_01              : 4;
N} lsm6dsl_sensor_sync_time_frame_t;
N
N#define LSM6DSL_SENSOR_SYNC_RES_RATIO        0x05U
Ntypedef struct {
N  uint8_t rr                       : 2;
N  uint8_t not_used_01              : 6;
N} lsm6dsl_sensor_sync_res_ratio_t;
N
N#define LSM6DSL_FIFO_CTRL1                   0x06U
Ntypedef struct {
N  uint8_t fth                      : 8;  /* + FIFO_CTRL2(fth) */
N} lsm6dsl_fifo_ctrl1_t;
N
N#define LSM6DSL_FIFO_CTRL2                   0x07U
Ntypedef struct {
N  uint8_t fth                      : 3;  /* + FIFO_CTRL1(fth) */
N  uint8_t fifo_temp_en             : 1;
N  uint8_t not_used_01              : 2;
N  uint8_t  timer_pedo_fifo_drdy    : 1;
N  uint8_t timer_pedo_fifo_en       : 1;
N} lsm6dsl_fifo_ctrl2_t;
N
N#define LSM6DSL_FIFO_CTRL3                   0x08U
Ntypedef struct {
N  uint8_t dec_fifo_xl              : 3;
N  uint8_t dec_fifo_gyro            : 3;
N  uint8_t not_used_01              : 2;
N} lsm6dsl_fifo_ctrl3_t;
N
N#define LSM6DSL_FIFO_CTRL4                   0x09U
Ntypedef struct {
N  uint8_t dec_ds3_fifo             : 3;
N  uint8_t dec_ds4_fifo             : 3;
N  uint8_t only_high_data           : 1;
N  uint8_t stop_on_fth              : 1;
N} lsm6dsl_fifo_ctrl4_t;
N
N#define LSM6DSL_FIFO_CTRL5                   0x0AU
Ntypedef struct {
N  uint8_t fifo_mode                : 3;
N  uint8_t odr_fifo                 : 4;
N  uint8_t not_used_01              : 1;
N} lsm6dsl_fifo_ctrl5_t;
N
N#define LSM6DSL_DRDY_PULSE_CFG_G             0x0BU
Ntypedef struct {
N  uint8_t int2_wrist_tilt          : 1;
N  uint8_t not_used_01              : 6;
N  uint8_t drdy_pulsed              : 1;
N} lsm6dsl_drdy_pulse_cfg_g_t;
N
N#define LSM6DSL_INT1_CTRL                    0x0DU
Ntypedef struct {
N  uint8_t int1_drdy_xl             : 1;
N  uint8_t int1_drdy_g              : 1;
N  uint8_t int1_boot                : 1;
N  uint8_t int1_fth                 : 1;
N  uint8_t int1_fifo_ovr            : 1;
N  uint8_t int1_full_flag           : 1;
N  uint8_t int1_sign_mot            : 1;
N  uint8_t int1_step_detector       : 1;
N} lsm6dsl_int1_ctrl_t;
N
N#define LSM6DSL_INT2_CTRL                    0x0EU
Ntypedef struct {
N  uint8_t int2_drdy_xl             : 1;
N  uint8_t int2_drdy_g              : 1;
N  uint8_t int2_drdy_temp           : 1;
N  uint8_t int2_fth                 : 1;
N  uint8_t int2_fifo_ovr            : 1;
N  uint8_t int2_full_flag           : 1;
N  uint8_t int2_step_count_ov       : 1;
N  uint8_t int2_step_delta          : 1;
N} lsm6dsl_int2_ctrl_t;
N
N#define LSM6DSL_WHO_AM_I                     0x0FU
N#define LSM6DSL_CTRL1_XL                     0x10U
Ntypedef struct {
N  uint8_t bw0_xl                   : 1;
N  uint8_t lpf1_bw_sel              : 1;
N  uint8_t fs_xl                    : 2;
N  uint8_t odr_xl                   : 4;
N} lsm6dsl_ctrl1_xl_t;
N
N#define LSM6DSL_CTRL2_G                      0x11U
Ntypedef struct {
N  uint8_t not_used_01              : 1;
N  uint8_t fs_g                     : 3;  /* fs_g + fs_125 */
N  uint8_t odr_g                    : 4;
N} lsm6dsl_ctrl2_g_t;
N
N#define LSM6DSL_CTRL3_C                      0x12U
Ntypedef struct {
N  uint8_t sw_reset                 : 1;
N  uint8_t ble                      : 1;
N  uint8_t if_inc                   : 1;
N  uint8_t sim                      : 1;
N  uint8_t pp_od                    : 1;
N  uint8_t h_lactive                : 1;
N  uint8_t bdu                      : 1;
N  uint8_t boot                     : 1;
N} lsm6dsl_ctrl3_c_t;
N
N#define LSM6DSL_CTRL4_C                      0x13U
Ntypedef struct {
N  uint8_t not_used_01              : 1;
N  uint8_t lpf1_sel_g               : 1;
N  uint8_t i2c_disable              : 1;
N  uint8_t drdy_mask                : 1;
N  uint8_t den_drdy_int1            : 1;
N  uint8_t int2_on_int1             : 1;
N  uint8_t sleep                    : 1;
N  uint8_t den_xl_en                : 1;
N} lsm6dsl_ctrl4_c_t;
N
N#define LSM6DSL_CTRL5_C                      0x14U
Ntypedef struct {
N  uint8_t st_xl                    : 2;
N  uint8_t st_g                     : 2;
N  uint8_t den_lh                   : 1;
N  uint8_t rounding                 : 3;
N} lsm6dsl_ctrl5_c_t;
N
N#define LSM6DSL_CTRL6_C                      0x15U
Ntypedef struct {
N  uint8_t ftype                    : 2;
N  uint8_t not_used_01              : 1;
N  uint8_t usr_off_w                : 1;
N  uint8_t xl_hm_mode               : 1;
N  uint8_t den_mode                 : 3;  /* trig_en + lvl_en + lvl2_en */
N} lsm6dsl_ctrl6_c_t;
N
N#define LSM6DSL_CTRL7_G                      0x16U
Ntypedef struct {
N  uint8_t not_used_01              : 2;
N  uint8_t rounding_status          : 1;
N  uint8_t not_used_02              : 1;
N  uint8_t hpm_g                    : 2;
N  uint8_t hp_en_g                  : 1;
N  uint8_t g_hm_mode                : 1;
N} lsm6dsl_ctrl7_g_t;
N
N#define LSM6DSL_CTRL8_XL                     0x17U
Ntypedef struct {
N  uint8_t low_pass_on_6d           : 1;
N  uint8_t not_used_01              : 1;
N  uint8_t hp_slope_xl_en           : 1;
N  uint8_t input_composite          : 1;
N  uint8_t hp_ref_mode              : 1;
N  uint8_t hpcf_xl                  : 2;
N  uint8_t lpf2_xl_en               : 1;
N} lsm6dsl_ctrl8_xl_t;
N
N#define LSM6DSL_CTRL9_XL                     0x18U
Ntypedef struct {
N  uint8_t not_used_01              : 2;
N  uint8_t soft_en                  : 1;
N  uint8_t not_used_02              : 1;
N  uint8_t den_xl_g                 : 1;
N  uint8_t den_z                    : 1;
N  uint8_t den_y                    : 1;
N  uint8_t den_x                    : 1;
N} lsm6dsl_ctrl9_xl_t;
N
N#define LSM6DSL_CTRL10_C                     0x19U
Ntypedef struct {
N  uint8_t sign_motion_en           : 1;
N  uint8_t pedo_rst_step            : 1;
N  uint8_t func_en                  : 1;
N  uint8_t tilt_en                  : 1;
N  uint8_t pedo_en                  : 1;
N  uint8_t timer_en                 : 1;
N  uint8_t not_used_01              : 1;
N  uint8_t wrist_tilt_en            : 1;
N} lsm6dsl_ctrl10_c_t;
N
N#define LSM6DSL_MASTER_CONFIG                0x1AU
Ntypedef struct {
N  uint8_t master_on                : 1;
N  uint8_t iron_en                  : 1;
N  uint8_t pass_through_mode        : 1;
N  uint8_t pull_up_en               : 1;
N  uint8_t start_config             : 1;
N  uint8_t not_used_01              : 1;
N  uint8_t  data_valid_sel_fifo     : 1;
N  uint8_t drdy_on_int1             : 1;
N} lsm6dsl_master_config_t;
N
N#define LSM6DSL_WAKE_UP_SRC                  0x1BU
Ntypedef struct {
N  uint8_t z_wu                     : 1;
N  uint8_t y_wu                     : 1;
N  uint8_t x_wu                     : 1;
N  uint8_t wu_ia                    : 1;
N  uint8_t sleep_state_ia           : 1;
N  uint8_t ff_ia                    : 1;
N  uint8_t not_used_01              : 2;
N} lsm6dsl_wake_up_src_t;
N
N#define LSM6DSL_TAP_SRC                      0x1CU
Ntypedef struct {
N  uint8_t z_tap                    : 1;
N  uint8_t y_tap                    : 1;
N  uint8_t x_tap                    : 1;
N  uint8_t tap_sign                 : 1;
N  uint8_t double_tap               : 1;
N  uint8_t single_tap               : 1;
N  uint8_t tap_ia                   : 1;
N  uint8_t not_used_01              : 1;
N} lsm6dsl_tap_src_t;
N
N#define LSM6DSL_D6D_SRC                      0x1DU
Ntypedef struct {
N  uint8_t xl                       : 1;
N  uint8_t xh                       : 1;
N  uint8_t yl                       : 1;
N  uint8_t yh                       : 1;
N  uint8_t zl                       : 1;
N  uint8_t zh                       : 1;
N  uint8_t d6d_ia                   : 1;
N  uint8_t den_drdy                 : 1;
N} lsm6dsl_d6d_src_t;
N
N#define LSM6DSL_STATUS_REG                   0x1EU
Ntypedef struct {
N  uint8_t xlda                     : 1;
N  uint8_t gda                      : 1;
N  uint8_t tda                      : 1;
N  uint8_t not_used_01              : 5;
N} lsm6dsl_status_reg_t;
N
N#define LSM6DSL_OUT_TEMP_L                   0x20U
N#define LSM6DSL_OUT_TEMP_H                   0x21U
N#define LSM6DSL_OUTX_L_G                     0x22U
N#define LSM6DSL_OUTX_H_G                     0x23U
N#define LSM6DSL_OUTY_L_G                     0x24U
N#define LSM6DSL_OUTY_H_G                     0x25U
N#define LSM6DSL_OUTZ_L_G                     0x26U
N#define LSM6DSL_OUTZ_H_G                     0x27U
N#define LSM6DSL_OUTX_L_XL                    0x28U
N#define LSM6DSL_OUTX_H_XL                    0x29U
N#define LSM6DSL_OUTY_L_XL                    0x2AU
N#define LSM6DSL_OUTY_H_XL                    0x2BU
N#define LSM6DSL_OUTZ_L_XL                    0x2CU
N#define LSM6DSL_OUTZ_H_XL                    0x2DU
N#define LSM6DSL_SENSORHUB1_REG               0x2EU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub1_reg_t;
N
N#define LSM6DSL_SENSORHUB2_REG               0x2FU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub2_reg_t;
N
N#define LSM6DSL_SENSORHUB3_REG               0x30U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub3_reg_t;
N
N#define LSM6DSL_SENSORHUB4_REG               0x31U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub4_reg_t;
N
N#define LSM6DSL_SENSORHUB5_REG               0x32U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub5_reg_t;
N
N#define LSM6DSL_SENSORHUB6_REG               0x33U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub6_reg_t;
N
N#define LSM6DSL_SENSORHUB7_REG               0x34U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub7_reg_t;
N
N#define LSM6DSL_SENSORHUB8_REG               0x35U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub8_reg_t;
N
N#define LSM6DSL_SENSORHUB9_REG               0x36U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub9_reg_t;
N
N#define LSM6DSL_SENSORHUB10_REG              0x37U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub10_reg_t;
N
N#define LSM6DSL_SENSORHUB11_REG              0x38U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub11_reg_t;
N
N#define LSM6DSL_SENSORHUB12_REG              0x39U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub12_reg_t;
N
N#define LSM6DSL_FIFO_STATUS1                 0x3AU
Ntypedef struct {
N  uint8_t diff_fifo                : 8;  /* + FIFO_STATUS2(diff_fifo) */
N} lsm6dsl_fifo_status1_t;
N
N#define LSM6DSL_FIFO_STATUS2                 0x3BU
Ntypedef struct {
N  uint8_t diff_fifo                : 3;  /* + FIFO_STATUS1(diff_fifo) */
N  uint8_t not_used_01              : 1;
N  uint8_t fifo_empty               : 1;
N  uint8_t fifo_full_smart          : 1;
N  uint8_t over_run                 : 1;
N  uint8_t waterm                   : 1;
N} lsm6dsl_fifo_status2_t;
N
N#define LSM6DSL_FIFO_STATUS3                 0x3CU
Ntypedef struct {
N  uint8_t fifo_pattern             : 8;  /* + FIFO_STATUS4(fifo_pattern) */
N} lsm6dsl_fifo_status3_t;
N
N#define LSM6DSL_FIFO_STATUS4                 0x3DU
Ntypedef struct {
N  uint8_t fifo_pattern             : 2;  /* + FIFO_STATUS3(fifo_pattern) */
N  uint8_t not_used_01              : 6;
N} lsm6dsl_fifo_status4_t;
N
N#define LSM6DSL_FIFO_DATA_OUT_L              0x3EU
N#define LSM6DSL_FIFO_DATA_OUT_H              0x3FU
N#define LSM6DSL_TIMESTAMP0_REG               0x40U
N#define LSM6DSL_TIMESTAMP1_REG               0x41U
N#define LSM6DSL_TIMESTAMP2_REG               0x42U
N#define LSM6DSL_STEP_TIMESTAMP_L             0x49U
N#define LSM6DSL_STEP_TIMESTAMP_H             0x4AU
N#define LSM6DSL_STEP_COUNTER_L               0x4BU
N#define LSM6DSL_STEP_COUNTER_H               0x4CU
N
N#define LSM6DSL_SENSORHUB13_REG              0x4DU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub13_reg_t;
N
N#define LSM6DSL_SENSORHUB14_REG              0x4EU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub14_reg_t;
N
N#define LSM6DSL_SENSORHUB15_REG              0x4FU
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub15_reg_t;
N
N#define LSM6DSL_SENSORHUB16_REG              0x50U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub16_reg_t;
N
N#define LSM6DSL_SENSORHUB17_REG              0x51U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub17_reg_t;
N
N#define LSM6DSL_SENSORHUB18_REG              0x52U
Ntypedef struct {
N  uint8_t bit0                     : 1;
N  uint8_t bit1                     : 1;
N  uint8_t bit2                     : 1;
N  uint8_t bit3                     : 1;
N  uint8_t bit4                     : 1;
N  uint8_t bit5                     : 1;
N  uint8_t bit6                     : 1;
N  uint8_t bit7                     : 1;
N} lsm6dsl_sensorhub18_reg_t;
N
N#define LSM6DSL_FUNC_SRC1                    0x53U
Ntypedef struct {
N  uint8_t sensorhub_end_op         : 1;
N  uint8_t si_end_op                : 1;
N  uint8_t hi_fail                  : 1;
N  uint8_t step_overflow            : 1;
N  uint8_t step_detected            : 1;
N  uint8_t tilt_ia                  : 1;
N  uint8_t sign_motion_ia           : 1;
N  uint8_t  step_count_delta_ia     : 1;
N} lsm6dsl_func_src1_t;
N
N#define LSM6DSL_FUNC_SRC2                    0x54U
Ntypedef struct {
N  uint8_t wrist_tilt_ia            : 1;
N  uint8_t not_used_01              : 2;
N  uint8_t slave0_nack              : 1;
N  uint8_t slave1_nack              : 1;
N  uint8_t slave2_nack              : 1;
N  uint8_t slave3_nack              : 1;
N  uint8_t not_used_02              : 1;
N} lsm6dsl_func_src2_t;
N
N#define LSM6DSL_WRIST_TILT_IA                0x55U
Ntypedef struct {
N  uint8_t not_used_01              : 2;
N  uint8_t wrist_tilt_ia_zneg       : 1;
N  uint8_t wrist_tilt_ia_zpos       : 1;
N  uint8_t wrist_tilt_ia_yneg       : 1;
N  uint8_t wrist_tilt_ia_ypos       : 1;
N  uint8_t wrist_tilt_ia_xneg       : 1;
N  uint8_t wrist_tilt_ia_xpos       : 1;
N} lsm6dsl_wrist_tilt_ia_t;
N
N#define LSM6DSL_TAP_CFG                      0x58U
Ntypedef struct {
N  uint8_t lir                      : 1;
N  uint8_t tap_z_en                 : 1;
N  uint8_t tap_y_en                 : 1;
N  uint8_t tap_x_en                 : 1;
N  uint8_t slope_fds                : 1;
N  uint8_t inact_en                 : 2;
N  uint8_t interrupts_enable        : 1;
N} lsm6dsl_tap_cfg_t;
N
N#define LSM6DSL_TAP_THS_6D                   0x59U
Ntypedef struct {
N  uint8_t tap_ths                  : 5;
N  uint8_t sixd_ths                 : 2;
N  uint8_t d4d_en                   : 1;
N} lsm6dsl_tap_ths_6d_t;
N
N#define LSM6DSL_INT_DUR2                     0x5AU
Ntypedef struct {
N  uint8_t shock                    : 2;
N  uint8_t quiet                    : 2;
N  uint8_t dur                      : 4;
N} lsm6dsl_int_dur2_t;
N
N#define LSM6DSL_WAKE_UP_THS                  0x5BU
Ntypedef struct {
N  uint8_t wk_ths                   : 6;
N  uint8_t not_used_01              : 1;
N  uint8_t single_double_tap        : 1;
N} lsm6dsl_wake_up_ths_t;
N
N#define LSM6DSL_WAKE_UP_DUR                  0x5CU
Ntypedef struct {
N  uint8_t sleep_dur                : 4;
N  uint8_t timer_hr                 : 1;
N  uint8_t wake_dur                 : 2;
N  uint8_t ff_dur                   : 1;
N} lsm6dsl_wake_up_dur_t;
N
N#define LSM6DSL_FREE_FALL                    0x5DU
Ntypedef struct {
N  uint8_t ff_ths                   : 3;
N  uint8_t ff_dur                   : 5;
N} lsm6dsl_free_fall_t;
N
N#define LSM6DSL_MD1_CFG                      0x5EU
Ntypedef struct {
N  uint8_t int1_timer               : 1;
N  uint8_t int1_tilt                : 1;
N  uint8_t int1_6d                  : 1;
N  uint8_t int1_double_tap          : 1;
N  uint8_t int1_ff                  : 1;
N  uint8_t int1_wu                  : 1;
N  uint8_t int1_single_tap          : 1;
N  uint8_t int1_inact_state         : 1;
N} lsm6dsl_md1_cfg_t;
N
N#define LSM6DSL_MD2_CFG                      0x5FU
Ntypedef struct {
N  uint8_t int2_iron                : 1;
N  uint8_t int2_tilt                : 1;
N  uint8_t int2_6d                  : 1;
N  uint8_t int2_double_tap          : 1;
N  uint8_t int2_ff                  : 1;
N  uint8_t int2_wu                  : 1;
N  uint8_t int2_single_tap          : 1;
N  uint8_t int2_inact_state         : 1;
N} lsm6dsl_md2_cfg_t;
N
N#define LSM6DSL_MASTER_CMD_CODE              0x60U
Ntypedef struct {
N  uint8_t master_cmd_code          : 8;
N} lsm6dsl_master_cmd_code_t;
N
N#define LSM6DSL_SENS_SYNC_SPI_ERROR_CODE     0x61U
Ntypedef struct {
N  uint8_t error_code               : 8;
N} lsm6dsl_sens_sync_spi_error_code_t;
N
N#define LSM6DSL_OUT_MAG_RAW_X_L              0x66U
N#define LSM6DSL_OUT_MAG_RAW_X_H              0x67U
N#define LSM6DSL_OUT_MAG_RAW_Y_L              0x68U
N#define LSM6DSL_OUT_MAG_RAW_Y_H              0x69U
N#define LSM6DSL_OUT_MAG_RAW_Z_L              0x6AU
N#define LSM6DSL_OUT_MAG_RAW_Z_H              0x6BU
N#define LSM6DSL_X_OFS_USR                    0x73U
N#define LSM6DSL_Y_OFS_USR                    0x74U
N#define LSM6DSL_Z_OFS_USR                    0x75U
N#define LSM6DSL_SLV0_ADD                     0x02U
Ntypedef struct {
N  uint8_t rw_0                     : 1;
N  uint8_t slave0_add               : 7;
N} lsm6dsl_slv0_add_t;
N
N#define LSM6DSL_SLV0_SUBADD                  0x03U
Ntypedef struct {
N  uint8_t slave0_reg               : 8;
N} lsm6dsl_slv0_subadd_t;
N
N#define LSM6DSL_SLAVE0_CONFIG                0x04U
Ntypedef struct {
N  uint8_t slave0_numop             : 3;
N  uint8_t src_mode                 : 1;
N  uint8_t aux_sens_on              : 2;
N  uint8_t slave0_rate              : 2;
N} lsm6dsl_slave0_config_t;
N
N#define LSM6DSL_SLV1_ADD                     0x05U
Ntypedef struct {
N  uint8_t r_1                      : 1;
N  uint8_t slave1_add               : 7;
N} lsm6dsl_slv1_add_t;
N
N#define LSM6DSL_SLV1_SUBADD                  0x06U
Ntypedef struct {
N  uint8_t slave1_reg               : 8;
N} lsm6dsl_slv1_subadd_t;
N
N#define LSM6DSL_SLAVE1_CONFIG                0x07U
Ntypedef struct {
N  uint8_t slave1_numop             : 3;
N  uint8_t not_used_01              : 2;
N  uint8_t write_once               : 1;
N  uint8_t slave1_rate              : 2;
N} lsm6dsl_slave1_config_t;
N
N#define LSM6DSL_SLV2_ADD                     0x08U
Ntypedef struct {
N  uint8_t r_2                      : 1;
N  uint8_t slave2_add               : 7;
N} lsm6dsl_slv2_add_t;
N
N#define LSM6DSL_SLV2_SUBADD                  0x09U
Ntypedef struct {
N  uint8_t slave2_reg               : 8;
N} lsm6dsl_slv2_subadd_t;
N
N#define LSM6DSL_SLAVE2_CONFIG                0x0AU
Ntypedef struct {
N  uint8_t slave2_numop             : 3;
N  uint8_t not_used_01              : 3;
N  uint8_t slave2_rate              : 2;
N} lsm6dsl_slave2_config_t;
N
N#define LSM6DSL_SLV3_ADD                     0x0BU
Ntypedef struct {
N  uint8_t r_3                      : 1;
N  uint8_t slave3_add               : 7;
N} lsm6dsl_slv3_add_t;
N
N#define LSM6DSL_SLV3_SUBADD                  0x0CU
Ntypedef struct {
N  uint8_t slave3_reg               : 8;
N} lsm6dsl_slv3_subadd_t;
N
N#define LSM6DSL_SLAVE3_CONFIG                0x0DU
Ntypedef struct {
N  uint8_t slave3_numop             : 3;
N  uint8_t not_used_01              : 3;
N  uint8_t slave3_rate              : 2;
N} lsm6dsl_slave3_config_t;
N
N#define LSM6DSL_DATAWRITE_SRC_MODE_SUB_SLV0  0x0EU
Ntypedef struct {
N  uint8_t slave_dataw              : 8;
N} lsm6dsl_datawrite_src_mode_sub_slv0_t;
N
N#define LSM6DSL_CONFIG_PEDO_THS_MIN          0x0FU
Ntypedef struct {
N  uint8_t ths_min                  : 5;
N  uint8_t not_used_01              : 2;
N  uint8_t pedo_fs                  : 1;
N} lsm6dsl_config_pedo_ths_min_t;
N
N#define LSM6DSL_SM_THS                       0x13U
N#define LSM6DSL_PEDO_DEB_REG                 0x14U
Ntypedef struct {
N  uint8_t deb_step      : 3;
N  uint8_t deb_time      : 5;
N} lsm6dsl_pedo_deb_reg_t;
N
N#define LSM6DSL_STEP_COUNT_DELTA             0x15U
N#define LSM6DSL_MAG_SI_XX                    0x24U
N#define LSM6DSL_MAG_SI_XY                    0x25U
N#define LSM6DSL_MAG_SI_XZ                    0x26U
N#define LSM6DSL_MAG_SI_YX                    0x27U
N#define LSM6DSL_MAG_SI_YY                    0x28U
N#define LSM6DSL_MAG_SI_YZ                    0x29U
N#define LSM6DSL_MAG_SI_ZX                    0x2AU
N#define LSM6DSL_MAG_SI_ZY                    0x2BU
N#define LSM6DSL_MAG_SI_ZZ                    0x2CU
N#define LSM6DSL_MAG_OFFX_L                   0x2DU
N#define LSM6DSL_MAG_OFFX_H                   0x2EU
N#define LSM6DSL_MAG_OFFY_L                   0x2FU
N#define LSM6DSL_MAG_OFFY_H                   0x30U
N#define LSM6DSL_MAG_OFFZ_L                   0x31U
N#define LSM6DSL_MAG_OFFZ_H                   0x32U
N#define LSM6DSL_A_WRIST_TILT_LAT             0x50U
N#define LSM6DSL_A_WRIST_TILT_THS             0x54U
N#define LSM6DSL_A_WRIST_TILT_MASK            0x59U
Ntypedef struct {
N  uint8_t not_used_01              : 2;
N  uint8_t  wrist_tilt_mask_zneg    : 1;
N  uint8_t  wrist_tilt_mask_zpos    : 1;
N  uint8_t  wrist_tilt_mask_yneg    : 1;
N  uint8_t  wrist_tilt_mask_ypos    : 1;
N  uint8_t  wrist_tilt_mask_xneg    : 1;
N  uint8_t  wrist_tilt_mask_xpos    : 1;
N} lsm6dsl_a_wrist_tilt_mask_t;
N
N/**
N  * @defgroup LSM6DSL_Register_Union
N  * @brief    This union group all the registers that has a bit-field
N  *           description.
N  *           This union is useful but not need by the driver.
N  *
N  *           REMOVING this union you are compliant with:
N  *           MISRA-C 2012 [Rule 19.2] -> " Union are not allowed "
N  *
N  * @{
N  *
N  */
Ntypedef union{
N  lsm6dsl_func_cfg_access_t                  func_cfg_access;
N  lsm6dsl_sensor_sync_time_frame_t           sensor_sync_time_frame;
N  lsm6dsl_sensor_sync_res_ratio_t            sensor_sync_res_ratio;
N  lsm6dsl_fifo_ctrl1_t                       fifo_ctrl1;
N  lsm6dsl_fifo_ctrl2_t                       fifo_ctrl2;
N  lsm6dsl_fifo_ctrl3_t                       fifo_ctrl3;
N  lsm6dsl_fifo_ctrl4_t                       fifo_ctrl4;
N  lsm6dsl_fifo_ctrl5_t                       fifo_ctrl5;
N  lsm6dsl_drdy_pulse_cfg_g_t                 drdy_pulse_cfg_g;
N  lsm6dsl_int1_ctrl_t                        int1_ctrl;
N  lsm6dsl_int2_ctrl_t                        int2_ctrl;
N  lsm6dsl_ctrl1_xl_t                         ctrl1_xl;
N  lsm6dsl_ctrl2_g_t                          ctrl2_g;
N  lsm6dsl_ctrl3_c_t                          ctrl3_c;
N  lsm6dsl_ctrl4_c_t                          ctrl4_c;
N  lsm6dsl_ctrl5_c_t                          ctrl5_c;
N  lsm6dsl_ctrl6_c_t                          ctrl6_c;
N  lsm6dsl_ctrl7_g_t                          ctrl7_g;
N  lsm6dsl_ctrl8_xl_t                         ctrl8_xl;
N  lsm6dsl_ctrl9_xl_t                         ctrl9_xl;
N  lsm6dsl_ctrl10_c_t                         ctrl10_c;
N  lsm6dsl_master_config_t                    master_config;
N  lsm6dsl_wake_up_src_t                      wake_up_src;
N  lsm6dsl_tap_src_t                          tap_src;
N  lsm6dsl_d6d_src_t                          d6d_src;
N  lsm6dsl_status_reg_t                       status_reg;
N  lsm6dsl_sensorhub1_reg_t                   sensorhub1_reg;
N  lsm6dsl_sensorhub2_reg_t                   sensorhub2_reg;
N  lsm6dsl_sensorhub3_reg_t                   sensorhub3_reg;
N  lsm6dsl_sensorhub4_reg_t                   sensorhub4_reg;
N  lsm6dsl_sensorhub5_reg_t                   sensorhub5_reg;
N  lsm6dsl_sensorhub6_reg_t                   sensorhub6_reg;
N  lsm6dsl_sensorhub7_reg_t                   sensorhub7_reg;
N  lsm6dsl_sensorhub8_reg_t                   sensorhub8_reg;
N  lsm6dsl_sensorhub9_reg_t                   sensorhub9_reg;
N  lsm6dsl_sensorhub10_reg_t                  sensorhub10_reg;
N  lsm6dsl_sensorhub11_reg_t                  sensorhub11_reg;
N  lsm6dsl_sensorhub12_reg_t                  sensorhub12_reg;
N  lsm6dsl_fifo_status1_t                     fifo_status1;
N  lsm6dsl_fifo_status2_t                     fifo_status2;
N  lsm6dsl_fifo_status3_t                     fifo_status3;
N  lsm6dsl_fifo_status4_t                     fifo_status4;
N  lsm6dsl_sensorhub13_reg_t                  sensorhub13_reg;
N  lsm6dsl_sensorhub14_reg_t                  sensorhub14_reg;
N  lsm6dsl_sensorhub15_reg_t                  sensorhub15_reg;
N  lsm6dsl_sensorhub16_reg_t                  sensorhub16_reg;
N  lsm6dsl_sensorhub17_reg_t                  sensorhub17_reg;
N  lsm6dsl_sensorhub18_reg_t                  sensorhub18_reg;
N  lsm6dsl_func_src1_t                        func_src1;
N  lsm6dsl_func_src2_t                        func_src2;
N  lsm6dsl_wrist_tilt_ia_t                    wrist_tilt_ia;
N  lsm6dsl_tap_cfg_t                          tap_cfg;
N  lsm6dsl_tap_ths_6d_t                       tap_ths_6d;
N  lsm6dsl_int_dur2_t                         int_dur2;
N  lsm6dsl_wake_up_ths_t                      wake_up_ths;
N  lsm6dsl_wake_up_dur_t                      wake_up_dur;
N  lsm6dsl_free_fall_t                        free_fall;
N  lsm6dsl_md1_cfg_t                          md1_cfg;
N  lsm6dsl_md2_cfg_t                          md2_cfg;
N  lsm6dsl_master_cmd_code_t                  master_cmd_code;
N  lsm6dsl_sens_sync_spi_error_code_t         sens_sync_spi_error_code;
N  lsm6dsl_slv0_add_t                         slv0_add;
N  lsm6dsl_slv0_subadd_t                      slv0_subadd;
N  lsm6dsl_slave0_config_t                    slave0_config;
N  lsm6dsl_slv1_add_t                         slv1_add;
N  lsm6dsl_slv1_subadd_t                      slv1_subadd;
N  lsm6dsl_slave1_config_t                    slave1_config;
N  lsm6dsl_slv2_add_t                         slv2_add;
N  lsm6dsl_slv2_subadd_t                      slv2_subadd;
N  lsm6dsl_slave2_config_t                    slave2_config;
N  lsm6dsl_slv3_add_t                         slv3_add;
N  lsm6dsl_slv3_subadd_t                      slv3_subadd;
N  lsm6dsl_slave3_config_t                    slave3_config;
N  lsm6dsl_datawrite_src_mode_sub_slv0_t      datawrite_src_mode_sub_slv0;
N  lsm6dsl_config_pedo_ths_min_t              config_pedo_ths_min;
N  lsm6dsl_pedo_deb_reg_t                     pedo_deb_reg;
N  lsm6dsl_a_wrist_tilt_mask_t                a_wrist_tilt_mask;
N  bitwise_t                                  bitwise;
N  uint8_t                                    byte;
N} lsm6dsl_reg_t;
N
N/**
N  * @}
N  *
N  */
N
Nint32_t lsm6dsl_read_reg(lsm6dsl_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                         uint16_t len);
Nint32_t lsm6dsl_write_reg(lsm6dsl_ctx_t *ctx, uint8_t reg, uint8_t* data,
N                          uint16_t len);
N
Nextern float_t lsm6dsl_from_fs2g_to_mg(int16_t lsb);
Nextern float_t lsm6dsl_from_fs4g_to_mg(int16_t lsb);
Nextern float_t lsm6dsl_from_fs8g_to_mg(int16_t lsb);
Nextern float_t lsm6dsl_from_fs16g_to_mg(int16_t lsb);
N
Nextern float_t lsm6dsl_from_fs125dps_to_mdps(int16_t lsb);
Nextern float_t lsm6dsl_from_fs250dps_to_mdps(int16_t lsb);
Nextern float_t lsm6dsl_from_fs500dps_to_mdps(int16_t lsb);
Nextern float_t lsm6dsl_from_fs1000dps_to_mdps(int16_t lsb);
Nextern float_t lsm6dsl_from_fs2000dps_to_mdps(int16_t lsb);
N
Nextern float_t lsm6dsl_from_lsb_to_celsius(int16_t lsb);
N
Ntypedef enum {
N  LSM6DSL_2g       = 0,
N  LSM6DSL_16g      = 1,
N  LSM6DSL_4g       = 2,
N  LSM6DSL_8g       = 3,
N  LSM6DSL_XL_FS_ND = 4,  /* ERROR CODE */
N} lsm6dsl_fs_xl_t;
Nint32_t lsm6dsl_xl_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t val);
Nint32_t lsm6dsl_xl_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_ODR_OFF      =  0,
N  LSM6DSL_XL_ODR_12Hz5    =  1,
N  LSM6DSL_XL_ODR_26Hz     =  2,
N  LSM6DSL_XL_ODR_52Hz     =  3,
N  LSM6DSL_XL_ODR_104Hz    =  4,
N  LSM6DSL_XL_ODR_208Hz    =  5,
N  LSM6DSL_XL_ODR_416Hz    =  6,
N  LSM6DSL_XL_ODR_833Hz    =  7,
N  LSM6DSL_XL_ODR_1k66Hz   =  8,
N  LSM6DSL_XL_ODR_3k33Hz   =  9,
N  LSM6DSL_XL_ODR_6k66Hz   = 10,
N  LSM6DSL_XL_ODR_1Hz6     = 11,
N  LSM6DSL_XL_ODR_ND       = 12,  /* ERROR CODE */
N} lsm6dsl_odr_xl_t;
Nint32_t lsm6dsl_xl_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t val);
Nint32_t lsm6dsl_xl_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_250dps     = 0,
N  LSM6DSL_125dps     = 1,
N  LSM6DSL_500dps     = 2,
N  LSM6DSL_1000dps    = 4,
N  LSM6DSL_2000dps    = 6,
N  LSM6DSL_GY_FS_ND   = 7,    /* ERROR CODE */
N} lsm6dsl_fs_g_t;
Nint32_t lsm6dsl_gy_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t val);
Nint32_t lsm6dsl_gy_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t *val);
N
Ntypedef enum {
N  LSM6DSL_GY_ODR_OFF    =  0,
N  LSM6DSL_GY_ODR_12Hz5  =  1,
N  LSM6DSL_GY_ODR_26Hz   =  2,
N  LSM6DSL_GY_ODR_52Hz   =  3,
N  LSM6DSL_GY_ODR_104Hz  =  4,
N  LSM6DSL_GY_ODR_208Hz  =  5,
N  LSM6DSL_GY_ODR_416Hz  =  6,
N  LSM6DSL_GY_ODR_833Hz  =  7,
N  LSM6DSL_GY_ODR_1k66Hz =  8,
N  LSM6DSL_GY_ODR_3k33Hz =  9,
N  LSM6DSL_GY_ODR_6k66Hz = 10,
N  LSM6DSL_GY_ODR_ND     = 11,    /* ERROR CODE */
N} lsm6dsl_odr_g_t;
Nint32_t lsm6dsl_gy_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t val);
Nint32_t lsm6dsl_gy_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t *val);
N
Nint32_t lsm6dsl_block_data_update_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_block_data_update_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_LSb_1mg   = 0,
N  LSM6DSL_LSb_16mg  = 1,
N  LSM6DSL_WEIGHT_ND = 2,
N} lsm6dsl_usr_off_w_t;
Nint32_t lsm6dsl_xl_offset_weight_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_usr_off_w_t val);
Nint32_t lsm6dsl_xl_offset_weight_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_usr_off_w_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_HIGH_PERFORMANCE  = 0,
N  LSM6DSL_XL_NORMAL            = 1,
N  LSM6DSL_XL_PW_MODE_ND        = 2,    /* ERROR CODE */
N} lsm6dsl_xl_hm_mode_t;
Nint32_t lsm6dsl_xl_power_mode_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_xl_hm_mode_t val);
Nint32_t lsm6dsl_xl_power_mode_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_xl_hm_mode_t *val);
N
Ntypedef enum {
N  LSM6DSL_STAT_RND_DISABLE  = 0,
N  LSM6DSL_STAT_RND_ENABLE   = 1,
N  LSM6DSL_STAT_RND_ND       = 2,    /* ERROR CODE */
N} lsm6dsl_rounding_status_t;
Nint32_t lsm6dsl_rounding_on_status_set(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_rounding_status_t val);
Nint32_t lsm6dsl_rounding_on_status_get(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_rounding_status_t *val);
N
Ntypedef enum {
N  LSM6DSL_GY_HIGH_PERFORMANCE  = 0,
N  LSM6DSL_GY_NORMAL            = 1,
N  LSM6DSL_GY_PW_MODE_ND        = 2,    /* ERROR CODE */
N} lsm6dsl_g_hm_mode_t;
Nint32_t lsm6dsl_gy_power_mode_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_g_hm_mode_t val);
Nint32_t lsm6dsl_gy_power_mode_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_g_hm_mode_t *val);
N
Ntypedef struct {
N  lsm6dsl_wake_up_src_t        wake_up_src;
N  lsm6dsl_tap_src_t            tap_src;
N  lsm6dsl_d6d_src_t            d6d_src;
N  lsm6dsl_status_reg_t         status_reg;
N  lsm6dsl_func_src1_t          func_src1;
N  lsm6dsl_func_src2_t          func_src2;
N  lsm6dsl_wrist_tilt_ia_t      wrist_tilt_ia;
N  lsm6dsl_a_wrist_tilt_mask_t  a_wrist_tilt_mask;
N} lsm6dsl_all_sources_t;
Nint32_t lsm6dsl_all_sources_get(lsm6dsl_ctx_t *ctx,
N                                lsm6dsl_all_sources_t *val);
N
Nint32_t lsm6dsl_status_reg_get(lsm6dsl_ctx_t *ctx, lsm6dsl_status_reg_t *val);
N
Nint32_t lsm6dsl_xl_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_gy_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_temp_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_xl_usr_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_xl_usr_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_timestamp_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_timestamp_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_LSB_6ms4    = 0,
N  LSM6DSL_LSB_25us    = 1,
N  LSM6DSL_TS_RES_ND   = 2,    /* ERROR CODE */
N} lsm6dsl_timer_hr_t;
Nint32_t lsm6dsl_timestamp_res_set(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t val);
Nint32_t lsm6dsl_timestamp_res_get(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t *val);
N
Ntypedef enum {
N  LSM6DSL_ROUND_DISABLE            = 0,
N  LSM6DSL_ROUND_XL                 = 1,
N  LSM6DSL_ROUND_GY                 = 2,
N  LSM6DSL_ROUND_GY_XL              = 3,
N  LSM6DSL_ROUND_SH1_TO_SH6         = 4,
N  LSM6DSL_ROUND_XL_SH1_TO_SH6      = 5,
N  LSM6DSL_ROUND_GY_XL_SH1_TO_SH12  = 6,
N  LSM6DSL_ROUND_GY_XL_SH1_TO_SH6   = 7,
N  LSM6DSL_ROUND_OUT_ND             = 8,    /* ERROR CODE */
N} lsm6dsl_rounding_t;
Nint32_t lsm6dsl_rounding_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t val);
Nint32_t lsm6dsl_rounding_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t *val);
N
Nint32_t lsm6dsl_temperature_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_angular_rate_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_acceleration_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_mag_calibrated_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_fifo_raw_data_get(lsm6dsl_ctx_t *ctx, uint8_t *buffer,
N                                  uint8_t len);
N
Ntypedef enum {
N  LSM6DSL_USER_BANK   = 0,
N  LSM6DSL_BANK_A      = 4,
N  LSM6DSL_BANK_B      = 5,
N  LSM6DSL_BANK_ND     = 6,    /* ERROR CODE */
N} lsm6dsl_func_cfg_en_t;
Nint32_t lsm6dsl_mem_bank_set(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t val);
Nint32_t lsm6dsl_mem_bank_get(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t *val);
N
Ntypedef enum {
N  LSM6DSL_DRDY_LATCHED    = 0,
N  LSM6DSL_DRDY_PULSED     = 1,
N  LSM6DSL_DRDY_ND         = 2,  /* ERROR CODE */
N} lsm6dsl_drdy_pulsed_g_t;
Nint32_t lsm6dsl_data_ready_mode_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_drdy_pulsed_g_t val);
Nint32_t lsm6dsl_data_ready_mode_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_drdy_pulsed_g_t *val);
N
Nint32_t lsm6dsl_device_id_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_LSB_AT_LOW_ADD  = 0,
N  LSM6DSL_MSB_AT_LOW_ADD  = 1,
N  LSM6DSL_DATA_FMT_ND     = 2,    /* ERROR CODE */
N} lsm6dsl_ble_t;
Nint32_t lsm6dsl_data_format_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t val);
Nint32_t lsm6dsl_data_format_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t *val);
N
Nint32_t lsm6dsl_auto_increment_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_auto_increment_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_boot_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_boot_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_ST_DISABLE    = 0,
N  LSM6DSL_XL_ST_POSITIVE   = 1,
N  LSM6DSL_XL_ST_NEGATIVE   = 2,
N  LSM6DSL_XL_ST_ND         = 3,    /* ERROR CODE */
N} lsm6dsl_st_xl_t;
Nint32_t lsm6dsl_xl_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t val);
Nint32_t lsm6dsl_xl_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_GY_ST_DISABLE    = 0,
N  LSM6DSL_GY_ST_POSITIVE   = 1,
N  LSM6DSL_GY_ST_NEGATIVE   = 3,
N  LSM6DSL_GY_ST_ND         = 4,    /* ERROR CODE */
N} lsm6dsl_st_g_t;
Nint32_t lsm6dsl_gy_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t val);
Nint32_t lsm6dsl_gy_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t *val);
N
Nint32_t lsm6dsl_filter_settling_mask_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_filter_settling_mask_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_USE_SLOPE    = 0,
N  LSM6DSL_USE_HPF      = 1,
N  LSM6DSL_HP_PATH_ND   = 2,    /* ERROR CODE */
N} lsm6dsl_slope_fds_t;
Nint32_t lsm6dsl_xl_hp_path_internal_set(lsm6dsl_ctx_t *ctx,
N                                        lsm6dsl_slope_fds_t val);
Nint32_t lsm6dsl_xl_hp_path_internal_get(lsm6dsl_ctx_t *ctx,
N                                        lsm6dsl_slope_fds_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_ANA_BW_1k5Hz = 0,
N  LSM6DSL_XL_ANA_BW_400Hz = 1,
N  LSM6DSL_XL_ANA_BW_ND    = 2,    /* ERROR CODE */
N} lsm6dsl_bw0_xl_t;
Nint32_t lsm6dsl_xl_filter_analog_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_bw0_xl_t val);
Nint32_t lsm6dsl_xl_filter_analog_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_bw0_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_LP1_ODR_DIV_2 = 0,
N  LSM6DSL_XL_LP1_ODR_DIV_4 = 1,
N  LSM6DSL_XL_LP1_NA        = 2,  /* ERROR CODE */
N} lsm6dsl_lpf1_bw_sel_t;
Nint32_t lsm6dsl_xl_lp1_bandwidth_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_lpf1_bw_sel_t val);
Nint32_t lsm6dsl_xl_lp1_bandwidth_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_lpf1_bw_sel_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_50     = 0x00,
N  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_100    = 0x01,
N  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_9      = 0x02,
N  LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_400    = 0x03,
N  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_50   = 0x10,
N  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_100  = 0x11,
N  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_9    = 0x12,
N  LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_400  = 0x13,
N  LSM6DSL_XL_LP_NA                     = 0x20, /* ERROR CODE */
N} lsm6dsl_input_composite_t;
Nint32_t lsm6dsl_xl_lp2_bandwidth_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_input_composite_t val);
Nint32_t lsm6dsl_xl_lp2_bandwidth_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_input_composite_t *val);
N
Nint32_t lsm6dsl_xl_reference_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_xl_reference_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_HP_ODR_DIV_4      = 0x00, /* Slope filter */
N  LSM6DSL_XL_HP_ODR_DIV_100    = 0x01,
N  LSM6DSL_XL_HP_ODR_DIV_9      = 0x02,
N  LSM6DSL_XL_HP_ODR_DIV_400    = 0x03,
N  LSM6DSL_XL_HP_NA             = 0x10, /* ERROR CODE */
N} lsm6dsl_hpcf_xl_t;
Nint32_t lsm6dsl_xl_hp_bandwidth_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_hpcf_xl_t val);
Nint32_t lsm6dsl_xl_hp_bandwidth_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_hpcf_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_LP2_ONLY                    = 0x00,
N
N  LSM6DSL_HP_16mHz_LP2                = 0x80,
N  LSM6DSL_HP_65mHz_LP2                = 0x90,
N  LSM6DSL_HP_260mHz_LP2               = 0xA0,
N  LSM6DSL_HP_1Hz04_LP2                = 0xB0,
N
N  LSM6DSL_HP_DISABLE_LP1_LIGHT        = 0x0A,
N  LSM6DSL_HP_DISABLE_LP1_NORMAL       = 0x09,
N  LSM6DSL_HP_DISABLE_LP_STRONG        = 0x08,
N  LSM6DSL_HP_DISABLE_LP1_AGGRESSIVE   = 0x0B,
N
N  LSM6DSL_HP_16mHz_LP1_LIGHT          = 0x8A,
N  LSM6DSL_HP_65mHz_LP1_NORMAL         = 0x99,
N  LSM6DSL_HP_260mHz_LP1_STRONG        = 0xA8,
N  LSM6DSL_HP_1Hz04_LP1_AGGRESSIVE     = 0xBB,
N
N  LSM6DSL_HP_GY_BAND_NA               = 0xFF,    /* ERROR CODE */
N} lsm6dsl_lpf1_sel_g_t;
Nint32_t lsm6dsl_gy_band_pass_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_lpf1_sel_g_t val);
Nint32_t lsm6dsl_gy_band_pass_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_lpf1_sel_g_t *val);
N
Ntypedef enum {
N  LSM6DSL_SPI_4_WIRE  = 0,
N  LSM6DSL_SPI_3_WIRE  = 1,
N  LSM6DSL_SPI_MODE_ND = 2,    /* ERROR CODE */
N} lsm6dsl_sim_t;
Nint32_t lsm6dsl_spi_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t val);
Nint32_t lsm6dsl_spi_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t *val);
N
Ntypedef enum {
N  LSM6DSL_I2C_ENABLE   = 0,
N  LSM6DSL_I2C_DISABLE  = 1,
N  LSM6DSL_I2C_MODE_ND  = 2,    /* ERROR CODE */
N} lsm6dsl_i2c_disable_t;
Nint32_t lsm6dsl_i2c_interface_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_i2c_disable_t val);
Nint32_t lsm6dsl_i2c_interface_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_i2c_disable_t *val);
N
Ntypedef struct {
N  uint8_t int1_drdy_xl             : 1;
N  uint8_t int1_drdy_g              : 1;
N  uint8_t int1_boot                : 1;
N  uint8_t int1_fth                 : 1;
N  uint8_t int1_fifo_ovr            : 1;
N  uint8_t int1_full_flag           : 1;
N  uint8_t int1_sign_mot            : 1;
N  uint8_t int1_step_detector       : 1;
N  uint8_t int1_timer               : 1;
N  uint8_t int1_tilt                : 1;
N  uint8_t int1_6d                  : 1;
N  uint8_t int1_double_tap          : 1;
N  uint8_t int1_ff                  : 1;
N  uint8_t int1_wu                  : 1;
N  uint8_t int1_single_tap          : 1;
N  uint8_t int1_inact_state         : 1;
N  uint8_t den_drdy_int1            : 1;
N  uint8_t drdy_on_int1             : 1;
N} lsm6dsl_int1_route_t;
Nint32_t lsm6dsl_pin_int1_route_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int1_route_t val);
Nint32_t lsm6dsl_pin_int1_route_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int1_route_t *val);
N
Ntypedef struct{
N  uint8_t int2_drdy_xl             : 1;
N  uint8_t int2_drdy_g              : 1;
N  uint8_t int2_drdy_temp           : 1;
N  uint8_t int2_fth                 : 1;
N  uint8_t int2_fifo_ovr            : 1;
N  uint8_t int2_full_flag           : 1;
N  uint8_t int2_step_count_ov       : 1;
N  uint8_t int2_step_delta          : 1;
N  uint8_t int2_iron                : 1;
N  uint8_t int2_tilt                : 1;
N  uint8_t int2_6d                  : 1;
N  uint8_t int2_double_tap          : 1;
N  uint8_t int2_ff                  : 1;
N  uint8_t int2_wu                  : 1;
N  uint8_t int2_single_tap          : 1;
N  uint8_t int2_inact_state         : 1;
N  uint8_t int2_wrist_tilt          : 1;
N} lsm6dsl_int2_route_t;
Nint32_t lsm6dsl_pin_int2_route_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int2_route_t val);
Nint32_t lsm6dsl_pin_int2_route_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int2_route_t *val);
N
Ntypedef enum {
N  LSM6DSL_PUSH_PULL   = 0,
N  LSM6DSL_OPEN_DRAIN  = 1,
N  LSM6DSL_PIN_MODE_ND = 2,    /* ERROR CODE */
N} lsm6dsl_pp_od_t;
Nint32_t lsm6dsl_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t val);
Nint32_t lsm6dsl_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t *val);
N
Ntypedef enum {
N  LSM6DSL_ACTIVE_HIGH   = 0,
N  LSM6DSL_ACTIVE_LOW    = 1,
N  LSM6DSL_POLARITY_ND   = 2,    /* ERROR CODE */
N} lsm6dsl_h_lactive_t;
Nint32_t lsm6dsl_pin_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t val);
Nint32_t lsm6dsl_pin_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t *val);
N
Nint32_t lsm6dsl_all_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_all_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_INT_PULSED   = 0,
N  LSM6DSL_INT_LATCHED  = 1,
N  LSM6DSL_INT_MODE     = 2,    /* ERROR CODE */
N} lsm6dsl_lir_t;
Nint32_t lsm6dsl_int_notification_set(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t val);
Nint32_t lsm6dsl_int_notification_get(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t *val);
N
Nint32_t lsm6dsl_wkup_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_wkup_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_wkup_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_wkup_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_gy_sleep_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_gy_sleep_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_PROPERTY_DISABLE          = 0,
N  LSM6DSL_XL_12Hz5_GY_NOT_AFFECTED  = 1,
N  LSM6DSL_XL_12Hz5_GY_SLEEP         = 2,
N  LSM6DSL_XL_12Hz5_GY_PD            = 3,
N  LSM6DSL_ACT_MODE_ND               = 4,    /* ERROR CODE */
N} lsm6dsl_inact_en_t;
Nint32_t lsm6dsl_act_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t val);
Nint32_t lsm6dsl_act_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t *val);
N
Nint32_t lsm6dsl_act_sleep_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_act_sleep_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_src_get(lsm6dsl_ctx_t *ctx, lsm6dsl_tap_src_t *val);
N
Nint32_t lsm6dsl_tap_detection_on_z_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_detection_on_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_detection_on_y_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_detection_on_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_detection_on_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_detection_on_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_threshold_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_threshold_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_shock_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_shock_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_quiet_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_quiet_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tap_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tap_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_ONLY_SINGLE          = 0,
N  LSM6DSL_BOTH_SINGLE_DOUBLE   = 1,
N  LSM6DSL_TAP_MODE_ND          = 2,    /* ERROR CODE */
N} lsm6dsl_single_double_tap_t;
Nint32_t lsm6dsl_tap_mode_set(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_single_double_tap_t val);
Nint32_t lsm6dsl_tap_mode_get(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_single_double_tap_t *val);
N
Ntypedef enum {
N  LSM6DSL_ODR_DIV_2_FEED      = 0,
N  LSM6DSL_LPF2_FEED           = 1,
N  LSM6DSL_6D_FEED_ND          = 2,    /* ERROR CODE */
N} lsm6dsl_low_pass_on_6d_t;
Nint32_t lsm6dsl_6d_feed_data_set(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_low_pass_on_6d_t val);
Nint32_t lsm6dsl_6d_feed_data_get(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_low_pass_on_6d_t *val);
N
Ntypedef enum {
N  LSM6DSL_DEG_80      = 0,
N  LSM6DSL_DEG_70      = 1,
N  LSM6DSL_DEG_60      = 2,
N  LSM6DSL_DEG_50      = 3,
N  LSM6DSL_6D_TH_ND    = 4,    /* ERROR CODE */
N} lsm6dsl_sixd_ths_t;
Nint32_t lsm6dsl_6d_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t val);
Nint32_t lsm6dsl_6d_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t *val);
N
Nint32_t lsm6dsl_4d_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_4d_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_ff_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_ff_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_FF_TSH_156mg = 0,
N  LSM6DSL_FF_TSH_219mg = 1,
N  LSM6DSL_FF_TSH_250mg = 2,
N  LSM6DSL_FF_TSH_312mg = 3,
N  LSM6DSL_FF_TSH_344mg = 4,
N  LSM6DSL_FF_TSH_406mg = 5,
N  LSM6DSL_FF_TSH_469mg = 6,
N  LSM6DSL_FF_TSH_500mg = 7,
N  LSM6DSL_FF_TSH_ND    = 8,    /* ERROR CODE */
N} lsm6dsl_ff_ths_t;
Nint32_t lsm6dsl_ff_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t val);
Nint32_t lsm6dsl_ff_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t *val);
N
Nint32_t lsm6dsl_fifo_watermark_set(lsm6dsl_ctx_t *ctx, uint16_t val);
Nint32_t lsm6dsl_fifo_watermark_get(lsm6dsl_ctx_t *ctx, uint16_t *val);
N
Nint32_t lsm6dsl_fifo_data_level_get(lsm6dsl_ctx_t *ctx, uint16_t *val);
N
Nint32_t lsm6dsl_fifo_wtm_flag_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_fifo_pattern_get(lsm6dsl_ctx_t *ctx, uint16_t *val);
N
Nint32_t lsm6dsl_fifo_temp_batch_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_fifo_temp_batch_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_TRG_XL_GY_DRDY     = 0,
N  LSM6DSL_TRG_STEP_DETECT    = 1,
N  LSM6DSL_TRG_SH_DRDY        = 2,
N  LSM6DSL_TRG_SH_ND          = 3,    /* ERROR CODE */
N} lsm6dsl_trigger_fifo_t;
Nint32_t lsm6dsl_fifo_write_trigger_set(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_trigger_fifo_t val);
Nint32_t lsm6dsl_fifo_write_trigger_get(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_trigger_fifo_t *val);
N
Nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_set(lsm6dsl_ctx_t *ctx,
N                                                  uint8_t val);
Nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_get(lsm6dsl_ctx_t *ctx,
N                                                  uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_XL_DISABLE  = 0,
N  LSM6DSL_FIFO_XL_NO_DEC   = 1,
N  LSM6DSL_FIFO_XL_DEC_2    = 2,
N  LSM6DSL_FIFO_XL_DEC_3    = 3,
N  LSM6DSL_FIFO_XL_DEC_4    = 4,
N  LSM6DSL_FIFO_XL_DEC_8    = 5,
N  LSM6DSL_FIFO_XL_DEC_16   = 6,
N  LSM6DSL_FIFO_XL_DEC_32   = 7,
N  LSM6DSL_FIFO_XL_DEC_ND   = 8,    /* ERROR CODE */
N} lsm6dsl_dec_fifo_xl_t;
Nint32_t lsm6dsl_fifo_xl_batch_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_xl_t val);
Nint32_t lsm6dsl_fifo_xl_batch_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_xl_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_GY_DISABLE = 0,
N  LSM6DSL_FIFO_GY_NO_DEC  = 1,
N  LSM6DSL_FIFO_GY_DEC_2   = 2,
N  LSM6DSL_FIFO_GY_DEC_3   = 3,
N  LSM6DSL_FIFO_GY_DEC_4   = 4,
N  LSM6DSL_FIFO_GY_DEC_8   = 5,
N  LSM6DSL_FIFO_GY_DEC_16  = 6,
N  LSM6DSL_FIFO_GY_DEC_32  = 7,
N  LSM6DSL_FIFO_GY_DEC_ND  = 8,    /* ERROR CODE */
N} lsm6dsl_dec_fifo_gyro_t;
Nint32_t lsm6dsl_fifo_gy_batch_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_gyro_t val);
Nint32_t lsm6dsl_fifo_gy_batch_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_gyro_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_DS3_DISABLE   = 0,
N  LSM6DSL_FIFO_DS3_NO_DEC    = 1,
N  LSM6DSL_FIFO_DS3_DEC_2     = 2,
N  LSM6DSL_FIFO_DS3_DEC_3     = 3,
N  LSM6DSL_FIFO_DS3_DEC_4     = 4,
N  LSM6DSL_FIFO_DS3_DEC_8     = 5,
N  LSM6DSL_FIFO_DS3_DEC_16    = 6,
N  LSM6DSL_FIFO_DS3_DEC_32    = 7,
N  LSM6DSL_FIFO_DS3_DEC_ND    = 8,    /* ERROR CODE */
N} lsm6dsl_dec_ds3_fifo_t;
Nint32_t lsm6dsl_fifo_dataset_3_batch_set(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds3_fifo_t val);
Nint32_t lsm6dsl_fifo_dataset_3_batch_get(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds3_fifo_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_DS4_DISABLE  = 0,
N  LSM6DSL_FIFO_DS4_NO_DEC   = 1,
N  LSM6DSL_FIFO_DS4_DEC_2    = 2,
N  LSM6DSL_FIFO_DS4_DEC_3    = 3,
N  LSM6DSL_FIFO_DS4_DEC_4    = 4,
N  LSM6DSL_FIFO_DS4_DEC_8    = 5,
N  LSM6DSL_FIFO_DS4_DEC_16   = 6,
N  LSM6DSL_FIFO_DS4_DEC_32   = 7,
N  LSM6DSL_FIFO_DS4_DEC_ND   = 8,    /* ERROR CODE */
N} lsm6dsl_dec_ds4_fifo_t;
Nint32_t lsm6dsl_fifo_dataset_4_batch_set(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds4_fifo_t val);
Nint32_t lsm6dsl_fifo_dataset_4_batch_get(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds4_fifo_t *val);
N
Nint32_t lsm6dsl_fifo_xl_gy_8bit_format_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_fifo_xl_gy_8bit_format_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_fifo_stop_on_wtm_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_fifo_stop_on_wtm_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_BYPASS_MODE           = 0,
N  LSM6DSL_FIFO_MODE             = 1,
N  LSM6DSL_STREAM_TO_FIFO_MODE   = 3,
N  LSM6DSL_BYPASS_TO_STREAM_MODE = 4,
N  LSM6DSL_STREAM_MODE           = 6,
N  LSM6DSL_FIFO_MODE_ND          = 8,    /* ERROR CODE */
N} lsm6dsl_fifo_mode_t;
Nint32_t lsm6dsl_fifo_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t val);
Nint32_t lsm6dsl_fifo_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t *val);
N
Ntypedef enum {
N  LSM6DSL_FIFO_DISABLE   =  0,
N  LSM6DSL_FIFO_12Hz5     =  1,
N  LSM6DSL_FIFO_26Hz      =  2,
N  LSM6DSL_FIFO_52Hz      =  3,
N  LSM6DSL_FIFO_104Hz     =  4,
N  LSM6DSL_FIFO_208Hz     =  5,
N  LSM6DSL_FIFO_416Hz     =  6,
N  LSM6DSL_FIFO_833Hz     =  7,
N  LSM6DSL_FIFO_1k66Hz    =  8,
N  LSM6DSL_FIFO_3k33Hz    =  9,
N  LSM6DSL_FIFO_6k66Hz    = 10,
N  LSM6DSL_FIFO_RATE_ND   = 11,    /* ERROR CODE */
N} lsm6dsl_odr_fifo_t;
Nint32_t lsm6dsl_fifo_data_rate_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_odr_fifo_t val);
Nint32_t lsm6dsl_fifo_data_rate_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_odr_fifo_t *val);
N
Ntypedef enum {
N  LSM6DSL_DEN_ACT_LOW    = 0,
N  LSM6DSL_DEN_ACT_HIGH   = 1,
N  LSM6DSL_DEN_POL_ND     = 2,    /* ERROR CODE */
N} lsm6dsl_den_lh_t;
Nint32_t lsm6dsl_den_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t val);
Nint32_t lsm6dsl_den_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t *val);
N
Ntypedef enum {
N  LSM6DSL_DEN_DISABLE    = 0,
N  LSM6DSL_LEVEL_FIFO     = 6,
N  LSM6DSL_LEVEL_LETCHED  = 3,
N  LSM6DSL_LEVEL_TRIGGER  = 2,
N  LSM6DSL_EDGE_TRIGGER   = 4,
N  LSM6DSL_DEN_MODE_ND    = 5,    /* ERROR CODE */
N} lsm6dsl_den_mode_t;
Nint32_t lsm6dsl_den_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t val);
Nint32_t lsm6dsl_den_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t *val);
N
Ntypedef enum {
N  LSM6DSL_STAMP_IN_GY_DATA     = 0,
N  LSM6DSL_STAMP_IN_XL_DATA     = 1,
N  LSM6DSL_STAMP_IN_GY_XL_DATA  = 2,
N  LSM6DSL_DEN_STAMP_ND         = 3,    /* ERROR CODE */
N} lsm6dsl_den_xl_en_t;
Nint32_t lsm6dsl_den_enable_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t val);
Nint32_t lsm6dsl_den_enable_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t *val);
N
Nint32_t lsm6dsl_den_mark_axis_z_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_den_mark_axis_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_den_mark_axis_y_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_den_mark_axis_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_den_mark_axis_x_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_den_mark_axis_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_step_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_step_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_PEDO_AT_2g = 0,
N  LSM6DSL_PEDO_AT_4g = 1,
N  LSM6DSL_PEDO_FS_ND = 2,    /* ERROR CODE */
N} lsm6dsl_pedo_fs_t;
Nint32_t lsm6dsl_pedo_full_scale_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_pedo_fs_t val);
Nint32_t lsm6dsl_pedo_full_scale_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_pedo_fs_t *val);
N
Nint32_t lsm6dsl_pedo_debounce_steps_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_debounce_steps_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_timeout_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_pedo_timeout_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_pedo_steps_period_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_pedo_steps_period_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_motion_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_motion_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_motion_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_motion_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_wrist_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_wrist_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_tilt_latency_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_tilt_latency_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_tilt_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_tilt_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_tilt_src_set(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_a_wrist_tilt_mask_t *val);
Nint32_t lsm6dsl_tilt_src_get(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_a_wrist_tilt_mask_t *val);
N
Nint32_t lsm6dsl_mag_soft_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_mag_soft_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_mag_hard_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_mag_hard_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_mag_soft_iron_mat_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_mag_soft_iron_mat_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_mag_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff);
Nint32_t lsm6dsl_mag_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff);
N
Nint32_t lsm6dsl_func_en_set(lsm6dsl_ctx_t *ctx, uint8_t val);
N
Nint32_t lsm6dsl_sh_sync_sens_frame_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_sync_sens_frame_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_RES_RATIO_2_11  = 0,
N  LSM6DSL_RES_RATIO_2_12  = 1,
N  LSM6DSL_RES_RATIO_2_13  = 2,
N  LSM6DSL_RES_RATIO_2_14  = 3,
N  LSM6DSL_RES_RATIO_ND    = 4,    /* ERROR CODE */
N} lsm6dsl_rr_t;
Nint32_t lsm6dsl_sh_sync_sens_ratio_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t val);
Nint32_t lsm6dsl_sh_sync_sens_ratio_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t *val);
N
Nint32_t lsm6dsl_sh_master_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_master_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_sh_pass_through_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_pass_through_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_EXT_PULL_UP       = 0,
N  LSM6DSL_INTERNAL_PULL_UP  = 1,
N  LSM6DSL_SH_PIN_MODE       = 2,    /* ERROR CODE */
N} lsm6dsl_pull_up_en_t;
Nint32_t lsm6dsl_sh_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t val);
Nint32_t lsm6dsl_sh_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t *val);
N
Ntypedef enum {
N  LSM6DSL_XL_GY_DRDY        = 0,
N  LSM6DSL_EXT_ON_INT2_PIN   = 1,
N  LSM6DSL_SH_SYNCRO_ND      = 2,    /* ERROR CODE */
N} lsm6dsl_start_config_t;
Nint32_t lsm6dsl_sh_syncro_mode_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_start_config_t val);
Nint32_t lsm6dsl_sh_syncro_mode_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_start_config_t *val);
N
Nint32_t lsm6dsl_sh_drdy_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_drdy_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef struct {
N    lsm6dsl_sensorhub1_reg_t   sh_byte_1;
N    lsm6dsl_sensorhub2_reg_t   sh_byte_2;
N    lsm6dsl_sensorhub3_reg_t   sh_byte_3;
N    lsm6dsl_sensorhub4_reg_t   sh_byte_4;
N    lsm6dsl_sensorhub5_reg_t   sh_byte_5;
N    lsm6dsl_sensorhub6_reg_t   sh_byte_6;
N    lsm6dsl_sensorhub7_reg_t   sh_byte_7;
N    lsm6dsl_sensorhub8_reg_t   sh_byte_8;
N    lsm6dsl_sensorhub9_reg_t   sh_byte_9;
N    lsm6dsl_sensorhub10_reg_t  sh_byte_10;
N    lsm6dsl_sensorhub11_reg_t  sh_byte_11;
N    lsm6dsl_sensorhub12_reg_t  sh_byte_12;
N    lsm6dsl_sensorhub13_reg_t  sh_byte_13;
N    lsm6dsl_sensorhub14_reg_t  sh_byte_14;
N    lsm6dsl_sensorhub15_reg_t  sh_byte_15;
N    lsm6dsl_sensorhub16_reg_t  sh_byte_16;
N    lsm6dsl_sensorhub17_reg_t  sh_byte_17;
N    lsm6dsl_sensorhub18_reg_t  sh_byte_18;
N} lsm6dsl_emb_sh_read_t;
Nint32_t lsm6dsl_sh_read_data_raw_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_emb_sh_read_t *val);
N
Nint32_t lsm6dsl_sh_cmd_sens_sync_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_cmd_sens_sync_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Nint32_t lsm6dsl_sh_spi_sync_error_set(lsm6dsl_ctx_t *ctx, uint8_t val);
Nint32_t lsm6dsl_sh_spi_sync_error_get(lsm6dsl_ctx_t *ctx, uint8_t *val);
N
Ntypedef enum {
N  LSM6DSL_SLV_0        = 0,
N  LSM6DSL_SLV_0_1      = 1,
N  LSM6DSL_SLV_0_1_2    = 2,
N  LSM6DSL_SLV_0_1_2_3  = 3,
N  LSM6DSL_SLV_EN_ND    = 4,    /* ERROR CODE */
N} lsm6dsl_aux_sens_on_t;
Nint32_t lsm6dsl_sh_num_of_dev_connected_set(lsm6dsl_ctx_t *ctx,
N                                            lsm6dsl_aux_sens_on_t val);
Nint32_t lsm6dsl_sh_num_of_dev_connected_get(lsm6dsl_ctx_t *ctx,
N                                            lsm6dsl_aux_sens_on_t *val);
N
Ntypedef struct{
N  uint8_t   slv0_add;
N  uint8_t   slv0_subadd;
N  uint8_t   slv0_data;
N} lsm6dsl_sh_cfg_write_t;
Nint32_t lsm6dsl_sh_cfg_write(lsm6dsl_ctx_t *ctx, lsm6dsl_sh_cfg_write_t *val);
N
Ntypedef struct{
N  uint8_t   slv_add;
N  uint8_t   slv_subadd;
N  uint8_t   slv_len;
N} lsm6dsl_sh_cfg_read_t;
Nint32_t lsm6dsl_sh_slv0_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val);
Nint32_t lsm6dsl_sh_slv1_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val);
Nint32_t lsm6dsl_sh_slv2_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val);
Nint32_t lsm6dsl_sh_slv3_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val);
N
Ntypedef enum {
N  LSM6DSL_SL0_NO_DEC   = 0,
N  LSM6DSL_SL0_DEC_2    = 1,
N  LSM6DSL_SL0_DEC_4    = 2,
N  LSM6DSL_SL0_DEC_8    = 3,
N  LSM6DSL_SL0_DEC_ND   = 4,    /* ERROR CODE */
N} lsm6dsl_slave0_rate_t;
Nint32_t lsm6dsl_sh_slave_0_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave0_rate_t val);
Nint32_t lsm6dsl_sh_slave_0_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave0_rate_t *val);
N
Ntypedef enum {
N  LSM6DSL_EACH_SH_CYCLE     = 0,
N  LSM6DSL_ONLY_FIRST_CYCLE  = 1,
N  LSM6DSL_SH_WR_MODE_ND     = 2,    /* ERROR CODE */
N} lsm6dsl_write_once_t;
Nint32_t lsm6dsl_sh_write_mode_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_write_once_t val);
Nint32_t lsm6dsl_sh_write_mode_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_write_once_t *val);
N
Ntypedef enum {
N  LSM6DSL_SL1_NO_DEC   = 0,
N  LSM6DSL_SL1_DEC_2    = 1,
N  LSM6DSL_SL1_DEC_4    = 2,
N  LSM6DSL_SL1_DEC_8    = 3,
N  LSM6DSL_SL1_DEC_ND   = 4,    /* ERROR CODE */
N} lsm6dsl_slave1_rate_t;
Nint32_t lsm6dsl_sh_slave_1_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave1_rate_t val);
Nint32_t lsm6dsl_sh_slave_1_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave1_rate_t *val);
N
Ntypedef enum {
N  LSM6DSL_SL2_NO_DEC  = 0,
N  LSM6DSL_SL2_DEC_2   = 1,
N  LSM6DSL_SL2_DEC_4   = 2,
N  LSM6DSL_SL2_DEC_8   = 3,
N  LSM6DSL_SL2_DEC_ND  = 4,    /* ERROR CODE */
N} lsm6dsl_slave2_rate_t;
Nint32_t lsm6dsl_sh_slave_2_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave2_rate_t val);
Nint32_t lsm6dsl_sh_slave_2_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave2_rate_t *val);
N
Ntypedef enum {
N  LSM6DSL_SL3_NO_DEC  = 0,
N  LSM6DSL_SL3_DEC_2   = 1,
N  LSM6DSL_SL3_DEC_4   = 2,
N  LSM6DSL_SL3_DEC_8   = 3,
N  LSM6DSL_SL3_DEC_ND  = 4,    /* ERROR CODE */
N} lsm6dsl_slave3_rate_t;
Nint32_t lsm6dsl_sh_slave_3_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave3_rate_t val);
Nint32_t lsm6dsl_sh_slave_3_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave3_rate_t *val);
N
N/**
N  * @}
N  *
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LSM6DSL_DRIVER_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 38 "..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl\lsm6dsl_reg.c" 2
N
N/**
N  * @defgroup    LSM6DSL
N  * @brief       This file provides a set of functions needed to drive the
N  *              lsm6dsl enanced inertial module.
N  * @{
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_interfaces_functions
N  * @brief       This section provide a set of functions used to read and
N  *              write a generic register of the device.
N  *              MANDATORY: return 0 -> no Error.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Read generic device register
N  *
N  * @param  ctx   read / write interface definitions(ptr)
N  * @param  reg   register to read
N  * @param  data  pointer to buffer that store the data read(ptr)
N  * @param  len   number of consecutive register to read
N  * @retval       interface status (MANDATORY: return 0 -> no Error)
N  *
N  */
Nint32_t lsm6dsl_read_reg(lsm6dsl_ctx_t* ctx, uint8_t reg, uint8_t* data,
N                         uint16_t len)
N{
N  int32_t ret;
N  ret = ctx->read_reg(ctx->handle, reg, data, len);
N  return ret;
N}
N
N/**
N  * @brief  Write generic device register
N  *
N  * @param  ctx   read / write interface definitions(ptr)
N  * @param  reg   register to write
N  * @param  data  pointer to data to write in register reg(ptr)
N  * @param  len   number of consecutive register to write
N  * @retval       interface status (MANDATORY: return 0 -> no Error)
N  *
N  */
Nint32_t lsm6dsl_write_reg(lsm6dsl_ctx_t* ctx, uint8_t reg, uint8_t* data,
N                          uint16_t len)
N{
N  int32_t ret;
N  ret = ctx->write_reg(ctx->handle, reg, data, len);
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_Sensitivity
N  * @brief       These functions convert raw-data into engineering units.
N  * @{
N  *
N  */
N
Nfloat_t lsm6dsl_from_fs2g_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb * 0.061f);
N}
N
Nfloat_t lsm6dsl_from_fs4g_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb * 0.122f);
N}
N
Nfloat_t lsm6dsl_from_fs8g_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb * 0.244f);
N}
N
Nfloat_t lsm6dsl_from_fs16g_to_mg(int16_t lsb)
N{
N  return ((float_t)lsb * 0.488f);
N}
N
Nfloat_t lsm6dsl_from_fs125dps_to_mdps(int16_t lsb)
N{
N  return ((float_t)lsb * 4.375f);
N}
N
Nfloat_t lsm6dsl_from_fs250dps_to_mdps(int16_t lsb)
N{
N  return ((float_t)lsb * 8.750f);
N}
N
Nfloat_t lsm6dsl_from_fs500dps_to_mdps(int16_t lsb)
N{
N  return ((float_t)lsb * 17.50f);
N}
N
Nfloat_t lsm6dsl_from_fs1000dps_to_mdps(int16_t lsb)
N{
N  return ((float_t)lsb * 35.0f);
N}
N
Nfloat_t lsm6dsl_from_fs2000dps_to_mdps(int16_t lsb)
N{
N  return ((float_t)lsb * 70.0f);
N}
N
Nfloat_t lsm6dsl_from_lsb_to_celsius(int16_t lsb)
N{
N  return (((float_t)lsb / 256.0f) + 25.0f);
N}
N
N/**
N  * @}
N  *
N  */
N
N
N/**
N  * @defgroup    LSM6DSL_data_generation
N  * @brief       This section groups all the functions concerning data
N  *              generation
N  * @{
N  *
N*/
N
N/**
N  * @brief  Accelerometer full-scale selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of fs_xl in reg CTRL1_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t val)
N{
N  lsm6dsl_ctrl1_xl_t ctrl1_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  if(ret == 0){
N    ctrl1_xl.fs_xl = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Accelerometer full-scale selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of fs_xl in reg CTRL1_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t *val)
N{
N  lsm6dsl_ctrl1_xl_t ctrl1_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  switch (ctrl1_xl.fs_xl) {
N    case LSM6DSL_2g:
N      *val = LSM6DSL_2g;
N      break;
N    case LSM6DSL_16g:
N      *val = LSM6DSL_16g;
N      break;
N    case LSM6DSL_4g:
N      *val = LSM6DSL_4g;
N      break;
N    case LSM6DSL_8g:
N      *val = LSM6DSL_8g;
N      break;
N    default:
N      *val = LSM6DSL_XL_FS_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Accelerometer data rate selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of odr_xl in reg CTRL1_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t val)
N{
N  lsm6dsl_ctrl1_xl_t ctrl1_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  if(ret == 0){
N    ctrl1_xl.odr_xl = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Accelerometer data rate selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of odr_xl in reg CTRL1_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t *val)
N{
N  lsm6dsl_ctrl1_xl_t ctrl1_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  switch (ctrl1_xl.odr_xl) {
N    case LSM6DSL_XL_ODR_OFF:
N      *val = LSM6DSL_XL_ODR_OFF;
N      break;
N    case LSM6DSL_XL_ODR_12Hz5:
N      *val = LSM6DSL_XL_ODR_12Hz5;
N      break;
N    case LSM6DSL_XL_ODR_26Hz:
N      *val = LSM6DSL_XL_ODR_26Hz;
N      break;
N    case LSM6DSL_XL_ODR_52Hz:
N      *val = LSM6DSL_XL_ODR_52Hz;
N      break;
N    case LSM6DSL_XL_ODR_104Hz:
N      *val = LSM6DSL_XL_ODR_104Hz;
N      break;
N    case LSM6DSL_XL_ODR_208Hz:
N      *val = LSM6DSL_XL_ODR_208Hz;
N      break;
N    case LSM6DSL_XL_ODR_416Hz:
N      *val = LSM6DSL_XL_ODR_416Hz;
N      break;
N    case LSM6DSL_XL_ODR_833Hz:
N      *val = LSM6DSL_XL_ODR_833Hz;
N      break;
N    case LSM6DSL_XL_ODR_1k66Hz:
N      *val = LSM6DSL_XL_ODR_1k66Hz;
N      break;
N    case LSM6DSL_XL_ODR_3k33Hz:
N      *val = LSM6DSL_XL_ODR_3k33Hz;
N      break;
N    case LSM6DSL_XL_ODR_6k66Hz:
N      *val = LSM6DSL_XL_ODR_6k66Hz;
N      break;
N    case LSM6DSL_XL_ODR_1Hz6:
N      *val = LSM6DSL_XL_ODR_1Hz6;
N      break;
N    default:
N      *val = LSM6DSL_XL_ODR_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Gyroscope chain full-scale selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of fs_g in reg CTRL2_G
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t val)
N{
N  lsm6dsl_ctrl2_g_t ctrl2_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x11U, (uint8_t*)&ctrl2_g, 1);
N  if(ret == 0){
N    ctrl2_g.fs_g = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x11U, (uint8_t*)&ctrl2_g, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Gyroscope chain full-scale selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of fs_g in reg CTRL2_G
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t *val)
N{
N  lsm6dsl_ctrl2_g_t ctrl2_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x11U, (uint8_t*)&ctrl2_g, 1);
N  switch (ctrl2_g.fs_g) {
N    case LSM6DSL_250dps:
N      *val = LSM6DSL_250dps;
N      break;
N    case LSM6DSL_125dps:
N      *val = LSM6DSL_125dps;
N      break;
N    case LSM6DSL_500dps:
N      *val = LSM6DSL_500dps;
N      break;
N    case LSM6DSL_1000dps:
N      *val = LSM6DSL_1000dps;
N      break;
N    case LSM6DSL_2000dps:
N      *val = LSM6DSL_2000dps;
N      break;
N    default:
N      *val = LSM6DSL_GY_FS_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Gyroscope data rate selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of odr_g in reg CTRL2_G
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t val)
N{
N  lsm6dsl_ctrl2_g_t ctrl2_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x11U, (uint8_t*)&ctrl2_g, 1);
N  if(ret == 0){
N    ctrl2_g.odr_g = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x11U, (uint8_t*)&ctrl2_g, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Gyroscope data rate selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of odr_g in reg CTRL2_G
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t *val)
N{
N  lsm6dsl_ctrl2_g_t ctrl2_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x11U, (uint8_t*)&ctrl2_g, 1);
N  switch (ctrl2_g.odr_g) {
N    case LSM6DSL_GY_ODR_OFF:
N      *val = LSM6DSL_GY_ODR_OFF;
N      break;
N    case LSM6DSL_GY_ODR_12Hz5:
N      *val = LSM6DSL_GY_ODR_12Hz5;
N      break;
N    case LSM6DSL_GY_ODR_26Hz:
N      *val = LSM6DSL_GY_ODR_26Hz;
N      break;
N    case LSM6DSL_GY_ODR_52Hz:
N      *val = LSM6DSL_GY_ODR_52Hz;
N      break;
N    case LSM6DSL_GY_ODR_104Hz:
N      *val = LSM6DSL_GY_ODR_104Hz;
N      break;
N    case LSM6DSL_GY_ODR_208Hz:
N      *val = LSM6DSL_GY_ODR_208Hz;
N      break;
N    case LSM6DSL_GY_ODR_416Hz:
N      *val = LSM6DSL_GY_ODR_416Hz;
N      break;
N    case LSM6DSL_GY_ODR_833Hz:
N      *val = LSM6DSL_GY_ODR_833Hz;
N      break;
N    case LSM6DSL_GY_ODR_1k66Hz:
N      *val = LSM6DSL_GY_ODR_1k66Hz;
N      break;
N    case LSM6DSL_GY_ODR_3k33Hz:
N      *val = LSM6DSL_GY_ODR_3k33Hz;
N      break;
N    case LSM6DSL_GY_ODR_6k66Hz:
N      *val = LSM6DSL_GY_ODR_6k66Hz;
N      break;
N    default:
N      *val = LSM6DSL_GY_ODR_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Block data update.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of bdu in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_block_data_update_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  if(ret == 0){
N    ctrl3_c.bdu = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Block data update.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of bdu in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_block_data_update_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  *val = ctrl3_c.bdu;
N
N  return ret;
N}
N
N/**
N  * @brief  Weight of XL user offset bits of registers
N  *         X_OFS_USR(73h), Y_OFS_USR(74h), Z_OFS_USR(75h).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of usr_off_w in reg CTRL6_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_offset_weight_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_usr_off_w_t val)
N{
N  lsm6dsl_ctrl6_c_t ctrl6_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  if(ret == 0){
N    ctrl6_c.usr_off_w = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Weight of XL user offset bits of registers
N  *         X_OFS_USR(73h), Y_OFS_USR(74h), Z_OFS_USR(75h).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of usr_off_w in reg CTRL6_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_offset_weight_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_usr_off_w_t *val)
N{
N  lsm6dsl_ctrl6_c_t ctrl6_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  switch (ctrl6_c.usr_off_w) {
N    case LSM6DSL_LSb_1mg:
N      *val = LSM6DSL_LSb_1mg;
N      break;
N    case LSM6DSL_LSb_16mg:
N      *val = LSM6DSL_LSb_16mg;
N      break;
N    default:
N      *val = LSM6DSL_WEIGHT_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  High-performance operating mode for accelerometer[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of xl_hm_mode in reg CTRL6_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_power_mode_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_xl_hm_mode_t val)
N{
N  lsm6dsl_ctrl6_c_t ctrl6_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  if(ret == 0){
N    ctrl6_c.xl_hm_mode = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  High-performance operating mode for accelerometer.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of xl_hm_mode in reg CTRL6_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_power_mode_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_xl_hm_mode_t *val)
N{
N  lsm6dsl_ctrl6_c_t ctrl6_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  switch (ctrl6_c.xl_hm_mode) {
N    case LSM6DSL_XL_HIGH_PERFORMANCE:
N      *val = LSM6DSL_XL_HIGH_PERFORMANCE;
N      break;
N    case LSM6DSL_XL_NORMAL:
N      *val = LSM6DSL_XL_NORMAL;
N      break;
N    default:
N      *val = LSM6DSL_XL_PW_MODE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Source register rounding function on WAKE_UP_SRC (1Bh),
N  *         TAP_SRC (1Ch), D6D_SRC (1Dh), STATUS_REG (1Eh) and
N  *         FUNC_SRC1 (53h) registers in the primary interface.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of rounding_status in reg CTRL7_G
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_rounding_on_status_set(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_rounding_status_t val)
N{
N  lsm6dsl_ctrl7_g_t ctrl7_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N  if(ret == 0){
N    ctrl7_g.rounding_status = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Source register rounding function on WAKE_UP_SRC (1Bh),
N  *         TAP_SRC (1Ch), D6D_SRC (1Dh), STATUS_REG (1Eh) and
N  *         FUNC_SRC1 (53h) registers in the primary interface.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of rounding_status in reg CTRL7_G
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_rounding_on_status_get(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_rounding_status_t *val)
N{
N  lsm6dsl_ctrl7_g_t ctrl7_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N  switch (ctrl7_g.rounding_status) {
N    case LSM6DSL_STAT_RND_DISABLE:
N      *val = LSM6DSL_STAT_RND_DISABLE;
N      break;
N    case LSM6DSL_STAT_RND_ENABLE:
N      *val = LSM6DSL_STAT_RND_ENABLE;
N      break;
N    default:
N      *val = LSM6DSL_STAT_RND_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  High-performance operating mode disable for gyroscope.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of g_hm_mode in reg CTRL7_G
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_power_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_g_hm_mode_t val)
N{
N  lsm6dsl_ctrl7_g_t ctrl7_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N  if(ret == 0){
N    ctrl7_g.g_hm_mode = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  High-performance operating mode disable for gyroscope.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of g_hm_mode in reg CTRL7_G
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_power_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_g_hm_mode_t *val)
N{
N  lsm6dsl_ctrl7_g_t ctrl7_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N  switch (ctrl7_g.g_hm_mode) {
N    case LSM6DSL_GY_HIGH_PERFORMANCE:
N      *val = LSM6DSL_GY_HIGH_PERFORMANCE;
N      break;
N    case LSM6DSL_GY_NORMAL:
N      *val = LSM6DSL_GY_NORMAL;
N      break;
N    default:
N      *val = LSM6DSL_GY_PW_MODE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Read all the interrupt/status flag of the device.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    WAKE_UP_SRC, TAP_SRC, D6D_SRC, STATUS_REG,
N  *                FUNC_SRC1, FUNC_SRC2, WRIST_TILT_IA, A_WRIST_TILT_Mask
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_all_sources_get(lsm6dsl_ctx_t *ctx,
N                                lsm6dsl_all_sources_t *val)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_SRC,
X  ret = lsm6dsl_read_reg(ctx, 0x1BU,
N                         (uint8_t*)&(val->wake_up_src), 1);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_SRC,
X    ret = lsm6dsl_read_reg(ctx, 0x1CU,
N                           (uint8_t*)&(val->tap_src), 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_D6D_SRC,
X    ret = lsm6dsl_read_reg(ctx, 0x1DU,
N                           (uint8_t*)&(val->d6d_src), 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG,
X    ret = lsm6dsl_read_reg(ctx, 0x1EU,
N                           (uint8_t*)&(val->status_reg), 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_FUNC_SRC1,
X    ret = lsm6dsl_read_reg(ctx, 0x53U,
N                           (uint8_t*)&(val->func_src1), 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_FUNC_SRC2,
X    ret = lsm6dsl_read_reg(ctx, 0x54U,
N                           (uint8_t*)&(val->func_src2), 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_WRIST_TILT_IA,
X    ret = lsm6dsl_read_reg(ctx, 0x55U,
N                           (uint8_t*)&(val->wrist_tilt_ia), 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_MASK,
X    ret = lsm6dsl_read_reg(ctx, 0x59U,
N                           (uint8_t*)&(val->a_wrist_tilt_mask), 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N  }
N
N  return ret;
N}
N/**
N  * @brief  The STATUS_REG register is read by the primary interface[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Registers STATUS_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_status_reg_get(lsm6dsl_ctx_t *ctx, lsm6dsl_status_reg_t *val)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG, (uint8_t*) val, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x1EU, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Accelerometer new data available.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of xlda in reg STATUS_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_status_reg_t status_reg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG, (uint8_t*)&status_reg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x1EU, (uint8_t*)&status_reg, 1);
N  *val = status_reg.xlda;
N
N  return ret;
N}
N
N/**
N  * @brief  Gyroscope new data available.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of gda in reg STATUS_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_status_reg_t status_reg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG, (uint8_t*)&status_reg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x1EU, (uint8_t*)&status_reg, 1);
N  *val = status_reg.gda;
N
N  return ret;
N}
N
N/**
N  * @brief  Temperature new data available.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tda in reg STATUS_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_temp_flag_data_ready_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_status_reg_t status_reg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_STATUS_REG, (uint8_t*)&status_reg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x1EU, (uint8_t*)&status_reg, 1);
N  *val = status_reg.tda;
N
N  return ret;
N}
N
N/**
N  * @brief  Accelerometer axis user offset correction expressed in two’s
N  *         complement, weight depends on USR_OFF_W in CTRL6_C.
N  *         The value must be in the range [-127 127].[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that contains data to write
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_usr_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm6dsl_write_reg(ctx, LSM6DSL_X_OFS_USR, buff, 3);
X  ret = lsm6dsl_write_reg(ctx, 0x73U, buff, 3);
N  return ret;
N}
N
N/**
N  * @brief  Accelerometer axis user offset correction xpressed in two’s
N  *         complement, weight depends on USR_OFF_W in CTRL6_C.
N  *         The value must be in the range [-127 127].[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_usr_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_X_OFS_USR, buff, 3);
X  ret = lsm6dsl_read_reg(ctx, 0x73U, buff, 3);
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_Timestamp
N  * @brief       This section groups all the functions that manage the
N  *              timestamp generation.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Enable timestamp count. The count is saved in TIMESTAMP0_REG (40h),
N  *         TIMESTAMP1_REG (41h) and TIMESTAMP2_REG (42h).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of timer_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_timestamp_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  if(ret == 0){
N    ctrl10_c.timer_en = val;
N    if ( val != 0x00U) {
N      ctrl10_c.func_en = val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X      ret = lsm6dsl_write_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable timestamp count. The count is saved in TIMESTAMP0_REG (40h),
N  *         TIMESTAMP1_REG (41h) and TIMESTAMP2_REG (42h).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of timer_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_timestamp_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  *val = ctrl10_c.timer_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Timestamp register resolution setting.
N  *         Configuration of this bit affects
N  *         TIMESTAMP0_REG(40h), TIMESTAMP1_REG(41h),
N  *         TIMESTAMP2_REG(42h), STEP_TIMESTAMP_L(49h),
N  *         STEP_TIMESTAMP_H(4Ah) and
N  *         STEP_COUNT_DELTA(15h) registers.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of timer_hr in reg WAKE_UP_DUR
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_timestamp_res_set(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t val)
N{
N  lsm6dsl_wake_up_dur_t wake_up_dur;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, (uint8_t*)&wake_up_dur, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5CU, (uint8_t*)&wake_up_dur, 1);
N  if(ret == 0){
N    wake_up_dur.timer_hr = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_DUR,
X    ret = lsm6dsl_write_reg(ctx, 0x5CU,
N                            (uint8_t*)&wake_up_dur, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Timestamp register resolution setting.
N  *         Configuration of this bit affects
N  *         TIMESTAMP0_REG(40h), TIMESTAMP1_REG(41h),
N  *         TIMESTAMP2_REG(42h), STEP_TIMESTAMP_L(49h),
N  *         STEP_TIMESTAMP_H(4Ah) and
N  *         STEP_COUNT_DELTA(15h) registers.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of timer_hr in reg WAKE_UP_DUR
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_timestamp_res_get(lsm6dsl_ctx_t *ctx, lsm6dsl_timer_hr_t *val)
N{
N  lsm6dsl_wake_up_dur_t wake_up_dur;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, (uint8_t*)&wake_up_dur, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5CU, (uint8_t*)&wake_up_dur, 1);
N  switch (wake_up_dur.timer_hr) {
N    case LSM6DSL_LSB_6ms4:
N      *val = LSM6DSL_LSB_6ms4;
N      break;
N    case LSM6DSL_LSB_25us:
N      *val = LSM6DSL_LSB_25us;
N      break;
N    default:
N      *val = LSM6DSL_TS_RES_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_Dataoutput
N  * @brief       This section groups all the data output functions.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Circular burst-mode (rounding) read from output registers
N  *         through the primary interface.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of rounding in reg CTRL5_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_rounding_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t val)
N{
N  lsm6dsl_ctrl5_c_t ctrl5_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  if(ret == 0){
N    ctrl5_c.rounding = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Circular burst-mode (rounding) read from output registers
N  *         through the primary interface.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of rounding in reg CTRL5_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_rounding_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rounding_t *val)
N{
N  lsm6dsl_ctrl5_c_t ctrl5_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  switch (ctrl5_c.rounding) {
N    case LSM6DSL_ROUND_DISABLE:
N      *val = LSM6DSL_ROUND_DISABLE;
N      break;
N    case LSM6DSL_ROUND_XL:
N      *val = LSM6DSL_ROUND_XL;
N      break;
N    case LSM6DSL_ROUND_GY:
N      *val = LSM6DSL_ROUND_GY;
N      break;
N    case LSM6DSL_ROUND_GY_XL:
N      *val = LSM6DSL_ROUND_GY_XL;
N      break;
N    case LSM6DSL_ROUND_SH1_TO_SH6:
N      *val = LSM6DSL_ROUND_SH1_TO_SH6;
N      break;
N    case LSM6DSL_ROUND_XL_SH1_TO_SH6:
N      *val = LSM6DSL_ROUND_XL_SH1_TO_SH6;
N      break;
N    case LSM6DSL_ROUND_GY_XL_SH1_TO_SH12:
N      *val = LSM6DSL_ROUND_GY_XL_SH1_TO_SH12;
N      break;
N    case LSM6DSL_ROUND_GY_XL_SH1_TO_SH6:
N      *val = LSM6DSL_ROUND_GY_XL_SH1_TO_SH6;
N      break;
N    default:
N      *val = LSM6DSL_ROUND_OUT_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Temperature data output register (r). L and H registers together
N  *         express a 16-bit word in two’s complement.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_temperature_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_OUT_TEMP_L, buff, 2);
X  ret = lsm6dsl_read_reg(ctx, 0x20U, buff, 2);
N  return ret;
N}
N
N/**
N  * @brief  Angular rate sensor. The value is expressed as a 16-bit word in
N  *         two’s complement.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_angular_rate_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_OUTX_L_G, buff, 6);
X  ret = lsm6dsl_read_reg(ctx, 0x22U, buff, 6);
N  return ret;
N}
N
N/**
N  * @brief  Linear acceleration output register. The value is expressed
N  *         as a 16-bit word in two’s complement.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_acceleration_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_OUTX_L_XL, buff, 6);
X  ret = lsm6dsl_read_reg(ctx, 0x28U, buff, 6);
N  return ret;
N}
N
N/**
N  * @brief  External magnetometer raw data.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_calibrated_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_OUT_MAG_RAW_X_L, buff, 6);
X  ret = lsm6dsl_read_reg(ctx, 0x66U, buff, 6);
N  return ret;
N}
N
N/**
N  * @brief  Read data in FIFO.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buffer Data buffer to store FIFO data.
N  * @param  len    Number of data to read from FIFO.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_raw_data_get(lsm6dsl_ctx_t *ctx, uint8_t *buffer,
N                                  uint8_t len)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_DATA_OUT_L, buffer, len);
X  ret = lsm6dsl_read_reg(ctx, 0x3EU, buffer, len);
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_common
N  * @brief       This section groups common usefull functions.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Enable access to the embedded functions/sensor hub
N  *         configuration registers[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of func_cfg_en in reg FUNC_CFG_ACCESS
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mem_bank_set(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t val)
N{
N  lsm6dsl_func_cfg_access_t func_cfg_access;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FUNC_CFG_ACCESS,
X  ret = lsm6dsl_read_reg(ctx, 0x01U,
N                         (uint8_t*)&func_cfg_access, 1);
N  if(ret == 0){
N    func_cfg_access.func_cfg_en = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FUNC_CFG_ACCESS,
X    ret = lsm6dsl_write_reg(ctx, 0x01U,
N                            (uint8_t*)&func_cfg_access, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Enable access to the embedded functions/sensor hub configuration
N  *         registers[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of func_cfg_en in reg FUNC_CFG_ACCESS
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mem_bank_get(lsm6dsl_ctx_t *ctx, lsm6dsl_func_cfg_en_t *val)
N{
N  lsm6dsl_func_cfg_access_t func_cfg_access;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FUNC_CFG_ACCESS,
X  ret = lsm6dsl_read_reg(ctx, 0x01U,
N                         (uint8_t*)&func_cfg_access, 1);
N  switch (func_cfg_access.func_cfg_en) {
N    case LSM6DSL_USER_BANK:
N      *val = LSM6DSL_USER_BANK;
N      break;
N    case LSM6DSL_BANK_B:
N      *val = LSM6DSL_BANK_B;
N      break;
N    default:
N      *val = LSM6DSL_BANK_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Data-ready pulsed / letched mode[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of drdy_pulsed in reg DRDY_PULSE_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_data_ready_mode_set(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_drdy_pulsed_g_t val)
N{
N  lsm6dsl_drdy_pulse_cfg_g_t drdy_pulse_cfg_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G,
X  ret = lsm6dsl_read_reg(ctx, 0x0BU,
N                         (uint8_t*)&drdy_pulse_cfg_g, 1);
N  if(ret == 0){
N    drdy_pulse_cfg_g.drdy_pulsed = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G,
X    ret = lsm6dsl_write_reg(ctx, 0x0BU,
N                            (uint8_t*)&drdy_pulse_cfg_g, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Data-ready pulsed / letched mode[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of drdy_pulsed in reg DRDY_PULSE_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_data_ready_mode_get(lsm6dsl_ctx_t *ctx,
N                                    lsm6dsl_drdy_pulsed_g_t *val)
N{
N  lsm6dsl_drdy_pulse_cfg_g_t drdy_pulse_cfg_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G,
X  ret = lsm6dsl_read_reg(ctx, 0x0BU,
N                         (uint8_t*)&drdy_pulse_cfg_g, 1);
N  switch (drdy_pulse_cfg_g.drdy_pulsed) {
N    case LSM6DSL_DRDY_LATCHED:
N      *val = LSM6DSL_DRDY_LATCHED;
N      break;
N    case LSM6DSL_DRDY_PULSED:
N      *val = LSM6DSL_DRDY_PULSED;
N      break;
N    default:
N      *val = LSM6DSL_DRDY_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  DeviceWhoamI.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_device_id_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WHO_AM_I, buff, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0FU, buff, 1);
N  return ret;
N}
N
N/**
N  * @brief  Software reset. Restore the default values in user registers[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sw_reset in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  if(ret == 0){
N    ctrl3_c.sw_reset = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Software reset. Restore the default values in user registers[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sw_reset in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  *val = ctrl3_c.sw_reset;
N
N  return ret;
N}
N
N/**
N  * @brief  Big/Little Endian Data selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of ble in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_data_format_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  if(ret == 0){
N    ctrl3_c.ble = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Big/Little Endian Data selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of ble in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_data_format_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ble_t *val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  switch (ctrl3_c.ble) {
N    case LSM6DSL_LSB_AT_LOW_ADD:
N      *val = LSM6DSL_LSB_AT_LOW_ADD;
N      break;
N    case LSM6DSL_MSB_AT_LOW_ADD:
N      *val = LSM6DSL_MSB_AT_LOW_ADD;
N      break;
N    default:
N      *val = LSM6DSL_DATA_FMT_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Register address automatically incremented during a multiple byte
N  *         access with a serial interface.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of if_inc in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_auto_increment_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  if(ret == 0){
N    ctrl3_c.if_inc = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Register address automatically incremented during a multiple byte
N  *         access with a serial interface.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of if_inc in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_auto_increment_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  *val = ctrl3_c.if_inc;
N
N  return ret;
N}
N
N/**
N  * @brief  Reboot memory content. Reload the calibration parameters.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of boot in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_boot_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  if(ret == 0){
N    ctrl3_c.boot = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Reboot memory content. Reload the calibration parameters.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of boot in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_boot_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  *val = ctrl3_c.boot;
N
N  return ret;
N}
N
N/**
N  * @brief  Linear acceleration sensor self-test enable.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of st_xl in reg CTRL5_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t val)
N{
N  lsm6dsl_ctrl5_c_t ctrl5_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  if(ret == 0){
N    ctrl5_c.st_xl = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Linear acceleration sensor self-test enable.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of st_xl in reg CTRL5_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_xl_t *val)
N{
N  lsm6dsl_ctrl5_c_t ctrl5_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  switch (ctrl5_c.st_xl) {
N    case LSM6DSL_XL_ST_DISABLE:
N      *val = LSM6DSL_XL_ST_DISABLE;
N      break;
N    case LSM6DSL_XL_ST_POSITIVE:
N      *val = LSM6DSL_XL_ST_POSITIVE;
N      break;
N    case LSM6DSL_XL_ST_NEGATIVE:
N      *val = LSM6DSL_XL_ST_NEGATIVE;
N      break;
N    default:
N      *val = LSM6DSL_XL_ST_ND;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Angular rate sensor self-test enable.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of st_g in reg CTRL5_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_self_test_set(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t val)
N{
N  lsm6dsl_ctrl5_c_t ctrl5_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  if(ret == 0){
N    ctrl5_c.st_g = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Angular rate sensor self-test enable.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of st_g in reg CTRL5_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_self_test_get(lsm6dsl_ctx_t *ctx, lsm6dsl_st_g_t *val)
N{
N  lsm6dsl_ctrl5_c_t ctrl5_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  switch (ctrl5_c.st_g) {
N    case LSM6DSL_GY_ST_DISABLE:
N      *val = LSM6DSL_GY_ST_DISABLE;
N      break;
N    case LSM6DSL_GY_ST_POSITIVE:
N      *val = LSM6DSL_GY_ST_POSITIVE;
N      break;
N    case LSM6DSL_GY_ST_NEGATIVE:
N      *val = LSM6DSL_GY_ST_NEGATIVE;
N      break;
N    default:
N      *val = LSM6DSL_GY_ST_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_filters
N  * @brief       This section group all the functions concerning the filters
N  *              configuration that impact both accelerometer and gyro.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Mask DRDY on pin (both XL & Gyro) until filter settling ends
N  *         (XL and Gyro independently masked).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of drdy_mask in reg CTRL4_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_filter_settling_mask_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  if(ret == 0){
N    ctrl4_c.drdy_mask = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Mask DRDY on pin (both XL & Gyro) until filter settling ends
N  *         (XL and Gyro independently masked).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of drdy_mask in reg CTRL4_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_filter_settling_mask_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  *val = ctrl4_c.drdy_mask;
N
N  return ret;
N}
N
N/**
N  * @brief  HPF or SLOPE filter selection on wake-up and Activity/Inactivity
N  *         functions.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of slope_fds in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_hp_path_internal_set(lsm6dsl_ctx_t *ctx,
N                                        lsm6dsl_slope_fds_t val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  if(ret == 0){
N    tap_cfg.slope_fds = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  HPF or SLOPE filter selection on wake-up and Activity/Inactivity
N  *         functions.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of slope_fds in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_hp_path_internal_get(lsm6dsl_ctx_t *ctx,
N                                        lsm6dsl_slope_fds_t *val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  switch (tap_cfg.slope_fds) {
N    case LSM6DSL_USE_SLOPE:
N      *val = LSM6DSL_USE_SLOPE;
N      break;
N    case LSM6DSL_USE_HPF:
N      *val = LSM6DSL_USE_HPF;
N      break;
N    default:
N      *val = LSM6DSL_HP_PATH_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_accelerometer_filters
N  * @brief       This section group all the functions concerning the filters
N  *              configuration that impact accelerometer in every mode.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Accelerometer analog chain bandwidth selection (only for
N  *         accelerometer ODR ≥ 1.67 kHz).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of bw0_xl in reg CTRL1_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_filter_analog_set(lsm6dsl_ctx_t *ctx, lsm6dsl_bw0_xl_t val)
N{
N  lsm6dsl_ctrl1_xl_t ctrl1_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  if(ret == 0){
N    ctrl1_xl.bw0_xl = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Accelerometer analog chain bandwidth selection (only for
N  *         accelerometer ODR ≥ 1.67 kHz).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of bw0_xl in reg CTRL1_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_filter_analog_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_bw0_xl_t *val)
N{
N  lsm6dsl_ctrl1_xl_t ctrl1_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  switch (ctrl1_xl.bw0_xl) {
N    case LSM6DSL_XL_ANA_BW_1k5Hz:
N      *val = LSM6DSL_XL_ANA_BW_1k5Hz;
N      break;
N    case LSM6DSL_XL_ANA_BW_400Hz:
N      *val = LSM6DSL_XL_ANA_BW_400Hz;
N      break;
N    default:
N      *val = LSM6DSL_XL_ANA_BW_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_accelerometer_filters
N  * @brief       This section group all the functions concerning the filters
N  *              configuration that impact accelerometer.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Accelerometer digital LPF (LPF1) bandwidth selection LPF2 is
N  *         not used.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of lpf1_bw_sel in reg CTRL1_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_lp1_bandwidth_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_lpf1_bw_sel_t val)
N{
N  lsm6dsl_ctrl1_xl_t ctrl1_xl;
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N  if(ret == 0){
N    ctrl1_xl.lpf1_bw_sel = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N    if(ret == 0){
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X      ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N      if(ret == 0){
N        ctrl8_xl.lpf2_xl_en = 0;
N        ctrl8_xl.hp_slope_xl_en = 0;
N        ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X        ret = lsm6dsl_write_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Accelerometer digital LPF (LPF1) bandwidth selection LPF2
N  *         is not used.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of lpf1_bw_sel in reg CTRL1_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_lp1_bandwidth_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_lpf1_bw_sel_t *val)
N{
N  lsm6dsl_ctrl1_xl_t ctrl1_xl;
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  if(ret == 0){
N    if ((ctrl8_xl.lpf2_xl_en != 0x00U) ||
N        (ctrl8_xl.hp_slope_xl_en != 0x00U)){
N      *val = LSM6DSL_XL_LP1_NA;
N    }
N    else{
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
X      ret = lsm6dsl_read_reg(ctx, 0x10U, (uint8_t*)&ctrl1_xl, 1);
N      switch ( ctrl1_xl.lpf1_bw_sel) {
N        case LSM6DSL_XL_LP1_ODR_DIV_2:
N          *val = LSM6DSL_XL_LP1_ODR_DIV_2;
N          break;
N        case LSM6DSL_XL_LP1_ODR_DIV_4:
N          *val = LSM6DSL_XL_LP1_ODR_DIV_4;
N          break;
N        default:
N          *val = LSM6DSL_XL_LP1_NA;
N          break;
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  LPF2 on outputs[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of input_composite in reg CTRL8_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_lp2_bandwidth_set(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_input_composite_t val)
N{
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  if(ret == 0){
N    ctrl8_xl.input_composite = ( (uint8_t) val & 0x10U ) >> 4;
N    ctrl8_xl.hpcf_xl = (uint8_t) val & 0x03U;
N    ctrl8_xl.lpf2_xl_en = 1;
N    ctrl8_xl.hp_slope_xl_en = 0;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  LPF2 on outputs[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of input_composite in reg CTRL8_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_lp2_bandwidth_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_input_composite_t *val)
N{
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  if(ret == 0){
N    if ((ctrl8_xl.lpf2_xl_en == 0x00U) ||
N        (ctrl8_xl.hp_slope_xl_en != 0x00U)){
N      *val = LSM6DSL_XL_LP_NA;
N    }
N    else{
N      switch ((ctrl8_xl.input_composite << 4) + ctrl8_xl.hpcf_xl) {
N        case LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_50:
N          *val = LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_50;
N          break;
N        case LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_100:
N          *val = LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_100;
N          break;
N        case LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_9:
N          *val = LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_9;
N          break;
N        case LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_400:
N          *val = LSM6DSL_XL_LOW_LAT_LP_ODR_DIV_400;
N          break;
N        case LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_50:
N          *val = LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_50;
N          break;
N        case LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_100:
N          *val = LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_100;
N          break;
N        case LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_9:
N          *val = LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_9;
N          break;
N        case LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_400:
N          *val = LSM6DSL_XL_LOW_NOISE_LP_ODR_DIV_400;
N          break;
N        default:
N          *val = LSM6DSL_XL_LP_NA;
N          break;
N      }
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Enable HP filter reference mode.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of hp_ref_mode in reg CTRL8_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_reference_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  if(ret == 0){
N    ctrl8_xl.hp_ref_mode = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable HP filter reference mode.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of hp_ref_mode in reg CTRL8_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_reference_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  *val = ctrl8_xl.hp_ref_mode;
N
N  return ret;
N}
N
N/**
N  * @brief  High pass/Slope on outputs.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of hpcf_xl in reg CTRL8_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_hp_bandwidth_set(lsm6dsl_ctx_t *ctx, lsm6dsl_hpcf_xl_t val)
N{
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  if(ret == 0){
N    ctrl8_xl.input_composite = 0;
N    ctrl8_xl.hpcf_xl = (uint8_t)val & 0x03U;
N    ctrl8_xl.hp_slope_xl_en = 1;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  High pass/Slope on outputs.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of hpcf_xl in reg CTRL8_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_xl_hp_bandwidth_get(lsm6dsl_ctx_t *ctx, lsm6dsl_hpcf_xl_t *val)
N{
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  if (ctrl8_xl.hp_slope_xl_en == 0x00U){
N    *val = LSM6DSL_XL_HP_NA;
N  }
N  switch (ctrl8_xl.hpcf_xl) {
N    case LSM6DSL_XL_HP_ODR_DIV_4:
N      *val = LSM6DSL_XL_HP_ODR_DIV_4;
N      break;
N    case LSM6DSL_XL_HP_ODR_DIV_100:
N      *val = LSM6DSL_XL_HP_ODR_DIV_100;
N      break;
N    case LSM6DSL_XL_HP_ODR_DIV_9:
N      *val = LSM6DSL_XL_HP_ODR_DIV_9;
N      break;
N    case LSM6DSL_XL_HP_ODR_DIV_400:
N      *val = LSM6DSL_XL_HP_ODR_DIV_400;
N      break;
N    default:
N      *val = LSM6DSL_XL_HP_NA;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_gyroscope_filters
N  * @brief       This section group all the functions concerning the filters
N  *              configuration that impact gyroscope.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Gyroscope low pass path bandwidth.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    gyroscope filtering chain configuration.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_band_pass_set(lsm6dsl_ctx_t *ctx, lsm6dsl_lpf1_sel_g_t val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  lsm6dsl_ctrl6_c_t ctrl6_c;
N  lsm6dsl_ctrl7_g_t ctrl7_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N  if(ret == 0){
N    ctrl7_g.hpm_g  =  ( (uint8_t)val & 0x30U ) >> 4;
N    ctrl7_g.hp_en_g = ( (uint8_t)val & 0x80U ) >> 7;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N    if(ret == 0){
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X      ret = lsm6dsl_read_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N      if(ret == 0){
N        ctrl6_c.ftype = (uint8_t)val & 0x03U;
N        ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X        ret = lsm6dsl_write_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N        if(ret == 0){
N          ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C,
X          ret = lsm6dsl_read_reg(ctx, 0x13U,
N                                 (uint8_t*)&ctrl4_c, 1);
N          if(ret == 0){
N            ctrl4_c.lpf1_sel_g = ( (uint8_t)val & 0x08U ) >> 3;
N            ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C,
X            ret = lsm6dsl_write_reg(ctx, 0x13U,
N                                    (uint8_t*)&ctrl4_c, 1);
N          }
N        }
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Gyroscope low pass path bandwidth.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    gyroscope filtering chain
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_band_pass_get(lsm6dsl_ctx_t *ctx, lsm6dsl_lpf1_sel_g_t *val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  lsm6dsl_ctrl6_c_t ctrl6_c;
N  lsm6dsl_ctrl7_g_t ctrl7_g;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N    if(ret == 0){
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL7_G, (uint8_t*)&ctrl7_g, 1);
X      ret = lsm6dsl_read_reg(ctx, 0x16U, (uint8_t*)&ctrl7_g, 1);
N
N      switch ( ( ctrl7_g.hp_en_g << 7 ) + ( ctrl7_g.hpm_g << 4 ) +
N               ( ctrl4_c.lpf1_sel_g << 3) + ctrl6_c.ftype ) {
N        case LSM6DSL_HP_16mHz_LP2:
N          *val = LSM6DSL_HP_16mHz_LP2;
N          break;
N        case LSM6DSL_HP_65mHz_LP2:
N          *val = LSM6DSL_HP_65mHz_LP2;
N          break;
N        case LSM6DSL_HP_260mHz_LP2:
N          *val = LSM6DSL_HP_260mHz_LP2;
N          break;
N        case LSM6DSL_HP_1Hz04_LP2:
N          *val = LSM6DSL_HP_1Hz04_LP2;
N          break;
N        case LSM6DSL_HP_DISABLE_LP1_LIGHT:
N          *val = LSM6DSL_HP_DISABLE_LP1_LIGHT;
N          break;
N        case LSM6DSL_HP_DISABLE_LP1_NORMAL:
N          *val = LSM6DSL_HP_DISABLE_LP1_NORMAL;
N          break;
N        case LSM6DSL_HP_DISABLE_LP_STRONG:
N          *val = LSM6DSL_HP_DISABLE_LP_STRONG;
N          break;
N        case LSM6DSL_HP_DISABLE_LP1_AGGRESSIVE:
N          *val = LSM6DSL_HP_DISABLE_LP1_AGGRESSIVE;
N          break;
N        case LSM6DSL_HP_16mHz_LP1_LIGHT:
N          *val = LSM6DSL_HP_16mHz_LP1_LIGHT;
N          break;
N        case LSM6DSL_HP_65mHz_LP1_NORMAL:
N          *val = LSM6DSL_HP_65mHz_LP1_NORMAL;
N          break;
N        case LSM6DSL_HP_260mHz_LP1_STRONG:
N          *val = LSM6DSL_HP_260mHz_LP1_STRONG;
N          break;
N        case LSM6DSL_HP_1Hz04_LP1_AGGRESSIVE:
N          *val = LSM6DSL_HP_1Hz04_LP1_AGGRESSIVE;
N          break;
N        default:
N          *val = LSM6DSL_HP_GY_BAND_NA;
N          break;
N      }
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_serial_interface
N  * @brief       This section groups all the functions concerning serial
N  *              interface management
N  * @{
N  *
N  */
N
N/**
N  * @brief  SPI Serial Interface Mode selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sim in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_spi_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  if(ret == 0){
N    ctrl3_c.sim = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  SPI Serial Interface Mode selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of sim in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_spi_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sim_t *val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  switch (ctrl3_c.sim) {
N    case LSM6DSL_SPI_4_WIRE:
N      *val = LSM6DSL_SPI_4_WIRE;
N      break;
N    case LSM6DSL_SPI_3_WIRE:
N      *val = LSM6DSL_SPI_3_WIRE;
N      break;
N    default:
N      *val = LSM6DSL_SPI_MODE_ND;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Disable / Enable I2C interface.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of i2c_disable in reg CTRL4_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_i2c_interface_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_i2c_disable_t val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  if(ret == 0){
N    ctrl4_c.i2c_disable = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Disable / Enable I2C interface.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of i2c_disable in reg CTRL4_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_i2c_interface_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_i2c_disable_t *val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  switch (ctrl4_c.i2c_disable) {
N    case LSM6DSL_I2C_ENABLE:
N      *val = LSM6DSL_I2C_ENABLE;
N      break;
N    case LSM6DSL_I2C_DISABLE:
N      *val = LSM6DSL_I2C_DISABLE;
N      break;
N    default:
N      *val = LSM6DSL_I2C_MODE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_interrupt_pins
N  * @brief       This section groups all the functions that manage
N  *              interrup pins
N  * @{
N  *
N  */
N
N/**
N  * @brief  Select the signal that need to route on int1 pad[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    configure INT1_CTRL, MD1_CFG, CTRL4_C(den_drdy_int1),
N  *                MASTER_CONFIG(drdy_on_int1)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pin_int1_route_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int1_route_t val)
N{
N  lsm6dsl_master_config_t master_config;
N  lsm6dsl_int1_ctrl_t int1_ctrl;
N  lsm6dsl_md1_cfg_t md1_cfg;
N  lsm6dsl_md2_cfg_t md2_cfg;
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT1_CTRL, (uint8_t*)&int1_ctrl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0DU, (uint8_t*)&int1_ctrl, 1);
N  if(ret == 0){
N    int1_ctrl.int1_drdy_xl        = val.int1_drdy_xl;
N    int1_ctrl.int1_drdy_g         = val.int1_drdy_g;
N    int1_ctrl.int1_boot           = val.int1_boot;
N    int1_ctrl.int1_fth            = val.int1_fth;
N    int1_ctrl.int1_fifo_ovr       = val.int1_fifo_ovr;
N    int1_ctrl.int1_full_flag      = val.int1_full_flag;
N    int1_ctrl.int1_sign_mot       = val.int1_sign_mot;
N    int1_ctrl.int1_step_detector  = val.int1_step_detector;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT1_CTRL, (uint8_t*)&int1_ctrl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x0DU, (uint8_t*)&int1_ctrl, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD1_CFG, (uint8_t*)&md1_cfg, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x5EU, (uint8_t*)&md1_cfg, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD2_CFG, (uint8_t*)&md2_cfg, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x5FU, (uint8_t*)&md2_cfg, 1);
N  }
N  if(ret == 0){
N        md1_cfg.int1_timer           = val.int1_timer;
N        md1_cfg.int1_tilt            = val.int1_tilt;
N        md1_cfg.int1_6d              = val.int1_6d;
N        md1_cfg.int1_double_tap      = val.int1_double_tap;
N        md1_cfg.int1_ff              = val.int1_ff;
N        md1_cfg.int1_wu              = val.int1_wu;
N        md1_cfg.int1_single_tap      = val.int1_single_tap;
N        md1_cfg.int1_inact_state     = val.int1_inact_state;
N        ret = lsm6dsl_write_reg(ctx, LSM6DSL_MD1_CFG, (uint8_t*)&md1_cfg, 1);
X        ret = lsm6dsl_write_reg(ctx, 0x5EU, (uint8_t*)&md1_cfg, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  }
N  if(ret == 0){
N    ctrl4_c.den_drdy_int1 = val.den_drdy_int1;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                           (uint8_t*)&master_config, 1);
N  }
N  if(ret == 0){
N     master_config.drdy_on_int1   = val.den_drdy_int1;
N     ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,
X     ret = lsm6dsl_write_reg(ctx, 0x1AU,
N                             (uint8_t*)&master_config, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N    if ((val.int1_6d != 0x00U) ||
N        (val.int1_ff != 0x00U) ||
N        (val.int1_wu != 0x00U) ||
N        (val.int1_single_tap != 0x00U) ||
N        (val.int1_double_tap != 0x00U) ||
N        (val.int1_inact_state != 0x00U)||
N        (md2_cfg.int2_6d != 0x00U) ||
N        (md2_cfg.int2_ff != 0x00U) ||
N        (md2_cfg.int2_wu != 0x00U) ||
N        (md2_cfg.int2_single_tap != 0x00U) ||
N        (md2_cfg.int2_double_tap != 0x00U) ||
N        (md2_cfg.int2_inact_state!= 0x00U) ){
N      tap_cfg.interrupts_enable = PROPERTY_ENABLE;
X      tap_cfg.interrupts_enable = (1U);
N    }
N    else{
N      tap_cfg.interrupts_enable = PROPERTY_DISABLE;
X      tap_cfg.interrupts_enable = (0U);
N    }
N  }
N  if(ret == 0){
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Select the signal that need to route on int1 pad[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    read INT1_CTRL, MD1_CFG, CTRL4_C(den_drdy_int1),
N  *                MASTER_CONFIG(drdy_on_int1)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pin_int1_route_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int1_route_t *val)
N{
N  lsm6dsl_master_config_t master_config;
N  lsm6dsl_int1_ctrl_t int1_ctrl;
N  lsm6dsl_md1_cfg_t md1_cfg;
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT1_CTRL, (uint8_t*)&int1_ctrl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0DU, (uint8_t*)&int1_ctrl, 1);
N  if(ret == 0){
N    val->int1_drdy_xl       = int1_ctrl.int1_drdy_xl;
N    val->int1_drdy_g        = int1_ctrl.int1_drdy_g;
N    val->int1_boot          = int1_ctrl.int1_boot;
N    val->int1_fth           = int1_ctrl.int1_fth;
N    val->int1_fifo_ovr      = int1_ctrl.int1_fifo_ovr;
N    val->int1_full_flag     = int1_ctrl.int1_full_flag;
N    val->int1_sign_mot      = int1_ctrl.int1_sign_mot;
N    val->int1_step_detector = int1_ctrl.int1_step_detector ;
N
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD1_CFG, (uint8_t*)&md1_cfg, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x5EU, (uint8_t*)&md1_cfg, 1);
N    if(ret == 0){
N    val->int1_timer       = md1_cfg.int1_timer;
N    val->int1_tilt        = md1_cfg.int1_tilt;
N    val->int1_6d          = md1_cfg.int1_6d;
N    val->int1_double_tap  = md1_cfg.int1_double_tap;
N    val->int1_ff          = md1_cfg.int1_ff;
N    val->int1_wu          = md1_cfg.int1_wu;
N    val->int1_single_tap  = md1_cfg.int1_single_tap;
N    val->int1_inact_state = md1_cfg.int1_inact_state;
N
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N      if(ret == 0){
N        val->den_drdy_int1 = ctrl4_c.den_drdy_int1;
N        ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X        ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                               (uint8_t*)&master_config, 1);
N        val->den_drdy_int1 = master_config.drdy_on_int1;
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Select the signal that need to route on int2 pad[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    INT2_CTRL, DRDY_PULSE_CFG(int2_wrist_tilt), MD2_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pin_int2_route_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_int2_route_t val)
N{
N  lsm6dsl_int2_ctrl_t int2_ctrl;
N  lsm6dsl_md1_cfg_t md1_cfg;
N  lsm6dsl_md2_cfg_t md2_cfg;
N  lsm6dsl_drdy_pulse_cfg_g_t drdy_pulse_cfg_g;
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT2_CTRL, (uint8_t*)&int2_ctrl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0EU, (uint8_t*)&int2_ctrl, 1);
N  if(ret == 0){
N    int2_ctrl.int2_drdy_xl        = val.int2_drdy_xl;
N    int2_ctrl.int2_drdy_g         = val.int2_drdy_g;
N    int2_ctrl.int2_drdy_temp      = val.int2_drdy_temp;
N    int2_ctrl.int2_fth            = val.int2_fth;
N    int2_ctrl.int2_fifo_ovr       = val.int2_fifo_ovr;
N    int2_ctrl.int2_full_flag      = val.int2_full_flag;
N    int2_ctrl.int2_step_count_ov  = val.int2_step_count_ov;
N    int2_ctrl.int2_step_delta     = val.int2_step_delta;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT2_CTRL, (uint8_t*)&int2_ctrl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x0EU, (uint8_t*)&int2_ctrl, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD1_CFG, (uint8_t*)&md1_cfg, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x5EU, (uint8_t*)&md1_cfg, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD2_CFG, (uint8_t*)&md2_cfg, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x5FU, (uint8_t*)&md2_cfg, 1);
N  }
N  if(ret == 0){
N    md2_cfg.int2_iron              = val.int2_iron;
N    md2_cfg.int2_tilt              = val.int2_tilt;
N    md2_cfg.int2_6d                = val.int2_6d;
N    md2_cfg.int2_double_tap        = val.int2_double_tap;
N    md2_cfg.int2_ff                = val.int2_ff;
N    md2_cfg.int2_wu                = val.int2_wu;
N    md2_cfg.int2_single_tap        = val.int2_single_tap;
N    md2_cfg.int2_inact_state       = val.int2_inact_state;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MD2_CFG, (uint8_t*)&md2_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x5FU, (uint8_t*)&md2_cfg, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G,
X    ret = lsm6dsl_read_reg(ctx, 0x0BU,
N                           (uint8_t*)&drdy_pulse_cfg_g, 1);
N  }
N  if(ret == 0){
N    drdy_pulse_cfg_g.int2_wrist_tilt = val.int2_wrist_tilt;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G,
X    ret = lsm6dsl_write_reg(ctx, 0x0BU,
N                            (uint8_t*)&drdy_pulse_cfg_g, 1);
N  }
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N    if ((md1_cfg.int1_6d != 0x00U) ||
N        (md1_cfg.int1_ff != 0x00U) ||
N        (md1_cfg.int1_wu != 0x00U) ||
N        (md1_cfg.int1_single_tap != 0x00U) ||
N        (md1_cfg.int1_double_tap != 0x00U) ||
N        (md1_cfg.int1_inact_state != 0x00U) ||
N        (val.int2_6d != 0x00U) ||
N        (val.int2_ff != 0x00U) ||
N        (val.int2_wu != 0x00U) ||
N        (val.int2_single_tap != 0x00U) ||
N        (val.int2_double_tap != 0x00U) ||
N        (val.int2_inact_state!= 0x00U) ){
N      tap_cfg.interrupts_enable = PROPERTY_ENABLE;
X      tap_cfg.interrupts_enable = (1U);
N    }
N    else{
N      tap_cfg.interrupts_enable = PROPERTY_DISABLE;
X      tap_cfg.interrupts_enable = (0U);
N    }
N  }
N  if(ret == 0){
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Select the signal that need to route on int2 pad[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    INT2_CTRL, DRDY_PULSE_CFG(int2_wrist_tilt), MD2_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pin_int2_route_get(lsm6dsl_ctx_t *ctx,
Nlsm6dsl_int2_route_t *val)
N{
N  lsm6dsl_int2_ctrl_t int2_ctrl;
N  lsm6dsl_md2_cfg_t md2_cfg;
N  lsm6dsl_drdy_pulse_cfg_g_t drdy_pulse_cfg_g;
N
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT2_CTRL, (uint8_t*)&int2_ctrl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0EU, (uint8_t*)&int2_ctrl, 1);
N  if(ret == 0){
N    val->int2_drdy_xl         = int2_ctrl.int2_drdy_xl;
N    val->int2_drdy_g          = int2_ctrl.int2_drdy_g;
N    val->int2_drdy_temp       = int2_ctrl.int2_drdy_temp;
N    val->int2_fth             = int2_ctrl.int2_fth;
N    val->int2_fifo_ovr        = int2_ctrl.int2_fifo_ovr;
N    val->int2_full_flag       = int2_ctrl.int2_full_flag;
N    val->int2_step_count_ov   = int2_ctrl.int2_step_count_ov;
N    val->int2_step_delta      = int2_ctrl.int2_step_delta;
N
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MD2_CFG, (uint8_t*)&md2_cfg, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x5FU, (uint8_t*)&md2_cfg, 1);
N    if(ret == 0){
N      val->int2_iron           = md2_cfg.int2_iron;
N      val->int2_tilt           = md2_cfg.int2_tilt;
N      val->int2_6d             = md2_cfg.int2_6d;
N      val->int2_double_tap     = md2_cfg.int2_double_tap;
N      val->int2_ff             = md2_cfg.int2_ff;
N      val->int2_wu             = md2_cfg.int2_wu;
N      val->int2_single_tap     = md2_cfg.int2_single_tap;
N      val->int2_inact_state    = md2_cfg.int2_inact_state;
N
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_DRDY_PULSE_CFG_G,
X      ret = lsm6dsl_read_reg(ctx, 0x0BU,
N                             (uint8_t*)&drdy_pulse_cfg_g, 1);
N      val->int2_wrist_tilt = drdy_pulse_cfg_g.int2_wrist_tilt;
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Push-pull/open drain selection on interrupt pads.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pp_od in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  if(ret == 0){
N    ctrl3_c.pp_od = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Push-pull/open drain selection on interrupt pads.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of pp_od in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pp_od_t *val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  switch (ctrl3_c.pp_od) {
N    case LSM6DSL_PUSH_PULL:
N      *val = LSM6DSL_PUSH_PULL;
N      break;
N    case LSM6DSL_OPEN_DRAIN:
N      *val = LSM6DSL_OPEN_DRAIN;
N      break;
N    default:
N      *val = LSM6DSL_PIN_MODE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Interrupt active-high/low.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of h_lactive in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pin_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  if(ret == 0){
N    ctrl3_c.h_lactive = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Interrupt active-high/low.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of h_lactive in reg CTRL3_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pin_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_h_lactive_t *val)
N{
N  lsm6dsl_ctrl3_c_t ctrl3_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x12U, (uint8_t*)&ctrl3_c, 1);
N  switch (ctrl3_c.h_lactive) {
N    case LSM6DSL_ACTIVE_HIGH:
N      *val = LSM6DSL_ACTIVE_HIGH;
N      break;
N    case LSM6DSL_ACTIVE_LOW:
N      *val = LSM6DSL_ACTIVE_LOW;
N      break;
N    default:
N      *val = LSM6DSL_POLARITY_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  All interrupt signals become available on INT1 pin.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of int2_on_int1 in reg CTRL4_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_all_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  if(ret == 0){
N    ctrl4_c.int2_on_int1 = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  All interrupt signals become available on INT1 pin.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of int2_on_int1 in reg CTRL4_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_all_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  *val = ctrl4_c.int2_on_int1;
N
N  return ret;
N}
N
N/**
N  * @brief  Latched/pulsed interrupt.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of lir in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_int_notification_set(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  if(ret == 0){
N    tap_cfg.lir = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Latched/pulsed interrupt.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of lir in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_int_notification_get(lsm6dsl_ctx_t *ctx, lsm6dsl_lir_t *val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  switch (tap_cfg.lir) {
N    case LSM6DSL_INT_PULSED:
N      *val = LSM6DSL_INT_PULSED;
N      break;
N    case LSM6DSL_INT_LATCHED:
N      *val = LSM6DSL_INT_LATCHED;
N      break;
N    default:
N      *val = LSM6DSL_INT_MODE;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_Wake_Up_event
N  * @brief       This section groups all the functions that manage the
N  *              Wake Up event generation.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Threshold for wakeup.1 LSB = FS_XL / 64.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of wk_ths in reg WAKE_UP_THS
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_wkup_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_wake_up_ths_t wake_up_ths;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_THS, (uint8_t*)&wake_up_ths, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5BU, (uint8_t*)&wake_up_ths, 1);
N  if(ret == 0){
N    wake_up_ths.wk_ths = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_THS,
X    ret = lsm6dsl_write_reg(ctx, 0x5BU,
N                            (uint8_t*)&wake_up_ths, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Threshold for wakeup.1 LSB = FS_XL / 64.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of wk_ths in reg WAKE_UP_THS
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_wkup_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_wake_up_ths_t wake_up_ths;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_THS, (uint8_t*)&wake_up_ths, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5BU, (uint8_t*)&wake_up_ths, 1);
N  *val = wake_up_ths.wk_ths;
N
N  return ret;
N}
N
N/**
N  * @brief  Wake up duration event.1LSb = 1 / ODR[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of wake_dur in reg WAKE_UP_DUR
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_wkup_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_wake_up_dur_t wake_up_dur;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, (uint8_t*)&wake_up_dur, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5CU, (uint8_t*)&wake_up_dur, 1);
N  if(ret == 0){
N    wake_up_dur.wake_dur = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_DUR,
X    ret = lsm6dsl_write_reg(ctx, 0x5CU,
N                            (uint8_t*)&wake_up_dur, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Wake up duration event.1LSb = 1 / ODR[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of wake_dur in reg WAKE_UP_DUR
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_wkup_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_wake_up_dur_t wake_up_dur;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, (uint8_t*)&wake_up_dur, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5CU, (uint8_t*)&wake_up_dur, 1);
N  *val = wake_up_dur.wake_dur;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_Activity/Inactivity_detection
N  * @brief       This section groups all the functions concerning
N  *              activity/inactivity detection.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Enables gyroscope Sleep mode.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sleep in reg CTRL4_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_sleep_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  if(ret == 0){
N    ctrl4_c.sleep = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enables gyroscope Sleep mode.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sleep in reg CTRL4_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_gy_sleep_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  *val = ctrl4_c.sleep;
N
N  return ret;
N}
N
N/**
N  * @brief  Enable inactivity function.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of inact_en in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_act_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  if(ret == 0){
N    tap_cfg.inact_en = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable inactivity function.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of inact_en in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_act_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_inact_en_t *val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  switch (tap_cfg.inact_en) {
N    case LSM6DSL_PROPERTY_DISABLE:
N      *val = LSM6DSL_PROPERTY_DISABLE;
N      break;
N    case LSM6DSL_XL_12Hz5_GY_NOT_AFFECTED:
N      *val = LSM6DSL_XL_12Hz5_GY_NOT_AFFECTED;
N      break;
N    case LSM6DSL_XL_12Hz5_GY_SLEEP:
N      *val = LSM6DSL_XL_12Hz5_GY_SLEEP;
N      break;
N    case LSM6DSL_XL_12Hz5_GY_PD:
N      *val = LSM6DSL_XL_12Hz5_GY_PD;
N      break;
N    default:
N      *val = LSM6DSL_ACT_MODE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Duration to go in sleep mode.1 LSb = 512 / ODR[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sleep_dur in reg WAKE_UP_DUR
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_act_sleep_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_wake_up_dur_t wake_up_dur;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, (uint8_t*)&wake_up_dur, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5CU, (uint8_t*)&wake_up_dur, 1);
N  if(ret == 0){
N    wake_up_dur.sleep_dur = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_DUR,
X    ret = lsm6dsl_write_reg(ctx, 0x5CU,
N          (uint8_t*)&wake_up_dur, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Duration to go in sleep mode. 1 LSb = 512 / ODR[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sleep_dur in reg WAKE_UP_DUR
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_act_sleep_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_wake_up_dur_t wake_up_dur;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, (uint8_t*)&wake_up_dur, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5CU, (uint8_t*)&wake_up_dur, 1);
N  *val = wake_up_dur.sleep_dur;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_tap_generator
N  * @brief       This section groups all the functions that manage the
N  *              tap and double tap event generation.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Read the tap / double tap source register.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Structure of registers from TAP_SRC
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_src_get(lsm6dsl_ctx_t *ctx, lsm6dsl_tap_src_t *val)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_SRC, (uint8_t*) val, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x1CU, (uint8_t*) val, 1);
N  return ret;
N}
N
N/**
N  * @brief  Enable Z direction in tap recognition.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tap_z_en in reg TAP_CFG
N  *
N  */
Nint32_t lsm6dsl_tap_detection_on_z_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  if(ret == 0){
N    tap_cfg.tap_z_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable Z direction in tap recognition.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tap_z_en in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_detection_on_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  *val = tap_cfg.tap_z_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Enable Y direction in tap recognition.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tap_y_en in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_detection_on_y_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  if(ret == 0){
N    tap_cfg.tap_y_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable Y direction in tap recognition.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tap_y_en in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_detection_on_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  *val = tap_cfg.tap_y_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Enable X direction in tap recognition.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tap_x_en in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_detection_on_x_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  if(ret == 0){
N    tap_cfg.tap_x_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable X direction in tap recognition.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tap_x_en in reg TAP_CFG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_detection_on_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_tap_cfg_t tap_cfg;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_CFG, (uint8_t*)&tap_cfg, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x58U, (uint8_t*)&tap_cfg, 1);
N  *val = tap_cfg.tap_x_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Threshold for tap recognition.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tap_ths in reg TAP_THS_6D
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_threshold_x_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_tap_ths_6d_t tap_ths_6d;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, (uint8_t*)&tap_ths_6d, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x59U, (uint8_t*)&tap_ths_6d, 1);
N  if(ret == 0){
N    tap_ths_6d.tap_ths = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_THS_6D,
X    ret = lsm6dsl_write_reg(ctx, 0x59U,
N                            (uint8_t*)&tap_ths_6d, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Threshold for tap recognition.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tap_ths in reg TAP_THS_6D
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_threshold_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_tap_ths_6d_t tap_ths_6d;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, (uint8_t*)&tap_ths_6d, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x59U, (uint8_t*)&tap_ths_6d, 1);
N  *val = tap_ths_6d.tap_ths;
N
N  return ret;
N}
N
N/**
N  * @brief  Maximum duration is the maximum time of an overthreshold signal
N  *         detection to be recognized as a tap event.
N  *         The default value of these bits is 00b which corresponds to
N  *         4*ODR_XL time.
N  *         If the SHOCK[1:0] bits are set to a different
N  *         value, 1LSB corresponds to 8*ODR_XL time.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of shock in reg INT_DUR2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_shock_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_int_dur2_t int_dur2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  if(ret == 0){
N    int_dur2.shock = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Maximum duration is the maximum time of an overthreshold signal
N  *         detection to be recognized as a tap event.
N  *         The default value of these bits is 00b which corresponds to
N  *         4*ODR_XL time.
N  *         If the SHOCK[1:0] bits are set to a different value, 1LSB
N  *         corresponds to 8*ODR_XL time.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of shock in reg INT_DUR2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_shock_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_int_dur2_t int_dur2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  *val = int_dur2.shock;
N
N  return ret;
N}
N
N/**
N  * @brief  Quiet time is the time after the first detected tap in which there
N  *         must not be any overthreshold event.
N  *         The default value of these bits is 00b which corresponds to
N  *         2*ODR_XL time.
N  *         If the QUIET[1:0] bits are set to a different value, 1LSB
N  *         corresponds to 4*ODR_XL time.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of quiet in reg INT_DUR2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_quiet_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_int_dur2_t int_dur2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  if(ret == 0){
N    int_dur2.quiet = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Quiet time is the time after the first detected tap in which there
N  *         must not be any overthreshold event.
N  *         The default value of these bits is 00b which corresponds to
N  *         2*ODR_XL time.
N  *         If the QUIET[1:0] bits are set to a different value, 1LSB
N  *         corresponds to 4*ODR_XL time.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of quiet in reg INT_DUR2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_quiet_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_int_dur2_t int_dur2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  *val = int_dur2.quiet;
N
N  return ret;
N}
N
N/**
N  * @brief  When double tap recognition is enabled, this register expresses the
N  *         maximum time between two consecutive detected taps to determine a
N  *         double tap event.
N  *         The default value of these bits is 0000b which corresponds to
N  *         16*ODR_XL time.
N  *         If the DUR[3:0] bits are set to a different value,1LSB corresponds
N  *         to 32*ODR_XL time.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of dur in reg INT_DUR2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_int_dur2_t int_dur2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  if(ret == 0){
N    int_dur2.dur = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  When double tap recognition is enabled, this register expresses the
N  *         maximum time between two consecutive detected taps to determine a
N  *         double tap event.
N  *         The default value of these bits is 0000b which corresponds to
N  *         16*ODR_XL time.
N  *         If the DUR[3:0] bits are set to a different value,1LSB corresponds
N  *         to 32*ODR_XL time.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of dur in reg INT_DUR2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_int_dur2_t int_dur2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_INT_DUR2, (uint8_t*)&int_dur2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5AU, (uint8_t*)&int_dur2, 1);
N  *val = int_dur2.dur;
N
N  return ret;
N}
N
N/**
N  * @brief  Single/double-tap event enable/disable.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of
N  *                                      single_double_tap in reg WAKE_UP_THS
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_mode_set(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_single_double_tap_t val)
N{
N  lsm6dsl_wake_up_ths_t wake_up_ths;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_THS, (uint8_t*)&wake_up_ths, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5BU, (uint8_t*)&wake_up_ths, 1);
N  if(ret == 0){
N    wake_up_ths.single_double_tap = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_THS,
X    ret = lsm6dsl_write_reg(ctx, 0x5BU,
N                            (uint8_t*)&wake_up_ths, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Single/double-tap event enable/disable.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of single_double_tap
N  *                                      in reg WAKE_UP_THS
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tap_mode_get(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_single_double_tap_t *val)
N{
N  lsm6dsl_wake_up_ths_t wake_up_ths;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_THS, (uint8_t*)&wake_up_ths, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5BU, (uint8_t*)&wake_up_ths, 1);
N  switch (wake_up_ths.single_double_tap) {
N    case LSM6DSL_ONLY_SINGLE:
N      *val = LSM6DSL_ONLY_SINGLE;
N      break;
N    case LSM6DSL_BOTH_SINGLE_DOUBLE:
N      *val = LSM6DSL_BOTH_SINGLE_DOUBLE;
N      break;
N    default:
N      *val = LSM6DSL_TAP_MODE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_ Six_position_detection(6D/4D)
N  * @brief       This section groups all the functions concerning six
N  *              position detection (6D).
N  * @{
N  *
N  */
N
N/**
N  * @brief  LPF2 feed 6D function selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of low_pass_on_6d in
N  *                                   reg CTRL8_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_6d_feed_data_set(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_low_pass_on_6d_t val)
N{
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  if(ret == 0){
N    ctrl8_xl.low_pass_on_6d = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  LPF2 feed 6D function selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of low_pass_on_6d in reg CTRL8_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_6d_feed_data_get(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_low_pass_on_6d_t *val)
N{
N  lsm6dsl_ctrl8_xl_t ctrl8_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x17U, (uint8_t*)&ctrl8_xl, 1);
N  switch (ctrl8_xl.low_pass_on_6d) {
N    case LSM6DSL_ODR_DIV_2_FEED:
N      *val = LSM6DSL_ODR_DIV_2_FEED;
N      break;
N    case LSM6DSL_LPF2_FEED:
N      *val = LSM6DSL_LPF2_FEED;
N      break;
N    default:
N      *val = LSM6DSL_6D_FEED_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Threshold for 4D/6D function.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sixd_ths in reg TAP_THS_6D
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_6d_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t val)
N{
N  lsm6dsl_tap_ths_6d_t tap_ths_6d;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, (uint8_t*)&tap_ths_6d, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x59U, (uint8_t*)&tap_ths_6d, 1);
N  if(ret == 0){
N    tap_ths_6d.sixd_ths = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_THS_6D, (uint8_t*)&tap_ths_6d, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x59U, (uint8_t*)&tap_ths_6d, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Threshold for 4D/6D function.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of sixd_ths in reg TAP_THS_6D
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_6d_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_sixd_ths_t *val)
N{
N  lsm6dsl_tap_ths_6d_t tap_ths_6d;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, (uint8_t*)&tap_ths_6d, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x59U, (uint8_t*)&tap_ths_6d, 1);
N  switch (tap_ths_6d.sixd_ths) {
N    case LSM6DSL_DEG_80:
N      *val = LSM6DSL_DEG_80;
N      break;
N    case LSM6DSL_DEG_70:
N      *val = LSM6DSL_DEG_70;
N      break;
N    case LSM6DSL_DEG_60:
N      *val = LSM6DSL_DEG_60;
N      break;
N    case LSM6DSL_DEG_50:
N      *val = LSM6DSL_DEG_50;
N      break;
N    default:
N      *val = LSM6DSL_6D_TH_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  4D orientation detection enable.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of d4d_en in reg TAP_THS_6D
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_4d_mode_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_tap_ths_6d_t tap_ths_6d;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, (uint8_t*)&tap_ths_6d, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x59U, (uint8_t*)&tap_ths_6d, 1);
N  if(ret == 0){
N    tap_ths_6d.d4d_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_TAP_THS_6D,
X    ret = lsm6dsl_write_reg(ctx, 0x59U,
N                            (uint8_t*)&tap_ths_6d, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  4D orientation detection enable.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of d4d_en in reg TAP_THS_6D
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_4d_mode_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_tap_ths_6d_t tap_ths_6d;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_TAP_THS_6D, (uint8_t*)&tap_ths_6d, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x59U, (uint8_t*)&tap_ths_6d, 1);
N  *val = tap_ths_6d.d4d_en;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_free_fall
N  * @brief       This section group all the functions concerning the free
N  *              fall detection.
N  * @{
N  *
N  */
N
N/**
N  * @brief Free-fall duration event. 1LSb = 1 / ODR[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of ff_dur in reg WAKE_UP_DUR
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_ff_dur_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_wake_up_dur_t wake_up_dur;
N  lsm6dsl_free_fall_t free_fall;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FREE_FALL, (uint8_t*)&free_fall, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5DU, (uint8_t*)&free_fall, 1);
N  if(ret == 0){
N    free_fall.ff_dur = (val & 0x1FU);
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FREE_FALL, (uint8_t*)&free_fall, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x5DU, (uint8_t*)&free_fall, 1);
N    if(ret == 0){
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR,
X      ret = lsm6dsl_read_reg(ctx, 0x5CU,
N                             (uint8_t*)&wake_up_dur, 1);
N      if(ret == 0){
N        wake_up_dur.ff_dur = (val & 0x20U) >> 5;
N        ret = lsm6dsl_write_reg(ctx, LSM6DSL_WAKE_UP_DUR,
X        ret = lsm6dsl_write_reg(ctx, 0x5CU,
N                                (uint8_t*)&wake_up_dur, 1);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Free-fall duration event. 1LSb = 1 / ODR[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of ff_dur in reg WAKE_UP_DUR
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_ff_dur_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_wake_up_dur_t wake_up_dur;
N  lsm6dsl_free_fall_t free_fall;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WAKE_UP_DUR, (uint8_t*)&wake_up_dur, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5CU, (uint8_t*)&wake_up_dur, 1);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_FREE_FALL, (uint8_t*)&free_fall, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x5DU, (uint8_t*)&free_fall, 1);
N  }
N  *val = (wake_up_dur.ff_dur << 5) + free_fall.ff_dur;
N
N  return ret;
N}
N
N/**
N  * @brief  Free fall threshold setting.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of ff_ths in reg FREE_FALL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_ff_threshold_set(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t val)
N{
N  lsm6dsl_free_fall_t free_fall;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FREE_FALL, (uint8_t*)&free_fall, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5DU, (uint8_t*)&free_fall, 1);
N  if(ret == 0){
N    free_fall.ff_ths = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FREE_FALL, (uint8_t*)&free_fall, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x5DU, (uint8_t*)&free_fall, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Free fall threshold setting.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of ff_ths in reg FREE_FALL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_ff_threshold_get(lsm6dsl_ctx_t *ctx, lsm6dsl_ff_ths_t *val)
N{
N  lsm6dsl_free_fall_t free_fall;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FREE_FALL, (uint8_t*)&free_fall, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x5DU, (uint8_t*)&free_fall, 1);
N  switch (free_fall.ff_ths) {
N    case LSM6DSL_FF_TSH_156mg:
N      *val = LSM6DSL_FF_TSH_156mg;
N      break;
N    case LSM6DSL_FF_TSH_219mg:
N      *val = LSM6DSL_FF_TSH_219mg;
N      break;
N    case LSM6DSL_FF_TSH_250mg:
N      *val = LSM6DSL_FF_TSH_250mg;
N      break;
N    case LSM6DSL_FF_TSH_312mg:
N      *val = LSM6DSL_FF_TSH_312mg;
N      break;
N    case LSM6DSL_FF_TSH_344mg:
N      *val = LSM6DSL_FF_TSH_344mg;
N      break;
N    case LSM6DSL_FF_TSH_406mg:
N      *val = LSM6DSL_FF_TSH_406mg;
N      break;
N    case LSM6DSL_FF_TSH_469mg:
N      *val = LSM6DSL_FF_TSH_469mg;
N      break;
N    case LSM6DSL_FF_TSH_500mg:
N      *val = LSM6DSL_FF_TSH_500mg;
N      break;
N    default:
N      *val = LSM6DSL_FF_TSH_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_fifo
N  * @brief       This section group all the functions concerning the
N  *              fifo usage
N  * @{
N  *
N  */
N
N/**
N  * @brief  FIFO watermark level selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of fth in reg FIFO_CTRL1
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_watermark_set(lsm6dsl_ctx_t *ctx, uint16_t val)
N{
N  lsm6dsl_fifo_ctrl1_t fifo_ctrl1;
N  lsm6dsl_fifo_ctrl2_t fifo_ctrl2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x07U, (uint8_t*)&fifo_ctrl2, 1);
N  if(ret == 0){
N    fifo_ctrl1.fth = (uint8_t) (0x00FFU & val);
N    fifo_ctrl2.fth = (uint8_t) (( 0x0700U & val ) >> 8);
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL1, (uint8_t*)&fifo_ctrl1, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x06U, (uint8_t*)&fifo_ctrl1, 1);
N    if(ret == 0){
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL2,
X      ret = lsm6dsl_write_reg(ctx, 0x07U,
N                              (uint8_t*)&fifo_ctrl2, 1);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  FIFO watermark level selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of fth in reg FIFO_CTRL1
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_watermark_get(lsm6dsl_ctx_t *ctx, uint16_t *val)
N{
N  lsm6dsl_fifo_ctrl1_t fifo_ctrl1;
N  lsm6dsl_fifo_ctrl2_t fifo_ctrl2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL1, (uint8_t*)&fifo_ctrl1, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x06U, (uint8_t*)&fifo_ctrl1, 1);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x07U, (uint8_t*)&fifo_ctrl2, 1);
N  }
N  *val = ((uint16_t)fifo_ctrl2.fth << 8) + (uint16_t)fifo_ctrl1.fth;
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO data level.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    get the values of diff_fifo in reg  FIFO_STATUS1 and
N  *                FIFO_STATUS2(diff_fifo), it is recommended to set the
N  *                BDU bit.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_data_level_get(lsm6dsl_ctx_t *ctx, uint16_t *val)
N{
N  lsm6dsl_fifo_status1_t fifo_status1;
N  lsm6dsl_fifo_status2_t fifo_status2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_STATUS1,
X  ret = lsm6dsl_read_reg(ctx, 0x3AU,
N                         (uint8_t*)&fifo_status1, 1);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_STATUS2,
X    ret = lsm6dsl_read_reg(ctx, 0x3BU,
N                           (uint8_t*)&fifo_status2, 1);
N    *val = ( (uint16_t) fifo_status2.diff_fifo << 8) +
N             (uint16_t) fifo_status1.diff_fifo;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO watermark.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    get the values of watermark in reg  FIFO_STATUS2 and
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_wtm_flag_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_fifo_status2_t fifo_status2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_STATUS2, (uint8_t*)&fifo_status2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x3BU, (uint8_t*)&fifo_status2, 1);
N  *val = fifo_status2.waterm;
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO pattern.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    get the values of fifo_pattern in reg  FIFO_STATUS3 and
N  *                FIFO_STATUS4, it is recommended to set the BDU bit
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_pattern_get(lsm6dsl_ctx_t *ctx, uint16_t *val)
N{
N  lsm6dsl_fifo_status3_t fifo_status3;
N  lsm6dsl_fifo_status4_t fifo_status4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_STATUS3,
X  ret = lsm6dsl_read_reg(ctx, 0x3CU,
N                         (uint8_t*)&fifo_status3, 1);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_STATUS4,
X    ret = lsm6dsl_read_reg(ctx, 0x3DU,
N                           (uint8_t*)&fifo_status4, 1);
N    *val = ( (uint16_t)fifo_status4.fifo_pattern << 8) +
N             fifo_status3.fifo_pattern;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Batching of temperature data[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of fifo_temp_en in reg FIFO_CTRL2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_temp_batch_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_fifo_ctrl2_t fifo_ctrl2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x07U, (uint8_t*)&fifo_ctrl2, 1);
N  if(ret == 0){
N    fifo_ctrl2.fifo_temp_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL2,
X    ret = lsm6dsl_write_reg(ctx, 0x07U,
N                            (uint8_t*)&fifo_ctrl2, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Batching of temperature data[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of fifo_temp_en in reg FIFO_CTRL2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_temp_batch_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_fifo_ctrl2_t fifo_ctrl2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x07U, (uint8_t*)&fifo_ctrl2, 1);
N  *val = fifo_ctrl2.fifo_temp_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Trigger signal for FIFO write operation.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    act on FIFO_CTRL2(timer_pedo_fifo_drdy)
N  *                and MASTER_CONFIG(data_valid_sel_fifo)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_write_trigger_set(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_trigger_fifo_t val)
N{
N  lsm6dsl_fifo_ctrl2_t fifo_ctrl2;
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x07U, (uint8_t*)&fifo_ctrl2, 1);
N  if(ret == 0){
N    fifo_ctrl2.timer_pedo_fifo_drdy = (uint8_t)val & 0x01U;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL2,
X    ret = lsm6dsl_write_reg(ctx, 0x07U,
N                            (uint8_t*)&fifo_ctrl2, 1);
N    if(ret == 0){
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X      ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                             (uint8_t*)&master_config, 1);
N      if(ret == 0){
N        master_config.data_valid_sel_fifo = (((uint8_t)val & 0x02U) >> 1);
N        ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,
X        ret = lsm6dsl_write_reg(ctx, 0x1AU,
N                                (uint8_t*)&master_config, 1);
N      }
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Trigger signal for FIFO write operation.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    act on FIFO_CTRL2(timer_pedo_fifo_drdy)
N  *                and MASTER_CONFIG(data_valid_sel_fifo)
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_write_trigger_get(lsm6dsl_ctx_t *ctx,
N                                       lsm6dsl_trigger_fifo_t *val)
N{
N  lsm6dsl_fifo_ctrl2_t fifo_ctrl2;
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x07U, (uint8_t*)&fifo_ctrl2, 1);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                           (uint8_t*)&master_config, 1);
N
N    switch ( ( fifo_ctrl2.timer_pedo_fifo_drdy << 1 ) +
N             fifo_ctrl2. timer_pedo_fifo_drdy ) {
N      case LSM6DSL_TRG_XL_GY_DRDY:
N        *val = LSM6DSL_TRG_XL_GY_DRDY;
N        break;
N      case LSM6DSL_TRG_STEP_DETECT:
N        *val = LSM6DSL_TRG_STEP_DETECT;
N        break;
N      case LSM6DSL_TRG_SH_DRDY:
N        *val = LSM6DSL_TRG_SH_DRDY;
N        break;
N      default:
N        *val = LSM6DSL_TRG_SH_ND;
N        break;
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief   Enable pedometer step counter and timestamp as 4th
N  *          FIFO data set.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of timer_pedo_fifo_en in reg FIFO_CTRL2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_set(lsm6dsl_ctx_t *ctx,
N                                                  uint8_t val)
N{
N  lsm6dsl_fifo_ctrl2_t fifo_ctrl2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x07U, (uint8_t*)&fifo_ctrl2, 1);
N  if(ret == 0){
N    fifo_ctrl2.timer_pedo_fifo_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL2,
X    ret = lsm6dsl_write_reg(ctx, 0x07U,
N                            (uint8_t*)&fifo_ctrl2, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable pedometer step counter and timestamp as 4th
N  *         FIFO data set.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of timer_pedo_fifo_en in reg FIFO_CTRL2
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_pedo_and_timestamp_batch_get(lsm6dsl_ctx_t *ctx,
N                                                  uint8_t *val)
N{
N  lsm6dsl_fifo_ctrl2_t fifo_ctrl2;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x07U, (uint8_t*)&fifo_ctrl2, 1);
N  *val = fifo_ctrl2.timer_pedo_fifo_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Selects Batching Data Rate (writing frequency in FIFO) for
N  *         accelerometer data.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of dec_fifo_xl in reg FIFO_CTRL3
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_xl_batch_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_xl_t val)
N{
N  lsm6dsl_fifo_ctrl3_t fifo_ctrl3;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL3, (uint8_t*)&fifo_ctrl3, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x08U, (uint8_t*)&fifo_ctrl3, 1);
N  if(ret == 0){
N    fifo_ctrl3.dec_fifo_xl = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL3,
X    ret = lsm6dsl_write_reg(ctx, 0x08U,
N                            (uint8_t*)&fifo_ctrl3, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Selects Batching Data Rate (writing frequency in FIFO) for
N  *         accelerometer data.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of dec_fifo_xl in reg FIFO_CTRL3
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_xl_batch_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_xl_t *val)
N{
N  lsm6dsl_fifo_ctrl3_t fifo_ctrl3;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL3, (uint8_t*)&fifo_ctrl3, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x08U, (uint8_t*)&fifo_ctrl3, 1);
N  switch (fifo_ctrl3.dec_fifo_xl) {
N    case LSM6DSL_FIFO_XL_DISABLE:
N      *val = LSM6DSL_FIFO_XL_DISABLE;
N      break;
N    case LSM6DSL_FIFO_XL_NO_DEC:
N      *val = LSM6DSL_FIFO_XL_NO_DEC;
N      break;
N    case LSM6DSL_FIFO_XL_DEC_2:
N      *val = LSM6DSL_FIFO_XL_DEC_2;
N      break;
N    case LSM6DSL_FIFO_XL_DEC_3:
N      *val = LSM6DSL_FIFO_XL_DEC_3;
N      break;
N    case LSM6DSL_FIFO_XL_DEC_4:
N      *val = LSM6DSL_FIFO_XL_DEC_4;
N      break;
N    case LSM6DSL_FIFO_XL_DEC_8:
N      *val = LSM6DSL_FIFO_XL_DEC_8;
N      break;
N    case LSM6DSL_FIFO_XL_DEC_16:
N      *val = LSM6DSL_FIFO_XL_DEC_16;
N      break;
N    case LSM6DSL_FIFO_XL_DEC_32:
N      *val = LSM6DSL_FIFO_XL_DEC_32;
N      break;
N    default:
N      *val = LSM6DSL_FIFO_XL_DEC_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Selects Batching Data Rate (writing frequency in FIFO)
N  *         for gyroscope data.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of dec_fifo_gyro in reg FIFO_CTRL3
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_gy_batch_set(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_gyro_t val)
N{
N  lsm6dsl_fifo_ctrl3_t fifo_ctrl3;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL3, (uint8_t*)&fifo_ctrl3, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x08U, (uint8_t*)&fifo_ctrl3, 1);
N  if(ret == 0){
N    fifo_ctrl3.dec_fifo_gyro = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL3, (uint8_t*)&fifo_ctrl3, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x08U, (uint8_t*)&fifo_ctrl3, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Selects Batching Data Rate (writing frequency in FIFO)
N  *         for gyroscope data.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of dec_fifo_gyro in reg FIFO_CTRL3
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_gy_batch_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_dec_fifo_gyro_t *val)
N{
N  lsm6dsl_fifo_ctrl3_t fifo_ctrl3;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL3, (uint8_t*)&fifo_ctrl3, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x08U, (uint8_t*)&fifo_ctrl3, 1);
N  switch (fifo_ctrl3.dec_fifo_gyro) {
N    case LSM6DSL_FIFO_GY_DISABLE:
N      *val = LSM6DSL_FIFO_GY_DISABLE;
N      break;
N    case LSM6DSL_FIFO_GY_NO_DEC:
N      *val = LSM6DSL_FIFO_GY_NO_DEC;
N      break;
N    case LSM6DSL_FIFO_GY_DEC_2:
N      *val = LSM6DSL_FIFO_GY_DEC_2;
N      break;
N    case LSM6DSL_FIFO_GY_DEC_3:
N      *val = LSM6DSL_FIFO_GY_DEC_3;
N      break;
N    case LSM6DSL_FIFO_GY_DEC_4:
N      *val = LSM6DSL_FIFO_GY_DEC_4;
N      break;
N    case LSM6DSL_FIFO_GY_DEC_8:
N      *val = LSM6DSL_FIFO_GY_DEC_8;
N      break;
N    case LSM6DSL_FIFO_GY_DEC_16:
N      *val = LSM6DSL_FIFO_GY_DEC_16;
N      break;
N    case LSM6DSL_FIFO_GY_DEC_32:
N      *val = LSM6DSL_FIFO_GY_DEC_32;
N      break;
N    default:
N      *val = LSM6DSL_FIFO_GY_DEC_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief   Selects Batching Data Rate (writing frequency in FIFO)
N  *          for third data set.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of dec_ds3_fifo in reg FIFO_CTRL4
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_dataset_3_batch_set(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds3_fifo_t val)
N{
N  lsm6dsl_fifo_ctrl4_t fifo_ctrl4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  if(ret == 0){
N    fifo_ctrl4.dec_ds3_fifo = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL4,
X    ret = lsm6dsl_write_reg(ctx, 0x09U,
N                            (uint8_t*)&fifo_ctrl4, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief   Selects Batching Data Rate (writing frequency in FIFO)
N  *          for third data set.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of dec_ds3_fifo in reg FIFO_CTRL4
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_dataset_3_batch_get(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds3_fifo_t *val)
N{
N  lsm6dsl_fifo_ctrl4_t fifo_ctrl4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  switch (fifo_ctrl4.dec_ds3_fifo) {
N    case LSM6DSL_FIFO_DS3_DISABLE:
N      *val = LSM6DSL_FIFO_DS3_DISABLE;
N      break;
N    case LSM6DSL_FIFO_DS3_NO_DEC:
N      *val = LSM6DSL_FIFO_DS3_NO_DEC;
N      break;
N    case LSM6DSL_FIFO_DS3_DEC_2:
N      *val = LSM6DSL_FIFO_DS3_DEC_2;
N      break;
N    case LSM6DSL_FIFO_DS3_DEC_3:
N      *val = LSM6DSL_FIFO_DS3_DEC_3;
N      break;
N    case LSM6DSL_FIFO_DS3_DEC_4:
N      *val = LSM6DSL_FIFO_DS3_DEC_4;
N      break;
N    case LSM6DSL_FIFO_DS3_DEC_8:
N      *val = LSM6DSL_FIFO_DS3_DEC_8;
N      break;
N    case LSM6DSL_FIFO_DS3_DEC_16:
N      *val = LSM6DSL_FIFO_DS3_DEC_16;
N      break;
N    case LSM6DSL_FIFO_DS3_DEC_32:
N      *val = LSM6DSL_FIFO_DS3_DEC_32;
N      break;
N    default:
N      *val = LSM6DSL_FIFO_DS3_DEC_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief   Selects Batching Data Rate (writing frequency in FIFO)
N  *          for fourth data set.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of dec_ds4_fifo in reg FIFO_CTRL4
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_dataset_4_batch_set(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds4_fifo_t val)
N{
N  lsm6dsl_fifo_ctrl4_t fifo_ctrl4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  if(ret == 0){
N    fifo_ctrl4.dec_ds4_fifo = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL4,
X    ret = lsm6dsl_write_reg(ctx, 0x09U,
N                            (uint8_t*)&fifo_ctrl4, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief   Selects Batching Data Rate (writing frequency in FIFO) for
N  *          fourth data set.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of dec_ds4_fifo in reg FIFO_CTRL4
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_dataset_4_batch_get(lsm6dsl_ctx_t *ctx,
N                                         lsm6dsl_dec_ds4_fifo_t *val)
N{
N  lsm6dsl_fifo_ctrl4_t fifo_ctrl4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  switch (fifo_ctrl4.dec_ds4_fifo) {
N    case LSM6DSL_FIFO_DS4_DISABLE:
N      *val = LSM6DSL_FIFO_DS4_DISABLE;
N      break;
N    case LSM6DSL_FIFO_DS4_NO_DEC:
N      *val = LSM6DSL_FIFO_DS4_NO_DEC;
N      break;
N    case LSM6DSL_FIFO_DS4_DEC_2:
N      *val = LSM6DSL_FIFO_DS4_DEC_2;
N      break;
N    case LSM6DSL_FIFO_DS4_DEC_3:
N      *val = LSM6DSL_FIFO_DS4_DEC_3;
N      break;
N    case LSM6DSL_FIFO_DS4_DEC_4:
N      *val = LSM6DSL_FIFO_DS4_DEC_4;
N      break;
N    case LSM6DSL_FIFO_DS4_DEC_8:
N      *val = LSM6DSL_FIFO_DS4_DEC_8;
N      break;
N    case LSM6DSL_FIFO_DS4_DEC_16:
N      *val = LSM6DSL_FIFO_DS4_DEC_16;
N      break;
N    case LSM6DSL_FIFO_DS4_DEC_32:
N      *val = LSM6DSL_FIFO_DS4_DEC_32;
N      break;
N    default:
N      *val = LSM6DSL_FIFO_DS4_DEC_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief   8-bit data storage in FIFO.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of only_high_data in reg FIFO_CTRL4
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_xl_gy_8bit_format_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_fifo_ctrl4_t fifo_ctrl4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  if(ret == 0){
N    fifo_ctrl4.only_high_data = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  8-bit data storage in FIFO.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of only_high_data in reg FIFO_CTRL4
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_xl_gy_8bit_format_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_fifo_ctrl4_t fifo_ctrl4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  *val = fifo_ctrl4.only_high_data;
N
N  return ret;
N}
N
N/**
N  * @brief  Sensing chain FIFO stop values memorization at threshold
N  *         level.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of stop_on_fth in reg FIFO_CTRL4
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_stop_on_wtm_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_fifo_ctrl4_t fifo_ctrl4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  if(ret == 0){
N    fifo_ctrl4.stop_on_fth = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Sensing chain FIFO stop values memorization at threshold
N  *         level.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of stop_on_fth in reg FIFO_CTRL4
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_stop_on_wtm_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_fifo_ctrl4_t fifo_ctrl4;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL4, (uint8_t*)&fifo_ctrl4, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x09U, (uint8_t*)&fifo_ctrl4, 1);
N  *val = fifo_ctrl4.stop_on_fth;
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO mode selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of fifo_mode in reg FIFO_CTRL5
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t val)
N{
N  lsm6dsl_fifo_ctrl5_t fifo_ctrl5;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, (uint8_t*)&fifo_ctrl5, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0AU, (uint8_t*)&fifo_ctrl5, 1);
N  if(ret == 0){
N    fifo_ctrl5.fifo_mode = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL5, (uint8_t*)&fifo_ctrl5, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x0AU, (uint8_t*)&fifo_ctrl5, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  FIFO mode selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of fifo_mode in reg FIFO_CTRL5
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t *val)
N{
N  lsm6dsl_fifo_ctrl5_t fifo_ctrl5;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, (uint8_t*)&fifo_ctrl5, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0AU, (uint8_t*)&fifo_ctrl5, 1);
N  switch (fifo_ctrl5.fifo_mode) {
N    case LSM6DSL_BYPASS_MODE:
N      *val = LSM6DSL_BYPASS_MODE;
N      break;
N    case LSM6DSL_FIFO_MODE:
N      *val = LSM6DSL_FIFO_MODE;
N      break;
N    case LSM6DSL_STREAM_TO_FIFO_MODE:
N      *val = LSM6DSL_STREAM_TO_FIFO_MODE;
N      break;
N    case LSM6DSL_BYPASS_TO_STREAM_MODE:
N      *val = LSM6DSL_BYPASS_TO_STREAM_MODE;
N      break;
N    case LSM6DSL_STREAM_MODE:
N      *val = LSM6DSL_STREAM_MODE;
N      break;
N    default:
N      *val = LSM6DSL_FIFO_MODE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  FIFO ODR selection, setting FIFO_MODE also.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of odr_fifo in reg FIFO_CTRL5
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_fifo_t val)
N{
N  lsm6dsl_fifo_ctrl5_t fifo_ctrl5;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, (uint8_t*)&fifo_ctrl5, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0AU, (uint8_t*)&fifo_ctrl5, 1);
N  if(ret == 0){
N    fifo_ctrl5.odr_fifo = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL5, (uint8_t*)&fifo_ctrl5, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x0AU, (uint8_t*)&fifo_ctrl5, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  FIFO ODR selection, setting FIFO_MODE also.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of odr_fifo in reg FIFO_CTRL5
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_fifo_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_fifo_t *val)
N{
N  lsm6dsl_fifo_ctrl5_t fifo_ctrl5;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, (uint8_t*)&fifo_ctrl5, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x0AU, (uint8_t*)&fifo_ctrl5, 1);
N  switch (fifo_ctrl5.odr_fifo) {
N    case LSM6DSL_FIFO_DISABLE:
N      *val = LSM6DSL_FIFO_DISABLE;
N      break;
N    case LSM6DSL_FIFO_12Hz5:
N      *val = LSM6DSL_FIFO_12Hz5;
N      break;
N    case LSM6DSL_FIFO_26Hz:
N      *val = LSM6DSL_FIFO_26Hz;
N      break;
N    case LSM6DSL_FIFO_52Hz:
N      *val = LSM6DSL_FIFO_52Hz;
N      break;
N    case LSM6DSL_FIFO_104Hz:
N      *val = LSM6DSL_FIFO_104Hz;
N      break;
N    case LSM6DSL_FIFO_208Hz:
N      *val = LSM6DSL_FIFO_208Hz;
N      break;
N    case LSM6DSL_FIFO_416Hz:
N      *val = LSM6DSL_FIFO_416Hz;
N      break;
N    case LSM6DSL_FIFO_833Hz:
N      *val = LSM6DSL_FIFO_833Hz;
N      break;
N    case LSM6DSL_FIFO_1k66Hz:
N      *val = LSM6DSL_FIFO_1k66Hz;
N      break;
N    case LSM6DSL_FIFO_3k33Hz:
N      *val = LSM6DSL_FIFO_3k33Hz;
N      break;
N    case LSM6DSL_FIFO_6k66Hz:
N      *val = LSM6DSL_FIFO_6k66Hz;
N      break;
N    default:
N      *val = LSM6DSL_FIFO_RATE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_DEN_functionality
N  * @brief       This section groups all the functions concerning DEN
N  *              functionality.
N  * @{
N  *
N  */
N
N/**
N  * @brief  DEN active level configuration.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_lh in reg CTRL5_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
N int32_t lsm6dsl_den_polarity_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t val)
N{
N  lsm6dsl_ctrl5_c_t ctrl5_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  if(ret == 0){
N    ctrl5_c.den_lh = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  DEN active level configuration.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of den_lh in reg CTRL5_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_polarity_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_lh_t *val)
N{
N  lsm6dsl_ctrl5_c_t ctrl5_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL5_C, (uint8_t*)&ctrl5_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x14U, (uint8_t*)&ctrl5_c, 1);
N  switch (ctrl5_c.den_lh) {
N    case LSM6DSL_DEN_ACT_LOW:
N      *val = LSM6DSL_DEN_ACT_LOW;
N      break;
N    case LSM6DSL_DEN_ACT_HIGH:
N      *val = LSM6DSL_DEN_ACT_HIGH;
N      break;
N    default:
N      *val = LSM6DSL_DEN_POL_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  DEN functionality marking mode[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_mode in reg CTRL6_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t val)
N{
N  lsm6dsl_ctrl6_c_t ctrl6_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  if(ret == 0){
N    ctrl6_c.den_mode = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  DEN functionality marking mode[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_mode in reg CTRL6_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_mode_t *val)
N{
N  lsm6dsl_ctrl6_c_t ctrl6_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL6_C, (uint8_t*)&ctrl6_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x15U, (uint8_t*)&ctrl6_c, 1);
N  switch (ctrl6_c.den_mode) {
N    case LSM6DSL_DEN_DISABLE:
N      *val = LSM6DSL_DEN_DISABLE;
N      break;
N    case LSM6DSL_LEVEL_LETCHED:
N      *val = LSM6DSL_LEVEL_LETCHED;
N      break;
N    case LSM6DSL_LEVEL_TRIGGER:
N      *val = LSM6DSL_LEVEL_TRIGGER;
N      break;
N    case LSM6DSL_EDGE_TRIGGER:
N      *val = LSM6DSL_EDGE_TRIGGER;
N      break;
N    default:
N      *val = LSM6DSL_DEN_MODE_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Extend DEN functionality to accelerometer sensor.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_xl_g in reg CTRL9_XL
N  *                             and den_xl_en in CTRL4_C.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_enable_set(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  if(ret == 0){
N    ctrl9_xl.den_xl_g = (uint8_t)val & 0x01U;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N    if(ret == 0){
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X      ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N      if(ret == 0){
N        ctrl4_c.den_xl_en = (uint8_t)val & 0x02U;
N        ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X        ret = lsm6dsl_write_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Extend DEN functionality to accelerometer sensor. [get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of den_xl_g in reg CTRL9_XL
N  *                             and den_xl_en in CTRL4_C.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_enable_get(lsm6dsl_ctx_t *ctx, lsm6dsl_den_xl_en_t *val)
N{
N  lsm6dsl_ctrl4_c_t ctrl4_c;
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x13U, (uint8_t*)&ctrl4_c, 1);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N    switch ( ( ctrl4_c.den_xl_en << 1) + ctrl9_xl.den_xl_g ) {
N      case LSM6DSL_STAMP_IN_GY_DATA:
N        *val = LSM6DSL_STAMP_IN_GY_DATA;
N        break;
N      case LSM6DSL_STAMP_IN_XL_DATA:
N        *val = LSM6DSL_STAMP_IN_XL_DATA;
N        break;
N      case LSM6DSL_STAMP_IN_GY_XL_DATA:
N        *val = LSM6DSL_STAMP_IN_GY_XL_DATA;
N        break;
N      default:
N        *val = LSM6DSL_DEN_STAMP_ND;
N        break;
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  DEN value stored in LSB of Z-axis.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_z in reg CTRL9_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_mark_axis_z_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  if(ret == 0){
N    ctrl9_xl.den_z = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  DEN value stored in LSB of Z-axis.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_z in reg CTRL9_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_mark_axis_z_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  *val = ctrl9_xl.den_z;
N
N  return ret;
N}
N
N/**
N  * @brief  DEN value stored in LSB of Y-axis.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_y in reg CTRL9_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_mark_axis_y_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  if(ret == 0){
N    ctrl9_xl.den_y = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  DEN value stored in LSB of Y-axis.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_y in reg CTRL9_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_mark_axis_y_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  *val = ctrl9_xl.den_y;
N
N  return ret;
N}
N
N/**
N  * @brief  DEN value stored in LSB of X-axis.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_x in reg CTRL9_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_mark_axis_x_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  if(ret == 0){
N    ctrl9_xl.den_x = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  DEN value stored in LSB of X-axis.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of den_x in reg CTRL9_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_den_mark_axis_x_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  *val = ctrl9_xl.den_x;
N
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_Pedometer
N  * @brief       This section groups all the functions that manage pedometer.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Reset pedometer step counter.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pedo_rst_step in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_step_reset_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  if(ret == 0){
N    ctrl10_c.pedo_rst_step = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Reset pedometer step counter.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pedo_rst_step in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_step_reset_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  *val = ctrl10_c.pedo_rst_step;
N
N  return ret;
N}
N
N/**
N  * @brief  Enable pedometer algorithm.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pedo_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  if(ret == 0){
N    ctrl10_c.pedo_en = val;
N    if (val != 0x00U) {
N      ctrl10_c.func_en = val;
N    }
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  pedo_sens:   Enable pedometer algorithm.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pedo_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  *val = ctrl10_c.pedo_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Minimum threshold to detect a peak. Default is 10h.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of ths_min in reg
N  *                      CONFIG_PEDO_THS_MIN
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_config_pedo_ths_min_t config_pedo_ths_min;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN,
X    ret = lsm6dsl_read_reg(ctx, 0x0FU,
N                           (uint8_t*)&config_pedo_ths_min, 1);
N      if(ret == 0){
N       config_pedo_ths_min.ths_min = val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN,
X      ret = lsm6dsl_write_reg(ctx, 0x0FU,
N                              (uint8_t*)&config_pedo_ths_min, 1);
N        if(ret == 0){
N          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N        }
N      }
N    }
N  return ret;
N}
N
N/**
N  * @brief  Minimum threshold to detect a peak. Default is 10h.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of ths_min in reg  CONFIG_PEDO_THS_MIN
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_config_pedo_ths_min_t config_pedo_ths_min;
N  int32_t ret;
N
N    ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N    if(ret == 0){
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN,
X      ret = lsm6dsl_read_reg(ctx, 0x0FU,
N                             (uint8_t*)&config_pedo_ths_min, 1);
N      if(ret == 0){
N        *val =  config_pedo_ths_min.ths_min;
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  return ret;
N}
N
N/**
N  * @brief  pedo_full_scale:   Pedometer data range.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pedo_fs in
N  *                            reg CONFIG_PEDO_THS_MIN
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pedo_fs_t val)
N{
N  lsm6dsl_config_pedo_ths_min_t config_pedo_ths_min;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN,
X    ret = lsm6dsl_read_reg(ctx, 0x0FU,
N                           (uint8_t*)&config_pedo_ths_min, 1);
N    if(ret == 0){
N       config_pedo_ths_min.pedo_fs = (uint8_t) val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN,
X      ret = lsm6dsl_write_reg(ctx, 0x0FU,
N                              (uint8_t*)&config_pedo_ths_min, 1);
N      if(ret == 0){
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Pedometer data range.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of pedo_fs in
N  *                            reg CONFIG_PEDO_THS_MIN
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pedo_fs_t *val)
N{
N  lsm6dsl_config_pedo_ths_min_t config_pedo_ths_min;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_CONFIG_PEDO_THS_MIN,
X    ret = lsm6dsl_read_reg(ctx, 0x0FU,
N                           (uint8_t*)&config_pedo_ths_min, 1);
N    if(ret == 0){
N      switch (config_pedo_ths_min.pedo_fs) {
N         case LSM6DSL_PEDO_AT_2g:
N          *val = LSM6DSL_PEDO_AT_2g;
N          break;
N        case LSM6DSL_PEDO_AT_4g:
N          *val = LSM6DSL_PEDO_AT_4g;
N          break;
N        default:
N          *val = LSM6DSL_PEDO_FS_ND;
N          break;
N      }
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Pedometer debounce configuration register (r/w).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of deb_step in reg PEDO_DEB_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_debounce_steps_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_pedo_deb_reg_t pedo_deb_reg;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_PEDO_DEB_REG,
X    ret = lsm6dsl_read_reg(ctx, 0x14U,
N                           (uint8_t*)&pedo_deb_reg, 1);
N    if(ret == 0){
N      pedo_deb_reg.deb_step = val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_PEDO_DEB_REG,
X      ret = lsm6dsl_write_reg(ctx, 0x14U,
N                              (uint8_t*)&pedo_deb_reg, 1);
N        if(ret == 0){
N          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N        }
N      }
N    }
N  return ret;
N}
N
N/**
N  * @brief  Pedometer debounce configuration register (r/w).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of deb_step in reg PEDO_DEB_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_debounce_steps_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_pedo_deb_reg_t pedo_deb_reg;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_PEDO_DEB_REG,
X    ret = lsm6dsl_read_reg(ctx, 0x14U,
N                           (uint8_t*)&pedo_deb_reg, 1);
N      if(ret == 0){
N        *val = pedo_deb_reg.deb_step;
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N
N  return ret;
N}
N
N/**
N  * @brief  Debounce time. If the time between two consecutive steps is
N  *         greater than  DEB_TIME*80ms, the debouncer is reactivated.
N  *         Default value: 01101[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of deb_time in reg PEDO_DEB_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_timeout_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_pedo_deb_reg_t pedo_deb_reg;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_PEDO_DEB_REG,
X    ret = lsm6dsl_read_reg(ctx, 0x14U,
N                           (uint8_t*)&pedo_deb_reg, 1);
N    if(ret == 0){
N      pedo_deb_reg.deb_time = val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_PEDO_DEB_REG,
X      ret = lsm6dsl_write_reg(ctx, 0x14U,
N                              (uint8_t*)&pedo_deb_reg, 1);
N      if(ret == 0){
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Debounce time. If the time between two consecutive steps is
N  *         greater than  DEB_TIME*80ms, the debouncer is reactivated.
N  *         Default value: 01101[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of deb_time in reg PEDO_DEB_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_timeout_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_pedo_deb_reg_t pedo_deb_reg;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_PEDO_DEB_REG,
X    ret = lsm6dsl_read_reg(ctx, 0x14U,
N                           (uint8_t*)&pedo_deb_reg, 1);
N    if(ret == 0){
N      *val = pedo_deb_reg.deb_time;
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Time period register for step detection on delta time (r/w).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that contains data to write
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_steps_period_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_STEP_COUNT_DELTA, buff, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x15U, buff, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Time period register for step detection on delta time (r/w).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_pedo_steps_period_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_STEP_COUNT_DELTA, buff, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x15U, buff, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_significant_motion
N  * @brief       This section groups all the functions that manage the
N  *              significant motion detection.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Enable significant motion detection function.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sign_motion_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_motion_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  if(ret == 0){
N    ctrl10_c.sign_motion_en = val;
N    if (val != 0x00U) {
N      ctrl10_c.func_en = val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X      ret = lsm6dsl_write_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable significant motion detection function.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of sign_motion_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_motion_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  *val = ctrl10_c.sign_motion_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Significant motion threshold.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that store significant motion threshold.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_motion_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SM_THS, buff, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x13U, buff, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Significant motion threshold.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that store significant motion threshold.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_motion_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SM_THS, buff, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x13U, buff, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_tilt_detection
N  * @brief       This section groups all the functions that manage the tilt
N  *              event detection.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Enable tilt calculation.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tilt_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  if(ret == 0){
N    ctrl10_c.tilt_en = val;
N    if (val != 0x00U) {
N      ctrl10_c.func_en = val;
N    }
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable tilt calculation.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tilt_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  *val = ctrl10_c.tilt_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Enable tilt calculation.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tilt_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_wrist_tilt_sens_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  if(ret == 0){
N    ctrl10_c.wrist_tilt_en = val;
N    if (val != 0x00U) {
N      ctrl10_c.func_en = val;
N    }
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable tilt calculation.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tilt_en in reg CTRL10_C
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_wrist_tilt_sens_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  *val = ctrl10_c.wrist_tilt_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Absolute Wrist Tilt latency register (r/w).
N  *         Absolute wrist tilt latency parameters.
N  *         1 LSB = 40 ms. Default value: 0Fh (600 ms).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that contains data to write
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tilt_latency_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);
N  if(ret == 0){
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_A_WRIST_TILT_LAT, buff, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x50U, buff, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Absolute Wrist Tilt latency register (r/w).
N  *         Absolute wrist tilt latency parameters.
N  *         1 LSB = 40 ms. Default value: 0Fh (600 ms).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tilt_latency_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_LAT, buff, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x50U, buff, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Absolute Wrist Tilt threshold register(r/w).
N  *         Absolute wrist tilt threshold parameters.
N  *         1 LSB = 15.625 mg.Default value: 20h (500 mg).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that contains data to write
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tilt_threshold_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);
N  if(ret == 0){
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_A_WRIST_TILT_THS, buff, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x54U, buff, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Absolute Wrist Tilt threshold register(r/w).
N  *         Absolute wrist tilt threshold parameters.
N  *         1 LSB = 15.625 mg.Default value: 20h (500 mg).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tilt_threshold_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_THS, buff, 1);
X    ret = lsm6dsl_read_reg(ctx, 0x54U, buff, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Absolute Wrist Tilt mask register (r/w).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Registers A_WRIST_TILT_MASK
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tilt_src_set(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_a_wrist_tilt_mask_t *val)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_MASK,
X    ret = lsm6dsl_read_reg(ctx, 0x59U,
N                           (uint8_t*) val, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Absolute Wrist Tilt mask register (r/w).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Registers A_WRIST_TILT_MASK
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_tilt_src_get(lsm6dsl_ctx_t *ctx,
N                             lsm6dsl_a_wrist_tilt_mask_t *val)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_B);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_A_WRIST_TILT_MASK,
X    ret = lsm6dsl_read_reg(ctx, 0x59U,
N                           (uint8_t*) val, 1);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_ magnetometer_sensor
N  * @brief       This section groups all the functions that manage additional
N  *              magnetometer sensor.
N  * @{
N  *
N  */
N
N/**
N  * @brief  Enable soft-iron correction algorithm for magnetometer.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of soft_en in reg CTRL9_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_soft_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  if(ret == 0){
N    ctrl9_xl.soft_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable soft-iron correction algorithm for magnetometer.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of soft_en in reg CTRL9_XL
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_soft_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_ctrl9_xl_t ctrl9_xl;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x18U, (uint8_t*)&ctrl9_xl, 1);
N  *val = ctrl9_xl.soft_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Enable hard-iron correction algorithm for magnetometer.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of iron_en in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_hard_iron_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_master_config_t master_config;
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  if(ret == 0){
N    master_config.iron_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,
X    ret = lsm6dsl_write_reg(ctx, 0x1AU,
N                            (uint8_t*)&master_config, 1);
N    if(ret == 0){
N      ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X      ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N      if(ret == 0){
N        if (val != 0x00U) {
N          ctrl10_c.func_en = val;
N        }
N        ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C,
X        ret = lsm6dsl_write_reg(ctx, 0x19U,
N                                (uint8_t*)&ctrl10_c, 1);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Enable hard-iron correction algorithm for magnetometer.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of iron_en in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_hard_iron_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  *val = master_config.iron_en;
N
N  return ret;
N}
N
N/**
N  * @brief  Soft iron 3x3 matrix. Value are expressed in sign-module format.
N  *         (Es. SVVVVVVVb where S is the sign 0/+1/- and V is the value).[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that contains data to write
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_soft_iron_mat_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MAG_SI_XX, buff, 9);
X    ret = lsm6dsl_write_reg(ctx, 0x24U, buff, 9);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Soft iron 3x3 matrix. Value are expressed in sign-module format.
N  *         (Es. SVVVVVVVb where S is the sign 0/+1/- and V is the value).[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_soft_iron_mat_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MAG_SI_XX, buff, 9);
X    ret = lsm6dsl_read_reg(ctx, 0x24U, buff, 9);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Offset for hard-iron compensation register (r/w). The value is
N  *         expressed as a 16-bit word in two’s complement.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that contains data to write
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_offset_set(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MAG_OFFX_L, buff, 6);
X    ret = lsm6dsl_write_reg(ctx, 0x2DU, buff, 6);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Offset for hard-iron compensation register(r/w).
N  *         The value is expressed as a 16-bit word in two’s complement.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  buff   Buffer that stores data read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_mag_offset_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
N{
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_MAG_OFFX_L, buff, 6);
X    ret = lsm6dsl_read_reg(ctx, 0x2DU, buff, 6);
N    if(ret == 0){
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N  return ret;
N}
N
N/**
N  * @}
N  *
N  */
N
N/**
N  * @defgroup    LSM6DSL_Sensor_hub
N  * @brief       This section groups all the functions that manage the sensor
N  *              hub functionality.
N  * @{
N  *
N  */
N
N  /**
N  * @brief  Enable function.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values func_en
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_func_en_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_ctrl10_c_t ctrl10_c;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X  ret = lsm6dsl_read_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  if(ret == 0){
N    ctrl10_c.func_en = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL10_C, (uint8_t*)&ctrl10_c, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x19U, (uint8_t*)&ctrl10_c, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Sensor synchronization time frame with the step of 500 ms and
N  *         full range of 5s. Unsigned 8-bit.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tph in reg SENSOR_SYNC_TIME_FRAME
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_sync_sens_frame_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_sensor_sync_time_frame_t sensor_sync_time_frame;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSOR_SYNC_TIME_FRAME,
X  ret = lsm6dsl_read_reg(ctx, 0x04U,
N                         (uint8_t*)&sensor_sync_time_frame, 1);
N  if(ret == 0){
N     sensor_sync_time_frame.tph = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SENSOR_SYNC_TIME_FRAME,
X    ret = lsm6dsl_write_reg(ctx, 0x04U,
N                            (uint8_t*)&sensor_sync_time_frame, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Sensor synchronization time frame with the step of 500 ms and
N  *         full range of 5s. Unsigned 8-bit.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of tph in reg  SENSOR_SYNC_TIME_FRAME
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_sync_sens_frame_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_sensor_sync_time_frame_t sensor_sync_time_frame;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSOR_SYNC_TIME_FRAME,
X  ret = lsm6dsl_read_reg(ctx, 0x04U,
N                         (uint8_t*)&sensor_sync_time_frame, 1);
N  *val =  sensor_sync_time_frame.tph;
N
N  return ret;
N}
N
N/**
N  * @brief  Resolution ratio of error code for sensor synchronization.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of rr in reg  SENSOR_SYNC_RES_RATIO
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_sync_sens_ratio_set(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t val)
N{
N  lsm6dsl_sensor_sync_res_ratio_t sensor_sync_res_ratio;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSOR_SYNC_RES_RATIO,
X  ret = lsm6dsl_read_reg(ctx, 0x05U,
N                              (uint8_t*)&sensor_sync_res_ratio, 1);
N  if(ret == 0){
N    sensor_sync_res_ratio.rr = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SENSOR_SYNC_RES_RATIO,
X    ret = lsm6dsl_write_reg(ctx, 0x05U,
N                            (uint8_t*)&sensor_sync_res_ratio, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Resolution ratio of error code for sensor synchronization.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of rr in reg  SENSOR_SYNC_RES_RATIO
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_sync_sens_ratio_get(lsm6dsl_ctx_t *ctx, lsm6dsl_rr_t *val)
N{
N  lsm6dsl_sensor_sync_res_ratio_t sensor_sync_res_ratio;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSOR_SYNC_RES_RATIO,
X  ret = lsm6dsl_read_reg(ctx, 0x05U,
N                         (uint8_t*)&sensor_sync_res_ratio, 1);
N
N  switch ( sensor_sync_res_ratio.rr) {
N    case LSM6DSL_RES_RATIO_2_11:
N      *val = LSM6DSL_RES_RATIO_2_11;
N      break;
N    case LSM6DSL_RES_RATIO_2_12:
N      *val = LSM6DSL_RES_RATIO_2_12;
N      break;
N    case LSM6DSL_RES_RATIO_2_13:
N      *val = LSM6DSL_RES_RATIO_2_13;
N      break;
N    case LSM6DSL_RES_RATIO_2_14:
N      *val = LSM6DSL_RES_RATIO_2_14;
N      break;
N    default:
N      *val = LSM6DSL_RES_RATIO_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Sensor hub I2C master enable.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of master_on in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_master_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  if(ret == 0){
N    master_config.master_on = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,
X    ret = lsm6dsl_write_reg(ctx, 0x1AU,
N                            (uint8_t*)&master_config, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Sensor hub I2C master enable.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of master_on in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_master_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  *val = master_config.master_on;
N
N  return ret;
N}
N
N/**
N  * @brief  I2C interface pass-through.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pass_through_mode in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_pass_through_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  if(ret == 0){
N    master_config.pass_through_mode = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,
X    ret = lsm6dsl_write_reg(ctx, 0x1AU,
N                            (uint8_t*)&master_config, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  I2C interface pass-through.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pass_through_mode in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_pass_through_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  *val = master_config.pass_through_mode;
N
N  return ret;
N}
N
N/**
N  * @brief  Master I2C pull-up enable/disable.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of pull_up_en in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_pin_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  if(ret == 0){
N    master_config.pull_up_en = (uint8_t) val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,
X    ret = lsm6dsl_write_reg(ctx, 0x1AU,
N                            (uint8_t*)&master_config, 1);
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Master I2C pull-up enable/disable.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of pull_up_en in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_pin_mode_get(lsm6dsl_ctx_t *ctx, lsm6dsl_pull_up_en_t *val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  switch (master_config.pull_up_en) {
N    case LSM6DSL_EXT_PULL_UP:
N      *val = LSM6DSL_EXT_PULL_UP;
N      break;
N    case LSM6DSL_INTERNAL_PULL_UP:
N      *val = LSM6DSL_INTERNAL_PULL_UP;
N      break;
N    default:
N      *val = LSM6DSL_SH_PIN_MODE;
N      break;
N  }
N  return ret;
N}
N
N/**
N  * @brief  Sensor hub trigger signal selection.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of start_config in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_syncro_mode_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_start_config_t val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  if(ret == 0){
N    master_config.start_config = (uint8_t)val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,
X    ret = lsm6dsl_write_reg(ctx, 0x1AU,
N                            (uint8_t*)&master_config, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Sensor hub trigger signal selection.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of start_config in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_syncro_mode_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_start_config_t *val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  switch (master_config.start_config) {
N    case LSM6DSL_XL_GY_DRDY:
N      *val = LSM6DSL_XL_GY_DRDY;
N      break;
N    case LSM6DSL_EXT_ON_INT2_PIN:
N      *val = LSM6DSL_EXT_ON_INT2_PIN;
N      break;
N    default:
N      *val = LSM6DSL_SH_SYNCRO_ND;
N      break;
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Manage the Master DRDY signal on INT1 pad.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of drdy_on_int1 in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_drdy_on_int1_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  if(ret == 0){
N    master_config.drdy_on_int1 = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CONFIG,
X    ret = lsm6dsl_write_reg(ctx, 0x1AU,
N                            (uint8_t*)&master_config, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Manage the Master DRDY signal on INT1 pad.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of drdy_on_int1 in reg MASTER_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_drdy_on_int1_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_master_config_t master_config;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CONFIG,
X  ret = lsm6dsl_read_reg(ctx, 0x1AU,
N                         (uint8_t*)&master_config, 1);
N  *val = master_config.drdy_on_int1;
N
N  return ret;
N}
N
N/**
N  * @brief  Sensor hub output registers.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Structure of registers from SENSORHUB1_REG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_read_data_raw_get(lsm6dsl_ctx_t *ctx,
N                                     lsm6dsl_emb_sh_read_t *val)
N{
N  int32_t ret;
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSORHUB1_REG,
X  ret = lsm6dsl_read_reg(ctx, 0x2EU,
N                         (uint8_t*)&(val->sh_byte_1), 12);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENSORHUB13_REG,
X    ret = lsm6dsl_read_reg(ctx, 0x4DU,
N                           (uint8_t*)&(val->sh_byte_13), 6);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Master command code used for stamping for sensor sync.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of master_cmd_code in
N  *                reg MASTER_CMD_CODE
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_cmd_sens_sync_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_master_cmd_code_t master_cmd_code;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CMD_CODE,
X  ret = lsm6dsl_read_reg(ctx, 0x60U,
N                         (uint8_t*)&master_cmd_code, 1);
N  if(ret == 0){
N    master_cmd_code.master_cmd_code = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_MASTER_CMD_CODE,
X    ret = lsm6dsl_write_reg(ctx, 0x60U,
N                            (uint8_t*)&master_cmd_code, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Master command code used for stamping for sensor sync.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of master_cmd_code in
N  *                reg MASTER_CMD_CODE
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_cmd_sens_sync_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_master_cmd_code_t master_cmd_code;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_MASTER_CMD_CODE,
X  ret = lsm6dsl_read_reg(ctx, 0x60U,
N                         (uint8_t*)&master_cmd_code, 1);
N  *val = master_cmd_code.master_cmd_code;
N
N  return ret;
N}
N
N/**
N  * @brief  Error code used for sensor synchronization.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of error_code in
N  *                reg SENS_SYNC_SPI_ERROR_CODE.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_spi_sync_error_set(lsm6dsl_ctx_t *ctx, uint8_t val)
N{
N  lsm6dsl_sens_sync_spi_error_code_t sens_sync_spi_error_code;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENS_SYNC_SPI_ERROR_CODE,
X  ret = lsm6dsl_read_reg(ctx, 0x61U,
N                         (uint8_t*)&sens_sync_spi_error_code, 1);
N  if(ret == 0){
N     sens_sync_spi_error_code.error_code = val;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SENS_SYNC_SPI_ERROR_CODE,
X    ret = lsm6dsl_write_reg(ctx, 0x61U,
N                            (uint8_t*)&sens_sync_spi_error_code, 1);
N  }
N  return ret;
N}
N
N/**
N  * @brief  Error code used for sensor synchronization.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of error_code in
N  *                reg SENS_SYNC_SPI_ERROR_CODE.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_spi_sync_error_get(lsm6dsl_ctx_t *ctx, uint8_t *val)
N{
N  lsm6dsl_sens_sync_spi_error_code_t sens_sync_spi_error_code;
N  int32_t ret;
N
N  ret = lsm6dsl_read_reg(ctx, LSM6DSL_SENS_SYNC_SPI_ERROR_CODE,
X  ret = lsm6dsl_read_reg(ctx, 0x61U,
N                         (uint8_t*)&sens_sync_spi_error_code, 1);
N  *val =  sens_sync_spi_error_code.error_code;
N
N  return ret;
N}
N
N/**
N  * @brief   Number of external sensors to be read by the sensor hub.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of aux_sens_on in reg SLAVE0_CONFIG.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_num_of_dev_connected_set(lsm6dsl_ctx_t *ctx,
N                                            lsm6dsl_aux_sens_on_t val)
N{
N  lsm6dsl_slave0_config_t slave0_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x04U,
N                           (uint8_t*)&slave0_config, 1);
N    if(ret == 0){
N      slave0_config.aux_sens_on = (uint8_t) val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE0_CONFIG,
X      ret = lsm6dsl_write_reg(ctx, 0x04U,
N                              (uint8_t*)&slave0_config, 1);
N      if(ret == 0){
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief   Number of external sensors to be read by the sensor hub.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of aux_sens_on in reg SLAVE0_CONFIG.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_num_of_dev_connected_get(lsm6dsl_ctx_t *ctx,
N                                            lsm6dsl_aux_sens_on_t *val)
N{
N  lsm6dsl_slave0_config_t slave0_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x04U,
N                           (uint8_t*)&slave0_config, 1);
N    if(ret == 0){
N      switch (slave0_config.aux_sens_on) {
N        case LSM6DSL_SLV_0:
N          *val = LSM6DSL_SLV_0;
N          break;
N        case LSM6DSL_SLV_0_1:
N          *val = LSM6DSL_SLV_0_1;
N          break;
N        case LSM6DSL_SLV_0_1_2:
N          *val = LSM6DSL_SLV_0_1_2;
N          break;
N        case LSM6DSL_SLV_0_1_2_3:
N          *val = LSM6DSL_SLV_0_1_2_3;
N          break;
N        default:
N          *val = LSM6DSL_SLV_EN_ND;
N          break;
N      }
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Configure slave 0 for perform a write.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Structure that contain:
N  *                  - uint8_t slv_add;    8 bit i2c device address
N  *                  - uint8_t slv_subadd; 8 bit register device address
N  *                  - uint8_t slv_data;   8 bit data to write
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_cfg_write(lsm6dsl_ctx_t *ctx, lsm6dsl_sh_cfg_write_t *val)
N{
N  lsm6dsl_slv0_add_t slv0_add;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    slv0_add.slave0_add = val->slv0_add;
N    slv0_add.rw_0 = 0;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV0_ADD, (uint8_t*)&slv0_add, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x02U, (uint8_t*)&slv0_add, 1);
N    if(ret == 0){
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV0_SUBADD,
X      ret = lsm6dsl_write_reg(ctx, 0x03U,
N                              &(val->slv0_subadd), 1);
N      if(ret == 0){
N        ret = lsm6dsl_write_reg(ctx, LSM6DSL_DATAWRITE_SRC_MODE_SUB_SLV0,
X        ret = lsm6dsl_write_reg(ctx, 0x0EU,
N                                &(val->slv0_data), 1);
N        if(ret == 0){
N          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N        }
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Configure slave 0 for perform a read.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Structure that contain:
N  *                  - uint8_t slv_add;    8 bit i2c device address
N  *                  - uint8_t slv_subadd; 8 bit register device address
N  *                  - uint8_t slv_len;    num of bit to read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slv0_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val)
N{
N  lsm6dsl_slave0_config_t slave0_config;
N  lsm6dsl_slv0_add_t slv0_add;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    slv0_add.slave0_add = val->slv_add;
N    slv0_add.rw_0 = 1;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV0_ADD, (uint8_t*)&slv0_add, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x02U, (uint8_t*)&slv0_add, 1);
N    if(ret == 0){
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV0_SUBADD,
X      ret = lsm6dsl_write_reg(ctx, 0x03U,
N                              &(val->slv_subadd), 1);
N      if(ret == 0){
N        ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG,
X        ret = lsm6dsl_read_reg(ctx, 0x04U,
N                               (uint8_t*)&slave0_config, 1);
N        slave0_config.slave0_numop = val->slv_len;
N        if(ret == 0){
N          ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE0_CONFIG,
X          ret = lsm6dsl_write_reg(ctx, 0x04U,
N                                  (uint8_t*)&slave0_config, 1);
N          if(ret == 0){
N            ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N          }
N        }
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Configure slave 1 for perform a read.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Structure that contain:
N  *                  - uint8_t slv_add;    8 bit i2c device address
N  *                  - uint8_t slv_subadd; 8 bit register device address
N  *                  - uint8_t slv_len;    num of bit to read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slv1_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val)
N{
N  lsm6dsl_slave1_config_t slave1_config;
N  lsm6dsl_slv1_add_t slv1_add;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    slv1_add.slave1_add  = val->slv_add;
N    slv1_add.r_1 = 1;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV1_ADD, (uint8_t*)&slv1_add, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x05U, (uint8_t*)&slv1_add, 1);
N    if(ret == 0){
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV1_SUBADD,
X      ret = lsm6dsl_write_reg(ctx, 0x06U,
N                                   &(val->slv_subadd), 1);
N      if(ret == 0){
N        ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG,
X        ret = lsm6dsl_read_reg(ctx, 0x07U,
N                               (uint8_t*)&slave1_config, 1);
N        slave1_config.slave1_numop = val->slv_len;
N        if(ret == 0){
N          ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE1_CONFIG,
X          ret = lsm6dsl_write_reg(ctx, 0x07U,
N                                  (uint8_t*)&slave1_config, 1);
N          if(ret == 0){
N            ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N          }
N        }
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Configure slave 2 for perform a read.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Structure that contain:
N  *                  - uint8_t slv_add;    8 bit i2c device address
N  *                  - uint8_t slv_subadd; 8 bit register device address
N  *                  - uint8_t slv_len;    num of bit to read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slv2_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val)
N{
N  lsm6dsl_slv2_add_t slv2_add;
N  lsm6dsl_slave2_config_t slave2_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    slv2_add.slave2_add  = val->slv_add;
N    slv2_add.r_2 = 1;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV2_ADD, (uint8_t*)&slv2_add, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x08U, (uint8_t*)&slv2_add, 1);
N    if(ret == 0){
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV2_SUBADD,
X      ret = lsm6dsl_write_reg(ctx, 0x09U,
N                              &(val->slv_subadd), 1);
N      if(ret == 0){
N        ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE2_CONFIG,
X        ret = lsm6dsl_read_reg(ctx, 0x0AU,
N                               (uint8_t*)&slave2_config, 1);
N        if(ret == 0){
N          slave2_config.slave2_numop = val->slv_len;
N          ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE2_CONFIG,
X          ret = lsm6dsl_write_reg(ctx, 0x0AU,
N                                  (uint8_t*)&slave2_config, 1);
N          if(ret == 0){
N            ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N          }
N        }
N      }
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Configure slave 3 for perform a read.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Structure that contain:
N  *                  - uint8_t slv_add;    8 bit i2c device address
N  *                  - uint8_t slv_subadd; 8 bit register device address
N  *                  - uint8_t slv_len;    num of bit to read
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slv3_cfg_read(lsm6dsl_ctx_t *ctx,
N                                 lsm6dsl_sh_cfg_read_t *val)
N{
N  lsm6dsl_slave3_config_t slave3_config;
N  lsm6dsl_slv3_add_t slv3_add;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    slv3_add.slave3_add  = val->slv_add;
N    slv3_add.r_3 = 1;
N    ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV3_ADD, (uint8_t*)&slv3_add, 1);
X    ret = lsm6dsl_write_reg(ctx, 0x0BU, (uint8_t*)&slv3_add, 1);
N    if(ret == 0){
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLV3_SUBADD,
X      ret = lsm6dsl_write_reg(ctx, 0x0CU,
N                              (uint8_t*)&(val->slv_subadd), 1);
N      if(ret == 0){
N        ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE3_CONFIG,
X        ret = lsm6dsl_read_reg(ctx, 0x0DU,
N                               (uint8_t*)&slave3_config, 1);
N        if(ret == 0){
N          slave3_config.slave3_numop = val->slv_len;
N          ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE3_CONFIG,
X          ret = lsm6dsl_write_reg(ctx, 0x0DU,
N                                  (uint8_t*)&slave3_config, 1);
N          if(ret == 0){
N            ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N          }
N        }
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Decimation of read operation on Slave 0 starting from the
N  *         sensor hub trigger.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of slave0_rate in reg SLAVE0_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slave_0_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave0_rate_t val)
N{
N  lsm6dsl_slave0_config_t slave0_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x04U,
N                           (uint8_t*)&slave0_config, 1);
N    if(ret == 0){
N      slave0_config.slave0_rate = (uint8_t) val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE0_CONFIG,
X      ret = lsm6dsl_write_reg(ctx, 0x04U,
N                              (uint8_t*)&slave0_config, 1);
N      if(ret == 0){
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Decimation of read operation on Slave 0 starting from the
N  *         sensor hub trigger.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of slave0_rate in reg SLAVE0_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slave_0_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave0_rate_t *val)
N{
N  lsm6dsl_slave0_config_t slave0_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE0_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x04U,
N                           (uint8_t*)&slave0_config, 1);
N    if(ret == 0){
N      switch (slave0_config.slave0_rate) {
N        case LSM6DSL_SL0_NO_DEC:
N          *val = LSM6DSL_SL0_NO_DEC;
N          break;
N        case LSM6DSL_SL0_DEC_2:
N          *val = LSM6DSL_SL0_DEC_2;
N          break;
N        case LSM6DSL_SL0_DEC_4:
N          *val = LSM6DSL_SL0_DEC_4;
N          break;
N        case LSM6DSL_SL0_DEC_8:
N          *val = LSM6DSL_SL0_DEC_8;
N          break;
N        default:
N          *val = LSM6DSL_SL0_DEC_ND;
N          break;
N      }
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Slave 0 write operation is performed only at the first sensor
N  *         hub cycle.
N  *         This is effective if the Aux_sens_on[1:0] field in
N  *         SLAVE0_CONFIG(04h) is set to a value other than 00.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of write_once in reg SLAVE1_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_write_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_write_once_t val)
N{
N  lsm6dsl_slave1_config_t slave1_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x07U,
N                           (uint8_t*)&slave1_config, 1);
N    slave1_config.write_once = (uint8_t) val;
N    if(ret == 0){
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE1_CONFIG,
X      ret = lsm6dsl_write_reg(ctx, 0x07U,
N                              (uint8_t*)&slave1_config, 1);
N      if(ret == 0){
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Slave 0 write operation is performed only at the first sensor
N  *         hub cycle.
N  *         This is effective if the Aux_sens_on[1:0] field in
N  *         SLAVE0_CONFIG(04h) is set to a value other than 00.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of write_once in reg SLAVE1_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_write_mode_get(lsm6dsl_ctx_t *ctx,
N                                  lsm6dsl_write_once_t *val)
N{
N  lsm6dsl_slave1_config_t slave1_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x07U,
N                           (uint8_t*)&slave1_config, 1);
N    if(ret == 0){
N      switch (slave1_config.write_once) {
N        case LSM6DSL_EACH_SH_CYCLE:
N          *val = LSM6DSL_EACH_SH_CYCLE;
N          break;
N        case LSM6DSL_ONLY_FIRST_CYCLE:
N          *val = LSM6DSL_ONLY_FIRST_CYCLE;
N          break;
N        default:
N          *val = LSM6DSL_SH_WR_MODE_ND;
N          break;
N      }
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Decimation of read operation on Slave 1 starting from the
N  *         sensor hub trigger.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of slave1_rate in reg SLAVE1_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slave_1_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave1_rate_t val)
N{
N  lsm6dsl_slave1_config_t slave1_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x07U,
N                           (uint8_t*)&slave1_config, 1);
N    if(ret == 0){
N      slave1_config.slave1_rate = (uint8_t) val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE1_CONFIG,
X      ret = lsm6dsl_write_reg(ctx, 0x07U,
N                              (uint8_t*)&slave1_config, 1);
N      if(ret == 0){
N          ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Decimation of read operation on Slave 1 starting from the
N  *         sensor hub trigger.[get]
N  *
N  * @param  ctx    Read / write interface definitions reg SLAVE1_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slave_1_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave1_rate_t *val)
N{
N  lsm6dsl_slave1_config_t slave1_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE1_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x07U,
N                           (uint8_t*)&slave1_config, 1);
N    if(ret == 0){
N      switch (slave1_config.slave1_rate) {
N        case LSM6DSL_SL1_NO_DEC:
N          *val = LSM6DSL_SL1_NO_DEC;
N          break;
N        case LSM6DSL_SL1_DEC_2:
N          *val = LSM6DSL_SL1_DEC_2;
N          break;
N        case LSM6DSL_SL1_DEC_4:
N          *val = LSM6DSL_SL1_DEC_4;
N          break;
N        case LSM6DSL_SL1_DEC_8:
N          *val = LSM6DSL_SL1_DEC_8;
N          break;
N        default:
N          *val = LSM6DSL_SL1_DEC_ND;
N          break;
N      }
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Decimation of read operation on Slave 2 starting from the
N  *         sensor hub trigger.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of slave2_rate in reg SLAVE2_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slave_2_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave2_rate_t val)
N{
N  lsm6dsl_slave2_config_t slave2_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE2_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x0AU,
N                           (uint8_t*)&slave2_config, 1);
N    if(ret == 0){
N      slave2_config.slave2_rate =(uint8_t) val;
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE2_CONFIG,
X      ret = lsm6dsl_write_reg(ctx, 0x0AU,
N                              (uint8_t*)&slave2_config, 1);
N      if(ret == 0){
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Decimation of read operation on Slave 2 starting from the
N  *         sensor hub trigger.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of slave2_rate in reg SLAVE2_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slave_2_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave2_rate_t *val)
N{
N  lsm6dsl_slave2_config_t slave2_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE2_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x0AU,
N                           (uint8_t*)&slave2_config, 1);
N    if(ret == 0){
N      switch (slave2_config.slave2_rate) {
N        case LSM6DSL_SL2_NO_DEC:
N          *val = LSM6DSL_SL2_NO_DEC;
N          break;
N        case LSM6DSL_SL2_DEC_2:
N          *val = LSM6DSL_SL2_DEC_2;
N          break;
N        case LSM6DSL_SL2_DEC_4:
N          *val = LSM6DSL_SL2_DEC_4;
N          break;
N        case LSM6DSL_SL2_DEC_8:
N          *val = LSM6DSL_SL2_DEC_8;
N          break;
N        default:
N          *val = LSM6DSL_SL2_DEC_ND;
N          break;
N      }
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N
N  return ret;
N}
N
N/**
N  * @brief  Decimation of read operation on Slave 3 starting from the
N  *         sensor hub trigger.[set]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Change the values of slave3_rate in reg SLAVE3_CONFIG
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slave_3_dec_set(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave3_rate_t val)
N{
N  lsm6dsl_slave3_config_t slave3_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE3_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x0DU,
N                           (uint8_t*)&slave3_config, 1);
N    slave3_config.slave3_rate = (uint8_t)val;
N    if(ret == 0){
N      ret = lsm6dsl_write_reg(ctx, LSM6DSL_SLAVE3_CONFIG,
X      ret = lsm6dsl_write_reg(ctx, 0x0DU,
N                              (uint8_t*)&slave3_config, 1);
N      if(ret == 0){
N        ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N      }
N    }
N  }
N  return ret;
N}
N
N/**
N  * @brief  Decimation of read operation on Slave 3 starting from the
N  *         sensor hub trigger.[get]
N  *
N  * @param  ctx    Read / write interface definitions
N  * @param  val    Get the values of slave3_rate in reg SLAVE3_CONFIG.
N  * @retval        Interface status (MANDATORY: return 0 -> no Error).
N  *
N  */
Nint32_t lsm6dsl_sh_slave_3_dec_get(lsm6dsl_ctx_t *ctx,
N                                   lsm6dsl_slave3_rate_t *val)
N{
N  lsm6dsl_slave3_config_t slave3_config;
N  int32_t ret;
N
N  ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_BANK_A);
N  if(ret == 0){
N    ret = lsm6dsl_read_reg(ctx, LSM6DSL_SLAVE3_CONFIG,
X    ret = lsm6dsl_read_reg(ctx, 0x0DU,
N                           (uint8_t*)&slave3_config, 1);
N    if(ret == 0){
N      switch (slave3_config.slave3_rate) {
N        case LSM6DSL_SL3_NO_DEC:
N          *val = LSM6DSL_SL3_NO_DEC;
N          break;
N        case LSM6DSL_SL3_DEC_2:
N          *val = LSM6DSL_SL3_DEC_2;
N          break;
N        case LSM6DSL_SL3_DEC_4:
N          *val = LSM6DSL_SL3_DEC_4;
N          break;
N        case LSM6DSL_SL3_DEC_8:
N          *val = LSM6DSL_SL3_DEC_8;
N          break;
N        default:
N          *val = LSM6DSL_SL3_DEC_ND;
N          break;
N      }
N      ret = lsm6dsl_mem_bank_set(ctx, LSM6DSL_USER_BANK);
N    }
N  }
N
N  return ret;
N}
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
