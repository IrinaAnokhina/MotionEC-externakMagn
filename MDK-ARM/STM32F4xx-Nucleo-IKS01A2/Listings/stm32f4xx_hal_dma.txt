; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_dma.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_dma.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_CalcBaseAndBitshift||, CODE, READONLY, ALIGN=2

                  DMA_CalcBaseAndBitshift PROC
;;;1184     */
;;;1185   static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1186   {
;;;1187     uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
000002  7808              LDRB     r0,[r1,#0]
000004  3810              SUBS     r0,r0,#0x10
000006  2318              MOVS     r3,#0x18
000008  fbb0f2f3          UDIV     r2,r0,r3
;;;1188     
;;;1189     /* lookup table for necessary bitshift of flags within status registers */
;;;1190     static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
;;;1191     hdma->StreamIndex = flagBitshiftOffset[stream_number];
00000c  4808              LDR      r0,|L1.48|
00000e  5c80              LDRB     r0,[r0,r2]
000010  65c8              STR      r0,[r1,#0x5c]
;;;1192     
;;;1193     if (stream_number > 3U)
000012  2a03              CMP      r2,#3
000014  d905              BLS      |L1.34|
;;;1194     {
;;;1195       /* return pointer to HISR and HIFCR */
;;;1196       hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
000016  6808              LDR      r0,[r1,#0]
000018  f36f0009          BFC      r0,#0,#10
00001c  1d00              ADDS     r0,r0,#4
00001e  6588              STR      r0,[r1,#0x58]
000020  e003              B        |L1.42|
                  |L1.34|
;;;1197     }
;;;1198     else
;;;1199     {
;;;1200       /* return pointer to LISR and LIFCR */
;;;1201       hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
000022  6808              LDR      r0,[r1,#0]
000024  f36f0009          BFC      r0,#0,#10
000028  6588              STR      r0,[r1,#0x58]
                  |L1.42|
;;;1202     }
;;;1203     
;;;1204     return hdma->StreamBaseAddress;
00002a  6d88              LDR      r0,[r1,#0x58]
;;;1205   }
00002c  4770              BX       lr
;;;1206   
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      flagBitshiftOffset

                          AREA ||i.DMA_CheckFifoParam||, CODE, READONLY, ALIGN=1

                  DMA_CheckFifoParam PROC
;;;1212     */
;;;1213   static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1214   {
;;;1215     HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;1216     uint32_t tmp = hdma->Init.FIFOThreshold;
000004  6a8a              LDR      r2,[r1,#0x28]
;;;1217     
;;;1218     /* Memory Data size equal to Byte */
;;;1219     if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
000006  698b              LDR      r3,[r1,#0x18]
000008  b9cb              CBNZ     r3,|L2.62|
;;;1220     {
;;;1221       switch (tmp)
00000a  b132              CBZ      r2,|L2.26|
00000c  2a01              CMP      r2,#1
00000e  d00d              BEQ      |L2.44|
000010  2a02              CMP      r2,#2
000012  d003              BEQ      |L2.28|
000014  2a03              CMP      r2,#3
000016  d110              BNE      |L2.58|
000018  e00e              B        |L2.56|
                  |L2.26|
;;;1222       {
;;;1223       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1224       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00001a  bf00              NOP      
                  |L2.28|
;;;1225         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00001c  6acb              LDR      r3,[r1,#0x2c]
00001e  f0037380          AND      r3,r3,#0x1000000
000022  f1b37f80          CMP      r3,#0x1000000
000026  d100              BNE      |L2.42|
;;;1226         {
;;;1227           status = HAL_ERROR;
000028  2001              MOVS     r0,#1
                  |L2.42|
;;;1228         }
;;;1229         break;
00002a  e007              B        |L2.60|
                  |L2.44|
;;;1230       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1231         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00002c  6acb              LDR      r3,[r1,#0x2c]
00002e  f1b37fc0          CMP      r3,#0x1800000
000032  d100              BNE      |L2.54|
;;;1232         {
;;;1233           status = HAL_ERROR;
000034  2001              MOVS     r0,#1
                  |L2.54|
;;;1234         }
;;;1235         break;
000036  e001              B        |L2.60|
                  |L2.56|
;;;1236       case DMA_FIFO_THRESHOLD_FULL:
;;;1237         break;
000038  e000              B        |L2.60|
                  |L2.58|
;;;1238       default:
;;;1239         break;
00003a  bf00              NOP      
                  |L2.60|
00003c  e034              B        |L2.168|
                  |L2.62|
;;;1240       }
;;;1241     }
;;;1242     
;;;1243     /* Memory Data size equal to Half-Word */
;;;1244     else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
00003e  698b              LDR      r3,[r1,#0x18]
000040  f5b35f00          CMP      r3,#0x2000
000044  d11a              BNE      |L2.124|
;;;1245     {
;;;1246       switch (tmp)
000046  b132              CBZ      r2,|L2.86|
000048  2a01              CMP      r2,#1
00004a  d007              BEQ      |L2.92|
00004c  2a02              CMP      r2,#2
00004e  d003              BEQ      |L2.88|
000050  2a03              CMP      r2,#3
000052  d111              BNE      |L2.120|
000054  e00a              B        |L2.108|
                  |L2.86|
;;;1247       {
;;;1248       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1249       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
000056  bf00              NOP      
                  |L2.88|
;;;1250         status = HAL_ERROR;
000058  2001              MOVS     r0,#1
;;;1251         break;
00005a  e00e              B        |L2.122|
                  |L2.92|
;;;1252       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1253         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00005c  6acb              LDR      r3,[r1,#0x2c]
00005e  f0037380          AND      r3,r3,#0x1000000
000062  f1b37f80          CMP      r3,#0x1000000
000066  d100              BNE      |L2.106|
;;;1254         {
;;;1255           status = HAL_ERROR;
000068  2001              MOVS     r0,#1
                  |L2.106|
;;;1256         }
;;;1257         break;
00006a  e006              B        |L2.122|
                  |L2.108|
;;;1258       case DMA_FIFO_THRESHOLD_FULL:
;;;1259         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00006c  6acb              LDR      r3,[r1,#0x2c]
00006e  f1b37fc0          CMP      r3,#0x1800000
000072  d100              BNE      |L2.118|
;;;1260         {
;;;1261           status = HAL_ERROR;
000074  2001              MOVS     r0,#1
                  |L2.118|
;;;1262         }
;;;1263         break;   
000076  e000              B        |L2.122|
                  |L2.120|
;;;1264       default:
;;;1265         break;
000078  bf00              NOP      
                  |L2.122|
00007a  e015              B        |L2.168|
                  |L2.124|
;;;1266       }
;;;1267     }
;;;1268     
;;;1269     /* Memory Data size equal to Word */
;;;1270     else
;;;1271     {
;;;1272       switch (tmp)
00007c  b132              CBZ      r2,|L2.140|
00007e  2a01              CMP      r2,#1
000080  d005              BEQ      |L2.142|
000082  2a02              CMP      r2,#2
000084  d004              BEQ      |L2.144|
000086  2a03              CMP      r2,#3
000088  d10c              BNE      |L2.164|
00008a  e003              B        |L2.148|
                  |L2.140|
;;;1273       {
;;;1274       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1275       case DMA_FIFO_THRESHOLD_HALFFULL:
00008c  bf00              NOP      
                  |L2.142|
;;;1276       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00008e  bf00              NOP      
                  |L2.144|
;;;1277         status = HAL_ERROR;
000090  2001              MOVS     r0,#1
;;;1278         break;
000092  e008              B        |L2.166|
                  |L2.148|
;;;1279       case DMA_FIFO_THRESHOLD_FULL:
;;;1280         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
000094  6acb              LDR      r3,[r1,#0x2c]
000096  f0037380          AND      r3,r3,#0x1000000
00009a  f1b37f80          CMP      r3,#0x1000000
00009e  d100              BNE      |L2.162|
;;;1281         {
;;;1282           status = HAL_ERROR;
0000a0  2001              MOVS     r0,#1
                  |L2.162|
;;;1283         }
;;;1284         break;
0000a2  e000              B        |L2.166|
                  |L2.164|
;;;1285       default:
;;;1286         break;
0000a4  bf00              NOP      
                  |L2.166|
0000a6  bf00              NOP                            ;1278
                  |L2.168|
;;;1287       }
;;;1288     } 
;;;1289     
;;;1290     return status; 
;;;1291   }
0000a8  4770              BX       lr
;;;1292   
                          ENDP


                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1150     */
;;;1151   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1152   {
;;;1153     /* Clear DBM bit */
;;;1154     hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
000002  6804              LDR      r4,[r0,#0]
000004  6824              LDR      r4,[r4,#0]
000006  f4242480          BIC      r4,r4,#0x40000
00000a  6805              LDR      r5,[r0,#0]
00000c  602c              STR      r4,[r5,#0]
;;;1155   
;;;1156     /* Configure DMA Stream data length */
;;;1157     hdma->Instance->NDTR = DataLength;
00000e  6804              LDR      r4,[r0,#0]
000010  6063              STR      r3,[r4,#4]
;;;1158   
;;;1159     /* Memory to Peripheral */
;;;1160     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000012  6884              LDR      r4,[r0,#8]
000014  2c40              CMP      r4,#0x40
000016  d104              BNE      |L3.34|
;;;1161     {
;;;1162       /* Configure DMA Stream destination address */
;;;1163       hdma->Instance->PAR = DstAddress;
000018  6804              LDR      r4,[r0,#0]
00001a  60a2              STR      r2,[r4,#8]
;;;1164   
;;;1165       /* Configure DMA Stream source address */
;;;1166       hdma->Instance->M0AR = SrcAddress;
00001c  6804              LDR      r4,[r0,#0]
00001e  60e1              STR      r1,[r4,#0xc]
000020  e003              B        |L3.42|
                  |L3.34|
;;;1167     }
;;;1168     /* Peripheral to Memory */
;;;1169     else
;;;1170     {
;;;1171       /* Configure DMA Stream source address */
;;;1172       hdma->Instance->PAR = SrcAddress;
000022  6804              LDR      r4,[r0,#0]
000024  60a1              STR      r1,[r4,#8]
;;;1173   
;;;1174       /* Configure DMA Stream destination address */
;;;1175       hdma->Instance->M0AR = DstAddress;
000026  6804              LDR      r4,[r0,#0]
000028  60e2              STR      r2,[r4,#0xc]
                  |L3.42|
;;;1176     }
;;;1177   }
00002a  bd30              POP      {r4,r5,pc}
;;;1178   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;514      */
;;;515    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;516    {
000002  4604              MOV      r4,r0
;;;517      /* calculate DMA base and stream number */
;;;518      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000004  6da5              LDR      r5,[r4,#0x58]
;;;519      
;;;520      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;521      
;;;522      if(hdma->State != HAL_DMA_STATE_BUSY)
00000c  f8940035          LDRB     r0,[r4,#0x35]
000010  2802              CMP      r0,#2
000012  d008              BEQ      |L4.38|
;;;523      {
;;;524        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000014  2080              MOVS     r0,#0x80
000016  6560              STR      r0,[r4,#0x54]
;;;525        
;;;526        /* Process Unlocked */
;;;527        __HAL_UNLOCK(hdma);
000018  bf00              NOP      
00001a  2000              MOVS     r0,#0
00001c  f8840034          STRB     r0,[r4,#0x34]
000020  bf00              NOP      
;;;528        
;;;529        return HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L4.36|
;;;530      }
;;;531      else
;;;532      {
;;;533        /* Disable all the transfer interrupts */
;;;534        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;535        hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;536        
;;;537        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;538        {
;;;539          hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;540        }
;;;541        
;;;542        /* Disable the stream */
;;;543        __HAL_DMA_DISABLE(hdma);
;;;544        
;;;545        /* Check if the DMA Stream is effectively disabled */
;;;546        while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;547        {
;;;548          /* Check for the Timeout */
;;;549          if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;550          {
;;;551            /* Update error code */
;;;552            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;553            
;;;554            /* Process Unlocked */
;;;555            __HAL_UNLOCK(hdma);
;;;556            
;;;557            /* Change the DMA state */
;;;558            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;559            
;;;560            return HAL_TIMEOUT;
;;;561          }
;;;562        }
;;;563        
;;;564        /* Clear all interrupt flags at correct offset within the register */
;;;565        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;566        
;;;567        /* Process Unlocked */
;;;568        __HAL_UNLOCK(hdma);
;;;569        
;;;570        /* Change the DMA state*/
;;;571        hdma->State = HAL_DMA_STATE_READY;
;;;572      }
;;;573      return HAL_OK;
;;;574    }
000024  bd70              POP      {r4-r6,pc}
                  |L4.38|
000026  6820              LDR      r0,[r4,#0]            ;534
000028  6800              LDR      r0,[r0,#0]            ;534
00002a  f0200016          BIC      r0,r0,#0x16           ;534
00002e  6821              LDR      r1,[r4,#0]            ;534
000030  6008              STR      r0,[r1,#0]            ;534
000032  6820              LDR      r0,[r4,#0]            ;535
000034  6940              LDR      r0,[r0,#0x14]         ;535
000036  f0200080          BIC      r0,r0,#0x80           ;535
00003a  6821              LDR      r1,[r4,#0]            ;535
00003c  6148              STR      r0,[r1,#0x14]         ;535
00003e  6c20              LDR      r0,[r4,#0x40]         ;537
000040  b908              CBNZ     r0,|L4.70|
000042  6ca0              LDR      r0,[r4,#0x48]         ;537
000044  b128              CBZ      r0,|L4.82|
                  |L4.70|
000046  6820              LDR      r0,[r4,#0]            ;539
000048  6800              LDR      r0,[r0,#0]            ;539
00004a  f0200008          BIC      r0,r0,#8              ;539
00004e  6821              LDR      r1,[r4,#0]            ;539
000050  6008              STR      r0,[r1,#0]            ;539
                  |L4.82|
000052  6820              LDR      r0,[r4,#0]            ;543
000054  6800              LDR      r0,[r0,#0]            ;543
000056  f0200001          BIC      r0,r0,#1              ;543
00005a  6821              LDR      r1,[r4,#0]            ;543
00005c  6008              STR      r0,[r1,#0]            ;543
00005e  e00f              B        |L4.128|
                  |L4.96|
000060  f7fffffe          BL       HAL_GetTick
000064  1b80              SUBS     r0,r0,r6              ;549
000066  2805              CMP      r0,#5                 ;549
000068  d90a              BLS      |L4.128|
00006a  2020              MOVS     r0,#0x20              ;552
00006c  6560              STR      r0,[r4,#0x54]         ;552
00006e  bf00              NOP                            ;555
000070  2000              MOVS     r0,#0                 ;555
000072  f8840034          STRB     r0,[r4,#0x34]         ;555
000076  bf00              NOP                            ;555
000078  2003              MOVS     r0,#3                 ;558
00007a  f8840035          STRB     r0,[r4,#0x35]         ;558
00007e  e7d1              B        |L4.36|
                  |L4.128|
000080  6820              LDR      r0,[r4,#0]            ;546
000082  6800              LDR      r0,[r0,#0]            ;546
000084  f0000001          AND      r0,r0,#1              ;546
000088  2800              CMP      r0,#0                 ;546
00008a  d1e9              BNE      |L4.96|
00008c  f894105c          LDRB     r1,[r4,#0x5c]         ;565
000090  203f              MOVS     r0,#0x3f              ;565
000092  4088              LSLS     r0,r0,r1              ;565
000094  60a8              STR      r0,[r5,#8]            ;565
000096  bf00              NOP                            ;568
000098  2000              MOVS     r0,#0                 ;568
00009a  f8840034          STRB     r0,[r4,#0x34]         ;568
00009e  bf00              NOP                            ;568
0000a0  2001              MOVS     r0,#1                 ;571
0000a2  f8840035          STRB     r0,[r4,#0x35]         ;571
0000a6  2000              MOVS     r0,#0                 ;573
0000a8  e7bc              B        |L4.36|
;;;575    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;581      */
;;;582    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;583    {
;;;584      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  f8910035          LDRB     r0,[r1,#0x35]
000006  2802              CMP      r0,#2
000008  d003              BEQ      |L5.18|
;;;585      {
;;;586        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000a  2080              MOVS     r0,#0x80
00000c  6548              STR      r0,[r1,#0x54]
;;;587        return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L5.16|
;;;588      }
;;;589      else
;;;590      {
;;;591        /* Set Abort State  */
;;;592        hdma->State = HAL_DMA_STATE_ABORT;
;;;593        
;;;594        /* Disable the stream */
;;;595        __HAL_DMA_DISABLE(hdma);
;;;596      }
;;;597    
;;;598      return HAL_OK;
;;;599    }
000010  4770              BX       lr
                  |L5.18|
000012  2005              MOVS     r0,#5                 ;592
000014  f8810035          STRB     r0,[r1,#0x35]         ;592
000018  6808              LDR      r0,[r1,#0]            ;595
00001a  6800              LDR      r0,[r0,#0]            ;595
00001c  f0200001          BIC      r0,r0,#1              ;595
000020  680a              LDR      r2,[r1,#0]            ;595
000022  6010              STR      r0,[r2,#0]            ;595
000024  2000              MOVS     r0,#0                 ;598
000026  e7f3              B        |L5.16|
;;;600    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA_DeInit PROC
;;;309      */
;;;310    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;311    {
000002  4604              MOV      r4,r0
;;;312      DMA_Base_Registers *regs;
;;;313    
;;;314      /* Check the DMA peripheral state */
;;;315      if(hdma == NULL)
000004  b90c              CBNZ     r4,|L6.10|
;;;316      {
;;;317        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;318      }
;;;319      
;;;320      /* Check the DMA peripheral state */
;;;321      if(hdma->State == HAL_DMA_STATE_BUSY)
;;;322      {
;;;323        /* Return error status */
;;;324        return HAL_BUSY;
;;;325      }
;;;326    
;;;327      /* Check the parameters */
;;;328      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;329    
;;;330      /* Disable the selected DMA Streamx */
;;;331      __HAL_DMA_DISABLE(hdma);
;;;332    
;;;333      /* Reset DMA Streamx control register */
;;;334      hdma->Instance->CR   = 0U;
;;;335    
;;;336      /* Reset DMA Streamx number of data to transfer register */
;;;337      hdma->Instance->NDTR = 0U;
;;;338    
;;;339      /* Reset DMA Streamx peripheral address register */
;;;340      hdma->Instance->PAR  = 0U;
;;;341    
;;;342      /* Reset DMA Streamx memory 0 address register */
;;;343      hdma->Instance->M0AR = 0U;
;;;344      
;;;345      /* Reset DMA Streamx memory 1 address register */
;;;346      hdma->Instance->M1AR = 0U;
;;;347      
;;;348      /* Reset DMA Streamx FIFO control register */
;;;349      hdma->Instance->FCR  = 0x00000021U;
;;;350      
;;;351      /* Get DMA steam Base Address */  
;;;352      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;353      
;;;354      /* Clean all callbacks */
;;;355      hdma->XferCpltCallback = NULL;
;;;356      hdma->XferHalfCpltCallback = NULL;
;;;357      hdma->XferM1CpltCallback = NULL;
;;;358      hdma->XferM1HalfCpltCallback = NULL;
;;;359      hdma->XferErrorCallback = NULL;
;;;360      hdma->XferAbortCallback = NULL;
;;;361    
;;;362      /* Clear all interrupt flags at correct offset within the register */
;;;363      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;364    
;;;365      /* Reset the error code */
;;;366      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;367    
;;;368      /* Reset the DMA state */
;;;369      hdma->State = HAL_DMA_STATE_RESET;
;;;370    
;;;371      /* Release Lock */
;;;372      __HAL_UNLOCK(hdma);
;;;373    
;;;374      return HAL_OK;
;;;375    }
000008  bd70              POP      {r4-r6,pc}
                  |L6.10|
00000a  f8940035          LDRB     r0,[r4,#0x35]         ;321
00000e  2802              CMP      r0,#2                 ;321
000010  d100              BNE      |L6.20|
000012  e7f9              B        |L6.8|
                  |L6.20|
000014  6820              LDR      r0,[r4,#0]            ;331
000016  6800              LDR      r0,[r0,#0]            ;331
000018  f0200001          BIC      r0,r0,#1              ;331
00001c  6821              LDR      r1,[r4,#0]            ;331
00001e  6008              STR      r0,[r1,#0]            ;331
000020  2000              MOVS     r0,#0                 ;334
000022  6821              LDR      r1,[r4,#0]            ;334
000024  6008              STR      r0,[r1,#0]            ;334
000026  6821              LDR      r1,[r4,#0]            ;337
000028  6048              STR      r0,[r1,#4]            ;337
00002a  6821              LDR      r1,[r4,#0]            ;340
00002c  6088              STR      r0,[r1,#8]            ;340
00002e  6821              LDR      r1,[r4,#0]            ;343
000030  60c8              STR      r0,[r1,#0xc]          ;343
000032  6821              LDR      r1,[r4,#0]            ;346
000034  6108              STR      r0,[r1,#0x10]         ;346
000036  2021              MOVS     r0,#0x21              ;349
000038  6821              LDR      r1,[r4,#0]            ;349
00003a  6148              STR      r0,[r1,#0x14]         ;349
00003c  4620              MOV      r0,r4                 ;352
00003e  f7fffffe          BL       DMA_CalcBaseAndBitshift
000042  4605              MOV      r5,r0                 ;352
000044  2000              MOVS     r0,#0                 ;355
000046  63e0              STR      r0,[r4,#0x3c]         ;355
000048  6420              STR      r0,[r4,#0x40]         ;356
00004a  6460              STR      r0,[r4,#0x44]         ;357
00004c  64a0              STR      r0,[r4,#0x48]         ;358
00004e  64e0              STR      r0,[r4,#0x4c]         ;359
000050  6520              STR      r0,[r4,#0x50]         ;360
000052  f894105c          LDRB     r1,[r4,#0x5c]         ;363
000056  203f              MOVS     r0,#0x3f              ;363
000058  4088              LSLS     r0,r0,r1              ;363
00005a  60a8              STR      r0,[r5,#8]            ;363
00005c  2000              MOVS     r0,#0                 ;366
00005e  6560              STR      r0,[r4,#0x54]         ;366
000060  f8840035          STRB     r0,[r4,#0x35]         ;369
000064  bf00              NOP                            ;372
000066  f8840034          STRB     r0,[r4,#0x34]         ;372
00006a  bf00              NOP                            ;372
00006c  bf00              NOP                            ;374
00006e  e7cb              B        |L6.8|
;;;376    
                          ENDP


                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1124     */
;;;1125   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1126   {
;;;1127     return hdma->ErrorCode;
000002  6d48              LDR      r0,[r1,#0x54]
;;;1128   }
000004  4770              BX       lr
;;;1129   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1113     */
;;;1114   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1115   {
;;;1116     return hdma->State;
000002  f8910035          LDRB     r0,[r1,#0x35]
;;;1117   }
000006  4770              BX       lr
;;;1118   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;747      */
;;;748    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;749    {
000002  4604              MOV      r4,r0
;;;750      uint32_t tmpisr;
;;;751      __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;752      uint32_t timeout = SystemCoreClock / 9600U;
000008  488c              LDR      r0,|L9.572|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f44f5116          MOV      r1,#0x2580
000010  fbb0f7f1          UDIV     r7,r0,r1
;;;753    
;;;754      /* calculate DMA base and stream number */
;;;755      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000014  6da5              LDR      r5,[r4,#0x58]
;;;756    
;;;757      tmpisr = regs->ISR;
000016  682e              LDR      r6,[r5,#0]
;;;758    
;;;759      /* Transfer Error Interrupt management ***************************************/
;;;760      if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
000018  f894105c          LDRB     r1,[r4,#0x5c]
00001c  2008              MOVS     r0,#8
00001e  4088              LSLS     r0,r0,r1
000020  4030              ANDS     r0,r0,r6
000022  b198              CBZ      r0,|L9.76|
;;;761      {
;;;762        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f0000004          AND      r0,r0,#4
00002c  b170              CBZ      r0,|L9.76|
;;;763        {
;;;764          /* Disable the transfer error interrupt */
;;;765          hdma->Instance->CR  &= ~(DMA_IT_TE);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;766          
;;;767          /* Clear the transfer error flag */
;;;768          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00003a  f894105c          LDRB     r1,[r4,#0x5c]
00003e  2008              MOVS     r0,#8
000040  4088              LSLS     r0,r0,r1
000042  60a8              STR      r0,[r5,#8]
;;;769          
;;;770          /* Update error code */
;;;771          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000044  6d60              LDR      r0,[r4,#0x54]
000046  f0400001          ORR      r0,r0,#1
00004a  6560              STR      r0,[r4,#0x54]
                  |L9.76|
;;;772        }
;;;773      }
;;;774      /* FIFO Error Interrupt management ******************************************/
;;;775      if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
00004c  f894105c          LDRB     r1,[r4,#0x5c]
000050  2001              MOVS     r0,#1
000052  4088              LSLS     r0,r0,r1
000054  4030              ANDS     r0,r0,r6
000056  b168              CBZ      r0,|L9.116|
;;;776      {
;;;777        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
000058  6820              LDR      r0,[r4,#0]
00005a  6940              LDR      r0,[r0,#0x14]
00005c  f0000080          AND      r0,r0,#0x80
000060  b140              CBZ      r0,|L9.116|
;;;778        {
;;;779          /* Clear the FIFO error flag */
;;;780          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000062  f894105c          LDRB     r1,[r4,#0x5c]
000066  2001              MOVS     r0,#1
000068  4088              LSLS     r0,r0,r1
00006a  60a8              STR      r0,[r5,#8]
;;;781    
;;;782          /* Update error code */
;;;783          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
00006c  6d60              LDR      r0,[r4,#0x54]
00006e  f0400002          ORR      r0,r0,#2
000072  6560              STR      r0,[r4,#0x54]
                  |L9.116|
;;;784        }
;;;785      }
;;;786      /* Direct Mode Error Interrupt management ***********************************/
;;;787      if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
000074  f894105c          LDRB     r1,[r4,#0x5c]
000078  2004              MOVS     r0,#4
00007a  4088              LSLS     r0,r0,r1
00007c  4030              ANDS     r0,r0,r6
00007e  b168              CBZ      r0,|L9.156|
;;;788      {
;;;789        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0000002          AND      r0,r0,#2
000088  b140              CBZ      r0,|L9.156|
;;;790        {
;;;791          /* Clear the direct mode error flag */
;;;792          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
00008a  f894105c          LDRB     r1,[r4,#0x5c]
00008e  2004              MOVS     r0,#4
000090  4088              LSLS     r0,r0,r1
000092  60a8              STR      r0,[r5,#8]
;;;793    
;;;794          /* Update error code */
;;;795          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
000094  6d60              LDR      r0,[r4,#0x54]
000096  f0400004          ORR      r0,r0,#4
00009a  6560              STR      r0,[r4,#0x54]
                  |L9.156|
;;;796        }
;;;797      }
;;;798      /* Half Transfer Complete Interrupt management ******************************/
;;;799      if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
00009c  f894105c          LDRB     r1,[r4,#0x5c]
0000a0  2010              MOVS     r0,#0x10
0000a2  4088              LSLS     r0,r0,r1
0000a4  4030              ANDS     r0,r0,r6
0000a6  b378              CBZ      r0,|L9.264|
;;;800      {
;;;801        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f0000008          AND      r0,r0,#8
0000b0  b350              CBZ      r0,|L9.264|
;;;802        {
;;;803          /* Clear the half transfer complete flag */
;;;804          regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
0000b2  f894105c          LDRB     r1,[r4,#0x5c]
0000b6  2010              MOVS     r0,#0x10
0000b8  4088              LSLS     r0,r0,r1
0000ba  60a8              STR      r0,[r5,#8]
;;;805          
;;;806          /* Multi_Buffering mode enabled */
;;;807          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000bc  6820              LDR      r0,[r4,#0]
0000be  6800              LDR      r0,[r0,#0]
0000c0  f4002080          AND      r0,r0,#0x40000
0000c4  b180              CBZ      r0,|L9.232|
;;;808          {
;;;809            /* Current memory buffer used is Memory 0 */
;;;810            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000c6  6820              LDR      r0,[r4,#0]
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f4002000          AND      r0,r0,#0x80000
0000ce  b928              CBNZ     r0,|L9.220|
;;;811            {
;;;812              if(hdma->XferHalfCpltCallback != NULL)
0000d0  6c20              LDR      r0,[r4,#0x40]
0000d2  b1c8              CBZ      r0,|L9.264|
;;;813              {
;;;814                /* Half transfer callback */
;;;815                hdma->XferHalfCpltCallback(hdma);
0000d4  4620              MOV      r0,r4
0000d6  6c21              LDR      r1,[r4,#0x40]
0000d8  4788              BLX      r1
0000da  e015              B        |L9.264|
                  |L9.220|
;;;816              }
;;;817            }
;;;818            /* Current memory buffer used is Memory 1 */
;;;819            else
;;;820            {
;;;821              if(hdma->XferM1HalfCpltCallback != NULL)
0000dc  6ca0              LDR      r0,[r4,#0x48]
0000de  b198              CBZ      r0,|L9.264|
;;;822              {
;;;823                /* Half transfer callback */
;;;824                hdma->XferM1HalfCpltCallback(hdma);
0000e0  4620              MOV      r0,r4
0000e2  6ca1              LDR      r1,[r4,#0x48]
0000e4  4788              BLX      r1
0000e6  e00f              B        |L9.264|
                  |L9.232|
;;;825              }
;;;826            }
;;;827          }
;;;828          else
;;;829          {
;;;830            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;831            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6800              LDR      r0,[r0,#0]
0000ec  f4007080          AND      r0,r0,#0x100
0000f0  b928              CBNZ     r0,|L9.254|
;;;832            {
;;;833              /* Disable the half transfer interrupt */
;;;834              hdma->Instance->CR  &= ~(DMA_IT_HT);
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6800              LDR      r0,[r0,#0]
0000f6  f0200008          BIC      r0,r0,#8
0000fa  6821              LDR      r1,[r4,#0]
0000fc  6008              STR      r0,[r1,#0]
                  |L9.254|
;;;835            }
;;;836            
;;;837            if(hdma->XferHalfCpltCallback != NULL)
0000fe  6c20              LDR      r0,[r4,#0x40]
000100  b110              CBZ      r0,|L9.264|
;;;838            {
;;;839              /* Half transfer callback */
;;;840              hdma->XferHalfCpltCallback(hdma);
000102  4620              MOV      r0,r4
000104  6c21              LDR      r1,[r4,#0x40]
000106  4788              BLX      r1
                  |L9.264|
;;;841            }
;;;842          }
;;;843        }
;;;844      }
;;;845      /* Transfer Complete Interrupt management ***********************************/
;;;846      if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
000108  f894105c          LDRB     r1,[r4,#0x5c]
00010c  2020              MOVS     r0,#0x20
00010e  4088              LSLS     r0,r0,r1
000110  4030              ANDS     r0,r0,r6
000112  2800              CMP      r0,#0
000114  d065              BEQ      |L9.482|
;;;847      {
;;;848        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
000116  6820              LDR      r0,[r4,#0]
000118  6800              LDR      r0,[r0,#0]
00011a  f0000010          AND      r0,r0,#0x10
00011e  2800              CMP      r0,#0
000120  d05f              BEQ      |L9.482|
;;;849        {
;;;850          /* Clear the transfer complete flag */
;;;851          regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
000122  f894105c          LDRB     r1,[r4,#0x5c]
000126  2020              MOVS     r0,#0x20
000128  4088              LSLS     r0,r0,r1
00012a  60a8              STR      r0,[r5,#8]
;;;852          
;;;853          if(HAL_DMA_STATE_ABORT == hdma->State)
00012c  f8940035          LDRB     r0,[r4,#0x35]
000130  2805              CMP      r0,#5
000132  d128              BNE      |L9.390|
;;;854          {
;;;855            /* Disable all the transfer interrupts */
;;;856            hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
000134  6820              LDR      r0,[r4,#0]
000136  6800              LDR      r0,[r0,#0]
000138  f0200016          BIC      r0,r0,#0x16
00013c  6821              LDR      r1,[r4,#0]
00013e  6008              STR      r0,[r1,#0]
;;;857            hdma->Instance->FCR &= ~(DMA_IT_FE);
000140  6820              LDR      r0,[r4,#0]
000142  6940              LDR      r0,[r0,#0x14]
000144  f0200080          BIC      r0,r0,#0x80
000148  6821              LDR      r1,[r4,#0]
00014a  6148              STR      r0,[r1,#0x14]
;;;858            
;;;859            if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
00014c  6c20              LDR      r0,[r4,#0x40]
00014e  b908              CBNZ     r0,|L9.340|
000150  6ca0              LDR      r0,[r4,#0x48]
000152  b128              CBZ      r0,|L9.352|
                  |L9.340|
;;;860            {
;;;861              hdma->Instance->CR  &= ~(DMA_IT_HT);
000154  6820              LDR      r0,[r4,#0]
000156  6800              LDR      r0,[r0,#0]
000158  f0200008          BIC      r0,r0,#8
00015c  6821              LDR      r1,[r4,#0]
00015e  6008              STR      r0,[r1,#0]
                  |L9.352|
;;;862            }
;;;863    
;;;864            /* Clear all interrupt flags at correct offset within the register */
;;;865            regs->IFCR = 0x3FU << hdma->StreamIndex;
000160  f894105c          LDRB     r1,[r4,#0x5c]
000164  203f              MOVS     r0,#0x3f
000166  4088              LSLS     r0,r0,r1
000168  60a8              STR      r0,[r5,#8]
;;;866    
;;;867            /* Process Unlocked */
;;;868            __HAL_UNLOCK(hdma);
00016a  bf00              NOP      
00016c  2000              MOVS     r0,#0
00016e  f8840034          STRB     r0,[r4,#0x34]
000172  bf00              NOP      
;;;869    
;;;870            /* Change the DMA state */
;;;871            hdma->State = HAL_DMA_STATE_READY;
000174  2001              MOVS     r0,#1
000176  f8840035          STRB     r0,[r4,#0x35]
;;;872    
;;;873            if(hdma->XferAbortCallback != NULL)
00017a  6d20              LDR      r0,[r4,#0x50]
00017c  b110              CBZ      r0,|L9.388|
;;;874            {
;;;875              hdma->XferAbortCallback(hdma);
00017e  4620              MOV      r0,r4
000180  6d21              LDR      r1,[r4,#0x50]
000182  4788              BLX      r1
                  |L9.388|
;;;876            }
;;;877            return;
;;;878          }
;;;879    
;;;880          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
;;;881          {
;;;882            /* Current memory buffer used is Memory 0 */
;;;883            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
;;;884            {
;;;885              if(hdma->XferM1CpltCallback != NULL)
;;;886              {
;;;887                /* Transfer complete Callback for memory1 */
;;;888                hdma->XferM1CpltCallback(hdma);
;;;889              }
;;;890            }
;;;891            /* Current memory buffer used is Memory 1 */
;;;892            else
;;;893            {
;;;894              if(hdma->XferCpltCallback != NULL)
;;;895              {
;;;896                /* Transfer complete Callback for memory0 */
;;;897                hdma->XferCpltCallback(hdma);
;;;898              }
;;;899            }
;;;900          }
;;;901          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;902          else
;;;903          {
;;;904            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
;;;905            {
;;;906              /* Disable the transfer complete interrupt */
;;;907              hdma->Instance->CR  &= ~(DMA_IT_TC);
;;;908    
;;;909              /* Process Unlocked */
;;;910              __HAL_UNLOCK(hdma);
;;;911    
;;;912              /* Change the DMA state */
;;;913              hdma->State = HAL_DMA_STATE_READY;
;;;914            }
;;;915    
;;;916            if(hdma->XferCpltCallback != NULL)
;;;917            {
;;;918              /* Transfer complete callback */
;;;919              hdma->XferCpltCallback(hdma);
;;;920            }
;;;921          }
;;;922        }
;;;923      }
;;;924      
;;;925      /* manage error case */
;;;926      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;927      {
;;;928        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;929        {
;;;930          hdma->State = HAL_DMA_STATE_ABORT;
;;;931    
;;;932          /* Disable the stream */
;;;933          __HAL_DMA_DISABLE(hdma);
;;;934    
;;;935          do
;;;936          {
;;;937            if (++count > timeout)
;;;938            {
;;;939              break;
;;;940            }
;;;941          }
;;;942          while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
;;;943    
;;;944          /* Process Unlocked */
;;;945          __HAL_UNLOCK(hdma);
;;;946    
;;;947          /* Change the DMA state */
;;;948          hdma->State = HAL_DMA_STATE_READY;
;;;949        }
;;;950    
;;;951        if(hdma->XferErrorCallback != NULL)
;;;952        {
;;;953          /* Transfer error callback */
;;;954          hdma->XferErrorCallback(hdma);
;;;955        }
;;;956      }
;;;957    }
000184  bdf8              POP      {r3-r7,pc}
                  |L9.390|
000186  6820              LDR      r0,[r4,#0]            ;880
000188  6800              LDR      r0,[r0,#0]            ;880
00018a  f4002080          AND      r0,r0,#0x40000        ;880
00018e  b180              CBZ      r0,|L9.434|
000190  6820              LDR      r0,[r4,#0]            ;883
000192  6800              LDR      r0,[r0,#0]            ;883
000194  f4002000          AND      r0,r0,#0x80000        ;883
000198  b928              CBNZ     r0,|L9.422|
00019a  6c60              LDR      r0,[r4,#0x44]         ;885
00019c  b110              CBZ      r0,|L9.420|
00019e  4620              MOV      r0,r4                 ;888
0001a0  6c61              LDR      r1,[r4,#0x44]         ;888
0001a2  4788              BLX      r1                    ;888
                  |L9.420|
0001a4  e01d              B        |L9.482|
                  |L9.422|
0001a6  6be0              LDR      r0,[r4,#0x3c]         ;894
0001a8  b1d8              CBZ      r0,|L9.482|
0001aa  4620              MOV      r0,r4                 ;897
0001ac  6be1              LDR      r1,[r4,#0x3c]         ;897
0001ae  4788              BLX      r1                    ;897
0001b0  e017              B        |L9.482|
                  |L9.434|
0001b2  6820              LDR      r0,[r4,#0]            ;904
0001b4  6800              LDR      r0,[r0,#0]            ;904
0001b6  f4007080          AND      r0,r0,#0x100          ;904
0001ba  b968              CBNZ     r0,|L9.472|
0001bc  6820              LDR      r0,[r4,#0]            ;907
0001be  6800              LDR      r0,[r0,#0]            ;907
0001c0  f0200010          BIC      r0,r0,#0x10           ;907
0001c4  6821              LDR      r1,[r4,#0]            ;907
0001c6  6008              STR      r0,[r1,#0]            ;907
0001c8  bf00              NOP                            ;910
0001ca  2000              MOVS     r0,#0                 ;910
0001cc  f8840034          STRB     r0,[r4,#0x34]         ;910
0001d0  bf00              NOP                            ;910
0001d2  2001              MOVS     r0,#1                 ;913
0001d4  f8840035          STRB     r0,[r4,#0x35]         ;913
                  |L9.472|
0001d8  6be0              LDR      r0,[r4,#0x3c]         ;916
0001da  b110              CBZ      r0,|L9.482|
0001dc  4620              MOV      r0,r4                 ;919
0001de  6be1              LDR      r1,[r4,#0x3c]         ;919
0001e0  4788              BLX      r1                    ;919
                  |L9.482|
0001e2  6d60              LDR      r0,[r4,#0x54]         ;926
0001e4  b338              CBZ      r0,|L9.566|
0001e6  6d60              LDR      r0,[r4,#0x54]         ;928
0001e8  f0000001          AND      r0,r0,#1              ;928
0001ec  b1f0              CBZ      r0,|L9.556|
0001ee  2005              MOVS     r0,#5                 ;930
0001f0  f8840035          STRB     r0,[r4,#0x35]         ;930
0001f4  6820              LDR      r0,[r4,#0]            ;933
0001f6  6800              LDR      r0,[r0,#0]            ;933
0001f8  f0200001          BIC      r0,r0,#1              ;933
0001fc  6821              LDR      r1,[r4,#0]            ;933
0001fe  6008              STR      r0,[r1,#0]            ;933
000200  bf00              NOP                            ;935
                  |L9.514|
000202  9800              LDR      r0,[sp,#0]            ;937
000204  1c40              ADDS     r0,r0,#1              ;937
000206  9000              STR      r0,[sp,#0]            ;937
000208  42b8              CMP      r0,r7                 ;937
00020a  d900              BLS      |L9.526|
00020c  e005              B        |L9.538|
                  |L9.526|
00020e  6820              LDR      r0,[r4,#0]            ;942
000210  6800              LDR      r0,[r0,#0]            ;942
000212  f0000001          AND      r0,r0,#1              ;942
000216  2800              CMP      r0,#0                 ;942
000218  d1f3              BNE      |L9.514|
                  |L9.538|
00021a  bf00              NOP                            ;939
00021c  bf00              NOP                            ;945
00021e  2000              MOVS     r0,#0                 ;945
000220  f8840034          STRB     r0,[r4,#0x34]         ;945
000224  bf00              NOP                            ;945
000226  2001              MOVS     r0,#1                 ;948
000228  f8840035          STRB     r0,[r4,#0x35]         ;948
                  |L9.556|
00022c  6ce0              LDR      r0,[r4,#0x4c]         ;951
00022e  b110              CBZ      r0,|L9.566|
000230  4620              MOV      r0,r4                 ;954
000232  6ce1              LDR      r1,[r4,#0x4c]         ;954
000234  4788              BLX      r1                    ;954
                  |L9.566|
000236  bf00              NOP      
000238  e7a4              B        |L9.388|
;;;958    
                          ENDP

00023a  0000              DCW      0x0000
                  |L9.572|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;170      */
;;;171    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;172    {
000004  4604              MOV      r4,r0
;;;173      uint32_t tmp = 0U;
000006  2500              MOVS     r5,#0
;;;174      uint32_t tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;175      DMA_Base_Registers *regs;
;;;176    
;;;177      /* Check the DMA peripheral state */
;;;178      if(hdma == NULL)
00000e  b914              CBNZ     r4,|L10.22|
;;;179      {
;;;180        return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L10.18|
;;;181      }
;;;182    
;;;183      /* Check the parameters */
;;;184      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;185      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;186      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;187      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;188      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;189      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;190      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;191      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;192      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;193      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;194      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;195         when FIFO mode is enabled */
;;;196      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;197      {
;;;198        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;199        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;200        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;201      }
;;;202      
;;;203      /* Allocate lock resource */
;;;204      __HAL_UNLOCK(hdma);
;;;205    
;;;206      /* Change DMA peripheral state */
;;;207      hdma->State = HAL_DMA_STATE_BUSY;
;;;208      
;;;209      /* Disable the peripheral */
;;;210      __HAL_DMA_DISABLE(hdma);
;;;211      
;;;212      /* Check if the DMA Stream is effectively disabled */
;;;213      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;214      {
;;;215        /* Check for the Timeout */
;;;216        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;217        {
;;;218          /* Update error code */
;;;219          hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;220          
;;;221          /* Change the DMA state */
;;;222          hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;223          
;;;224          return HAL_TIMEOUT;
;;;225        }
;;;226      }
;;;227      
;;;228      /* Get the CR register value */
;;;229      tmp = hdma->Instance->CR;
;;;230    
;;;231      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;232      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;233                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;234                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;235                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;236    
;;;237      /* Prepare the DMA Stream configuration */
;;;238      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;239              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;240              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;241              hdma->Init.Mode                | hdma->Init.Priority;
;;;242    
;;;243      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;244      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;245      {
;;;246        /* Get memory burst and peripheral burst */
;;;247        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;248      }
;;;249      
;;;250      /* Write to DMA Stream CR register */
;;;251      hdma->Instance->CR = tmp;  
;;;252    
;;;253      /* Get the FCR register value */
;;;254      tmp = hdma->Instance->FCR;
;;;255    
;;;256      /* Clear Direct mode and FIFO threshold bits */
;;;257      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;258    
;;;259      /* Prepare the DMA Stream FIFO configuration */
;;;260      tmp |= hdma->Init.FIFOMode;
;;;261    
;;;262      /* The FIFO threshold is not used when the FIFO mode is disabled */
;;;263      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;264      {
;;;265        /* Get the FIFO threshold */
;;;266        tmp |= hdma->Init.FIFOThreshold;
;;;267        
;;;268        /* Check compatibility between FIFO threshold level and size of the memory burst */
;;;269        /* for INCR4, INCR8, INCR16 bursts */
;;;270        if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
;;;271        {
;;;272          if (DMA_CheckFifoParam(hdma) != HAL_OK)
;;;273          {
;;;274            /* Update error code */
;;;275            hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
;;;276            
;;;277            /* Change the DMA state */
;;;278            hdma->State = HAL_DMA_STATE_READY;
;;;279            
;;;280            return HAL_ERROR; 
;;;281          }
;;;282        }
;;;283      }
;;;284      
;;;285      /* Write to DMA Stream FCR */
;;;286      hdma->Instance->FCR = tmp;
;;;287    
;;;288      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;289         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;290      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;291      
;;;292      /* Clear all interrupt flags */
;;;293      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;294    
;;;295      /* Initialize the error code */
;;;296      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;297                                                                                         
;;;298      /* Initialize the DMA state */
;;;299      hdma->State = HAL_DMA_STATE_READY;
;;;300    
;;;301      return HAL_OK;
;;;302    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L10.22|
000016  6a60              LDR      r0,[r4,#0x24]         ;196
000018  b100              CBZ      r0,|L10.28|
00001a  bf00              NOP                            ;200
                  |L10.28|
00001c  bf00              NOP                            ;204
00001e  2000              MOVS     r0,#0                 ;204
000020  f8840034          STRB     r0,[r4,#0x34]         ;204
000024  bf00              NOP                            ;204
000026  2002              MOVS     r0,#2                 ;207
000028  f8840035          STRB     r0,[r4,#0x35]         ;207
00002c  6820              LDR      r0,[r4,#0]            ;210
00002e  6800              LDR      r0,[r0,#0]            ;210
000030  f0200001          BIC      r0,r0,#1              ;210
000034  6821              LDR      r1,[r4,#0]            ;210
000036  6008              STR      r0,[r1,#0]            ;210
000038  e00a              B        |L10.80|
                  |L10.58|
00003a  f7fffffe          BL       HAL_GetTick
00003e  1bc0              SUBS     r0,r0,r7              ;216
000040  2805              CMP      r0,#5                 ;216
000042  d905              BLS      |L10.80|
000044  2020              MOVS     r0,#0x20              ;219
000046  6560              STR      r0,[r4,#0x54]         ;219
000048  2003              MOVS     r0,#3                 ;222
00004a  f8840035          STRB     r0,[r4,#0x35]         ;222
00004e  e7e0              B        |L10.18|
                  |L10.80|
000050  6820              LDR      r0,[r4,#0]            ;213
000052  6800              LDR      r0,[r0,#0]            ;213
000054  f0000001          AND      r0,r0,#1              ;213
000058  2800              CMP      r0,#0                 ;213
00005a  d1ee              BNE      |L10.58|
00005c  6820              LDR      r0,[r4,#0]            ;229
00005e  6805              LDR      r5,[r0,#0]            ;229
000060  4821              LDR      r0,|L10.232|
000062  4005              ANDS     r5,r5,r0              ;232
000064  e9d40101          LDRD     r0,r1,[r4,#4]         ;238
000068  4308              ORRS     r0,r0,r1              ;238
00006a  68e1              LDR      r1,[r4,#0xc]          ;238
00006c  4308              ORRS     r0,r0,r1              ;238
00006e  6921              LDR      r1,[r4,#0x10]         ;238
000070  4308              ORRS     r0,r0,r1              ;238
000072  6961              LDR      r1,[r4,#0x14]         ;238
000074  4308              ORRS     r0,r0,r1              ;238
000076  69a1              LDR      r1,[r4,#0x18]         ;238
000078  4308              ORRS     r0,r0,r1              ;238
00007a  69e1              LDR      r1,[r4,#0x1c]         ;238
00007c  4308              ORRS     r0,r0,r1              ;238
00007e  6a21              LDR      r1,[r4,#0x20]         ;238
000080  4308              ORRS     r0,r0,r1              ;238
000082  4305              ORRS     r5,r5,r0              ;238
000084  6a60              LDR      r0,[r4,#0x24]         ;244
000086  2804              CMP      r0,#4                 ;244
000088  d103              BNE      |L10.146|
00008a  e9d4010b          LDRD     r0,r1,[r4,#0x2c]      ;247
00008e  4308              ORRS     r0,r0,r1              ;247
000090  4305              ORRS     r5,r5,r0              ;247
                  |L10.146|
000092  6820              LDR      r0,[r4,#0]            ;251
000094  6005              STR      r5,[r0,#0]            ;251
000096  6820              LDR      r0,[r4,#0]            ;254
000098  6945              LDR      r5,[r0,#0x14]         ;254
00009a  f0250507          BIC      r5,r5,#7              ;257
00009e  6a60              LDR      r0,[r4,#0x24]         ;260
0000a0  4305              ORRS     r5,r5,r0              ;260
0000a2  6a60              LDR      r0,[r4,#0x24]         ;263
0000a4  2804              CMP      r0,#4                 ;263
0000a6  d10d              BNE      |L10.196|
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;266
0000aa  4305              ORRS     r5,r5,r0              ;266
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;270
0000ae  b148              CBZ      r0,|L10.196|
0000b0  4620              MOV      r0,r4                 ;272
0000b2  f7fffffe          BL       DMA_CheckFifoParam
0000b6  b128              CBZ      r0,|L10.196|
0000b8  2040              MOVS     r0,#0x40              ;275
0000ba  6560              STR      r0,[r4,#0x54]         ;275
0000bc  2001              MOVS     r0,#1                 ;278
0000be  f8840035          STRB     r0,[r4,#0x35]         ;278
0000c2  e7a6              B        |L10.18|
                  |L10.196|
0000c4  6820              LDR      r0,[r4,#0]            ;286
0000c6  6145              STR      r5,[r0,#0x14]         ;286
0000c8  4620              MOV      r0,r4                 ;290
0000ca  f7fffffe          BL       DMA_CalcBaseAndBitshift
0000ce  4606              MOV      r6,r0                 ;290
0000d0  f894105c          LDRB     r1,[r4,#0x5c]         ;293
0000d4  203f              MOVS     r0,#0x3f              ;293
0000d6  4088              LSLS     r0,r0,r1              ;293
0000d8  60b0              STR      r0,[r6,#8]            ;293
0000da  2000              MOVS     r0,#0                 ;296
0000dc  6560              STR      r0,[r4,#0x54]         ;296
0000de  2001              MOVS     r0,#1                 ;299
0000e0  f8840035          STRB     r0,[r4,#0x35]         ;299
0000e4  2000              MOVS     r0,#0                 ;301
0000e6  e794              B        |L10.18|
;;;303    
                          ENDP

                  |L10.232|
                          DCD      0xf010803f

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=1

                  HAL_DMA_PollForTransfer PROC
;;;611      */
;;;612    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;613    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;614      HAL_StatusTypeDef status = HAL_OK; 
00000a  f04f0a00          MOV      r10,#0
;;;615      uint32_t mask_cpltlevel;
;;;616      uint32_t tickstart = HAL_GetTick(); 
00000e  f7fffffe          BL       HAL_GetTick
000012  4683              MOV      r11,r0
;;;617      uint32_t tmpisr;
;;;618      
;;;619      /* calculate DMA base and stream number */
;;;620      DMA_Base_Registers *regs;
;;;621    
;;;622      if(HAL_DMA_STATE_BUSY != hdma->State)
000014  f8940035          LDRB     r0,[r4,#0x35]
000018  2802              CMP      r0,#2
00001a  d009              BEQ      |L11.48|
;;;623      {
;;;624        /* No transfer ongoing */
;;;625        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00001c  2080              MOVS     r0,#0x80
00001e  6560              STR      r0,[r4,#0x54]
;;;626        __HAL_UNLOCK(hdma);
000020  bf00              NOP      
000022  2000              MOVS     r0,#0
000024  f8840034          STRB     r0,[r4,#0x34]
000028  bf00              NOP      
;;;627        return HAL_ERROR;
00002a  2001              MOVS     r0,#1
                  |L11.44|
;;;628      }
;;;629    
;;;630      /* Polling mode not supported in circular mode and double buffering mode */
;;;631      if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
;;;632      {
;;;633        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;634        return HAL_ERROR;
;;;635      }
;;;636      
;;;637      /* Get the level transfer complete flag */
;;;638      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;639      {
;;;640        /* Transfer Complete flag */
;;;641        mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
;;;642      }
;;;643      else
;;;644      {
;;;645        /* Half Transfer Complete flag */
;;;646        mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
;;;647      }
;;;648      
;;;649      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;650      tmpisr = regs->ISR;
;;;651      
;;;652      while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
;;;653      {
;;;654        /* Check for the Timeout (Not applicable in circular mode)*/
;;;655        if(Timeout != HAL_MAX_DELAY)
;;;656        {
;;;657          if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
;;;658          {
;;;659            /* Update error code */
;;;660            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;661    
;;;662            /* Process Unlocked */
;;;663            __HAL_UNLOCK(hdma);
;;;664            
;;;665            /* Change the DMA state */
;;;666            hdma->State = HAL_DMA_STATE_READY;
;;;667            
;;;668            return HAL_TIMEOUT;
;;;669          }
;;;670        }
;;;671    
;;;672        /* Get the ISR register value */
;;;673        tmpisr = regs->ISR;
;;;674    
;;;675        if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
;;;676        {
;;;677          /* Update error code */
;;;678          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
;;;679          
;;;680          /* Clear the transfer error flag */
;;;681          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
;;;682        }
;;;683        
;;;684        if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
;;;685        {
;;;686          /* Update error code */
;;;687          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
;;;688          
;;;689          /* Clear the FIFO error flag */
;;;690          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
;;;691        }
;;;692        
;;;693        if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
;;;694        {
;;;695          /* Update error code */
;;;696          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
;;;697          
;;;698          /* Clear the Direct Mode error flag */
;;;699          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
;;;700        }
;;;701      }
;;;702      
;;;703      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;704      {
;;;705        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;706        {
;;;707          HAL_DMA_Abort(hdma);
;;;708        
;;;709          /* Clear the half transfer and transfer complete flags */
;;;710          regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;711        
;;;712          /* Process Unlocked */
;;;713          __HAL_UNLOCK(hdma);
;;;714    
;;;715          /* Change the DMA state */
;;;716          hdma->State= HAL_DMA_STATE_READY;
;;;717    
;;;718          return HAL_ERROR;
;;;719       }
;;;720      }
;;;721      
;;;722      /* Get the level transfer complete flag */
;;;723      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;724      {
;;;725        /* Clear the half transfer and transfer complete flags */
;;;726        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;727        
;;;728        /* Process Unlocked */
;;;729        __HAL_UNLOCK(hdma);
;;;730    
;;;731        hdma->State = HAL_DMA_STATE_READY;
;;;732      }
;;;733      else
;;;734      {
;;;735        /* Clear the half transfer and transfer complete flags */
;;;736        regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
;;;737      }
;;;738      
;;;739      return status;
;;;740    }
00002c  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.48|
000030  6820              LDR      r0,[r4,#0]            ;631
000032  6800              LDR      r0,[r0,#0]            ;631
000034  f4007080          AND      r0,r0,#0x100          ;631
000038  b120              CBZ      r0,|L11.68|
00003a  f44f7080          MOV      r0,#0x100             ;633
00003e  6560              STR      r0,[r4,#0x54]         ;633
000040  2001              MOVS     r0,#1                 ;634
000042  e7f3              B        |L11.44|
                  |L11.68|
000044  f1b80f00          CMP      r8,#0                 ;638
000048  d105              BNE      |L11.86|
00004a  f894105c          LDRB     r1,[r4,#0x5c]         ;641
00004e  2020              MOVS     r0,#0x20              ;641
000050  fa00f901          LSL      r9,r0,r1              ;641
000054  e004              B        |L11.96|
                  |L11.86|
000056  f894105c          LDRB     r1,[r4,#0x5c]         ;646
00005a  2010              MOVS     r0,#0x10              ;646
00005c  fa00f901          LSL      r9,r0,r1              ;646
                  |L11.96|
000060  6da5              LDR      r5,[r4,#0x58]         ;649
000062  682e              LDR      r6,[r5,#0]            ;650
000064  e042              B        |L11.236|
                  |L11.102|
000066  1c78              ADDS     r0,r7,#1              ;655
000068  b190              CBZ      r0,|L11.144|
00006a  b12f              CBZ      r7,|L11.120|
00006c  f7fffffe          BL       HAL_GetTick
000070  eba0000b          SUB      r0,r0,r11             ;657
000074  42b8              CMP      r0,r7                 ;657
000076  d90b              BLS      |L11.144|
                  |L11.120|
000078  2020              MOVS     r0,#0x20              ;660
00007a  6560              STR      r0,[r4,#0x54]         ;660
00007c  bf00              NOP                            ;663
00007e  2000              MOVS     r0,#0                 ;663
000080  f8840034          STRB     r0,[r4,#0x34]         ;663
000084  bf00              NOP                            ;663
000086  2001              MOVS     r0,#1                 ;666
000088  f8840035          STRB     r0,[r4,#0x35]         ;666
00008c  2003              MOVS     r0,#3                 ;668
00008e  e7cd              B        |L11.44|
                  |L11.144|
000090  682e              LDR      r6,[r5,#0]            ;673
000092  f894105c          LDRB     r1,[r4,#0x5c]         ;675
000096  2008              MOVS     r0,#8                 ;675
000098  4088              LSLS     r0,r0,r1              ;675
00009a  4030              ANDS     r0,r0,r6              ;675
00009c  b140              CBZ      r0,|L11.176|
00009e  6d60              LDR      r0,[r4,#0x54]         ;678
0000a0  f0400001          ORR      r0,r0,#1              ;678
0000a4  6560              STR      r0,[r4,#0x54]         ;678
0000a6  f894105c          LDRB     r1,[r4,#0x5c]         ;681
0000aa  2008              MOVS     r0,#8                 ;681
0000ac  4088              LSLS     r0,r0,r1              ;681
0000ae  60a8              STR      r0,[r5,#8]            ;681
                  |L11.176|
0000b0  f894105c          LDRB     r1,[r4,#0x5c]         ;684
0000b4  2001              MOVS     r0,#1                 ;684
0000b6  4088              LSLS     r0,r0,r1              ;684
0000b8  4030              ANDS     r0,r0,r6              ;684
0000ba  b140              CBZ      r0,|L11.206|
0000bc  6d60              LDR      r0,[r4,#0x54]         ;687
0000be  f0400002          ORR      r0,r0,#2              ;687
0000c2  6560              STR      r0,[r4,#0x54]         ;687
0000c4  f894105c          LDRB     r1,[r4,#0x5c]         ;690
0000c8  2001              MOVS     r0,#1                 ;690
0000ca  4088              LSLS     r0,r0,r1              ;690
0000cc  60a8              STR      r0,[r5,#8]            ;690
                  |L11.206|
0000ce  f894105c          LDRB     r1,[r4,#0x5c]         ;693
0000d2  2004              MOVS     r0,#4                 ;693
0000d4  4088              LSLS     r0,r0,r1              ;693
0000d6  4030              ANDS     r0,r0,r6              ;693
0000d8  b140              CBZ      r0,|L11.236|
0000da  6d60              LDR      r0,[r4,#0x54]         ;696
0000dc  f0400004          ORR      r0,r0,#4              ;696
0000e0  6560              STR      r0,[r4,#0x54]         ;696
0000e2  f894105c          LDRB     r1,[r4,#0x5c]         ;699
0000e6  2004              MOVS     r0,#4                 ;699
0000e8  4088              LSLS     r0,r0,r1              ;699
0000ea  60a8              STR      r0,[r5,#8]            ;699
                  |L11.236|
0000ec  ea060009          AND      r0,r6,r9              ;652
0000f0  b920              CBNZ     r0,|L11.252|
0000f2  6d60              LDR      r0,[r4,#0x54]         ;652
0000f4  f0000001          AND      r0,r0,#1              ;652
0000f8  2800              CMP      r0,#0                 ;652
0000fa  d0b4              BEQ      |L11.102|
                  |L11.252|
0000fc  6d60              LDR      r0,[r4,#0x54]         ;703
0000fe  b1a0              CBZ      r0,|L11.298|
000100  6d60              LDR      r0,[r4,#0x54]         ;705
000102  f0000001          AND      r0,r0,#1              ;705
000106  b180              CBZ      r0,|L11.298|
000108  4620              MOV      r0,r4                 ;707
00010a  f7fffffe          BL       HAL_DMA_Abort
00010e  f894105c          LDRB     r1,[r4,#0x5c]         ;710
000112  2030              MOVS     r0,#0x30              ;710
000114  4088              LSLS     r0,r0,r1              ;710
000116  60a8              STR      r0,[r5,#8]            ;710
000118  bf00              NOP                            ;713
00011a  2000              MOVS     r0,#0                 ;713
00011c  f8840034          STRB     r0,[r4,#0x34]         ;713
000120  bf00              NOP                            ;713
000122  2001              MOVS     r0,#1                 ;716
000124  f8840035          STRB     r0,[r4,#0x35]         ;716
000128  e780              B        |L11.44|
                  |L11.298|
00012a  f1b80f00          CMP      r8,#0                 ;723
00012e  d10d              BNE      |L11.332|
000130  f894105c          LDRB     r1,[r4,#0x5c]         ;726
000134  2030              MOVS     r0,#0x30              ;726
000136  4088              LSLS     r0,r0,r1              ;726
000138  60a8              STR      r0,[r5,#8]            ;726
00013a  bf00              NOP                            ;729
00013c  2000              MOVS     r0,#0                 ;729
00013e  f8840034          STRB     r0,[r4,#0x34]         ;729
000142  bf00              NOP                            ;729
000144  2001              MOVS     r0,#1                 ;731
000146  f8840035          STRB     r0,[r4,#0x35]         ;731
00014a  e004              B        |L11.342|
                  |L11.332|
00014c  f894105c          LDRB     r1,[r4,#0x5c]         ;736
000150  2010              MOVS     r0,#0x10              ;736
000152  4088              LSLS     r0,r0,r1              ;736
000154  60a8              STR      r0,[r5,#8]            ;736
                  |L11.342|
000156  4650              MOV      r0,r10                ;739
000158  e768              B        |L11.44|
;;;741    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;968      */                      
;;;969    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
000000  b510              PUSH     {r4,lr}
;;;970    {
000002  4603              MOV      r3,r0
;;;971    
;;;972      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;973    
;;;974      /* Process locked */
;;;975      __HAL_LOCK(hdma);
000006  bf00              NOP      
000008  f8930034          LDRB     r0,[r3,#0x34]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L12.20|
000010  2002              MOVS     r0,#2
                  |L12.18|
;;;976    
;;;977      if(HAL_DMA_STATE_READY == hdma->State)
;;;978      {
;;;979        switch (CallbackID)
;;;980        {
;;;981        case  HAL_DMA_XFER_CPLT_CB_ID:
;;;982          hdma->XferCpltCallback = pCallback;
;;;983          break;
;;;984    
;;;985        case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;986          hdma->XferHalfCpltCallback = pCallback;
;;;987          break;
;;;988    
;;;989        case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;990          hdma->XferM1CpltCallback = pCallback;
;;;991          break;
;;;992    
;;;993        case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;994          hdma->XferM1HalfCpltCallback = pCallback;
;;;995          break;
;;;996    
;;;997        case  HAL_DMA_XFER_ERROR_CB_ID:
;;;998          hdma->XferErrorCallback = pCallback;
;;;999          break;
;;;1000   
;;;1001       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1002         hdma->XferAbortCallback = pCallback;
;;;1003         break;
;;;1004   
;;;1005       default:
;;;1006         break;
;;;1007       }
;;;1008     }
;;;1009     else
;;;1010     {
;;;1011       /* Return error status */
;;;1012       status =  HAL_ERROR;
;;;1013     }
;;;1014   
;;;1015     /* Release Lock */
;;;1016     __HAL_UNLOCK(hdma);
;;;1017     
;;;1018     return status;
;;;1019   }
000012  bd10              POP      {r4,pc}
                  |L12.20|
000014  2001              MOVS     r0,#1                 ;975
000016  f8830034          STRB     r0,[r3,#0x34]         ;975
00001a  bf00              NOP                            ;975
00001c  f8930035          LDRB     r0,[r3,#0x35]         ;977
000020  2801              CMP      r0,#1                 ;977
000022  d114              BNE      |L12.78|
000024  2906              CMP      r1,#6                 ;979
000026  d210              BCS      |L12.74|
000028  e8dff001          TBB      [pc,r1]               ;979
00002c  03050709          DCB      0x03,0x05,0x07,0x09
000030  0b0d              DCB      0x0b,0x0d
000032  63da              STR      r2,[r3,#0x3c]         ;982
000034  e00a              B        |L12.76|
000036  641a              STR      r2,[r3,#0x40]         ;986
000038  e008              B        |L12.76|
00003a  645a              STR      r2,[r3,#0x44]         ;990
00003c  e006              B        |L12.76|
00003e  649a              STR      r2,[r3,#0x48]         ;994
000040  e004              B        |L12.76|
000042  64da              STR      r2,[r3,#0x4c]         ;998
000044  e002              B        |L12.76|
000046  651a              STR      r2,[r3,#0x50]         ;1002
000048  e000              B        |L12.76|
                  |L12.74|
00004a  bf00              NOP                            ;1006
                  |L12.76|
00004c  e000              B        |L12.80|
                  |L12.78|
00004e  2401              MOVS     r4,#1                 ;1012
                  |L12.80|
000050  bf00              NOP                            ;1016
000052  2000              MOVS     r0,#0                 ;1016
000054  f8830034          STRB     r0,[r3,#0x34]         ;1016
000058  bf00              NOP                            ;1016
00005a  4620              MOV      r0,r4                 ;1018
00005c  e7d9              B        |L12.18|
;;;1020   
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;407      */
;;;408    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;409    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;410      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;411      
;;;412      /* Check the parameters */
;;;413      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;414    
;;;415      /* Process locked */
;;;416      __HAL_LOCK(hdma);
000010  bf00              NOP      
000012  f8940034          LDRB     r0,[r4,#0x34]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L13.32|
00001a  2002              MOVS     r0,#2
                  |L13.28|
;;;417    
;;;418      if(HAL_DMA_STATE_READY == hdma->State)
;;;419      {
;;;420        /* Change DMA peripheral state */
;;;421        hdma->State = HAL_DMA_STATE_BUSY;
;;;422        
;;;423        /* Initialize the error code */
;;;424        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;425        
;;;426        /* Configure the source, destination address and the data length */
;;;427        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;428    
;;;429        /* Enable the Peripheral */
;;;430        __HAL_DMA_ENABLE(hdma);
;;;431      }
;;;432      else
;;;433      {
;;;434        /* Process unlocked */
;;;435        __HAL_UNLOCK(hdma);
;;;436        
;;;437        /* Return error status */
;;;438        status = HAL_BUSY;
;;;439      } 
;;;440      return status; 
;;;441    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.32|
000020  2001              MOVS     r0,#1                 ;416
000022  f8840034          STRB     r0,[r4,#0x34]         ;416
000026  bf00              NOP                            ;416
000028  f8940035          LDRB     r0,[r4,#0x35]         ;418
00002c  2801              CMP      r0,#1                 ;418
00002e  d111              BNE      |L13.84|
000030  2002              MOVS     r0,#2                 ;421
000032  f8840035          STRB     r0,[r4,#0x35]         ;421
000036  2000              MOVS     r0,#0                 ;424
000038  6560              STR      r0,[r4,#0x54]         ;424
00003a  463b              MOV      r3,r7                 ;427
00003c  4632              MOV      r2,r6                 ;427
00003e  4629              MOV      r1,r5                 ;427
000040  4620              MOV      r0,r4                 ;427
000042  f7fffffe          BL       DMA_SetConfig
000046  6820              LDR      r0,[r4,#0]            ;430
000048  6800              LDR      r0,[r0,#0]            ;430
00004a  f0400001          ORR      r0,r0,#1              ;430
00004e  6821              LDR      r1,[r4,#0]            ;430
000050  6008              STR      r0,[r1,#0]            ;430
000052  e006              B        |L13.98|
                  |L13.84|
000054  bf00              NOP                            ;435
000056  2000              MOVS     r0,#0                 ;435
000058  f8840034          STRB     r0,[r4,#0x34]         ;435
00005c  bf00              NOP                            ;435
00005e  f04f0802          MOV      r8,#2                 ;438
                  |L13.98|
000062  4640              MOV      r0,r8                 ;440
000064  e7da              B        |L13.28|
;;;442    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;451      */
;;;452    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;453    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;454      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;455    
;;;456      /* calculate DMA base and stream number */
;;;457      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000010  f8d49058          LDR      r9,[r4,#0x58]
;;;458      
;;;459      /* Check the parameters */
;;;460      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;461     
;;;462      /* Process locked */
;;;463      __HAL_LOCK(hdma);
000014  bf00              NOP      
000016  f8940034          LDRB     r0,[r4,#0x34]
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L14.36|
00001e  2002              MOVS     r0,#2
                  |L14.32|
;;;464      
;;;465      if(HAL_DMA_STATE_READY == hdma->State)
;;;466      {
;;;467        /* Change DMA peripheral state */
;;;468        hdma->State = HAL_DMA_STATE_BUSY;
;;;469        
;;;470        /* Initialize the error code */
;;;471        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;472        
;;;473        /* Configure the source, destination address and the data length */
;;;474        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;475        
;;;476        /* Clear all interrupt flags at correct offset within the register */
;;;477        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;478        
;;;479        /* Enable Common interrupts*/
;;;480        hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
;;;481        hdma->Instance->FCR |= DMA_IT_FE;
;;;482        
;;;483        if(hdma->XferHalfCpltCallback != NULL)
;;;484        {
;;;485          hdma->Instance->CR  |= DMA_IT_HT;
;;;486        }
;;;487        
;;;488        /* Enable the Peripheral */
;;;489        __HAL_DMA_ENABLE(hdma);
;;;490      }
;;;491      else
;;;492      {
;;;493        /* Process unlocked */
;;;494        __HAL_UNLOCK(hdma);	  
;;;495        
;;;496        /* Return error status */
;;;497        status = HAL_BUSY;
;;;498      }
;;;499      
;;;500      return status;
;;;501    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L14.36|
000024  2001              MOVS     r0,#1                 ;463
000026  f8840034          STRB     r0,[r4,#0x34]         ;463
00002a  bf00              NOP                            ;463
00002c  f8940035          LDRB     r0,[r4,#0x35]         ;465
000030  2801              CMP      r0,#1                 ;465
000032  d12b              BNE      |L14.140|
000034  2002              MOVS     r0,#2                 ;468
000036  f8840035          STRB     r0,[r4,#0x35]         ;468
00003a  2000              MOVS     r0,#0                 ;471
00003c  6560              STR      r0,[r4,#0x54]         ;471
00003e  463b              MOV      r3,r7                 ;474
000040  4632              MOV      r2,r6                 ;474
000042  4629              MOV      r1,r5                 ;474
000044  4620              MOV      r0,r4                 ;474
000046  f7fffffe          BL       DMA_SetConfig
00004a  f894105c          LDRB     r1,[r4,#0x5c]         ;477
00004e  203f              MOVS     r0,#0x3f              ;477
000050  4088              LSLS     r0,r0,r1              ;477
000052  f8c90008          STR      r0,[r9,#8]            ;477
000056  6820              LDR      r0,[r4,#0]            ;480
000058  6800              LDR      r0,[r0,#0]            ;480
00005a  f0400016          ORR      r0,r0,#0x16           ;480
00005e  6821              LDR      r1,[r4,#0]            ;480
000060  6008              STR      r0,[r1,#0]            ;480
000062  6820              LDR      r0,[r4,#0]            ;481
000064  6940              LDR      r0,[r0,#0x14]         ;481
000066  f0400080          ORR      r0,r0,#0x80           ;481
00006a  6821              LDR      r1,[r4,#0]            ;481
00006c  6148              STR      r0,[r1,#0x14]         ;481
00006e  6c20              LDR      r0,[r4,#0x40]         ;483
000070  b128              CBZ      r0,|L14.126|
000072  6820              LDR      r0,[r4,#0]            ;485
000074  6800              LDR      r0,[r0,#0]            ;485
000076  f0400008          ORR      r0,r0,#8              ;485
00007a  6821              LDR      r1,[r4,#0]            ;485
00007c  6008              STR      r0,[r1,#0]            ;485
                  |L14.126|
00007e  6820              LDR      r0,[r4,#0]            ;489
000080  6800              LDR      r0,[r0,#0]            ;489
000082  f0400001          ORR      r0,r0,#1              ;489
000086  6821              LDR      r1,[r4,#0]            ;489
000088  6008              STR      r0,[r1,#0]            ;489
00008a  e006              B        |L14.154|
                  |L14.140|
00008c  bf00              NOP                            ;494
00008e  2000              MOVS     r0,#0                 ;494
000090  f8840034          STRB     r0,[r4,#0x34]         ;494
000094  bf00              NOP                            ;494
000096  f04f0802          MOV      r8,#2                 ;497
                  |L14.154|
00009a  4640              MOV      r0,r8                 ;500
00009c  e7c0              B        |L14.32|
;;;502    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;1028     */              
;;;1029   HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  4602              MOV      r2,r0
;;;1030   {
;;;1031     HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1032     
;;;1033     /* Process locked */
;;;1034     __HAL_LOCK(hdma);
000004  bf00              NOP      
000006  f8920034          LDRB     r0,[r2,#0x34]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L15.18|
00000e  2002              MOVS     r0,#2
                  |L15.16|
;;;1035     
;;;1036     if(HAL_DMA_STATE_READY == hdma->State)
;;;1037     {
;;;1038       switch (CallbackID)
;;;1039       {
;;;1040       case  HAL_DMA_XFER_CPLT_CB_ID:
;;;1041         hdma->XferCpltCallback = NULL;
;;;1042         break;
;;;1043         
;;;1044       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1045         hdma->XferHalfCpltCallback = NULL;
;;;1046         break;
;;;1047         
;;;1048       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1049         hdma->XferM1CpltCallback = NULL;
;;;1050         break;
;;;1051         
;;;1052       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1053         hdma->XferM1HalfCpltCallback = NULL;
;;;1054         break;
;;;1055         
;;;1056       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1057         hdma->XferErrorCallback = NULL;
;;;1058         break;
;;;1059         
;;;1060       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1061         hdma->XferAbortCallback = NULL;
;;;1062         break; 
;;;1063         
;;;1064       case   HAL_DMA_XFER_ALL_CB_ID:
;;;1065         hdma->XferCpltCallback = NULL;
;;;1066         hdma->XferHalfCpltCallback = NULL;
;;;1067         hdma->XferM1CpltCallback = NULL;
;;;1068         hdma->XferM1HalfCpltCallback = NULL;
;;;1069         hdma->XferErrorCallback = NULL;
;;;1070         hdma->XferAbortCallback = NULL;
;;;1071         break; 
;;;1072         
;;;1073       default:
;;;1074         status = HAL_ERROR;
;;;1075         break;
;;;1076       }
;;;1077     }
;;;1078     else
;;;1079     {
;;;1080       status = HAL_ERROR;
;;;1081     }
;;;1082     
;;;1083     /* Release Lock */
;;;1084     __HAL_UNLOCK(hdma);
;;;1085     
;;;1086     return status;
;;;1087   }
000010  4770              BX       lr
                  |L15.18|
000012  2001              MOVS     r0,#1                 ;1034
000014  f8820034          STRB     r0,[r2,#0x34]         ;1034
000018  bf00              NOP                            ;1034
00001a  f8920035          LDRB     r0,[r2,#0x35]         ;1036
00001e  2801              CMP      r0,#1                 ;1036
000020  d124              BNE      |L15.108|
000022  2907              CMP      r1,#7                 ;1038
000024  d21f              BCS      |L15.102|
000026  e8dff001          TBB      [pc,r1]               ;1038
00002a  0407              DCB      0x04,0x07
00002c  0a0d1013          DCB      0x0a,0x0d,0x10,0x13
000030  1600              DCB      0x16,0x00
000032  2000              MOVS     r0,#0                 ;1041
000034  63d0              STR      r0,[r2,#0x3c]         ;1041
000036  e018              B        |L15.106|
000038  2000              MOVS     r0,#0                 ;1045
00003a  6410              STR      r0,[r2,#0x40]         ;1045
00003c  e015              B        |L15.106|
00003e  2000              MOVS     r0,#0                 ;1049
000040  6450              STR      r0,[r2,#0x44]         ;1049
000042  e012              B        |L15.106|
000044  2000              MOVS     r0,#0                 ;1053
000046  6490              STR      r0,[r2,#0x48]         ;1053
000048  e00f              B        |L15.106|
00004a  2000              MOVS     r0,#0                 ;1057
00004c  64d0              STR      r0,[r2,#0x4c]         ;1057
00004e  e00c              B        |L15.106|
000050  2000              MOVS     r0,#0                 ;1061
000052  6510              STR      r0,[r2,#0x50]         ;1061
000054  e009              B        |L15.106|
000056  2000              MOVS     r0,#0                 ;1065
000058  63d0              STR      r0,[r2,#0x3c]         ;1065
00005a  6410              STR      r0,[r2,#0x40]         ;1066
00005c  6450              STR      r0,[r2,#0x44]         ;1067
00005e  6490              STR      r0,[r2,#0x48]         ;1068
000060  64d0              STR      r0,[r2,#0x4c]         ;1069
000062  6510              STR      r0,[r2,#0x50]         ;1070
000064  e001              B        |L15.106|
                  |L15.102|
000066  2301              MOVS     r3,#1                 ;1074
000068  bf00              NOP                            ;1075
                  |L15.106|
00006a  e000              B        |L15.110|
                  |L15.108|
00006c  2301              MOVS     r3,#1                 ;1080
                  |L15.110|
00006e  bf00              NOP                            ;1084
000070  2000              MOVS     r0,#0                 ;1084
000072  f8820034          STRB     r0,[r2,#0x34]         ;1084
000076  bf00              NOP                            ;1084
000078  4618              MOV      r0,r3                 ;1086
00007a  e7c9              B        |L15.16|
;;;1088   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____RRX|
#line 587
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
