; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_spi.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_spi.c]
                          THUMB

                          AREA ||i.HAL_SPI_Abort||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort PROC
;;;1939   */
;;;1940   HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
000000  b53e              PUSH     {r1-r5,lr}
;;;1941   {
000002  4604              MOV      r4,r0
;;;1942     HAL_StatusTypeDef errorcode;
;;;1943     __IO uint32_t count, resetcount;
;;;1944   
;;;1945     /* Initialized local variable  */
;;;1946     errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1947     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000006  4857              LDR      r0,|L1.356|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  2118              MOVS     r1,#0x18
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  f44f717a          MOV      r1,#0x3e8
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  2164              MOVS     r1,#0x64
00001a  4348              MULS     r0,r1,r0
00001c  9001              STR      r0,[sp,#4]
;;;1948     count = resetcount;
00001e  9801              LDR      r0,[sp,#4]
000020  9002              STR      r0,[sp,#8]
;;;1949   
;;;1950     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;1951     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
000022  6820              LDR      r0,[r4,#0]
000024  6840              LDR      r0,[r0,#4]
000026  f0200020          BIC      r0,r0,#0x20
00002a  6821              LDR      r1,[r4,#0]
00002c  6048              STR      r0,[r1,#4]
;;;1952   
;;;1953     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;1954     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
00002e  6820              LDR      r0,[r4,#0]
000030  6840              LDR      r0,[r0,#4]
000032  f0000080          AND      r0,r0,#0x80
000036  2880              CMP      r0,#0x80
000038  d113              BNE      |L1.98|
;;;1955     {
;;;1956       hspi->TxISR = SPI_AbortTx_ISR;
00003a  484b              LDR      r0,|L1.360|
00003c  6460              STR      r0,[r4,#0x44]
;;;1957       /* Wait HAL_SPI_STATE_ABORT state */
;;;1958       do
00003e  bf00              NOP      
                  |L1.64|
;;;1959       {
;;;1960         if (count == 0U)
000040  9802              LDR      r0,[sp,#8]
000042  b920              CBNZ     r0,|L1.78|
;;;1961         {
;;;1962           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000044  6d60              LDR      r0,[r4,#0x54]
000046  f0400040          ORR      r0,r0,#0x40
00004a  6560              STR      r0,[r4,#0x54]
;;;1963           break;
00004c  e006              B        |L1.92|
                  |L1.78|
;;;1964         }
;;;1965         count--;
00004e  9802              LDR      r0,[sp,#8]
000050  1e40              SUBS     r0,r0,#1
000052  9002              STR      r0,[sp,#8]
;;;1966       }
;;;1967       while (hspi->State != HAL_SPI_STATE_ABORT);
000054  f8940051          LDRB     r0,[r4,#0x51]
000058  2807              CMP      r0,#7
00005a  d1f1              BNE      |L1.64|
                  |L1.92|
00005c  bf00              NOP                            ;1963
;;;1968       /* Reset Timeout Counter */
;;;1969       count = resetcount;
00005e  9801              LDR      r0,[sp,#4]
000060  9002              STR      r0,[sp,#8]
                  |L1.98|
;;;1970     }
;;;1971   
;;;1972     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
000062  6820              LDR      r0,[r4,#0]
000064  6840              LDR      r0,[r0,#4]
000066  f0000040          AND      r0,r0,#0x40
00006a  2840              CMP      r0,#0x40
00006c  d113              BNE      |L1.150|
;;;1973     {
;;;1974       hspi->RxISR = SPI_AbortRx_ISR;
00006e  483f              LDR      r0,|L1.364|
000070  6420              STR      r0,[r4,#0x40]
;;;1975       /* Wait HAL_SPI_STATE_ABORT state */
;;;1976       do
000072  bf00              NOP      
                  |L1.116|
;;;1977       {
;;;1978         if (count == 0U)
000074  9802              LDR      r0,[sp,#8]
000076  b920              CBNZ     r0,|L1.130|
;;;1979         {
;;;1980           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000078  6d60              LDR      r0,[r4,#0x54]
00007a  f0400040          ORR      r0,r0,#0x40
00007e  6560              STR      r0,[r4,#0x54]
;;;1981           break;
000080  e006              B        |L1.144|
                  |L1.130|
;;;1982         }
;;;1983         count--;
000082  9802              LDR      r0,[sp,#8]
000084  1e40              SUBS     r0,r0,#1
000086  9002              STR      r0,[sp,#8]
;;;1984       }
;;;1985       while (hspi->State != HAL_SPI_STATE_ABORT);
000088  f8940051          LDRB     r0,[r4,#0x51]
00008c  2807              CMP      r0,#7
00008e  d1f1              BNE      |L1.116|
                  |L1.144|
000090  bf00              NOP                            ;1981
;;;1986       /* Reset Timeout Counter */
;;;1987       count = resetcount;
000092  9801              LDR      r0,[sp,#4]
000094  9002              STR      r0,[sp,#8]
                  |L1.150|
;;;1988     }
;;;1989   
;;;1990     /* Disable the SPI DMA Tx request if enabled */
;;;1991     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
000096  6820              LDR      r0,[r4,#0]
000098  6840              LDR      r0,[r0,#4]
00009a  f0000002          AND      r0,r0,#2
00009e  2802              CMP      r0,#2
0000a0  d122              BNE      |L1.232|
;;;1992     {
;;;1993       /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;1994       if (hspi->hdmatx != NULL)
0000a2  6ca0              LDR      r0,[r4,#0x48]
0000a4  b300              CBZ      r0,|L1.232|
;;;1995       {
;;;1996         /* Set the SPI DMA Abort callback :
;;;1997         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;1998         hspi->hdmatx->XferAbortCallback = NULL;
0000a6  2000              MOVS     r0,#0
0000a8  6ca1              LDR      r1,[r4,#0x48]
0000aa  6508              STR      r0,[r1,#0x50]
;;;1999   
;;;2000         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2001         if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)
0000ac  6ca0              LDR      r0,[r4,#0x48]
0000ae  f7fffffe          BL       HAL_DMA_Abort
0000b2  b108              CBZ      r0,|L1.184|
;;;2002         {
;;;2003           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000b4  2040              MOVS     r0,#0x40
0000b6  6560              STR      r0,[r4,#0x54]
                  |L1.184|
;;;2004         }
;;;2005   
;;;2006         /* Disable Tx DMA Request */
;;;2007         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6840              LDR      r0,[r0,#4]
0000bc  f0200002          BIC      r0,r0,#2
0000c0  6821              LDR      r1,[r4,#0]
0000c2  6048              STR      r0,[r1,#4]
;;;2008   
;;;2009         /* Wait until TXE flag is set */
;;;2010         do
0000c4  bf00              NOP      
                  |L1.198|
;;;2011         {
;;;2012           if (count == 0U)
0000c6  9802              LDR      r0,[sp,#8]
0000c8  b920              CBNZ     r0,|L1.212|
;;;2013           {
;;;2014             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
0000ca  6d60              LDR      r0,[r4,#0x54]
0000cc  f0400040          ORR      r0,r0,#0x40
0000d0  6560              STR      r0,[r4,#0x54]
;;;2015             break;
0000d2  e008              B        |L1.230|
                  |L1.212|
;;;2016           }
;;;2017           count--;
0000d4  9802              LDR      r0,[sp,#8]
0000d6  1e40              SUBS     r0,r0,#1
0000d8  9002              STR      r0,[sp,#8]
;;;2018         }
;;;2019         while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
0000da  6820              LDR      r0,[r4,#0]
0000dc  6880              LDR      r0,[r0,#8]
0000de  f0000002          AND      r0,r0,#2
0000e2  2800              CMP      r0,#0
0000e4  d0ef              BEQ      |L1.198|
                  |L1.230|
0000e6  bf00              NOP                            ;2015
                  |L1.232|
;;;2020       }
;;;2021     }
;;;2022   
;;;2023     /* Disable the SPI DMA Rx request if enabled */
;;;2024     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6840              LDR      r0,[r0,#4]
0000ec  f0000001          AND      r0,r0,#1
0000f0  b1b0              CBZ      r0,|L1.288|
;;;2025     {
;;;2026       /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2027       if (hspi->hdmarx != NULL)
0000f2  6ce0              LDR      r0,[r4,#0x4c]
0000f4  b1a0              CBZ      r0,|L1.288|
;;;2028       {
;;;2029         /* Set the SPI DMA Abort callback :
;;;2030         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2031         hspi->hdmarx->XferAbortCallback = NULL;
0000f6  2000              MOVS     r0,#0
0000f8  6ce1              LDR      r1,[r4,#0x4c]
0000fa  6508              STR      r0,[r1,#0x50]
;;;2032   
;;;2033         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2034         if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)
0000fc  6ce0              LDR      r0,[r4,#0x4c]
0000fe  f7fffffe          BL       HAL_DMA_Abort
000102  b108              CBZ      r0,|L1.264|
;;;2035         {
;;;2036           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000104  2040              MOVS     r0,#0x40
000106  6560              STR      r0,[r4,#0x54]
                  |L1.264|
;;;2037         }
;;;2038   
;;;2039         /* Disable peripheral */
;;;2040         __HAL_SPI_DISABLE(hspi);
000108  6820              LDR      r0,[r4,#0]
00010a  6800              LDR      r0,[r0,#0]
00010c  f0200040          BIC      r0,r0,#0x40
000110  6821              LDR      r1,[r4,#0]
000112  6008              STR      r0,[r1,#0]
;;;2041   
;;;2042         /* Disable Rx DMA Request */
;;;2043         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
000114  6820              LDR      r0,[r4,#0]
000116  6840              LDR      r0,[r0,#4]
000118  f0200001          BIC      r0,r0,#1
00011c  6821              LDR      r1,[r4,#0]
00011e  6048              STR      r0,[r1,#4]
                  |L1.288|
;;;2044       }
;;;2045     }
;;;2046     /* Reset Tx and Rx transfer counters */
;;;2047     hspi->RxXferCount = 0U;
000120  2000              MOVS     r0,#0
000122  87e0              STRH     r0,[r4,#0x3e]
;;;2048     hspi->TxXferCount = 0U;
000124  86e0              STRH     r0,[r4,#0x36]
;;;2049   
;;;2050     /* Check error during Abort procedure */
;;;2051     if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
000126  6d60              LDR      r0,[r4,#0x54]
000128  2840              CMP      r0,#0x40
00012a  d101              BNE      |L1.304|
;;;2052     {
;;;2053       /* return HAL_Error in case of error during Abort procedure */
;;;2054       errorcode = HAL_ERROR;
00012c  2501              MOVS     r5,#1
00012e  e001              B        |L1.308|
                  |L1.304|
;;;2055     }
;;;2056     else
;;;2057     {
;;;2058       /* Reset errorCode */
;;;2059       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
000130  2000              MOVS     r0,#0
000132  6560              STR      r0,[r4,#0x54]
                  |L1.308|
;;;2060     }
;;;2061   
;;;2062     /* Clear the Error flags in the SR register */
;;;2063     __HAL_SPI_CLEAR_OVRFLAG(hspi);
000134  bf00              NOP      
000136  2000              MOVS     r0,#0
000138  9000              STR      r0,[sp,#0]
00013a  6820              LDR      r0,[r4,#0]
00013c  68c0              LDR      r0,[r0,#0xc]
00013e  9000              STR      r0,[sp,#0]
000140  6820              LDR      r0,[r4,#0]
000142  6880              LDR      r0,[r0,#8]
000144  9000              STR      r0,[sp,#0]
000146  bf00              NOP      
000148  bf00              NOP      
;;;2064     __HAL_SPI_CLEAR_FREFLAG(hspi);
00014a  bf00              NOP      
00014c  2000              MOVS     r0,#0
00014e  9000              STR      r0,[sp,#0]
000150  6820              LDR      r0,[r4,#0]
000152  6880              LDR      r0,[r0,#8]
000154  9000              STR      r0,[sp,#0]
000156  bf00              NOP      
000158  bf00              NOP      
;;;2065   
;;;2066     /* Restore hspi->state to ready */
;;;2067     hspi->State = HAL_SPI_STATE_READY;
00015a  2001              MOVS     r0,#1
00015c  f8840051          STRB     r0,[r4,#0x51]
;;;2068   
;;;2069     return errorcode;
000160  4628              MOV      r0,r5
;;;2070   }
000162  bd3e              POP      {r1-r5,pc}
;;;2071   
                          ENDP

                  |L1.356|
                          DCD      SystemCoreClock
                  |L1.360|
                          DCD      SPI_AbortTx_ISR
                  |L1.364|
                          DCD      SPI_AbortRx_ISR

                          AREA ||i.HAL_SPI_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_AbortCpltCallback PROC
;;;2548     */
;;;2549   __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2550   {
;;;2551     /* Prevent unused argument(s) compilation warning */
;;;2552     UNUSED(hspi);
;;;2553   
;;;2554     /* NOTE : This function should not be modified, when the callback is needed,
;;;2555               the HAL_SPI_AbortCpltCallback can be implemented in the user file.
;;;2556      */
;;;2557   }
;;;2558   
                          ENDP


                          AREA ||i.HAL_SPI_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort_IT PROC
;;;2086   */
;;;2087   HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2088   {
000002  4604              MOV      r4,r0
;;;2089     HAL_StatusTypeDef errorcode;
;;;2090     uint32_t abortcplt ;
;;;2091     __IO uint32_t count, resetcount;
;;;2092   
;;;2093     /* Initialized local variable  */
;;;2094     errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2095     abortcplt = 1U;
000006  2601              MOVS     r6,#1
;;;2096     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000008  4858              LDR      r0,|L3.364|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  2118              MOVS     r1,#0x18
00000e  fbb0f0f1          UDIV     r0,r0,r1
000012  f44f717a          MOV      r1,#0x3e8
000016  fbb0f0f1          UDIV     r0,r0,r1
00001a  2164              MOVS     r1,#0x64
00001c  4348              MULS     r0,r1,r0
00001e  9001              STR      r0,[sp,#4]
;;;2097     count = resetcount;
000020  9801              LDR      r0,[sp,#4]
000022  9002              STR      r0,[sp,#8]
;;;2098   
;;;2099     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2100     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  f0200020          BIC      r0,r0,#0x20
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;2101   
;;;2102     /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
;;;2103     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
000030  6820              LDR      r0,[r4,#0]
000032  6840              LDR      r0,[r0,#4]
000034  f0000080          AND      r0,r0,#0x80
000038  2880              CMP      r0,#0x80
00003a  d113              BNE      |L3.100|
;;;2104     {
;;;2105       hspi->TxISR = SPI_AbortTx_ISR;
00003c  484c              LDR      r0,|L3.368|
00003e  6460              STR      r0,[r4,#0x44]
;;;2106       /* Wait HAL_SPI_STATE_ABORT state */
;;;2107       do
000040  bf00              NOP      
                  |L3.66|
;;;2108       {
;;;2109         if (count == 0U)
000042  9802              LDR      r0,[sp,#8]
000044  b920              CBNZ     r0,|L3.80|
;;;2110         {
;;;2111           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000046  6d60              LDR      r0,[r4,#0x54]
000048  f0400040          ORR      r0,r0,#0x40
00004c  6560              STR      r0,[r4,#0x54]
;;;2112           break;
00004e  e006              B        |L3.94|
                  |L3.80|
;;;2113         }
;;;2114         count--;
000050  9802              LDR      r0,[sp,#8]
000052  1e40              SUBS     r0,r0,#1
000054  9002              STR      r0,[sp,#8]
;;;2115       }
;;;2116       while (hspi->State != HAL_SPI_STATE_ABORT);
000056  f8940051          LDRB     r0,[r4,#0x51]
00005a  2807              CMP      r0,#7
00005c  d1f1              BNE      |L3.66|
                  |L3.94|
00005e  bf00              NOP                            ;2112
;;;2117       /* Reset Timeout Counter */
;;;2118       count = resetcount;
000060  9801              LDR      r0,[sp,#4]
000062  9002              STR      r0,[sp,#8]
                  |L3.100|
;;;2119     }
;;;2120   
;;;2121     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
000064  6820              LDR      r0,[r4,#0]
000066  6840              LDR      r0,[r0,#4]
000068  f0000040          AND      r0,r0,#0x40
00006c  2840              CMP      r0,#0x40
00006e  d113              BNE      |L3.152|
;;;2122     {
;;;2123       hspi->RxISR = SPI_AbortRx_ISR;
000070  4840              LDR      r0,|L3.372|
000072  6420              STR      r0,[r4,#0x40]
;;;2124       /* Wait HAL_SPI_STATE_ABORT state */
;;;2125       do
000074  bf00              NOP      
                  |L3.118|
;;;2126       {
;;;2127         if (count == 0U)
000076  9802              LDR      r0,[sp,#8]
000078  b920              CBNZ     r0,|L3.132|
;;;2128         {
;;;2129           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
00007a  6d60              LDR      r0,[r4,#0x54]
00007c  f0400040          ORR      r0,r0,#0x40
000080  6560              STR      r0,[r4,#0x54]
;;;2130           break;
000082  e006              B        |L3.146|
                  |L3.132|
;;;2131         }
;;;2132         count--;
000084  9802              LDR      r0,[sp,#8]
000086  1e40              SUBS     r0,r0,#1
000088  9002              STR      r0,[sp,#8]
;;;2133       }
;;;2134       while (hspi->State != HAL_SPI_STATE_ABORT);
00008a  f8940051          LDRB     r0,[r4,#0x51]
00008e  2807              CMP      r0,#7
000090  d1f1              BNE      |L3.118|
                  |L3.146|
000092  bf00              NOP                            ;2130
;;;2135       /* Reset Timeout Counter */
;;;2136       count = resetcount;
000094  9801              LDR      r0,[sp,#4]
000096  9002              STR      r0,[sp,#8]
                  |L3.152|
;;;2137     }
;;;2138   
;;;2139     /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
;;;2140        before any call to DMA Abort functions */
;;;2141     /* DMA Tx Handle is valid */
;;;2142     if (hspi->hdmatx != NULL)
000098  6ca0              LDR      r0,[r4,#0x48]
00009a  b160              CBZ      r0,|L3.182|
;;;2143     {
;;;2144       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;2145          Otherwise, set it to NULL */
;;;2146       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
00009c  6820              LDR      r0,[r4,#0]
00009e  6840              LDR      r0,[r0,#4]
0000a0  f0000002          AND      r0,r0,#2
0000a4  2802              CMP      r0,#2
0000a6  d103              BNE      |L3.176|
;;;2147       {
;;;2148         hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
0000a8  4833              LDR      r0,|L3.376|
0000aa  6ca1              LDR      r1,[r4,#0x48]
0000ac  6508              STR      r0,[r1,#0x50]
0000ae  e002              B        |L3.182|
                  |L3.176|
;;;2149       }
;;;2150       else
;;;2151       {
;;;2152         hspi->hdmatx->XferAbortCallback = NULL;
0000b0  2000              MOVS     r0,#0
0000b2  6ca1              LDR      r1,[r4,#0x48]
0000b4  6508              STR      r0,[r1,#0x50]
                  |L3.182|
;;;2153       }
;;;2154     }
;;;2155     /* DMA Rx Handle is valid */
;;;2156     if (hspi->hdmarx != NULL)
0000b6  6ce0              LDR      r0,[r4,#0x4c]
0000b8  b158              CBZ      r0,|L3.210|
;;;2157     {
;;;2158       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;2159          Otherwise, set it to NULL */
;;;2160       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6840              LDR      r0,[r0,#4]
0000be  f0000001          AND      r0,r0,#1
0000c2  b118              CBZ      r0,|L3.204|
;;;2161       {
;;;2162         hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
0000c4  482d              LDR      r0,|L3.380|
0000c6  6ce1              LDR      r1,[r4,#0x4c]
0000c8  6508              STR      r0,[r1,#0x50]
0000ca  e002              B        |L3.210|
                  |L3.204|
;;;2163       }
;;;2164       else
;;;2165       {
;;;2166         hspi->hdmarx->XferAbortCallback = NULL;
0000cc  2000              MOVS     r0,#0
0000ce  6ce1              LDR      r1,[r4,#0x4c]
0000d0  6508              STR      r0,[r1,#0x50]
                  |L3.210|
;;;2167       }
;;;2168     }
;;;2169   
;;;2170     /* Disable the SPI DMA Tx request if enabled */
;;;2171     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
0000d2  6820              LDR      r0,[r4,#0]
0000d4  6840              LDR      r0,[r0,#4]
0000d6  f0000002          AND      r0,r0,#2
0000da  2802              CMP      r0,#2
0000dc  d10c              BNE      |L3.248|
;;;2172     {
;;;2173       /* Abort the SPI DMA Tx Stream/Channel */
;;;2174       if (hspi->hdmatx != NULL)
0000de  6ca0              LDR      r0,[r4,#0x48]
0000e0  b150              CBZ      r0,|L3.248|
;;;2175       {
;;;2176         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2177         if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
0000e2  6ca0              LDR      r0,[r4,#0x48]
0000e4  f7fffffe          BL       HAL_DMA_Abort_IT
0000e8  b128              CBZ      r0,|L3.246|
;;;2178         {
;;;2179           hspi->hdmatx->XferAbortCallback = NULL;
0000ea  2000              MOVS     r0,#0
0000ec  6ca1              LDR      r1,[r4,#0x48]
0000ee  6508              STR      r0,[r1,#0x50]
;;;2180           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000f0  2040              MOVS     r0,#0x40
0000f2  6560              STR      r0,[r4,#0x54]
0000f4  e000              B        |L3.248|
                  |L3.246|
;;;2181         }
;;;2182         else
;;;2183         {
;;;2184           abortcplt = 0U;
0000f6  2600              MOVS     r6,#0
                  |L3.248|
;;;2185         }
;;;2186       }
;;;2187     }
;;;2188     /* Disable the SPI DMA Rx request if enabled */
;;;2189     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000f8  6820              LDR      r0,[r4,#0]
0000fa  6840              LDR      r0,[r0,#4]
0000fc  f0000001          AND      r0,r0,#1
000100  b160              CBZ      r0,|L3.284|
;;;2190     {
;;;2191       /* Abort the SPI DMA Rx Stream/Channel */
;;;2192       if (hspi->hdmarx != NULL)
000102  6ce0              LDR      r0,[r4,#0x4c]
000104  b150              CBZ      r0,|L3.284|
;;;2193       {
;;;2194         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2195         if (HAL_DMA_Abort_IT(hspi->hdmarx) !=  HAL_OK)
000106  6ce0              LDR      r0,[r4,#0x4c]
000108  f7fffffe          BL       HAL_DMA_Abort_IT
00010c  b128              CBZ      r0,|L3.282|
;;;2196         {
;;;2197           hspi->hdmarx->XferAbortCallback = NULL;
00010e  2000              MOVS     r0,#0
000110  6ce1              LDR      r1,[r4,#0x4c]
000112  6508              STR      r0,[r1,#0x50]
;;;2198           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
000114  2040              MOVS     r0,#0x40
000116  6560              STR      r0,[r4,#0x54]
000118  e000              B        |L3.284|
                  |L3.282|
;;;2199         }
;;;2200         else
;;;2201         {
;;;2202           abortcplt = 0U;
00011a  2600              MOVS     r6,#0
                  |L3.284|
;;;2203         }
;;;2204       }
;;;2205     }
;;;2206   
;;;2207     if (abortcplt == 1U)
00011c  2e01              CMP      r6,#1
00011e  d122              BNE      |L3.358|
;;;2208     {
;;;2209       /* Reset Tx and Rx transfer counters */
;;;2210       hspi->RxXferCount = 0U;
000120  2000              MOVS     r0,#0
000122  87e0              STRH     r0,[r4,#0x3e]
;;;2211       hspi->TxXferCount = 0U;
000124  86e0              STRH     r0,[r4,#0x36]
;;;2212   
;;;2213       /* Check error during Abort procedure */
;;;2214       if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
000126  6d60              LDR      r0,[r4,#0x54]
000128  2840              CMP      r0,#0x40
00012a  d101              BNE      |L3.304|
;;;2215       {
;;;2216         /* return HAL_Error in case of error during Abort procedure */
;;;2217         errorcode = HAL_ERROR;
00012c  2501              MOVS     r5,#1
00012e  e001              B        |L3.308|
                  |L3.304|
;;;2218       }
;;;2219       else
;;;2220       {
;;;2221         /* Reset errorCode */
;;;2222         hspi->ErrorCode = HAL_SPI_ERROR_NONE;
000130  2000              MOVS     r0,#0
000132  6560              STR      r0,[r4,#0x54]
                  |L3.308|
;;;2223       }
;;;2224   
;;;2225       /* Clear the Error flags in the SR register */
;;;2226       __HAL_SPI_CLEAR_OVRFLAG(hspi);
000134  bf00              NOP      
000136  2000              MOVS     r0,#0
000138  9000              STR      r0,[sp,#0]
00013a  6820              LDR      r0,[r4,#0]
00013c  68c0              LDR      r0,[r0,#0xc]
00013e  9000              STR      r0,[sp,#0]
000140  6820              LDR      r0,[r4,#0]
000142  6880              LDR      r0,[r0,#8]
000144  9000              STR      r0,[sp,#0]
000146  bf00              NOP      
000148  bf00              NOP      
;;;2227       __HAL_SPI_CLEAR_FREFLAG(hspi);
00014a  bf00              NOP      
00014c  2000              MOVS     r0,#0
00014e  9000              STR      r0,[sp,#0]
000150  6820              LDR      r0,[r4,#0]
000152  6880              LDR      r0,[r0,#8]
000154  9000              STR      r0,[sp,#0]
000156  bf00              NOP      
000158  bf00              NOP      
;;;2228   
;;;2229       /* Restore hspi->State to Ready */
;;;2230       hspi->State = HAL_SPI_STATE_READY;
00015a  2001              MOVS     r0,#1
00015c  f8840051          STRB     r0,[r4,#0x51]
;;;2231   
;;;2232       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2233   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2234       hspi->AbortCpltCallback(hspi);
;;;2235   #else
;;;2236       HAL_SPI_AbortCpltCallback(hspi);
000160  4620              MOV      r0,r4
000162  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L3.358|
;;;2237   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2238     }
;;;2239   
;;;2240     return errorcode;
000166  4628              MOV      r0,r5
;;;2241   }
000168  bdfe              POP      {r1-r7,pc}
;;;2242   
                          ENDP

00016a  0000              DCW      0x0000
                  |L3.364|
                          DCD      SystemCoreClock
                  |L3.368|
                          DCD      SPI_AbortTx_ISR
                  |L3.372|
                          DCD      SPI_AbortRx_ISR
                  |L3.376|
                          DCD      SPI_DMATxAbortCallback
                  |L3.380|
                          DCD      SPI_DMARxAbortCallback

                          AREA ||i.HAL_SPI_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAPause PROC
;;;2248     */
;;;2249   HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2250   {
;;;2251     /* Process Locked */
;;;2252     __HAL_LOCK(hspi);
000002  bf00              NOP      
000004  f8910050          LDRB     r0,[r1,#0x50]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L4.16|
00000c  2002              MOVS     r0,#2
                  |L4.14|
;;;2253   
;;;2254     /* Disable the SPI DMA Tx & Rx requests */
;;;2255     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
;;;2256   
;;;2257     /* Process Unlocked */
;;;2258     __HAL_UNLOCK(hspi);
;;;2259   
;;;2260     return HAL_OK;
;;;2261   }
00000e  4770              BX       lr
                  |L4.16|
000010  2001              MOVS     r0,#1                 ;2252
000012  f8810050          STRB     r0,[r1,#0x50]         ;2252
000016  bf00              NOP                            ;2252
000018  6808              LDR      r0,[r1,#0]            ;2255
00001a  6840              LDR      r0,[r0,#4]            ;2255
00001c  f0200003          BIC      r0,r0,#3              ;2255
000020  680a              LDR      r2,[r1,#0]            ;2255
000022  6050              STR      r0,[r2,#4]            ;2255
000024  bf00              NOP                            ;2258
000026  2000              MOVS     r0,#0                 ;2258
000028  f8810050          STRB     r0,[r1,#0x50]         ;2258
00002c  bf00              NOP                            ;2258
00002e  bf00              NOP                            ;2260
000030  e7ed              B        |L4.14|
;;;2262   
                          ENDP


                          AREA ||i.HAL_SPI_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAResume PROC
;;;2268     */
;;;2269   HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2270   {
;;;2271     /* Process Locked */
;;;2272     __HAL_LOCK(hspi);
000002  bf00              NOP      
000004  f8910050          LDRB     r0,[r1,#0x50]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;2273   
;;;2274     /* Enable the SPI DMA Tx & Rx requests */
;;;2275     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
;;;2276   
;;;2277     /* Process Unlocked */
;;;2278     __HAL_UNLOCK(hspi);
;;;2279   
;;;2280     return HAL_OK;
;;;2281   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;2272
000012  f8810050          STRB     r0,[r1,#0x50]         ;2272
000016  bf00              NOP                            ;2272
000018  6808              LDR      r0,[r1,#0]            ;2275
00001a  6840              LDR      r0,[r0,#4]            ;2275
00001c  f0400003          ORR      r0,r0,#3              ;2275
000020  680a              LDR      r2,[r1,#0]            ;2275
000022  6050              STR      r0,[r2,#4]            ;2275
000024  bf00              NOP                            ;2278
000026  2000              MOVS     r0,#0                 ;2278
000028  f8810050          STRB     r0,[r1,#0x50]         ;2278
00002c  bf00              NOP                            ;2278
00002e  bf00              NOP                            ;2280
000030  e7ed              B        |L5.14|
;;;2282   
                          ENDP


                          AREA ||i.HAL_SPI_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAStop PROC
;;;2288     */
;;;2289   HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
000000  b570              PUSH     {r4-r6,lr}
;;;2290   {
000002  4604              MOV      r4,r0
;;;2291     HAL_StatusTypeDef errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2292     /* The Lock is not implemented on this API to allow the user application
;;;2293        to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
;;;2294        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;2295        and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
;;;2296        */
;;;2297   
;;;2298     /* Abort the SPI DMA tx Stream/Channel  */
;;;2299     if (hspi->hdmatx != NULL)
000006  6ca0              LDR      r0,[r4,#0x48]
000008  b140              CBZ      r0,|L6.28|
;;;2300     {
;;;2301       if (HAL_OK != HAL_DMA_Abort(hspi->hdmatx))
00000a  6ca0              LDR      r0,[r4,#0x48]
00000c  f7fffffe          BL       HAL_DMA_Abort
000010  b120              CBZ      r0,|L6.28|
;;;2302       {
;;;2303         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000012  6d60              LDR      r0,[r4,#0x54]
000014  f0400010          ORR      r0,r0,#0x10
000018  6560              STR      r0,[r4,#0x54]
;;;2304         errorcode = HAL_ERROR;
00001a  2501              MOVS     r5,#1
                  |L6.28|
;;;2305       }
;;;2306     }
;;;2307     /* Abort the SPI DMA rx Stream/Channel  */
;;;2308     if (hspi->hdmarx != NULL)
00001c  6ce0              LDR      r0,[r4,#0x4c]
00001e  b140              CBZ      r0,|L6.50|
;;;2309     {
;;;2310       if (HAL_OK != HAL_DMA_Abort(hspi->hdmarx))
000020  6ce0              LDR      r0,[r4,#0x4c]
000022  f7fffffe          BL       HAL_DMA_Abort
000026  b120              CBZ      r0,|L6.50|
;;;2311       {
;;;2312         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000028  6d60              LDR      r0,[r4,#0x54]
00002a  f0400010          ORR      r0,r0,#0x10
00002e  6560              STR      r0,[r4,#0x54]
;;;2313         errorcode = HAL_ERROR;
000030  2501              MOVS     r5,#1
                  |L6.50|
;;;2314       }
;;;2315     }
;;;2316   
;;;2317     /* Disable the SPI DMA Tx & Rx requests */
;;;2318     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000032  6820              LDR      r0,[r4,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f0200003          BIC      r0,r0,#3
00003a  6821              LDR      r1,[r4,#0]
00003c  6048              STR      r0,[r1,#4]
;;;2319     hspi->State = HAL_SPI_STATE_READY;
00003e  2001              MOVS     r0,#1
000040  f8840051          STRB     r0,[r4,#0x51]
;;;2320     return errorcode;
000044  4628              MOV      r0,r5
;;;2321   }
000046  bd70              POP      {r4-r6,pc}
;;;2322   
                          ENDP


                          AREA ||i.HAL_SPI_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DeInit PROC
;;;411      */
;;;412    HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;413    {
000002  4604              MOV      r4,r0
;;;414      /* Check the SPI handle allocation */
;;;415      if (hspi == NULL)
000004  b90c              CBNZ     r4,|L7.10|
;;;416      {
;;;417        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L7.8|
;;;418      }
;;;419    
;;;420      /* Check SPI Instance parameter */
;;;421      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;422    
;;;423      hspi->State = HAL_SPI_STATE_BUSY;
;;;424    
;;;425      /* Disable the SPI Peripheral Clock */
;;;426      __HAL_SPI_DISABLE(hspi);
;;;427    
;;;428    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;429      if (hspi->MspDeInitCallback == NULL)
;;;430      {
;;;431        hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */
;;;432      }
;;;433    
;;;434      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;435      hspi->MspDeInitCallback(hspi);
;;;436    #else
;;;437      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;438      HAL_SPI_MspDeInit(hspi);
;;;439    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;440    
;;;441      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;442      hspi->State = HAL_SPI_STATE_RESET;
;;;443    
;;;444      /* Release Lock */
;;;445      __HAL_UNLOCK(hspi);
;;;446    
;;;447      return HAL_OK;
;;;448    }
000008  bd10              POP      {r4,pc}
                  |L7.10|
00000a  2002              MOVS     r0,#2                 ;423
00000c  f8840051          STRB     r0,[r4,#0x51]         ;423
000010  6820              LDR      r0,[r4,#0]            ;426
000012  6800              LDR      r0,[r0,#0]            ;426
000014  f0200040          BIC      r0,r0,#0x40           ;426
000018  6821              LDR      r1,[r4,#0]            ;426
00001a  6008              STR      r0,[r1,#0]            ;426
00001c  4620              MOV      r0,r4                 ;438
00001e  f7fffffe          BL       HAL_SPI_MspDeInit
000022  2000              MOVS     r0,#0                 ;441
000024  6560              STR      r0,[r4,#0x54]         ;441
000026  f8840051          STRB     r0,[r4,#0x51]         ;442
00002a  bf00              NOP                            ;445
00002c  f8840050          STRB     r0,[r4,#0x50]         ;445
000030  bf00              NOP                            ;445
000032  bf00              NOP                            ;447
000034  e7e8              B        |L7.8|
;;;449    
                          ENDP


                          AREA ||i.HAL_SPI_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_ErrorCallback PROC
;;;2530     */
;;;2531   __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2532   {
;;;2533     /* Prevent unused argument(s) compilation warning */
;;;2534     UNUSED(hspi);
;;;2535   
;;;2536     /* NOTE : This function should not be modified, when the callback is needed,
;;;2537               the HAL_SPI_ErrorCallback should be implemented in the user file
;;;2538      */
;;;2539     /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
;;;2540               and user can use HAL_SPI_GetError() API to check the latest error occurred
;;;2541      */
;;;2542   }
;;;2543   
                          ENDP


                          AREA ||i.HAL_SPI_GetError||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetError PROC
;;;2595     */
;;;2596   uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2597   {
;;;2598     /* Return SPI ErrorCode */
;;;2599     return hspi->ErrorCode;
000002  6d48              LDR      r0,[r1,#0x54]
;;;2600   }
000004  4770              BX       lr
;;;2601   
                          ENDP


                          AREA ||i.HAL_SPI_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetState PROC
;;;2583     */
;;;2584   HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2585   {
;;;2586     /* Return SPI handle state */
;;;2587     return hspi->State;
000002  f8910051          LDRB     r0,[r1,#0x51]
;;;2588   }
000006  4770              BX       lr
;;;2589   
                          ENDP


                          AREA ||i.HAL_SPI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_SPI_IRQHandler PROC
;;;2328     */
;;;2329   void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2330   {
000002  4604              MOV      r4,r0
;;;2331     uint32_t itsource = hspi->Instance->CR2;
000004  6820              LDR      r0,[r4,#0]
000006  6846              LDR      r6,[r0,#4]
;;;2332     uint32_t itflag   = hspi->Instance->SR;
000008  6820              LDR      r0,[r4,#0]
00000a  6885              LDR      r5,[r0,#8]
;;;2333   
;;;2334     /* SPI in mode Receiver ----------------------------------------------------*/
;;;2335     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
00000c  f3c51080          UBFX     r0,r5,#6,#1
000010  b948              CBNZ     r0,|L11.38|
;;;2336         (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
000012  f0050001          AND      r0,r5,#1
000016  b130              CBZ      r0,|L11.38|
000018  f3c61080          UBFX     r0,r6,#6,#1
00001c  b118              CBZ      r0,|L11.38|
;;;2337     {
;;;2338       hspi->RxISR(hspi);
00001e  4620              MOV      r0,r4
000020  6c21              LDR      r1,[r4,#0x40]
000022  4788              BLX      r1
                  |L11.36|
;;;2339       return;
;;;2340     }
;;;2341   
;;;2342     /* SPI in mode Transmitter -------------------------------------------------*/
;;;2343     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
;;;2344     {
;;;2345       hspi->TxISR(hspi);
;;;2346       return;
;;;2347     }
;;;2348   
;;;2349     /* SPI in Error Treatment --------------------------------------------------*/
;;;2350     if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
;;;2351     {
;;;2352       /* SPI Overrun error interrupt occurred ----------------------------------*/
;;;2353       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
;;;2354       {
;;;2355         if (hspi->State != HAL_SPI_STATE_BUSY_TX)
;;;2356         {
;;;2357           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
;;;2358           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2359         }
;;;2360         else
;;;2361         {
;;;2362           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2363           return;
;;;2364         }
;;;2365       }
;;;2366   
;;;2367       /* SPI Mode Fault error interrupt occurred -------------------------------*/
;;;2368       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
;;;2369       {
;;;2370         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
;;;2371         __HAL_SPI_CLEAR_MODFFLAG(hspi);
;;;2372       }
;;;2373   
;;;2374       /* SPI Frame error interrupt occurred ------------------------------------*/
;;;2375       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
;;;2376       {
;;;2377         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
;;;2378         __HAL_SPI_CLEAR_FREFLAG(hspi);
;;;2379       }
;;;2380   
;;;2381       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;2382       {
;;;2383         /* Disable all interrupts */
;;;2384         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
;;;2385   
;;;2386         hspi->State = HAL_SPI_STATE_READY;
;;;2387         /* Disable the SPI DMA requests if enabled */
;;;2388         if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
;;;2389         {
;;;2390           CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
;;;2391   
;;;2392           /* Abort the SPI DMA Rx channel */
;;;2393           if (hspi->hdmarx != NULL)
;;;2394           {
;;;2395             /* Set the SPI DMA Abort callback :
;;;2396             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2397             hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
;;;2398             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
;;;2399             {
;;;2400               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2401             }
;;;2402           }
;;;2403           /* Abort the SPI DMA Tx channel */
;;;2404           if (hspi->hdmatx != NULL)
;;;2405           {
;;;2406             /* Set the SPI DMA Abort callback :
;;;2407             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2408             hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
;;;2409             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
;;;2410             {
;;;2411               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2412             }
;;;2413           }
;;;2414         }
;;;2415         else
;;;2416         {
;;;2417           /* Call user error callback */
;;;2418   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2419           hspi->ErrorCallback(hspi);
;;;2420   #else
;;;2421           HAL_SPI_ErrorCallback(hspi);
;;;2422   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2423         }
;;;2424       }
;;;2425       return;
;;;2426     }
;;;2427   }
000024  bdf8              POP      {r3-r7,pc}
                  |L11.38|
000026  f3c50040          UBFX     r0,r5,#1,#1           ;2343
00002a  b130              CBZ      r0,|L11.58|
00002c  f3c610c0          UBFX     r0,r6,#7,#1           ;2343
000030  b118              CBZ      r0,|L11.58|
000032  4620              MOV      r0,r4                 ;2345
000034  6c61              LDR      r1,[r4,#0x44]         ;2345
000036  4788              BLX      r1                    ;2345
000038  e7f4              B        |L11.36|
                  |L11.58|
00003a  f3c51040          UBFX     r0,r5,#5,#1           ;2350
00003e  b930              CBNZ     r0,|L11.78|
000040  f3c51080          UBFX     r0,r5,#6,#1           ;2350
000044  b918              CBNZ     r0,|L11.78|
000046  f3c52000          UBFX     r0,r5,#8,#1           ;2350
00004a  2800              CMP      r0,#0                 ;2350
00004c  d07c              BEQ      |L11.328|
                  |L11.78|
00004e  f3c61040          UBFX     r0,r6,#5,#1           ;2350
000052  2800              CMP      r0,#0                 ;2350
000054  d07d              BEQ      |L11.338|
000056  f3c51080          UBFX     r0,r5,#6,#1           ;2353
00005a  b1f0              CBZ      r0,|L11.154|
00005c  f8940051          LDRB     r0,[r4,#0x51]         ;2355
000060  2803              CMP      r0,#3                 ;2355
000062  d00e              BEQ      |L11.130|
000064  6d60              LDR      r0,[r4,#0x54]         ;2357
000066  f0400004          ORR      r0,r0,#4              ;2357
00006a  6560              STR      r0,[r4,#0x54]         ;2357
00006c  bf00              NOP                            ;2358
00006e  2000              MOVS     r0,#0                 ;2358
000070  9000              STR      r0,[sp,#0]            ;2358
000072  6820              LDR      r0,[r4,#0]            ;2358
000074  68c0              LDR      r0,[r0,#0xc]          ;2358
000076  9000              STR      r0,[sp,#0]            ;2358
000078  6820              LDR      r0,[r4,#0]            ;2358
00007a  6880              LDR      r0,[r0,#8]            ;2358
00007c  9000              STR      r0,[sp,#0]            ;2358
00007e  bf00              NOP                            ;2358
000080  e00b              B        |L11.154|
                  |L11.130|
000082  bf00              NOP                            ;2362
000084  2000              MOVS     r0,#0                 ;2362
000086  9000              STR      r0,[sp,#0]            ;2362
000088  6820              LDR      r0,[r4,#0]            ;2362
00008a  68c0              LDR      r0,[r0,#0xc]          ;2362
00008c  9000              STR      r0,[sp,#0]            ;2362
00008e  6820              LDR      r0,[r4,#0]            ;2362
000090  6880              LDR      r0,[r0,#8]            ;2362
000092  9000              STR      r0,[sp,#0]            ;2362
000094  bf00              NOP                            ;2362
000096  bf00              NOP                            ;2362
000098  e7c4              B        |L11.36|
                  |L11.154|
00009a  f3c51040          UBFX     r0,r5,#5,#1           ;2368
00009e  b188              CBZ      r0,|L11.196|
0000a0  6d60              LDR      r0,[r4,#0x54]         ;2370
0000a2  f0400001          ORR      r0,r0,#1              ;2370
0000a6  6560              STR      r0,[r4,#0x54]         ;2370
0000a8  bf00              NOP                            ;2371
0000aa  2000              MOVS     r0,#0                 ;2371
0000ac  9000              STR      r0,[sp,#0]            ;2371
0000ae  6820              LDR      r0,[r4,#0]            ;2371
0000b0  6880              LDR      r0,[r0,#8]            ;2371
0000b2  9000              STR      r0,[sp,#0]            ;2371
0000b4  6820              LDR      r0,[r4,#0]            ;2371
0000b6  6800              LDR      r0,[r0,#0]            ;2371
0000b8  f0200040          BIC      r0,r0,#0x40           ;2371
0000bc  6821              LDR      r1,[r4,#0]            ;2371
0000be  6008              STR      r0,[r1,#0]            ;2371
0000c0  bf00              NOP                            ;2371
0000c2  bf00              NOP                            ;2371
                  |L11.196|
0000c4  f3c52000          UBFX     r0,r5,#8,#1           ;2375
0000c8  b158              CBZ      r0,|L11.226|
0000ca  6d60              LDR      r0,[r4,#0x54]         ;2377
0000cc  f0400008          ORR      r0,r0,#8              ;2377
0000d0  6560              STR      r0,[r4,#0x54]         ;2377
0000d2  bf00              NOP                            ;2378
0000d4  2000              MOVS     r0,#0                 ;2378
0000d6  9000              STR      r0,[sp,#0]            ;2378
0000d8  6820              LDR      r0,[r4,#0]            ;2378
0000da  6880              LDR      r0,[r0,#8]            ;2378
0000dc  9000              STR      r0,[sp,#0]            ;2378
0000de  bf00              NOP                            ;2378
0000e0  bf00              NOP                            ;2378
                  |L11.226|
0000e2  6d60              LDR      r0,[r4,#0x54]         ;2381
0000e4  b378              CBZ      r0,|L11.326|
0000e6  6820              LDR      r0,[r4,#0]            ;2384
0000e8  6840              LDR      r0,[r0,#4]            ;2384
0000ea  f02000e0          BIC      r0,r0,#0xe0           ;2384
0000ee  6821              LDR      r1,[r4,#0]            ;2384
0000f0  6048              STR      r0,[r1,#4]            ;2384
0000f2  2001              MOVS     r0,#1                 ;2386
0000f4  f8840051          STRB     r0,[r4,#0x51]         ;2386
0000f8  f0060002          AND      r0,r6,#2              ;2388
0000fc  2802              CMP      r0,#2                 ;2388
0000fe  d002              BEQ      |L11.262|
000100  f0060001          AND      r0,r6,#1              ;2388
000104  b308              CBZ      r0,|L11.330|
                  |L11.262|
000106  6820              LDR      r0,[r4,#0]            ;2390
000108  6840              LDR      r0,[r0,#4]            ;2390
00010a  f0200003          BIC      r0,r0,#3              ;2390
00010e  6821              LDR      r1,[r4,#0]            ;2390
000110  6048              STR      r0,[r1,#4]            ;2390
000112  6ce0              LDR      r0,[r4,#0x4c]         ;2393
000114  b150              CBZ      r0,|L11.300|
000116  4810              LDR      r0,|L11.344|
000118  6ce1              LDR      r1,[r4,#0x4c]         ;2397
00011a  6508              STR      r0,[r1,#0x50]         ;2397
00011c  6ce0              LDR      r0,[r4,#0x4c]         ;2398
00011e  f7fffffe          BL       HAL_DMA_Abort_IT
000122  b118              CBZ      r0,|L11.300|
000124  6d60              LDR      r0,[r4,#0x54]         ;2400
000126  f0400040          ORR      r0,r0,#0x40           ;2400
00012a  6560              STR      r0,[r4,#0x54]         ;2400
                  |L11.300|
00012c  6ca0              LDR      r0,[r4,#0x48]         ;2404
00012e  b150              CBZ      r0,|L11.326|
000130  4809              LDR      r0,|L11.344|
000132  6ca1              LDR      r1,[r4,#0x48]         ;2408
000134  6508              STR      r0,[r1,#0x50]         ;2408
000136  6ca0              LDR      r0,[r4,#0x48]         ;2409
000138  f7fffffe          BL       HAL_DMA_Abort_IT
00013c  b118              CBZ      r0,|L11.326|
00013e  6d60              LDR      r0,[r4,#0x54]         ;2411
000140  f0400040          ORR      r0,r0,#0x40           ;2411
000144  6560              STR      r0,[r4,#0x54]         ;2411
                  |L11.326|
000146  e003              B        |L11.336|
                  |L11.328|
000148  e003              B        |L11.338|
                  |L11.330|
00014a  4620              MOV      r0,r4                 ;2421
00014c  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L11.336|
000150  e768              B        |L11.36|
                  |L11.338|
000152  bf00              NOP      
000154  e766              B        |L11.36|
;;;2428   
                          ENDP

000156  0000              DCW      0x0000
                  |L11.344|
                          DCD      SPI_DMAAbortOnError

                          AREA ||i.HAL_SPI_Init||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Init PROC
;;;309      */
;;;310    HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;311    {
000002  4604              MOV      r4,r0
;;;312      /* Check the SPI handle allocation */
;;;313      if (hspi == NULL)
000004  b90c              CBNZ     r4,|L12.10|
;;;314      {
;;;315        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L12.8|
;;;316      }
;;;317    
;;;318      /* Check the parameters */
;;;319      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;320      assert_param(IS_SPI_MODE(hspi->Init.Mode));
;;;321      assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
;;;322      assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
;;;323      assert_param(IS_SPI_NSS(hspi->Init.NSS));
;;;324      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;325      assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
;;;326      assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
;;;327      if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
;;;328      {
;;;329        assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
;;;330        assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
;;;331      }
;;;332    #if (USE_SPI_CRC != 0U)
;;;333      assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
;;;334      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;335      {
;;;336        assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
;;;337      }
;;;338    #else
;;;339      hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
;;;340    #endif /* USE_SPI_CRC */
;;;341    
;;;342      if (hspi->State == HAL_SPI_STATE_RESET)
;;;343      {
;;;344        /* Allocate lock resource and initialize it */
;;;345        hspi->Lock = HAL_UNLOCKED;
;;;346    
;;;347    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;348        /* Init the SPI Callback settings */
;;;349        hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
;;;350        hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
;;;351        hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
;;;352        hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
;;;353        hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
;;;354        hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
;;;355        hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;356        hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;357    
;;;358        if (hspi->MspInitCallback == NULL)
;;;359        {
;;;360          hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
;;;361        }
;;;362    
;;;363        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;364        hspi->MspInitCallback(hspi);
;;;365    #else
;;;366        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;367        HAL_SPI_MspInit(hspi);
;;;368    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;369      }
;;;370    
;;;371      hspi->State = HAL_SPI_STATE_BUSY;
;;;372    
;;;373      /* Disable the selected SPI peripheral */
;;;374      __HAL_SPI_DISABLE(hspi);
;;;375    
;;;376      /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
;;;377      /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
;;;378      Communication speed, First bit and CRC calculation state */
;;;379      WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
;;;380                                      hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
;;;381                                      hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));
;;;382    
;;;383      /* Configure : NSS management, TI Mode */
;;;384      WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
;;;385    
;;;386    #if (USE_SPI_CRC != 0U)
;;;387      /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
;;;388      /* Configure : CRC Polynomial */
;;;389      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;390      {
;;;391        WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
;;;392      }
;;;393    #endif /* USE_SPI_CRC */
;;;394    
;;;395    #if defined(SPI_I2SCFGR_I2SMOD)
;;;396      /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
;;;397      CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
;;;398    #endif /* SPI_I2SCFGR_I2SMOD */
;;;399    
;;;400      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;401      hspi->State     = HAL_SPI_STATE_READY;
;;;402    
;;;403      return HAL_OK;
;;;404    }
000008  bd10              POP      {r4,pc}
                  |L12.10|
00000a  6a60              LDR      r0,[r4,#0x24]         ;327
00000c  b900              CBNZ     r0,|L12.16|
00000e  bf00              NOP                            ;330
                  |L12.16|
000010  6aa0              LDR      r0,[r4,#0x28]         ;334
000012  f5b05f00          CMP      r0,#0x2000            ;334
000016  d100              BNE      |L12.26|
000018  bf00              NOP                            ;336
                  |L12.26|
00001a  f8940051          LDRB     r0,[r4,#0x51]         ;342
00001e  b928              CBNZ     r0,|L12.44|
000020  2000              MOVS     r0,#0                 ;345
000022  f8840050          STRB     r0,[r4,#0x50]         ;345
000026  4620              MOV      r0,r4                 ;367
000028  f7fffffe          BL       HAL_SPI_MspInit
                  |L12.44|
00002c  2002              MOVS     r0,#2                 ;371
00002e  f8840051          STRB     r0,[r4,#0x51]         ;371
000032  6820              LDR      r0,[r4,#0]            ;374
000034  6800              LDR      r0,[r0,#0]            ;374
000036  f0200040          BIC      r0,r0,#0x40           ;374
00003a  6821              LDR      r1,[r4,#0]            ;374
00003c  6008              STR      r0,[r1,#0]            ;374
00003e  e9d40101          LDRD     r0,r1,[r4,#4]         ;379
000042  4308              ORRS     r0,r0,r1              ;379
000044  68e1              LDR      r1,[r4,#0xc]          ;379
000046  4308              ORRS     r0,r0,r1              ;379
000048  6921              LDR      r1,[r4,#0x10]         ;379
00004a  4308              ORRS     r0,r0,r1              ;379
00004c  6961              LDR      r1,[r4,#0x14]         ;379
00004e  4308              ORRS     r0,r0,r1              ;379
000050  8b21              LDRH     r1,[r4,#0x18]         ;379
000052  f4017100          AND      r1,r1,#0x200          ;379
000056  4308              ORRS     r0,r0,r1              ;379
000058  69e1              LDR      r1,[r4,#0x1c]         ;379
00005a  4308              ORRS     r0,r0,r1              ;379
00005c  6a21              LDR      r1,[r4,#0x20]         ;379
00005e  4308              ORRS     r0,r0,r1              ;379
000060  6aa1              LDR      r1,[r4,#0x28]         ;379
000062  4308              ORRS     r0,r0,r1              ;379
000064  6821              LDR      r1,[r4,#0]            ;379
000066  6008              STR      r0,[r1,#0]            ;379
000068  2104              MOVS     r1,#4                 ;384
00006a  69a0              LDR      r0,[r4,#0x18]         ;384
00006c  ea014010          AND      r0,r1,r0,LSR #16      ;384
000070  6a61              LDR      r1,[r4,#0x24]         ;384
000072  4308              ORRS     r0,r0,r1              ;384
000074  6821              LDR      r1,[r4,#0]            ;384
000076  6048              STR      r0,[r1,#4]            ;384
000078  6aa0              LDR      r0,[r4,#0x28]         ;389
00007a  f5b05f00          CMP      r0,#0x2000            ;389
00007e  d102              BNE      |L12.134|
000080  6821              LDR      r1,[r4,#0]            ;391
000082  6ae0              LDR      r0,[r4,#0x2c]         ;391
000084  6108              STR      r0,[r1,#0x10]         ;391
                  |L12.134|
000086  6820              LDR      r0,[r4,#0]            ;397
000088  69c0              LDR      r0,[r0,#0x1c]         ;397
00008a  f4206000          BIC      r0,r0,#0x800          ;397
00008e  6821              LDR      r1,[r4,#0]            ;397
000090  61c8              STR      r0,[r1,#0x1c]         ;397
000092  2000              MOVS     r0,#0                 ;400
000094  6560              STR      r0,[r4,#0x54]         ;400
000096  2001              MOVS     r0,#1                 ;401
000098  f8840051          STRB     r0,[r4,#0x51]         ;401
00009c  2000              MOVS     r0,#0                 ;403
00009e  e7b3              B        |L12.8|
;;;405    
                          ENDP


                          AREA ||i.HAL_SPI_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspDeInit PROC
;;;471      */
;;;472    __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;473    {
;;;474      /* Prevent unused argument(s) compilation warning */
;;;475      UNUSED(hspi);
;;;476    
;;;477      /* NOTE : This function should not be modified, when the callback is needed,
;;;478                the HAL_SPI_MspDeInit should be implemented in the user file
;;;479       */
;;;480    }
;;;481    
                          ENDP


                          AREA ||i.HAL_SPI_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspInit PROC
;;;455      */
;;;456    __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;457    {
;;;458      /* Prevent unused argument(s) compilation warning */
;;;459      UNUSED(hspi);
;;;460    
;;;461      /* NOTE : This function should not be modified, when the callback is needed,
;;;462                the HAL_SPI_MspInit should be implemented in the user file
;;;463       */
;;;464    }
;;;465    
                          ENDP


                          AREA ||i.HAL_SPI_Receive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Receive PROC
;;;905      */
;;;906    HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;907    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;908      uint32_t tickstart;
;;;909      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0900          MOV      r9,#0
;;;910    
;;;911      if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
000010  6860              LDR      r0,[r4,#4]
000012  f5b07f82          CMP      r0,#0x104
000016  d10d              BNE      |L15.52|
000018  68a0              LDR      r0,[r4,#8]
00001a  b958              CBNZ     r0,|L15.52|
;;;912      {
;;;913        hspi->State = HAL_SPI_STATE_BUSY_RX;
00001c  2004              MOVS     r0,#4
00001e  f8840051          STRB     r0,[r4,#0x51]
;;;914        /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;915        return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
000022  463b              MOV      r3,r7
000024  4642              MOV      r2,r8
000026  4641              MOV      r1,r8
000028  4620              MOV      r0,r4
00002a  9500              STR      r5,[sp,#0]
00002c  f7fffffe          BL       HAL_SPI_TransmitReceive
                  |L15.48|
;;;916      }
;;;917    
;;;918      /* Process Locked */
;;;919      __HAL_LOCK(hspi);
;;;920    
;;;921      /* Init tickstart for timeout management*/
;;;922      tickstart = HAL_GetTick();
;;;923    
;;;924      if (hspi->State != HAL_SPI_STATE_READY)
;;;925      {
;;;926        errorcode = HAL_BUSY;
;;;927        goto error;
;;;928      }
;;;929    
;;;930      if ((pData == NULL) || (Size == 0U))
;;;931      {
;;;932        errorcode = HAL_ERROR;
;;;933        goto error;
;;;934      }
;;;935    
;;;936      /* Set the transaction information */
;;;937      hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;938      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;939      hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;940      hspi->RxXferSize  = Size;
;;;941      hspi->RxXferCount = Size;
;;;942    
;;;943      /*Init field not used in handle to zero */
;;;944      hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;945      hspi->TxXferSize  = 0U;
;;;946      hspi->TxXferCount = 0U;
;;;947      hspi->RxISR       = NULL;
;;;948      hspi->TxISR       = NULL;
;;;949    
;;;950    #if (USE_SPI_CRC != 0U)
;;;951      /* Reset CRC Calculation */
;;;952      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;953      {
;;;954        SPI_RESET_CRC(hspi);
;;;955        /* this is done to handle the CRCNEXT before the latest data */
;;;956        hspi->RxXferCount--;
;;;957      }
;;;958    #endif /* USE_SPI_CRC */
;;;959    
;;;960      /* Configure communication direction: 1Line */
;;;961      if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;962      {
;;;963        SPI_1LINE_RX(hspi);
;;;964      }
;;;965    
;;;966      /* Check if the SPI is already enabled */
;;;967      if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;968      {
;;;969        /* Enable SPI peripheral */
;;;970        __HAL_SPI_ENABLE(hspi);
;;;971      }
;;;972    
;;;973      /* Receive data in 8 Bit mode */
;;;974      if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
;;;975      {
;;;976        /* Transfer loop */
;;;977        while (hspi->RxXferCount > 0U)
;;;978        {
;;;979          /* Check the RXNE flag */
;;;980          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;981          {
;;;982            /* read the received data */
;;;983            (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;984            hspi->pRxBuffPtr += sizeof(uint8_t);
;;;985            hspi->RxXferCount--;
;;;986          }
;;;987          else
;;;988          {
;;;989            /* Timeout management */
;;;990            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;991            {
;;;992              errorcode = HAL_TIMEOUT;
;;;993              goto error;
;;;994            }
;;;995          }
;;;996        }
;;;997      }
;;;998      else
;;;999      {
;;;1000       /* Transfer loop */
;;;1001       while (hspi->RxXferCount > 0U)
;;;1002       {
;;;1003         /* Check the RXNE flag */
;;;1004         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1005         {
;;;1006           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1007           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1008           hspi->RxXferCount--;
;;;1009         }
;;;1010         else
;;;1011         {
;;;1012           /* Timeout management */
;;;1013           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1014           {
;;;1015             errorcode = HAL_TIMEOUT;
;;;1016             goto error;
;;;1017           }
;;;1018         }
;;;1019       }
;;;1020     }
;;;1021   
;;;1022   #if (USE_SPI_CRC != 0U)
;;;1023     /* Handle the CRC Transmission */
;;;1024     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1025     {
;;;1026       /* freeze the CRC before the latest data */
;;;1027       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1028   
;;;1029       /* Read the latest data */
;;;1030       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1031       {
;;;1032         /* the latest data has not been received */
;;;1033         errorcode = HAL_TIMEOUT;
;;;1034         goto error;
;;;1035       }
;;;1036   
;;;1037       /* Receive last data in 16 Bit mode */
;;;1038       if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1039       {
;;;1040         *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1041       }
;;;1042       /* Receive last data in 8 Bit mode */
;;;1043       else
;;;1044       {
;;;1045         (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1046       }
;;;1047   
;;;1048       /* Wait the CRC data */
;;;1049       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1050       {
;;;1051         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1052         errorcode = HAL_TIMEOUT;
;;;1053         goto error;
;;;1054       }
;;;1055   
;;;1056       /* Read CRC to Flush DR and RXNE flag */
;;;1057       READ_REG(hspi->Instance->DR);
;;;1058     }
;;;1059   #endif /* USE_SPI_CRC */
;;;1060   
;;;1061     /* Check the end of the transaction */
;;;1062     if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1063     {
;;;1064       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1065     }
;;;1066   
;;;1067   #if (USE_SPI_CRC != 0U)
;;;1068     /* Check if CRC error occurred */
;;;1069     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
;;;1070     {
;;;1071       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1072       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1073     }
;;;1074   #endif /* USE_SPI_CRC */
;;;1075   
;;;1076     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;1077     {
;;;1078       errorcode = HAL_ERROR;
;;;1079     }
;;;1080   
;;;1081   error :
;;;1082     hspi->State = HAL_SPI_STATE_READY;
;;;1083     __HAL_UNLOCK(hspi);
;;;1084     return errorcode;
;;;1085   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L15.52|
000034  bf00              NOP                            ;919
000036  f8940050          LDRB     r0,[r4,#0x50]         ;919
00003a  2801              CMP      r0,#1                 ;919
00003c  d101              BNE      |L15.66|
00003e  2002              MOVS     r0,#2                 ;919
000040  e7f6              B        |L15.48|
                  |L15.66|
000042  2001              MOVS     r0,#1                 ;919
000044  f8840050          STRB     r0,[r4,#0x50]         ;919
000048  bf00              NOP                            ;919
00004a  f7fffffe          BL       HAL_GetTick
00004e  4606              MOV      r6,r0                 ;922
000050  f8940051          LDRB     r0,[r4,#0x51]         ;924
000054  2801              CMP      r0,#1                 ;924
000056  d002              BEQ      |L15.94|
000058  f04f0902          MOV      r9,#2                 ;926
00005c  e0ce              B        |L15.508|
                  |L15.94|
00005e  f1b80f00          CMP      r8,#0                 ;930
000062  d000              BEQ      |L15.102|
000064  b917              CBNZ     r7,|L15.108|
                  |L15.102|
000066  f04f0901          MOV      r9,#1                 ;932
00006a  e0c7              B        |L15.508|
                  |L15.108|
00006c  2004              MOVS     r0,#4                 ;937
00006e  f8840051          STRB     r0,[r4,#0x51]         ;937
000072  2000              MOVS     r0,#0                 ;938
000074  6560              STR      r0,[r4,#0x54]         ;938
000076  f8c48038          STR      r8,[r4,#0x38]         ;939
00007a  87a7              STRH     r7,[r4,#0x3c]         ;940
00007c  87e7              STRH     r7,[r4,#0x3e]         ;941
00007e  6320              STR      r0,[r4,#0x30]         ;944
000080  86a0              STRH     r0,[r4,#0x34]         ;945
000082  86e0              STRH     r0,[r4,#0x36]         ;946
000084  6420              STR      r0,[r4,#0x40]         ;947
000086  6460              STR      r0,[r4,#0x44]         ;948
000088  6aa0              LDR      r0,[r4,#0x28]         ;952
00008a  f5b05f00          CMP      r0,#0x2000            ;952
00008e  d110              BNE      |L15.178|
000090  bf00              NOP                            ;954
000092  6820              LDR      r0,[r4,#0]            ;954
000094  6800              LDR      r0,[r0,#0]            ;954
000096  f4205000          BIC      r0,r0,#0x2000         ;954
00009a  6821              LDR      r1,[r4,#0]            ;954
00009c  6008              STR      r0,[r1,#0]            ;954
00009e  6820              LDR      r0,[r4,#0]            ;954
0000a0  6800              LDR      r0,[r0,#0]            ;954
0000a2  f4405000          ORR      r0,r0,#0x2000         ;954
0000a6  6821              LDR      r1,[r4,#0]            ;954
0000a8  6008              STR      r0,[r1,#0]            ;954
0000aa  bf00              NOP                            ;954
0000ac  8fe0              LDRH     r0,[r4,#0x3e]         ;956
0000ae  1e40              SUBS     r0,r0,#1              ;956
0000b0  87e0              STRH     r0,[r4,#0x3e]         ;956
                  |L15.178|
0000b2  68a0              LDR      r0,[r4,#8]            ;961
0000b4  f5b04f00          CMP      r0,#0x8000            ;961
0000b8  d105              BNE      |L15.198|
0000ba  6820              LDR      r0,[r4,#0]            ;963
0000bc  6800              LDR      r0,[r0,#0]            ;963
0000be  f4204080          BIC      r0,r0,#0x4000         ;963
0000c2  6821              LDR      r1,[r4,#0]            ;963
0000c4  6008              STR      r0,[r1,#0]            ;963
                  |L15.198|
0000c6  6820              LDR      r0,[r4,#0]            ;967
0000c8  6800              LDR      r0,[r0,#0]            ;967
0000ca  f0000040          AND      r0,r0,#0x40           ;967
0000ce  2840              CMP      r0,#0x40              ;967
0000d0  d005              BEQ      |L15.222|
0000d2  6820              LDR      r0,[r4,#0]            ;970
0000d4  6800              LDR      r0,[r0,#0]            ;970
0000d6  f0400040          ORR      r0,r0,#0x40           ;970
0000da  6821              LDR      r1,[r4,#0]            ;970
0000dc  6008              STR      r0,[r1,#0]            ;970
                  |L15.222|
0000de  68e0              LDR      r0,[r4,#0xc]          ;974
0000e0  b9f8              CBNZ     r0,|L15.290|
0000e2  e01a              B        |L15.282|
                  |L15.228|
0000e4  6820              LDR      r0,[r4,#0]            ;980
0000e6  6880              LDR      r0,[r0,#8]            ;980
0000e8  f0000001          AND      r0,r0,#1              ;980
0000ec  b150              CBZ      r0,|L15.260|
0000ee  6820              LDR      r0,[r4,#0]            ;983
0000f0  7b00              LDRB     r0,[r0,#0xc]          ;983
0000f2  6ba1              LDR      r1,[r4,#0x38]         ;983
0000f4  7008              STRB     r0,[r1,#0]            ;983
0000f6  6ba0              LDR      r0,[r4,#0x38]         ;984
0000f8  1c40              ADDS     r0,r0,#1              ;984
0000fa  63a0              STR      r0,[r4,#0x38]         ;984
0000fc  8fe0              LDRH     r0,[r4,#0x3e]         ;985
0000fe  1e40              SUBS     r0,r0,#1              ;985
000100  87e0              STRH     r0,[r4,#0x3e]         ;985
000102  e00a              B        |L15.282|
                  |L15.260|
000104  f7fffffe          BL       HAL_GetTick
000108  1b80              SUBS     r0,r0,r6              ;990
00010a  42a8              CMP      r0,r5                 ;990
00010c  d301              BCC      |L15.274|
00010e  1c68              ADDS     r0,r5,#1              ;990
000110  b900              CBNZ     r0,|L15.276|
                  |L15.274|
000112  b915              CBNZ     r5,|L15.282|
                  |L15.276|
000114  f04f0903          MOV      r9,#3                 ;992
000118  e070              B        |L15.508|
                  |L15.282|
00011a  8fe0              LDRH     r0,[r4,#0x3e]         ;977
00011c  2800              CMP      r0,#0                 ;977
00011e  d1e1              BNE      |L15.228|
000120  e01e              B        |L15.352|
                  |L15.290|
000122  e01a              B        |L15.346|
                  |L15.292|
000124  6820              LDR      r0,[r4,#0]            ;1004
000126  6880              LDR      r0,[r0,#8]            ;1004
000128  f0000001          AND      r0,r0,#1              ;1004
00012c  b150              CBZ      r0,|L15.324|
00012e  6820              LDR      r0,[r4,#0]            ;1006
000130  68c0              LDR      r0,[r0,#0xc]          ;1006
000132  6ba1              LDR      r1,[r4,#0x38]         ;1006
000134  8008              STRH     r0,[r1,#0]            ;1006
000136  6ba0              LDR      r0,[r4,#0x38]         ;1007
000138  1c80              ADDS     r0,r0,#2              ;1007
00013a  63a0              STR      r0,[r4,#0x38]         ;1007
00013c  8fe0              LDRH     r0,[r4,#0x3e]         ;1008
00013e  1e40              SUBS     r0,r0,#1              ;1008
000140  87e0              STRH     r0,[r4,#0x3e]         ;1008
000142  e00a              B        |L15.346|
                  |L15.324|
000144  f7fffffe          BL       HAL_GetTick
000148  1b80              SUBS     r0,r0,r6              ;1013
00014a  42a8              CMP      r0,r5                 ;1013
00014c  d301              BCC      |L15.338|
00014e  1c68              ADDS     r0,r5,#1              ;1013
000150  b900              CBNZ     r0,|L15.340|
                  |L15.338|
000152  b915              CBNZ     r5,|L15.346|
                  |L15.340|
000154  f04f0903          MOV      r9,#3                 ;1015
000158  e050              B        |L15.508|
                  |L15.346|
00015a  8fe0              LDRH     r0,[r4,#0x3e]         ;1001
00015c  2800              CMP      r0,#0                 ;1001
00015e  d1e1              BNE      |L15.292|
                  |L15.352|
000160  6aa0              LDR      r0,[r4,#0x28]         ;1024
000162  f5b05f00          CMP      r0,#0x2000            ;1024
000166  d12e              BNE      |L15.454|
000168  6820              LDR      r0,[r4,#0]            ;1027
00016a  6800              LDR      r0,[r0,#0]            ;1027
00016c  f4405080          ORR      r0,r0,#0x1000         ;1027
000170  6821              LDR      r1,[r4,#0]            ;1027
000172  6008              STR      r0,[r1,#0]            ;1027
000174  462b              MOV      r3,r5                 ;1030
000176  2201              MOVS     r2,#1                 ;1030
000178  4611              MOV      r1,r2                 ;1030
00017a  4620              MOV      r0,r4                 ;1030
00017c  9600              STR      r6,[sp,#0]            ;1030
00017e  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000182  b110              CBZ      r0,|L15.394|
000184  f04f0903          MOV      r9,#3                 ;1033
000188  e038              B        |L15.508|
                  |L15.394|
00018a  68e0              LDR      r0,[r4,#0xc]          ;1038
00018c  f5b06f00          CMP      r0,#0x800             ;1038
000190  d104              BNE      |L15.412|
000192  6820              LDR      r0,[r4,#0]            ;1040
000194  68c0              LDR      r0,[r0,#0xc]          ;1040
000196  6ba1              LDR      r1,[r4,#0x38]         ;1040
000198  8008              STRH     r0,[r1,#0]            ;1040
00019a  e003              B        |L15.420|
                  |L15.412|
00019c  6820              LDR      r0,[r4,#0]            ;1045
00019e  7b00              LDRB     r0,[r0,#0xc]          ;1045
0001a0  6ba1              LDR      r1,[r4,#0x38]         ;1045
0001a2  7008              STRB     r0,[r1,#0]            ;1045
                  |L15.420|
0001a4  462b              MOV      r3,r5                 ;1049
0001a6  2201              MOVS     r2,#1                 ;1049
0001a8  4611              MOV      r1,r2                 ;1049
0001aa  4620              MOV      r0,r4                 ;1049
0001ac  9600              STR      r6,[sp,#0]            ;1049
0001ae  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
0001b2  b130              CBZ      r0,|L15.450|
0001b4  6d60              LDR      r0,[r4,#0x54]         ;1051
0001b6  f0400002          ORR      r0,r0,#2              ;1051
0001ba  6560              STR      r0,[r4,#0x54]         ;1051
0001bc  f04f0903          MOV      r9,#3                 ;1052
0001c0  e01c              B        |L15.508|
                  |L15.450|
0001c2  6820              LDR      r0,[r4,#0]            ;1057
0001c4  68c0              LDR      r0,[r0,#0xc]          ;1057
                  |L15.454|
0001c6  4632              MOV      r2,r6                 ;1062
0001c8  4629              MOV      r1,r5                 ;1062
0001ca  4620              MOV      r0,r4                 ;1062
0001cc  f7fffffe          BL       SPI_EndRxTransaction
0001d0  b108              CBZ      r0,|L15.470|
0001d2  2020              MOVS     r0,#0x20              ;1064
0001d4  6560              STR      r0,[r4,#0x54]         ;1064
                  |L15.470|
0001d6  6820              LDR      r0,[r4,#0]            ;1069
0001d8  6880              LDR      r0,[r0,#8]            ;1069
0001da  f0000010          AND      r0,r0,#0x10           ;1069
0001de  2810              CMP      r0,#0x10              ;1069
0001e0  d107              BNE      |L15.498|
0001e2  6d60              LDR      r0,[r4,#0x54]         ;1071
0001e4  f0400002          ORR      r0,r0,#2              ;1071
0001e8  6560              STR      r0,[r4,#0x54]         ;1071
0001ea  f64f70ef          MOV      r0,#0xffef            ;1072
0001ee  6821              LDR      r1,[r4,#0]            ;1072
0001f0  6088              STR      r0,[r1,#8]            ;1072
                  |L15.498|
0001f2  6d60              LDR      r0,[r4,#0x54]         ;1076
0001f4  b108              CBZ      r0,|L15.506|
0001f6  f04f0901          MOV      r9,#1                 ;1078
                  |L15.506|
0001fa  bf00              NOP                            ;1081
                  |L15.508|
0001fc  2001              MOVS     r0,#1                 ;1082
0001fe  f8840051          STRB     r0,[r4,#0x51]         ;1082
000202  bf00              NOP                            ;1083
000204  2000              MOVS     r0,#0                 ;1083
000206  f8840050          STRB     r0,[r4,#0x50]         ;1083
00020a  bf00              NOP                            ;1083
00020c  4648              MOV      r0,r9                 ;1084
00020e  e70f              B        |L15.48|
;;;1086   
                          ENDP


                          AREA ||i.HAL_SPI_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_DMA PROC
;;;1683     */
;;;1684   HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1685   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1686     HAL_StatusTypeDef errorcode = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;1687   
;;;1688     /* Check rx dma handle */
;;;1689     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
;;;1690   
;;;1691     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
00000c  68a0              LDR      r0,[r4,#8]
00000e  b970              CBNZ     r0,|L16.46|
000010  6860              LDR      r0,[r4,#4]
000012  f5b07f82          CMP      r0,#0x104
000016  d10a              BNE      |L16.46|
;;;1692     {
;;;1693       hspi->State = HAL_SPI_STATE_BUSY_RX;
000018  2004              MOVS     r0,#4
00001a  f8840051          STRB     r0,[r4,#0x51]
;;;1694   
;;;1695       /* Check tx dma handle */
;;;1696       assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1697   
;;;1698       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1699       return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
00001e  462b              MOV      r3,r5
000020  4632              MOV      r2,r6
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_SPI_TransmitReceive_DMA
                  |L16.42|
;;;1700     }
;;;1701   
;;;1702     /* Process Locked */
;;;1703     __HAL_LOCK(hspi);
;;;1704   
;;;1705     if (hspi->State != HAL_SPI_STATE_READY)
;;;1706     {
;;;1707       errorcode = HAL_BUSY;
;;;1708       goto error;
;;;1709     }
;;;1710   
;;;1711     if ((pData == NULL) || (Size == 0U))
;;;1712     {
;;;1713       errorcode = HAL_ERROR;
;;;1714       goto error;
;;;1715     }
;;;1716   
;;;1717     /* Set the transaction information */
;;;1718     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1719     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1720     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1721     hspi->RxXferSize  = Size;
;;;1722     hspi->RxXferCount = Size;
;;;1723   
;;;1724     /*Init field not used in handle to zero */
;;;1725     hspi->RxISR       = NULL;
;;;1726     hspi->TxISR       = NULL;
;;;1727     hspi->TxXferSize  = 0U;
;;;1728     hspi->TxXferCount = 0U;
;;;1729   
;;;1730     /* Configure communication direction : 1Line */
;;;1731     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1732     {
;;;1733       SPI_1LINE_RX(hspi);
;;;1734     }
;;;1735   
;;;1736   #if (USE_SPI_CRC != 0U)
;;;1737     /* Reset CRC Calculation */
;;;1738     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1739     {
;;;1740       SPI_RESET_CRC(hspi);
;;;1741     }
;;;1742   #endif /* USE_SPI_CRC */
;;;1743   
;;;1744     /* Set the SPI RxDMA Half transfer complete callback */
;;;1745     hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1746   
;;;1747     /* Set the SPI Rx DMA transfer complete callback */
;;;1748     hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
;;;1749   
;;;1750     /* Set the DMA error callback */
;;;1751     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1752   
;;;1753     /* Set the DMA AbortCpltCallback */
;;;1754     hspi->hdmarx->XferAbortCallback = NULL;
;;;1755   
;;;1756     /* Enable the Rx DMA Stream/Channel  */
;;;1757     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount))
;;;1758     {
;;;1759       /* Update SPI error code */
;;;1760       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1761       errorcode = HAL_ERROR;
;;;1762   
;;;1763       hspi->State = HAL_SPI_STATE_READY;
;;;1764       goto error;
;;;1765     }
;;;1766   
;;;1767     /* Check if the SPI is already enabled */
;;;1768     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1769     {
;;;1770       /* Enable SPI peripheral */
;;;1771       __HAL_SPI_ENABLE(hspi);
;;;1772     }
;;;1773   
;;;1774     /* Enable the SPI Error Interrupt Bit */
;;;1775     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1776   
;;;1777     /* Enable Rx DMA Request */
;;;1778     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1779   
;;;1780   error:
;;;1781     /* Process Unlocked */
;;;1782     __HAL_UNLOCK(hspi);
;;;1783     return errorcode;
;;;1784   }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.46|
00002e  bf00              NOP                            ;1703
000030  f8940050          LDRB     r0,[r4,#0x50]         ;1703
000034  2801              CMP      r0,#1                 ;1703
000036  d101              BNE      |L16.60|
000038  2002              MOVS     r0,#2                 ;1703
00003a  e7f6              B        |L16.42|
                  |L16.60|
00003c  2001              MOVS     r0,#1                 ;1703
00003e  f8840050          STRB     r0,[r4,#0x50]         ;1703
000042  bf00              NOP                            ;1703
000044  f8940051          LDRB     r0,[r4,#0x51]         ;1705
000048  2801              CMP      r0,#1                 ;1705
00004a  d001              BEQ      |L16.80|
00004c  2702              MOVS     r7,#2                 ;1707
00004e  e063              B        |L16.280|
                  |L16.80|
000050  b106              CBZ      r6,|L16.84|
000052  b90d              CBNZ     r5,|L16.88|
                  |L16.84|
000054  2701              MOVS     r7,#1                 ;1713
000056  e05f              B        |L16.280|
                  |L16.88|
000058  2004              MOVS     r0,#4                 ;1718
00005a  f8840051          STRB     r0,[r4,#0x51]         ;1718
00005e  2000              MOVS     r0,#0                 ;1719
000060  6560              STR      r0,[r4,#0x54]         ;1719
000062  63a6              STR      r6,[r4,#0x38]         ;1720
000064  87a5              STRH     r5,[r4,#0x3c]         ;1721
000066  87e5              STRH     r5,[r4,#0x3e]         ;1722
000068  6420              STR      r0,[r4,#0x40]         ;1725
00006a  6460              STR      r0,[r4,#0x44]         ;1726
00006c  86a0              STRH     r0,[r4,#0x34]         ;1727
00006e  86e0              STRH     r0,[r4,#0x36]         ;1728
000070  68a0              LDR      r0,[r4,#8]            ;1731
000072  f5b04f00          CMP      r0,#0x8000            ;1731
000076  d105              BNE      |L16.132|
000078  6820              LDR      r0,[r4,#0]            ;1733
00007a  6800              LDR      r0,[r0,#0]            ;1733
00007c  f4204080          BIC      r0,r0,#0x4000         ;1733
000080  6821              LDR      r1,[r4,#0]            ;1733
000082  6008              STR      r0,[r1,#0]            ;1733
                  |L16.132|
000084  6aa0              LDR      r0,[r4,#0x28]         ;1738
000086  f5b05f00          CMP      r0,#0x2000            ;1738
00008a  d10d              BNE      |L16.168|
00008c  bf00              NOP                            ;1740
00008e  6820              LDR      r0,[r4,#0]            ;1740
000090  6800              LDR      r0,[r0,#0]            ;1740
000092  f4205000          BIC      r0,r0,#0x2000         ;1740
000096  6821              LDR      r1,[r4,#0]            ;1740
000098  6008              STR      r0,[r1,#0]            ;1740
00009a  6820              LDR      r0,[r4,#0]            ;1740
00009c  6800              LDR      r0,[r0,#0]            ;1740
00009e  f4405000          ORR      r0,r0,#0x2000         ;1740
0000a2  6821              LDR      r1,[r4,#0]            ;1740
0000a4  6008              STR      r0,[r1,#0]            ;1740
0000a6  bf00              NOP                            ;1740
                  |L16.168|
0000a8  481f              LDR      r0,|L16.296|
0000aa  6ce1              LDR      r1,[r4,#0x4c]         ;1745
0000ac  6408              STR      r0,[r1,#0x40]         ;1745
0000ae  481f              LDR      r0,|L16.300|
0000b0  6ce1              LDR      r1,[r4,#0x4c]         ;1748
0000b2  63c8              STR      r0,[r1,#0x3c]         ;1748
0000b4  481e              LDR      r0,|L16.304|
0000b6  6ce1              LDR      r1,[r4,#0x4c]         ;1751
0000b8  64c8              STR      r0,[r1,#0x4c]         ;1751
0000ba  2000              MOVS     r0,#0                 ;1754
0000bc  6ce1              LDR      r1,[r4,#0x4c]         ;1754
0000be  6508              STR      r0,[r1,#0x50]         ;1754
0000c0  8fe3              LDRH     r3,[r4,#0x3e]         ;1757
0000c2  f8d4c000          LDR      r12,[r4,#0]           ;1757
0000c6  f10c010c          ADD      r1,r12,#0xc           ;1757
0000ca  6ba2              LDR      r2,[r4,#0x38]         ;1757
0000cc  6ce0              LDR      r0,[r4,#0x4c]         ;1757
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  b140              CBZ      r0,|L16.230|
0000d4  6d60              LDR      r0,[r4,#0x54]         ;1760
0000d6  f0400010          ORR      r0,r0,#0x10           ;1760
0000da  6560              STR      r0,[r4,#0x54]         ;1760
0000dc  2701              MOVS     r7,#1                 ;1761
0000de  2001              MOVS     r0,#1                 ;1763
0000e0  f8840051          STRB     r0,[r4,#0x51]         ;1763
0000e4  e018              B        |L16.280|
                  |L16.230|
0000e6  6820              LDR      r0,[r4,#0]            ;1768
0000e8  6800              LDR      r0,[r0,#0]            ;1768
0000ea  f0000040          AND      r0,r0,#0x40           ;1768
0000ee  2840              CMP      r0,#0x40              ;1768
0000f0  d005              BEQ      |L16.254|
0000f2  6820              LDR      r0,[r4,#0]            ;1771
0000f4  6800              LDR      r0,[r0,#0]            ;1771
0000f6  f0400040          ORR      r0,r0,#0x40           ;1771
0000fa  6821              LDR      r1,[r4,#0]            ;1771
0000fc  6008              STR      r0,[r1,#0]            ;1771
                  |L16.254|
0000fe  6820              LDR      r0,[r4,#0]            ;1775
000100  6840              LDR      r0,[r0,#4]            ;1775
000102  f0400020          ORR      r0,r0,#0x20           ;1775
000106  6821              LDR      r1,[r4,#0]            ;1775
000108  6048              STR      r0,[r1,#4]            ;1775
00010a  6820              LDR      r0,[r4,#0]            ;1778
00010c  6840              LDR      r0,[r0,#4]            ;1778
00010e  f0400001          ORR      r0,r0,#1              ;1778
000112  6821              LDR      r1,[r4,#0]            ;1778
000114  6048              STR      r0,[r1,#4]            ;1778
000116  bf00              NOP                            ;1780
                  |L16.280|
000118  bf00              NOP                            ;1782
00011a  2000              MOVS     r0,#0                 ;1782
00011c  f8840050          STRB     r0,[r4,#0x50]         ;1782
000120  bf00              NOP                            ;1782
000122  4638              MOV      r0,r7                 ;1783
000124  e781              B        |L16.42|
;;;1785   
                          ENDP

000126  0000              DCW      0x0000
                  |L16.296|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L16.300|
                          DCD      SPI_DMAReceiveCplt
                  |L16.304|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_IT PROC
;;;1398     */
;;;1399   HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1400   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1401     HAL_StatusTypeDef errorcode = HAL_OK;
000008  2700              MOVS     r7,#0
;;;1402   
;;;1403     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
00000a  68a0              LDR      r0,[r4,#8]
00000c  b968              CBNZ     r0,|L17.42|
00000e  6860              LDR      r0,[r4,#4]
000010  f5b07f82          CMP      r0,#0x104
000014  d109              BNE      |L17.42|
;;;1404     {
;;;1405       hspi->State = HAL_SPI_STATE_BUSY_RX;
000016  2004              MOVS     r0,#4
000018  f8840051          STRB     r0,[r4,#0x51]
;;;1406       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1407       return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
00001c  462b              MOV      r3,r5
00001e  4632              MOV      r2,r6
000020  4631              MOV      r1,r6
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_SPI_TransmitReceive_IT
                  |L17.40|
;;;1408     }
;;;1409   
;;;1410     /* Process Locked */
;;;1411     __HAL_LOCK(hspi);
;;;1412   
;;;1413     if (hspi->State != HAL_SPI_STATE_READY)
;;;1414     {
;;;1415       errorcode = HAL_BUSY;
;;;1416       goto error;
;;;1417     }
;;;1418   
;;;1419     if ((pData == NULL) || (Size == 0U))
;;;1420     {
;;;1421       errorcode = HAL_ERROR;
;;;1422       goto error;
;;;1423     }
;;;1424   
;;;1425     /* Set the transaction information */
;;;1426     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1427     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1428     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1429     hspi->RxXferSize  = Size;
;;;1430     hspi->RxXferCount = Size;
;;;1431   
;;;1432     /* Init field not used in handle to zero */
;;;1433     hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;1434     hspi->TxXferSize  = 0U;
;;;1435     hspi->TxXferCount = 0U;
;;;1436     hspi->TxISR       = NULL;
;;;1437   
;;;1438     /* Set the function for IT treatment */
;;;1439     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1440     {
;;;1441       hspi->RxISR = SPI_RxISR_16BIT;
;;;1442     }
;;;1443     else
;;;1444     {
;;;1445       hspi->RxISR = SPI_RxISR_8BIT;
;;;1446     }
;;;1447   
;;;1448     /* Configure communication direction : 1Line */
;;;1449     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1450     {
;;;1451       SPI_1LINE_RX(hspi);
;;;1452     }
;;;1453   
;;;1454   #if (USE_SPI_CRC != 0U)
;;;1455     /* Reset CRC Calculation */
;;;1456     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1457     {
;;;1458       SPI_RESET_CRC(hspi);
;;;1459     }
;;;1460   #endif /* USE_SPI_CRC */
;;;1461   
;;;1462     /* Enable TXE and ERR interrupt */
;;;1463     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
;;;1464   
;;;1465     /* Note : The SPI must be enabled after unlocking current process
;;;1466               to avoid the risk of SPI interrupt handle execution before current
;;;1467               process unlock */
;;;1468   
;;;1469     /* Check if the SPI is already enabled */
;;;1470     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1471     {
;;;1472       /* Enable SPI peripheral */
;;;1473       __HAL_SPI_ENABLE(hspi);
;;;1474     }
;;;1475   
;;;1476   error :
;;;1477     /* Process Unlocked */
;;;1478     __HAL_UNLOCK(hspi);
;;;1479     return errorcode;
;;;1480   }
000028  bdf0              POP      {r4-r7,pc}
                  |L17.42|
00002a  bf00              NOP                            ;1411
00002c  f8940050          LDRB     r0,[r4,#0x50]         ;1411
000030  2801              CMP      r0,#1                 ;1411
000032  d101              BNE      |L17.56|
000034  2002              MOVS     r0,#2                 ;1411
000036  e7f7              B        |L17.40|
                  |L17.56|
000038  2001              MOVS     r0,#1                 ;1411
00003a  f8840050          STRB     r0,[r4,#0x50]         ;1411
00003e  bf00              NOP                            ;1411
000040  f8940051          LDRB     r0,[r4,#0x51]         ;1413
000044  2801              CMP      r0,#1                 ;1413
000046  d001              BEQ      |L17.76|
000048  2702              MOVS     r7,#2                 ;1415
00004a  e045              B        |L17.216|
                  |L17.76|
00004c  b106              CBZ      r6,|L17.80|
00004e  b90d              CBNZ     r5,|L17.84|
                  |L17.80|
000050  2701              MOVS     r7,#1                 ;1421
000052  e041              B        |L17.216|
                  |L17.84|
000054  2004              MOVS     r0,#4                 ;1426
000056  f8840051          STRB     r0,[r4,#0x51]         ;1426
00005a  2000              MOVS     r0,#0                 ;1427
00005c  6560              STR      r0,[r4,#0x54]         ;1427
00005e  63a6              STR      r6,[r4,#0x38]         ;1428
000060  87a5              STRH     r5,[r4,#0x3c]         ;1429
000062  87e5              STRH     r5,[r4,#0x3e]         ;1430
000064  6320              STR      r0,[r4,#0x30]         ;1433
000066  86a0              STRH     r0,[r4,#0x34]         ;1434
000068  86e0              STRH     r0,[r4,#0x36]         ;1435
00006a  6460              STR      r0,[r4,#0x44]         ;1436
00006c  68e0              LDR      r0,[r4,#0xc]          ;1439
00006e  b110              CBZ      r0,|L17.118|
000070  481d              LDR      r0,|L17.232|
000072  6420              STR      r0,[r4,#0x40]         ;1441
000074  e001              B        |L17.122|
                  |L17.118|
000076  481d              LDR      r0,|L17.236|
000078  6420              STR      r0,[r4,#0x40]         ;1445
                  |L17.122|
00007a  68a0              LDR      r0,[r4,#8]            ;1449
00007c  f5b04f00          CMP      r0,#0x8000            ;1449
000080  d105              BNE      |L17.142|
000082  6820              LDR      r0,[r4,#0]            ;1451
000084  6800              LDR      r0,[r0,#0]            ;1451
000086  f4204080          BIC      r0,r0,#0x4000         ;1451
00008a  6821              LDR      r1,[r4,#0]            ;1451
00008c  6008              STR      r0,[r1,#0]            ;1451
                  |L17.142|
00008e  6aa0              LDR      r0,[r4,#0x28]         ;1456
000090  f5b05f00          CMP      r0,#0x2000            ;1456
000094  d10d              BNE      |L17.178|
000096  bf00              NOP                            ;1458
000098  6820              LDR      r0,[r4,#0]            ;1458
00009a  6800              LDR      r0,[r0,#0]            ;1458
00009c  f4205000          BIC      r0,r0,#0x2000         ;1458
0000a0  6821              LDR      r1,[r4,#0]            ;1458
0000a2  6008              STR      r0,[r1,#0]            ;1458
0000a4  6820              LDR      r0,[r4,#0]            ;1458
0000a6  6800              LDR      r0,[r0,#0]            ;1458
0000a8  f4405000          ORR      r0,r0,#0x2000         ;1458
0000ac  6821              LDR      r1,[r4,#0]            ;1458
0000ae  6008              STR      r0,[r1,#0]            ;1458
0000b0  bf00              NOP                            ;1458
                  |L17.178|
0000b2  6820              LDR      r0,[r4,#0]            ;1463
0000b4  6840              LDR      r0,[r0,#4]            ;1463
0000b6  f0400060          ORR      r0,r0,#0x60           ;1463
0000ba  6821              LDR      r1,[r4,#0]            ;1463
0000bc  6048              STR      r0,[r1,#4]            ;1463
0000be  6820              LDR      r0,[r4,#0]            ;1470
0000c0  6800              LDR      r0,[r0,#0]            ;1470
0000c2  f0000040          AND      r0,r0,#0x40           ;1470
0000c6  2840              CMP      r0,#0x40              ;1470
0000c8  d005              BEQ      |L17.214|
0000ca  6820              LDR      r0,[r4,#0]            ;1473
0000cc  6800              LDR      r0,[r0,#0]            ;1473
0000ce  f0400040          ORR      r0,r0,#0x40           ;1473
0000d2  6821              LDR      r1,[r4,#0]            ;1473
0000d4  6008              STR      r0,[r1,#0]            ;1473
                  |L17.214|
0000d6  bf00              NOP                            ;1476
                  |L17.216|
0000d8  bf00              NOP                            ;1478
0000da  2000              MOVS     r0,#0                 ;1478
0000dc  f8840050          STRB     r0,[r4,#0x50]         ;1478
0000e0  bf00              NOP                            ;1478
0000e2  4638              MOV      r0,r7                 ;1479
0000e4  e7a0              B        |L17.40|
;;;1481   
                          ENDP

0000e6  0000              DCW      0x0000
                  |L17.232|
                          DCD      SPI_RxISR_16BIT
                  |L17.236|
                          DCD      SPI_RxISR_8BIT

                          AREA ||i.HAL_SPI_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxCpltCallback PROC
;;;2450     */
;;;2451   __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2452   {
;;;2453     /* Prevent unused argument(s) compilation warning */
;;;2454     UNUSED(hspi);
;;;2455   
;;;2456     /* NOTE : This function should not be modified, when the callback is needed,
;;;2457               the HAL_SPI_RxCpltCallback should be implemented in the user file
;;;2458      */
;;;2459   }
;;;2460   
                          ENDP


                          AREA ||i.HAL_SPI_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxHalfCpltCallback PROC
;;;2498     */
;;;2499   __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2500   {
;;;2501     /* Prevent unused argument(s) compilation warning */
;;;2502     UNUSED(hspi);
;;;2503   
;;;2504     /* NOTE : This function should not be modified, when the callback is needed,
;;;2505               the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
;;;2506      */
;;;2507   }
;;;2508   
                          ENDP


                          AREA ||i.HAL_SPI_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Transmit PROC
;;;742      */
;;;743    HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;744    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;745      uint32_t tickstart;
;;;746      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0a00          MOV      r10,#0
;;;747      uint16_t initial_TxXferCount;
;;;748    
;;;749      /* Check Direction parameter */
;;;750      assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;751    
;;;752      /* Process Locked */
;;;753      __HAL_LOCK(hspi);
000010  bf00              NOP      
000012  f8940050          LDRB     r0,[r4,#0x50]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L20.32|
00001a  2002              MOVS     r0,#2
                  |L20.28|
;;;754    
;;;755      /* Init tickstart for timeout management*/
;;;756      tickstart = HAL_GetTick();
;;;757      initial_TxXferCount = Size;
;;;758    
;;;759      if (hspi->State != HAL_SPI_STATE_READY)
;;;760      {
;;;761        errorcode = HAL_BUSY;
;;;762        goto error;
;;;763      }
;;;764    
;;;765      if ((pData == NULL) || (Size == 0U))
;;;766      {
;;;767        errorcode = HAL_ERROR;
;;;768        goto error;
;;;769      }
;;;770    
;;;771      /* Set the transaction information */
;;;772      hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;773      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;774      hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;775      hspi->TxXferSize  = Size;
;;;776      hspi->TxXferCount = Size;
;;;777    
;;;778      /*Init field not used in handle to zero */
;;;779      hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;780      hspi->RxXferSize  = 0U;
;;;781      hspi->RxXferCount = 0U;
;;;782      hspi->TxISR       = NULL;
;;;783      hspi->RxISR       = NULL;
;;;784    
;;;785      /* Configure communication direction : 1Line */
;;;786      if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;787      {
;;;788        SPI_1LINE_TX(hspi);
;;;789      }
;;;790    
;;;791    #if (USE_SPI_CRC != 0U)
;;;792      /* Reset CRC Calculation */
;;;793      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;794      {
;;;795        SPI_RESET_CRC(hspi);
;;;796      }
;;;797    #endif /* USE_SPI_CRC */
;;;798    
;;;799      /* Check if the SPI is already enabled */
;;;800      if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;801      {
;;;802        /* Enable SPI peripheral */
;;;803        __HAL_SPI_ENABLE(hspi);
;;;804      }
;;;805    
;;;806      /* Transmit data in 16 Bit mode */
;;;807      if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;808      {
;;;809        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;810        {
;;;811          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;812          hspi->pTxBuffPtr += sizeof(uint16_t);
;;;813          hspi->TxXferCount--;
;;;814        }
;;;815        /* Transmit data in 16 Bit mode */
;;;816        while (hspi->TxXferCount > 0U)
;;;817        {
;;;818          /* Wait until TXE flag is set to send data */
;;;819          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;820          {
;;;821            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;822            hspi->pTxBuffPtr += sizeof(uint16_t);
;;;823            hspi->TxXferCount--;
;;;824          }
;;;825          else
;;;826          {
;;;827            /* Timeout management */
;;;828            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;829            {
;;;830              errorcode = HAL_TIMEOUT;
;;;831              goto error;
;;;832            }
;;;833          }
;;;834        }
;;;835      }
;;;836      /* Transmit data in 8 Bit mode */
;;;837      else
;;;838      {
;;;839        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;840        {
;;;841          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;842          hspi->pTxBuffPtr += sizeof(uint8_t);
;;;843          hspi->TxXferCount--;
;;;844        }
;;;845        while (hspi->TxXferCount > 0U)
;;;846        {
;;;847          /* Wait until TXE flag is set to send data */
;;;848          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;849          {
;;;850            *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;851            hspi->pTxBuffPtr += sizeof(uint8_t);
;;;852            hspi->TxXferCount--;
;;;853          }
;;;854          else
;;;855          {
;;;856            /* Timeout management */
;;;857            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;858            {
;;;859              errorcode = HAL_TIMEOUT;
;;;860              goto error;
;;;861            }
;;;862          }
;;;863        }
;;;864      }
;;;865    #if (USE_SPI_CRC != 0U)
;;;866      /* Enable CRC Transmission */
;;;867      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;868      {
;;;869        SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;870      }
;;;871    #endif /* USE_SPI_CRC */
;;;872    
;;;873      /* Check the end of the transaction */
;;;874      if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;875      {
;;;876        hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;877      }
;;;878    
;;;879      /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;880      if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;881      {
;;;882        __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;883      }
;;;884    
;;;885      if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;886      {
;;;887        errorcode = HAL_ERROR;
;;;888      }
;;;889    
;;;890    error:
;;;891      hspi->State = HAL_SPI_STATE_READY;
;;;892      /* Process Unlocked */
;;;893      __HAL_UNLOCK(hspi);
;;;894      return errorcode;
;;;895    }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.32|
000020  2001              MOVS     r0,#1                 ;753
000022  f8840050          STRB     r0,[r4,#0x50]         ;753
000026  bf00              NOP                            ;753
000028  f7fffffe          BL       HAL_GetTick
00002c  4607              MOV      r7,r0                 ;756
00002e  46b1              MOV      r9,r6                 ;757
000030  f8940051          LDRB     r0,[r4,#0x51]         ;759
000034  2801              CMP      r0,#1                 ;759
000036  d002              BEQ      |L20.62|
000038  f04f0a02          MOV      r10,#2                ;761
00003c  e0c3              B        |L20.454|
                  |L20.62|
00003e  f1b80f00          CMP      r8,#0                 ;765
000042  d000              BEQ      |L20.70|
000044  b916              CBNZ     r6,|L20.76|
                  |L20.70|
000046  f04f0a01          MOV      r10,#1                ;767
00004a  e0bc              B        |L20.454|
                  |L20.76|
00004c  2003              MOVS     r0,#3                 ;772
00004e  f8840051          STRB     r0,[r4,#0x51]         ;772
000052  2000              MOVS     r0,#0                 ;773
000054  6560              STR      r0,[r4,#0x54]         ;773
000056  f8c48030          STR      r8,[r4,#0x30]         ;774
00005a  86a6              STRH     r6,[r4,#0x34]         ;775
00005c  86e6              STRH     r6,[r4,#0x36]         ;776
00005e  63a0              STR      r0,[r4,#0x38]         ;779
000060  87a0              STRH     r0,[r4,#0x3c]         ;780
000062  87e0              STRH     r0,[r4,#0x3e]         ;781
000064  6460              STR      r0,[r4,#0x44]         ;782
000066  6420              STR      r0,[r4,#0x40]         ;783
000068  68a0              LDR      r0,[r4,#8]            ;786
00006a  f5b04f00          CMP      r0,#0x8000            ;786
00006e  d105              BNE      |L20.124|
000070  6820              LDR      r0,[r4,#0]            ;788
000072  6800              LDR      r0,[r0,#0]            ;788
000074  f4404080          ORR      r0,r0,#0x4000         ;788
000078  6821              LDR      r1,[r4,#0]            ;788
00007a  6008              STR      r0,[r1,#0]            ;788
                  |L20.124|
00007c  6aa0              LDR      r0,[r4,#0x28]         ;793
00007e  f5b05f00          CMP      r0,#0x2000            ;793
000082  d10d              BNE      |L20.160|
000084  bf00              NOP                            ;795
000086  6820              LDR      r0,[r4,#0]            ;795
000088  6800              LDR      r0,[r0,#0]            ;795
00008a  f4205000          BIC      r0,r0,#0x2000         ;795
00008e  6821              LDR      r1,[r4,#0]            ;795
000090  6008              STR      r0,[r1,#0]            ;795
000092  6820              LDR      r0,[r4,#0]            ;795
000094  6800              LDR      r0,[r0,#0]            ;795
000096  f4405000          ORR      r0,r0,#0x2000         ;795
00009a  6821              LDR      r1,[r4,#0]            ;795
00009c  6008              STR      r0,[r1,#0]            ;795
00009e  bf00              NOP                            ;795
                  |L20.160|
0000a0  6820              LDR      r0,[r4,#0]            ;800
0000a2  6800              LDR      r0,[r0,#0]            ;800
0000a4  f0000040          AND      r0,r0,#0x40           ;800
0000a8  2840              CMP      r0,#0x40              ;800
0000aa  d005              BEQ      |L20.184|
0000ac  6820              LDR      r0,[r4,#0]            ;803
0000ae  6800              LDR      r0,[r0,#0]            ;803
0000b0  f0400040          ORR      r0,r0,#0x40           ;803
0000b4  6821              LDR      r1,[r4,#0]            ;803
0000b6  6008              STR      r0,[r1,#0]            ;803
                  |L20.184|
0000b8  68e0              LDR      r0,[r4,#0xc]          ;807
0000ba  f5b06f00          CMP      r0,#0x800             ;807
0000be  d12f              BNE      |L20.288|
0000c0  6860              LDR      r0,[r4,#4]            ;809
0000c2  b110              CBZ      r0,|L20.202|
0000c4  f1b90f01          CMP      r9,#1                 ;809
0000c8  d109              BNE      |L20.222|
                  |L20.202|
0000ca  6b20              LDR      r0,[r4,#0x30]         ;811
0000cc  8800              LDRH     r0,[r0,#0]            ;811
0000ce  6821              LDR      r1,[r4,#0]            ;811
0000d0  60c8              STR      r0,[r1,#0xc]          ;811
0000d2  6b20              LDR      r0,[r4,#0x30]         ;812
0000d4  1c80              ADDS     r0,r0,#2              ;812
0000d6  6320              STR      r0,[r4,#0x30]         ;812
0000d8  8ee0              LDRH     r0,[r4,#0x36]         ;813
0000da  1e40              SUBS     r0,r0,#1              ;813
0000dc  86e0              STRH     r0,[r4,#0x36]         ;813
                  |L20.222|
0000de  e01b              B        |L20.280|
                  |L20.224|
0000e0  6820              LDR      r0,[r4,#0]            ;819
0000e2  6880              LDR      r0,[r0,#8]            ;819
0000e4  f0000002          AND      r0,r0,#2              ;819
0000e8  2802              CMP      r0,#2                 ;819
0000ea  d10a              BNE      |L20.258|
0000ec  6b20              LDR      r0,[r4,#0x30]         ;821
0000ee  8800              LDRH     r0,[r0,#0]            ;821
0000f0  6821              LDR      r1,[r4,#0]            ;821
0000f2  60c8              STR      r0,[r1,#0xc]          ;821
0000f4  6b20              LDR      r0,[r4,#0x30]         ;822
0000f6  1c80              ADDS     r0,r0,#2              ;822
0000f8  6320              STR      r0,[r4,#0x30]         ;822
0000fa  8ee0              LDRH     r0,[r4,#0x36]         ;823
0000fc  1e40              SUBS     r0,r0,#1              ;823
0000fe  86e0              STRH     r0,[r4,#0x36]         ;823
000100  e00a              B        |L20.280|
                  |L20.258|
000102  f7fffffe          BL       HAL_GetTick
000106  1bc0              SUBS     r0,r0,r7              ;828
000108  42a8              CMP      r0,r5                 ;828
00010a  d301              BCC      |L20.272|
00010c  1c68              ADDS     r0,r5,#1              ;828
00010e  b900              CBNZ     r0,|L20.274|
                  |L20.272|
000110  b915              CBNZ     r5,|L20.280|
                  |L20.274|
000112  f04f0a03          MOV      r10,#3                ;830
000116  e056              B        |L20.454|
                  |L20.280|
000118  8ee0              LDRH     r0,[r4,#0x36]         ;816
00011a  2800              CMP      r0,#0                 ;816
00011c  d1e0              BNE      |L20.224|
00011e  e02e              B        |L20.382|
                  |L20.288|
000120  6860              LDR      r0,[r4,#4]            ;839
000122  b110              CBZ      r0,|L20.298|
000124  f1b90f01          CMP      r9,#1                 ;839
000128  d109              BNE      |L20.318|
                  |L20.298|
00012a  6b20              LDR      r0,[r4,#0x30]         ;841
00012c  7800              LDRB     r0,[r0,#0]            ;841
00012e  6821              LDR      r1,[r4,#0]            ;841
000130  7308              STRB     r0,[r1,#0xc]          ;841
000132  6b20              LDR      r0,[r4,#0x30]         ;842
000134  1c40              ADDS     r0,r0,#1              ;842
000136  6320              STR      r0,[r4,#0x30]         ;842
000138  8ee0              LDRH     r0,[r4,#0x36]         ;843
00013a  1e40              SUBS     r0,r0,#1              ;843
00013c  86e0              STRH     r0,[r4,#0x36]         ;843
                  |L20.318|
00013e  e01b              B        |L20.376|
                  |L20.320|
000140  6820              LDR      r0,[r4,#0]            ;848
000142  6880              LDR      r0,[r0,#8]            ;848
000144  f0000002          AND      r0,r0,#2              ;848
000148  2802              CMP      r0,#2                 ;848
00014a  d10a              BNE      |L20.354|
00014c  6b20              LDR      r0,[r4,#0x30]         ;850
00014e  7800              LDRB     r0,[r0,#0]            ;850
000150  6821              LDR      r1,[r4,#0]            ;850
000152  7308              STRB     r0,[r1,#0xc]          ;850
000154  6b20              LDR      r0,[r4,#0x30]         ;851
000156  1c40              ADDS     r0,r0,#1              ;851
000158  6320              STR      r0,[r4,#0x30]         ;851
00015a  8ee0              LDRH     r0,[r4,#0x36]         ;852
00015c  1e40              SUBS     r0,r0,#1              ;852
00015e  86e0              STRH     r0,[r4,#0x36]         ;852
000160  e00a              B        |L20.376|
                  |L20.354|
000162  f7fffffe          BL       HAL_GetTick
000166  1bc0              SUBS     r0,r0,r7              ;857
000168  42a8              CMP      r0,r5                 ;857
00016a  d301              BCC      |L20.368|
00016c  1c68              ADDS     r0,r5,#1              ;857
00016e  b900              CBNZ     r0,|L20.370|
                  |L20.368|
000170  b915              CBNZ     r5,|L20.376|
                  |L20.370|
000172  f04f0a03          MOV      r10,#3                ;859
000176  e026              B        |L20.454|
                  |L20.376|
000178  8ee0              LDRH     r0,[r4,#0x36]         ;845
00017a  2800              CMP      r0,#0                 ;845
00017c  d1e0              BNE      |L20.320|
                  |L20.382|
00017e  6aa0              LDR      r0,[r4,#0x28]         ;867
000180  f5b05f00          CMP      r0,#0x2000            ;867
000184  d105              BNE      |L20.402|
000186  6820              LDR      r0,[r4,#0]            ;869
000188  6800              LDR      r0,[r0,#0]            ;869
00018a  f4405080          ORR      r0,r0,#0x1000         ;869
00018e  6821              LDR      r1,[r4,#0]            ;869
000190  6008              STR      r0,[r1,#0]            ;869
                  |L20.402|
000192  463a              MOV      r2,r7                 ;874
000194  4629              MOV      r1,r5                 ;874
000196  4620              MOV      r0,r4                 ;874
000198  f7fffffe          BL       SPI_EndRxTxTransaction
00019c  b108              CBZ      r0,|L20.418|
00019e  2020              MOVS     r0,#0x20              ;876
0001a0  6560              STR      r0,[r4,#0x54]         ;876
                  |L20.418|
0001a2  68a0              LDR      r0,[r4,#8]            ;880
0001a4  b950              CBNZ     r0,|L20.444|
0001a6  bf00              NOP                            ;882
0001a8  2000              MOVS     r0,#0                 ;882
0001aa  9000              STR      r0,[sp,#0]            ;882
0001ac  6820              LDR      r0,[r4,#0]            ;882
0001ae  68c0              LDR      r0,[r0,#0xc]          ;882
0001b0  9000              STR      r0,[sp,#0]            ;882
0001b2  6820              LDR      r0,[r4,#0]            ;882
0001b4  6880              LDR      r0,[r0,#8]            ;882
0001b6  9000              STR      r0,[sp,#0]            ;882
0001b8  bf00              NOP                            ;882
0001ba  bf00              NOP                            ;882
                  |L20.444|
0001bc  6d60              LDR      r0,[r4,#0x54]         ;885
0001be  b108              CBZ      r0,|L20.452|
0001c0  f04f0a01          MOV      r10,#1                ;887
                  |L20.452|
0001c4  bf00              NOP                            ;890
                  |L20.454|
0001c6  2001              MOVS     r0,#1                 ;891
0001c8  f8840051          STRB     r0,[r4,#0x51]         ;891
0001cc  bf00              NOP                            ;893
0001ce  2000              MOVS     r0,#0                 ;893
0001d0  f8840050          STRB     r0,[r4,#0x50]         ;893
0001d4  bf00              NOP                            ;893
0001d6  4650              MOV      r0,r10                ;894
0001d8  e720              B        |L20.28|
;;;896    
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TransmitReceive PROC
;;;1096     */
;;;1097   HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1098                                             uint32_t Timeout)
;;;1099   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
00000c  9e0e              LDR      r6,[sp,#0x38]
;;;1100     uint16_t             initial_TxXferCount;
;;;1101     uint32_t             tmp_mode;
;;;1102     HAL_SPI_StateTypeDef tmp_state;
;;;1103     uint32_t             tickstart;
;;;1104   
;;;1105     /* Variable used to alternate Rx and Tx during transfer */
;;;1106     uint32_t             txallowed = 1U;
00000e  2001              MOVS     r0,#1
000010  9002              STR      r0,[sp,#8]
;;;1107     HAL_StatusTypeDef    errorcode = HAL_OK;
000012  2000              MOVS     r0,#0
000014  9001              STR      r0,[sp,#4]
;;;1108   
;;;1109     /* Check Direction parameter */
;;;1110     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1111   
;;;1112     /* Process Locked */
;;;1113     __HAL_LOCK(hspi);
000016  bf00              NOP      
000018  f8940050          LDRB     r0,[r4,#0x50]
00001c  2801              CMP      r0,#1
00001e  d103              BNE      |L21.40|
000020  2002              MOVS     r0,#2
                  |L21.34|
;;;1114   
;;;1115     /* Init tickstart for timeout management*/
;;;1116     tickstart = HAL_GetTick();
;;;1117   
;;;1118     /* Init temporary variables */
;;;1119     tmp_state           = hspi->State;
;;;1120     tmp_mode            = hspi->Init.Mode;
;;;1121     initial_TxXferCount = Size;
;;;1122   
;;;1123     if (!((tmp_state == HAL_SPI_STATE_READY) || \
;;;1124           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1125     {
;;;1126       errorcode = HAL_BUSY;
;;;1127       goto error;
;;;1128     }
;;;1129   
;;;1130     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1131     {
;;;1132       errorcode = HAL_ERROR;
;;;1133       goto error;
;;;1134     }
;;;1135   
;;;1136     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1137     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1138     {
;;;1139       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1140     }
;;;1141   
;;;1142     /* Set the transaction information */
;;;1143     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1144     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1145     hspi->RxXferCount = Size;
;;;1146     hspi->RxXferSize  = Size;
;;;1147     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1148     hspi->TxXferCount = Size;
;;;1149     hspi->TxXferSize  = Size;
;;;1150   
;;;1151     /*Init field not used in handle to zero */
;;;1152     hspi->RxISR       = NULL;
;;;1153     hspi->TxISR       = NULL;
;;;1154   
;;;1155   #if (USE_SPI_CRC != 0U)
;;;1156     /* Reset CRC Calculation */
;;;1157     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1158     {
;;;1159       SPI_RESET_CRC(hspi);
;;;1160     }
;;;1161   #endif /* USE_SPI_CRC */
;;;1162   
;;;1163     /* Check if the SPI is already enabled */
;;;1164     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1165     {
;;;1166       /* Enable SPI peripheral */
;;;1167       __HAL_SPI_ENABLE(hspi);
;;;1168     }
;;;1169   
;;;1170     /* Transmit and Receive data in 16 Bit mode */
;;;1171     if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1172     {
;;;1173       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1174       {
;;;1175         hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1176         hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1177         hspi->TxXferCount--;
;;;1178       }
;;;1179       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1180       {
;;;1181         /* Check TXE flag */
;;;1182         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1183         {
;;;1184           hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1185           hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1186           hspi->TxXferCount--;
;;;1187           /* Next Data is a reception (Rx). Tx not allowed */
;;;1188           txallowed = 0U;
;;;1189   
;;;1190   #if (USE_SPI_CRC != 0U)
;;;1191           /* Enable CRC Transmission */
;;;1192           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1193           {
;;;1194             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1195           }
;;;1196   #endif /* USE_SPI_CRC */
;;;1197         }
;;;1198   
;;;1199         /* Check RXNE flag */
;;;1200         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1201         {
;;;1202           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1203           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1204           hspi->RxXferCount--;
;;;1205           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1206           txallowed = 1U;
;;;1207         }
;;;1208         if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
;;;1209         {
;;;1210           errorcode = HAL_TIMEOUT;
;;;1211           goto error;
;;;1212         }
;;;1213       }
;;;1214     }
;;;1215     /* Transmit and Receive data in 8 Bit mode */
;;;1216     else
;;;1217     {
;;;1218       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1219       {
;;;1220         *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;1221         hspi->pTxBuffPtr += sizeof(uint8_t);
;;;1222         hspi->TxXferCount--;
;;;1223       }
;;;1224       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1225       {
;;;1226         /* Check TXE flag */
;;;1227         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1228         {
;;;1229           *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
;;;1230           hspi->pTxBuffPtr++;
;;;1231           hspi->TxXferCount--;
;;;1232           /* Next Data is a reception (Rx). Tx not allowed */
;;;1233           txallowed = 0U;
;;;1234   
;;;1235   #if (USE_SPI_CRC != 0U)
;;;1236           /* Enable CRC Transmission */
;;;1237           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1238           {
;;;1239             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1240           }
;;;1241   #endif /* USE_SPI_CRC */
;;;1242         }
;;;1243   
;;;1244         /* Wait until RXNE flag is reset */
;;;1245         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1246         {
;;;1247           (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
;;;1248           hspi->pRxBuffPtr++;
;;;1249           hspi->RxXferCount--;
;;;1250           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1251           txallowed = 1U;
;;;1252         }
;;;1253         if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
;;;1254         {
;;;1255           errorcode = HAL_TIMEOUT;
;;;1256           goto error;
;;;1257         }
;;;1258       }
;;;1259     }
;;;1260   
;;;1261   #if (USE_SPI_CRC != 0U)
;;;1262     /* Read CRC from DR to close CRC calculation process */
;;;1263     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1264     {
;;;1265       /* Wait until TXE flag */
;;;1266       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1267       {
;;;1268         /* Error on the CRC reception */
;;;1269         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1270         errorcode = HAL_TIMEOUT;
;;;1271         goto error;
;;;1272       }
;;;1273       /* Read CRC */
;;;1274       READ_REG(hspi->Instance->DR);
;;;1275     }
;;;1276   
;;;1277     /* Check if CRC error occurred */
;;;1278     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
;;;1279     {
;;;1280       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1281       /* Clear CRC Flag */
;;;1282       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1283   
;;;1284       errorcode = HAL_ERROR;
;;;1285     }
;;;1286   #endif /* USE_SPI_CRC */
;;;1287   
;;;1288     /* Check the end of the transaction */
;;;1289     if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1290     {
;;;1291       errorcode = HAL_ERROR;
;;;1292       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1293       goto error;
;;;1294     }
;;;1295   
;;;1296     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;1297     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;1298     {
;;;1299       __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;1300     }
;;;1301   
;;;1302   error :
;;;1303     hspi->State = HAL_SPI_STATE_READY;
;;;1304     __HAL_UNLOCK(hspi);
;;;1305     return errorcode;
;;;1306   }
000022  b004              ADD      sp,sp,#0x10
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L21.40|
000028  2001              MOVS     r0,#1                 ;1113
00002a  f8840050          STRB     r0,[r4,#0x50]         ;1113
00002e  bf00              NOP                            ;1113
000030  f7fffffe          BL       HAL_GetTick
000034  4607              MOV      r7,r0                 ;1116
000036  f894b051          LDRB     r11,[r4,#0x51]        ;1119
00003a  6860              LDR      r0,[r4,#4]            ;1120
00003c  9003              STR      r0,[sp,#0xc]          ;1120
00003e  46aa              MOV      r10,r5                ;1121
000040  f1bb0f01          CMP      r11,#1                ;1123
000044  d00b              BEQ      |L21.94|
000046  9803              LDR      r0,[sp,#0xc]          ;1123
000048  f5b07f82          CMP      r0,#0x104             ;1123
00004c  d104              BNE      |L21.88|
00004e  68a0              LDR      r0,[r4,#8]            ;1123
000050  b910              CBNZ     r0,|L21.88|
000052  f1bb0f04          CMP      r11,#4                ;1123
000056  d002              BEQ      |L21.94|
                  |L21.88|
000058  2002              MOVS     r0,#2                 ;1126
00005a  9001              STR      r0,[sp,#4]            ;1126
00005c  e12a              B        |L21.692|
                  |L21.94|
00005e  f1b80f00          CMP      r8,#0                 ;1130
000062  d003              BEQ      |L21.108|
000064  f1b90f00          CMP      r9,#0                 ;1130
000068  d000              BEQ      |L21.108|
00006a  b915              CBNZ     r5,|L21.114|
                  |L21.108|
00006c  2001              MOVS     r0,#1                 ;1132
00006e  9001              STR      r0,[sp,#4]            ;1132
000070  e120              B        |L21.692|
                  |L21.114|
000072  f8940051          LDRB     r0,[r4,#0x51]         ;1137
000076  2804              CMP      r0,#4                 ;1137
000078  d002              BEQ      |L21.128|
00007a  2005              MOVS     r0,#5                 ;1139
00007c  f8840051          STRB     r0,[r4,#0x51]         ;1139
                  |L21.128|
000080  2000              MOVS     r0,#0                 ;1143
000082  6560              STR      r0,[r4,#0x54]         ;1143
000084  f8c49038          STR      r9,[r4,#0x38]         ;1144
000088  87e5              STRH     r5,[r4,#0x3e]         ;1145
00008a  87a5              STRH     r5,[r4,#0x3c]         ;1146
00008c  f8c48030          STR      r8,[r4,#0x30]         ;1147
000090  86e5              STRH     r5,[r4,#0x36]         ;1148
000092  86a5              STRH     r5,[r4,#0x34]         ;1149
000094  6420              STR      r0,[r4,#0x40]         ;1152
000096  6460              STR      r0,[r4,#0x44]         ;1153
000098  6aa0              LDR      r0,[r4,#0x28]         ;1157
00009a  f5b05f00          CMP      r0,#0x2000            ;1157
00009e  d10d              BNE      |L21.188|
0000a0  bf00              NOP                            ;1159
0000a2  6820              LDR      r0,[r4,#0]            ;1159
0000a4  6800              LDR      r0,[r0,#0]            ;1159
0000a6  f4205000          BIC      r0,r0,#0x2000         ;1159
0000aa  6821              LDR      r1,[r4,#0]            ;1159
0000ac  6008              STR      r0,[r1,#0]            ;1159
0000ae  6820              LDR      r0,[r4,#0]            ;1159
0000b0  6800              LDR      r0,[r0,#0]            ;1159
0000b2  f4405000          ORR      r0,r0,#0x2000         ;1159
0000b6  6821              LDR      r1,[r4,#0]            ;1159
0000b8  6008              STR      r0,[r1,#0]            ;1159
0000ba  bf00              NOP                            ;1159
                  |L21.188|
0000bc  6820              LDR      r0,[r4,#0]            ;1164
0000be  6800              LDR      r0,[r0,#0]            ;1164
0000c0  f0000040          AND      r0,r0,#0x40           ;1164
0000c4  2840              CMP      r0,#0x40              ;1164
0000c6  d005              BEQ      |L21.212|
0000c8  6820              LDR      r0,[r4,#0]            ;1167
0000ca  6800              LDR      r0,[r0,#0]            ;1167
0000cc  f0400040          ORR      r0,r0,#0x40           ;1167
0000d0  6821              LDR      r1,[r4,#0]            ;1167
0000d2  6008              STR      r0,[r1,#0]            ;1167
                  |L21.212|
0000d4  68e0              LDR      r0,[r4,#0xc]          ;1171
0000d6  f5b06f00          CMP      r0,#0x800             ;1171
0000da  d156              BNE      |L21.394|
0000dc  6860              LDR      r0,[r4,#4]            ;1173
0000de  b110              CBZ      r0,|L21.230|
0000e0  f1ba0f01          CMP      r10,#1                ;1173
0000e4  d109              BNE      |L21.250|
                  |L21.230|
0000e6  6b20              LDR      r0,[r4,#0x30]         ;1175
0000e8  8800              LDRH     r0,[r0,#0]            ;1175
0000ea  6821              LDR      r1,[r4,#0]            ;1175
0000ec  60c8              STR      r0,[r1,#0xc]          ;1175
0000ee  6b20              LDR      r0,[r4,#0x30]         ;1176
0000f0  1c80              ADDS     r0,r0,#2              ;1176
0000f2  6320              STR      r0,[r4,#0x30]         ;1176
0000f4  8ee0              LDRH     r0,[r4,#0x36]         ;1177
0000f6  1e40              SUBS     r0,r0,#1              ;1177
0000f8  86e0              STRH     r0,[r4,#0x36]         ;1177
                  |L21.250|
0000fa  e03f              B        |L21.380|
                  |L21.252|
0000fc  6820              LDR      r0,[r4,#0]            ;1182
0000fe  6880              LDR      r0,[r0,#8]            ;1182
000100  f0000002          AND      r0,r0,#2              ;1182
000104  2802              CMP      r0,#2                 ;1182
000106  d11c              BNE      |L21.322|
000108  8ee0              LDRH     r0,[r4,#0x36]         ;1182
00010a  b1d0              CBZ      r0,|L21.322|
00010c  9802              LDR      r0,[sp,#8]            ;1182
00010e  2801              CMP      r0,#1                 ;1182
000110  d117              BNE      |L21.322|
000112  6b20              LDR      r0,[r4,#0x30]         ;1184
000114  8800              LDRH     r0,[r0,#0]            ;1184
000116  6821              LDR      r1,[r4,#0]            ;1184
000118  60c8              STR      r0,[r1,#0xc]          ;1184
00011a  6b20              LDR      r0,[r4,#0x30]         ;1185
00011c  1c80              ADDS     r0,r0,#2              ;1185
00011e  6320              STR      r0,[r4,#0x30]         ;1185
000120  8ee0              LDRH     r0,[r4,#0x36]         ;1186
000122  1e40              SUBS     r0,r0,#1              ;1186
000124  86e0              STRH     r0,[r4,#0x36]         ;1186
000126  2000              MOVS     r0,#0                 ;1188
000128  9002              STR      r0,[sp,#8]            ;1188
00012a  8ee0              LDRH     r0,[r4,#0x36]         ;1192
00012c  b948              CBNZ     r0,|L21.322|
00012e  6aa0              LDR      r0,[r4,#0x28]         ;1192
000130  f5b05f00          CMP      r0,#0x2000            ;1192
000134  d105              BNE      |L21.322|
000136  6820              LDR      r0,[r4,#0]            ;1194
000138  6800              LDR      r0,[r0,#0]            ;1194
00013a  f4405080          ORR      r0,r0,#0x1000         ;1194
00013e  6821              LDR      r1,[r4,#0]            ;1194
000140  6008              STR      r0,[r1,#0]            ;1194
                  |L21.322|
000142  6820              LDR      r0,[r4,#0]            ;1200
000144  6880              LDR      r0,[r0,#8]            ;1200
000146  f0000001          AND      r0,r0,#1              ;1200
00014a  b168              CBZ      r0,|L21.360|
00014c  8fe0              LDRH     r0,[r4,#0x3e]         ;1200
00014e  b158              CBZ      r0,|L21.360|
000150  6820              LDR      r0,[r4,#0]            ;1202
000152  68c0              LDR      r0,[r0,#0xc]          ;1202
000154  6ba1              LDR      r1,[r4,#0x38]         ;1202
000156  8008              STRH     r0,[r1,#0]            ;1202
000158  6ba0              LDR      r0,[r4,#0x38]         ;1203
00015a  1c80              ADDS     r0,r0,#2              ;1203
00015c  63a0              STR      r0,[r4,#0x38]         ;1203
00015e  8fe0              LDRH     r0,[r4,#0x3e]         ;1204
000160  1e40              SUBS     r0,r0,#1              ;1204
000162  87e0              STRH     r0,[r4,#0x3e]         ;1204
000164  2001              MOVS     r0,#1                 ;1206
000166  9002              STR      r0,[sp,#8]            ;1206
                  |L21.360|
000168  f7fffffe          BL       HAL_GetTick
00016c  1bc0              SUBS     r0,r0,r7              ;1208
00016e  42b0              CMP      r0,r6                 ;1208
000170  d304              BCC      |L21.380|
000172  1c70              ADDS     r0,r6,#1              ;1208
000174  b110              CBZ      r0,|L21.380|
000176  2003              MOVS     r0,#3                 ;1210
000178  9001              STR      r0,[sp,#4]            ;1210
00017a  e09b              B        |L21.692|
                  |L21.380|
00017c  8ee0              LDRH     r0,[r4,#0x36]         ;1179
00017e  2800              CMP      r0,#0                 ;1179
000180  d1bc              BNE      |L21.252|
000182  8fe0              LDRH     r0,[r4,#0x3e]         ;1179
000184  2800              CMP      r0,#0                 ;1179
000186  d1b9              BNE      |L21.252|
000188  e056              B        |L21.568|
                  |L21.394|
00018a  6860              LDR      r0,[r4,#4]            ;1218
00018c  b110              CBZ      r0,|L21.404|
00018e  f1ba0f01          CMP      r10,#1                ;1218
000192  d109              BNE      |L21.424|
                  |L21.404|
000194  6b20              LDR      r0,[r4,#0x30]         ;1220
000196  7800              LDRB     r0,[r0,#0]            ;1220
000198  6821              LDR      r1,[r4,#0]            ;1220
00019a  7308              STRB     r0,[r1,#0xc]          ;1220
00019c  6b20              LDR      r0,[r4,#0x30]         ;1221
00019e  1c40              ADDS     r0,r0,#1              ;1221
0001a0  6320              STR      r0,[r4,#0x30]         ;1221
0001a2  8ee0              LDRH     r0,[r4,#0x36]         ;1222
0001a4  1e40              SUBS     r0,r0,#1              ;1222
0001a6  86e0              STRH     r0,[r4,#0x36]         ;1222
                  |L21.424|
0001a8  e040              B        |L21.556|
                  |L21.426|
0001aa  6820              LDR      r0,[r4,#0]            ;1227
0001ac  6880              LDR      r0,[r0,#8]            ;1227
0001ae  f0000002          AND      r0,r0,#2              ;1227
0001b2  2802              CMP      r0,#2                 ;1227
0001b4  d11c              BNE      |L21.496|
0001b6  8ee0              LDRH     r0,[r4,#0x36]         ;1227
0001b8  b1d0              CBZ      r0,|L21.496|
0001ba  9802              LDR      r0,[sp,#8]            ;1227
0001bc  2801              CMP      r0,#1                 ;1227
0001be  d117              BNE      |L21.496|
0001c0  6b20              LDR      r0,[r4,#0x30]         ;1229
0001c2  7800              LDRB     r0,[r0,#0]            ;1229
0001c4  6821              LDR      r1,[r4,#0]            ;1229
0001c6  7308              STRB     r0,[r1,#0xc]          ;1229
0001c8  6b20              LDR      r0,[r4,#0x30]         ;1230
0001ca  1c40              ADDS     r0,r0,#1              ;1230
0001cc  6320              STR      r0,[r4,#0x30]         ;1230
0001ce  8ee0              LDRH     r0,[r4,#0x36]         ;1231
0001d0  1e40              SUBS     r0,r0,#1              ;1231
0001d2  86e0              STRH     r0,[r4,#0x36]         ;1231
0001d4  2000              MOVS     r0,#0                 ;1233
0001d6  9002              STR      r0,[sp,#8]            ;1233
0001d8  8ee0              LDRH     r0,[r4,#0x36]         ;1237
0001da  b948              CBNZ     r0,|L21.496|
0001dc  6aa0              LDR      r0,[r4,#0x28]         ;1237
0001de  f5b05f00          CMP      r0,#0x2000            ;1237
0001e2  d105              BNE      |L21.496|
0001e4  6820              LDR      r0,[r4,#0]            ;1239
0001e6  6800              LDR      r0,[r0,#0]            ;1239
0001e8  f4405080          ORR      r0,r0,#0x1000         ;1239
0001ec  6821              LDR      r1,[r4,#0]            ;1239
0001ee  6008              STR      r0,[r1,#0]            ;1239
                  |L21.496|
0001f0  6820              LDR      r0,[r4,#0]            ;1245
0001f2  6880              LDR      r0,[r0,#8]            ;1245
0001f4  f0000001          AND      r0,r0,#1              ;1245
0001f8  b168              CBZ      r0,|L21.534|
0001fa  8fe0              LDRH     r0,[r4,#0x3e]         ;1245
0001fc  b158              CBZ      r0,|L21.534|
0001fe  6820              LDR      r0,[r4,#0]            ;1247
000200  68c0              LDR      r0,[r0,#0xc]          ;1247
000202  6ba1              LDR      r1,[r4,#0x38]         ;1247
000204  7008              STRB     r0,[r1,#0]            ;1247
000206  6ba0              LDR      r0,[r4,#0x38]         ;1248
000208  1c40              ADDS     r0,r0,#1              ;1248
00020a  63a0              STR      r0,[r4,#0x38]         ;1248
00020c  8fe0              LDRH     r0,[r4,#0x3e]         ;1249
00020e  1e40              SUBS     r0,r0,#1              ;1249
000210  87e0              STRH     r0,[r4,#0x3e]         ;1249
000212  2001              MOVS     r0,#1                 ;1251
000214  9002              STR      r0,[sp,#8]            ;1251
                  |L21.534|
000216  f7fffffe          BL       HAL_GetTick
00021a  1bc0              SUBS     r0,r0,r7              ;1253
00021c  42b0              CMP      r0,r6                 ;1253
00021e  d301              BCC      |L21.548|
000220  1c70              ADDS     r0,r6,#1              ;1253
000222  b900              CBNZ     r0,|L21.550|
                  |L21.548|
000224  b916              CBNZ     r6,|L21.556|
                  |L21.550|
000226  2003              MOVS     r0,#3                 ;1255
000228  9001              STR      r0,[sp,#4]            ;1255
00022a  e043              B        |L21.692|
                  |L21.556|
00022c  8ee0              LDRH     r0,[r4,#0x36]         ;1224
00022e  2800              CMP      r0,#0                 ;1224
000230  d1bb              BNE      |L21.426|
000232  8fe0              LDRH     r0,[r4,#0x3e]         ;1224
000234  2800              CMP      r0,#0                 ;1224
000236  d1b8              BNE      |L21.426|
                  |L21.568|
000238  6aa0              LDR      r0,[r4,#0x28]         ;1263
00023a  f5b05f00          CMP      r0,#0x2000            ;1263
00023e  d110              BNE      |L21.610|
000240  4633              MOV      r3,r6                 ;1266
000242  2201              MOVS     r2,#1                 ;1266
000244  4611              MOV      r1,r2                 ;1266
000246  4620              MOV      r0,r4                 ;1266
000248  9700              STR      r7,[sp,#0]            ;1266
00024a  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00024e  b130              CBZ      r0,|L21.606|
000250  6d60              LDR      r0,[r4,#0x54]         ;1269
000252  f0400002          ORR      r0,r0,#2              ;1269
000256  6560              STR      r0,[r4,#0x54]         ;1269
000258  2003              MOVS     r0,#3                 ;1270
00025a  9001              STR      r0,[sp,#4]            ;1270
00025c  e02a              B        |L21.692|
                  |L21.606|
00025e  6820              LDR      r0,[r4,#0]            ;1274
000260  68c0              LDR      r0,[r0,#0xc]          ;1274
                  |L21.610|
000262  6820              LDR      r0,[r4,#0]            ;1278
000264  6880              LDR      r0,[r0,#8]            ;1278
000266  f0000010          AND      r0,r0,#0x10           ;1278
00026a  2810              CMP      r0,#0x10              ;1278
00026c  d109              BNE      |L21.642|
00026e  6d60              LDR      r0,[r4,#0x54]         ;1280
000270  f0400002          ORR      r0,r0,#2              ;1280
000274  6560              STR      r0,[r4,#0x54]         ;1280
000276  f64f70ef          MOV      r0,#0xffef            ;1282
00027a  6821              LDR      r1,[r4,#0]            ;1282
00027c  6088              STR      r0,[r1,#8]            ;1282
00027e  2001              MOVS     r0,#1                 ;1284
000280  9001              STR      r0,[sp,#4]            ;1284
                  |L21.642|
000282  463a              MOV      r2,r7                 ;1289
000284  4631              MOV      r1,r6                 ;1289
000286  4620              MOV      r0,r4                 ;1289
000288  f7fffffe          BL       SPI_EndRxTxTransaction
00028c  b120              CBZ      r0,|L21.664|
00028e  2001              MOVS     r0,#1                 ;1291
000290  9001              STR      r0,[sp,#4]            ;1291
000292  2020              MOVS     r0,#0x20              ;1292
000294  6560              STR      r0,[r4,#0x54]         ;1292
000296  e00d              B        |L21.692|
                  |L21.664|
000298  68a0              LDR      r0,[r4,#8]            ;1297
00029a  b950              CBNZ     r0,|L21.690|
00029c  bf00              NOP                            ;1299
00029e  2000              MOVS     r0,#0                 ;1299
0002a0  9000              STR      r0,[sp,#0]            ;1299
0002a2  6820              LDR      r0,[r4,#0]            ;1299
0002a4  68c0              LDR      r0,[r0,#0xc]          ;1299
0002a6  9000              STR      r0,[sp,#0]            ;1299
0002a8  6820              LDR      r0,[r4,#0]            ;1299
0002aa  6880              LDR      r0,[r0,#8]            ;1299
0002ac  9000              STR      r0,[sp,#0]            ;1299
0002ae  bf00              NOP                            ;1299
0002b0  bf00              NOP                            ;1299
                  |L21.690|
0002b2  bf00              NOP                            ;1302
                  |L21.692|
0002b4  2001              MOVS     r0,#1                 ;1303
0002b6  f8840051          STRB     r0,[r4,#0x51]         ;1303
0002ba  bf00              NOP                            ;1304
0002bc  2000              MOVS     r0,#0                 ;1304
0002be  f8840050          STRB     r0,[r4,#0x50]         ;1304
0002c2  bf00              NOP                            ;1304
0002c4  9801              LDR      r0,[sp,#4]            ;1305
0002c6  e6ac              B        |L21.34|
;;;1307   
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_DMA PROC
;;;1795     */
;;;1796   HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1797                                                 uint16_t Size)
;;;1798   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1799     uint32_t             tmp_mode;
;;;1800     HAL_SPI_StateTypeDef tmp_state;
;;;1801     HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0a00          MOV      r10,#0
;;;1802   
;;;1803     /* Check rx & tx dma handles */
;;;1804     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
;;;1805     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1806   
;;;1807     /* Check Direction parameter */
;;;1808     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1809   
;;;1810     /* Process locked */
;;;1811     __HAL_LOCK(hspi);
000010  bf00              NOP      
000012  f8940050          LDRB     r0,[r4,#0x50]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L22.32|
00001a  2002              MOVS     r0,#2
                  |L22.28|
;;;1812   
;;;1813     /* Init temporary variables */
;;;1814     tmp_state           = hspi->State;
;;;1815     tmp_mode            = hspi->Init.Mode;
;;;1816   
;;;1817     if (!((tmp_state == HAL_SPI_STATE_READY) ||
;;;1818           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1819     {
;;;1820       errorcode = HAL_BUSY;
;;;1821       goto error;
;;;1822     }
;;;1823   
;;;1824     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1825     {
;;;1826       errorcode = HAL_ERROR;
;;;1827       goto error;
;;;1828     }
;;;1829   
;;;1830     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1831     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1832     {
;;;1833       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1834     }
;;;1835   
;;;1836     /* Set the transaction information */
;;;1837     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1838     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1839     hspi->TxXferSize  = Size;
;;;1840     hspi->TxXferCount = Size;
;;;1841     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1842     hspi->RxXferSize  = Size;
;;;1843     hspi->RxXferCount = Size;
;;;1844   
;;;1845     /* Init field not used in handle to zero */
;;;1846     hspi->RxISR       = NULL;
;;;1847     hspi->TxISR       = NULL;
;;;1848   
;;;1849   #if (USE_SPI_CRC != 0U)
;;;1850     /* Reset CRC Calculation */
;;;1851     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1852     {
;;;1853       SPI_RESET_CRC(hspi);
;;;1854     }
;;;1855   #endif /* USE_SPI_CRC */
;;;1856   
;;;1857     /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
;;;1858     if (hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;1859     {
;;;1860       /* Set the SPI Rx DMA Half transfer complete callback */
;;;1861       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1862       hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
;;;1863     }
;;;1864     else
;;;1865     {
;;;1866       /* Set the SPI Tx/Rx DMA Half transfer complete callback */
;;;1867       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
;;;1868       hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
;;;1869     }
;;;1870   
;;;1871     /* Set the DMA error callback */
;;;1872     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1873   
;;;1874     /* Set the DMA AbortCpltCallback */
;;;1875     hspi->hdmarx->XferAbortCallback = NULL;
;;;1876   
;;;1877     /* Enable the Rx DMA Stream/Channel  */
;;;1878     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount))
;;;1879     {
;;;1880       /* Update SPI error code */
;;;1881       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1882       errorcode = HAL_ERROR;
;;;1883   
;;;1884       hspi->State = HAL_SPI_STATE_READY;
;;;1885       goto error;
;;;1886     }
;;;1887   
;;;1888     /* Enable Rx DMA Request */
;;;1889     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1890   
;;;1891     /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
;;;1892     is performed in DMA reception complete callback  */
;;;1893     hspi->hdmatx->XferHalfCpltCallback = NULL;
;;;1894     hspi->hdmatx->XferCpltCallback     = NULL;
;;;1895     hspi->hdmatx->XferErrorCallback    = NULL;
;;;1896     hspi->hdmatx->XferAbortCallback    = NULL;
;;;1897   
;;;1898     /* Enable the Tx DMA Stream/Channel  */
;;;1899     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount))
;;;1900     {
;;;1901       /* Update SPI error code */
;;;1902       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1903       errorcode = HAL_ERROR;
;;;1904   
;;;1905       hspi->State = HAL_SPI_STATE_READY;
;;;1906       goto error;
;;;1907     }
;;;1908   
;;;1909     /* Check if the SPI is already enabled */
;;;1910     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1911     {
;;;1912       /* Enable SPI peripheral */
;;;1913       __HAL_SPI_ENABLE(hspi);
;;;1914     }
;;;1915     /* Enable the SPI Error Interrupt Bit */
;;;1916     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1917   
;;;1918     /* Enable Tx DMA Request */
;;;1919     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1920   
;;;1921   error :
;;;1922     /* Process Unlocked */
;;;1923     __HAL_UNLOCK(hspi);
;;;1924     return errorcode;
;;;1925   }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L22.32|
000020  2001              MOVS     r0,#1                 ;1811
000022  f8840050          STRB     r0,[r4,#0x50]         ;1811
000026  bf00              NOP                            ;1811
000028  f8948051          LDRB     r8,[r4,#0x51]         ;1814
00002c  f8d49004          LDR      r9,[r4,#4]            ;1815
000030  f1b80f01          CMP      r8,#1                 ;1817
000034  d00a              BEQ      |L22.76|
000036  f5b97f82          CMP      r9,#0x104             ;1817
00003a  d104              BNE      |L22.70|
00003c  68a0              LDR      r0,[r4,#8]            ;1817
00003e  b910              CBNZ     r0,|L22.70|
000040  f1b80f04          CMP      r8,#4                 ;1817
000044  d002              BEQ      |L22.76|
                  |L22.70|
000046  f04f0a02          MOV      r10,#2                ;1820
00004a  e08f              B        |L22.364|
                  |L22.76|
00004c  b10e              CBZ      r6,|L22.82|
00004e  b107              CBZ      r7,|L22.82|
000050  b915              CBNZ     r5,|L22.88|
                  |L22.82|
000052  f04f0a01          MOV      r10,#1                ;1826
000056  e089              B        |L22.364|
                  |L22.88|
000058  f8940051          LDRB     r0,[r4,#0x51]         ;1831
00005c  2804              CMP      r0,#4                 ;1831
00005e  d002              BEQ      |L22.102|
000060  2005              MOVS     r0,#5                 ;1833
000062  f8840051          STRB     r0,[r4,#0x51]         ;1833
                  |L22.102|
000066  2000              MOVS     r0,#0                 ;1837
000068  6560              STR      r0,[r4,#0x54]         ;1837
00006a  6326              STR      r6,[r4,#0x30]         ;1838
00006c  86a5              STRH     r5,[r4,#0x34]         ;1839
00006e  86e5              STRH     r5,[r4,#0x36]         ;1840
000070  63a7              STR      r7,[r4,#0x38]         ;1841
000072  87a5              STRH     r5,[r4,#0x3c]         ;1842
000074  87e5              STRH     r5,[r4,#0x3e]         ;1843
000076  6420              STR      r0,[r4,#0x40]         ;1846
000078  6460              STR      r0,[r4,#0x44]         ;1847
00007a  6aa0              LDR      r0,[r4,#0x28]         ;1851
00007c  f5b05f00          CMP      r0,#0x2000            ;1851
000080  d10d              BNE      |L22.158|
000082  bf00              NOP                            ;1853
000084  6820              LDR      r0,[r4,#0]            ;1853
000086  6800              LDR      r0,[r0,#0]            ;1853
000088  f4205000          BIC      r0,r0,#0x2000         ;1853
00008c  6821              LDR      r1,[r4,#0]            ;1853
00008e  6008              STR      r0,[r1,#0]            ;1853
000090  6820              LDR      r0,[r4,#0]            ;1853
000092  6800              LDR      r0,[r0,#0]            ;1853
000094  f4405000          ORR      r0,r0,#0x2000         ;1853
000098  6821              LDR      r1,[r4,#0]            ;1853
00009a  6008              STR      r0,[r1,#0]            ;1853
00009c  bf00              NOP                            ;1853
                  |L22.158|
00009e  f8940051          LDRB     r0,[r4,#0x51]         ;1858
0000a2  2804              CMP      r0,#4                 ;1858
0000a4  d106              BNE      |L22.180|
0000a6  4835              LDR      r0,|L22.380|
0000a8  6ce1              LDR      r1,[r4,#0x4c]         ;1861
0000aa  6408              STR      r0,[r1,#0x40]         ;1861
0000ac  4834              LDR      r0,|L22.384|
0000ae  6ce1              LDR      r1,[r4,#0x4c]         ;1862
0000b0  63c8              STR      r0,[r1,#0x3c]         ;1862
0000b2  e005              B        |L22.192|
                  |L22.180|
0000b4  4833              LDR      r0,|L22.388|
0000b6  6ce1              LDR      r1,[r4,#0x4c]         ;1867
0000b8  6408              STR      r0,[r1,#0x40]         ;1867
0000ba  4833              LDR      r0,|L22.392|
0000bc  6ce1              LDR      r1,[r4,#0x4c]         ;1868
0000be  63c8              STR      r0,[r1,#0x3c]         ;1868
                  |L22.192|
0000c0  4832              LDR      r0,|L22.396|
0000c2  6ce1              LDR      r1,[r4,#0x4c]         ;1872
0000c4  64c8              STR      r0,[r1,#0x4c]         ;1872
0000c6  2000              MOVS     r0,#0                 ;1875
0000c8  6ce1              LDR      r1,[r4,#0x4c]         ;1875
0000ca  6508              STR      r0,[r1,#0x50]         ;1875
0000cc  8fe3              LDRH     r3,[r4,#0x3e]         ;1878
0000ce  f8d4c000          LDR      r12,[r4,#0]           ;1878
0000d2  f10c010c          ADD      r1,r12,#0xc           ;1878
0000d6  6ba2              LDR      r2,[r4,#0x38]         ;1878
0000d8  6ce0              LDR      r0,[r4,#0x4c]         ;1878
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  b148              CBZ      r0,|L22.244|
0000e0  6d60              LDR      r0,[r4,#0x54]         ;1881
0000e2  f0400010          ORR      r0,r0,#0x10           ;1881
0000e6  6560              STR      r0,[r4,#0x54]         ;1881
0000e8  f04f0a01          MOV      r10,#1                ;1882
0000ec  2001              MOVS     r0,#1                 ;1884
0000ee  f8840051          STRB     r0,[r4,#0x51]         ;1884
0000f2  e03b              B        |L22.364|
                  |L22.244|
0000f4  6820              LDR      r0,[r4,#0]            ;1889
0000f6  6840              LDR      r0,[r0,#4]            ;1889
0000f8  f0400001          ORR      r0,r0,#1              ;1889
0000fc  6821              LDR      r1,[r4,#0]            ;1889
0000fe  6048              STR      r0,[r1,#4]            ;1889
000100  2000              MOVS     r0,#0                 ;1893
000102  6ca1              LDR      r1,[r4,#0x48]         ;1893
000104  6408              STR      r0,[r1,#0x40]         ;1893
000106  6ca1              LDR      r1,[r4,#0x48]         ;1894
000108  63c8              STR      r0,[r1,#0x3c]         ;1894
00010a  6ca1              LDR      r1,[r4,#0x48]         ;1895
00010c  64c8              STR      r0,[r1,#0x4c]         ;1895
00010e  6ca1              LDR      r1,[r4,#0x48]         ;1896
000110  6508              STR      r0,[r1,#0x50]         ;1896
000112  8ee3              LDRH     r3,[r4,#0x36]         ;1899
000114  f8d4c000          LDR      r12,[r4,#0]           ;1899
000118  f10c020c          ADD      r2,r12,#0xc           ;1899
00011c  6b21              LDR      r1,[r4,#0x30]         ;1899
00011e  6ca0              LDR      r0,[r4,#0x48]         ;1899
000120  f7fffffe          BL       HAL_DMA_Start_IT
000124  b148              CBZ      r0,|L22.314|
000126  6d60              LDR      r0,[r4,#0x54]         ;1902
000128  f0400010          ORR      r0,r0,#0x10           ;1902
00012c  6560              STR      r0,[r4,#0x54]         ;1902
00012e  f04f0a01          MOV      r10,#1                ;1903
000132  2001              MOVS     r0,#1                 ;1905
000134  f8840051          STRB     r0,[r4,#0x51]         ;1905
000138  e018              B        |L22.364|
                  |L22.314|
00013a  6820              LDR      r0,[r4,#0]            ;1910
00013c  6800              LDR      r0,[r0,#0]            ;1910
00013e  f0000040          AND      r0,r0,#0x40           ;1910
000142  2840              CMP      r0,#0x40              ;1910
000144  d005              BEQ      |L22.338|
000146  6820              LDR      r0,[r4,#0]            ;1913
000148  6800              LDR      r0,[r0,#0]            ;1913
00014a  f0400040          ORR      r0,r0,#0x40           ;1913
00014e  6821              LDR      r1,[r4,#0]            ;1913
000150  6008              STR      r0,[r1,#0]            ;1913
                  |L22.338|
000152  6820              LDR      r0,[r4,#0]            ;1916
000154  6840              LDR      r0,[r0,#4]            ;1916
000156  f0400020          ORR      r0,r0,#0x20           ;1916
00015a  6821              LDR      r1,[r4,#0]            ;1916
00015c  6048              STR      r0,[r1,#4]            ;1916
00015e  6820              LDR      r0,[r4,#0]            ;1919
000160  6840              LDR      r0,[r0,#4]            ;1919
000162  f0400002          ORR      r0,r0,#2              ;1919
000166  6821              LDR      r1,[r4,#0]            ;1919
000168  6048              STR      r0,[r1,#4]            ;1919
00016a  bf00              NOP                            ;1921
                  |L22.364|
00016c  bf00              NOP                            ;1923
00016e  2000              MOVS     r0,#0                 ;1923
000170  f8840050          STRB     r0,[r4,#0x50]         ;1923
000174  bf00              NOP                            ;1923
000176  4650              MOV      r0,r10                ;1924
000178  e750              B        |L22.28|
;;;1926   
                          ENDP

00017a  0000              DCW      0x0000
                  |L22.380|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L22.384|
                          DCD      SPI_DMAReceiveCplt
                  |L22.388|
                          DCD      SPI_DMAHalfTransmitReceiveCplt
                  |L22.392|
                          DCD      SPI_DMATransmitReceiveCplt
                  |L22.396|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_IT PROC
;;;1490     */
;;;1491   HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1492   {
000002  4604              MOV      r4,r0
;;;1493     uint32_t             tmp_mode;
;;;1494     HAL_SPI_StateTypeDef tmp_state;
;;;1495     HAL_StatusTypeDef    errorcode = HAL_OK;
000004  2700              MOVS     r7,#0
;;;1496   
;;;1497     /* Check Direction parameter */
;;;1498     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1499   
;;;1500     /* Process locked */
;;;1501     __HAL_LOCK(hspi);
000006  bf00              NOP      
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L23.20|
000010  2002              MOVS     r0,#2
                  |L23.18|
;;;1502   
;;;1503     /* Init temporary variables */
;;;1504     tmp_state           = hspi->State;
;;;1505     tmp_mode            = hspi->Init.Mode;
;;;1506   
;;;1507     if (!((tmp_state == HAL_SPI_STATE_READY) || \
;;;1508           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1509     {
;;;1510       errorcode = HAL_BUSY;
;;;1511       goto error;
;;;1512     }
;;;1513   
;;;1514     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1515     {
;;;1516       errorcode = HAL_ERROR;
;;;1517       goto error;
;;;1518     }
;;;1519   
;;;1520     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1521     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1522     {
;;;1523       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1524     }
;;;1525   
;;;1526     /* Set the transaction information */
;;;1527     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1528     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1529     hspi->TxXferSize  = Size;
;;;1530     hspi->TxXferCount = Size;
;;;1531     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1532     hspi->RxXferSize  = Size;
;;;1533     hspi->RxXferCount = Size;
;;;1534   
;;;1535     /* Set the function for IT treatment */
;;;1536     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1537     {
;;;1538       hspi->RxISR     = SPI_2linesRxISR_16BIT;
;;;1539       hspi->TxISR     = SPI_2linesTxISR_16BIT;
;;;1540     }
;;;1541     else
;;;1542     {
;;;1543       hspi->RxISR     = SPI_2linesRxISR_8BIT;
;;;1544       hspi->TxISR     = SPI_2linesTxISR_8BIT;
;;;1545     }
;;;1546   
;;;1547   #if (USE_SPI_CRC != 0U)
;;;1548     /* Reset CRC Calculation */
;;;1549     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1550     {
;;;1551       SPI_RESET_CRC(hspi);
;;;1552     }
;;;1553   #endif /* USE_SPI_CRC */
;;;1554   
;;;1555     /* Enable TXE, RXNE and ERR interrupt */
;;;1556     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;1557   
;;;1558     /* Check if the SPI is already enabled */
;;;1559     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1560     {
;;;1561       /* Enable SPI peripheral */
;;;1562       __HAL_SPI_ENABLE(hspi);
;;;1563     }
;;;1564   
;;;1565   error :
;;;1566     /* Process Unlocked */
;;;1567     __HAL_UNLOCK(hspi);
;;;1568     return errorcode;
;;;1569   }
000012  bdf0              POP      {r4-r7,pc}
                  |L23.20|
000014  2001              MOVS     r0,#1                 ;1501
000016  f8840050          STRB     r0,[r4,#0x50]         ;1501
00001a  bf00              NOP                            ;1501
00001c  f8945051          LDRB     r5,[r4,#0x51]         ;1504
000020  6866              LDR      r6,[r4,#4]            ;1505
000022  2d01              CMP      r5,#1                 ;1507
000024  d008              BEQ      |L23.56|
000026  f5b67f82          CMP      r6,#0x104             ;1507
00002a  d103              BNE      |L23.52|
00002c  68a0              LDR      r0,[r4,#8]            ;1507
00002e  b908              CBNZ     r0,|L23.52|
000030  2d04              CMP      r5,#4                 ;1507
000032  d001              BEQ      |L23.56|
                  |L23.52|
000034  2702              MOVS     r7,#2                 ;1510
000036  e04b              B        |L23.208|
                  |L23.56|
000038  b109              CBZ      r1,|L23.62|
00003a  b102              CBZ      r2,|L23.62|
00003c  b90b              CBNZ     r3,|L23.66|
                  |L23.62|
00003e  2701              MOVS     r7,#1                 ;1516
000040  e046              B        |L23.208|
                  |L23.66|
000042  f8940051          LDRB     r0,[r4,#0x51]         ;1521
000046  2804              CMP      r0,#4                 ;1521
000048  d002              BEQ      |L23.80|
00004a  2005              MOVS     r0,#5                 ;1523
00004c  f8840051          STRB     r0,[r4,#0x51]         ;1523
                  |L23.80|
000050  2000              MOVS     r0,#0                 ;1527
000052  6560              STR      r0,[r4,#0x54]         ;1527
000054  6321              STR      r1,[r4,#0x30]         ;1528
000056  86a3              STRH     r3,[r4,#0x34]         ;1529
000058  86e3              STRH     r3,[r4,#0x36]         ;1530
00005a  63a2              STR      r2,[r4,#0x38]         ;1531
00005c  87a3              STRH     r3,[r4,#0x3c]         ;1532
00005e  87e3              STRH     r3,[r4,#0x3e]         ;1533
000060  68e0              LDR      r0,[r4,#0xc]          ;1536
000062  b120              CBZ      r0,|L23.110|
000064  481e              LDR      r0,|L23.224|
000066  6420              STR      r0,[r4,#0x40]         ;1538
000068  481e              LDR      r0,|L23.228|
00006a  6460              STR      r0,[r4,#0x44]         ;1539
00006c  e003              B        |L23.118|
                  |L23.110|
00006e  481e              LDR      r0,|L23.232|
000070  6420              STR      r0,[r4,#0x40]         ;1543
000072  481e              LDR      r0,|L23.236|
000074  6460              STR      r0,[r4,#0x44]         ;1544
                  |L23.118|
000076  6aa0              LDR      r0,[r4,#0x28]         ;1549
000078  f5b05f00          CMP      r0,#0x2000            ;1549
00007c  d111              BNE      |L23.162|
00007e  bf00              NOP                            ;1551
000080  6820              LDR      r0,[r4,#0]            ;1551
000082  6800              LDR      r0,[r0,#0]            ;1551
000084  f4205000          BIC      r0,r0,#0x2000         ;1551
000088  f8d4c000          LDR      r12,[r4,#0]           ;1551
00008c  f8cc0000          STR      r0,[r12,#0]           ;1551
000090  6820              LDR      r0,[r4,#0]            ;1551
000092  6800              LDR      r0,[r0,#0]            ;1551
000094  f4405000          ORR      r0,r0,#0x2000         ;1551
000098  f8d4c000          LDR      r12,[r4,#0]           ;1551
00009c  f8cc0000          STR      r0,[r12,#0]           ;1551
0000a0  bf00              NOP                            ;1551
                  |L23.162|
0000a2  6820              LDR      r0,[r4,#0]            ;1556
0000a4  6840              LDR      r0,[r0,#4]            ;1556
0000a6  f04000e0          ORR      r0,r0,#0xe0           ;1556
0000aa  f8d4c000          LDR      r12,[r4,#0]           ;1556
0000ae  f8cc0004          STR      r0,[r12,#4]           ;1556
0000b2  6820              LDR      r0,[r4,#0]            ;1559
0000b4  6800              LDR      r0,[r0,#0]            ;1559
0000b6  f0000040          AND      r0,r0,#0x40           ;1559
0000ba  2840              CMP      r0,#0x40              ;1559
0000bc  d007              BEQ      |L23.206|
0000be  6820              LDR      r0,[r4,#0]            ;1562
0000c0  6800              LDR      r0,[r0,#0]            ;1562
0000c2  f0400040          ORR      r0,r0,#0x40           ;1562
0000c6  f8d4c000          LDR      r12,[r4,#0]           ;1562
0000ca  f8cc0000          STR      r0,[r12,#0]           ;1562
                  |L23.206|
0000ce  bf00              NOP                            ;1565
                  |L23.208|
0000d0  bf00              NOP                            ;1567
0000d2  2000              MOVS     r0,#0                 ;1567
0000d4  f8840050          STRB     r0,[r4,#0x50]         ;1567
0000d8  bf00              NOP                            ;1567
0000da  4638              MOV      r0,r7                 ;1568
0000dc  e799              B        |L23.18|
;;;1570   
                          ENDP

0000de  0000              DCW      0x0000
                  |L23.224|
                          DCD      SPI_2linesRxISR_16BIT
                  |L23.228|
                          DCD      SPI_2linesTxISR_16BIT
                  |L23.232|
                          DCD      SPI_2linesRxISR_8BIT
                  |L23.236|
                          DCD      SPI_2linesTxISR_8BIT

                          AREA ||i.HAL_SPI_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_DMA PROC
;;;1578     */
;;;1579   HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1580   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1581     HAL_StatusTypeDef errorcode = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;1582   
;;;1583     /* Check tx dma handle */
;;;1584     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1585   
;;;1586     /* Check Direction parameter */
;;;1587     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1588   
;;;1589     /* Process Locked */
;;;1590     __HAL_LOCK(hspi);
00000c  bf00              NOP      
00000e  f8940050          LDRB     r0,[r4,#0x50]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L24.28|
000016  2002              MOVS     r0,#2
                  |L24.24|
;;;1591   
;;;1592     if (hspi->State != HAL_SPI_STATE_READY)
;;;1593     {
;;;1594       errorcode = HAL_BUSY;
;;;1595       goto error;
;;;1596     }
;;;1597   
;;;1598     if ((pData == NULL) || (Size == 0U))
;;;1599     {
;;;1600       errorcode = HAL_ERROR;
;;;1601       goto error;
;;;1602     }
;;;1603   
;;;1604     /* Set the transaction information */
;;;1605     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1606     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1607     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1608     hspi->TxXferSize  = Size;
;;;1609     hspi->TxXferCount = Size;
;;;1610   
;;;1611     /* Init field not used in handle to zero */
;;;1612     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1613     hspi->TxISR       = NULL;
;;;1614     hspi->RxISR       = NULL;
;;;1615     hspi->RxXferSize  = 0U;
;;;1616     hspi->RxXferCount = 0U;
;;;1617   
;;;1618     /* Configure communication direction : 1Line */
;;;1619     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1620     {
;;;1621       SPI_1LINE_TX(hspi);
;;;1622     }
;;;1623   
;;;1624   #if (USE_SPI_CRC != 0U)
;;;1625     /* Reset CRC Calculation */
;;;1626     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1627     {
;;;1628       SPI_RESET_CRC(hspi);
;;;1629     }
;;;1630   #endif /* USE_SPI_CRC */
;;;1631   
;;;1632     /* Set the SPI TxDMA Half transfer complete callback */
;;;1633     hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
;;;1634   
;;;1635     /* Set the SPI TxDMA transfer complete callback */
;;;1636     hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
;;;1637   
;;;1638     /* Set the DMA error callback */
;;;1639     hspi->hdmatx->XferErrorCallback = SPI_DMAError;
;;;1640   
;;;1641     /* Set the DMA AbortCpltCallback */
;;;1642     hspi->hdmatx->XferAbortCallback = NULL;
;;;1643   
;;;1644     /* Enable the Tx DMA Stream/Channel */
;;;1645     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount))
;;;1646     {
;;;1647       /* Update SPI error code */
;;;1648       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1649       errorcode = HAL_ERROR;
;;;1650   
;;;1651       hspi->State = HAL_SPI_STATE_READY;
;;;1652       goto error;
;;;1653     }
;;;1654   
;;;1655     /* Check if the SPI is already enabled */
;;;1656     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1657     {
;;;1658       /* Enable SPI peripheral */
;;;1659       __HAL_SPI_ENABLE(hspi);
;;;1660     }
;;;1661   
;;;1662     /* Enable the SPI Error Interrupt Bit */
;;;1663     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1664   
;;;1665     /* Enable Tx DMA Request */
;;;1666     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1667   
;;;1668   error :
;;;1669     /* Process Unlocked */
;;;1670     __HAL_UNLOCK(hspi);
;;;1671     return errorcode;
;;;1672   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L24.28|
00001c  2001              MOVS     r0,#1                 ;1590
00001e  f8840050          STRB     r0,[r4,#0x50]         ;1590
000022  bf00              NOP                            ;1590
000024  f8940051          LDRB     r0,[r4,#0x51]         ;1592
000028  2801              CMP      r0,#1                 ;1592
00002a  d001              BEQ      |L24.48|
00002c  2702              MOVS     r7,#2                 ;1594
00002e  e064              B        |L24.250|
                  |L24.48|
000030  b106              CBZ      r6,|L24.52|
000032  b90d              CBNZ     r5,|L24.56|
                  |L24.52|
000034  2701              MOVS     r7,#1                 ;1600
000036  e060              B        |L24.250|
                  |L24.56|
000038  2003              MOVS     r0,#3                 ;1605
00003a  f8840051          STRB     r0,[r4,#0x51]         ;1605
00003e  2000              MOVS     r0,#0                 ;1606
000040  6560              STR      r0,[r4,#0x54]         ;1606
000042  6326              STR      r6,[r4,#0x30]         ;1607
000044  86a5              STRH     r5,[r4,#0x34]         ;1608
000046  86e5              STRH     r5,[r4,#0x36]         ;1609
000048  63a0              STR      r0,[r4,#0x38]         ;1612
00004a  6460              STR      r0,[r4,#0x44]         ;1613
00004c  6420              STR      r0,[r4,#0x40]         ;1614
00004e  87a0              STRH     r0,[r4,#0x3c]         ;1615
000050  87e0              STRH     r0,[r4,#0x3e]         ;1616
000052  68a0              LDR      r0,[r4,#8]            ;1619
000054  f5b04f00          CMP      r0,#0x8000            ;1619
000058  d105              BNE      |L24.102|
00005a  6820              LDR      r0,[r4,#0]            ;1621
00005c  6800              LDR      r0,[r0,#0]            ;1621
00005e  f4404080          ORR      r0,r0,#0x4000         ;1621
000062  6821              LDR      r1,[r4,#0]            ;1621
000064  6008              STR      r0,[r1,#0]            ;1621
                  |L24.102|
000066  6aa0              LDR      r0,[r4,#0x28]         ;1626
000068  f5b05f00          CMP      r0,#0x2000            ;1626
00006c  d10d              BNE      |L24.138|
00006e  bf00              NOP                            ;1628
000070  6820              LDR      r0,[r4,#0]            ;1628
000072  6800              LDR      r0,[r0,#0]            ;1628
000074  f4205000          BIC      r0,r0,#0x2000         ;1628
000078  6821              LDR      r1,[r4,#0]            ;1628
00007a  6008              STR      r0,[r1,#0]            ;1628
00007c  6820              LDR      r0,[r4,#0]            ;1628
00007e  6800              LDR      r0,[r0,#0]            ;1628
000080  f4405000          ORR      r0,r0,#0x2000         ;1628
000084  6821              LDR      r1,[r4,#0]            ;1628
000086  6008              STR      r0,[r1,#0]            ;1628
000088  bf00              NOP                            ;1628
                  |L24.138|
00008a  481f              LDR      r0,|L24.264|
00008c  6ca1              LDR      r1,[r4,#0x48]         ;1633
00008e  6408              STR      r0,[r1,#0x40]         ;1633
000090  481e              LDR      r0,|L24.268|
000092  6ca1              LDR      r1,[r4,#0x48]         ;1636
000094  63c8              STR      r0,[r1,#0x3c]         ;1636
000096  481e              LDR      r0,|L24.272|
000098  6ca1              LDR      r1,[r4,#0x48]         ;1639
00009a  64c8              STR      r0,[r1,#0x4c]         ;1639
00009c  2000              MOVS     r0,#0                 ;1642
00009e  6ca1              LDR      r1,[r4,#0x48]         ;1642
0000a0  6508              STR      r0,[r1,#0x50]         ;1642
0000a2  8ee3              LDRH     r3,[r4,#0x36]         ;1645
0000a4  f8d4c000          LDR      r12,[r4,#0]           ;1645
0000a8  f10c020c          ADD      r2,r12,#0xc           ;1645
0000ac  6b21              LDR      r1,[r4,#0x30]         ;1645
0000ae  6ca0              LDR      r0,[r4,#0x48]         ;1645
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  b140              CBZ      r0,|L24.200|
0000b6  6d60              LDR      r0,[r4,#0x54]         ;1648
0000b8  f0400010          ORR      r0,r0,#0x10           ;1648
0000bc  6560              STR      r0,[r4,#0x54]         ;1648
0000be  2701              MOVS     r7,#1                 ;1649
0000c0  2001              MOVS     r0,#1                 ;1651
0000c2  f8840051          STRB     r0,[r4,#0x51]         ;1651
0000c6  e018              B        |L24.250|
                  |L24.200|
0000c8  6820              LDR      r0,[r4,#0]            ;1656
0000ca  6800              LDR      r0,[r0,#0]            ;1656
0000cc  f0000040          AND      r0,r0,#0x40           ;1656
0000d0  2840              CMP      r0,#0x40              ;1656
0000d2  d005              BEQ      |L24.224|
0000d4  6820              LDR      r0,[r4,#0]            ;1659
0000d6  6800              LDR      r0,[r0,#0]            ;1659
0000d8  f0400040          ORR      r0,r0,#0x40           ;1659
0000dc  6821              LDR      r1,[r4,#0]            ;1659
0000de  6008              STR      r0,[r1,#0]            ;1659
                  |L24.224|
0000e0  6820              LDR      r0,[r4,#0]            ;1663
0000e2  6840              LDR      r0,[r0,#4]            ;1663
0000e4  f0400020          ORR      r0,r0,#0x20           ;1663
0000e8  6821              LDR      r1,[r4,#0]            ;1663
0000ea  6048              STR      r0,[r1,#4]            ;1663
0000ec  6820              LDR      r0,[r4,#0]            ;1666
0000ee  6840              LDR      r0,[r0,#4]            ;1666
0000f0  f0400002          ORR      r0,r0,#2              ;1666
0000f4  6821              LDR      r1,[r4,#0]            ;1666
0000f6  6048              STR      r0,[r1,#4]            ;1666
0000f8  bf00              NOP                            ;1668
                  |L24.250|
0000fa  bf00              NOP                            ;1670
0000fc  2000              MOVS     r0,#0                 ;1670
0000fe  f8840050          STRB     r0,[r4,#0x50]         ;1670
000102  bf00              NOP                            ;1670
000104  4638              MOV      r0,r7                 ;1671
000106  e787              B        |L24.24|
;;;1673   
                          ENDP

                  |L24.264|
                          DCD      SPI_DMAHalfTransmitCplt
                  |L24.268|
                          DCD      SPI_DMATransmitCplt
                  |L24.272|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_IT PROC
;;;1315     */
;;;1316   HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;1317   {
000002  4603              MOV      r3,r0
;;;1318     HAL_StatusTypeDef errorcode = HAL_OK;
000004  2400              MOVS     r4,#0
;;;1319   
;;;1320     /* Check Direction parameter */
;;;1321     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1322   
;;;1323     /* Process Locked */
;;;1324     __HAL_LOCK(hspi);
000006  bf00              NOP      
000008  f8930050          LDRB     r0,[r3,#0x50]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L25.20|
000010  2002              MOVS     r0,#2
                  |L25.18|
;;;1325   
;;;1326     if ((pData == NULL) || (Size == 0U))
;;;1327     {
;;;1328       errorcode = HAL_ERROR;
;;;1329       goto error;
;;;1330     }
;;;1331   
;;;1332     if (hspi->State != HAL_SPI_STATE_READY)
;;;1333     {
;;;1334       errorcode = HAL_BUSY;
;;;1335       goto error;
;;;1336     }
;;;1337   
;;;1338     /* Set the transaction information */
;;;1339     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1340     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1341     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1342     hspi->TxXferSize  = Size;
;;;1343     hspi->TxXferCount = Size;
;;;1344   
;;;1345     /* Init field not used in handle to zero */
;;;1346     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1347     hspi->RxXferSize  = 0U;
;;;1348     hspi->RxXferCount = 0U;
;;;1349     hspi->RxISR       = NULL;
;;;1350   
;;;1351     /* Set the function for IT treatment */
;;;1352     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1353     {
;;;1354       hspi->TxISR = SPI_TxISR_16BIT;
;;;1355     }
;;;1356     else
;;;1357     {
;;;1358       hspi->TxISR = SPI_TxISR_8BIT;
;;;1359     }
;;;1360   
;;;1361     /* Configure communication direction : 1Line */
;;;1362     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1363     {
;;;1364       SPI_1LINE_TX(hspi);
;;;1365     }
;;;1366   
;;;1367   #if (USE_SPI_CRC != 0U)
;;;1368     /* Reset CRC Calculation */
;;;1369     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1370     {
;;;1371       SPI_RESET_CRC(hspi);
;;;1372     }
;;;1373   #endif /* USE_SPI_CRC */
;;;1374   
;;;1375     /* Enable TXE and ERR interrupt */
;;;1376     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
;;;1377   
;;;1378   
;;;1379     /* Check if the SPI is already enabled */
;;;1380     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1381     {
;;;1382       /* Enable SPI peripheral */
;;;1383       __HAL_SPI_ENABLE(hspi);
;;;1384     }
;;;1385   
;;;1386   error :
;;;1387     __HAL_UNLOCK(hspi);
;;;1388     return errorcode;
;;;1389   }
000012  bd30              POP      {r4,r5,pc}
                  |L25.20|
000014  2001              MOVS     r0,#1                 ;1324
000016  f8830050          STRB     r0,[r3,#0x50]         ;1324
00001a  bf00              NOP                            ;1324
00001c  b101              CBZ      r1,|L25.32|
00001e  b90a              CBNZ     r2,|L25.36|
                  |L25.32|
000020  2401              MOVS     r4,#1                 ;1328
000022  e047              B        |L25.180|
                  |L25.36|
000024  f8930051          LDRB     r0,[r3,#0x51]         ;1332
000028  2801              CMP      r0,#1                 ;1332
00002a  d001              BEQ      |L25.48|
00002c  2402              MOVS     r4,#2                 ;1334
00002e  e041              B        |L25.180|
                  |L25.48|
000030  2003              MOVS     r0,#3                 ;1339
000032  f8830051          STRB     r0,[r3,#0x51]         ;1339
000036  2000              MOVS     r0,#0                 ;1340
000038  6558              STR      r0,[r3,#0x54]         ;1340
00003a  6319              STR      r1,[r3,#0x30]         ;1341
00003c  869a              STRH     r2,[r3,#0x34]         ;1342
00003e  86da              STRH     r2,[r3,#0x36]         ;1343
000040  6398              STR      r0,[r3,#0x38]         ;1346
000042  8798              STRH     r0,[r3,#0x3c]         ;1347
000044  87d8              STRH     r0,[r3,#0x3e]         ;1348
000046  6418              STR      r0,[r3,#0x40]         ;1349
000048  68d8              LDR      r0,[r3,#0xc]          ;1352
00004a  b110              CBZ      r0,|L25.82|
00004c  481d              LDR      r0,|L25.196|
00004e  6458              STR      r0,[r3,#0x44]         ;1354
000050  e001              B        |L25.86|
                  |L25.82|
000052  481d              LDR      r0,|L25.200|
000054  6458              STR      r0,[r3,#0x44]         ;1358
                  |L25.86|
000056  6898              LDR      r0,[r3,#8]            ;1362
000058  f5b04f00          CMP      r0,#0x8000            ;1362
00005c  d105              BNE      |L25.106|
00005e  6818              LDR      r0,[r3,#0]            ;1364
000060  6800              LDR      r0,[r0,#0]            ;1364
000062  f4404080          ORR      r0,r0,#0x4000         ;1364
000066  681d              LDR      r5,[r3,#0]            ;1364
000068  6028              STR      r0,[r5,#0]            ;1364
                  |L25.106|
00006a  6a98              LDR      r0,[r3,#0x28]         ;1369
00006c  f5b05f00          CMP      r0,#0x2000            ;1369
000070  d10d              BNE      |L25.142|
000072  bf00              NOP                            ;1371
000074  6818              LDR      r0,[r3,#0]            ;1371
000076  6800              LDR      r0,[r0,#0]            ;1371
000078  f4205000          BIC      r0,r0,#0x2000         ;1371
00007c  681d              LDR      r5,[r3,#0]            ;1371
00007e  6028              STR      r0,[r5,#0]            ;1371
000080  6818              LDR      r0,[r3,#0]            ;1371
000082  6800              LDR      r0,[r0,#0]            ;1371
000084  f4405000          ORR      r0,r0,#0x2000         ;1371
000088  681d              LDR      r5,[r3,#0]            ;1371
00008a  6028              STR      r0,[r5,#0]            ;1371
00008c  bf00              NOP                            ;1371
                  |L25.142|
00008e  6818              LDR      r0,[r3,#0]            ;1376
000090  6840              LDR      r0,[r0,#4]            ;1376
000092  f04000a0          ORR      r0,r0,#0xa0           ;1376
000096  681d              LDR      r5,[r3,#0]            ;1376
000098  6068              STR      r0,[r5,#4]            ;1376
00009a  6818              LDR      r0,[r3,#0]            ;1380
00009c  6800              LDR      r0,[r0,#0]            ;1380
00009e  f0000040          AND      r0,r0,#0x40           ;1380
0000a2  2840              CMP      r0,#0x40              ;1380
0000a4  d005              BEQ      |L25.178|
0000a6  6818              LDR      r0,[r3,#0]            ;1383
0000a8  6800              LDR      r0,[r0,#0]            ;1383
0000aa  f0400040          ORR      r0,r0,#0x40           ;1383
0000ae  681d              LDR      r5,[r3,#0]            ;1383
0000b0  6028              STR      r0,[r5,#0]            ;1383
                  |L25.178|
0000b2  bf00              NOP                            ;1386
                  |L25.180|
0000b4  bf00              NOP                            ;1387
0000b6  2000              MOVS     r0,#0                 ;1387
0000b8  f8830050          STRB     r0,[r3,#0x50]         ;1387
0000bc  bf00              NOP                            ;1387
0000be  4620              MOV      r0,r4                 ;1388
0000c0  e7a7              B        |L25.18|
;;;1390   
                          ENDP

0000c2  0000              DCW      0x0000
                  |L25.196|
                          DCD      SPI_TxISR_16BIT
                  |L25.200|
                          DCD      SPI_TxISR_8BIT

                          AREA ||i.HAL_SPI_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxCpltCallback PROC
;;;2434     */
;;;2435   __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2436   {
;;;2437     /* Prevent unused argument(s) compilation warning */
;;;2438     UNUSED(hspi);
;;;2439   
;;;2440     /* NOTE : This function should not be modified, when the callback is needed,
;;;2441               the HAL_SPI_TxCpltCallback should be implemented in the user file
;;;2442      */
;;;2443   }
;;;2444   
                          ENDP


                          AREA ||i.HAL_SPI_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxHalfCpltCallback PROC
;;;2482     */
;;;2483   __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2484   {
;;;2485     /* Prevent unused argument(s) compilation warning */
;;;2486     UNUSED(hspi);
;;;2487   
;;;2488     /* NOTE : This function should not be modified, when the callback is needed,
;;;2489               the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
;;;2490      */
;;;2491   }
;;;2492   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxCpltCallback PROC
;;;2466     */
;;;2467   __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2468   {
;;;2469     /* Prevent unused argument(s) compilation warning */
;;;2470     UNUSED(hspi);
;;;2471   
;;;2472     /* NOTE : This function should not be modified, when the callback is needed,
;;;2473               the HAL_SPI_TxRxCpltCallback should be implemented in the user file
;;;2474      */
;;;2475   }
;;;2476   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxHalfCpltCallback PROC
;;;2514     */
;;;2515   __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2516   {
;;;2517     /* Prevent unused argument(s) compilation warning */
;;;2518     UNUSED(hspi);
;;;2519   
;;;2520     /* NOTE : This function should not be modified, when the callback is needed,
;;;2521               the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
;;;2522      */
;;;2523   }
;;;2524   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_16BIT||, CODE, READONLY, ALIGN=2

                  SPI_2linesRxISR_16BIT PROC
;;;3143     */
;;;3144   static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3145   {
000002  4604              MOV      r4,r0
;;;3146     /* Receive data in 16 Bit mode */
;;;3147     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  8008              STRH     r0,[r1,#0]
;;;3148     hspi->pRxBuffPtr += sizeof(uint16_t);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c80              ADDS     r0,r0,#2
000010  63a0              STR      r0,[r4,#0x38]
;;;3149     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3150   
;;;3151     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b988              CBNZ     r0,|L30.64|
;;;3152     {
;;;3153   #if (USE_SPI_CRC != 0U)
;;;3154       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  f5b05f00          CMP      r0,#0x2000
000022  d102              BNE      |L30.42|
;;;3155       {
;;;3156         hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
000024  4807              LDR      r0,|L30.68|
000026  6420              STR      r0,[r4,#0x40]
                  |L30.40|
;;;3157         return;
;;;3158       }
;;;3159   #endif /* USE_SPI_CRC */
;;;3160   
;;;3161       /* Disable RXNE interrupt */
;;;3162       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
;;;3163   
;;;3164       if (hspi->TxXferCount == 0U)
;;;3165       {
;;;3166         SPI_CloseRxTx_ISR(hspi);
;;;3167       }
;;;3168     }
;;;3169   }
000028  bd10              POP      {r4,pc}
                  |L30.42|
00002a  6820              LDR      r0,[r4,#0]            ;3162
00002c  6840              LDR      r0,[r0,#4]            ;3162
00002e  f0200040          BIC      r0,r0,#0x40           ;3162
000032  6821              LDR      r1,[r4,#0]            ;3162
000034  6048              STR      r0,[r1,#4]            ;3162
000036  8ee0              LDRH     r0,[r4,#0x36]         ;3164
000038  b910              CBNZ     r0,|L30.64|
00003a  4620              MOV      r0,r4                 ;3166
00003c  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L30.64|
000040  bf00              NOP      
000042  e7f1              B        |L30.40|
;;;3170   
                          ENDP

                  |L30.68|
                          DCD      SPI_2linesRxISR_16BITCRC

                          AREA ||i.SPI_2linesRxISR_16BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_16BITCRC PROC
;;;3177     */
;;;3178   static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3179   {
000002  4604              MOV      r4,r0
;;;3180     /* Read 16bit CRC to flush Data Regsiter */
;;;3181     READ_REG(hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
;;;3182   
;;;3183     /* Disable RXNE interrupt */
;;;3184     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
000008  6820              LDR      r0,[r4,#0]
00000a  6840              LDR      r0,[r0,#4]
00000c  f0200040          BIC      r0,r0,#0x40
000010  6821              LDR      r1,[r4,#0]
000012  6048              STR      r0,[r1,#4]
;;;3185   
;;;3186     SPI_CloseRxTx_ISR(hspi);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_CloseRxTx_ISR
;;;3187   }
00001a  bd10              POP      {r4,pc}
;;;3188   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_2linesRxISR_8BIT||, CODE, READONLY, ALIGN=2

                  SPI_2linesRxISR_8BIT PROC
;;;3051     */
;;;3052   static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3053   {
000002  4604              MOV      r4,r0
;;;3054     /* Receive data in 8bit mode */
;;;3055     *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  7b00              LDRB     r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  7008              STRB     r0,[r1,#0]
;;;3056     hspi->pRxBuffPtr++;
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c40              ADDS     r0,r0,#1
000010  63a0              STR      r0,[r4,#0x38]
;;;3057     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3058   
;;;3059     /* Check end of the reception */
;;;3060     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b988              CBNZ     r0,|L32.64|
;;;3061     {
;;;3062   #if (USE_SPI_CRC != 0U)
;;;3063       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  f5b05f00          CMP      r0,#0x2000
000022  d102              BNE      |L32.42|
;;;3064       {
;;;3065         hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
000024  4807              LDR      r0,|L32.68|
000026  6420              STR      r0,[r4,#0x40]
                  |L32.40|
;;;3066         return;
;;;3067       }
;;;3068   #endif /* USE_SPI_CRC */
;;;3069   
;;;3070       /* Disable RXNE  and ERR interrupt */
;;;3071       __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
;;;3072   
;;;3073       if (hspi->TxXferCount == 0U)
;;;3074       {
;;;3075         SPI_CloseRxTx_ISR(hspi);
;;;3076       }
;;;3077     }
;;;3078   }
000028  bd10              POP      {r4,pc}
                  |L32.42|
00002a  6820              LDR      r0,[r4,#0]            ;3071
00002c  6840              LDR      r0,[r0,#4]            ;3071
00002e  f0200060          BIC      r0,r0,#0x60           ;3071
000032  6821              LDR      r1,[r4,#0]            ;3071
000034  6048              STR      r0,[r1,#4]            ;3071
000036  8ee0              LDRH     r0,[r4,#0x36]         ;3073
000038  b910              CBNZ     r0,|L32.64|
00003a  4620              MOV      r0,r4                 ;3075
00003c  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L32.64|
000040  bf00              NOP      
000042  e7f1              B        |L32.40|
;;;3079   
                          ENDP

                  |L32.68|
                          DCD      SPI_2linesRxISR_8BITCRC

                          AREA ||i.SPI_2linesRxISR_8BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_8BITCRC PROC
;;;3086     */
;;;3087   static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3088   {
000002  4604              MOV      r4,r0
;;;3089     /* Read 8bit CRC to flush Data Regsiter */
;;;3090     READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  7b00              LDRB     r0,[r0,#0xc]
;;;3091   
;;;3092     /* Disable RXNE and ERR interrupt */
;;;3093     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000008  6820              LDR      r0,[r4,#0]
00000a  6840              LDR      r0,[r0,#4]
00000c  f0200060          BIC      r0,r0,#0x60
000010  6821              LDR      r1,[r4,#0]
000012  6048              STR      r0,[r1,#4]
;;;3094   
;;;3095     if (hspi->TxXferCount == 0U)
000014  8ee0              LDRH     r0,[r4,#0x36]
000016  b910              CBNZ     r0,|L33.30|
;;;3096     {
;;;3097       SPI_CloseRxTx_ISR(hspi);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L33.30|
;;;3098     }
;;;3099   }
00001e  bd10              POP      {r4,pc}
;;;3100   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_2linesTxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_16BIT PROC
;;;3195     */
;;;3196   static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3197   {
000002  4604              MOV      r4,r0
;;;3198     /* Transmit data in 16 Bit mode */
;;;3199     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  8800              LDRH     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  60c8              STR      r0,[r1,#0xc]
;;;3200     hspi->pTxBuffPtr += sizeof(uint16_t);
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c80              ADDS     r0,r0,#2
000010  6320              STR      r0,[r4,#0x30]
;;;3201     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3202   
;;;3203     /* Enable CRC Transmission */
;;;3204     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b9d8              CBNZ     r0,|L34.84|
;;;3205     {
;;;3206   #if (USE_SPI_CRC != 0U)
;;;3207       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  f5b05f00          CMP      r0,#0x2000
000022  d10c              BNE      |L34.62|
;;;3208       {
;;;3209         /* Set CRC Next Bit to send CRC */
;;;3210         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f4405080          ORR      r0,r0,#0x1000
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
;;;3211         /* Disable TXE interrupt */
;;;3212         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
000030  6820              LDR      r0,[r4,#0]
000032  6840              LDR      r0,[r0,#4]
000034  f0200080          BIC      r0,r0,#0x80
000038  6821              LDR      r1,[r4,#0]
00003a  6048              STR      r0,[r1,#4]
                  |L34.60|
;;;3213         return;
;;;3214       }
;;;3215   #endif /* USE_SPI_CRC */
;;;3216   
;;;3217       /* Disable TXE interrupt */
;;;3218       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3219   
;;;3220       if (hspi->RxXferCount == 0U)
;;;3221       {
;;;3222         SPI_CloseRxTx_ISR(hspi);
;;;3223       }
;;;3224     }
;;;3225   }
00003c  bd10              POP      {r4,pc}
                  |L34.62|
00003e  6820              LDR      r0,[r4,#0]            ;3218
000040  6840              LDR      r0,[r0,#4]            ;3218
000042  f0200080          BIC      r0,r0,#0x80           ;3218
000046  6821              LDR      r1,[r4,#0]            ;3218
000048  6048              STR      r0,[r1,#4]            ;3218
00004a  8fe0              LDRH     r0,[r4,#0x3e]         ;3220
00004c  b910              CBNZ     r0,|L34.84|
00004e  4620              MOV      r0,r4                 ;3222
000050  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L34.84|
000054  bf00              NOP      
000056  e7f1              B        |L34.60|
;;;3226   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_8BIT PROC
;;;3107     */
;;;3108   static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3109   {
000002  4604              MOV      r4,r0
;;;3110     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  7800              LDRB     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  7308              STRB     r0,[r1,#0xc]
;;;3111     hspi->pTxBuffPtr++;
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c40              ADDS     r0,r0,#1
000010  6320              STR      r0,[r4,#0x30]
;;;3112     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3113   
;;;3114     /* Check the end of the transmission */
;;;3115     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b9d8              CBNZ     r0,|L35.84|
;;;3116     {
;;;3117   #if (USE_SPI_CRC != 0U)
;;;3118       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  f5b05f00          CMP      r0,#0x2000
000022  d10c              BNE      |L35.62|
;;;3119       {
;;;3120         /* Set CRC Next Bit to send CRC */
;;;3121         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f4405080          ORR      r0,r0,#0x1000
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
;;;3122         /* Disable TXE interrupt */
;;;3123         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
000030  6820              LDR      r0,[r4,#0]
000032  6840              LDR      r0,[r0,#4]
000034  f0200080          BIC      r0,r0,#0x80
000038  6821              LDR      r1,[r4,#0]
00003a  6048              STR      r0,[r1,#4]
                  |L35.60|
;;;3124         return;
;;;3125       }
;;;3126   #endif /* USE_SPI_CRC */
;;;3127   
;;;3128       /* Disable TXE interrupt */
;;;3129       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3130   
;;;3131       if (hspi->RxXferCount == 0U)
;;;3132       {
;;;3133         SPI_CloseRxTx_ISR(hspi);
;;;3134       }
;;;3135     }
;;;3136   }
00003c  bd10              POP      {r4,pc}
                  |L35.62|
00003e  6820              LDR      r0,[r4,#0]            ;3129
000040  6840              LDR      r0,[r0,#4]            ;3129
000042  f0200080          BIC      r0,r0,#0x80           ;3129
000046  6821              LDR      r1,[r4,#0]            ;3129
000048  6048              STR      r0,[r1,#4]            ;3129
00004a  8fe0              LDRH     r0,[r4,#0x3e]         ;3131
00004c  b910              CBNZ     r0,|L35.84|
00004e  4620              MOV      r0,r4                 ;3133
000050  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L35.84|
000054  bf00              NOP      
000056  e7f1              B        |L35.60|
;;;3137   
                          ENDP


                          AREA ||i.SPI_AbortRx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_AbortRx_ISR PROC
;;;3749     */
;;;3750   static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
000000  b508              PUSH     {r3,lr}
;;;3751   {
;;;3752     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000002  4918              LDR      r1,|L36.100|
000004  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000006  2218              MOVS     r2,#0x18
000008  fbb1f1f2          UDIV     r1,r1,r2
00000c  f44f727a          MOV      r2,#0x3e8
000010  fbb1f1f2          UDIV     r1,r1,r2
000014  2264              MOVS     r2,#0x64
000016  4351              MULS     r1,r2,r1
000018  9100              STR      r1,[sp,#0]
;;;3753   
;;;3754     /* Wait until TXE flag is set */
;;;3755     do
00001a  bf00              NOP      
                  |L36.28|
;;;3756     {
;;;3757       if (count == 0U)
00001c  9900              LDR      r1,[sp,#0]
00001e  b921              CBNZ     r1,|L36.42|
;;;3758       {
;;;3759         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000020  6d41              LDR      r1,[r0,#0x54]
000022  f0410140          ORR      r1,r1,#0x40
000026  6541              STR      r1,[r0,#0x54]
;;;3760         break;
000028  e008              B        |L36.60|
                  |L36.42|
;;;3761       }
;;;3762       count--;
00002a  9900              LDR      r1,[sp,#0]
00002c  1e49              SUBS     r1,r1,#1
00002e  9100              STR      r1,[sp,#0]
;;;3763     }
;;;3764     while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000030  6801              LDR      r1,[r0,#0]
000032  6889              LDR      r1,[r1,#8]
000034  f0010102          AND      r1,r1,#2
000038  2900              CMP      r1,#0
00003a  d0ef              BEQ      |L36.28|
                  |L36.60|
00003c  bf00              NOP                            ;3760
;;;3765   
;;;3766     /* Disable SPI Peripheral */
;;;3767     __HAL_SPI_DISABLE(hspi);
00003e  6801              LDR      r1,[r0,#0]
000040  6809              LDR      r1,[r1,#0]
000042  f0210140          BIC      r1,r1,#0x40
000046  6802              LDR      r2,[r0,#0]
000048  6011              STR      r1,[r2,#0]
;;;3768   
;;;3769     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;3770     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
00004a  6801              LDR      r1,[r0,#0]
00004c  6849              LDR      r1,[r1,#4]
00004e  f02101e0          BIC      r1,r1,#0xe0
000052  6802              LDR      r2,[r0,#0]
000054  6051              STR      r1,[r2,#4]
;;;3771   
;;;3772     /* Read CRC to flush Data Register */
;;;3773     READ_REG(hspi->Instance->DR);
000056  6801              LDR      r1,[r0,#0]
000058  68c9              LDR      r1,[r1,#0xc]
;;;3774   
;;;3775     hspi->State = HAL_SPI_STATE_ABORT;
00005a  2107              MOVS     r1,#7
00005c  f8801051          STRB     r1,[r0,#0x51]
;;;3776   }
000060  bd08              POP      {r3,pc}
;;;3777   
                          ENDP

000062  0000              DCW      0x0000
                  |L36.100|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_AbortTx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_AbortTx_ISR PROC
;;;3783     */
;;;3784   static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3785   {
;;;3786     /* Disable TXEIE interrupt */
;;;3787     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE));
000002  6849              LDR      r1,[r1,#4]
000004  f0210180          BIC      r1,r1,#0x80
000008  6802              LDR      r2,[r0,#0]
00000a  6051              STR      r1,[r2,#4]
;;;3788   
;;;3789     /* Disable SPI Peripheral */
;;;3790     __HAL_SPI_DISABLE(hspi);
00000c  6801              LDR      r1,[r0,#0]
00000e  6809              LDR      r1,[r1,#0]
000010  f0210140          BIC      r1,r1,#0x40
000014  6802              LDR      r2,[r0,#0]
000016  6011              STR      r1,[r2,#0]
;;;3791   
;;;3792     hspi->State = HAL_SPI_STATE_ABORT;
000018  2107              MOVS     r1,#7
00001a  f8801051          STRB     r1,[r0,#0x51]
;;;3793   }
00001e  4770              BX       lr
;;;3794   
                          ENDP


                          AREA ||i.SPI_CloseRxTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseRxTx_ISR PROC
;;;3528     */
;;;3529   static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;3530   {
000002  4604              MOV      r4,r0
;;;3531     uint32_t tickstart;
;;;3532     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  4836              LDR      r0,|L38.224|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  2118              MOVS     r1,#0x18
00000a  fbb0f0f1          UDIV     r0,r0,r1
00000e  f44f717a          MOV      r1,#0x3e8
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  2164              MOVS     r1,#0x64
000018  4348              MULS     r0,r1,r0
00001a  9001              STR      r0,[sp,#4]
;;;3533   
;;;3534     /* Init tickstart for timeout managment*/
;;;3535     tickstart = HAL_GetTick();
00001c  f7fffffe          BL       HAL_GetTick
000020  4605              MOV      r5,r0
;;;3536   
;;;3537     /* Disable ERR interrupt */
;;;3538     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
000022  6820              LDR      r0,[r4,#0]
000024  6840              LDR      r0,[r0,#4]
000026  f0200020          BIC      r0,r0,#0x20
00002a  6821              LDR      r1,[r4,#0]
00002c  6048              STR      r0,[r1,#4]
;;;3539   
;;;3540     /* Wait until TXE flag is set */
;;;3541     do
00002e  bf00              NOP      
                  |L38.48|
;;;3542     {
;;;3543       if (count == 0U)
000030  9801              LDR      r0,[sp,#4]
000032  b920              CBNZ     r0,|L38.62|
;;;3544       {
;;;3545         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000034  6d60              LDR      r0,[r4,#0x54]
000036  f0400020          ORR      r0,r0,#0x20
00003a  6560              STR      r0,[r4,#0x54]
;;;3546         break;
00003c  e008              B        |L38.80|
                  |L38.62|
;;;3547       }
;;;3548       count--;
00003e  9801              LDR      r0,[sp,#4]
000040  1e40              SUBS     r0,r0,#1
000042  9001              STR      r0,[sp,#4]
;;;3549     }
;;;3550     while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000044  6820              LDR      r0,[r4,#0]
000046  6880              LDR      r0,[r0,#8]
000048  f0000002          AND      r0,r0,#2
00004c  2800              CMP      r0,#0
00004e  d0ef              BEQ      |L38.48|
                  |L38.80|
000050  bf00              NOP                            ;3546
;;;3551   
;;;3552     /* Check the end of the transaction */
;;;3553     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000052  462a              MOV      r2,r5
000054  2164              MOVS     r1,#0x64
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       SPI_EndRxTxTransaction
00005c  b118              CBZ      r0,|L38.102|
;;;3554     {
;;;3555       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00005e  6d60              LDR      r0,[r4,#0x54]
000060  f0400020          ORR      r0,r0,#0x20
000064  6560              STR      r0,[r4,#0x54]
                  |L38.102|
;;;3556     }
;;;3557   
;;;3558     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3559     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000066  68a0              LDR      r0,[r4,#8]
000068  b950              CBNZ     r0,|L38.128|
;;;3560     {
;;;3561       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00006a  bf00              NOP      
00006c  2000              MOVS     r0,#0
00006e  9000              STR      r0,[sp,#0]
000070  6820              LDR      r0,[r4,#0]
000072  68c0              LDR      r0,[r0,#0xc]
000074  9000              STR      r0,[sp,#0]
000076  6820              LDR      r0,[r4,#0]
000078  6880              LDR      r0,[r0,#8]
00007a  9000              STR      r0,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
                  |L38.128|
;;;3562     }
;;;3563   
;;;3564   #if (USE_SPI_CRC != 0U)
;;;3565     /* Check if CRC error occurred */
;;;3566     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
000080  6820              LDR      r0,[r4,#0]
000082  6880              LDR      r0,[r0,#8]
000084  f3c01000          UBFX     r0,r0,#4,#1
000088  b170              CBZ      r0,|L38.168|
;;;3567     {
;;;3568       hspi->State = HAL_SPI_STATE_READY;
00008a  2001              MOVS     r0,#1
00008c  f8840051          STRB     r0,[r4,#0x51]
;;;3569       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
000090  6d60              LDR      r0,[r4,#0x54]
000092  f0400002          ORR      r0,r0,#2
000096  6560              STR      r0,[r4,#0x54]
;;;3570       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
000098  f64f70ef          MOV      r0,#0xffef
00009c  6821              LDR      r1,[r4,#0]
00009e  6088              STR      r0,[r1,#8]
;;;3571       /* Call user error callback */
;;;3572   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3573       hspi->ErrorCallback(hspi);
;;;3574   #else
;;;3575       HAL_SPI_ErrorCallback(hspi);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_SPI_ErrorCallback
0000a6  e019              B        |L38.220|
                  |L38.168|
;;;3576   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3577     }
;;;3578     else
;;;3579     {
;;;3580   #endif /* USE_SPI_CRC */
;;;3581       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
0000a8  6d60              LDR      r0,[r4,#0x54]
0000aa  b988              CBNZ     r0,|L38.208|
;;;3582       {
;;;3583         if (hspi->State == HAL_SPI_STATE_BUSY_RX)
0000ac  f8940051          LDRB     r0,[r4,#0x51]
0000b0  2804              CMP      r0,#4
0000b2  d106              BNE      |L38.194|
;;;3584         {
;;;3585           hspi->State = HAL_SPI_STATE_READY;
0000b4  2001              MOVS     r0,#1
0000b6  f8840051          STRB     r0,[r4,#0x51]
;;;3586           /* Call user Rx complete callback */
;;;3587   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3588           hspi->RxCpltCallback(hspi);
;;;3589   #else
;;;3590           HAL_SPI_RxCpltCallback(hspi);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       HAL_SPI_RxCpltCallback
0000c0  e00c              B        |L38.220|
                  |L38.194|
;;;3591   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3592         }
;;;3593         else
;;;3594         {
;;;3595           hspi->State = HAL_SPI_STATE_READY;
0000c2  2001              MOVS     r0,#1
0000c4  f8840051          STRB     r0,[r4,#0x51]
;;;3596           /* Call user TxRx complete callback */
;;;3597   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3598           hspi->TxRxCpltCallback(hspi);
;;;3599   #else
;;;3600           HAL_SPI_TxRxCpltCallback(hspi);
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
0000ce  e005              B        |L38.220|
                  |L38.208|
;;;3601   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3602         }
;;;3603       }
;;;3604       else
;;;3605       {
;;;3606         hspi->State = HAL_SPI_STATE_READY;
0000d0  2001              MOVS     r0,#1
0000d2  f8840051          STRB     r0,[r4,#0x51]
;;;3607         /* Call user error callback */
;;;3608   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3609         hspi->ErrorCallback(hspi);
;;;3610   #else
;;;3611         HAL_SPI_ErrorCallback(hspi);
0000d6  4620              MOV      r0,r4
0000d8  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L38.220|
;;;3612   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3613       }
;;;3614   #if (USE_SPI_CRC != 0U)
;;;3615     }
;;;3616   #endif /* USE_SPI_CRC */
;;;3617   }
0000dc  bd7c              POP      {r2-r6,pc}
;;;3618   
                          ENDP

0000de  0000              DCW      0x0000
                  |L38.224|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_CloseRx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_CloseRx_ISR PROC
;;;3624     */
;;;3625   static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
000000  b538              PUSH     {r3-r5,lr}
;;;3626   {
000002  4604              MOV      r4,r0
;;;3627     /* Disable RXNE and ERR interrupt */
;;;3628     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  f0200060          BIC      r0,r0,#0x60
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;3629   
;;;3630     /* Check the end of the transaction */
;;;3631     if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000010  f7fffffe          BL       HAL_GetTick
000014  4605              MOV      r5,r0
000016  462a              MOV      r2,r5
000018  2164              MOVS     r1,#0x64
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_EndRxTransaction
000020  b118              CBZ      r0,|L39.42|
;;;3632     {
;;;3633       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000022  6d60              LDR      r0,[r4,#0x54]
000024  f0400020          ORR      r0,r0,#0x20
000028  6560              STR      r0,[r4,#0x54]
                  |L39.42|
;;;3634     }
;;;3635   
;;;3636     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3637     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
00002a  68a0              LDR      r0,[r4,#8]
00002c  b950              CBNZ     r0,|L39.68|
;;;3638     {
;;;3639       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00002e  bf00              NOP      
000030  2000              MOVS     r0,#0
000032  9000              STR      r0,[sp,#0]
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  9000              STR      r0,[sp,#0]
00003a  6820              LDR      r0,[r4,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  9000              STR      r0,[sp,#0]
000040  bf00              NOP      
000042  bf00              NOP      
                  |L39.68|
;;;3640     }
;;;3641     hspi->State = HAL_SPI_STATE_READY;
000044  2001              MOVS     r0,#1
000046  f8840051          STRB     r0,[r4,#0x51]
;;;3642   
;;;3643   #if (USE_SPI_CRC != 0U)
;;;3644     /* Check if CRC error occurred */
;;;3645     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
00004a  6820              LDR      r0,[r4,#0]
00004c  6880              LDR      r0,[r0,#8]
00004e  f3c01000          UBFX     r0,r0,#4,#1
000052  b158              CBZ      r0,|L39.108|
;;;3646     {
;;;3647       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
000054  6d60              LDR      r0,[r4,#0x54]
000056  f0400002          ORR      r0,r0,#2
00005a  6560              STR      r0,[r4,#0x54]
;;;3648       __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
00005c  f64f70ef          MOV      r0,#0xffef
000060  6821              LDR      r1,[r4,#0]
000062  6088              STR      r0,[r1,#8]
;;;3649       /* Call user error callback */
;;;3650   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3651       hspi->ErrorCallback(hspi);
;;;3652   #else
;;;3653       HAL_SPI_ErrorCallback(hspi);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       HAL_SPI_ErrorCallback
00006a  e008              B        |L39.126|
                  |L39.108|
;;;3654   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3655     }
;;;3656     else
;;;3657     {
;;;3658   #endif /* USE_SPI_CRC */
;;;3659       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
00006c  6d60              LDR      r0,[r4,#0x54]
00006e  b918              CBNZ     r0,|L39.120|
;;;3660       {
;;;3661         /* Call user Rx complete callback */
;;;3662   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3663         hspi->RxCpltCallback(hspi);
;;;3664   #else
;;;3665         HAL_SPI_RxCpltCallback(hspi);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_SPI_RxCpltCallback
000076  e002              B        |L39.126|
                  |L39.120|
;;;3666   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3667       }
;;;3668       else
;;;3669       {
;;;3670         /* Call user error callback */
;;;3671   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3672         hspi->ErrorCallback(hspi);
;;;3673   #else
;;;3674         HAL_SPI_ErrorCallback(hspi);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L39.126|
;;;3675   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3676       }
;;;3677   #if (USE_SPI_CRC != 0U)
;;;3678     }
;;;3679   #endif /* USE_SPI_CRC */
;;;3680   }
00007e  bd38              POP      {r3-r5,pc}
;;;3681   
                          ENDP


                          AREA ||i.SPI_CloseTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseTx_ISR PROC
;;;3687     */
;;;3688   static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;3689   {
000002  4604              MOV      r4,r0
;;;3690     uint32_t tickstart;
;;;3691     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  4825              LDR      r0,|L40.156|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  2118              MOVS     r1,#0x18
00000a  fbb0f0f1          UDIV     r0,r0,r1
00000e  f44f717a          MOV      r1,#0x3e8
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  2164              MOVS     r1,#0x64
000018  4348              MULS     r0,r1,r0
00001a  9001              STR      r0,[sp,#4]
;;;3692   
;;;3693     /* Init tickstart for timeout management*/
;;;3694     tickstart = HAL_GetTick();
00001c  f7fffffe          BL       HAL_GetTick
000020  4605              MOV      r5,r0
;;;3695   
;;;3696     /* Wait until TXE flag is set */
;;;3697     do
000022  bf00              NOP      
                  |L40.36|
;;;3698     {
;;;3699       if (count == 0U)
000024  9801              LDR      r0,[sp,#4]
000026  b920              CBNZ     r0,|L40.50|
;;;3700       {
;;;3701         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000028  6d60              LDR      r0,[r4,#0x54]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6560              STR      r0,[r4,#0x54]
;;;3702         break;
000030  e008              B        |L40.68|
                  |L40.50|
;;;3703       }
;;;3704       count--;
000032  9801              LDR      r0,[sp,#4]
000034  1e40              SUBS     r0,r0,#1
000036  9001              STR      r0,[sp,#4]
;;;3705     }
;;;3706     while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  f0000002          AND      r0,r0,#2
000040  2800              CMP      r0,#0
000042  d0ef              BEQ      |L40.36|
                  |L40.68|
000044  bf00              NOP                            ;3702
;;;3707   
;;;3708     /* Disable TXE and ERR interrupt */
;;;3709     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
000046  6820              LDR      r0,[r4,#0]
000048  6840              LDR      r0,[r0,#4]
00004a  f02000a0          BIC      r0,r0,#0xa0
00004e  6821              LDR      r1,[r4,#0]
000050  6048              STR      r0,[r1,#4]
;;;3710   
;;;3711     /* Check the end of the transaction */
;;;3712     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000052  462a              MOV      r2,r5
000054  2164              MOVS     r1,#0x64
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       SPI_EndRxTxTransaction
00005c  b118              CBZ      r0,|L40.102|
;;;3713     {
;;;3714       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00005e  6d60              LDR      r0,[r4,#0x54]
000060  f0400020          ORR      r0,r0,#0x20
000064  6560              STR      r0,[r4,#0x54]
                  |L40.102|
;;;3715     }
;;;3716   
;;;3717     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3718     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000066  68a0              LDR      r0,[r4,#8]
000068  b950              CBNZ     r0,|L40.128|
;;;3719     {
;;;3720       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00006a  bf00              NOP      
00006c  2000              MOVS     r0,#0
00006e  9000              STR      r0,[sp,#0]
000070  6820              LDR      r0,[r4,#0]
000072  68c0              LDR      r0,[r0,#0xc]
000074  9000              STR      r0,[sp,#0]
000076  6820              LDR      r0,[r4,#0]
000078  6880              LDR      r0,[r0,#8]
00007a  9000              STR      r0,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
                  |L40.128|
;;;3721     }
;;;3722   
;;;3723     hspi->State = HAL_SPI_STATE_READY;
000080  2001              MOVS     r0,#1
000082  f8840051          STRB     r0,[r4,#0x51]
;;;3724     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000086  6d60              LDR      r0,[r4,#0x54]
000088  b118              CBZ      r0,|L40.146|
;;;3725     {
;;;3726       /* Call user error callback */
;;;3727   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3728       hspi->ErrorCallback(hspi);
;;;3729   #else
;;;3730       HAL_SPI_ErrorCallback(hspi);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_SPI_ErrorCallback
000090  e002              B        |L40.152|
                  |L40.146|
;;;3731   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3732     }
;;;3733     else
;;;3734     {
;;;3735       /* Call user Rx complete callback */
;;;3736   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3737       hspi->TxCpltCallback(hspi);
;;;3738   #else
;;;3739       HAL_SPI_TxCpltCallback(hspi);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       HAL_SPI_TxCpltCallback
                  |L40.152|
;;;3740   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3741     }
;;;3742   }
000098  bd7c              POP      {r2-r6,pc}
;;;3743   
                          ENDP

00009a  0000              DCW      0x0000
                  |L40.156|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  SPI_DMAAbortOnError PROC
;;;2904     */
;;;2905   static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2906   {
000002  4605              MOV      r5,r0
;;;2907     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2908     hspi->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  87e0              STRH     r0,[r4,#0x3e]
;;;2909     hspi->TxXferCount = 0U;
00000a  86e0              STRH     r0,[r4,#0x36]
;;;2910   
;;;2911     /* Call user error callback */
;;;2912   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2913     hspi->ErrorCallback(hspi);
;;;2914   #else
;;;2915     HAL_SPI_ErrorCallback(hspi);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2916   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2917   }
000012  bd70              POP      {r4-r6,pc}
;;;2918   
                          ENDP


                          AREA ||i.SPI_DMAError||, CODE, READONLY, ALIGN=1

                  SPI_DMAError PROC
;;;2881     */
;;;2882   static void SPI_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2883   {
000002  4605              MOV      r5,r0
;;;2884     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2885   
;;;2886     /* Stop the disable DMA transfer on SPI side */
;;;2887     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  f0200003          BIC      r0,r0,#3
00000e  6821              LDR      r1,[r4,#0]
000010  6048              STR      r0,[r1,#4]
;;;2888   
;;;2889     SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000012  6d60              LDR      r0,[r4,#0x54]
000014  f0400010          ORR      r0,r0,#0x10
000018  6560              STR      r0,[r4,#0x54]
;;;2890     hspi->State = HAL_SPI_STATE_READY;
00001a  2001              MOVS     r0,#1
00001c  f8840051          STRB     r0,[r4,#0x51]
;;;2891     /* Call user error callback */
;;;2892   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2893     hspi->ErrorCallback(hspi);
;;;2894   #else
;;;2895     HAL_SPI_ErrorCallback(hspi);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2896   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2897   }
000026  bd70              POP      {r4-r6,pc}
;;;2898   
                          ENDP


                          AREA ||i.SPI_DMAHalfReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfReceiveCplt PROC
;;;2845     */
;;;2846   static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2847   {
000002  4604              MOV      r4,r0
;;;2848     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2849   
;;;2850     /* Call user Rx half complete callback */
;;;2851   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2852     hspi->RxHalfCpltCallback(hspi);
;;;2853   #else
;;;2854     HAL_SPI_RxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_RxHalfCpltCallback
;;;2855   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2856   }
00000c  bd70              POP      {r4-r6,pc}
;;;2857   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitCplt PROC
;;;2827     */
;;;2828   static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2829   {
000002  4604              MOV      r4,r0
;;;2830     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2831   
;;;2832     /* Call user Tx half complete callback */
;;;2833   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2834     hspi->TxHalfCpltCallback(hspi);
;;;2835   #else
;;;2836     HAL_SPI_TxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_TxHalfCpltCallback
;;;2837   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2838   }
00000c  bd70              POP      {r4-r6,pc}
;;;2839   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitReceiveCplt PROC
;;;2863     */
;;;2864   static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2865   {
000002  4604              MOV      r4,r0
;;;2866     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2867   
;;;2868     /* Call user TxRx half complete callback */
;;;2869   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2870     hspi->TxRxHalfCpltCallback(hspi);
;;;2871   #else
;;;2872     HAL_SPI_TxRxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_TxRxHalfCpltCallback
;;;2873   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2874   }
00000c  bd70              POP      {r4-r6,pc}
;;;2875   
                          ENDP


                          AREA ||i.SPI_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAReceiveCplt PROC
;;;2677     */
;;;2678   static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2679   {
000002  4605              MOV      r5,r0
;;;2680     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2681     uint32_t tickstart;
;;;2682   
;;;2683     /* Init tickstart for timeout management*/
;;;2684     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2685   
;;;2686     /* DMA Normal Mode */
;;;2687     if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f4007080          AND      r0,r0,#0x100
000014  f5b07f80          CMP      r0,#0x100
000018  d03e              BEQ      |L46.152|
;;;2688     {
;;;2689       /* Disable ERR interrupt */
;;;2690       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f0200020          BIC      r0,r0,#0x20
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;2691   
;;;2692   #if (USE_SPI_CRC != 0U)
;;;2693       /* CRC handling */
;;;2694       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000026  6aa0              LDR      r0,[r4,#0x28]
000028  f5b05f00          CMP      r0,#0x2000
00002c  d10d              BNE      |L46.74|
;;;2695       {
;;;2696         /* Wait until RXNE flag */
;;;2697         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00002e  2364              MOVS     r3,#0x64
000030  2201              MOVS     r2,#1
000032  4611              MOV      r1,r2
000034  4620              MOV      r0,r4
000036  9600              STR      r6,[sp,#0]
000038  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00003c  b118              CBZ      r0,|L46.70|
;;;2698         {
;;;2699           /* Error on the CRC reception */
;;;2700           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
00003e  6d60              LDR      r0,[r4,#0x54]
000040  f0400002          ORR      r0,r0,#2
000044  6560              STR      r0,[r4,#0x54]
                  |L46.70|
;;;2701         }
;;;2702         /* Read CRC */
;;;2703         READ_REG(hspi->Instance->DR);
000046  6820              LDR      r0,[r4,#0]
000048  68c0              LDR      r0,[r0,#0xc]
                  |L46.74|
;;;2704       }
;;;2705   #endif /* USE_SPI_CRC */
;;;2706   
;;;2707       /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
;;;2708       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00004a  6820              LDR      r0,[r4,#0]
00004c  6840              LDR      r0,[r0,#4]
00004e  f0200003          BIC      r0,r0,#3
000052  6821              LDR      r1,[r4,#0]
000054  6048              STR      r0,[r1,#4]
;;;2709   
;;;2710       /* Check the end of the transaction */
;;;2711       if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000056  4632              MOV      r2,r6
000058  2164              MOVS     r1,#0x64
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       SPI_EndRxTransaction
000060  b108              CBZ      r0,|L46.102|
;;;2712       {
;;;2713         hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
000062  2020              MOVS     r0,#0x20
000064  6560              STR      r0,[r4,#0x54]
                  |L46.102|
;;;2714       }
;;;2715   
;;;2716       hspi->RxXferCount = 0U;
000066  2000              MOVS     r0,#0
000068  87e0              STRH     r0,[r4,#0x3e]
;;;2717       hspi->State = HAL_SPI_STATE_READY;
00006a  2001              MOVS     r0,#1
00006c  f8840051          STRB     r0,[r4,#0x51]
;;;2718   
;;;2719   #if (USE_SPI_CRC != 0U)
;;;2720       /* Check if CRC error occurred */
;;;2721       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
000070  6820              LDR      r0,[r4,#0]
000072  6880              LDR      r0,[r0,#8]
000074  f0000010          AND      r0,r0,#0x10
000078  2810              CMP      r0,#0x10
00007a  d107              BNE      |L46.140|
;;;2722       {
;;;2723         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
00007c  6d60              LDR      r0,[r4,#0x54]
00007e  f0400002          ORR      r0,r0,#2
000082  6560              STR      r0,[r4,#0x54]
;;;2724         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
000084  f64f70ef          MOV      r0,#0xffef
000088  6821              LDR      r1,[r4,#0]
00008a  6088              STR      r0,[r1,#8]
                  |L46.140|
;;;2725       }
;;;2726   #endif /* USE_SPI_CRC */
;;;2727   
;;;2728       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
00008c  6d60              LDR      r0,[r4,#0x54]
00008e  b118              CBZ      r0,|L46.152|
;;;2729       {
;;;2730         /* Call user error callback */
;;;2731   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2732         hspi->ErrorCallback(hspi);
;;;2733   #else
;;;2734         HAL_SPI_ErrorCallback(hspi);
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L46.150|
;;;2735   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2736         return;
;;;2737       }
;;;2738     }
;;;2739     /* Call user Rx complete callback */
;;;2740   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2741     hspi->RxCpltCallback(hspi);
;;;2742   #else
;;;2743     HAL_SPI_RxCpltCallback(hspi);
;;;2744   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2745   }
000096  bdf8              POP      {r3-r7,pc}
                  |L46.152|
000098  4620              MOV      r0,r4                 ;2743
00009a  f7fffffe          BL       HAL_SPI_RxCpltCallback
00009e  bf00              NOP      
0000a0  e7f9              B        |L46.150|
;;;2746   
                          ENDP


                          AREA ||i.SPI_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  SPI_DMARxAbortCallback PROC
;;;2992     */
;;;2993   static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2994   {
000002  4605              MOV      r5,r0
;;;2995     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2996   
;;;2997     /* Disable SPI Peripheral */
;;;2998     __HAL_SPI_DISABLE(hspi);
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f0200040          BIC      r0,r0,#0x40
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;2999   
;;;3000     hspi->hdmarx->XferAbortCallback = NULL;
000012  2000              MOVS     r0,#0
000014  6ce1              LDR      r1,[r4,#0x4c]
000016  6508              STR      r0,[r1,#0x50]
;;;3001   
;;;3002     /* Disable Rx DMA Request */
;;;3003     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  f0200001          BIC      r0,r0,#1
000020  6821              LDR      r1,[r4,#0]
000022  6048              STR      r0,[r1,#4]
;;;3004   
;;;3005     /* Check Busy flag */
;;;3006     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000024  f7fffffe          BL       HAL_GetTick
000028  4606              MOV      r6,r0
00002a  4632              MOV      r2,r6
00002c  2164              MOVS     r1,#0x64
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SPI_EndRxTxTransaction
000034  b118              CBZ      r0,|L47.62|
;;;3007     {
;;;3008       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000036  6d60              LDR      r0,[r4,#0x54]
000038  f0400040          ORR      r0,r0,#0x40
00003c  6560              STR      r0,[r4,#0x54]
                  |L47.62|
;;;3009     }
;;;3010   
;;;3011     /* Check if an Abort process is still ongoing */
;;;3012     if (hspi->hdmatx != NULL)
00003e  6ca0              LDR      r0,[r4,#0x48]
000040  b118              CBZ      r0,|L47.74|
;;;3013     {
;;;3014       if (hspi->hdmatx->XferAbortCallback != NULL)
000042  6ca0              LDR      r0,[r4,#0x48]
000044  6d00              LDR      r0,[r0,#0x50]
000046  b100              CBZ      r0,|L47.74|
                  |L47.72|
;;;3015       {
;;;3016         return;
;;;3017       }
;;;3018     }
;;;3019   
;;;3020     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3021     hspi->RxXferCount = 0U;
;;;3022     hspi->TxXferCount = 0U;
;;;3023   
;;;3024     /* Check no error during Abort procedure */
;;;3025     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
;;;3026     {
;;;3027       /* Reset errorCode */
;;;3028       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;3029     }
;;;3030   
;;;3031     /* Clear the Error flags in the SR register */
;;;3032     __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;3033     __HAL_SPI_CLEAR_FREFLAG(hspi);
;;;3034   
;;;3035     /* Restore hspi->State to Ready */
;;;3036     hspi->State  = HAL_SPI_STATE_READY;
;;;3037   
;;;3038     /* Call user Abort complete callback */
;;;3039   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3040     hspi->AbortCpltCallback(hspi);
;;;3041   #else
;;;3042     HAL_SPI_AbortCpltCallback(hspi);
;;;3043   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3044   }
000048  bdf8              POP      {r3-r7,pc}
                  |L47.74|
00004a  2000              MOVS     r0,#0                 ;3021
00004c  87e0              STRH     r0,[r4,#0x3e]         ;3021
00004e  86e0              STRH     r0,[r4,#0x36]         ;3022
000050  6d60              LDR      r0,[r4,#0x54]         ;3025
000052  2840              CMP      r0,#0x40              ;3025
000054  d001              BEQ      |L47.90|
000056  2000              MOVS     r0,#0                 ;3028
000058  6560              STR      r0,[r4,#0x54]         ;3028
                  |L47.90|
00005a  bf00              NOP                            ;3032
00005c  2000              MOVS     r0,#0                 ;3032
00005e  9000              STR      r0,[sp,#0]            ;3032
000060  6820              LDR      r0,[r4,#0]            ;3032
000062  68c0              LDR      r0,[r0,#0xc]          ;3032
000064  9000              STR      r0,[sp,#0]            ;3032
000066  6820              LDR      r0,[r4,#0]            ;3032
000068  6880              LDR      r0,[r0,#8]            ;3032
00006a  9000              STR      r0,[sp,#0]            ;3032
00006c  bf00              NOP                            ;3032
00006e  bf00              NOP                            ;3032
000070  bf00              NOP                            ;3033
000072  2000              MOVS     r0,#0                 ;3033
000074  9000              STR      r0,[sp,#0]            ;3033
000076  6820              LDR      r0,[r4,#0]            ;3033
000078  6880              LDR      r0,[r0,#8]            ;3033
00007a  9000              STR      r0,[sp,#0]            ;3033
00007c  bf00              NOP                            ;3033
00007e  bf00              NOP                            ;3033
000080  2001              MOVS     r0,#1                 ;3036
000082  f8840051          STRB     r0,[r4,#0x51]         ;3036
000086  4620              MOV      r0,r4                 ;3042
000088  f7fffffe          BL       HAL_SPI_AbortCpltCallback
00008c  bf00              NOP      
00008e  e7db              B        |L47.72|
;;;3045   
                          ENDP


                          AREA ||i.SPI_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitCplt PROC
;;;2620     */
;;;2621   static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2622   {
000002  4605              MOV      r5,r0
;;;2623     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2624     uint32_t tickstart;
;;;2625   
;;;2626     /* Init tickstart for timeout management*/
;;;2627     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2628   
;;;2629     /* DMA Normal Mode */
;;;2630     if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f4007080          AND      r0,r0,#0x100
000014  f5b07f80          CMP      r0,#0x100
000018  d02d              BEQ      |L48.118|
;;;2631     {
;;;2632       /* Disable ERR interrupt */
;;;2633       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f0200020          BIC      r0,r0,#0x20
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;2634   
;;;2635       /* Disable Tx DMA Request */
;;;2636       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
000026  6820              LDR      r0,[r4,#0]
000028  6840              LDR      r0,[r0,#4]
00002a  f0200002          BIC      r0,r0,#2
00002e  6821              LDR      r1,[r4,#0]
000030  6048              STR      r0,[r1,#4]
;;;2637   
;;;2638       /* Check the end of the transaction */
;;;2639       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000032  4632              MOV      r2,r6
000034  2164              MOVS     r1,#0x64
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       SPI_EndRxTxTransaction
00003c  b118              CBZ      r0,|L48.70|
;;;2640       {
;;;2641         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00003e  6d60              LDR      r0,[r4,#0x54]
000040  f0400020          ORR      r0,r0,#0x20
000044  6560              STR      r0,[r4,#0x54]
                  |L48.70|
;;;2642       }
;;;2643   
;;;2644       /* Clear overrun flag in 2 Lines communication mode because received data is not read */
;;;2645       if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000046  68a0              LDR      r0,[r4,#8]
000048  b950              CBNZ     r0,|L48.96|
;;;2646       {
;;;2647         __HAL_SPI_CLEAR_OVRFLAG(hspi);
00004a  bf00              NOP      
00004c  2000              MOVS     r0,#0
00004e  9000              STR      r0,[sp,#0]
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  9000              STR      r0,[sp,#0]
000056  6820              LDR      r0,[r4,#0]
000058  6880              LDR      r0,[r0,#8]
00005a  9000              STR      r0,[sp,#0]
00005c  bf00              NOP      
00005e  bf00              NOP      
                  |L48.96|
;;;2648       }
;;;2649   
;;;2650       hspi->TxXferCount = 0U;
000060  2000              MOVS     r0,#0
000062  86e0              STRH     r0,[r4,#0x36]
;;;2651       hspi->State = HAL_SPI_STATE_READY;
000064  2001              MOVS     r0,#1
000066  f8840051          STRB     r0,[r4,#0x51]
;;;2652   
;;;2653       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
00006a  6d60              LDR      r0,[r4,#0x54]
00006c  b118              CBZ      r0,|L48.118|
;;;2654       {
;;;2655         /* Call user error callback */
;;;2656   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2657         hspi->ErrorCallback(hspi);
;;;2658   #else
;;;2659         HAL_SPI_ErrorCallback(hspi);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L48.116|
;;;2660   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2661         return;
;;;2662       }
;;;2663     }
;;;2664     /* Call user Tx complete callback */
;;;2665   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2666     hspi->TxCpltCallback(hspi);
;;;2667   #else
;;;2668     HAL_SPI_TxCpltCallback(hspi);
;;;2669   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2670   }
000074  bdf8              POP      {r3-r7,pc}
                  |L48.118|
000076  4620              MOV      r0,r4                 ;2668
000078  f7fffffe          BL       HAL_SPI_TxCpltCallback
00007c  bf00              NOP      
00007e  e7f9              B        |L48.116|
;;;2671   
                          ENDP


                          AREA ||i.SPI_DMATransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitReceiveCplt PROC
;;;2752     */
;;;2753   static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2754   {
000002  4605              MOV      r5,r0
;;;2755     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2756     uint32_t tickstart;
;;;2757   
;;;2758     /* Init tickstart for timeout management*/
;;;2759     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2760   
;;;2761     /* DMA Normal Mode */
;;;2762     if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f4007080          AND      r0,r0,#0x100
000014  f5b07f80          CMP      r0,#0x100
000018  d041              BEQ      |L49.158|
;;;2763     {
;;;2764       /* Disable ERR interrupt */
;;;2765       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  f0200020          BIC      r0,r0,#0x20
000022  6821              LDR      r1,[r4,#0]
000024  6048              STR      r0,[r1,#4]
;;;2766   
;;;2767   #if (USE_SPI_CRC != 0U)
;;;2768       /* CRC handling */
;;;2769       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000026  6aa0              LDR      r0,[r4,#0x28]
000028  f5b05f00          CMP      r0,#0x2000
00002c  d10d              BNE      |L49.74|
;;;2770       {
;;;2771         /* Wait the CRC data */
;;;2772         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00002e  2364              MOVS     r3,#0x64
000030  2201              MOVS     r2,#1
000032  4611              MOV      r1,r2
000034  4620              MOV      r0,r4
000036  9600              STR      r6,[sp,#0]
000038  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00003c  b118              CBZ      r0,|L49.70|
;;;2773         {
;;;2774           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
00003e  6d60              LDR      r0,[r4,#0x54]
000040  f0400002          ORR      r0,r0,#2
000044  6560              STR      r0,[r4,#0x54]
                  |L49.70|
;;;2775         }
;;;2776         /* Read CRC to Flush DR and RXNE flag */
;;;2777         READ_REG(hspi->Instance->DR);
000046  6820              LDR      r0,[r4,#0]
000048  68c0              LDR      r0,[r0,#0xc]
                  |L49.74|
;;;2778       }
;;;2779   #endif /* USE_SPI_CRC */
;;;2780   
;;;2781       /* Check the end of the transaction */
;;;2782       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00004a  4632              MOV      r2,r6
00004c  2164              MOVS     r1,#0x64
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       SPI_EndRxTxTransaction
000054  b118              CBZ      r0,|L49.94|
;;;2783       {
;;;2784         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000056  6d60              LDR      r0,[r4,#0x54]
000058  f0400020          ORR      r0,r0,#0x20
00005c  6560              STR      r0,[r4,#0x54]
                  |L49.94|
;;;2785       }
;;;2786   
;;;2787       /* Disable Rx/Tx DMA Request */
;;;2788       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00005e  6820              LDR      r0,[r4,#0]
000060  6840              LDR      r0,[r0,#4]
000062  f0200003          BIC      r0,r0,#3
000066  6821              LDR      r1,[r4,#0]
000068  6048              STR      r0,[r1,#4]
;;;2789   
;;;2790       hspi->TxXferCount = 0U;
00006a  2000              MOVS     r0,#0
00006c  86e0              STRH     r0,[r4,#0x36]
;;;2791       hspi->RxXferCount = 0U;
00006e  87e0              STRH     r0,[r4,#0x3e]
;;;2792       hspi->State = HAL_SPI_STATE_READY;
000070  2001              MOVS     r0,#1
000072  f8840051          STRB     r0,[r4,#0x51]
;;;2793   
;;;2794   #if (USE_SPI_CRC != 0U)
;;;2795       /* Check if CRC error occurred */
;;;2796       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
000076  6820              LDR      r0,[r4,#0]
000078  6880              LDR      r0,[r0,#8]
00007a  f0000010          AND      r0,r0,#0x10
00007e  2810              CMP      r0,#0x10
000080  d107              BNE      |L49.146|
;;;2797       {
;;;2798         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
000082  6d60              LDR      r0,[r4,#0x54]
000084  f0400002          ORR      r0,r0,#2
000088  6560              STR      r0,[r4,#0x54]
;;;2799         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
00008a  f64f70ef          MOV      r0,#0xffef
00008e  6821              LDR      r1,[r4,#0]
000090  6088              STR      r0,[r1,#8]
                  |L49.146|
;;;2800       }
;;;2801   #endif /* USE_SPI_CRC */
;;;2802   
;;;2803       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000092  6d60              LDR      r0,[r4,#0x54]
000094  b118              CBZ      r0,|L49.158|
;;;2804       {
;;;2805         /* Call user error callback */
;;;2806   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2807         hspi->ErrorCallback(hspi);
;;;2808   #else
;;;2809         HAL_SPI_ErrorCallback(hspi);
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L49.156|
;;;2810   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2811         return;
;;;2812       }
;;;2813     }
;;;2814     /* Call user TxRx complete callback */
;;;2815   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2816     hspi->TxRxCpltCallback(hspi);
;;;2817   #else
;;;2818     HAL_SPI_TxRxCpltCallback(hspi);
;;;2819   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2820   }
00009c  bdf8              POP      {r3-r7,pc}
                  |L49.158|
00009e  4620              MOV      r0,r4                 ;2818
0000a0  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
0000a4  bf00              NOP      
0000a6  e7f9              B        |L49.156|
;;;2821   
                          ENDP


                          AREA ||i.SPI_DMATxAbortCallback||, CODE, READONLY, ALIGN=2

                  SPI_DMATxAbortCallback PROC
;;;2926     */
;;;2927   static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b57c              PUSH     {r2-r6,lr}
;;;2928   {
000002  4605              MOV      r5,r0
;;;2929     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6bac              LDR      r4,[r5,#0x38]
;;;2930     __IO uint32_t count;
;;;2931   
;;;2932     hspi->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ca1              LDR      r1,[r4,#0x48]
00000a  6508              STR      r0,[r1,#0x50]
;;;2933     count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
00000c  4826              LDR      r0,|L50.168|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  2118              MOVS     r1,#0x18
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  f44f717a          MOV      r1,#0x3e8
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  2164              MOVS     r1,#0x64
000020  4348              MULS     r0,r1,r0
000022  9001              STR      r0,[sp,#4]
;;;2934   
;;;2935     /* Disable Tx DMA Request */
;;;2936     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  f0200002          BIC      r0,r0,#2
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;2937   
;;;2938     /* Wait until TXE flag is set */
;;;2939     do
000030  bf00              NOP      
                  |L50.50|
;;;2940     {
;;;2941       if (count == 0U)
000032  9801              LDR      r0,[sp,#4]
000034  b920              CBNZ     r0,|L50.64|
;;;2942       {
;;;2943         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000036  6d60              LDR      r0,[r4,#0x54]
000038  f0400040          ORR      r0,r0,#0x40
00003c  6560              STR      r0,[r4,#0x54]
;;;2944         break;
00003e  e008              B        |L50.82|
                  |L50.64|
;;;2945       }
;;;2946       count--;
000040  9801              LDR      r0,[sp,#4]
000042  1e40              SUBS     r0,r0,#1
000044  9001              STR      r0,[sp,#4]
;;;2947     }
;;;2948     while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  f0000002          AND      r0,r0,#2
00004e  2800              CMP      r0,#0
000050  d0ef              BEQ      |L50.50|
                  |L50.82|
000052  bf00              NOP                            ;2944
;;;2949   
;;;2950     /* Check if an Abort process is still ongoing */
;;;2951     if (hspi->hdmarx != NULL)
000054  6ce0              LDR      r0,[r4,#0x4c]
000056  b118              CBZ      r0,|L50.96|
;;;2952     {
;;;2953       if (hspi->hdmarx->XferAbortCallback != NULL)
000058  6ce0              LDR      r0,[r4,#0x4c]
00005a  6d00              LDR      r0,[r0,#0x50]
00005c  b100              CBZ      r0,|L50.96|
                  |L50.94|
;;;2954       {
;;;2955         return;
;;;2956       }
;;;2957     }
;;;2958   
;;;2959     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;2960     hspi->RxXferCount = 0U;
;;;2961     hspi->TxXferCount = 0U;
;;;2962   
;;;2963     /* Check no error during Abort procedure */
;;;2964     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
;;;2965     {
;;;2966       /* Reset errorCode */
;;;2967       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;2968     }
;;;2969   
;;;2970     /* Clear the Error flags in the SR register */
;;;2971     __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2972     __HAL_SPI_CLEAR_FREFLAG(hspi);
;;;2973   
;;;2974     /* Restore hspi->State to Ready */
;;;2975     hspi->State  = HAL_SPI_STATE_READY;
;;;2976   
;;;2977     /* Call user Abort complete callback */
;;;2978   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2979     hspi->AbortCpltCallback(hspi);
;;;2980   #else
;;;2981     HAL_SPI_AbortCpltCallback(hspi);
;;;2982   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2983   }
00005e  bd7c              POP      {r2-r6,pc}
                  |L50.96|
000060  2000              MOVS     r0,#0                 ;2960
000062  87e0              STRH     r0,[r4,#0x3e]         ;2960
000064  86e0              STRH     r0,[r4,#0x36]         ;2961
000066  6d60              LDR      r0,[r4,#0x54]         ;2964
000068  2840              CMP      r0,#0x40              ;2964
00006a  d001              BEQ      |L50.112|
00006c  2000              MOVS     r0,#0                 ;2967
00006e  6560              STR      r0,[r4,#0x54]         ;2967
                  |L50.112|
000070  bf00              NOP                            ;2971
000072  2000              MOVS     r0,#0                 ;2971
000074  9000              STR      r0,[sp,#0]            ;2971
000076  6820              LDR      r0,[r4,#0]            ;2971
000078  68c0              LDR      r0,[r0,#0xc]          ;2971
00007a  9000              STR      r0,[sp,#0]            ;2971
00007c  6820              LDR      r0,[r4,#0]            ;2971
00007e  6880              LDR      r0,[r0,#8]            ;2971
000080  9000              STR      r0,[sp,#0]            ;2971
000082  bf00              NOP                            ;2971
000084  bf00              NOP                            ;2971
000086  bf00              NOP                            ;2972
000088  2000              MOVS     r0,#0                 ;2972
00008a  9000              STR      r0,[sp,#0]            ;2972
00008c  6820              LDR      r0,[r4,#0]            ;2972
00008e  6880              LDR      r0,[r0,#8]            ;2972
000090  9000              STR      r0,[sp,#0]            ;2972
000092  bf00              NOP                            ;2972
000094  bf00              NOP                            ;2972
000096  2001              MOVS     r0,#1                 ;2975
000098  f8840051          STRB     r0,[r4,#0x51]         ;2975
00009c  4620              MOV      r0,r4                 ;2981
00009e  f7fffffe          BL       HAL_SPI_AbortCpltCallback
0000a2  bf00              NOP      
0000a4  e7db              B        |L50.94|
;;;2984   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L50.168|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_EndRxTransaction||, CODE, READONLY, ALIGN=1

                  SPI_EndRxTransaction PROC
;;;3438     */
;;;3439   static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3440   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;3441     if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
000008  6860              LDR      r0,[r4,#4]
00000a  f5b07f82          CMP      r0,#0x104
00000e  d10d              BNE      |L51.44|
000010  68a0              LDR      r0,[r4,#8]
000012  f5b04f00          CMP      r0,#0x8000
000016  d003              BEQ      |L51.32|
;;;3442                                                  || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
000018  68a0              LDR      r0,[r4,#8]
00001a  f5b06f80          CMP      r0,#0x400
00001e  d105              BNE      |L51.44|
                  |L51.32|
;;;3443     {
;;;3444       /* Disable SPI peripheral */
;;;3445       __HAL_SPI_DISABLE(hspi);
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200040          BIC      r0,r0,#0x40
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L51.44|
;;;3446     }
;;;3447   
;;;3448     /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
;;;3449     if (hspi->Init.Mode == SPI_MODE_MASTER)
00002c  6860              LDR      r0,[r4,#4]
00002e  f5b07f82          CMP      r0,#0x104
000032  d11f              BNE      |L51.116|
;;;3450     {
;;;3451       if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
000034  68a0              LDR      r0,[r4,#8]
000036  f5b06f80          CMP      r0,#0x400
00003a  d00d              BEQ      |L51.88|
;;;3452       {
;;;3453         /* Control the BSY flag */
;;;3454         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
00003c  4633              MOV      r3,r6
00003e  2200              MOVS     r2,#0
000040  2180              MOVS     r1,#0x80
000042  4620              MOV      r0,r4
000044  9500              STR      r5,[sp,#0]
000046  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00004a  b308              CBZ      r0,|L51.144|
;;;3455         {
;;;3456           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00004c  6d60              LDR      r0,[r4,#0x54]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6560              STR      r0,[r4,#0x54]
;;;3457           return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L51.86|
;;;3458         }
;;;3459       }
;;;3460       else
;;;3461       {
;;;3462         /* Wait the RXNE reset */
;;;3463         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
;;;3464         {
;;;3465           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3466           return HAL_TIMEOUT;
;;;3467         }
;;;3468       }
;;;3469     }
;;;3470     else
;;;3471     {
;;;3472       /* Wait the RXNE reset */
;;;3473       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
;;;3474       {
;;;3475         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3476         return HAL_TIMEOUT;
;;;3477       }
;;;3478     }
;;;3479     return HAL_OK;
;;;3480   }
000056  bdf8              POP      {r3-r7,pc}
                  |L51.88|
000058  4633              MOV      r3,r6                 ;3463
00005a  2200              MOVS     r2,#0                 ;3463
00005c  2101              MOVS     r1,#1                 ;3463
00005e  4620              MOV      r0,r4                 ;3463
000060  9500              STR      r5,[sp,#0]            ;3463
000062  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000066  b198              CBZ      r0,|L51.144|
000068  6d60              LDR      r0,[r4,#0x54]         ;3465
00006a  f0400020          ORR      r0,r0,#0x20           ;3465
00006e  6560              STR      r0,[r4,#0x54]         ;3465
000070  2003              MOVS     r0,#3                 ;3466
000072  e7f0              B        |L51.86|
                  |L51.116|
000074  4633              MOV      r3,r6                 ;3473
000076  2200              MOVS     r2,#0                 ;3473
000078  2101              MOVS     r1,#1                 ;3473
00007a  4620              MOV      r0,r4                 ;3473
00007c  9500              STR      r5,[sp,#0]            ;3473
00007e  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000082  b128              CBZ      r0,|L51.144|
000084  6d60              LDR      r0,[r4,#0x54]         ;3475
000086  f0400020          ORR      r0,r0,#0x20           ;3475
00008a  6560              STR      r0,[r4,#0x54]         ;3475
00008c  2003              MOVS     r0,#3                 ;3476
00008e  e7e2              B        |L51.86|
                  |L51.144|
000090  2000              MOVS     r0,#0                 ;3479
000092  e7e0              B        |L51.86|
;;;3481   
                          ENDP


                          AREA ||i.SPI_EndRxTxTransaction||, CODE, READONLY, ALIGN=2

                  SPI_EndRxTxTransaction PROC
;;;3488     */
;;;3489   static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
000000  b57c              PUSH     {r2-r6,lr}
;;;3490   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3491     /* Timeout in s */
;;;3492     __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
000008  4816              LDR      r0,|L52.100|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  2118              MOVS     r1,#0x18
00000e  fbb0f0f1          UDIV     r0,r0,r1
000012  4915              LDR      r1,|L52.104|
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  f44f717a          MOV      r1,#0x3e8
00001c  4348              MULS     r0,r1,r0
00001e  9001              STR      r0,[sp,#4]
;;;3493     /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
;;;3494     if (hspi->Init.Mode == SPI_MODE_MASTER)
000020  6860              LDR      r0,[r4,#4]
000022  f5b07f82          CMP      r0,#0x104
000026  d10d              BNE      |L52.68|
;;;3495     {
;;;3496       /* Control the BSY flag */
;;;3497       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
000028  462b              MOV      r3,r5
00002a  2200              MOVS     r2,#0
00002c  2180              MOVS     r1,#0x80
00002e  4620              MOV      r0,r4
000030  9600              STR      r6,[sp,#0]
000032  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000036  b198              CBZ      r0,|L52.96|
;;;3498       {
;;;3499         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000038  6d60              LDR      r0,[r4,#0x54]
00003a  f0400020          ORR      r0,r0,#0x20
00003e  6560              STR      r0,[r4,#0x54]
;;;3500         return HAL_TIMEOUT;
000040  2003              MOVS     r0,#3
                  |L52.66|
;;;3501       }
;;;3502     }
;;;3503     else
;;;3504     {
;;;3505       /* Wait BSY flag during 1 Byte time transfer in case of Full-Duplex and Tx transfer
;;;3506       * If Timeout is reached, the transfer is considered as finish.
;;;3507       * User have to calculate the timeout value to fit with the time of 1 byte transfer.
;;;3508       * This time is directly link with the SPI clock from Master device.
;;;3509       */
;;;3510       do
;;;3511       {
;;;3512         if (count == 0U)
;;;3513         {
;;;3514           break;
;;;3515         }
;;;3516         count--;
;;;3517       } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
;;;3518     }
;;;3519   
;;;3520     return HAL_OK;
;;;3521   }
000042  bd7c              POP      {r2-r6,pc}
                  |L52.68|
000044  bf00              NOP                            ;3510
                  |L52.70|
000046  9801              LDR      r0,[sp,#4]            ;3512
000048  b900              CBNZ     r0,|L52.76|
00004a  e008              B        |L52.94|
                  |L52.76|
00004c  9801              LDR      r0,[sp,#4]            ;3516
00004e  1e40              SUBS     r0,r0,#1              ;3516
000050  9001              STR      r0,[sp,#4]            ;3516
000052  6820              LDR      r0,[r4,#0]            ;3517
000054  6880              LDR      r0,[r0,#8]            ;3517
000056  f3c010c0          UBFX     r0,r0,#7,#1           ;3517
00005a  2800              CMP      r0,#0                 ;3517
00005c  d1f3              BNE      |L52.70|
                  |L52.94|
00005e  bf00              NOP                            ;3514
                  |L52.96|
000060  2000              MOVS     r0,#0                 ;3520
000062  e7ee              B        |L52.66|
;;;3522   
                          ENDP

                  |L52.100|
                          DCD      SystemCoreClock
                  |L52.104|
                          DCD      0x000f4240

                          AREA ||i.SPI_RxISR_16BIT||, CODE, READONLY, ALIGN=2

                  SPI_RxISR_16BIT PROC
;;;3300     */
;;;3301   static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3302   {
000002  4604              MOV      r4,r0
;;;3303     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  8008              STRH     r0,[r1,#0]
;;;3304     hspi->pRxBuffPtr += sizeof(uint16_t);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c80              ADDS     r0,r0,#2
000010  63a0              STR      r0,[r4,#0x38]
;;;3305     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3306   
;;;3307   #if (USE_SPI_CRC != 0U)
;;;3308     /* Enable CRC Transmission */
;;;3309     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  2801              CMP      r0,#1
00001c  d109              BNE      |L53.50|
00001e  6aa0              LDR      r0,[r4,#0x28]
000020  f5b05f00          CMP      r0,#0x2000
000024  d105              BNE      |L53.50|
;;;3310     {
;;;3311       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000026  6820              LDR      r0,[r4,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4405080          ORR      r0,r0,#0x1000
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
                  |L53.50|
;;;3312     }
;;;3313   #endif /* USE_SPI_CRC */
;;;3314   
;;;3315     if (hspi->RxXferCount == 0U)
000032  8fe0              LDRH     r0,[r4,#0x3e]
000034  b948              CBNZ     r0,|L53.74|
;;;3316     {
;;;3317   #if (USE_SPI_CRC != 0U)
;;;3318       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000036  6aa0              LDR      r0,[r4,#0x28]
000038  f5b05f00          CMP      r0,#0x2000
00003c  d102              BNE      |L53.68|
;;;3319       {
;;;3320         hspi->RxISR = SPI_RxISR_16BITCRC;
00003e  4804              LDR      r0,|L53.80|
000040  6420              STR      r0,[r4,#0x40]
                  |L53.66|
;;;3321         return;
;;;3322       }
;;;3323   #endif /* USE_SPI_CRC */
;;;3324       SPI_CloseRx_ISR(hspi);
;;;3325     }
;;;3326   }
000042  bd10              POP      {r4,pc}
                  |L53.68|
000044  4620              MOV      r0,r4                 ;3324
000046  f7fffffe          BL       SPI_CloseRx_ISR
                  |L53.74|
00004a  bf00              NOP      
00004c  e7f9              B        |L53.66|
;;;3327   
                          ENDP

00004e  0000              DCW      0x0000
                  |L53.80|
                          DCD      SPI_RxISR_16BITCRC

                          AREA ||i.SPI_RxISR_16BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_16BITCRC PROC
;;;3282     */
;;;3283   static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3284   {
000002  4604              MOV      r4,r0
;;;3285     /* Read 16bit CRC to flush Data Register */
;;;3286     READ_REG(hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
;;;3287   
;;;3288     /* Disable RXNE and ERR interrupt */
;;;3289     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000008  6820              LDR      r0,[r4,#0]
00000a  6840              LDR      r0,[r0,#4]
00000c  f0200060          BIC      r0,r0,#0x60
000010  6821              LDR      r1,[r4,#0]
000012  6048              STR      r0,[r1,#4]
;;;3290   
;;;3291     SPI_CloseRx_ISR(hspi);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_CloseRx_ISR
;;;3292   }
00001a  bd10              POP      {r4,pc}
;;;3293   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_RxISR_8BIT||, CODE, READONLY, ALIGN=2

                  SPI_RxISR_8BIT PROC
;;;3248     */
;;;3249   static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3250   {
000002  4604              MOV      r4,r0
;;;3251     *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  7b00              LDRB     r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  7008              STRB     r0,[r1,#0]
;;;3252     hspi->pRxBuffPtr++;
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c40              ADDS     r0,r0,#1
000010  63a0              STR      r0,[r4,#0x38]
;;;3253     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3254   
;;;3255   #if (USE_SPI_CRC != 0U)
;;;3256     /* Enable CRC Transmission */
;;;3257     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  2801              CMP      r0,#1
00001c  d109              BNE      |L55.50|
00001e  6aa0              LDR      r0,[r4,#0x28]
000020  f5b05f00          CMP      r0,#0x2000
000024  d105              BNE      |L55.50|
;;;3258     {
;;;3259       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000026  6820              LDR      r0,[r4,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f4405080          ORR      r0,r0,#0x1000
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
                  |L55.50|
;;;3260     }
;;;3261   #endif /* USE_SPI_CRC */
;;;3262   
;;;3263     if (hspi->RxXferCount == 0U)
000032  8fe0              LDRH     r0,[r4,#0x3e]
000034  b948              CBNZ     r0,|L55.74|
;;;3264     {
;;;3265   #if (USE_SPI_CRC != 0U)
;;;3266       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000036  6aa0              LDR      r0,[r4,#0x28]
000038  f5b05f00          CMP      r0,#0x2000
00003c  d102              BNE      |L55.68|
;;;3267       {
;;;3268         hspi->RxISR =  SPI_RxISR_8BITCRC;
00003e  4804              LDR      r0,|L55.80|
000040  6420              STR      r0,[r4,#0x40]
                  |L55.66|
;;;3269         return;
;;;3270       }
;;;3271   #endif /* USE_SPI_CRC */
;;;3272       SPI_CloseRx_ISR(hspi);
;;;3273     }
;;;3274   }
000042  bd10              POP      {r4,pc}
                  |L55.68|
000044  4620              MOV      r0,r4                 ;3272
000046  f7fffffe          BL       SPI_CloseRx_ISR
                  |L55.74|
00004a  bf00              NOP      
00004c  e7f9              B        |L55.66|
;;;3275   
                          ENDP

00004e  0000              DCW      0x0000
                  |L55.80|
                          DCD      SPI_RxISR_8BITCRC

                          AREA ||i.SPI_RxISR_8BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_8BITCRC PROC
;;;3233     */
;;;3234   static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3235   {
000002  4604              MOV      r4,r0
;;;3236     /* Read 8bit CRC to flush Data Register */
;;;3237     READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  7b00              LDRB     r0,[r0,#0xc]
;;;3238   
;;;3239     SPI_CloseRx_ISR(hspi);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_CloseRx_ISR
;;;3240   }
00000e  bd10              POP      {r4,pc}
;;;3241   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_16BIT PROC
;;;3358     */
;;;3359   static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3360   {
000002  4604              MOV      r4,r0
;;;3361     /* Transmit data in 16 Bit mode */
;;;3362     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  8800              LDRH     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  60c8              STR      r0,[r1,#0xc]
;;;3363     hspi->pTxBuffPtr += sizeof(uint16_t);
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c80              ADDS     r0,r0,#2
000010  6320              STR      r0,[r4,#0x30]
;;;3364     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3365   
;;;3366     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b960              CBNZ     r0,|L57.54|
;;;3367     {
;;;3368   #if (USE_SPI_CRC != 0U)
;;;3369       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  f5b05f00          CMP      r0,#0x2000
000022  d105              BNE      |L57.48|
;;;3370       {
;;;3371         /* Enable CRC Transmission */
;;;3372         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f4405080          ORR      r0,r0,#0x1000
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
                  |L57.48|
;;;3373       }
;;;3374   #endif /* USE_SPI_CRC */
;;;3375       SPI_CloseTx_ISR(hspi);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       SPI_CloseTx_ISR
                  |L57.54|
;;;3376     }
;;;3377   }
000036  bd10              POP      {r4,pc}
;;;3378   
                          ENDP


                          AREA ||i.SPI_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_8BIT PROC
;;;3333     */
;;;3334   static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3335   {
000002  4604              MOV      r4,r0
;;;3336     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  7800              LDRB     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  7308              STRB     r0,[r1,#0xc]
;;;3337     hspi->pTxBuffPtr++;
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c40              ADDS     r0,r0,#1
000010  6320              STR      r0,[r4,#0x30]
;;;3338     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3339   
;;;3340     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b960              CBNZ     r0,|L58.54|
;;;3341     {
;;;3342   #if (USE_SPI_CRC != 0U)
;;;3343       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  f5b05f00          CMP      r0,#0x2000
000022  d105              BNE      |L58.48|
;;;3344       {
;;;3345         /* Enable CRC Transmission */
;;;3346         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f4405080          ORR      r0,r0,#0x1000
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
                  |L58.48|
;;;3347       }
;;;3348   #endif /* USE_SPI_CRC */
;;;3349       SPI_CloseTx_ISR(hspi);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       SPI_CloseTx_ISR
                  |L58.54|
;;;3350     }
;;;3351   }
000036  bd10              POP      {r4,pc}
;;;3352   
                          ENDP


                          AREA ||i.SPI_WaitFlagStateUntilTimeout||, CODE, READONLY, ALIGN=1

                  SPI_WaitFlagStateUntilTimeout PROC
;;;3388     */
;;;3389   static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3390                                                          uint32_t Timeout, uint32_t Tickstart)
;;;3391   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;3392     while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
000010  e03e              B        |L59.144|
                  |L59.18|
;;;3393     {
;;;3394       if (Timeout != HAL_MAX_DELAY)
000012  1c68              ADDS     r0,r5,#1
000014  b3d8              CBZ      r0,|L59.142|
;;;3395       {
;;;3396         if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42a8              CMP      r0,r5
000020  d200              BCS      |L59.36|
000022  bba5              CBNZ     r5,|L59.142|
                  |L59.36|
;;;3397         {
;;;3398           /* Disable the SPI and reset the CRC: the CRC value should be cleared
;;;3399           on both master and slave sides in order to resynchronize the master
;;;3400           and slave for their respective CRC calculation */
;;;3401   
;;;3402           /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
;;;3403           __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  f02000e0          BIC      r0,r0,#0xe0
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;3404   
;;;3405           if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
000030  6860              LDR      r0,[r4,#4]
000032  f5b07f82          CMP      r0,#0x104
000036  d10d              BNE      |L59.84|
000038  68a0              LDR      r0,[r4,#8]
00003a  f5b04f00          CMP      r0,#0x8000
00003e  d003              BEQ      |L59.72|
;;;3406                                                        || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
000040  68a0              LDR      r0,[r4,#8]
000042  f5b06f80          CMP      r0,#0x400
000046  d105              BNE      |L59.84|
                  |L59.72|
;;;3407           {
;;;3408             /* Disable SPI peripheral */
;;;3409             __HAL_SPI_DISABLE(hspi);
000048  6820              LDR      r0,[r4,#0]
00004a  6800              LDR      r0,[r0,#0]
00004c  f0200040          BIC      r0,r0,#0x40
000050  6821              LDR      r1,[r4,#0]
000052  6008              STR      r0,[r1,#0]
                  |L59.84|
;;;3410           }
;;;3411   
;;;3412           /* Reset CRC Calculation */
;;;3413           if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000054  6aa0              LDR      r0,[r4,#0x28]
000056  f5b05f00          CMP      r0,#0x2000
00005a  d10d              BNE      |L59.120|
;;;3414           {
;;;3415             SPI_RESET_CRC(hspi);
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6800              LDR      r0,[r0,#0]
000062  f4205000          BIC      r0,r0,#0x2000
000066  6821              LDR      r1,[r4,#0]
000068  6008              STR      r0,[r1,#0]
00006a  6820              LDR      r0,[r4,#0]
00006c  6800              LDR      r0,[r0,#0]
00006e  f4405000          ORR      r0,r0,#0x2000
000072  6821              LDR      r1,[r4,#0]
000074  6008              STR      r0,[r1,#0]
000076  bf00              NOP      
                  |L59.120|
;;;3416           }
;;;3417   
;;;3418           hspi->State = HAL_SPI_STATE_READY;
000078  2001              MOVS     r0,#1
00007a  f8840051          STRB     r0,[r4,#0x51]
;;;3419   
;;;3420           /* Process Unlocked */
;;;3421           __HAL_UNLOCK(hspi);
00007e  bf00              NOP      
000080  2000              MOVS     r0,#0
000082  f8840050          STRB     r0,[r4,#0x50]
000086  bf00              NOP      
;;;3422   
;;;3423           return HAL_TIMEOUT;
000088  2003              MOVS     r0,#3
                  |L59.138|
;;;3424         }
;;;3425       }
;;;3426     }
;;;3427   
;;;3428     return HAL_OK;
;;;3429   }
00008a  e8bd81f0          POP      {r4-r8,pc}
                  |L59.142|
00008e  e7ff              B        |L59.144|
                  |L59.144|
000090  6820              LDR      r0,[r4,#0]            ;3392
000092  6880              LDR      r0,[r0,#8]            ;3392
000094  4030              ANDS     r0,r0,r6              ;3392
000096  42b0              CMP      r0,r6                 ;3392
000098  d101              BNE      |L59.158|
00009a  2001              MOVS     r0,#1                 ;3392
00009c  e000              B        |L59.160|
                  |L59.158|
00009e  2000              MOVS     r0,#0                 ;3392
                  |L59.160|
0000a0  42b8              CMP      r0,r7                 ;3392
0000a2  d1b6              BNE      |L59.18|
0000a4  2000              MOVS     r0,#0                 ;3428
0000a6  e7f0              B        |L59.138|
;;;3430   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____RRX|
#line 587
|__asm___19_stm32f4xx_hal_spi_c_5e7b22bd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
