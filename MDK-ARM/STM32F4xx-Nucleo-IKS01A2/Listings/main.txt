; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\main.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\main.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\Src\main.c]
                          THUMB

                          AREA ||i.Accelero_Sensor_Handler||, CODE, READONLY, ALIGN=2

                  Accelero_Sensor_Handler PROC
;;;368     */
;;;369    static void Accelero_Sensor_Handler(TMsg *Msg, uint32_t Instance)
000000  b570              PUSH     {r4-r6,lr}
;;;370    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;371      if ((SensorsEnabled & ACCELEROMETER_SENSOR) == ACCELEROMETER_SENSOR)
000006  4810              LDR      r0,|L1.72|
000008  7800              LDRB     r0,[r0,#0]  ; SensorsEnabled
00000a  f0000010          AND      r0,r0,#0x10
00000e  2810              CMP      r0,#0x10
000010  d119              BNE      |L1.70|
;;;372      {
;;;373        (void)IKS01A2_MOTION_SENSOR_GetAxes(Instance, MOTION_ACCELERO, &AccValue);
000012  4a0e              LDR      r2,|L1.76|
000014  2102              MOVS     r1,#2
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       IKS01A2_MOTION_SENSOR_GetAxes
;;;374        Serialize_s32(&Msg->Data[19], (int32_t)AccValue.x, 4);
00001c  480b              LDR      r0,|L1.76|
00001e  2204              MOVS     r2,#4
000020  6801              LDR      r1,[r0,#0]  ; AccValue
000022  f1040017          ADD      r0,r4,#0x17
000026  f7fffffe          BL       Serialize_s32
;;;375        Serialize_s32(&Msg->Data[23], (int32_t)AccValue.y, 4);
00002a  4808              LDR      r0,|L1.76|
00002c  2204              MOVS     r2,#4
00002e  6841              LDR      r1,[r0,#4]  ; AccValue
000030  f104001b          ADD      r0,r4,#0x1b
000034  f7fffffe          BL       Serialize_s32
;;;376        Serialize_s32(&Msg->Data[27], (int32_t)AccValue.z, 4);
000038  4804              LDR      r0,|L1.76|
00003a  2204              MOVS     r2,#4
00003c  6881              LDR      r1,[r0,#8]  ; AccValue
00003e  f104001f          ADD      r0,r4,#0x1f
000042  f7fffffe          BL       Serialize_s32
                  |L1.70|
;;;377      }
;;;378    }
000046  bd70              POP      {r4-r6,pc}
;;;379    
                          ENDP

                  |L1.72|
                          DCD      SensorsEnabled
                  |L1.76|
                          DCD      AccValue

                          AREA ||i.Error_Handler||, CODE, READONLY, ALIGN=1

                  Error_Handler PROC
;;;638     */
;;;639    void Error_Handler(void)
000000  bf00              NOP      
                  |L2.2|
;;;640    {
;;;641      for (;;)
;;;642      {
;;;643        BSP_LED_On(LED2);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       BSP_LED_On
;;;644        HAL_Delay(100);
000008  2064              MOVS     r0,#0x64
00000a  f7fffffe          BL       HAL_Delay
;;;645        BSP_LED_Off(LED2);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       BSP_LED_Off
;;;646        HAL_Delay(100);
000014  2064              MOVS     r0,#0x64
000016  f7fffffe          BL       HAL_Delay
00001a  e7f2              B        |L2.2|
;;;647      }
;;;648    }
;;;649    
                          ENDP


                          AREA ||i.Gyro_Sensor_Handler||, CODE, READONLY, ALIGN=2

                  Gyro_Sensor_Handler PROC
;;;385     */
;;;386    static void Gyro_Sensor_Handler(TMsg *Msg, uint32_t Instance)
000000  b53e              PUSH     {r1-r5,lr}
;;;387    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;388      IKS01A2_MOTION_SENSOR_Axes_t gyr_value;
;;;389    
;;;390      if ((SensorsEnabled & GYROSCOPE_SENSOR) == GYROSCOPE_SENSOR)
000006  480f              LDR      r0,|L3.68|
000008  7800              LDRB     r0,[r0,#0]  ; SensorsEnabled
00000a  f0000020          AND      r0,r0,#0x20
00000e  2820              CMP      r0,#0x20
000010  d116              BNE      |L3.64|
;;;391      {
;;;392        (void)IKS01A2_MOTION_SENSOR_GetAxes(Instance, MOTION_GYRO, &gyr_value);
000012  466a              MOV      r2,sp
000014  2101              MOVS     r1,#1
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       IKS01A2_MOTION_SENSOR_GetAxes
;;;393        Serialize_s32(&Msg->Data[31], gyr_value.x, 4);
00001c  2204              MOVS     r2,#4
00001e  f1040023          ADD      r0,r4,#0x23
000022  9900              LDR      r1,[sp,#0]
000024  f7fffffe          BL       Serialize_s32
;;;394        Serialize_s32(&Msg->Data[35], gyr_value.y, 4);
000028  2204              MOVS     r2,#4
00002a  f1040027          ADD      r0,r4,#0x27
00002e  9901              LDR      r1,[sp,#4]
000030  f7fffffe          BL       Serialize_s32
;;;395        Serialize_s32(&Msg->Data[39], gyr_value.z, 4);
000034  2204              MOVS     r2,#4
000036  f104002b          ADD      r0,r4,#0x2b
00003a  9902              LDR      r1,[sp,#8]
00003c  f7fffffe          BL       Serialize_s32
                  |L3.64|
;;;396      }
;;;397    }
000040  bd3e              POP      {r1-r5,pc}
;;;398    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      SensorsEnabled

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;654     */
;;;655    void HAL_GPIO_EXTI_Callback(uint16_t GpioPin)
000000  4770              BX       lr
;;;656    {
;;;657    }
;;;658    
                          ENDP


                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PeriodElapsedCallback PROC
;;;664     */
;;;665    void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4a06              LDR      r2,|L5.28|
;;;666    {
;;;667      if (htim->Instance == TIM_ALGO)
000002  6801              LDR      r1,[r0,#0]
000004  4291              CMP      r1,r2
000006  d107              BNE      |L5.24|
;;;668      {
;;;669        SensorReadRequest = 1;
000008  2101              MOVS     r1,#1
00000a  4a05              LDR      r2,|L5.32|
00000c  7011              STRB     r1,[r2,#0]
;;;670        TimeStamp += ALGO_PERIOD;
00000e  4905              LDR      r1,|L5.36|
000010  6809              LDR      r1,[r1,#0]  ; TimeStamp
000012  3114              ADDS     r1,r1,#0x14
000014  4a03              LDR      r2,|L5.36|
000016  6011              STR      r1,[r2,#0]  ; TimeStamp
                  |L5.24|
;;;671      }
;;;672    }
000018  4770              BX       lr
;;;673    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40000400
                  |L5.32|
                          DCD      SensorReadRequest
                  |L5.36|
                          DCD      TimeStamp

                          AREA ||i.Humidity_Sensor_Handler||, CODE, READONLY, ALIGN=2

                  Humidity_Sensor_Handler PROC
;;;476     */
;;;477    static void Humidity_Sensor_Handler(TMsg *Msg, uint32_t Instance)
000000  b538              PUSH     {r3-r5,lr}
;;;478    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;479      float hum_value;
;;;480    
;;;481      if ((SensorsEnabled & HUMIDITY_SENSOR) == HUMIDITY_SENSOR)
000006  4807              LDR      r0,|L6.36|
000008  7800              LDRB     r0,[r0,#0]  ; SensorsEnabled
00000a  f0000004          AND      r0,r0,#4
00000e  2804              CMP      r0,#4
000010  d107              BNE      |L6.34|
;;;482      {
;;;483        (void)IKS01A2_ENV_SENSOR_GetValue(Instance, ENV_HUMIDITY, &hum_value);
000012  466a              MOV      r2,sp
000014  2104              MOVS     r1,#4
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IKS01A2_ENV_SENSOR_GetValue
;;;484        (void)memcpy(&Msg->Data[15], (void *)&hum_value, sizeof(float));;
00001c  9900              LDR      r1,[sp,#0]
00001e  f8c51013          STR      r1,[r5,#0x13]
                  |L6.34|
;;;485      }
;;;486    }
000022  bd38              POP      {r3-r5,pc}
;;;487    
                          ENDP

                  |L6.36|
                          DCD      SensorsEnabled

                          AREA ||i.Init_Sensors||, CODE, READONLY, ALIGN=2

                  Init_Sensors PROC
;;;238     */
;;;239    static void Init_Sensors(void)
000000  b510              PUSH     {r4,lr}
;;;240    {
;;;241      (void)IKS01A2_MOTION_SENSOR_Init(IKS01A2_LSM303AGR_ACC_0, MOTION_ACCELERO);
000002  2102              MOVS     r1,#2
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       IKS01A2_MOTION_SENSOR_Init
;;;242      (void)IKS01A2_MOTION_SENSOR_Init(IKS01A2_LSM6DSL_0, MOTION_GYRO);
00000a  2101              MOVS     r1,#1
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       IKS01A2_MOTION_SENSOR_Init
;;;243      (void)IKS01A2_MOTION_SENSOR_Init(IKS01A2_LSM303AGR_MAG_0, MOTION_MAGNETO);
000012  2104              MOVS     r1,#4
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       IKS01A2_MOTION_SENSOR_Init
;;;244      (void)IKS01A2_ENV_SENSOR_Init(IKS01A2_HTS221_0, ENV_TEMPERATURE | ENV_HUMIDITY);
00001a  2105              MOVS     r1,#5
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       IKS01A2_ENV_SENSOR_Init
;;;245      (void)IKS01A2_ENV_SENSOR_Init(IKS01A2_LPS22HB_0, ENV_PRESSURE);
000022  2102              MOVS     r1,#2
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       IKS01A2_ENV_SENSOR_Init
;;;246    
;;;247      /* Set accelerometer:
;;;248       *   - ODR >= 100Hz
;;;249       *   - FS   = <-2g, 2g>
;;;250       */
;;;251      (void)IKS01A2_MOTION_SENSOR_SetOutputDataRate(IKS01A2_LSM303AGR_ACC_0, MOTION_ACCELERO, 100.0f);
00002a  ed9f0a09          VLDR     s0,|L7.80|
00002e  2102              MOVS     r1,#2
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       IKS01A2_MOTION_SENSOR_SetOutputDataRate
;;;252      (void)IKS01A2_MOTION_SENSOR_SetFullScale(IKS01A2_LSM303AGR_ACC_0, MOTION_ACCELERO, 2);
000036  2202              MOVS     r2,#2
000038  4611              MOV      r1,r2
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       IKS01A2_MOTION_SENSOR_SetFullScale
;;;253    
;;;254      /* Set magnetometer:
;;;255       *   - ODR >= 100Hz
;;;256       *   - FS   = 50Gauss (always)
;;;257       */
;;;258      (void)IKS01A2_MOTION_SENSOR_SetOutputDataRate(IKS01A2_LSM303AGR_MAG_0, MOTION_MAGNETO, 100.0f);
000040  ed9f0a03          VLDR     s0,|L7.80|
000044  2104              MOVS     r1,#4
000046  2002              MOVS     r0,#2
000048  f7fffffe          BL       IKS01A2_MOTION_SENSOR_SetOutputDataRate
;;;259    }
00004c  bd10              POP      {r4,pc}
;;;260    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
000050  42c80000          DCFS     0x42c80000 ; 100

                          AREA ||i.MX_CRC_Init||, CODE, READONLY, ALIGN=2

                  MX_CRC_Init PROC
;;;280     */
;;;281    static void MX_CRC_Init(void)
000000  b508              PUSH     {r3,lr}
;;;282    {
;;;283      __CRC_CLK_ENABLE();
000002  bf00              NOP      
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4806              LDR      r0,|L8.36|
00000a  6800              LDR      r0,[r0,#0]
00000c  f4405080          ORR      r0,r0,#0x1000
000010  4904              LDR      r1,|L8.36|
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  f4005080          AND      r0,r0,#0x1000
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  bf00              NOP      
;;;284    }
000022  bd08              POP      {r3,pc}
;;;285    
                          ENDP

                  |L8.36|
                          DCD      0x40023830

                          AREA ||i.MX_GPIO_Init||, CODE, READONLY, ALIGN=1

                  MX_GPIO_Init PROC
;;;266     */
;;;267    static void MX_GPIO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;268    {
;;;269      /* Initialize LED */
;;;270      BSP_LED_Init(LED2);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       BSP_LED_Init
;;;271    
;;;272      /* Initialize push button */
;;;273      BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
000008  2101              MOVS     r1,#1
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       BSP_PB_Init
;;;274    }
000010  bd10              POP      {r4,pc}
;;;275    
                          ENDP


                          AREA ||i.MX_TIM_ALGO_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM_ALGO_Init PROC
;;;291     */
;;;292    static void MX_TIM_ALGO_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;293    {
000002  b087              SUB      sp,sp,#0x1c
;;;294    #if (defined (USE_STM32F4XX_NUCLEO))
;;;295    #define CPU_CLOCK  84000000U
;;;296    
;;;297    #elif (defined (USE_STM32L0XX_NUCLEO))
;;;298    #define CPU_CLOCK  32000000U
;;;299    
;;;300    #elif (defined (USE_STM32L1XX_NUCLEO))
;;;301    #define CPU_CLOCK  32000000U
;;;302    
;;;303    #elif (defined (USE_STM32L4XX_NUCLEO))
;;;304    #define CPU_CLOCK  80000000U
;;;305    
;;;306    #else
;;;307    #error Not supported platform
;;;308    #endif
;;;309    
;;;310    #define TIM_CLOCK  2000U
;;;311    
;;;312      const uint32_t prescaler = CPU_CLOCK / TIM_CLOCK - 1U;
000004  f24a440f          MOV      r4,#0xa40f
;;;313      const uint32_t tim_period = TIM_CLOCK / ALGO_FREQ - 1U;
000008  2527              MOVS     r5,#0x27
;;;314    
;;;315      TIM_ClockConfigTypeDef s_clock_source_config;
;;;316      TIM_MasterConfigTypeDef s_master_config;
;;;317    
;;;318      AlgoTimHandle.Instance           = TIM_ALGO;
00000a  480f              LDR      r0,|L10.72|
00000c  490f              LDR      r1,|L10.76|
00000e  6008              STR      r0,[r1,#0]  ; AlgoTimHandle
;;;319      AlgoTimHandle.Init.Prescaler     = prescaler;
000010  4620              MOV      r0,r4
000012  6048              STR      r0,[r1,#4]  ; AlgoTimHandle
;;;320      AlgoTimHandle.Init.CounterMode   = TIM_COUNTERMODE_UP;
000014  2100              MOVS     r1,#0
000016  480d              LDR      r0,|L10.76|
000018  6081              STR      r1,[r0,#8]
;;;321      AlgoTimHandle.Init.Period        = tim_period;
00001a  2127              MOVS     r1,#0x27
00001c  60c1              STR      r1,[r0,#0xc]
;;;322      AlgoTimHandle.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
00001e  2100              MOVS     r1,#0
000020  6101              STR      r1,[r0,#0x10]
;;;323      (void)HAL_TIM_Base_Init(&AlgoTimHandle);
000022  f7fffffe          BL       HAL_TIM_Base_Init
;;;324    
;;;325      s_clock_source_config.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
000026  f44f5080          MOV      r0,#0x1000
00002a  9003              STR      r0,[sp,#0xc]
;;;326      (void)HAL_TIM_ConfigClockSource(&AlgoTimHandle, &s_clock_source_config);
00002c  a903              ADD      r1,sp,#0xc
00002e  4807              LDR      r0,|L10.76|
000030  f7fffffe          BL       HAL_TIM_ConfigClockSource
;;;327    
;;;328      s_master_config.MasterOutputTrigger = TIM_TRGO_RESET;
000034  2000              MOVS     r0,#0
000036  9001              STR      r0,[sp,#4]
;;;329      s_master_config.MasterSlaveMode     = TIM_MASTERSLAVEMODE_DISABLE;
000038  9002              STR      r0,[sp,#8]
;;;330      (void)HAL_TIMEx_MasterConfigSynchronization(&AlgoTimHandle, &s_master_config);
00003a  a901              ADD      r1,sp,#4
00003c  4803              LDR      r0,|L10.76|
00003e  f7fffffe          BL       HAL_TIMEx_MasterConfigSynchronization
;;;331    }
000042  b007              ADD      sp,sp,#0x1c
000044  bd30              POP      {r4,r5,pc}
;;;332    
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      0x40000400
                  |L10.76|
                          DCD      AlgoTimHandle

                          AREA ||i.Magneto_Sensor_Handler||, CODE, READONLY, ALIGN=2

                  Magneto_Sensor_Handler PROC
;;;404     */
;;;405    static void Magneto_Sensor_Handler(TMsg *Msg, uint32_t Instance)
000000  b57f              PUSH     {r0-r6,lr}
;;;406    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;407    	uint8_t data[2] = {0};
000006  2000              MOVS     r0,#0
000008  9003              STR      r0,[sp,#0xc]
;;;408      //if ((SensorsEnabled & MAGNETIC_SENSOR) == MAGNETIC_SENSOR)
;;;409      //{
;;;410        //(void)IKS01A2_MOTION_SENSOR_GetAxes(Instance, MOTION_MAGNETO, &MagValue);
;;;411    		
;;;412         status = HAL_I2C_Mem_Read(&hi2c3, ADDR, 0x28, I2C_MEMADD_SIZE_8BIT , data, 0x02, 100); 
00000a  2064              MOVS     r0,#0x64
00000c  2102              MOVS     r1,#2
00000e  aa03              ADD      r2,sp,#0xc
000010  2301              MOVS     r3,#1
000012  e9cd2100          STRD     r2,r1,[sp,#0]
000016  9002              STR      r0,[sp,#8]
000018  2228              MOVS     r2,#0x28
00001a  213d              MOVS     r1,#0x3d
00001c  4829              LDR      r0,|L11.196|
00001e  f7fffffe          BL       HAL_I2C_Mem_Read
000022  4929              LDR      r1,|L11.200|
000024  7008              STRB     r0,[r1,#0]
;;;413    	
;;;414    	int16_t a;
;;;415    	//a= data[0];
;;;416    	//a= a |(data[1] << 8);
;;;417    	a=(data[1] << 8)|data[0];
000026  f89d000c          LDRB     r0,[sp,#0xc]
00002a  f89d100d          LDRB     r1,[sp,#0xd]
00002e  ea402001          ORR      r0,r0,r1,LSL #8
000032  b204              SXTH     r4,r0
;;;418    		MagValue.x = a;//(int16_t)data[1] << 8 | data[0];							
000034  4825              LDR      r0,|L11.204|
000036  6004              STR      r4,[r0,#0]  ; MagValue
;;;419    		HAL_Delay(10);
000038  200a              MOVS     r0,#0xa
00003a  f7fffffe          BL       HAL_Delay
;;;420    		data[0] = 0; data[1] = 0;
00003e  2000              MOVS     r0,#0
000040  f88d000c          STRB     r0,[sp,#0xc]
000044  f88d000d          STRB     r0,[sp,#0xd]
;;;421    	
;;;422    	
;;;423    		 status = HAL_I2C_Mem_Read(&hi2c3, ADDR, 0x2A, I2C_MEMADD_SIZE_8BIT , data, 0x02, 100);
000048  2064              MOVS     r0,#0x64
00004a  2102              MOVS     r1,#2
00004c  aa03              ADD      r2,sp,#0xc
00004e  2301              MOVS     r3,#1
000050  e9cd2100          STRD     r2,r1,[sp,#0]
000054  9002              STR      r0,[sp,#8]
000056  222a              MOVS     r2,#0x2a
000058  213d              MOVS     r1,#0x3d
00005a  481a              LDR      r0,|L11.196|
00005c  f7fffffe          BL       HAL_I2C_Mem_Read
000060  4919              LDR      r1,|L11.200|
000062  7008              STRB     r0,[r1,#0]
;;;424    a=(data[1] << 8)|data[0];	
000064  f89d000c          LDRB     r0,[sp,#0xc]
000068  f89d100d          LDRB     r1,[sp,#0xd]
00006c  ea402001          ORR      r0,r0,r1,LSL #8
000070  b204              SXTH     r4,r0
;;;425    		MagValue.y = a;//(int16_t)data[1] << 8 | data[0];	
000072  4816              LDR      r0,|L11.204|
000074  6044              STR      r4,[r0,#4]  ; MagValue
;;;426    		data[0] = 0; data[1] = 0;
000076  2000              MOVS     r0,#0
000078  f88d000c          STRB     r0,[sp,#0xc]
00007c  f88d000d          STRB     r0,[sp,#0xd]
;;;427    		HAL_Delay(10);
000080  200a              MOVS     r0,#0xa
000082  f7fffffe          BL       HAL_Delay
;;;428    		status = HAL_I2C_Mem_Read(&hi2c3, ADDR, 0x2C, I2C_MEMADD_SIZE_8BIT , data, 0x02, 100); 
000086  2064              MOVS     r0,#0x64
000088  2102              MOVS     r1,#2
00008a  aa03              ADD      r2,sp,#0xc
00008c  2301              MOVS     r3,#1
00008e  e9cd2100          STRD     r2,r1,[sp,#0]
000092  9002              STR      r0,[sp,#8]
000094  222c              MOVS     r2,#0x2c
000096  213d              MOVS     r1,#0x3d
000098  480a              LDR      r0,|L11.196|
00009a  f7fffffe          BL       HAL_I2C_Mem_Read
00009e  490a              LDR      r1,|L11.200|
0000a0  7008              STRB     r0,[r1,#0]
;;;429    		a=(data[1] << 8)|data[0];
0000a2  f89d000c          LDRB     r0,[sp,#0xc]
0000a6  f89d100d          LDRB     r1,[sp,#0xd]
0000aa  ea402001          ORR      r0,r0,r1,LSL #8
0000ae  b204              SXTH     r4,r0
;;;430    		MagValue.z = a;//(int16_t)data[1] << 8 | data[0];	
0000b0  4806              LDR      r0,|L11.204|
0000b2  6084              STR      r4,[r0,#8]  ; MagValue
;;;431    		HAL_Delay(10);
0000b4  200a              MOVS     r0,#0xa
0000b6  f7fffffe          BL       HAL_Delay
;;;432        /* Magnetometer calibration */
;;;433        MotionMC_manager_run(Msg);
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       MotionMC_manager_run
;;;434     //}
;;;435    }
0000c0  bd7f              POP      {r0-r6,pc}
;;;436    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L11.196|
                          DCD      hi2c3
                  |L11.200|
                          DCD      status
                  |L11.204|
                          DCD      MagValue

                          AREA ||i.Pressure_Sensor_Handler||, CODE, READONLY, ALIGN=2

                  Pressure_Sensor_Handler PROC
;;;442     */
;;;443    static void Pressure_Sensor_Handler(TMsg *Msg, uint32_t Instance)
000000  b538              PUSH     {r3-r5,lr}
;;;444    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;445      float pres_value;
;;;446    
;;;447      if ((SensorsEnabled & PRESSURE_SENSOR) == PRESSURE_SENSOR)
000006  4807              LDR      r0,|L12.36|
000008  7800              LDRB     r0,[r0,#0]  ; SensorsEnabled
00000a  f0000001          AND      r0,r0,#1
00000e  b138              CBZ      r0,|L12.32|
;;;448      {
;;;449        (void)IKS01A2_ENV_SENSOR_GetValue(Instance, ENV_PRESSURE, &pres_value);
000010  466a              MOV      r2,sp
000012  2102              MOVS     r1,#2
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       IKS01A2_ENV_SENSOR_GetValue
;;;450        (void)memcpy(&Msg->Data[7], (void *)&pres_value, sizeof(float));
00001a  9900              LDR      r1,[sp,#0]
00001c  f8c5100b          STR      r1,[r5,#0xb]
                  |L12.32|
;;;451      }
;;;452    }
000020  bd38              POP      {r3-r5,pc}
;;;453    
                          ENDP

000022  0000              DCW      0x0000
                  |L12.36|
                          DCD      SensorsEnabled

                          AREA ||i.RTC_Config||, CODE, READONLY, ALIGN=2

                  RTC_Config PROC
;;;492     */
;;;493    static void RTC_Config(void)
000000  b500              PUSH     {lr}
;;;494    {
000002  b08d              SUB      sp,sp,#0x34
;;;495      /*##-1- Configure the RTC peripheral #######################################*/
;;;496      /* Check if LSE can be used */
;;;497      RCC_OscInitTypeDef rcc_osc_init_struct;
;;;498    
;;;499      /*##-2- Configure LSE as RTC clock soucre ###################################*/
;;;500      rcc_osc_init_struct.OscillatorType = RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
000004  200c              MOVS     r0,#0xc
000006  9001              STR      r0,[sp,#4]
;;;501      rcc_osc_init_struct.PLL.PLLState   = RCC_PLL_NONE;
000008  2000              MOVS     r0,#0
00000a  9007              STR      r0,[sp,#0x1c]
;;;502      rcc_osc_init_struct.LSEState       = RCC_LSE_ON;
00000c  2001              MOVS     r0,#1
00000e  9003              STR      r0,[sp,#0xc]
;;;503      rcc_osc_init_struct.LSIState       = RCC_LSI_OFF;
000010  2000              MOVS     r0,#0
000012  9006              STR      r0,[sp,#0x18]
;;;504    
;;;505      if (HAL_RCC_OscConfig(&rcc_osc_init_struct) != HAL_OK)
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       HAL_RCC_OscConfig
00001a  b158              CBZ      r0,|L13.52|
;;;506      {
;;;507        /* LSE not available, we use LSI */
;;;508        UseLSI = 1;
00001c  2001              MOVS     r0,#1
00001e  4913              LDR      r1,|L13.108|
000020  6008              STR      r0,[r1,#0]  ; UseLSI
;;;509        RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSI;
000022  217f              MOVS     r1,#0x7f
000024  4812              LDR      r0,|L13.112|
000026  6081              STR      r1,[r0,#8]
;;;510        RtcHandle.Init.SynchPrediv  = RTC_SYNCH_PREDIV_LSI;
000028  21f9              MOVS     r1,#0xf9
00002a  60c1              STR      r1,[r0,#0xc]
;;;511        RtcSynchPrediv = RTC_SYNCH_PREDIV_LSI;
00002c  20f9              MOVS     r0,#0xf9
00002e  4911              LDR      r1,|L13.116|
000030  6008              STR      r0,[r1,#0]  ; RtcSynchPrediv
000032  e00a              B        |L13.74|
                  |L13.52|
;;;512      }
;;;513      else
;;;514      {
;;;515        /* We use LSE */
;;;516        UseLSI = 0;
000034  2000              MOVS     r0,#0
000036  490d              LDR      r1,|L13.108|
000038  6008              STR      r0,[r1,#0]  ; UseLSI
;;;517        RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSE;
00003a  217f              MOVS     r1,#0x7f
00003c  480c              LDR      r0,|L13.112|
00003e  6081              STR      r1,[r0,#8]
;;;518        RtcHandle.Init.SynchPrediv  = RTC_SYNCH_PREDIV_LSE;
000040  21ff              MOVS     r1,#0xff
000042  60c1              STR      r1,[r0,#0xc]
;;;519        RtcSynchPrediv = RTC_SYNCH_PREDIV_LSE;
000044  20ff              MOVS     r0,#0xff
000046  490b              LDR      r1,|L13.116|
000048  6008              STR      r0,[r1,#0]  ; RtcSynchPrediv
                  |L13.74|
;;;520      }
;;;521    
;;;522      RtcHandle.Instance = RTC;
00004a  480b              LDR      r0,|L13.120|
00004c  4908              LDR      r1,|L13.112|
00004e  6008              STR      r0,[r1,#0]  ; RtcHandle
;;;523    
;;;524      /* Configure RTC prescaler and RTC data registers */
;;;525      /* RTC configured as follow:
;;;526           - Hour Format    = Format 12
;;;527           - Asynch Prediv  = Value according to source clock
;;;528           - Synch Prediv   = Value according to source clock
;;;529           - OutPut         = Output Disable
;;;530           - OutPutPolarity = High Polarity
;;;531           - OutPutType     = Open Drain
;;;532       */
;;;533      RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_12;
000050  2040              MOVS     r0,#0x40
000052  6048              STR      r0,[r1,#4]  ; RtcHandle
;;;534      RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
000054  2100              MOVS     r1,#0
000056  4806              LDR      r0,|L13.112|
000058  6101              STR      r1,[r0,#0x10]
;;;535      RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
00005a  6141              STR      r1,[r0,#0x14]
;;;536      RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
00005c  6181              STR      r1,[r0,#0x18]
;;;537    
;;;538      if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
00005e  f7fffffe          BL       HAL_RTC_Init
000062  b108              CBZ      r0,|L13.104|
;;;539      {
;;;540        /* Initialization Error */
;;;541        Error_Handler();
000064  f7fffffe          BL       Error_Handler
                  |L13.104|
;;;542      }
;;;543    }
000068  b00d              ADD      sp,sp,#0x34
00006a  bd00              POP      {pc}
;;;544    
                          ENDP

                  |L13.108|
                          DCD      UseLSI
                  |L13.112|
                          DCD      RtcHandle
                  |L13.116|
                          DCD      RtcSynchPrediv
                  |L13.120|
                          DCD      0x40002800

                          AREA ||i.RTC_DateRegulate||, CODE, READONLY, ALIGN=2

                  RTC_DateRegulate PROC
;;;591     */
;;;592    void RTC_DateRegulate(uint8_t y, uint8_t m, uint8_t d, uint8_t dw)
000000  b5f8              PUSH     {r3-r7,lr}
;;;593    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4617              MOV      r7,r2
000008  461e              MOV      r6,r3
;;;594      RTC_DateTypeDef sdatestructure;
;;;595    
;;;596      sdatestructure.Year    = y;
00000a  f88d4003          STRB     r4,[sp,#3]
;;;597      sdatestructure.Month   = m;
00000e  f88d5001          STRB     r5,[sp,#1]
;;;598      sdatestructure.Date    = d;
000012  f88d7002          STRB     r7,[sp,#2]
;;;599      sdatestructure.WeekDay = dw;
000016  f88d6000          STRB     r6,[sp,#0]
;;;600    
;;;601      if (HAL_RTC_SetDate(&RtcHandle, &sdatestructure, FORMAT_BIN) != HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  4669              MOV      r1,sp
00001e  4803              LDR      r0,|L14.44|
000020  f7fffffe          BL       HAL_RTC_SetDate
000024  b108              CBZ      r0,|L14.42|
;;;602      {
;;;603        /* Initialization Error */
;;;604        Error_Handler();
000026  f7fffffe          BL       Error_Handler
                  |L14.42|
;;;605      }
;;;606    }
00002a  bdf8              POP      {r3-r7,pc}
;;;607    
                          ENDP

                  |L14.44|
                          DCD      RtcHandle

                          AREA ||i.RTC_Handler||, CODE, READONLY, ALIGN=2

                  RTC_Handler PROC
;;;337     */
;;;338    static void RTC_Handler(TMsg *Msg)
000000  b5f0              PUSH     {r4-r7,lr}
;;;339    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;340      uint8_t sub_sec;
;;;341      uint32_t ans_uint32;
;;;342      int32_t ans_int32;
;;;343      RTC_DateTypeDef sdatestructureget;
;;;344      RTC_TimeTypeDef stimestructure;
;;;345    
;;;346      (void)HAL_RTC_GetTime(&RtcHandle, &stimestructure, FORMAT_BIN);
000006  2200              MOVS     r2,#0
000008  a901              ADD      r1,sp,#4
00000a  4811              LDR      r0,|L15.80|
00000c  f7fffffe          BL       HAL_RTC_GetTime
;;;347      (void)HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, FORMAT_BIN);
000010  2200              MOVS     r2,#0
000012  a906              ADD      r1,sp,#0x18
000014  480e              LDR      r0,|L15.80|
000016  f7fffffe          BL       HAL_RTC_GetDate
;;;348    
;;;349      /* To be MISRA C-2012 compliant the original calculation:
;;;350         sub_sec = ((((((int)RtcSynchPrediv) - ((int)stimestructure.SubSeconds)) * 100) / (RtcSynchPrediv + 1)) & 0xFF);
;;;351         has been split to separate expressions */
;;;352      ans_int32 = (RtcSynchPrediv - (int32_t)stimestructure.SubSeconds) * 100;
00001a  490e              LDR      r1,|L15.84|
00001c  9802              LDR      r0,[sp,#8]
00001e  6809              LDR      r1,[r1,#0]  ; RtcSynchPrediv
000020  1a08              SUBS     r0,r1,r0
000022  2164              MOVS     r1,#0x64
000024  fb00f501          MUL      r5,r0,r1
;;;353      ans_int32 /= RtcSynchPrediv + 1;
000028  480a              LDR      r0,|L15.84|
00002a  6800              LDR      r0,[r0,#0]  ; RtcSynchPrediv
00002c  1c40              ADDS     r0,r0,#1
00002e  fb95f5f0          SDIV     r5,r5,r0
;;;354      ans_uint32 = (uint32_t)ans_int32 & 0xFFU;
000032  b2ef              UXTB     r7,r5
;;;355      sub_sec = (uint8_t)ans_uint32;
000034  463e              MOV      r6,r7
;;;356    
;;;357      Msg->Data[3] = (uint8_t)stimestructure.Hours;
000036  f89d1004          LDRB     r1,[sp,#4]
00003a  71e1              STRB     r1,[r4,#7]
;;;358      Msg->Data[4] = (uint8_t)stimestructure.Minutes;
00003c  f89d1005          LDRB     r1,[sp,#5]
000040  7221              STRB     r1,[r4,#8]
;;;359      Msg->Data[5] = (uint8_t)stimestructure.Seconds;
000042  f89d1006          LDRB     r1,[sp,#6]
000046  7261              STRB     r1,[r4,#9]
;;;360      Msg->Data[6] = sub_sec;
000048  72a6              STRB     r6,[r4,#0xa]
;;;361    }
00004a  b007              ADD      sp,sp,#0x1c
00004c  bdf0              POP      {r4-r7,pc}
;;;362    
                          ENDP

00004e  0000              DCW      0x0000
                  |L15.80|
                          DCD      RtcHandle
                  |L15.84|
                          DCD      RtcSynchPrediv

                          AREA ||i.RTC_TimeRegulate||, CODE, READONLY, ALIGN=2

                  RTC_TimeRegulate PROC
;;;614     */
;;;615    void RTC_TimeRegulate(uint8_t hh, uint8_t mm, uint8_t ss)
000000  b570              PUSH     {r4-r6,lr}
;;;616    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;617      RTC_TimeTypeDef stimestructure;
;;;618    
;;;619      stimestructure.TimeFormat     = RTC_HOURFORMAT12_AM;
00000a  2000              MOVS     r0,#0
00000c  f88d0007          STRB     r0,[sp,#7]
;;;620      stimestructure.Hours          = hh;
000010  f88d4004          STRB     r4,[sp,#4]
;;;621      stimestructure.Minutes        = mm;
000014  f88d5005          STRB     r5,[sp,#5]
;;;622      stimestructure.Seconds        = ss;
000018  f88d6006          STRB     r6,[sp,#6]
;;;623      stimestructure.SubSeconds     = 0;
00001c  9002              STR      r0,[sp,#8]
;;;624      stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
00001e  9004              STR      r0,[sp,#0x10]
;;;625      stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
000020  9005              STR      r0,[sp,#0x14]
;;;626    
;;;627      if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BIN) != HAL_OK)
000022  2200              MOVS     r2,#0
000024  a901              ADD      r1,sp,#4
000026  4804              LDR      r0,|L16.56|
000028  f7fffffe          BL       HAL_RTC_SetTime
00002c  b108              CBZ      r0,|L16.50|
;;;628      {
;;;629        /* Initialization Error */
;;;630        Error_Handler();
00002e  f7fffffe          BL       Error_Handler
                  |L16.50|
;;;631      }
;;;632    }
000032  b006              ADD      sp,sp,#0x18
000034  bd70              POP      {r4-r6,pc}
;;;633    
                          ENDP

000036  0000              DCW      0x0000
                  |L16.56|
                          DCD      RtcHandle

                          AREA ||i.RTC_TimeStampConfig||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampConfig PROC
;;;549     */
;;;550    static void RTC_TimeStampConfig(void)
000000  b500              PUSH     {lr}
;;;551    {
000002  b087              SUB      sp,sp,#0x1c
;;;552      RTC_DateTypeDef sdatestructure;
;;;553      RTC_TimeTypeDef stimestructure;
;;;554    
;;;555      /* Configure the Date */
;;;556      /* Set Date: Monday January 1st 2001 */
;;;557      sdatestructure.Year    = 0x01;
000004  2001              MOVS     r0,#1
000006  f88d001b          STRB     r0,[sp,#0x1b]
;;;558      sdatestructure.Month   = RTC_MONTH_JANUARY;
00000a  f88d0019          STRB     r0,[sp,#0x19]
;;;559      sdatestructure.Date    = 0x01;
00000e  f88d001a          STRB     r0,[sp,#0x1a]
;;;560      sdatestructure.WeekDay = RTC_WEEKDAY_MONDAY;
000012  f88d0018          STRB     r0,[sp,#0x18]
;;;561    
;;;562      if (HAL_RTC_SetDate(&RtcHandle, &sdatestructure, FORMAT_BCD) != HAL_OK)
000016  2201              MOVS     r2,#1
000018  a906              ADD      r1,sp,#0x18
00001a  480d              LDR      r0,|L17.80|
00001c  f7fffffe          BL       HAL_RTC_SetDate
000020  b108              CBZ      r0,|L17.38|
;;;563      {
;;;564        /* Initialization Error */
;;;565        Error_Handler();
000022  f7fffffe          BL       Error_Handler
                  |L17.38|
;;;566      }
;;;567    
;;;568      /* Configure the Time */
;;;569      /* Set Time: 00:00:00 */
;;;570      stimestructure.Hours          = 0x00;
000026  2000              MOVS     r0,#0
000028  f88d0004          STRB     r0,[sp,#4]
;;;571      stimestructure.Minutes        = 0x00;
00002c  f88d0005          STRB     r0,[sp,#5]
;;;572      stimestructure.Seconds        = 0x00;
000030  f88d0006          STRB     r0,[sp,#6]
;;;573      stimestructure.TimeFormat     = RTC_HOURFORMAT12_AM;
000034  f88d0007          STRB     r0,[sp,#7]
;;;574      stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
000038  9004              STR      r0,[sp,#0x10]
;;;575      stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
00003a  9005              STR      r0,[sp,#0x14]
;;;576    
;;;577      if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BCD) != HAL_OK)
00003c  2201              MOVS     r2,#1
00003e  a901              ADD      r1,sp,#4
000040  4803              LDR      r0,|L17.80|
000042  f7fffffe          BL       HAL_RTC_SetTime
000046  b108              CBZ      r0,|L17.76|
;;;578      {
;;;579        /* Initialization Error */
;;;580        Error_Handler();
000048  f7fffffe          BL       Error_Handler
                  |L17.76|
;;;581      }
;;;582    }
00004c  b007              ADD      sp,sp,#0x1c
00004e  bd00              POP      {pc}
;;;583    
                          ENDP

                  |L17.80|
                          DCD      RtcHandle

                          AREA ||i.Temperature_Sensor_Handler||, CODE, READONLY, ALIGN=2

                  Temperature_Sensor_Handler PROC
;;;459     */
;;;460    static void Temperature_Sensor_Handler(TMsg *Msg, uint32_t Instance)
000000  b538              PUSH     {r3-r5,lr}
;;;461    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;462      float temp_value;
;;;463    
;;;464      if ((SensorsEnabled & TEMPERATURE_SENSOR) == TEMPERATURE_SENSOR)
000006  4807              LDR      r0,|L18.36|
000008  7800              LDRB     r0,[r0,#0]  ; SensorsEnabled
00000a  f0000002          AND      r0,r0,#2
00000e  2802              CMP      r0,#2
000010  d107              BNE      |L18.34|
;;;465      {
;;;466        (void)IKS01A2_ENV_SENSOR_GetValue(Instance, ENV_TEMPERATURE, &temp_value);
000012  466a              MOV      r2,sp
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IKS01A2_ENV_SENSOR_GetValue
;;;467        (void)memcpy(&Msg->Data[11], (void *)&temp_value, sizeof(float));
00001c  9900              LDR      r1,[sp,#0]
00001e  f8c5100f          STR      r1,[r5,#0xf]
                  |L18.34|
;;;468      }
;;;469    }
000022  bd38              POP      {r3-r5,pc}
;;;470    
                          ENDP

                  |L18.36|
                          DCD      SensorsEnabled

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;115    int main(void); /* This "redundant" line is here to fulfil MISRA C-2012 rule 8.4 */
;;;116    int main(void)
000000  f5ad7d0c          SUB      sp,sp,#0x230
;;;117    {
;;;118      char lib_version[35];
;;;119      int lib_version_len;
;;;120      TMsg msg_dat;
;;;121      TMsg msg_cmd;
;;;122    
;;;123      /* STM32xxxx HAL library initialization:
;;;124       *   - Configure the Flash prefetch, instruction and Data caches
;;;125       *   - Configure the Systick to generate an interrupt each 1 msec
;;;126       *   - Set NVIC Group Priority to 4
;;;127       *   - Global MSP (MCU Support Package) initialization
;;;128       */
;;;129      (void)HAL_Init();
000004  f7fffffe          BL       HAL_Init
;;;130    
;;;131      /* Configure the system clock */
;;;132      SystemClock_Config();
000008  f7fffffe          BL       SystemClock_Config
;;;133    
;;;134      /* Configure the SysTick IRQ priority - set the second lowest priority */
;;;135      HAL_NVIC_SetPriority(SysTick_IRQn, 0x0E, 0);
00000c  2200              MOVS     r2,#0
00000e  210e              MOVS     r1,#0xe
000010  1e50              SUBS     r0,r2,#1
000012  f7fffffe          BL       HAL_NVIC_SetPriority
;;;136    
;;;137      /* Initialize GPIOs */
;;;138      MX_GPIO_Init();
000016  f7fffffe          BL       MX_GPIO_Init
;;;139    
;;;140      /* Initialize CRC */
;;;141      MX_CRC_Init();
00001a  f7fffffe          BL       MX_CRC_Init
;;;142    
;;;143      /* Initialize (disabled) Sensors */
;;;144    	 MX_I2C2_Init();
00001e  f7fffffe          BL       MX_I2C2_Init
;;;145    	 // while(1)
;;;146     //{
;;;147    	 init_LSM9DS1_I2C ();
000022  f7fffffe          BL       init_LSM9DS1_I2C
;;;148    	 //status = HAL_I2C_IsDeviceReady(&hi2c3, ADDR, (uint32_t)3, (uint32_t)1000);
;;;149    /*	 if(status != HAL_OK)
;;;150    	 {
;;;151    		 I2C3->CR1 |= I2C_CR1_SWRST;
;;;152    		 MX_I2C2_Init();
;;;153    	 HAL_Delay(10);
;;;154    	 }*/
;;;155    	// HAL_Delay(10);
;;;156     //}
;;;157      Init_Sensors();
000026  f7fffffe          BL       Init_Sensors
;;;158    
;;;159      /* Magnetometer Calibration API initialization function */
;;;160    #if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L1XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
;;;161      MotionMC_manager_init((int)ALGO_PERIOD, 1);
00002a  2101              MOVS     r1,#1
00002c  2014              MOVS     r0,#0x14
00002e  f7fffffe          BL       MotionMC_manager_init
;;;162    
;;;163    #elif (defined (USE_STM32L0XX_NUCLEO))
;;;164      MotionMC_manager_init((int)ALGO_PERIOD, MMC_CM0P_HI_AND_SI, 1);
;;;165    
;;;166    #else
;;;167    #error Not supported platform
;;;168    #endif
;;;169    
;;;170      /* E-Compass API initialization function */
;;;171      MotionEC_manager_init((float)ALGO_FREQ);
000032  ed9f0a2d          VLDR     s0,|L19.232|
000036  f7fffffe          BL       MotionEC_manager_init
;;;172    
;;;173      /* OPTIONAL */
;;;174      /* Get library version */
;;;175      MotionEC_manager_get_version(lib_version, &lib_version_len);
00003a  a982              ADD      r1,sp,#0x208
00003c  a883              ADD      r0,sp,#0x20c
00003e  f7fffffe          BL       MotionEC_manager_get_version
;;;176    
;;;177      /* Initialize Communication Peripheral for data log */
;;;178      USARTConfig();
000042  f7fffffe          BL       USARTConfig
;;;179    
;;;180      /* RTC Initialization */
;;;181      RTC_Config();
000046  f7fffffe          BL       RTC_Config
;;;182      RTC_TimeStampConfig();
00004a  f7fffffe          BL       RTC_TimeStampConfig
;;;183    
;;;184      /* Timer for algorithm synchronization initialization */
;;;185      MX_TIM_ALGO_Init();
00004e  f7fffffe          BL       MX_TIM_ALGO_Init
;;;186    
;;;187      /* LED Blink */
;;;188      BSP_LED_On(LED2);
000052  2000              MOVS     r0,#0
000054  f7fffffe          BL       BSP_LED_On
;;;189      HAL_Delay(500);
000058  f44f70fa          MOV      r0,#0x1f4
00005c  f7fffffe          BL       HAL_Delay
;;;190      BSP_LED_Off(LED2);
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       BSP_LED_Off
;;;191    	
;;;192     
;;;193    
;;;194     init_LSM9DS1_I2C ();
000066  f7fffffe          BL       init_LSM9DS1_I2C
;;;195     //sensors_enable();
;;;196      for (;;)
00006a  bf00              NOP      
                  |L19.108|
;;;197      {
;;;198        if (UART_ReceivedMSG((TMsg *)&msg_cmd) != 1)
00006c  4668              MOV      r0,sp
00006e  f7fffffe          BL       UART_ReceivedMSG
000072  2801              CMP      r0,#1
000074  d006              BEQ      |L19.132|
;;;199        {
;;;200          if (msg_cmd.Data[0] == DEV_ADDR)
000076  f89d0004          LDRB     r0,[sp,#4]
00007a  2832              CMP      r0,#0x32
00007c  d102              BNE      |L19.132|
;;;201          {
;;;202            (void)HandleMSG((TMsg *)&msg_cmd);
00007e  4668              MOV      r0,sp
000080  f7fffffe          BL       HandleMSG
                  |L19.132|
;;;203          }
;;;204        }
;;;205    
;;;206        if (SensorReadRequest == 1U)
000084  4819              LDR      r0,|L19.236|
000086  7800              LDRB     r0,[r0,#0]  ; SensorReadRequest
000088  2801              CMP      r0,#1
00008a  d1ef              BNE      |L19.108|
;;;207        {
;;;208          if (DataLoggerActive == 1U)
00008c  4818              LDR      r0,|L19.240|
00008e  7800              LDRB     r0,[r0,#0]  ; DataLoggerActive
000090  2801              CMP      r0,#1
000092  d1eb              BNE      |L19.108|
;;;209          {
;;;210            SensorReadRequest = 0;
000094  2000              MOVS     r0,#0
000096  4915              LDR      r1,|L19.236|
000098  7008              STRB     r0,[r1,#0]
;;;211    
;;;212            /* Acquire data from enabled sensors and fill Msg stream */
;;;213            RTC_Handler(&msg_dat);
00009a  a841              ADD      r0,sp,#0x104
00009c  f7fffffe          BL       RTC_Handler
;;;214            Accelero_Sensor_Handler(&msg_dat, IKS01A2_LSM303AGR_ACC_0);
0000a0  2101              MOVS     r1,#1
0000a2  a841              ADD      r0,sp,#0x104
0000a4  f7fffffe          BL       Accelero_Sensor_Handler
;;;215            Gyro_Sensor_Handler(&msg_dat, IKS01A2_LSM6DSL_0);
0000a8  2100              MOVS     r1,#0
0000aa  a841              ADD      r0,sp,#0x104
0000ac  f7fffffe          BL       Gyro_Sensor_Handler
;;;216            Magneto_Sensor_Handler(&msg_dat, IKS01A2_LSM303AGR_MAG_0);
0000b0  2102              MOVS     r1,#2
0000b2  a841              ADD      r0,sp,#0x104
0000b4  f7fffffe          BL       Magneto_Sensor_Handler
;;;217            Humidity_Sensor_Handler(&msg_dat, IKS01A2_HTS221_0);
0000b8  2100              MOVS     r1,#0
0000ba  a841              ADD      r0,sp,#0x104
0000bc  f7fffffe          BL       Humidity_Sensor_Handler
;;;218            Temperature_Sensor_Handler(&msg_dat, IKS01A2_HTS221_0);
0000c0  2100              MOVS     r1,#0
0000c2  a841              ADD      r0,sp,#0x104
0000c4  f7fffffe          BL       Temperature_Sensor_Handler
;;;219            Pressure_Sensor_Handler(&msg_dat, IKS01A2_LPS22HB_0);
0000c8  2101              MOVS     r1,#1
0000ca  a841              ADD      r0,sp,#0x104
0000cc  f7fffffe          BL       Pressure_Sensor_Handler
;;;220    
;;;221            /* E-Compass specific part */
;;;222            MotionEC_manager_run(&msg_dat);
0000d0  a841              ADD      r0,sp,#0x104
0000d2  f7fffffe          BL       MotionEC_manager_run
;;;223    
;;;224            /* Send data stream */
;;;225            INIT_STREAMING_HEADER(&msg_dat);
0000d6  a841              ADD      r0,sp,#0x104
0000d8  f7fffffe          BL       INIT_STREAMING_HEADER
;;;226            msg_dat.Len = STREAMING_MSG_LENGTH;
0000dc  207d              MOVS     r0,#0x7d
0000de  9041              STR      r0,[sp,#0x104]
;;;227            UART_SendMsg(&msg_dat);
0000e0  a841              ADD      r0,sp,#0x104
0000e2  f7fffffe          BL       UART_SendMsg
0000e6  e7c1              B        |L19.108|
;;;228          }
;;;229        }
;;;230      }
;;;231    }
;;;232    
                          ENDP

                  |L19.232|
0000e8  42480000          DCFS     0x42480000 ; 50
                  |L19.236|
                          DCD      SensorReadRequest
                  |L19.240|
                          DCD      DataLoggerActive

                          AREA ||i.sensors_enable||, CODE, READONLY, ALIGN=2

                  sensors_enable PROC
;;;673    
;;;674    void sensors_enable()
000000  b510              PUSH     {r4,lr}
;;;675    {
;;;676    	  /* Start enabled sensors */
;;;677         // if ((SensorsEnabled & PRESSURE_SENSOR) == PRESSURE_SENSOR)
;;;678         // {
;;;679            (void)IKS01A2_ENV_SENSOR_Enable(IKS01A2_LPS22HB_0, ENV_PRESSURE);
000002  2102              MOVS     r1,#2
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       IKS01A2_ENV_SENSOR_Enable
;;;680         // }
;;;681    
;;;682         // if ((SensorsEnabled & TEMPERATURE_SENSOR) == TEMPERATURE_SENSOR)
;;;683         // {
;;;684            (void)IKS01A2_ENV_SENSOR_Enable(IKS01A2_HTS221_0, ENV_TEMPERATURE);
00000a  2101              MOVS     r1,#1
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       IKS01A2_ENV_SENSOR_Enable
;;;685         // }
;;;686    
;;;687         // if ((SensorsEnabled & HUMIDITY_SENSOR) == HUMIDITY_SENSOR)
;;;688         // {
;;;689            (void)IKS01A2_ENV_SENSOR_Enable(IKS01A2_HTS221_0, ENV_HUMIDITY);
000012  2104              MOVS     r1,#4
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       IKS01A2_ENV_SENSOR_Enable
;;;690         // }
;;;691    
;;;692         // if ((SensorsEnabled & ACCELEROMETER_SENSOR) == ACCELEROMETER_SENSOR)
;;;693          //{
;;;694            (void)IKS01A2_MOTION_SENSOR_Enable(IKS01A2_LSM303AGR_ACC_0, MOTION_ACCELERO);
00001a  2102              MOVS     r1,#2
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       IKS01A2_MOTION_SENSOR_Enable
;;;695         // }
;;;696    
;;;697         // if ((SensorsEnabled & GYROSCOPE_SENSOR) == GYROSCOPE_SENSOR)
;;;698         // {
;;;699            (void)IKS01A2_MOTION_SENSOR_Enable(IKS01A2_LSM6DSL_0, MOTION_GYRO);
000022  2101              MOVS     r1,#1
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       IKS01A2_MOTION_SENSOR_Enable
;;;700         // }
;;;701    
;;;702         // if ((SensorsEnabled & MAGNETIC_SENSOR) == MAGNETIC_SENSOR)
;;;703         // {
;;;704            (void)IKS01A2_MOTION_SENSOR_Enable(IKS01A2_LSM303AGR_MAG_0, MOTION_MAGNETO);
00002a  2104              MOVS     r1,#4
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       IKS01A2_MOTION_SENSOR_Enable
;;;705         // }
;;;706    
;;;707          (void)HAL_TIM_Base_Start_IT(&AlgoTimHandle);
000032  4803              LDR      r0,|L20.64|
000034  f7fffffe          BL       HAL_TIM_Base_Start_IT
;;;708          DataLoggerActive = 1;
000038  2001              MOVS     r0,#1
00003a  4902              LDR      r1,|L20.68|
00003c  7008              STRB     r0,[r1,#0]
;;;709    		}
00003e  bd10              POP      {r4,pc}
;;;710    #ifdef  USE_FULL_ASSERT
                          ENDP

                  |L20.64|
                          DCD      AlgoTimHandle
                  |L20.68|
                          DCD      DataLoggerActive

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  AlgoTimHandle
                          %        64
                  AccValue
                          %        12
                  MagValue
                          %        12
                  MagValueComp
                          %        12
                  RtcHandle
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  SensorsEnabled
                          DCD      0x00000000
                  UseLSI
                          DCD      0x00000000
                  SensorReadRequest
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  RtcSynchPrediv
                          DCD      0x00000000
                  status
000010  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\Src\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_e1e00a93____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_e1e00a93____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_e1e00a93____REVSH|
#line 402
|__asm___6_main_c_e1e00a93____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_e1e00a93____RRX|
#line 587
|__asm___6_main_c_e1e00a93____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
