; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_rtc.o --asm_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --list_dir=.\STM32F4xx-Nucleo-IKS01A2\Listings\ --depend=.\stm32f4xx-nucleo-iks01a2\objects\stm32f4xx_hal_rtc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Inc -I..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\..\..\..\Drivers\BSP\STM32F4xx-Nucleo -I..\..\..\..\..\..\Drivers\BSP\Components\Common -I..\..\..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\..\..\Drivers\BSP\Components\hts221 -I..\..\..\..\..\..\Drivers\BSP\Components\lps22hb -I..\..\..\..\..\..\Drivers\BSP\Components\lsm6dsl -I..\..\..\..\..\..\Drivers\BSP\Components\lsm303agr -I..\..\..\..\..\..\Drivers\BSP\IKS01A2 -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionEC_Library\Inc -I..\..\..\..\..\..\Middlewares\ST\STM32_MotionMC_Library\Inc -I.\LSM9DS1 -I.\LSM9DS1 -I.\RTE\_STM32F4xx-Nucleo-IKS01A2 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DSTM32F401xE -DSTM32F401xE -DUSE_HAL_DRIVER -DUSE_STM32F4XX_NUCLEO -DUSE_IKS01A2 ..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rtc.c]
                          THUMB

                          AREA ||i.HAL_RTC_AlarmAEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTC_AlarmAEventCallback PROC
;;;1621     */
;;;1622   __weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1623   {
;;;1624     /* Prevent unused argument(s) compilation warning */
;;;1625     UNUSED(hrtc);
;;;1626     /* NOTE : This function should not be modified, when the callback is needed,
;;;1627               the HAL_RTC_AlarmAEventCallback could be implemented in the user file
;;;1628      */
;;;1629   }
;;;1630   
                          ENDP


                          AREA ||i.HAL_RTC_AlarmIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTC_AlarmIRQHandler PROC
;;;1572     */
;;;1573   void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
000000  b510              PUSH     {r4,lr}
;;;1574   {
000002  4604              MOV      r4,r0
;;;1575     if(__HAL_RTC_ALARM_GET_IT(hrtc, RTC_IT_ALRA))
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f3c02000          UBFX     r0,r0,#8,#1
00000c  b178              CBZ      r0,|L2.46|
;;;1576     {
;;;1577       /* Get the status of the Interrupt */
;;;1578       if((uint32_t)(hrtc->Instance->CR & RTC_IT_ALRA) != (uint32_t)RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  6880              LDR      r0,[r0,#8]
000012  f4005080          AND      r0,r0,#0x1000
000016  b150              CBZ      r0,|L2.46|
;;;1579       {
;;;1580         /* AlarmA callback */
;;;1581       #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;1582         hrtc->AlarmAEventCallback(hrtc);
;;;1583       #else
;;;1584         HAL_RTC_AlarmAEventCallback(hrtc);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_RTC_AlarmAEventCallback
;;;1585       #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;1586   
;;;1587         /* Clear the Alarm interrupt pending bit */
;;;1588         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRAF);
00001e  6820              LDR      r0,[r4,#0]
000020  68c0              LDR      r0,[r0,#0xc]
000022  f0000080          AND      r0,r0,#0x80
000026  f46070c0          ORN      r0,r0,#0x180
00002a  6821              LDR      r1,[r4,#0]
00002c  60c8              STR      r0,[r1,#0xc]
                  |L2.46|
;;;1589       }
;;;1590     }
;;;1591   
;;;1592     if(__HAL_RTC_ALARM_GET_IT(hrtc, RTC_IT_ALRB))
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f3c02040          UBFX     r0,r0,#9,#1
000036  b178              CBZ      r0,|L2.88|
;;;1593     {
;;;1594       /* Get the status of the Interrupt */
;;;1595       if((uint32_t)(hrtc->Instance->CR & RTC_IT_ALRB) != (uint32_t)RESET)
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  f4005000          AND      r0,r0,#0x2000
000040  b150              CBZ      r0,|L2.88|
;;;1596       {
;;;1597         /* AlarmB callback */
;;;1598       #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;1599         hrtc->AlarmBEventCallback(hrtc);
;;;1600       #else
;;;1601         HAL_RTCEx_AlarmBEventCallback(hrtc);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_RTCEx_AlarmBEventCallback
;;;1602       #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;1603   
;;;1604         /* Clear the Alarm interrupt pending bit */
;;;1605         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRBF);
000048  6820              LDR      r0,[r4,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  f0000080          AND      r0,r0,#0x80
000050  f4607020          ORN      r0,r0,#0x280
000054  6821              LDR      r1,[r4,#0]
000056  60c8              STR      r0,[r1,#0xc]
                  |L2.88|
;;;1606       }
;;;1607     }
;;;1608   
;;;1609     /* Clear the EXTI's line Flag for RTC Alarm */
;;;1610     __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
000058  f44f3000          MOV      r0,#0x20000
00005c  4902              LDR      r1,|L2.104|
00005e  6008              STR      r0,[r1,#0]
;;;1611   
;;;1612     /* Change RTC state */
;;;1613     hrtc->State = HAL_RTC_STATE_READY;
000060  2001              MOVS     r0,#1
000062  7760              STRB     r0,[r4,#0x1d]
;;;1614   }
000064  bd10              POP      {r4,pc}
;;;1615   
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      0x40013c14

                          AREA ||i.HAL_RTC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DeInit PROC
;;;355      */
;;;356    HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;357    {
000002  4604              MOV      r4,r0
;;;358      uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;359    
;;;360      /* Set RTC state */
;;;361      hrtc->State = HAL_RTC_STATE_BUSY;
000006  2002              MOVS     r0,#2
000008  7760              STRB     r0,[r4,#0x1d]
;;;362    
;;;363      /* Disable the write protection for RTC registers */
;;;364      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
00000a  bf00              NOP      
00000c  20ca              MOVS     r0,#0xca
00000e  6821              LDR      r1,[r4,#0]
000010  6248              STR      r0,[r1,#0x24]
000012  2053              MOVS     r0,#0x53
000014  6821              LDR      r1,[r4,#0]
000016  6248              STR      r0,[r1,#0x24]
000018  bf00              NOP      
;;;365    
;;;366      /* Set Initialization mode */
;;;367      if(RTC_EnterInitMode(hrtc) != HAL_OK)
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RTC_EnterInitMode
000020  b140              CBZ      r0,|L3.52|
;;;368      {
;;;369        /* Enable the write protection for RTC registers */
;;;370        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000022  bf00              NOP      
000024  20ff              MOVS     r0,#0xff
000026  6821              LDR      r1,[r4,#0]
000028  6248              STR      r0,[r1,#0x24]
00002a  bf00              NOP      
;;;371    
;;;372        /* Set RTC state */
;;;373        hrtc->State = HAL_RTC_STATE_ERROR;
00002c  2004              MOVS     r0,#4
00002e  7760              STRB     r0,[r4,#0x1d]
;;;374    
;;;375        return HAL_ERROR;
000030  2001              MOVS     r0,#1
                  |L3.50|
;;;376      }
;;;377      else
;;;378      {
;;;379        /* Reset TR, DR and CR registers */
;;;380        hrtc->Instance->TR = 0x00000000U;
;;;381        hrtc->Instance->DR = 0x00002101U;
;;;382        /* Reset All CR bits except CR[2:0] */
;;;383        hrtc->Instance->CR &= 0x00000007U;
;;;384    
;;;385        /* Get tick */
;;;386        tickstart = HAL_GetTick();
;;;387    
;;;388        /* Wait till WUTWF flag is set and if Time out is reached exit */
;;;389        while(((hrtc->Instance->ISR) & RTC_ISR_WUTWF) == (uint32_t)RESET)
;;;390        {
;;;391          if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;392          {
;;;393            /* Enable the write protection for RTC registers */
;;;394            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;395    
;;;396            /* Set RTC state */
;;;397            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;398    
;;;399            return HAL_TIMEOUT;
;;;400          }
;;;401        }
;;;402    
;;;403        /* Reset all RTC CR register bits */
;;;404        hrtc->Instance->CR &= 0x00000000U;
;;;405        hrtc->Instance->WUTR = 0x0000FFFFU;
;;;406        hrtc->Instance->PRER = 0x007F00FFU;
;;;407        hrtc->Instance->CALIBR = 0x00000000U;
;;;408        hrtc->Instance->ALRMAR = 0x00000000U;
;;;409        hrtc->Instance->ALRMBR = 0x00000000U;
;;;410        hrtc->Instance->SHIFTR = 0x00000000U;
;;;411        hrtc->Instance->CALR = 0x00000000U;
;;;412        hrtc->Instance->ALRMASSR = 0x00000000U;
;;;413        hrtc->Instance->ALRMBSSR = 0x00000000U;
;;;414    
;;;415        /* Reset ISR register and exit initialization mode */
;;;416        hrtc->Instance->ISR = 0x00000000U;
;;;417    
;;;418        /* Reset Tamper and alternate functions configuration register */
;;;419        hrtc->Instance->TAFCR = 0x00000000U;
;;;420    
;;;421        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;422        if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
;;;423        {
;;;424          if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;425          {
;;;426            /* Enable the write protection for RTC registers */
;;;427            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;428    
;;;429            hrtc->State = HAL_RTC_STATE_ERROR;
;;;430    
;;;431            return HAL_ERROR;
;;;432          }
;;;433        }
;;;434      }
;;;435    
;;;436      /* Enable the write protection for RTC registers */
;;;437      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;438    
;;;439    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;440      if(hrtc->MspDeInitCallback == NULL)
;;;441      {
;;;442        hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
;;;443      }
;;;444    
;;;445      /* DeInit the low level hardware: CLOCK, NVIC.*/
;;;446      hrtc->MspDeInitCallback(hrtc);
;;;447    
;;;448    #else
;;;449      /* De-Initialize RTC MSP */
;;;450      HAL_RTC_MspDeInit(hrtc);
;;;451    #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
;;;452    
;;;453      hrtc->State = HAL_RTC_STATE_RESET;
;;;454    
;;;455      /* Release Lock */
;;;456      __HAL_UNLOCK(hrtc);
;;;457    
;;;458      return HAL_OK;
;;;459    }
000032  bd70              POP      {r4-r6,pc}
                  |L3.52|
000034  2000              MOVS     r0,#0                 ;380
000036  6821              LDR      r1,[r4,#0]            ;380
000038  6008              STR      r0,[r1,#0]            ;380
00003a  f2421001          MOV      r0,#0x2101            ;381
00003e  6821              LDR      r1,[r4,#0]            ;381
000040  6048              STR      r0,[r1,#4]            ;381
000042  6820              LDR      r0,[r4,#0]            ;383
000044  6880              LDR      r0,[r0,#8]            ;383
000046  f0000007          AND      r0,r0,#7              ;383
00004a  6821              LDR      r1,[r4,#0]            ;383
00004c  6088              STR      r0,[r1,#8]            ;383
00004e  f7fffffe          BL       HAL_GetTick
000052  4605              MOV      r5,r0                 ;386
000054  e00d              B        |L3.114|
                  |L3.86|
000056  f7fffffe          BL       HAL_GetTick
00005a  1b40              SUBS     r0,r0,r5              ;391
00005c  f5b07f7a          CMP      r0,#0x3e8             ;391
000060  d907              BLS      |L3.114|
000062  bf00              NOP                            ;394
000064  20ff              MOVS     r0,#0xff              ;394
000066  6821              LDR      r1,[r4,#0]            ;394
000068  6248              STR      r0,[r1,#0x24]         ;394
00006a  bf00              NOP                            ;394
00006c  2003              MOVS     r0,#3                 ;397
00006e  7760              STRB     r0,[r4,#0x1d]         ;397
000070  e7df              B        |L3.50|
                  |L3.114|
000072  6820              LDR      r0,[r4,#0]            ;389
000074  68c0              LDR      r0,[r0,#0xc]          ;389
000076  f0000004          AND      r0,r0,#4              ;389
00007a  2800              CMP      r0,#0                 ;389
00007c  d0eb              BEQ      |L3.86|
00007e  6820              LDR      r0,[r4,#0]            ;404
000080  6880              LDR      r0,[r0,#8]            ;404
000082  2000              MOVS     r0,#0                 ;404
000084  6821              LDR      r1,[r4,#0]            ;404
000086  6088              STR      r0,[r1,#8]            ;404
000088  f64f70ff          MOV      r0,#0xffff            ;405
00008c  6821              LDR      r1,[r4,#0]            ;405
00008e  6148              STR      r0,[r1,#0x14]         ;405
000090  481b              LDR      r0,|L3.256|
000092  6821              LDR      r1,[r4,#0]            ;406
000094  6108              STR      r0,[r1,#0x10]         ;406
000096  2000              MOVS     r0,#0                 ;407
000098  6821              LDR      r1,[r4,#0]            ;407
00009a  6188              STR      r0,[r1,#0x18]         ;407
00009c  6821              LDR      r1,[r4,#0]            ;408
00009e  61c8              STR      r0,[r1,#0x1c]         ;408
0000a0  6821              LDR      r1,[r4,#0]            ;409
0000a2  6208              STR      r0,[r1,#0x20]         ;409
0000a4  6821              LDR      r1,[r4,#0]            ;410
0000a6  62c8              STR      r0,[r1,#0x2c]         ;410
0000a8  6821              LDR      r1,[r4,#0]            ;411
0000aa  63c8              STR      r0,[r1,#0x3c]         ;411
0000ac  6821              LDR      r1,[r4,#0]            ;412
0000ae  6448              STR      r0,[r1,#0x44]         ;412
0000b0  6821              LDR      r1,[r4,#0]            ;413
0000b2  6488              STR      r0,[r1,#0x48]         ;413
0000b4  6821              LDR      r1,[r4,#0]            ;416
0000b6  60c8              STR      r0,[r1,#0xc]          ;416
0000b8  6821              LDR      r1,[r4,#0]            ;419
0000ba  6408              STR      r0,[r1,#0x40]         ;419
0000bc  6820              LDR      r0,[r4,#0]            ;422
0000be  6880              LDR      r0,[r0,#8]            ;422
0000c0  f0000020          AND      r0,r0,#0x20           ;422
0000c4  b960              CBNZ     r0,|L3.224|
0000c6  4620              MOV      r0,r4                 ;424
0000c8  f7fffffe          BL       HAL_RTC_WaitForSynchro
0000cc  b140              CBZ      r0,|L3.224|
0000ce  bf00              NOP                            ;427
0000d0  20ff              MOVS     r0,#0xff              ;427
0000d2  6821              LDR      r1,[r4,#0]            ;427
0000d4  6248              STR      r0,[r1,#0x24]         ;427
0000d6  bf00              NOP                            ;427
0000d8  2004              MOVS     r0,#4                 ;429
0000da  7760              STRB     r0,[r4,#0x1d]         ;429
0000dc  2001              MOVS     r0,#1                 ;431
0000de  e7a8              B        |L3.50|
                  |L3.224|
0000e0  bf00              NOP                            ;437
0000e2  20ff              MOVS     r0,#0xff              ;437
0000e4  6821              LDR      r1,[r4,#0]            ;437
0000e6  6248              STR      r0,[r1,#0x24]         ;437
0000e8  bf00              NOP                            ;437
0000ea  4620              MOV      r0,r4                 ;450
0000ec  f7fffffe          BL       HAL_RTC_MspDeInit
0000f0  2000              MOVS     r0,#0                 ;453
0000f2  7760              STRB     r0,[r4,#0x1d]         ;453
0000f4  bf00              NOP                            ;456
0000f6  7720              STRB     r0,[r4,#0x1c]         ;456
0000f8  bf00              NOP                            ;456
0000fa  bf00              NOP                            ;458
0000fc  e799              B        |L3.50|
;;;460    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L3.256|
                          DCD      0x007f00ff

                          AREA ||i.HAL_RTC_DeactivateAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DeactivateAlarm PROC
;;;1424     */
;;;1425   HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
000000  b570              PUSH     {r4-r6,lr}
;;;1426   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1427     uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;1428   
;;;1429     /* Check the parameters */
;;;1430     assert_param(IS_RTC_ALARM(Alarm));
;;;1431   
;;;1432     /* Process Locked */
;;;1433     __HAL_LOCK(hrtc);
000008  bf00              NOP      
00000a  7f20              LDRB     r0,[r4,#0x1c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L4.20|
000010  2002              MOVS     r0,#2
                  |L4.18|
;;;1434   
;;;1435     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1436   
;;;1437     /* Disable the write protection for RTC registers */
;;;1438     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1439   
;;;1440     if(Alarm == RTC_ALARM_A)
;;;1441     {
;;;1442       /* AlarmA */
;;;1443       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;1444   
;;;1445       /* In case of interrupt mode is used, the interrupt source must disabled */
;;;1446       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
;;;1447   
;;;1448       /* Get tick */
;;;1449       tickstart = HAL_GetTick();
;;;1450   
;;;1451       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1452       while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
;;;1453       {
;;;1454         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;1455         {
;;;1456           /* Enable the write protection for RTC registers */
;;;1457           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1458   
;;;1459           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1460   
;;;1461           /* Process Unlocked */
;;;1462           __HAL_UNLOCK(hrtc);
;;;1463   
;;;1464           return HAL_TIMEOUT;
;;;1465         }
;;;1466       }
;;;1467     }
;;;1468     else
;;;1469     {
;;;1470       /* AlarmB */
;;;1471       __HAL_RTC_ALARMB_DISABLE(hrtc);
;;;1472   
;;;1473       /* In case of interrupt mode is used, the interrupt source must disabled */
;;;1474       __HAL_RTC_ALARM_DISABLE_IT(hrtc,RTC_IT_ALRB);
;;;1475   
;;;1476       /* Get tick */
;;;1477       tickstart = HAL_GetTick();
;;;1478   
;;;1479       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1480       while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
;;;1481       {
;;;1482         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;1483         {
;;;1484           /* Enable the write protection for RTC registers */
;;;1485           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1486   
;;;1487           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1488   
;;;1489           /* Process Unlocked */
;;;1490           __HAL_UNLOCK(hrtc);
;;;1491   
;;;1492           return HAL_TIMEOUT;
;;;1493         }
;;;1494       }
;;;1495     }
;;;1496     /* Enable the write protection for RTC registers */
;;;1497     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1498   
;;;1499     hrtc->State = HAL_RTC_STATE_READY;
;;;1500   
;;;1501     /* Process Unlocked */
;;;1502     __HAL_UNLOCK(hrtc);
;;;1503   
;;;1504     return HAL_OK;
;;;1505   }
000012  bd70              POP      {r4-r6,pc}
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;1433
000016  7720              STRB     r0,[r4,#0x1c]         ;1433
000018  bf00              NOP                            ;1433
00001a  2002              MOVS     r0,#2                 ;1435
00001c  7760              STRB     r0,[r4,#0x1d]         ;1435
00001e  bf00              NOP                            ;1438
000020  20ca              MOVS     r0,#0xca              ;1438
000022  6821              LDR      r1,[r4,#0]            ;1438
000024  6248              STR      r0,[r1,#0x24]         ;1438
000026  2053              MOVS     r0,#0x53              ;1438
000028  6821              LDR      r1,[r4,#0]            ;1438
00002a  6248              STR      r0,[r1,#0x24]         ;1438
00002c  bf00              NOP                            ;1438
00002e  f5b57f80          CMP      r5,#0x100             ;1440
000032  d129              BNE      |L4.136|
000034  6820              LDR      r0,[r4,#0]            ;1443
000036  6880              LDR      r0,[r0,#8]            ;1443
000038  f4207080          BIC      r0,r0,#0x100          ;1443
00003c  6821              LDR      r1,[r4,#0]            ;1443
00003e  6088              STR      r0,[r1,#8]            ;1443
000040  6820              LDR      r0,[r4,#0]            ;1446
000042  6880              LDR      r0,[r0,#8]            ;1446
000044  f4205080          BIC      r0,r0,#0x1000         ;1446
000048  6821              LDR      r1,[r4,#0]            ;1446
00004a  6088              STR      r0,[r1,#8]            ;1446
00004c  f7fffffe          BL       HAL_GetTick
000050  4606              MOV      r6,r0                 ;1449
000052  e012              B        |L4.122|
                  |L4.84|
000054  f7fffffe          BL       HAL_GetTick
000058  1b80              SUBS     r0,r0,r6              ;1454
00005a  f5b07f7a          CMP      r0,#0x3e8             ;1454
00005e  d90c              BLS      |L4.122|
000060  bf00              NOP                            ;1457
000062  20ff              MOVS     r0,#0xff              ;1457
000064  6821              LDR      r1,[r4,#0]            ;1457
000066  6248              STR      r0,[r1,#0x24]         ;1457
000068  bf00              NOP                            ;1457
00006a  2003              MOVS     r0,#3                 ;1459
00006c  7760              STRB     r0,[r4,#0x1d]         ;1459
00006e  bf00              NOP                            ;1462
000070  2000              MOVS     r0,#0                 ;1462
000072  7720              STRB     r0,[r4,#0x1c]         ;1462
000074  bf00              NOP                            ;1462
000076  2003              MOVS     r0,#3                 ;1464
000078  e7cb              B        |L4.18|
                  |L4.122|
00007a  6820              LDR      r0,[r4,#0]            ;1452
00007c  68c0              LDR      r0,[r0,#0xc]          ;1452
00007e  f0000001          AND      r0,r0,#1              ;1452
000082  2800              CMP      r0,#0                 ;1452
000084  d0e6              BEQ      |L4.84|
000086  e028              B        |L4.218|
                  |L4.136|
000088  6820              LDR      r0,[r4,#0]            ;1471
00008a  6880              LDR      r0,[r0,#8]            ;1471
00008c  f4207000          BIC      r0,r0,#0x200          ;1471
000090  6821              LDR      r1,[r4,#0]            ;1471
000092  6088              STR      r0,[r1,#8]            ;1471
000094  6820              LDR      r0,[r4,#0]            ;1474
000096  6880              LDR      r0,[r0,#8]            ;1474
000098  f4205000          BIC      r0,r0,#0x2000         ;1474
00009c  6821              LDR      r1,[r4,#0]            ;1474
00009e  6088              STR      r0,[r1,#8]            ;1474
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  4606              MOV      r6,r0                 ;1477
0000a6  e012              B        |L4.206|
                  |L4.168|
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  1b80              SUBS     r0,r0,r6              ;1482
0000ae  f5b07f7a          CMP      r0,#0x3e8             ;1482
0000b2  d90c              BLS      |L4.206|
0000b4  bf00              NOP                            ;1485
0000b6  20ff              MOVS     r0,#0xff              ;1485
0000b8  6821              LDR      r1,[r4,#0]            ;1485
0000ba  6248              STR      r0,[r1,#0x24]         ;1485
0000bc  bf00              NOP                            ;1485
0000be  2003              MOVS     r0,#3                 ;1487
0000c0  7760              STRB     r0,[r4,#0x1d]         ;1487
0000c2  bf00              NOP                            ;1490
0000c4  2000              MOVS     r0,#0                 ;1490
0000c6  7720              STRB     r0,[r4,#0x1c]         ;1490
0000c8  bf00              NOP                            ;1490
0000ca  2003              MOVS     r0,#3                 ;1492
0000cc  e7a1              B        |L4.18|
                  |L4.206|
0000ce  6820              LDR      r0,[r4,#0]            ;1480
0000d0  68c0              LDR      r0,[r0,#0xc]          ;1480
0000d2  f3c00040          UBFX     r0,r0,#1,#1           ;1480
0000d6  2800              CMP      r0,#0                 ;1480
0000d8  d0e6              BEQ      |L4.168|
                  |L4.218|
0000da  bf00              NOP                            ;1497
0000dc  20ff              MOVS     r0,#0xff              ;1497
0000de  6821              LDR      r1,[r4,#0]            ;1497
0000e0  6248              STR      r0,[r1,#0x24]         ;1497
0000e2  bf00              NOP                            ;1497
0000e4  2001              MOVS     r0,#1                 ;1499
0000e6  7760              STRB     r0,[r4,#0x1d]         ;1499
0000e8  bf00              NOP                            ;1502
0000ea  2000              MOVS     r0,#0                 ;1502
0000ec  7720              STRB     r0,[r4,#0x1c]         ;1502
0000ee  bf00              NOP                            ;1502
0000f0  bf00              NOP                            ;1504
0000f2  e78e              B        |L4.18|
;;;1506   
                          ENDP


                          AREA ||i.HAL_RTC_GetAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetAlarm PROC
;;;1521     */
;;;1522   HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1523   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1524     uint32_t tmpreg = 0U, subsecondtmpreg = 0U;
00000c  2300              MOVS     r3,#0
00000e  4698              MOV      r8,r3
;;;1525   
;;;1526     /* Check the parameters */
;;;1527     assert_param(IS_RTC_FORMAT(Format));
;;;1528     assert_param(IS_RTC_ALARM(Alarm));
;;;1529   
;;;1530     if(Alarm == RTC_ALARM_A)
000010  f5b67f80          CMP      r6,#0x100
000014  d109              BNE      |L5.42|
;;;1531     {
;;;1532       /* AlarmA */
;;;1533       sAlarm->Alarm = RTC_ALARM_A;
000016  f44f7080          MOV      r0,#0x100
00001a  6260              STR      r0,[r4,#0x24]
;;;1534   
;;;1535       tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);
00001c  6828              LDR      r0,[r5,#0]
00001e  69c3              LDR      r3,[r0,#0x1c]
;;;1536       subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR ) & RTC_ALRMASSR_SS);
000020  6828              LDR      r0,[r5,#0]
000022  6c40              LDR      r0,[r0,#0x44]
000024  f3c0080e          UBFX     r8,r0,#0,#15
000028  e008              B        |L5.60|
                  |L5.42|
;;;1537     }
;;;1538     else
;;;1539     {
;;;1540       sAlarm->Alarm = RTC_ALARM_B;
00002a  f44f7000          MOV      r0,#0x200
00002e  6260              STR      r0,[r4,#0x24]
;;;1541   
;;;1542       tmpreg = (uint32_t)(hrtc->Instance->ALRMBR);
000030  6828              LDR      r0,[r5,#0]
000032  6a03              LDR      r3,[r0,#0x20]
;;;1543       subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);
000034  6828              LDR      r0,[r5,#0]
000036  6c80              LDR      r0,[r0,#0x48]
000038  f3c0080e          UBFX     r8,r0,#0,#15
                  |L5.60|
;;;1544     }
;;;1545   
;;;1546     /* Fill the structure with the read parameters */
;;;1547     sAlarm->AlarmTime.Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16U);
00003c  f3c34005          UBFX     r0,r3,#16,#6
000040  7020              STRB     r0,[r4,#0]
;;;1548     sAlarm->AlarmTime.Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8U);
000042  f3c32006          UBFX     r0,r3,#8,#7
000046  7060              STRB     r0,[r4,#1]
;;;1549     sAlarm->AlarmTime.Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
000048  f003007f          AND      r0,r3,#0x7f
00004c  70a0              STRB     r0,[r4,#2]
;;;1550     sAlarm->AlarmTime.TimeFormat = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16U);
00004e  f4030080          AND      r0,r3,#0x400000
000052  0c00              LSRS     r0,r0,#16
000054  70e0              STRB     r0,[r4,#3]
;;;1551     sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
000056  f8c48004          STR      r8,[r4,#4]
;;;1552     sAlarm->AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24U);
00005a  f3c36005          UBFX     r0,r3,#24,#6
00005e  f8840020          STRB     r0,[r4,#0x20]
;;;1553     sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
000062  f0034080          AND      r0,r3,#0x40000000
000066  61e0              STR      r0,[r4,#0x1c]
;;;1554     sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);
000068  f0033080          AND      r0,r3,#0x80808080
00006c  6160              STR      r0,[r4,#0x14]
;;;1555   
;;;1556     if(Format == RTC_FORMAT_BIN)
00006e  b98f              CBNZ     r7,|L5.148|
;;;1557     {
;;;1558       sAlarm->AlarmTime.Hours = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
000070  7820              LDRB     r0,[r4,#0]
000072  f7fffffe          BL       RTC_Bcd2ToByte
000076  7020              STRB     r0,[r4,#0]
;;;1559       sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);
000078  7860              LDRB     r0,[r4,#1]
00007a  f7fffffe          BL       RTC_Bcd2ToByte
00007e  7060              STRB     r0,[r4,#1]
;;;1560       sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);
000080  78a0              LDRB     r0,[r4,#2]
000082  f7fffffe          BL       RTC_Bcd2ToByte
000086  70a0              STRB     r0,[r4,#2]
;;;1561       sAlarm->AlarmDateWeekDay = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
000088  f8940020          LDRB     r0,[r4,#0x20]
00008c  f7fffffe          BL       RTC_Bcd2ToByte
000090  f8840020          STRB     r0,[r4,#0x20]
                  |L5.148|
;;;1562     }
;;;1563   
;;;1564     return HAL_OK;
000094  2000              MOVS     r0,#0
;;;1565   }
000096  e8bd81f0          POP      {r4-r8,pc}
;;;1566   
                          ENDP


                          AREA ||i.HAL_RTC_GetDate||, CODE, READONLY, ALIGN=2

                  HAL_RTC_GetDate PROC
;;;1003     */
;;;1004   HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  b570              PUSH     {r4-r6,lr}
;;;1005   {
000002  4605              MOV      r5,r0
000004  460b              MOV      r3,r1
000006  4616              MOV      r6,r2
;;;1006     uint32_t datetmpreg = 0U;
000008  2400              MOVS     r4,#0
;;;1007   
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_RTC_FORMAT(Format));
;;;1010   
;;;1011     /* Get the DR register */
;;;1012     datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
00000a  6828              LDR      r0,[r5,#0]
00000c  6840              LDR      r0,[r0,#4]
00000e  490e              LDR      r1,|L6.72|
000010  ea000401          AND      r4,r0,r1
;;;1013   
;;;1014     /* Fill the structure fields with the read parameters */
;;;1015     sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16U);
000014  0c20              LSRS     r0,r4,#16
000016  70d8              STRB     r0,[r3,#3]
;;;1016     sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
000018  f3c42004          UBFX     r0,r4,#8,#5
00001c  7058              STRB     r0,[r3,#1]
;;;1017     sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
00001e  f004003f          AND      r0,r4,#0x3f
000022  7098              STRB     r0,[r3,#2]
;;;1018     sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13U);
000024  f3c43042          UBFX     r0,r4,#13,#3
000028  7018              STRB     r0,[r3,#0]
;;;1019   
;;;1020     /* Check the input parameters format */
;;;1021     if(Format == RTC_FORMAT_BIN)
00002a  b95e              CBNZ     r6,|L6.68|
;;;1022     {
;;;1023       /* Convert the date structure parameters to Binary format */
;;;1024       sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
00002c  78d8              LDRB     r0,[r3,#3]
00002e  f7fffffe          BL       RTC_Bcd2ToByte
000032  70d8              STRB     r0,[r3,#3]
;;;1025       sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
000034  7858              LDRB     r0,[r3,#1]
000036  f7fffffe          BL       RTC_Bcd2ToByte
00003a  7058              STRB     r0,[r3,#1]
;;;1026       sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
00003c  7898              LDRB     r0,[r3,#2]
00003e  f7fffffe          BL       RTC_Bcd2ToByte
000042  7098              STRB     r0,[r3,#2]
                  |L6.68|
;;;1027     }
;;;1028     return HAL_OK;
000044  2000              MOVS     r0,#0
;;;1029   }
000046  bd70              POP      {r4-r6,pc}
;;;1030   
                          ENDP

                  |L6.72|
                          DCD      0x00ffff3f

                          AREA ||i.HAL_RTC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetState PROC
;;;1745     */
;;;1746   HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef* hrtc)
000000  4601              MOV      r1,r0
;;;1747   {
;;;1748     return hrtc->State;
000002  7f48              LDRB     r0,[r1,#0x1d]
;;;1749   }
000004  4770              BX       lr
;;;1750   
                          ENDP


                          AREA ||i.HAL_RTC_GetTime||, CODE, READONLY, ALIGN=2

                  HAL_RTC_GetTime PROC
;;;848      */
;;;849    HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  b570              PUSH     {r4-r6,lr}
;;;850    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4616              MOV      r6,r2
;;;851      uint32_t tmpreg = 0U;
000008  2500              MOVS     r5,#0
;;;852    
;;;853      /* Check the parameters */
;;;854      assert_param(IS_RTC_FORMAT(Format));
;;;855    
;;;856      /* Get subseconds structure field from the corresponding register */
;;;857      sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a80              LDR      r0,[r0,#0x28]
00000e  6058              STR      r0,[r3,#4]
;;;858    
;;;859      /* Get SecondFraction structure field from the corresponding register field*/
;;;860      sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  f3c0000e          UBFX     r0,r0,#0,#15
000018  6098              STR      r0,[r3,#8]
;;;861    
;;;862      /* Get the TR register */
;;;863      tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
00001a  6820              LDR      r0,[r4,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  490f              LDR      r1,|L8.92|
000020  ea000501          AND      r5,r0,r1
;;;864    
;;;865      /* Fill the structure fields with the read parameters */
;;;866      sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
000024  f3c54005          UBFX     r0,r5,#16,#6
000028  7018              STRB     r0,[r3,#0]
;;;867      sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
00002a  f3c52006          UBFX     r0,r5,#8,#7
00002e  7058              STRB     r0,[r3,#1]
;;;868      sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
000030  f005007f          AND      r0,r5,#0x7f
000034  7098              STRB     r0,[r3,#2]
;;;869      sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16U);
000036  f4050080          AND      r0,r5,#0x400000
00003a  0c00              LSRS     r0,r0,#16
00003c  70d8              STRB     r0,[r3,#3]
;;;870    
;;;871      /* Check the input parameters format */
;;;872      if(Format == RTC_FORMAT_BIN)
00003e  b95e              CBNZ     r6,|L8.88|
;;;873      {
;;;874        /* Convert the time structure parameters to Binary format */
;;;875        sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
000040  7818              LDRB     r0,[r3,#0]
000042  f7fffffe          BL       RTC_Bcd2ToByte
000046  7018              STRB     r0,[r3,#0]
;;;876        sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
000048  7858              LDRB     r0,[r3,#1]
00004a  f7fffffe          BL       RTC_Bcd2ToByte
00004e  7058              STRB     r0,[r3,#1]
;;;877        sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
000050  7898              LDRB     r0,[r3,#2]
000052  f7fffffe          BL       RTC_Bcd2ToByte
000056  7098              STRB     r0,[r3,#2]
                  |L8.88|
;;;878      }
;;;879    
;;;880      return HAL_OK;
000058  2000              MOVS     r0,#0
;;;881    }
00005a  bd70              POP      {r4-r6,pc}
;;;882    
                          ENDP

                  |L8.92|
                          DCD      0x007f7f7f

                          AREA ||i.HAL_RTC_Init||, CODE, READONLY, ALIGN=2

                  HAL_RTC_Init PROC
;;;238      */
;;;239    HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;240    {
000002  4604              MOV      r4,r0
;;;241      /* Check the RTC peripheral state */
;;;242      if(hrtc == NULL)
000004  b90c              CBNZ     r4,|L9.10|
;;;243      {
;;;244         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L9.8|
;;;245      }
;;;246    
;;;247      /* Check the parameters */
;;;248      assert_param(IS_RTC_HOUR_FORMAT(hrtc->Init.HourFormat));
;;;249      assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
;;;250      assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
;;;251      assert_param (IS_RTC_OUTPUT(hrtc->Init.OutPut));
;;;252      assert_param (IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
;;;253      assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
;;;254    
;;;255    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;256      if(hrtc->State == HAL_RTC_STATE_RESET)
;;;257      {
;;;258        /* Allocate lock resource and initialize it */
;;;259        hrtc->Lock = HAL_UNLOCKED;
;;;260    
;;;261        hrtc->AlarmAEventCallback          =  HAL_RTC_AlarmAEventCallback;        /* Legacy weak AlarmAEventCallback      */
;;;262        hrtc->AlarmBEventCallback          =  HAL_RTCEx_AlarmBEventCallback;      /* Legacy weak AlarmBEventCallback      */
;;;263        hrtc->TimeStampEventCallback       =  HAL_RTCEx_TimeStampEventCallback;   /* Legacy weak TimeStampEventCallback   */
;;;264        hrtc->WakeUpTimerEventCallback     =  HAL_RTCEx_WakeUpTimerEventCallback; /* Legacy weak WakeUpTimerEventCallback */
;;;265        hrtc->Tamper1EventCallback         =  HAL_RTCEx_Tamper1EventCallback;     /* Legacy weak Tamper1EventCallback     */
;;;266        hrtc->Tamper2EventCallback         =  HAL_RTCEx_Tamper2EventCallback;     /* Legacy weak Tamper2EventCallback     */
;;;267    
;;;268        if(hrtc->MspInitCallback == NULL)
;;;269        {
;;;270          hrtc->MspInitCallback = HAL_RTC_MspInit;
;;;271        }
;;;272        /* Init the low level hardware */
;;;273        hrtc->MspInitCallback(hrtc);
;;;274    
;;;275        if(hrtc->MspDeInitCallback == NULL)
;;;276        {
;;;277          hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
;;;278        }
;;;279      }
;;;280    #else
;;;281      if(hrtc->State == HAL_RTC_STATE_RESET)
;;;282      {
;;;283        /* Allocate lock resource and initialize it */
;;;284        hrtc->Lock = HAL_UNLOCKED;
;;;285    
;;;286        /* Initialize RTC MSP */
;;;287        HAL_RTC_MspInit(hrtc);
;;;288      }
;;;289    #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
;;;290    
;;;291      /* Set RTC state */
;;;292      hrtc->State = HAL_RTC_STATE_BUSY;
;;;293    
;;;294      /* Disable the write protection for RTC registers */
;;;295      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;296    
;;;297      /* Set Initialization mode */
;;;298      if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;299      {
;;;300        /* Enable the write protection for RTC registers */
;;;301        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;302    
;;;303        /* Set RTC state */
;;;304        hrtc->State = HAL_RTC_STATE_ERROR;
;;;305    
;;;306        return HAL_ERROR;
;;;307      }
;;;308      else
;;;309      {
;;;310        /* Clear RTC_CR FMT, OSEL and POL Bits */
;;;311        hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
;;;312        /* Set RTC_CR register */
;;;313        hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
;;;314    
;;;315        /* Configure the RTC PRER */
;;;316        hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
;;;317        hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
;;;318    
;;;319        /* Exit Initialization mode */
;;;320        hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
;;;321    
;;;322        /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;323        if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
;;;324        {
;;;325          if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;326          {
;;;327            /* Enable the write protection for RTC registers */
;;;328            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;329    
;;;330            hrtc->State = HAL_RTC_STATE_ERROR;
;;;331    
;;;332            return HAL_ERROR;
;;;333          }
;;;334        }
;;;335    
;;;336        hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
;;;337        hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType);
;;;338    
;;;339        /* Enable the write protection for RTC registers */
;;;340        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;341    
;;;342        /* Set RTC state */
;;;343        hrtc->State = HAL_RTC_STATE_READY;
;;;344    
;;;345        return HAL_OK;
;;;346      }
;;;347    }
000008  bd10              POP      {r4,pc}
                  |L9.10|
00000a  7f60              LDRB     r0,[r4,#0x1d]         ;281
00000c  b920              CBNZ     r0,|L9.24|
00000e  2000              MOVS     r0,#0                 ;284
000010  7720              STRB     r0,[r4,#0x1c]         ;284
000012  4620              MOV      r0,r4                 ;287
000014  f7fffffe          BL       HAL_RTC_MspInit
                  |L9.24|
000018  2002              MOVS     r0,#2                 ;292
00001a  7760              STRB     r0,[r4,#0x1d]         ;292
00001c  bf00              NOP                            ;295
00001e  20ca              MOVS     r0,#0xca              ;295
000020  6821              LDR      r1,[r4,#0]            ;295
000022  6248              STR      r0,[r1,#0x24]         ;295
000024  2053              MOVS     r0,#0x53              ;295
000026  6821              LDR      r1,[r4,#0]            ;295
000028  6248              STR      r0,[r1,#0x24]         ;295
00002a  bf00              NOP                            ;295
00002c  4620              MOV      r0,r4                 ;298
00002e  f7fffffe          BL       RTC_EnterInitMode
000032  b140              CBZ      r0,|L9.70|
000034  bf00              NOP                            ;301
000036  20ff              MOVS     r0,#0xff              ;301
000038  6821              LDR      r1,[r4,#0]            ;301
00003a  6248              STR      r0,[r1,#0x24]         ;301
00003c  bf00              NOP                            ;301
00003e  2004              MOVS     r0,#4                 ;304
000040  7760              STRB     r0,[r4,#0x1d]         ;304
000042  2001              MOVS     r0,#1                 ;306
000044  e7e0              B        |L9.8|
                  |L9.70|
000046  6820              LDR      r0,[r4,#0]            ;311
000048  6880              LDR      r0,[r0,#8]            ;311
00004a  4922              LDR      r1,|L9.212|
00004c  4008              ANDS     r0,r0,r1              ;311
00004e  6821              LDR      r1,[r4,#0]            ;311
000050  6088              STR      r0,[r1,#8]            ;311
000052  6921              LDR      r1,[r4,#0x10]         ;313
000054  6860              LDR      r0,[r4,#4]            ;313
000056  4308              ORRS     r0,r0,r1              ;313
000058  6961              LDR      r1,[r4,#0x14]         ;313
00005a  4308              ORRS     r0,r0,r1              ;313
00005c  6821              LDR      r1,[r4,#0]            ;313
00005e  6889              LDR      r1,[r1,#8]            ;313
000060  4308              ORRS     r0,r0,r1              ;313
000062  6821              LDR      r1,[r4,#0]            ;313
000064  6088              STR      r0,[r1,#8]            ;313
000066  6821              LDR      r1,[r4,#0]            ;316
000068  68e0              LDR      r0,[r4,#0xc]          ;316
00006a  6108              STR      r0,[r1,#0x10]         ;316
00006c  6820              LDR      r0,[r4,#0]            ;317
00006e  6901              LDR      r1,[r0,#0x10]         ;317
000070  8920              LDRH     r0,[r4,#8]            ;317
000072  ea414000          ORR      r0,r1,r0,LSL #16      ;317
000076  6821              LDR      r1,[r4,#0]            ;317
000078  6108              STR      r0,[r1,#0x10]         ;317
00007a  6820              LDR      r0,[r4,#0]            ;320
00007c  68c0              LDR      r0,[r0,#0xc]          ;320
00007e  f0200080          BIC      r0,r0,#0x80           ;320
000082  6821              LDR      r1,[r4,#0]            ;320
000084  60c8              STR      r0,[r1,#0xc]          ;320
000086  6820              LDR      r0,[r4,#0]            ;323
000088  6880              LDR      r0,[r0,#8]            ;323
00008a  f0000020          AND      r0,r0,#0x20           ;323
00008e  b960              CBNZ     r0,|L9.170|
000090  4620              MOV      r0,r4                 ;325
000092  f7fffffe          BL       HAL_RTC_WaitForSynchro
000096  b140              CBZ      r0,|L9.170|
000098  bf00              NOP                            ;328
00009a  20ff              MOVS     r0,#0xff              ;328
00009c  6821              LDR      r1,[r4,#0]            ;328
00009e  6248              STR      r0,[r1,#0x24]         ;328
0000a0  bf00              NOP                            ;328
0000a2  2004              MOVS     r0,#4                 ;330
0000a4  7760              STRB     r0,[r4,#0x1d]         ;330
0000a6  2001              MOVS     r0,#1                 ;332
0000a8  e7ae              B        |L9.8|
                  |L9.170|
0000aa  6820              LDR      r0,[r4,#0]            ;336
0000ac  6c00              LDR      r0,[r0,#0x40]         ;336
0000ae  f4202080          BIC      r0,r0,#0x40000        ;336
0000b2  6821              LDR      r1,[r4,#0]            ;336
0000b4  6408              STR      r0,[r1,#0x40]         ;336
0000b6  6820              LDR      r0,[r4,#0]            ;337
0000b8  6c00              LDR      r0,[r0,#0x40]         ;337
0000ba  69a1              LDR      r1,[r4,#0x18]         ;337
0000bc  4308              ORRS     r0,r0,r1              ;337
0000be  6821              LDR      r1,[r4,#0]            ;337
0000c0  6408              STR      r0,[r1,#0x40]         ;337
0000c2  bf00              NOP                            ;340
0000c4  20ff              MOVS     r0,#0xff              ;340
0000c6  6821              LDR      r1,[r4,#0]            ;340
0000c8  6248              STR      r0,[r1,#0x24]         ;340
0000ca  bf00              NOP                            ;340
0000cc  2001              MOVS     r0,#1                 ;343
0000ce  7760              STRB     r0,[r4,#0x1d]         ;343
0000d0  2000              MOVS     r0,#0                 ;345
0000d2  e799              B        |L9.8|
;;;348    
                          ENDP

                  |L9.212|
                          DCD      0xff8fffbf

                          AREA ||i.HAL_RTC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspDeInit PROC
;;;679      */
;;;680    __weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef* hrtc)
000000  4770              BX       lr
;;;681    {
;;;682      /* Prevent unused argument(s) compilation warning */
;;;683      UNUSED(hrtc);
;;;684      /* NOTE : This function Should not be modified, when the callback is needed,
;;;685                the HAL_RTC_MspDeInit could be implemented in the user file
;;;686       */
;;;687    }
;;;688    
                          ENDP


                          AREA ||i.HAL_RTC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspInit PROC
;;;664      */
;;;665    __weak void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
000000  4770              BX       lr
;;;666    {
;;;667      /* Prevent unused argument(s) compilation warning */
;;;668      UNUSED(hrtc);
;;;669      /* NOTE : This function Should not be modified, when the callback is needed,
;;;670                the HAL_RTC_MspInit could be implemented in the user file
;;;671       */
;;;672    }
;;;673    
                          ENDP


                          AREA ||i.HAL_RTC_PollForAlarmAEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTC_PollForAlarmAEvent PROC
;;;1637     */
;;;1638   HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1639   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1640     uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;1641   
;;;1642       /* Get tick */
;;;1643       tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;1644   
;;;1645     while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == RESET)
00000e  e00a              B        |L12.38|
                  |L12.16|
;;;1646     {
;;;1647       if(Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L12.38|
;;;1648       {
;;;1649         if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
000014  b125              CBZ      r5,|L12.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L12.38|
                  |L12.32|
;;;1650         {
;;;1651           hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L12.36|
;;;1652           return HAL_TIMEOUT;
;;;1653         }
;;;1654       }
;;;1655     }
;;;1656   
;;;1657     /* Clear the Alarm interrupt pending bit */
;;;1658     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1659   
;;;1660     /* Change RTC state */
;;;1661     hrtc->State = HAL_RTC_STATE_READY;
;;;1662   
;;;1663     return HAL_OK;
;;;1664   }
000024  bd70              POP      {r4-r6,pc}
                  |L12.38|
000026  6820              LDR      r0,[r4,#0]            ;1645
000028  68c0              LDR      r0,[r0,#0xc]          ;1645
00002a  f3c02000          UBFX     r0,r0,#8,#1           ;1645
00002e  2800              CMP      r0,#0                 ;1645
000030  d0ee              BEQ      |L12.16|
000032  6820              LDR      r0,[r4,#0]            ;1658
000034  68c0              LDR      r0,[r0,#0xc]          ;1658
000036  f0000080          AND      r0,r0,#0x80           ;1658
00003a  f46070c0          ORN      r0,r0,#0x180          ;1658
00003e  6821              LDR      r1,[r4,#0]            ;1658
000040  60c8              STR      r0,[r1,#0xc]          ;1658
000042  2001              MOVS     r0,#1                 ;1661
000044  7760              STRB     r0,[r4,#0x1d]         ;1661
000046  2000              MOVS     r0,#0                 ;1663
000048  e7ec              B        |L12.36|
;;;1665   
                          ENDP


                          AREA ||i.HAL_RTC_SetAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_SetAlarm PROC
;;;1058     */
;;;1059   HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1060   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1061     uint32_t tickstart = 0U;
00000a  2700              MOVS     r7,#0
;;;1062     uint32_t tmpreg = 0U, subsecondtmpreg = 0U;
00000c  46b8              MOV      r8,r7
00000e  46b9              MOV      r9,r7
;;;1063   
;;;1064     /* Check the parameters */
;;;1065     assert_param(IS_RTC_FORMAT(Format));
;;;1066     assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;1067     assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
;;;1068     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
;;;1069     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
;;;1070     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
;;;1071   
;;;1072     /* Process Locked */
;;;1073     __HAL_LOCK(hrtc);
000010  bf00              NOP      
000012  7f20              LDRB     r0,[r4,#0x1c]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L13.30|
000018  2002              MOVS     r0,#2
                  |L13.26|
;;;1074   
;;;1075     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1076   
;;;1077     if(Format == RTC_FORMAT_BIN)
;;;1078     {
;;;1079       if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;1080       {
;;;1081         assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
;;;1082         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1083       }
;;;1084       else
;;;1085       {
;;;1086         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1087         assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;1088       }
;;;1089       assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;1090       assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;1091   
;;;1092       if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1093       {
;;;1094         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
;;;1095       }
;;;1096       else
;;;1097       {
;;;1098         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
;;;1099       }
;;;1100   
;;;1101       tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
;;;1102                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
;;;1103                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
;;;1104                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
;;;1105                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
;;;1106                 ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
;;;1107                 ((uint32_t)sAlarm->AlarmMask));
;;;1108     }
;;;1109     else
;;;1110     {
;;;1111       if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;1112       {
;;;1113         assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1114         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1115       }
;;;1116       else
;;;1117       {
;;;1118         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1119         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1120       }
;;;1121   
;;;1122       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1123       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1124   
;;;1125       if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1126       {
;;;1127         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1128       }
;;;1129       else
;;;1130       {
;;;1131         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1132       }
;;;1133   
;;;1134       tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
;;;1135                 ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
;;;1136                 ((uint32_t) sAlarm->AlarmTime.Seconds) | \
;;;1137                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
;;;1138                 ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
;;;1139                 ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
;;;1140                 ((uint32_t)sAlarm->AlarmMask));
;;;1141     }
;;;1142   
;;;1143     /* Configure the Alarm A or Alarm B Sub Second registers */
;;;1144     subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
;;;1145   
;;;1146     /* Disable the write protection for RTC registers */
;;;1147     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1148   
;;;1149     /* Configure the Alarm register */
;;;1150     if(sAlarm->Alarm == RTC_ALARM_A)
;;;1151     {
;;;1152       /* Disable the Alarm A interrupt */
;;;1153       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;1154   
;;;1155       /* In case of interrupt mode is used, the interrupt source must disabled */
;;;1156       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
;;;1157   
;;;1158       /* Get tick */
;;;1159       tickstart = HAL_GetTick();
;;;1160   
;;;1161       /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
;;;1162       while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
;;;1163       {
;;;1164         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;1165         {
;;;1166           /* Enable the write protection for RTC registers */
;;;1167           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1168   
;;;1169           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1170   
;;;1171           /* Process Unlocked */
;;;1172           __HAL_UNLOCK(hrtc);
;;;1173   
;;;1174           return HAL_TIMEOUT;
;;;1175         }
;;;1176       }
;;;1177   
;;;1178       hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
;;;1179       /* Configure the Alarm A Sub Second register */
;;;1180       hrtc->Instance->ALRMASSR = subsecondtmpreg;
;;;1181       /* Configure the Alarm state: Enable Alarm */
;;;1182       __HAL_RTC_ALARMA_ENABLE(hrtc);
;;;1183     }
;;;1184     else
;;;1185     {
;;;1186       /* Disable the Alarm B interrupt */
;;;1187       __HAL_RTC_ALARMB_DISABLE(hrtc);
;;;1188   
;;;1189       /* In case of interrupt mode is used, the interrupt source must disabled */
;;;1190       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
;;;1191   
;;;1192       /* Get tick */
;;;1193       tickstart = HAL_GetTick();
;;;1194   
;;;1195       /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
;;;1196       while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
;;;1197       {
;;;1198         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
;;;1199         {
;;;1200           /* Enable the write protection for RTC registers */
;;;1201           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1202   
;;;1203           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1204   
;;;1205           /* Process Unlocked */
;;;1206           __HAL_UNLOCK(hrtc);
;;;1207   
;;;1208           return HAL_TIMEOUT;
;;;1209         }
;;;1210       }
;;;1211   
;;;1212       hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
;;;1213       /* Configure the Alarm B Sub Second register */
;;;1214       hrtc->Instance->ALRMBSSR = subsecondtmpreg;
;;;1215       /* Configure the Alarm state: Enable Alarm */
;;;1216       __HAL_RTC_ALARMB_ENABLE(hrtc);
;;;1217     }
;;;1218   
;;;1219     /* Enable the write protection for RTC registers */
;;;1220     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1221   
;;;1222     /* Change RTC state */
;;;1223     hrtc->State = HAL_RTC_STATE_READY;
;;;1224   
;;;1225     /* Process Unlocked */
;;;1226     __HAL_UNLOCK(hrtc);
;;;1227   
;;;1228     return HAL_OK;
;;;1229   }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L13.30|
00001e  2001              MOVS     r0,#1                 ;1073
000020  7720              STRB     r0,[r4,#0x1c]         ;1073
000022  bf00              NOP                            ;1073
000024  2002              MOVS     r0,#2                 ;1075
000026  7760              STRB     r0,[r4,#0x1d]         ;1075
000028  bb46              CBNZ     r6,|L13.124|
00002a  6820              LDR      r0,[r4,#0]            ;1079
00002c  6880              LDR      r0,[r0,#8]            ;1079
00002e  f0000040          AND      r0,r0,#0x40           ;1079
000032  b100              CBZ      r0,|L13.54|
000034  e002              B        |L13.60|
                  |L13.54|
000036  2000              MOVS     r0,#0                 ;1086
000038  70e8              STRB     r0,[r5,#3]            ;1086
00003a  bf00              NOP                            ;1087
                  |L13.60|
00003c  69e8              LDR      r0,[r5,#0x1c]         ;1092
00003e  b900              CBNZ     r0,|L13.66|
000040  e000              B        |L13.68|
                  |L13.66|
000042  bf00              NOP                            ;1098
                  |L13.68|
000044  7828              LDRB     r0,[r5,#0]            ;1101
000046  f7fffffe          BL       RTC_ByteToBcd2
00004a  0403              LSLS     r3,r0,#16             ;1101
00004c  7868              LDRB     r0,[r5,#1]            ;1101
00004e  f7fffffe          BL       RTC_ByteToBcd2
000052  ea432300          ORR      r3,r3,r0,LSL #8       ;1101
000056  78a8              LDRB     r0,[r5,#2]            ;1101
000058  f7fffffe          BL       RTC_ByteToBcd2
00005c  4303              ORRS     r3,r3,r0              ;1101
00005e  78e8              LDRB     r0,[r5,#3]            ;1101
000060  ea434300          ORR      r3,r3,r0,LSL #16      ;1101
000064  f8950020          LDRB     r0,[r5,#0x20]         ;1101
000068  f7fffffe          BL       RTC_ByteToBcd2
00006c  ea436000          ORR      r0,r3,r0,LSL #24      ;1101
000070  69e9              LDR      r1,[r5,#0x1c]         ;1101
000072  4308              ORRS     r0,r0,r1              ;1101
000074  6969              LDR      r1,[r5,#0x14]         ;1101
000076  ea400801          ORR      r8,r0,r1              ;1101
00007a  e01f              B        |L13.188|
                  |L13.124|
00007c  6820              LDR      r0,[r4,#0]            ;1111
00007e  6880              LDR      r0,[r0,#8]            ;1111
000080  f0000040          AND      r0,r0,#0x40           ;1111
000084  b100              CBZ      r0,|L13.136|
000086  e002              B        |L13.142|
                  |L13.136|
000088  2000              MOVS     r0,#0                 ;1118
00008a  70e8              STRB     r0,[r5,#3]            ;1118
00008c  bf00              NOP                            ;1119
                  |L13.142|
00008e  69e8              LDR      r0,[r5,#0x1c]         ;1125
000090  b900              CBNZ     r0,|L13.148|
000092  e000              B        |L13.150|
                  |L13.148|
000094  bf00              NOP                            ;1131
                  |L13.150|
000096  7828              LDRB     r0,[r5,#0]            ;1134
000098  0400              LSLS     r0,r0,#16             ;1134
00009a  7869              LDRB     r1,[r5,#1]            ;1134
00009c  ea402001          ORR      r0,r0,r1,LSL #8       ;1134
0000a0  78a9              LDRB     r1,[r5,#2]            ;1134
0000a2  4308              ORRS     r0,r0,r1              ;1134
0000a4  78e9              LDRB     r1,[r5,#3]            ;1134
0000a6  ea404001          ORR      r0,r0,r1,LSL #16      ;1134
0000aa  f8951020          LDRB     r1,[r5,#0x20]         ;1134
0000ae  ea406001          ORR      r0,r0,r1,LSL #24      ;1134
0000b2  69e9              LDR      r1,[r5,#0x1c]         ;1134
0000b4  4308              ORRS     r0,r0,r1              ;1134
0000b6  6969              LDR      r1,[r5,#0x14]         ;1134
0000b8  ea400801          ORR      r8,r0,r1              ;1134
                  |L13.188|
0000bc  69a9              LDR      r1,[r5,#0x18]         ;1144
0000be  6868              LDR      r0,[r5,#4]            ;1144
0000c0  ea400901          ORR      r9,r0,r1              ;1144
0000c4  bf00              NOP                            ;1147
0000c6  20ca              MOVS     r0,#0xca              ;1147
0000c8  6821              LDR      r1,[r4,#0]            ;1147
0000ca  6248              STR      r0,[r1,#0x24]         ;1147
0000cc  2053              MOVS     r0,#0x53              ;1147
0000ce  6821              LDR      r1,[r4,#0]            ;1147
0000d0  6248              STR      r0,[r1,#0x24]         ;1147
0000d2  bf00              NOP                            ;1147
0000d4  6a68              LDR      r0,[r5,#0x24]         ;1150
0000d6  f5b07f80          CMP      r0,#0x100             ;1150
0000da  d135              BNE      |L13.328|
0000dc  6820              LDR      r0,[r4,#0]            ;1153
0000de  6880              LDR      r0,[r0,#8]            ;1153
0000e0  f4207080          BIC      r0,r0,#0x100          ;1153
0000e4  6821              LDR      r1,[r4,#0]            ;1153
0000e6  6088              STR      r0,[r1,#8]            ;1153
0000e8  6820              LDR      r0,[r4,#0]            ;1156
0000ea  6880              LDR      r0,[r0,#8]            ;1156
0000ec  f4205080          BIC      r0,r0,#0x1000         ;1156
0000f0  6821              LDR      r1,[r4,#0]            ;1156
0000f2  6088              STR      r0,[r1,#8]            ;1156
0000f4  f7fffffe          BL       HAL_GetTick
0000f8  4607              MOV      r7,r0                 ;1159
0000fa  e012              B        |L13.290|
                  |L13.252|
0000fc  f7fffffe          BL       HAL_GetTick
000100  1bc0              SUBS     r0,r0,r7              ;1164
000102  f5b07f7a          CMP      r0,#0x3e8             ;1164
000106  d90c              BLS      |L13.290|
000108  bf00              NOP                            ;1167
00010a  20ff              MOVS     r0,#0xff              ;1167
00010c  6821              LDR      r1,[r4,#0]            ;1167
00010e  6248              STR      r0,[r1,#0x24]         ;1167
000110  bf00              NOP                            ;1167
000112  2003              MOVS     r0,#3                 ;1169
000114  7760              STRB     r0,[r4,#0x1d]         ;1169
000116  bf00              NOP                            ;1172
000118  2000              MOVS     r0,#0                 ;1172
00011a  7720              STRB     r0,[r4,#0x1c]         ;1172
00011c  bf00              NOP                            ;1172
00011e  2003              MOVS     r0,#3                 ;1174
000120  e77b              B        |L13.26|
                  |L13.290|
000122  6820              LDR      r0,[r4,#0]            ;1162
000124  68c0              LDR      r0,[r0,#0xc]          ;1162
000126  f0000001          AND      r0,r0,#1              ;1162
00012a  2800              CMP      r0,#0                 ;1162
00012c  d0e6              BEQ      |L13.252|
00012e  6820              LDR      r0,[r4,#0]            ;1178
000130  f8c0801c          STR      r8,[r0,#0x1c]         ;1178
000134  6820              LDR      r0,[r4,#0]            ;1180
000136  f8c09044          STR      r9,[r0,#0x44]         ;1180
00013a  6820              LDR      r0,[r4,#0]            ;1182
00013c  6880              LDR      r0,[r0,#8]            ;1182
00013e  f4407080          ORR      r0,r0,#0x100          ;1182
000142  6821              LDR      r1,[r4,#0]            ;1182
000144  6088              STR      r0,[r1,#8]            ;1182
000146  e034              B        |L13.434|
                  |L13.328|
000148  6820              LDR      r0,[r4,#0]            ;1187
00014a  6880              LDR      r0,[r0,#8]            ;1187
00014c  f4207000          BIC      r0,r0,#0x200          ;1187
000150  6821              LDR      r1,[r4,#0]            ;1187
000152  6088              STR      r0,[r1,#8]            ;1187
000154  6820              LDR      r0,[r4,#0]            ;1190
000156  6880              LDR      r0,[r0,#8]            ;1190
000158  f4205000          BIC      r0,r0,#0x2000         ;1190
00015c  6821              LDR      r1,[r4,#0]            ;1190
00015e  6088              STR      r0,[r1,#8]            ;1190
000160  f7fffffe          BL       HAL_GetTick
000164  4607              MOV      r7,r0                 ;1193
000166  e012              B        |L13.398|
                  |L13.360|
000168  f7fffffe          BL       HAL_GetTick
00016c  1bc0              SUBS     r0,r0,r7              ;1198
00016e  f5b07f7a          CMP      r0,#0x3e8             ;1198
000172  d90c              BLS      |L13.398|
000174  bf00              NOP                            ;1201
000176  20ff              MOVS     r0,#0xff              ;1201
000178  6821              LDR      r1,[r4,#0]            ;1201
00017a  6248              STR      r0,[r1,#0x24]         ;1201
00017c  bf00              NOP                            ;1201
00017e  2003              MOVS     r0,#3                 ;1203
000180  7760              STRB     r0,[r4,#0x1d]         ;1203
000182  bf00              NOP                            ;1206
000184  2000              MOVS     r0,#0                 ;1206
000186  7720              STRB     r0,[r4,#0x1c]         ;1206
000188  bf00              NOP                            ;1206
00018a  2003              MOVS     r0,#3                 ;1208
00018c  e745              B        |L13.26|
                  |L13.398|
00018e  6820              LDR      r0,[r4,#0]            ;1196
000190  68c0              LDR      r0,[r0,#0xc]          ;1196
000192  f3c00040          UBFX     r0,r0,#1,#1           ;1196
000196  2800              CMP      r0,#0                 ;1196
000198  d0e6              BEQ      |L13.360|
00019a  6820              LDR      r0,[r4,#0]            ;1212
00019c  f8c08020          STR      r8,[r0,#0x20]         ;1212
0001a0  6820              LDR      r0,[r4,#0]            ;1214
0001a2  f8c09048          STR      r9,[r0,#0x48]         ;1214
0001a6  6820              LDR      r0,[r4,#0]            ;1216
0001a8  6880              LDR      r0,[r0,#8]            ;1216
0001aa  f4407000          ORR      r0,r0,#0x200          ;1216
0001ae  6821              LDR      r1,[r4,#0]            ;1216
0001b0  6088              STR      r0,[r1,#8]            ;1216
                  |L13.434|
0001b2  bf00              NOP                            ;1220
0001b4  20ff              MOVS     r0,#0xff              ;1220
0001b6  6821              LDR      r1,[r4,#0]            ;1220
0001b8  6248              STR      r0,[r1,#0x24]         ;1220
0001ba  bf00              NOP                            ;1220
0001bc  2001              MOVS     r0,#1                 ;1223
0001be  7760              STRB     r0,[r4,#0x1d]         ;1223
0001c0  bf00              NOP                            ;1226
0001c2  2000              MOVS     r0,#0                 ;1226
0001c4  7720              STRB     r0,[r4,#0x1c]         ;1226
0001c6  bf00              NOP                            ;1226
0001c8  bf00              NOP                            ;1228
0001ca  e726              B        |L13.26|
;;;1230   
                          ENDP


                          AREA ||i.HAL_RTC_SetAlarm_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetAlarm_IT PROC
;;;1241     */
;;;1242   HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d41f8          PUSH     {r3-r8,lr}
;;;1243   {
000004  4603              MOV      r3,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1244     uint32_t tmpreg = 0U, subsecondtmpreg = 0U;
00000a  2600              MOVS     r6,#0
00000c  2700              MOVS     r7,#0
;;;1245     __IO uint32_t count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U) ;
00000e  487c              LDR      r0,|L14.512|
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  0940              LSRS     r0,r0,#5
000014  f44f717a          MOV      r1,#0x3e8
000018  fbb0f0f1          UDIV     r0,r0,r1
00001c  4348              MULS     r0,r1,r0
00001e  9000              STR      r0,[sp,#0]
;;;1246   
;;;1247     /* Check the parameters */
;;;1248     assert_param(IS_RTC_FORMAT(Format));
;;;1249     assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;1250     assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
;;;1251     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
;;;1252     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
;;;1253     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
;;;1254   
;;;1255     /* Process Locked */
;;;1256     __HAL_LOCK(hrtc);
000020  bf00              NOP      
000022  7f18              LDRB     r0,[r3,#0x1c]
000024  2801              CMP      r0,#1
000026  d102              BNE      |L14.46|
000028  2002              MOVS     r0,#2
                  |L14.42|
;;;1257   
;;;1258     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1259   
;;;1260     if(Format == RTC_FORMAT_BIN)
;;;1261     {
;;;1262       if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;1263       {
;;;1264         assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
;;;1265         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1266       }
;;;1267       else
;;;1268       {
;;;1269         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1270         assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;1271       }
;;;1272       assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;1273       assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;1274   
;;;1275       if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1276       {
;;;1277         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
;;;1278       }
;;;1279       else
;;;1280       {
;;;1281         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
;;;1282       }
;;;1283       tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
;;;1284                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
;;;1285                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
;;;1286                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
;;;1287                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
;;;1288                 ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
;;;1289                 ((uint32_t)sAlarm->AlarmMask));
;;;1290     }
;;;1291     else
;;;1292     {
;;;1293       if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;1294       {
;;;1295         assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1296         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1297       }
;;;1298       else
;;;1299       {
;;;1300         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1301         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1302       }
;;;1303   
;;;1304       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1305       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1306   
;;;1307       if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1308       {
;;;1309         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1310       }
;;;1311       else
;;;1312       {
;;;1313         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1314       }
;;;1315       tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
;;;1316                 ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
;;;1317                 ((uint32_t) sAlarm->AlarmTime.Seconds) | \
;;;1318                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
;;;1319                 ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
;;;1320                 ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
;;;1321                 ((uint32_t)sAlarm->AlarmMask));
;;;1322     }
;;;1323     /* Configure the Alarm A or Alarm B Sub Second registers */
;;;1324     subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
;;;1325   
;;;1326     /* Disable the write protection for RTC registers */
;;;1327     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1328   
;;;1329     /* Configure the Alarm register */
;;;1330     if(sAlarm->Alarm == RTC_ALARM_A)
;;;1331     {
;;;1332       /* Disable the Alarm A interrupt */
;;;1333       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;1334   
;;;1335       /* Clear flag alarm A */
;;;1336       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1337   
;;;1338       /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
;;;1339       do
;;;1340       {
;;;1341         if (count-- == 0U)
;;;1342         {
;;;1343           /* Enable the write protection for RTC registers */
;;;1344           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1345   
;;;1346           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1347   
;;;1348           /* Process Unlocked */
;;;1349           __HAL_UNLOCK(hrtc);
;;;1350   
;;;1351           return HAL_TIMEOUT;
;;;1352         }
;;;1353       }
;;;1354       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET);
;;;1355   
;;;1356       hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
;;;1357       /* Configure the Alarm A Sub Second register */
;;;1358       hrtc->Instance->ALRMASSR = subsecondtmpreg;
;;;1359       /* Configure the Alarm state: Enable Alarm */
;;;1360       __HAL_RTC_ALARMA_ENABLE(hrtc);
;;;1361       /* Configure the Alarm interrupt */
;;;1362       __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
;;;1363     }
;;;1364     else
;;;1365     {
;;;1366       /* Disable the Alarm B interrupt */
;;;1367       __HAL_RTC_ALARMB_DISABLE(hrtc);
;;;1368   
;;;1369       /* Clear flag alarm B */
;;;1370       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
;;;1371   
;;;1372       /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
;;;1373       do
;;;1374       {
;;;1375         if (count-- == 0U)
;;;1376         {
;;;1377           /* Enable the write protection for RTC registers */
;;;1378           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1379   
;;;1380           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1381   
;;;1382           /* Process Unlocked */
;;;1383           __HAL_UNLOCK(hrtc);
;;;1384   
;;;1385           return HAL_TIMEOUT;
;;;1386         }
;;;1387       }
;;;1388       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET);
;;;1389   
;;;1390       hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
;;;1391       /* Configure the Alarm B Sub Second register */
;;;1392       hrtc->Instance->ALRMBSSR = subsecondtmpreg;
;;;1393       /* Configure the Alarm state: Enable Alarm */
;;;1394       __HAL_RTC_ALARMB_ENABLE(hrtc);
;;;1395       /* Configure the Alarm interrupt */
;;;1396       __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
;;;1397     }
;;;1398   
;;;1399     /* RTC Alarm Interrupt Configuration: EXTI configuration */
;;;1400     __HAL_RTC_ALARM_EXTI_ENABLE_IT();
;;;1401   
;;;1402     EXTI->RTSR |= RTC_EXTI_LINE_ALARM_EVENT;
;;;1403   
;;;1404     /* Enable the write protection for RTC registers */
;;;1405     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1406   
;;;1407     hrtc->State = HAL_RTC_STATE_READY;
;;;1408   
;;;1409     /* Process Unlocked */
;;;1410     __HAL_UNLOCK(hrtc);
;;;1411   
;;;1412     return HAL_OK;
;;;1413   }
00002a  e8bd81f8          POP      {r3-r8,pc}
                  |L14.46|
00002e  2001              MOVS     r0,#1                 ;1256
000030  7718              STRB     r0,[r3,#0x1c]         ;1256
000032  bf00              NOP                            ;1256
000034  2002              MOVS     r0,#2                 ;1258
000036  7758              STRB     r0,[r3,#0x1d]         ;1258
000038  bb55              CBNZ     r5,|L14.144|
00003a  6818              LDR      r0,[r3,#0]            ;1262
00003c  6880              LDR      r0,[r0,#8]            ;1262
00003e  f0000040          AND      r0,r0,#0x40           ;1262
000042  b100              CBZ      r0,|L14.70|
000044  e002              B        |L14.76|
                  |L14.70|
000046  2000              MOVS     r0,#0                 ;1269
000048  70e0              STRB     r0,[r4,#3]            ;1269
00004a  bf00              NOP                            ;1270
                  |L14.76|
00004c  69e0              LDR      r0,[r4,#0x1c]         ;1275
00004e  b900              CBNZ     r0,|L14.82|
000050  e000              B        |L14.84|
                  |L14.82|
000052  bf00              NOP                            ;1281
                  |L14.84|
000054  7820              LDRB     r0,[r4,#0]            ;1283
000056  f7fffffe          BL       RTC_ByteToBcd2
00005a  ea4f4800          LSL      r8,r0,#16             ;1283
00005e  7860              LDRB     r0,[r4,#1]            ;1283
000060  f7fffffe          BL       RTC_ByteToBcd2
000064  ea482800          ORR      r8,r8,r0,LSL #8       ;1283
000068  78a0              LDRB     r0,[r4,#2]            ;1283
00006a  f7fffffe          BL       RTC_ByteToBcd2
00006e  ea480800          ORR      r8,r8,r0              ;1283
000072  78e0              LDRB     r0,[r4,#3]            ;1283
000074  ea484800          ORR      r8,r8,r0,LSL #16      ;1283
000078  f8940020          LDRB     r0,[r4,#0x20]         ;1283
00007c  f7fffffe          BL       RTC_ByteToBcd2
000080  ea486000          ORR      r0,r8,r0,LSL #24      ;1283
000084  69e1              LDR      r1,[r4,#0x1c]         ;1283
000086  4308              ORRS     r0,r0,r1              ;1283
000088  6961              LDR      r1,[r4,#0x14]         ;1283
00008a  ea400601          ORR      r6,r0,r1              ;1283
00008e  e01f              B        |L14.208|
                  |L14.144|
000090  6818              LDR      r0,[r3,#0]            ;1293
000092  6880              LDR      r0,[r0,#8]            ;1293
000094  f0000040          AND      r0,r0,#0x40           ;1293
000098  b100              CBZ      r0,|L14.156|
00009a  e002              B        |L14.162|
                  |L14.156|
00009c  2000              MOVS     r0,#0                 ;1300
00009e  70e0              STRB     r0,[r4,#3]            ;1300
0000a0  bf00              NOP                            ;1301
                  |L14.162|
0000a2  69e0              LDR      r0,[r4,#0x1c]         ;1307
0000a4  b900              CBNZ     r0,|L14.168|
0000a6  e000              B        |L14.170|
                  |L14.168|
0000a8  bf00              NOP                            ;1313
                  |L14.170|
0000aa  7820              LDRB     r0,[r4,#0]            ;1315
0000ac  0400              LSLS     r0,r0,#16             ;1315
0000ae  7861              LDRB     r1,[r4,#1]            ;1315
0000b0  ea402001          ORR      r0,r0,r1,LSL #8       ;1315
0000b4  78a1              LDRB     r1,[r4,#2]            ;1315
0000b6  4308              ORRS     r0,r0,r1              ;1315
0000b8  78e1              LDRB     r1,[r4,#3]            ;1315
0000ba  ea404001          ORR      r0,r0,r1,LSL #16      ;1315
0000be  f8941020          LDRB     r1,[r4,#0x20]         ;1315
0000c2  ea406001          ORR      r0,r0,r1,LSL #24      ;1315
0000c6  69e1              LDR      r1,[r4,#0x1c]         ;1315
0000c8  4308              ORRS     r0,r0,r1              ;1315
0000ca  6961              LDR      r1,[r4,#0x14]         ;1315
0000cc  ea400601          ORR      r6,r0,r1              ;1315
                  |L14.208|
0000d0  69a1              LDR      r1,[r4,#0x18]         ;1324
0000d2  6860              LDR      r0,[r4,#4]            ;1324
0000d4  ea400701          ORR      r7,r0,r1              ;1324
0000d8  bf00              NOP                            ;1327
0000da  20ca              MOVS     r0,#0xca              ;1327
0000dc  6819              LDR      r1,[r3,#0]            ;1327
0000de  6248              STR      r0,[r1,#0x24]         ;1327
0000e0  2053              MOVS     r0,#0x53              ;1327
0000e2  6819              LDR      r1,[r3,#0]            ;1327
0000e4  6248              STR      r0,[r1,#0x24]         ;1327
0000e6  bf00              NOP                            ;1327
0000e8  6a60              LDR      r0,[r4,#0x24]         ;1330
0000ea  f5b07f80          CMP      r0,#0x100             ;1330
0000ee  d136              BNE      |L14.350|
0000f0  6818              LDR      r0,[r3,#0]            ;1333
0000f2  6880              LDR      r0,[r0,#8]            ;1333
0000f4  f4207080          BIC      r0,r0,#0x100          ;1333
0000f8  6819              LDR      r1,[r3,#0]            ;1333
0000fa  6088              STR      r0,[r1,#8]            ;1333
0000fc  6818              LDR      r0,[r3,#0]            ;1336
0000fe  68c0              LDR      r0,[r0,#0xc]          ;1336
000100  f0000080          AND      r0,r0,#0x80           ;1336
000104  f46070c0          ORN      r0,r0,#0x180          ;1336
000108  6819              LDR      r1,[r3,#0]            ;1336
00010a  60c8              STR      r0,[r1,#0xc]          ;1336
00010c  bf00              NOP                            ;1339
                  |L14.270|
00010e  9800              LDR      r0,[sp,#0]            ;1341
000110  1e41              SUBS     r1,r0,#1              ;1341
000112  9100              STR      r1,[sp,#0]            ;1341
000114  b960              CBNZ     r0,|L14.304|
000116  bf00              NOP                            ;1344
000118  20ff              MOVS     r0,#0xff              ;1344
00011a  6819              LDR      r1,[r3,#0]            ;1344
00011c  6248              STR      r0,[r1,#0x24]         ;1344
00011e  bf00              NOP                            ;1344
000120  2003              MOVS     r0,#3                 ;1346
000122  7758              STRB     r0,[r3,#0x1d]         ;1346
000124  bf00              NOP                            ;1349
000126  2000              MOVS     r0,#0                 ;1349
000128  7718              STRB     r0,[r3,#0x1c]         ;1349
00012a  bf00              NOP                            ;1349
00012c  2003              MOVS     r0,#3                 ;1351
00012e  e77c              B        |L14.42|
                  |L14.304|
000130  6818              LDR      r0,[r3,#0]            ;1354
000132  68c0              LDR      r0,[r0,#0xc]          ;1354
000134  f0000001          AND      r0,r0,#1              ;1354
000138  2800              CMP      r0,#0                 ;1354
00013a  d0e8              BEQ      |L14.270|
00013c  6818              LDR      r0,[r3,#0]            ;1356
00013e  61c6              STR      r6,[r0,#0x1c]         ;1356
000140  6818              LDR      r0,[r3,#0]            ;1358
000142  6447              STR      r7,[r0,#0x44]         ;1358
000144  6818              LDR      r0,[r3,#0]            ;1360
000146  6880              LDR      r0,[r0,#8]            ;1360
000148  f4407080          ORR      r0,r0,#0x100          ;1360
00014c  6819              LDR      r1,[r3,#0]            ;1360
00014e  6088              STR      r0,[r1,#8]            ;1360
000150  6818              LDR      r0,[r3,#0]            ;1362
000152  6880              LDR      r0,[r0,#8]            ;1362
000154  f4405080          ORR      r0,r0,#0x1000         ;1362
000158  6819              LDR      r1,[r3,#0]            ;1362
00015a  6088              STR      r0,[r1,#8]            ;1362
00015c  e035              B        |L14.458|
                  |L14.350|
00015e  6818              LDR      r0,[r3,#0]            ;1367
000160  6880              LDR      r0,[r0,#8]            ;1367
000162  f4207000          BIC      r0,r0,#0x200          ;1367
000166  6819              LDR      r1,[r3,#0]            ;1367
000168  6088              STR      r0,[r1,#8]            ;1367
00016a  6818              LDR      r0,[r3,#0]            ;1370
00016c  68c0              LDR      r0,[r0,#0xc]          ;1370
00016e  f0000080          AND      r0,r0,#0x80           ;1370
000172  f4607020          ORN      r0,r0,#0x280          ;1370
000176  6819              LDR      r1,[r3,#0]            ;1370
000178  60c8              STR      r0,[r1,#0xc]          ;1370
00017a  bf00              NOP                            ;1373
                  |L14.380|
00017c  9800              LDR      r0,[sp,#0]            ;1375
00017e  1e41              SUBS     r1,r0,#1              ;1375
000180  9100              STR      r1,[sp,#0]            ;1375
000182  b960              CBNZ     r0,|L14.414|
000184  bf00              NOP                            ;1378
000186  20ff              MOVS     r0,#0xff              ;1378
000188  6819              LDR      r1,[r3,#0]            ;1378
00018a  6248              STR      r0,[r1,#0x24]         ;1378
00018c  bf00              NOP                            ;1378
00018e  2003              MOVS     r0,#3                 ;1380
000190  7758              STRB     r0,[r3,#0x1d]         ;1380
000192  bf00              NOP                            ;1383
000194  2000              MOVS     r0,#0                 ;1383
000196  7718              STRB     r0,[r3,#0x1c]         ;1383
000198  bf00              NOP                            ;1383
00019a  2003              MOVS     r0,#3                 ;1385
00019c  e745              B        |L14.42|
                  |L14.414|
00019e  6818              LDR      r0,[r3,#0]            ;1388
0001a0  68c0              LDR      r0,[r0,#0xc]          ;1388
0001a2  f3c00040          UBFX     r0,r0,#1,#1           ;1388
0001a6  2800              CMP      r0,#0                 ;1388
0001a8  d0e8              BEQ      |L14.380|
0001aa  6818              LDR      r0,[r3,#0]            ;1390
0001ac  6206              STR      r6,[r0,#0x20]         ;1390
0001ae  6818              LDR      r0,[r3,#0]            ;1392
0001b0  6487              STR      r7,[r0,#0x48]         ;1392
0001b2  6818              LDR      r0,[r3,#0]            ;1394
0001b4  6880              LDR      r0,[r0,#8]            ;1394
0001b6  f4407000          ORR      r0,r0,#0x200          ;1394
0001ba  6819              LDR      r1,[r3,#0]            ;1394
0001bc  6088              STR      r0,[r1,#8]            ;1394
0001be  6818              LDR      r0,[r3,#0]            ;1396
0001c0  6880              LDR      r0,[r0,#8]            ;1396
0001c2  f4405000          ORR      r0,r0,#0x2000         ;1396
0001c6  6819              LDR      r1,[r3,#0]            ;1396
0001c8  6088              STR      r0,[r1,#8]            ;1396
                  |L14.458|
0001ca  480e              LDR      r0,|L14.516|
0001cc  6800              LDR      r0,[r0,#0]            ;1400
0001ce  f4403000          ORR      r0,r0,#0x20000        ;1400
0001d2  490c              LDR      r1,|L14.516|
0001d4  6008              STR      r0,[r1,#0]            ;1400
0001d6  480b              LDR      r0,|L14.516|
0001d8  3008              ADDS     r0,r0,#8              ;1402
0001da  6800              LDR      r0,[r0,#0]            ;1402
0001dc  f4403000          ORR      r0,r0,#0x20000        ;1402
0001e0  4908              LDR      r1,|L14.516|
0001e2  3108              ADDS     r1,r1,#8              ;1402
0001e4  6008              STR      r0,[r1,#0]            ;1402
0001e6  bf00              NOP                            ;1405
0001e8  20ff              MOVS     r0,#0xff              ;1405
0001ea  6819              LDR      r1,[r3,#0]            ;1405
0001ec  6248              STR      r0,[r1,#0x24]         ;1405
0001ee  bf00              NOP                            ;1405
0001f0  2001              MOVS     r0,#1                 ;1407
0001f2  7758              STRB     r0,[r3,#0x1d]         ;1407
0001f4  bf00              NOP                            ;1410
0001f6  2000              MOVS     r0,#0                 ;1410
0001f8  7718              STRB     r0,[r3,#0x1c]         ;1410
0001fa  bf00              NOP                            ;1410
0001fc  bf00              NOP                            ;1412
0001fe  e714              B        |L14.42|
;;;1414   
                          ENDP

                  |L14.512|
                          DCD      SystemCoreClock
                  |L14.516|
                          DCD      0x40013c00

                          AREA ||i.HAL_RTC_SetDate||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetDate PROC
;;;893      */
;;;894    HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;895    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;896      uint32_t datetmpreg = 0U;
00000a  2700              MOVS     r7,#0
;;;897    
;;;898     /* Check the parameters */
;;;899      assert_param(IS_RTC_FORMAT(Format));
;;;900    
;;;901     /* Process Locked */
;;;902     __HAL_LOCK(hrtc);
00000c  bf00              NOP      
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L15.26|
000014  2002              MOVS     r0,#2
                  |L15.22|
;;;903    
;;;904      hrtc->State = HAL_RTC_STATE_BUSY;
;;;905    
;;;906      if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
;;;907      {
;;;908        sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
;;;909      }
;;;910    
;;;911      assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));
;;;912    
;;;913      if(Format == RTC_FORMAT_BIN)
;;;914      {
;;;915        assert_param(IS_RTC_YEAR(sDate->Year));
;;;916        assert_param(IS_RTC_MONTH(sDate->Month));
;;;917        assert_param(IS_RTC_DATE(sDate->Date));
;;;918    
;;;919       datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
;;;920                     ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
;;;921                     ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
;;;922                     ((uint32_t)sDate->WeekDay << 13U));
;;;923      }
;;;924      else
;;;925      {
;;;926        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
;;;927        assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
;;;928        assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
;;;929    
;;;930        datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
;;;931                      (((uint32_t)sDate->Month) << 8U) | \
;;;932                      ((uint32_t)sDate->Date) | \
;;;933                      (((uint32_t)sDate->WeekDay) << 13U));
;;;934      }
;;;935    
;;;936      /* Disable the write protection for RTC registers */
;;;937      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;938    
;;;939      /* Set Initialization mode */
;;;940      if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;941      {
;;;942        /* Enable the write protection for RTC registers */
;;;943        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;944    
;;;945        /* Set RTC state*/
;;;946        hrtc->State = HAL_RTC_STATE_ERROR;
;;;947    
;;;948        /* Process Unlocked */
;;;949        __HAL_UNLOCK(hrtc);
;;;950    
;;;951        return HAL_ERROR;
;;;952      }
;;;953      else
;;;954      {
;;;955        /* Set the RTC_DR register */
;;;956        hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
;;;957    
;;;958        /* Exit Initialization mode */
;;;959        hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
;;;960    
;;;961        /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;962        if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
;;;963        {
;;;964          if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;965          {
;;;966            /* Enable the write protection for RTC registers */
;;;967            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;968    
;;;969            hrtc->State = HAL_RTC_STATE_ERROR;
;;;970    
;;;971            /* Process Unlocked */
;;;972            __HAL_UNLOCK(hrtc);
;;;973    
;;;974            return HAL_ERROR;
;;;975          }
;;;976        }
;;;977    
;;;978        /* Enable the write protection for RTC registers */
;;;979        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;980    
;;;981        hrtc->State = HAL_RTC_STATE_READY ;
;;;982    
;;;983        /* Process Unlocked */
;;;984        __HAL_UNLOCK(hrtc);
;;;985    
;;;986        return HAL_OK;
;;;987      }
;;;988    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L15.26|
00001a  2001              MOVS     r0,#1                 ;902
00001c  7720              STRB     r0,[r4,#0x1c]         ;902
00001e  bf00              NOP                            ;902
000020  2002              MOVS     r0,#2                 ;904
000022  7760              STRB     r0,[r4,#0x1d]         ;904
000024  b94e              CBNZ     r6,|L15.58|
000026  7868              LDRB     r0,[r5,#1]            ;906
000028  f0000010          AND      r0,r0,#0x10           ;906
00002c  2810              CMP      r0,#0x10              ;906
00002e  d104              BNE      |L15.58|
000030  7868              LDRB     r0,[r5,#1]            ;908
000032  f00000ef          AND      r0,r0,#0xef           ;908
000036  300a              ADDS     r0,r0,#0xa            ;908
000038  7068              STRB     r0,[r5,#1]            ;908
                  |L15.58|
00003a  b986              CBNZ     r6,|L15.94|
00003c  78e8              LDRB     r0,[r5,#3]            ;919
00003e  f7fffffe          BL       RTC_ByteToBcd2
000042  0403              LSLS     r3,r0,#16             ;919
000044  7868              LDRB     r0,[r5,#1]            ;919
000046  f7fffffe          BL       RTC_ByteToBcd2
00004a  ea432300          ORR      r3,r3,r0,LSL #8       ;919
00004e  78a8              LDRB     r0,[r5,#2]            ;919
000050  f7fffffe          BL       RTC_ByteToBcd2
000054  4303              ORRS     r3,r3,r0              ;919
000056  7828              LDRB     r0,[r5,#0]            ;919
000058  ea433740          ORR      r7,r3,r0,LSL #13      ;919
00005c  e009              B        |L15.114|
                  |L15.94|
00005e  78e8              LDRB     r0,[r5,#3]            ;930
000060  0400              LSLS     r0,r0,#16             ;930
000062  7869              LDRB     r1,[r5,#1]            ;930
000064  ea402001          ORR      r0,r0,r1,LSL #8       ;930
000068  78a9              LDRB     r1,[r5,#2]            ;930
00006a  4308              ORRS     r0,r0,r1              ;930
00006c  7829              LDRB     r1,[r5,#0]            ;930
00006e  ea403741          ORR      r7,r0,r1,LSL #13      ;930
                  |L15.114|
000072  bf00              NOP                            ;937
000074  20ca              MOVS     r0,#0xca              ;937
000076  6821              LDR      r1,[r4,#0]            ;937
000078  6248              STR      r0,[r1,#0x24]         ;937
00007a  2053              MOVS     r0,#0x53              ;937
00007c  6821              LDR      r1,[r4,#0]            ;937
00007e  6248              STR      r0,[r1,#0x24]         ;937
000080  bf00              NOP                            ;937
000082  4620              MOV      r0,r4                 ;940
000084  f7fffffe          BL       RTC_EnterInitMode
000088  b160              CBZ      r0,|L15.164|
00008a  bf00              NOP                            ;943
00008c  20ff              MOVS     r0,#0xff              ;943
00008e  6821              LDR      r1,[r4,#0]            ;943
000090  6248              STR      r0,[r1,#0x24]         ;943
000092  bf00              NOP                            ;943
000094  2004              MOVS     r0,#4                 ;946
000096  7760              STRB     r0,[r4,#0x1d]         ;946
000098  bf00              NOP                            ;949
00009a  2000              MOVS     r0,#0                 ;949
00009c  7720              STRB     r0,[r4,#0x1c]         ;949
00009e  bf00              NOP                            ;949
0000a0  2001              MOVS     r0,#1                 ;951
0000a2  e7b8              B        |L15.22|
                  |L15.164|
0000a4  4816              LDR      r0,|L15.256|
0000a6  4038              ANDS     r0,r0,r7              ;956
0000a8  6821              LDR      r1,[r4,#0]            ;956
0000aa  6048              STR      r0,[r1,#4]            ;956
0000ac  6820              LDR      r0,[r4,#0]            ;959
0000ae  68c0              LDR      r0,[r0,#0xc]          ;959
0000b0  f0200080          BIC      r0,r0,#0x80           ;959
0000b4  6821              LDR      r1,[r4,#0]            ;959
0000b6  60c8              STR      r0,[r1,#0xc]          ;959
0000b8  6820              LDR      r0,[r4,#0]            ;962
0000ba  6880              LDR      r0,[r0,#8]            ;962
0000bc  f0000020          AND      r0,r0,#0x20           ;962
0000c0  b980              CBNZ     r0,|L15.228|
0000c2  4620              MOV      r0,r4                 ;964
0000c4  f7fffffe          BL       HAL_RTC_WaitForSynchro
0000c8  b160              CBZ      r0,|L15.228|
0000ca  bf00              NOP                            ;967
0000cc  20ff              MOVS     r0,#0xff              ;967
0000ce  6821              LDR      r1,[r4,#0]            ;967
0000d0  6248              STR      r0,[r1,#0x24]         ;967
0000d2  bf00              NOP                            ;967
0000d4  2004              MOVS     r0,#4                 ;969
0000d6  7760              STRB     r0,[r4,#0x1d]         ;969
0000d8  bf00              NOP                            ;972
0000da  2000              MOVS     r0,#0                 ;972
0000dc  7720              STRB     r0,[r4,#0x1c]         ;972
0000de  bf00              NOP                            ;972
0000e0  2001              MOVS     r0,#1                 ;974
0000e2  e798              B        |L15.22|
                  |L15.228|
0000e4  bf00              NOP                            ;979
0000e6  20ff              MOVS     r0,#0xff              ;979
0000e8  6821              LDR      r1,[r4,#0]            ;979
0000ea  6248              STR      r0,[r1,#0x24]         ;979
0000ec  bf00              NOP                            ;979
0000ee  2001              MOVS     r0,#1                 ;981
0000f0  7760              STRB     r0,[r4,#0x1d]         ;981
0000f2  bf00              NOP                            ;984
0000f4  2000              MOVS     r0,#0                 ;984
0000f6  7720              STRB     r0,[r4,#0x1c]         ;984
0000f8  bf00              NOP                            ;984
0000fa  bf00              NOP                            ;986
0000fc  e78b              B        |L15.22|
;;;989    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L15.256|
                          DCD      0x00ffff3f

                          AREA ||i.HAL_RTC_SetTime||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetTime PROC
;;;717      */
;;;718    HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;719    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;720      uint32_t tmpreg = 0U;
00000a  2700              MOVS     r7,#0
;;;721    
;;;722     /* Check the parameters */
;;;723      assert_param(IS_RTC_FORMAT(Format));
;;;724      assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
;;;725      assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));
;;;726    
;;;727      /* Process Locked */
;;;728      __HAL_LOCK(hrtc);
00000c  bf00              NOP      
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  2801              CMP      r0,#1
000012  d102              BNE      |L16.26|
000014  2002              MOVS     r0,#2
                  |L16.22|
;;;729    
;;;730      hrtc->State = HAL_RTC_STATE_BUSY;
;;;731    
;;;732      if(Format == RTC_FORMAT_BIN)
;;;733      {
;;;734        if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;735        {
;;;736          assert_param(IS_RTC_HOUR12(sTime->Hours));
;;;737          assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
;;;738        }
;;;739        else
;;;740        {
;;;741          sTime->TimeFormat = 0x00U;
;;;742          assert_param(IS_RTC_HOUR24(sTime->Hours));
;;;743        }
;;;744        assert_param(IS_RTC_MINUTES(sTime->Minutes));
;;;745        assert_param(IS_RTC_SECONDS(sTime->Seconds));
;;;746    
;;;747        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
;;;748                            ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
;;;749                            ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
;;;750                            (((uint32_t)sTime->TimeFormat) << 16U));
;;;751      }
;;;752      else
;;;753      {
;;;754        if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;755        {
;;;756          assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
;;;757          assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
;;;758        }
;;;759        else
;;;760        {
;;;761          sTime->TimeFormat = 0x00U;
;;;762          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
;;;763        }
;;;764        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
;;;765        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
;;;766        tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
;;;767                  ((uint32_t)(sTime->Minutes) << 8U) | \
;;;768                  ((uint32_t)sTime->Seconds) | \
;;;769                  ((uint32_t)(sTime->TimeFormat) << 16U));
;;;770      }
;;;771    
;;;772      /* Disable the write protection for RTC registers */
;;;773      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;774    
;;;775      /* Set Initialization mode */
;;;776      if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;777      {
;;;778        /* Enable the write protection for RTC registers */
;;;779        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;780    
;;;781        /* Set RTC state */
;;;782        hrtc->State = HAL_RTC_STATE_ERROR;
;;;783    
;;;784        /* Process Unlocked */
;;;785        __HAL_UNLOCK(hrtc);
;;;786    
;;;787        return HAL_ERROR;
;;;788      }
;;;789      else
;;;790      {
;;;791        /* Set the RTC_TR register */
;;;792        hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
;;;793    
;;;794        /* Clear the bits to be configured */
;;;795        hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
;;;796    
;;;797        /* Configure the RTC_CR register */
;;;798        hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
;;;799    
;;;800        /* Exit Initialization mode */
;;;801        hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
;;;802    
;;;803        /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;804        if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
;;;805        {
;;;806          if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;807          {
;;;808            /* Enable the write protection for RTC registers */
;;;809            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;810    
;;;811            hrtc->State = HAL_RTC_STATE_ERROR;
;;;812    
;;;813            /* Process Unlocked */
;;;814            __HAL_UNLOCK(hrtc);
;;;815    
;;;816            return HAL_ERROR;
;;;817          }
;;;818        }
;;;819    
;;;820        /* Enable the write protection for RTC registers */
;;;821        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;822    
;;;823       hrtc->State = HAL_RTC_STATE_READY;
;;;824    
;;;825       __HAL_UNLOCK(hrtc);
;;;826    
;;;827       return HAL_OK;
;;;828      }
;;;829    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L16.26|
00001a  2001              MOVS     r0,#1                 ;728
00001c  7720              STRB     r0,[r4,#0x1c]         ;728
00001e  bf00              NOP                            ;728
000020  2002              MOVS     r0,#2                 ;730
000022  7760              STRB     r0,[r4,#0x1d]         ;730
000024  b9ce              CBNZ     r6,|L16.90|
000026  6820              LDR      r0,[r4,#0]            ;734
000028  6880              LDR      r0,[r0,#8]            ;734
00002a  f0000040          AND      r0,r0,#0x40           ;734
00002e  b100              CBZ      r0,|L16.50|
000030  e002              B        |L16.56|
                  |L16.50|
000032  2000              MOVS     r0,#0                 ;741
000034  70e8              STRB     r0,[r5,#3]            ;741
000036  bf00              NOP                            ;742
                  |L16.56|
000038  7828              LDRB     r0,[r5,#0]            ;747
00003a  f7fffffe          BL       RTC_ByteToBcd2
00003e  0403              LSLS     r3,r0,#16             ;747
000040  7868              LDRB     r0,[r5,#1]            ;747
000042  f7fffffe          BL       RTC_ByteToBcd2
000046  ea432300          ORR      r3,r3,r0,LSL #8       ;747
00004a  78a8              LDRB     r0,[r5,#2]            ;747
00004c  f7fffffe          BL       RTC_ByteToBcd2
000050  4303              ORRS     r3,r3,r0              ;747
000052  78e8              LDRB     r0,[r5,#3]            ;747
000054  ea434700          ORR      r7,r3,r0,LSL #16      ;747
000058  e012              B        |L16.128|
                  |L16.90|
00005a  6820              LDR      r0,[r4,#0]            ;754
00005c  6880              LDR      r0,[r0,#8]            ;754
00005e  f0000040          AND      r0,r0,#0x40           ;754
000062  b100              CBZ      r0,|L16.102|
000064  e002              B        |L16.108|
                  |L16.102|
000066  2000              MOVS     r0,#0                 ;761
000068  70e8              STRB     r0,[r5,#3]            ;761
00006a  bf00              NOP                            ;762
                  |L16.108|
00006c  7828              LDRB     r0,[r5,#0]            ;766
00006e  0400              LSLS     r0,r0,#16             ;766
000070  7869              LDRB     r1,[r5,#1]            ;766
000072  ea402001          ORR      r0,r0,r1,LSL #8       ;766
000076  78a9              LDRB     r1,[r5,#2]            ;766
000078  4308              ORRS     r0,r0,r1              ;766
00007a  78e9              LDRB     r1,[r5,#3]            ;766
00007c  ea404701          ORR      r7,r0,r1,LSL #16      ;766
                  |L16.128|
000080  bf00              NOP                            ;773
000082  20ca              MOVS     r0,#0xca              ;773
000084  6821              LDR      r1,[r4,#0]            ;773
000086  6248              STR      r0,[r1,#0x24]         ;773
000088  2053              MOVS     r0,#0x53              ;773
00008a  6821              LDR      r1,[r4,#0]            ;773
00008c  6248              STR      r0,[r1,#0x24]         ;773
00008e  bf00              NOP                            ;773
000090  4620              MOV      r0,r4                 ;776
000092  f7fffffe          BL       RTC_EnterInitMode
000096  b160              CBZ      r0,|L16.178|
000098  bf00              NOP                            ;779
00009a  20ff              MOVS     r0,#0xff              ;779
00009c  6821              LDR      r1,[r4,#0]            ;779
00009e  6248              STR      r0,[r1,#0x24]         ;779
0000a0  bf00              NOP                            ;779
0000a2  2004              MOVS     r0,#4                 ;782
0000a4  7760              STRB     r0,[r4,#0x1d]         ;782
0000a6  bf00              NOP                            ;785
0000a8  2000              MOVS     r0,#0                 ;785
0000aa  7720              STRB     r0,[r4,#0x1c]         ;785
0000ac  bf00              NOP                            ;785
0000ae  2001              MOVS     r0,#1                 ;787
0000b0  e7b1              B        |L16.22|
                  |L16.178|
0000b2  481d              LDR      r0,|L16.296|
0000b4  4038              ANDS     r0,r0,r7              ;792
0000b6  6821              LDR      r1,[r4,#0]            ;792
0000b8  6008              STR      r0,[r1,#0]            ;792
0000ba  6820              LDR      r0,[r4,#0]            ;795
0000bc  6880              LDR      r0,[r0,#8]            ;795
0000be  f4202080          BIC      r0,r0,#0x40000        ;795
0000c2  6821              LDR      r1,[r4,#0]            ;795
0000c4  6088              STR      r0,[r1,#8]            ;795
0000c6  e9d50103          LDRD     r0,r1,[r5,#0xc]       ;798
0000ca  4308              ORRS     r0,r0,r1              ;798
0000cc  6821              LDR      r1,[r4,#0]            ;798
0000ce  6889              LDR      r1,[r1,#8]            ;798
0000d0  4308              ORRS     r0,r0,r1              ;798
0000d2  6821              LDR      r1,[r4,#0]            ;798
0000d4  6088              STR      r0,[r1,#8]            ;798
0000d6  6820              LDR      r0,[r4,#0]            ;801
0000d8  68c0              LDR      r0,[r0,#0xc]          ;801
0000da  f0200080          BIC      r0,r0,#0x80           ;801
0000de  6821              LDR      r1,[r4,#0]            ;801
0000e0  60c8              STR      r0,[r1,#0xc]          ;801
0000e2  6820              LDR      r0,[r4,#0]            ;804
0000e4  6880              LDR      r0,[r0,#8]            ;804
0000e6  f0000020          AND      r0,r0,#0x20           ;804
0000ea  b980              CBNZ     r0,|L16.270|
0000ec  4620              MOV      r0,r4                 ;806
0000ee  f7fffffe          BL       HAL_RTC_WaitForSynchro
0000f2  b160              CBZ      r0,|L16.270|
0000f4  bf00              NOP                            ;809
0000f6  20ff              MOVS     r0,#0xff              ;809
0000f8  6821              LDR      r1,[r4,#0]            ;809
0000fa  6248              STR      r0,[r1,#0x24]         ;809
0000fc  bf00              NOP                            ;809
0000fe  2004              MOVS     r0,#4                 ;811
000100  7760              STRB     r0,[r4,#0x1d]         ;811
000102  bf00              NOP                            ;814
000104  2000              MOVS     r0,#0                 ;814
000106  7720              STRB     r0,[r4,#0x1c]         ;814
000108  bf00              NOP                            ;814
00010a  2001              MOVS     r0,#1                 ;816
00010c  e783              B        |L16.22|
                  |L16.270|
00010e  bf00              NOP                            ;821
000110  20ff              MOVS     r0,#0xff              ;821
000112  6821              LDR      r1,[r4,#0]            ;821
000114  6248              STR      r0,[r1,#0x24]         ;821
000116  bf00              NOP                            ;821
000118  2001              MOVS     r0,#1                 ;823
00011a  7760              STRB     r0,[r4,#0x1d]         ;823
00011c  bf00              NOP                            ;825
00011e  2000              MOVS     r0,#0                 ;825
000120  7720              STRB     r0,[r4,#0x1c]         ;825
000122  bf00              NOP                            ;825
000124  bf00              NOP                            ;827
000126  e776              B        |L16.22|
;;;830    
                          ENDP

                  |L16.296|
                          DCD      0x007f7f7f

                          AREA ||i.HAL_RTC_WaitForSynchro||, CODE, READONLY, ALIGN=1

                  HAL_RTC_WaitForSynchro PROC
;;;1699     */
;;;1700   HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1701   {
000002  4604              MOV      r4,r0
;;;1702     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;1703   
;;;1704     /* Clear RSF flag */
;;;1705     hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f02000a0          BIC      r0,r0,#0xa0
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;1706   
;;;1707       /* Get tick */
;;;1708       tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;1709   
;;;1710     /* Wait the registers to be synchronised */
;;;1711     while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
000018  e007              B        |L17.42|
                  |L17.26|
;;;1712     {
;;;1713       if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b40              SUBS     r0,r0,r5
000020  f5b07f7a          CMP      r0,#0x3e8
000024  d901              BLS      |L17.42|
;;;1714       {
;;;1715         return HAL_TIMEOUT;
000026  2003              MOVS     r0,#3
                  |L17.40|
;;;1716       }
;;;1717     }
;;;1718   
;;;1719     return HAL_OK;
;;;1720   }
000028  bd70              POP      {r4-r6,pc}
                  |L17.42|
00002a  6820              LDR      r0,[r4,#0]            ;1711
00002c  68c0              LDR      r0,[r0,#0xc]          ;1711
00002e  f0000020          AND      r0,r0,#0x20           ;1711
000032  2800              CMP      r0,#0                 ;1711
000034  d0f1              BEQ      |L17.26|
000036  2000              MOVS     r0,#0                 ;1719
000038  e7f6              B        |L17.40|
;;;1721   
                          ENDP


                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;1812     */
;;;1813   uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  4601              MOV      r1,r0
;;;1814   {
;;;1815     uint32_t tmp = 0U;
000002  bf00              NOP      
;;;1816     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000004  0908              LSRS     r0,r1,#4
000006  eb000080          ADD      r0,r0,r0,LSL #2
00000a  0042              LSLS     r2,r0,#1
;;;1817     return (tmp + (Value & (uint8_t)0x0F));
00000c  f001000f          AND      r0,r1,#0xf
000010  4410              ADD      r0,r0,r2
000012  b2c0              UXTB     r0,r0
;;;1818   }
000014  4770              BX       lr
;;;1819   
                          ENDP


                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;1794     */
;;;1795   uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  4601              MOV      r1,r0
;;;1796   {
;;;1797     uint32_t bcdhigh = 0U;
000002  2200              MOVS     r2,#0
;;;1798   
;;;1799     while(Value >= 10U)
000004  e003              B        |L19.14|
                  |L19.6|
;;;1800     {
;;;1801       bcdhigh++;
000006  1c52              ADDS     r2,r2,#1
;;;1802       Value -= 10U;
000008  f1a1000a          SUB      r0,r1,#0xa
00000c  b2c1              UXTB     r1,r0
                  |L19.14|
00000e  290a              CMP      r1,#0xa               ;1799
000010  d2f9              BCS      |L19.6|
;;;1803     }
;;;1804   
;;;1805     return  ((uint8_t)(bcdhigh << 4U) | Value);
000012  0710              LSLS     r0,r2,#28
000014  ea416010          ORR      r0,r1,r0,LSR #24
;;;1806   }
000018  4770              BX       lr
;;;1807   
                          ENDP


                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=1

                  RTC_EnterInitMode PROC
;;;1762     */
;;;1763   HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1764   {
000002  4604              MOV      r4,r0
;;;1765     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;1766   
;;;1767     /* Check if the Initialization mode is set */
;;;1768     if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0000040          AND      r0,r0,#0x40
00000e  b9a0              CBNZ     r0,|L20.58|
;;;1769     {
;;;1770       /* Set the Initialization mode */
;;;1771       hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
000010  1e68              SUBS     r0,r5,#1
000012  6821              LDR      r1,[r4,#0]
000014  60c8              STR      r0,[r1,#0xc]
;;;1772   
;;;1773       /* Get tick */
;;;1774       tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4605              MOV      r5,r0
;;;1775   
;;;1776       /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;1777       while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
00001c  e007              B        |L20.46|
                  |L20.30|
;;;1778       {
;;;1779         if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
00001e  f7fffffe          BL       HAL_GetTick
000022  1b40              SUBS     r0,r0,r5
000024  f5b07f7a          CMP      r0,#0x3e8
000028  d901              BLS      |L20.46|
;;;1780         {
;;;1781           return HAL_TIMEOUT;
00002a  2003              MOVS     r0,#3
                  |L20.44|
;;;1782         }
;;;1783       }
;;;1784     }
;;;1785   
;;;1786     return HAL_OK;
;;;1787   }
00002c  bd70              POP      {r4-r6,pc}
                  |L20.46|
00002e  6820              LDR      r0,[r4,#0]            ;1777
000030  68c0              LDR      r0,[r0,#0xc]          ;1777
000032  f0000040          AND      r0,r0,#0x40           ;1777
000036  2800              CMP      r0,#0                 ;1777
000038  d0f1              BEQ      |L20.30|
                  |L20.58|
00003a  2000              MOVS     r0,#0                 ;1786
00003c  e7f6              B        |L20.44|
;;;1788   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_rtc_c_c7052556____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_rtc_c_c7052556____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_rtc_c_c7052556____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_rtc_c_c7052556____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_rtc_c_c7052556____RRX|
#line 587
|__asm___19_stm32f4xx_hal_rtc_c_c7052556____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
